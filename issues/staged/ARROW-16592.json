{
    "issue": {
        "title": "[FlightRPC][Python] Regression in DoPut error handling",
        "body": "***Note**: This issue was originally created as [ARROW-16592](https://issues.apache.org/jira/browse/ARROW-16592). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nIn PyArrow 8.0.0, any error raised while handling DoPut on the server results in FlightInternalError on the client.\r\n\r\nIn PyArrow 7.0.0, errors raised while handling DoPut are propagated/converted to non-internal errors.\r\n\r\n\u2014\r\n\r\nExample: on 7.0.0, raising FlightCancelledError while handling DoPut on the server would propagate that error including extra_info all the way to the FlightClient. This is not the case anymore on 8.0.0.\r\n\r\nThe FlightInternalError contains extra detail that is derived from the cancelled error though:\r\n```java\n\r\n/arrow/cpp/src/arrow/flight/client.cc:363: Close() failed: IOError: <error message from FlightError is here>. Detail: Cancelled. gRPC client debug context: {\"created\":\"@1652777650.446052211\",\"description\":\"Error received from peer ipv4:127.0.0.1:16001\",\"file\":\"/opt/vcpkg/buildtrees/grpc/src/85a295989c-6cf7bf442d.clean/src/core/lib/surface/call.cc\",\"file_line\":903,\"grpc_message\":\"<error message from FlightError is here>. Detail: Cancelled\",\"grpc_status\":1}. Client context: OK. Detail: Cancelled\r\n \n```\r\nNote: skimming through the code, it seems this problem is not unique to PyArrow.",
        "created_at": "2022-05-17T08:58:11.000Z",
        "updated_at": "2022-05-27T03:23:39.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: FlightRPC",
            "Component: Python",
            "Type: bug"
        ],
        "closed": true,
        "closed_at": "2022-05-27T03:23:39.000Z"
    },
    "comments": [
        {
            "created_at": "2022-05-17T14:38:20.561Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16592?focusedCommentId=17538239) by David Li (lidavidm):*\nCan you provide a reproduction? This still works:\r\n\r\n```python\n\r\nimport traceback\r\nimport pyarrow as pa\r\nimport pyarrow.flight as flight\r\n\r\nclass Server(flight.FlightServerBase):\r\n    def do_put(self, context, descriptor, reader, writer):\r\n        raise flight.FlightCancelledError(\"foo\", extra_info=b\"bar\")\r\n\r\n\r\nprint(\"PyArrow version:\", pa.__version__)\r\nserver = Server(\"grpc://localhost:0\")\r\nclient = flight.connect(f\"grpc://localhost:{server.port}\")\r\n\r\nschema = pa.schema([(\"a\", pa.int64())])\r\nwriter, reader = client.do_put(flight.FlightDescriptor.for_command(b\"\"), schema)\r\ntry:\r\n    writer.write_batch(pa.record_batch([[1]], schema=schema))\r\n    writer.close()\r\nexcept flight.FlightError as e:\r\n    traceback.print_exc()\r\n    print(e.extra_info)\r\nexcept Exception:\r\n    traceback.print_exc()\r\n```\r\n\r\n```\n\r\nPyArrow version: 8.0.0\r\nTraceback (most recent call last):\r\n  File \"/home/lidavidm/Code/upstream/arrow-16592/test.py\", line 18, in <module>\r\n    writer.close()\r\n  File \"pyarrow/_flight.pyx\", line 1031, in pyarrow._flight.MetadataRecordBatchWriter.close\r\n  File \"pyarrow/_flight.pyx\", line 64, in pyarrow._flight.check_flight_status\r\npyarrow._flight.FlightCancelledError: foo. Detail: Cancelled. gRPC client debug context: {\"created\":\"@1652798292.507666326\",\"description\":\"Error received from peer ipv4:127.0.0.1:42099\",\"file\":\"/home/conda/feedstock_root/build_artifacts/grpc-cpp_1651922392722/work/src/core/lib/surface/call.cc\",\"file_line\":1074,\"grpc_message\":\"foo. Detail: Cancelled\",\"grpc_status\":1}. Client context: OK\r\nb'bar'\r\n```"
        },
        {
            "created_at": "2022-05-17T15:06:32.101Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16592?focusedCommentId=17538267) by David Li (lidavidm):*\nOk, hmm, I can see this happen with the log message if I tweak things and run this enough. But that's not an exception handled in Python code, that's a warning letting you know that  you should call `writer.close()` or use the writer as a context manager."
        },
        {
            "created_at": "2022-05-17T18:02:07.545Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16592?focusedCommentId=17538370) by Lubo Slivka (lupko):*\n`[~lidavidm]` thanks for looking into it. Let me investigate on my end - the my server has some extra 'hoops' and additional threads involved in handling the call. perhaps that is the diff. will keep you posted."
        },
        {
            "created_at": "2022-05-17T19:59:59.729Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16592?focusedCommentId=17538437) by Lubo Slivka (lupko):*\nHi `[~lidavidm]` , this was fun, I was trying many things left and right to extend the barebone reproducer with extra embellishments of my impl. No luck.\r\n\r\nSo then I tried sending same data that I'm using for my tests to your code above, and hit the internal error. Trying to narrow it down for your testcase, I got the following reproducer (the only diff from your code is the loop to write the batches):\r\n```java\n\r\nimport traceback\r\nimport pyarrow as pa\r\nimport pyarrow.flight as flight\r\n\r\n\r\nclass Server(flight.FlightServerBase):\r\n    def do_put(self, context, descriptor, reader, writer):\r\n        raise flight.FlightCancelledError(\"foo\", extra_info=b\"bar\")\r\n\r\n\r\nprint(\"PyArrow version:\", pa.__version__)\r\nserver = Server(\"grpc://localhost:0\")\r\nclient = flight.connect(f\"grpc://localhost:{server.port}\")\r\n\r\nschema = pa.schema([(\"a\", pa.int64())])\r\nwriter, reader = client.do_put(flight.FlightDescriptor.for_command(b\"\"), schema)\r\n\r\ntry:\r\n# starts failing at this exact number; before that the error is still cancelled\r\n    for i in range(27061):\r\n# print(f\"write {i}\")\r\n        writer.write_batch(pa.record_batch([[1]], schema=schema))\r\n\r\n    writer.close()\r\nexcept flight.FlightError as e:\r\n    traceback.print_exc()\r\n    print(e.extra_info)\r\nexcept Exception:\r\n    traceback.print_exc() \n```\r\nnote: this may be related to timing or something, if the repro does not work, try bumping the numbers :)\u00a0\r\n\r\nwhat strikes me (and smells like the actual root cause) is that the loop goes on and does not fail after the first write. that looks awkward - could this be the real problem?\r\n\r\nalso note, I originally reproduced this with the test data that I read from CSV into a Table, and then tried doing a single writer.write_table() followed by writer.close().\r\n\r\nif needed, I can provide the test data, it's a sheet generated from tpch model."
        },
        {
            "created_at": "2022-05-17T20:07:03.121Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16592?focusedCommentId=17538443) by David Li (lidavidm):*\nAha. Thank you so much!\r\n\r\nThat reproduces it for me. So what happens is that when writing data, gRPC crucially does not tell you if there was an error or not. It just returns boolean success/failure. (This is because there may be queueing behind the scenes, as far as I understand.) That's also why you can write data \"after\" the failure. \r\n\r\nBefore we just swallowed the error and continued on. Then you would only get the error once you finished \"writing\" (dropping all the data on the floor). Now we don't swallow the error - that's probably inadvertent, since we refactored how things work here. But the error here is \"meaningless\" because gRPC only gives a boolean. You can observe it if you do this:\r\n\r\n```python\n\r\ntry:\r\n# starts failing at this exact number; before that the error is still cancelled\r\n    try:\r\n        for i in range(27061):\r\n# print(f\"write {i}\")\r\n            writer.write_batch(pa.record_batch([[1]], schema=schema))\r\n    except flight.FlightError as e:\r\n        traceback.print_exc()\r\n        print(e.extra_info)\r\n\r\n    writer.close()\r\nexcept flight.FlightError as e:\r\n    traceback.print_exc()\r\n    print(e.extra_info)\r\n```\r\nThe 'real' exception is still there if you call close().\r\n\r\nSo how does Close() get the \"real\" error? gRPC will give the _reader_ side of the bidirectional stream the error. But we can't actually do this inside the writer, because gRPC will crash if two threads try to read the stream at once. Now, we do have a lock. So I think the \"right\" thing to do will be, if we get an error while writing, we need to lock the read side of the stream, drain it, and raise the real error, instead of propagating the \"fake\" error (or swallowing it, which would mean your client could do a lot of unnecessary work before getting the error)."
        },
        {
            "created_at": "2022-05-27T03:23:39.764Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16592?focusedCommentId=17542765) by Yibo Cai (yibocai):*\nIssue resolved by pull request 13191\n<https://github.com/apache/arrow/pull/13191>"
        }
    ]
}