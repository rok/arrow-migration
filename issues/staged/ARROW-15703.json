{
    "issue": {
        "title": "[Java]: Create custom sphinx plugin to help us with java verbose code to showcase highlighting code",
        "body": "***Note**: This issue was originally created as [ARROW-15703](https://issues.apache.org/jira/browse/ARROW-15703). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nWe are running java cookbook code thru sphinx using our custom extension <https://github.com/apache/arrow-cookbook/blob/main/java/ext/javadoctest.py>\u00a0\r\n\r\n\u00a0\r\n\r\nWe need to create another extension to only show our end user the java code that is needed to showcase but running the whole java code cookbook at testing part.\r\n\r\n\u00a0\r\n\r\nCurrent documentation:\r\n```java\n\r\nValidate Delete Data\r\n********************\r\n\r\nAnd confirm that it's been deleted:\r\n\r\n.. testcode::\r\n\r\n    import org.apache.arrow.flight.Action;\r\n    import org.apache.arrow.flight.AsyncPutListener;\r\n    import org.apache.arrow.flight.Criteria;\r\n    import org.apache.arrow.flight.FlightClient;\r\n    import org.apache.arrow.flight.FlightDescriptor;\r\n    import org.apache.arrow.flight.FlightEndpoint;\r\n    import org.apache.arrow.flight.FlightInfo;\r\n    import org.apache.arrow.flight.FlightServer;\r\n    import org.apache.arrow.flight.FlightStream;\r\n    import org.apache.arrow.flight.Location;\r\n    import org.apache.arrow.flight.NoOpFlightProducer;\r\n    import org.apache.arrow.flight.PutResult;\r\n    import org.apache.arrow.flight.Result;\r\n    import org.apache.arrow.flight.Ticket;\r\n    import org.apache.arrow.memory.RootAllocator;\r\n    import org.apache.arrow.vector.VarCharVector;\r\n    import org.apache.arrow.vector.VectorSchemaRoot;\r\n    import org.apache.arrow.vector.VectorUnloader;\r\n    import org.apache.arrow.vector.ipc.message.ArrowRecordBatch;\r\n    import org.apache.arrow.vector.types.pojo.ArrowType;\r\n    import org.apache.arrow.vector.types.pojo.Field;\r\n    import org.apache.arrow.vector.types.pojo.FieldType;\r\n    import org.apache.arrow.vector.types.pojo.Schema;\r\n\r\n    import java.io.IOException;\r\n    import java.nio.charset.StandardCharsets;\r\n    import java.util.ArrayList;\r\n    import java.util.Arrays;\r\n    import java.util.Collections;\r\n    import java.util.HashMap;\r\n    import java.util.Iterator;\r\n    import java.util.List;\r\n    import java.util.Map;\r\n\r\n    class DataInMemory {\r\n        private List<ArrowRecordBatch> listArrowRecordBatch;\r\n        private Schema schema;\r\n        private Long rows;\r\n        public DataInMemory(List<ArrowRecordBatch> listArrowRecordBatch, Schema schema, Long rows) {\r\n            this.listArrowRecordBatch = listArrowRecordBatch;\r\n            this.schema = schema;\r\n            this.rows = rows;\r\n        }\r\n        public List<ArrowRecordBatch> getListArrowRecordBatch() {\r\n            return listArrowRecordBatch;\r\n        }\r\n        public Schema getSchema() {\r\n            return schema;\r\n        }\r\n        public Long getRows() {\r\n            return rows;\r\n        }\r\n    }\r\n\r\n    // Server\r\n    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 33333);\r\n    Map<FlightDescriptor, DataInMemory> dataInMemory = new HashMap<>();\r\n    Map<String, DataInMemory> mapPojoFlightDataInMemory = new HashMap<>();\r\n    List<ArrowRecordBatch> listArrowRecordBatch = new ArrayList<>();\r\n    try (RootAllocator allocator = new RootAllocator(Long.MAX_VALUE)){\r\n        FlightServer flightServer = FlightServer.builder(allocator, location, new NoOpFlightProducer(){\r\n            @Override\r\n            public Runnable acceptPut(CallContext context, FlightStream flightStream, StreamListener<PutResult> ackStream) {\r\n                return () -> {\r\n                    long rows = 0;\r\n                    while (flightStream.next()) {\r\n                        VectorUnloader unloader = new VectorUnloader(flightStream.getRoot());\r\n                        try (final ArrowRecordBatch arb = unloader.getRecordBatch()) {\r\n                            // Retain data information\r\n                            listArrowRecordBatch.add(arb);\r\n                            rows = rows + flightStream.getRoot().getRowCount();\r\n                        }\r\n                    }\r\n                    long finalRows = rows;\r\n                    DataInMemory pojoFlightDataInMemory = new DataInMemory(listArrowRecordBatch, flightStream.getSchema(), finalRows);\r\n                    dataInMemory.put(flightStream.getDescriptor(), pojoFlightDataInMemory);\r\n                    ackStream.onCompleted();\r\n                };\r\n            }\r\n\r\n            @Override\r\n            public void doAction(CallContext context, Action action, StreamListener<Result> listener) {\r\n                FlightDescriptor flightDescriptor = FlightDescriptor.path(new String(action.getBody(), StandardCharsets.UTF_8)); // For recover data for key configured\r\n                if(dataInMemory.containsKey(flightDescriptor)) {\r\n                    switch (action.getType()) {\r\n                        case \"DELETE\":\r\n                            dataInMemory.remove(flightDescriptor);\r\n                            Result result = new Result(\"Delete completed\".getBytes(StandardCharsets.UTF_8));\r\n                            listener.onNext(result);\r\n                    }\r\n                    listener.onCompleted();\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public FlightInfo getFlightInfo(CallContext context, FlightDescriptor descriptor) {\r\n                if(!dataInMemory.containsKey(descriptor)){\r\n                    throw new IllegalStateException(\"Unknown descriptor.\");\r\n                }\r\n                return new FlightInfo(\r\n                        dataInMemory.get(descriptor).getSchema(),\r\n                        descriptor,\r\n                        Collections.singletonList(new FlightEndpoint(new Ticket(descriptor.getPath().get(0).getBytes(StandardCharsets.UTF_8)), location)), // Configure a key to map back and forward your data using Ticket argument\r\n                        allocator.getAllocatedMemory(),\r\n                        dataInMemory.get(descriptor).getRows()\r\n                );\r\n            }\r\n\r\n            @Override\r\n            public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\r\n                dataInMemory.forEach((k, v) -> {\r\n                    FlightInfo flightInfo = getFlightInfo(null, k);\r\n                    listener.onNext(flightInfo);\r\n                    }\r\n                );\r\n                listener.onCompleted();\r\n            }\r\n        }).build();\r\n        try {\r\n            flightServer.start();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    // Client\r\n    try (RootAllocator allocator = new RootAllocator(Long.MAX_VALUE)){\r\n        // Populate data\r\n        FlightClient flightClient = FlightClient.builder(allocator, location).build();\r\n        Schema schema = new Schema(Arrays.asList( new Field(\"name\", FieldType.nullable(new ArrowType.Utf8()), null)));\r\n        VectorSchemaRoot vectorSchemaRoot = VectorSchemaRoot.create(schema, allocator);\r\n        VarCharVector varCharVector = (VarCharVector) vectorSchemaRoot.getVector(\"name\");\r\n        varCharVector.allocateNew(3);\r\n        varCharVector.set(0, \"Ronald\".getBytes());\r\n        varCharVector.set(1, \"David\".getBytes());\r\n        varCharVector.set(2, \"Francisco\".getBytes());\r\n        varCharVector.setValueCount(3);\r\n        vectorSchemaRoot.setRowCount(3);\r\n        FlightClient.ClientStreamListener listener = flightClient.startPut(FlightDescriptor.path(\"profiles\"), vectorSchemaRoot, new AsyncPutListener());\r\n        listener.putNext();\r\n        vectorSchemaRoot.allocateNew();\r\n        varCharVector.set(0, \"Manuel\".getBytes());\r\n        varCharVector.set(1, \"Felipe\".getBytes());\r\n        varCharVector.set(2, \"JJ\".getBytes());\r\n        varCharVector.setValueCount(3);\r\n        vectorSchemaRoot.setRowCount(3);\r\n        listener.putNext();\r\n        vectorSchemaRoot.clear();\r\n        listener.completed();\r\n        listener.getResult();\r\n\r\n        // Do delete action\r\n        Iterator<Result> deleteActionResult = flightClient.doAction(new Action(\"DELETE\", FlightDescriptor.path(\"profiles\").getPath().get(0).getBytes(StandardCharsets.UTF_8) ));\r\n        while(deleteActionResult.hasNext()){\r\n            Result result = deleteActionResult.next();\r\n            System.out.println(\"Do Delete Action: \" + new String(result.getBody(), StandardCharsets.UTF_8));\r\n        }\r\n\r\n        // Get all metadata information\r\n        Iterable<FlightInfo> flightInfos = flightClient.listFlights(Criteria.ALL);\r\n        flightInfos.forEach(t -> System.out.println(t));\r\n        System.out.println(\"List Flights Info (after delete): No records\");\r\n    }\r\n\r\n.. testoutput::\r\n\r\n    Do Delete Action: Delete completed\r\n    List Flights Info (after delete): No records \n```\r\n\u00a0\r\n\r\nHow it could be:\r\n\r\nOnly offer to the user the main code but running behind scene all the code needed\r\n```java\n\r\n// Server\r\n@Override\r\npublic void doAction(CallContext context, Action action, StreamListener<Result> listener) {\r\n    FlightDescriptor flightDescriptor = FlightDescriptor.path(new String(action.getBody(), StandardCharsets.UTF_8)); // For recover data for key configured\r\n    if(dataInMemory.containsKey(flightDescriptor)) {\r\n        switch (action.getType()) {\r\n            case \"DELETE\":\r\n                dataInMemory.remove(flightDescriptor);\r\n                Result result = new Result(\"Delete completed\".getBytes(StandardCharsets.UTF_8));\r\n                listener.onNext(result);\r\n        }\r\n        listener.onCompleted();\r\n    }\r\n}\r\n\r\n// Client\r\n// Do delete action\r\nIterator<Result> deleteActionResult = flightClient.doAction(new Action(\"DELETE\", FlightDescriptor.path(\"profiles\").getPath().get(0).getBytes(StandardCharsets.UTF_8) ));\r\nwhile(deleteActionResult.hasNext()){\r\n    Result result = deleteActionResult.next();\r\n    System.out.println(\"Do Delete Action: \" + new String(result.getBody(), StandardCharsets.UTF_8));\r\n}\r\n\r\n// Get all metadata information\r\nIterable<FlightInfo> flightInfos = flightClient.listFlights(Criteria.ALL);\r\nflightInfos.forEach(t -> System.out.println(t));\r\nSystem.out.println(\"List Flights Info (after delete): No records\");\r\n \n```",
        "created_at": "2022-02-16T15:05:08.000Z",
        "updated_at": "2022-02-23T12:37:44.000Z",
        "labels": [
            "Migrated from Jira",
            "Type: task"
        ],
        "closed": true,
        "closed_at": "2022-02-23T12:37:44.000Z"
    },
    "comments": [
        {
            "created_at": "2022-02-18T15:46:42.398Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15703?focusedCommentId=17494683) by Alessandro Molina (amol-):*\nWe should pay attention to this one. The recipes usually should show all the code they need as they have to be copy/pastable for the user. In general we should spend an extra effort in making the examples as short and minimal as possible but fully shown to the user. If we start hiding pieces it can quickly become confusing for the user and recipes might not work out of the box when copied in user code."
        },
        {
            "created_at": "2022-02-22T13:59:02.570Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15703?focusedCommentId=17496104) by Alessandro Molina (amol-):*\nI think we should defer decision on this until we have gathered more feedbacks on the Cookbook.\r\nUnless there are specific reasons to keep it open I'll close this ticket as won't fix next week."
        }
    ]
}