{
    "issue": {
        "title": "[R] [C++] Handle suffix argument in joins",
        "body": "***Note**: This issue was originally created as [ARROW-14679](https://issues.apache.org/jira/browse/ARROW-14679). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nIf there is a name collision, we need to do something https://github.com/apache/arrow/blob/a3746040d8a3ddb84bab6c7ca4771b6c120e3444/r/R/dplyr-join.R#L31\r\n\r\nA few notes:\r\n- arrow doesn't seem to actually be able to apply the prefixes (I'm getting errors when trying), I couldn't tell if there were tests of this \u2014 I couldn't find any, so I'm not sure if I'm calling this wrong or if it's not working at all.\n- arrow always appends the affixes (where as dplyr only adds them if there is a name collision)\n- arrow only supports prefixes (can we configure this, or ask the clients to provide new names?) in the tests I wrote I've worked around this, but it would be nice to be able to match dplyr/allow things other than prefix\n",
        "created_at": "2021-11-11T18:53:51.000Z",
        "updated_at": "2022-04-18T14:49:25.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Component: R",
            "Type: enhancement"
        ],
        "closed": true,
        "closed_at": "2022-03-21T16:22:08.000Z"
    },
    "comments": [
        {
            "created_at": "2021-11-11T19:39:45.676Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14679?focusedCommentId=17442427) by Jonathan Keane (jonkeane):*\nI've uploaded my tests to show the failures. Feel free to either push changes to this branch, pull these tests into a new branch, or ignore them entirely.\r\n\r\nhttps://github.com/apache/arrow/pull/11682"
        },
        {
            "created_at": "2021-12-01T01:51:01.237Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14679?focusedCommentId=17451465) by Weston Pace (westonpace):*\n`[~jonkeane]` I see a PR with purely R code.  Are C++ changes needed here?"
        },
        {
            "created_at": "2021-12-01T01:51:56.562Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14679?focusedCommentId=17451466) by Weston Pace (westonpace):*\nCC `[~sakras]` `[~michalno]`"
        },
        {
            "created_at": "2021-12-08T14:33:25.982Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14679?focusedCommentId=17455278) by Jonathan Keane (jonkeane):*\n> I see a PR with purely R code. Are C++ changes needed here?\r\n\r\nThe PR only has failing tests. The changes will mostly (all?) need to on the C++ side. Feel free to close that PR and start a new branch, or pull from it (or push to it), whichever is easier!"
        },
        {
            "created_at": "2021-12-30T05:18:45.416Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14679?focusedCommentId=17466688) by Vibhatha Lakmal Abeykoon (vibhatha):*\n`[~jonkeane]` `[~westonpace]` \u00a0\r\nIs the intent here is to match the dplyr R API for joins (left_join, inner_join, ...) match with the Arrow R join APIs?\u00a0\r\n\r\nA note on this, when looking into Pandas (join, merge) and deplyr (join), there is no concept called prefix, they only provide suffix. I guess this is a standard followed. But in our source we have prefixes. Should this be the first thing to fix, use suffix within C++ code instead of prefix and make it available to the other language bindings?\u00a0\r\n\r\nI want to make sure whether I have understood this correctly. For now I went throught the code base and see how it is being done. A related but not a direct issue is that, when we read the output from a join (given that we are using the execplan and a sink node to get the response out), we still have to provide a schema, so no matter which affix we use, the output table will have the name we provide as the schema. It is a bit bothering given that the schema should be sort of inferred with the given input data, but give user an opportunity to project what is needed. It is not clear how to grasp this idea clearly. Or is there a way to do the joins without using the ExecPlan by just calling the kernel (just curious are we exposing this kind of a functionality given an advance user just needs the join kernel and use their own dataflow model to move data among operators). May be I am not 100% familiary with the current approach, but just wanted to make a note about this.\u00a0"
        },
        {
            "created_at": "2021-12-30T18:20:58.719Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14679?focusedCommentId=17466957) by Jonathan Keane (jonkeane):*\n> Is the intent here is to match the dplyr R API for joins (left_join, inner_join, ...) match with the Arrow R join APIs? \r\n\r\nI would like to be able to match the dplyr API if possible. We can deviate from it if we have to for some reason (and we can also do some pre/post processing in R if we need to: e.g. rename columns in a project after the join)\r\n\r\n> A note on this, when looking into Pandas (join, merge) and deplyr (join), there is no concept called prefix, they only provide suffix\r\n\r\nYeah, suffix seems more right to me (if we only support one), though I will admit I haven't surveyed other systems to see what they use (many SQLs, you'ld need to reference the table as a prefiex (e.g. `left_table.col AS col_new` or the like). I tried to find what ibis does, but https://ibis-project.org/docs/generated/ibis.expr.api.TableExpr.inner_join.html doesn't have much info about that (that might be the wrong place to look for that too!). Would it make sense to make the choice of suffix/prefix an option? (that is not intended as a leading question \u2014 I'm not sure if the trade off of complexity is worth it here!)\r\n\r\n> A related but not a direct issue is that, when we read the output from a join (given that we are using the execplan and a sink node to get the response out), we still have to provide a schema, so no matter which affix we use, the output table will have the name we provide as the schema. It is a bit bothering given that the schema should be sort of inferred with the given input data, but give user an opportunity to project what is needed. \r\n\r\nHmmm maybe this is what I was running into when I couldn't get the prefixes to work at all (the tests on my branch). I haven't been able to trigger this feature successfully at all myself.\r\n\r\nI'm happy to split this into separate issues if that's easier (though I'm not totally sure that it's necessary), but there are three issues here that we should resolve:\r\n\r\n- Be able to successfully join two tables with columns that have the same names (but aren't used as keys). \n- Be able to only add the unique-name-making affixes to the columns that are duplicated (if I have two tables with the cols: [id, col_a, col_b] and [id, col_b, col_c, col_d] and I join them (with the key being id, I should get [id, col_a, col_b.x, col_b.y, col_c, col_d] (or the prefix version with x.col_b, y.col_b if we allow prefixes)\n- Be able to use suffixes\n  \n  \n  \n  \n"
        },
        {
            "created_at": "2021-12-31T04:52:21.541Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14679?focusedCommentId=17467099) by Vibhatha Lakmal Abeykoon (vibhatha):*\n\" I'm happy to split this into separate issues if that's easier (though I'm not totally sure that it's necessary), but there are three issues here that we should resolve:\"\r\n\r\n> Yes, the subtask was just added to make it neater, but that is very optional :)\u00a0\r\n\r\n\u00a0\r\n \\* \"Be able to successfully join two tables with columns that have the same names (but aren't used as keys).\"\r\n\r\n \\* \r\n \\*\\* > I think the Pandas.merge is the expected functionality (please comment `[~westonpace]` \u00a0, `[~jonkeane]`).\u00a0\r\n \\* Be able to only add the unique-name-making affixes to the columns that are duplicated (if I have two tables with the cols: [id, col_a, col_b] and [id, col_b, col_c, col_d] and I join them (with the key being id, I should get [id, col_a, col_b.x, col_b.y, col_c, col_d] (or the prefix version with x.col_b, y.col_b if we allow prefixes)\r\n \\*\\* > First we need to decide whether to keep prefix or suffix. Having both doesn't make sense (my point of view) and it could be very confusing when we handle the case in the code. So we need to decide what option we need to expose. If we go for suffixes as Pandas is doing, we need to avoid using prefixes in the C++ core and replace it with suffixes. The related functionality change is trivial, but if we have already exposed this to multiple languages we have to change those function signatures and test cases. But there is another way, we can do a schema refactor just after getting the join respone and do a string comparison and do it in the R level, but that would be very untidy and hard to maintain.\u00a0\r\n \\* \"Be able to use suffixes\"\r\n> +1 for this and I suggest dropping prefix if it is possible and be consistent with the R stack and Pandas stack since most users are familar with suffixes.\r\n\r\n\"\r\n\r\n\u00a0\r\n\r\nPandas Example\r\n\r\n-----------------\u00a0 \u00a0\r\n```java\n\r\n    import pandas as pd\r\n\r\n    df_l = pd.DataFrame({\"id\": [10, 20, 30, 40, 50, 10, 30],\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"a\": [11, 12, 14, 14, 15, 16, 17],\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"b\": [1, 2, 3, 4, 5, 6, 7]\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 })\r\n\u00a0\u00a0 \u00a0\r\n\u00a0 \u00a0 df_r = pd.DataFrame({\"id\": [10, 10, 12, 41, 51, 20, 30],\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"a\": [21, 22, 24, 24, 25, 26, 27],\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"c\": [1, 2, 3, 4, 5, 6, 7]\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 })\r\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\r\n\u00a0 \u00a0 print(df_l)\r\n\u00a0 \u00a0 print(\"-------------\")\r\n\u00a0 \u00a0 print(df_r)\r\n\u00a0\u00a0 \u00a0\r\n\u00a0 \u00a0 df_join = df_l.merge(df_r, on=\"id\", how=\"inner\", suffixes=(\".x\", \".y\"))\r\n\u00a0\u00a0 \u00a0\r\n\u00a0 \u00a0 print(df_join)\r\n\u00a0\u00a0 \u00a0\r\n\u00a0 \u00a0 \"\"\"\r\n\u00a0 \u00a0 Output:\r\n\u00a0\u00a0 \u00a0 \u00a0 id\u00a0 a.x\u00a0 b\u00a0 a.y\u00a0 c\r\n\u00a0 \u00a0 0\u00a0 10 \u00a0 11\u00a0 1 \u00a0 21\u00a0 1\r\n\u00a0 \u00a0 1\u00a0 10 \u00a0 11\u00a0 1 \u00a0 22\u00a0 2\r\n\u00a0 \u00a0 2\u00a0 10 \u00a0 16\u00a0 6 \u00a0 21\u00a0 1\r\n\u00a0 \u00a0 3\u00a0 10 \u00a0 16\u00a0 6 \u00a0 22\u00a0 2\r\n\u00a0 \u00a0 4\u00a0 20 \u00a0 12\u00a0 2 \u00a0 26\u00a0 6\r\n\u00a0 \u00a0 5\u00a0 30 \u00a0 14\u00a0 3 \u00a0 27\u00a0 7\r\n\u00a0 \u00a0 6\u00a0 30 \u00a0 17\u00a0 7 \u00a0 27\u00a0 7\r\n\u00a0 \u00a0 \"\"\"\r\n```\r\n\u00a0"
        },
        {
            "created_at": "2021-12-31T15:43:42.014Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14679?focusedCommentId=17467277) by Jonathan Keane (jonkeane):*\nOh, I hadn't seen the subtask, oops. That's also a nice way to track the components, thanks for doing that!\r\n\r\nAnd looking at the pandas behavior that's what dplyr does as well \u2014 so I would say since both of those languages do it that way we should follow that.\r\n\r\nAs to if the prefix has already been exposed: technically it has, but I'm not actually certain any of the bindings have taken advantage of it (and honestly I'm not even certain it works completely). We could make the change to suffixes and then see if any tests fail (I don't think there are any C++ tests for this functionality \u2014 at least I haven't been able to find them, and the R tests on my branch fail already).  "
        },
        {
            "created_at": "2022-01-01T00:06:15.319Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14679?focusedCommentId=17467350) by Vibhatha Lakmal Abeykoon (vibhatha):*\nGreat, let\u2019s first check it\u2019s usage and exposure in other languages or components and come up with test cases. Then incrementally will replace component by component.\u00a0"
        },
        {
            "created_at": "2022-01-04T21:55:44.859Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14679?focusedCommentId=17468872) by Weston Pace (westonpace):*\nI spoke with `[~michalno]` offline today and he confirmed that the current prefix decision was arbitrary so I agree we should just move over to suffix.  All exec node APIs are \"experimental\" so even if the prefix term has been exposed it shouldn't be a big issue to switch.  Let's not worry too much over it."
        },
        {
            "created_at": "2022-01-05T02:09:32.504Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14679?focusedCommentId=17468955) by Weston Pace (westonpace):*\nI created a unit test to play around and observe the behavior.  `[~vibhatha]` can you include something like this (I'll put it at the end) in your PR?\r\n\r\n`[~jonkeane]` I observed some of the same things you observed:\r\n\r\n> arrow doesn't seem to actually be able to apply the prefixes (I'm getting errors when trying), I couldn't tell if there were tests of this \u2014 I couldn't find any, so I'm not sure if I'm calling this wrong or if it's not working at all.\r\n\r\nI did not experience this.  The unit test appears to be working.\r\n\r\n> arrow always appends the affixes (where as dplyr only adds them if there is a name collision)\r\n\r\nYes, I noticed this as well.  If I understand correctly your desired behavior is:\r\n\r\n- If a column name is distinct between the two inputs then use the column name as-is.\n- If a column name is shared between the two inputs then attach the suffix to both output column names\n  \n  In other words, if `key, shared, left` is joined with `key, shared, right` on `key` with suffixes `_L, _R` then the output would be `key_L, shared_L, left, key_R, shared_R, right`.\n  \n  > arrow only supports prefixes...\n  \n  As mentioned earlier I agree to moving to suffixes.\n  \n~~I also noticed one other issue.  The affix is not currently attached to key columns.  I assume this is desired as well (assuming the key column has the same name).~~\r\n"
        },
        {
            "created_at": "2022-01-05T02:14:57.644Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14679?focusedCommentId=17468957) by Weston Pace (westonpace):*\nForgot to add the unit test:\r\n\r\n```Java\n\r\nTEST(HashJoin, Prefix) {\r\n  BatchesWithSchema input_left;\r\n  input_left.batches = {ExecBatchFromJSON({int32(), int32(), int32()}, R\"([\r\n                   [1, 4, 7],\r\n                   [2, 5, 8],\r\n                   [3, 6, 9]\r\n                 ])\")};\r\n  input_left.schema = schema(\r\n      {field(\"lkey\", int32()), field(\"shared\", int32()), field(\"ldistinct\", int32())});\r\n\r\n  BatchesWithSchema input_right;\r\n  input_right.batches = {ExecBatchFromJSON({int32(), int32(), int32()}, R\"([\r\n                   [1, 10, 13],\r\n                   [2, 11, 14],\r\n                   [3, 12, 15]\r\n                 ])\")};\r\n  input_right.schema = schema(\r\n      {field(\"rkey\", int32()), field(\"shared\", int32()), field(\"rdistinct\", int32())});\r\n\r\n  BatchesWithSchema expected;\r\n  expected.batches = {\r\n      ExecBatchFromJSON({int32(), int32(), int32(), int32(), int32(), int32()}, R\"([\r\n    [1, 4, 7, 1, 10, 13],\r\n    [2, 5, 8, 2, 11, 14],\r\n    [3, 6, 9, 3, 12, 15]\r\n  ])\")};\r\n  // This is the current behavior, not the desired behavior.  Ideally it should be\r\n  // lkey, ldistinct, rkey, and rdistinct and NOT l_lkey, l_ldistinct, r_rkey, and\r\n  // r_rdistinct.  The l_shared and r_shared is correct.\r\n  expected.schema = schema({field(\"l_lkey\", int32()), field(\"l_shared\", int32()),\r\n                            field(\"l_ldistinct\", int32()), field(\"r_rkey\", int32()),\r\n                            field(\"r_shared\", int32()), field(\"r_rdistinct\", int32())});\r\n\r\n  ExecContext exec_ctx;\r\n\r\n  ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make(&exec_ctx));\r\n  AsyncGenerator<util::optional<ExecBatch>> sink_gen;\r\n\r\n  ExecNode* left_source;\r\n  ExecNode* right_source;\r\n  ASSERT_OK_AND_ASSIGN(\r\n      left_source,\r\n      MakeExecNode(\"source\", plan.get(), {},\r\n                   SourceNodeOptions{input_left.schema,\r\n                                     input_left.gen(/*parallel=*/true, /*slow=*/false)}));\r\n\r\n  ASSERT_OK_AND_ASSIGN(\r\n      right_source,\r\n      MakeExecNode(\"source\", plan.get(), {},\r\n                   SourceNodeOptions{input_right.schema,\r\n                                     input_right.gen(/*parallel=*/true, /*slow=*/false)}))\r\n\r\n  HashJoinNodeOptions join_opts{JoinType::INNER,\r\n                                /*left_keys=*/{\"lkey\"},\r\n                                /*right_keys=*/{\"rkey\"}, literal(true), \"l_\", \"r_\"};\r\n\r\n  ASSERT_OK_AND_ASSIGN(\r\n      auto hashjoin,\r\n      MakeExecNode(\"hashjoin\", plan.get(), {left_source, right_source}, join_opts));\r\n\r\n  ASSERT_OK_AND_ASSIGN(std::ignore, MakeExecNode(\"sink\", plan.get(), {hashjoin},\r\n                                                 SinkNodeOptions{&sink_gen}));\r\n\r\n  ASSERT_FINISHES_OK_AND_ASSIGN(auto result, StartAndCollect(plan.get(), sink_gen));\r\n\r\n  AssertExecBatchesEqual(expected.schema, expected.batches, result);\r\n  AssertSchemaEqual(expected.schema, hashjoin->output_schema());\r\n}\r\n```"
        },
        {
            "created_at": "2022-01-05T02:15:42.350Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14679?focusedCommentId=17468958) by Weston Pace (westonpace):*\n> I also noticed one other issue. The affix is not currently attached to key columns. I assume this is desired as well (assuming the key column has the same name).\r\n\r\nLooking more closely I see I was wrong about this.  The affix is being applied to key columns."
        },
        {
            "created_at": "2022-01-07T00:19:29.656Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14679?focusedCommentId=17470260) by Vibhatha Lakmal Abeykoon (vibhatha):*\nBy the way, I am going to add an join example explicity in addition to the join related example in the streaming execution engine. The reason is most people are looking for joins. Is it okay to do that as well?\u00a0"
        },
        {
            "created_at": "2022-01-07T00:20:09.257Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14679?focusedCommentId=17470261) by Vibhatha Lakmal Abeykoon (vibhatha):*\n`[~westonpace]` \u00a0I added the test case, and will modify once the suffixes are properly added.\u00a0"
        },
        {
            "created_at": "2022-01-10T03:00:12.829Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14679?focusedCommentId=17471648) by Vibhatha Lakmal Abeykoon (vibhatha):*\n`[~westonpace]`,\u00a0created a PR for [C++] Handle suffix argument in joins"
        },
        {
            "created_at": "2022-01-14T14:21:34.056Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14679?focusedCommentId=17476166) by Krisztian Szucs (kszucs):*\nPostponing it to 8.0"
        },
        {
            "created_at": "2022-02-14T05:08:44.113Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14679?focusedCommentId=17491796) by Vibhatha Lakmal Abeykoon (vibhatha):*\n`[~jonkeane]` `[~westonpace]` I updated the PR since the sub-task is merged.\u00a0"
        },
        {
            "created_at": "2022-03-21T16:22:08.949Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14679?focusedCommentId=17509981) by Jonathan Keane (jonkeane):*\nIssue resolved by pull request 12113\n<https://github.com/apache/arrow/pull/12113>"
        }
    ]
}