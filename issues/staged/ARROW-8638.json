{
    "issue": {
        "title": "Arrow Cython API Usage Gives an error when calling CTable API Endpoints",
        "body": "***Note**: This issue was originally created as [ARROW-8638](https://issues.apache.org/jira/browse/ARROW-8638). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nI am working on using both Arrow C++ API and Cython API to support an application that I am developing. But here, I will add the issue I experienced when I am trying to follow the example,\u00a0\r\n\r\n<https://arrow.apache.org/docs/python/extending.html>\r\n\r\nI am testing on Ubuntu 20.04 LTS\r\n\r\nPython version 3.8.2\r\n\r\nThese are the steps I followed.\r\n1. Create Virtualenv\n   \n   python3 -m venv ENVARROW\n   \n   \u00a0\n   \n   2. Activate ENV\n   \n   source ENVARROW/bin/activate\n   \n   \u00a0\n   \n   3. pip3 install pyarrow==0.16.0 cython numpy\n   \n   \u00a0\n   \n   \u00a04. Code block and Tools,\n   \n   \u00a0\n   \n   **example.pyx**\n   \n   \u00a0\n   \n   \u00a0\n   {code:java}\n   from pyarrow.lib cimport \\*\n   def get_array_length(obj):\n1. Just an example function accessing both the pyarrow Cython API\n1. and the Arrow C++ API\n    cdef shared_ptr[CArray] arr = pyarrow_unwrap_array(obj)\n    if arr.get() == NULL:\n    raise TypeError(\"not an array\")\n    return arr.get().length()\n   def get_table_info(obj):\n    cdef shared_ptr[CTable] table = pyarrow_unwrap_table(obj)\n    if table.get() == NULL:\n    raise TypeError(\"not an table\")\n    \n    return table.get().num_columns()\u00a0\n   {code}\n   \u00a0\n   \n   \u00a0\n   \n   **setup.py**\n   \n   \u00a0\n   \n   \u00a0\n   {code:java}\n   from distutils.core import setup\n   from Cython.Build import cythonize\n   import os\n   import numpy as np\n   import pyarrow as pa\n   \n   ext_modules = cythonize(\"example.pyx\")\n   for ext in ext_modules:\n1. The Numpy C headers are currently required\n    ext.include_dirs.append(np.get_include())\n    ext.include_dirs.append(pa.get_include())\n    ext.libraries.extend(pa.get_libraries())\n    ext.library_dirs.extend(pa.get_library_dirs())\n   if os.name == 'posix':\n    ext.extra_compile_args.append('-std=c++11')\n1. Try uncommenting the following line on Linux\n1. if you get weird linker errors or runtime crashes\n    #ext.define_macros.append((\"_GLIBCXX_USE_CXX11_ABI\", \"0\"))\n   \n   setup(ext_modules=ext_modules)\n   ```Java\n   \n   \u00a0\n   \n   \u00a0\n   \n   +*arrow_array.py*+\n   \n   \u00a0\n   {code:java}\n   import example\n   import pyarrow as pa\n   import numpy as np\n   arr = pa.array([1,2,3,4,5])\n   len = example.get_array_length(arr)\n   print(\"Array length {} \".format(len))\u00a0\n   ```\n   \u00a0\n   \n   **arrow_table.py**\n   \n   \u00a0\n   ```java\n   \n   import example\n   import pyarrow as pa\n   import numpy as np\n   from pyarrow import csv\n   fn = 'data.csv'\n   table = csv.read_csv(fn)\n   print(table)\n   cols = example.get_table_info(table)\n   print(cols)\n   \u00a0\n   ```\n   **data.csv**\n   ```java\n   \n   1,2,3,4,5\n   6,7,8,9,10\n   11,12,13,14,15\n   ```\n   \u00a0\n   \n   **Makefile**\n   \n   \u00a0\n   ```java\n   \n   install: \n           python3 setup.py build_ext --inplace\n   clean: \n           rm -R *.so build *.cpp\u00a0\n   ```\n   \u00a0\n   \n\\*\\*When I try to run either of the python example scripts arrow_table.py or arrow_array.py,\u00a0\r\n\r\nI get the following error.\u00a0\r\n\r\n\u00a0\r\n```java\n\r\nFile \"arrow_array.py\", line 1, in <module>\r\n import example\r\nImportError: libarrow.so.16: cannot open shared object file: No such file or directory\r\n```\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n**Note: I also checked this on RHEL7 with Python 3.6.8, I got a similar response.**\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0",
        "created_at": "2020-04-30T03:22:27.000Z",
        "updated_at": "2021-08-22T13:20:33.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Component: Python",
            "Type: bug"
        ],
        "closed": true,
        "closed_at": "2020-04-30T14:16:35.000Z"
    },
    "comments": [
        {
            "created_at": "2020-04-30T12:51:00.776Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-8638?focusedCommentId=17096493) by Uwe Korn (uwe):*\nYou either need to extend the environment variable `LD_LIBRARY_PATH` to point to the directory where `libarrow.so.16` resides or (a bit more complicated in setup.py but the preferred approach) set the RPATH on the generated `example.so` Python module to also include the directory where `libarrow.so.16` reside, see turbodbc for an example:\u00a0https://github.com/blue-yonder/turbodbc/blob/8e2db0d0a26b620ad3e687e56a88fdab3117e09c/setup.py#L186-L189"
        },
        {
            "created_at": "2020-04-30T13:00:13.233Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-8638?focusedCommentId=17096500) by Vibhatha Lakmal Abeykoon (vibhatha):*\nI tried the LD_LIBRARY_PATH approach and it worked fine. But I think, I need to adopt a neat setup as you point out.\u00a0\r\n\r\nThank you for this response.\u00a0\r\n\r\nI have another thing in mind. Think of an instance where the arrow is compiled from source. In such cases is there a best practice that can be adopted.\u00a0"
        },
        {
            "created_at": "2020-04-30T14:16:35.706Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-8638?focusedCommentId=17096574) by Wes McKinney (wesm):*\nClosing since there isn't a bug to fix, further discussion can take place here or on the mailing list"
        },
        {
            "created_at": "2021-08-22T13:20:33.067Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-8638?focusedCommentId=17402791) by krishna deepak (krsna):*\n`[~uwe]` \u00a0having\u00a0**extra_link_args**\u00a0in setup.py didn't help.\u00a0\r\n\r\nfrom distutils.core import setup, Extension\r\nfrom Cython.Build import cythonize\r\nimport numpy\r\nimport sys\r\nimport os\r\n\r\nimport pyarrow as pa\r\n\r\npython_module_link_args = list()\r\npython_module_link_args.append(\"-Wl,-rpath,$ORIGIN\")\r\npyarrow_module_link_args = python_module_link_args\r\npyarrow_module_link_args.append(\"-Wl,-rpath,$ORIGIN/pyarrow\")\r\n\r\n\r\nif __name__ == '__main__':\r\n\r\n numpy_include_dir = numpy.get_include()\r\n debug = False\r\n\r\n if '--debug' in sys.argv:\r\n debug = True\r\n\r\n print(debug)\r\n\r\n compiler_directives = {\r\n 'embedsignature': True,\r\n 'boundscheck': False,\r\n 'wraparound': False,\r\n 'language_level': 3,\r\n }\r\n\r\n if debug:\r\n compiler_directives.update({\r\n 'profile': True,\r\n 'linetrace': True,\r\n 'binding': True\r\n })\r\n\r\n define_macros = [\r\n ('CYTHON_TRACE', 1),\r\n ]\r\n\r\n extra_compile_args = ['-O0']\r\n\r\n else:\r\n define_macros = []\r\n extra_compile_args = ['-O3']\r\n\r\n\r\n if os.name == 'posix':\r\n extra_compile_args.append('-std=c++11')\r\n\r\n\r\n ext_modules = [\r\n Extension(name=f.replace('.pyx', ''),\r\n sources=[f],\r\n language=\"c++\",\r\n include_dirs=[numpy_include_dir, pa.get_include()] + pa.get_libraries() + pa.get_library_dirs(),\r\n define_macros=define_macros,\r\n extra_compile_args=extra_compile_args,\r\n extra_link_args=pyarrow_module_link_args,\r\n )\r\n for f in ['table_read.pyx']\r\n if 'pyx' in f\r\n ]\r\n setup(ext_modules=cythonize(ext_modules,\r\n compiler_directives=compiler_directives,\r\n annotate=True\r\n ))"
        }
    ]
}