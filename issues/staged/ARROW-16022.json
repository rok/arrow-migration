{
    "issue": {
        "title": "[C++] Temporal floor/ceil/round throws exception for timestamps ambiguous due to DST",
        "body": "***Note**: This issue was originally created as [ARROW-16022](https://issues.apache.org/jira/browse/ARROW-16022). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nRunning pyarrow.compute.floor_temporal for timestamps that exist will throw exceptions if the times are ambiguous during the daylight savings time transitions.\u00a0\r\n\r\nAs the \\*_temporal functions do not fundamentally change the times, it does not make sense that they would fail due to a timezone issue. If they must fail, it should be when the pyarrow.Timestamp is created.\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n```java\n\r\nimport pyarrow\r\nimport pyarrow.compute as pc\r\nimport datetime\r\nimport pytz\r\n\r\nt = pyarrow.timestamp('s', tz='America/New_York')\r\n\r\ndt = datetime.datetime(2013, 11, 3, 1, 3, 14, tzinfo = pytz.timezone('America/New_York'))\r\n\r\n# if a timestamp must be invalid, this could fail\r\nza = pyarrow.array([dt], t) \r\n\r\n# raises an exception, even though this is conceptually an identity function here\r\npc.floor_temporal(za, unit = 'second') \n```\r\n\u00a0\r\n\r\nAnd this actually works just fine (continued from above)\r\n```java\n\r\npc.cast(\u00a0 \u00a0 \r\n    pc.floor_temporal(\u00a0 \u00a0 \u00a0 \u00a0 \r\n        pc.cast(za, pyarrow.timestamp('s', 'UTC')), \u00a0 \u00a0 \u00a0 \u00a0 \r\n    unit='second'), \u00a0 \u00a0 \r\n    pyarrow.timestamp('s','America/New_York')\r\n)\r\n \n```\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0",
        "created_at": "2022-03-24T18:04:29.000Z",
        "updated_at": "2022-04-07T07:40:41.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: Python",
            "Type: bug"
        ],
        "closed": false
    },
    "comments": [
        {
            "created_at": "2022-03-24T19:05:43.620Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16022?focusedCommentId=17512034) by Rok Mihevc (rokm):*\nThanks for reporting this `[~krcrouse]`, it's good to know this is needed. There's an [open PR](https://github.com/apache/arrow/pull/12528) that will change the way this is handled. Would this solve your issue?\r\n\r\n> If they must fail, it should be when the pyarrow.Timestamp is created.\r\n\r\nI'm not sure we want to validate at creation time by default as it would add lots of overhead. We typically create timestamp arrays by assigning a timezone to UTC timestamps. This means all timestamps should exist in local time (I think), but some will be ambivalent. We could add an is_ambivalent or ambivalient_to_null or something like that."
        },
        {
            "created_at": "2022-03-24T19:07:54.738Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16022?focusedCommentId=17512035) by Rok Mihevc (rokm):*\ncc `[~alvinj15]` \u00a0"
        },
        {
            "created_at": "2022-03-25T05:43:33.042Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16022?focusedCommentId=17512204) by Kevin Crouse (krcrouse):*\n`[~rokm]` ,\u00a0\r\n\r\nI understand the overhead issue and am fine with it not throwing an Exception on creation. My point is more that\u00a0_if it must throw an exception,_ it should be on creation and not when calling a function to round to the nearest second/millisecond/nanosecond. The variable already exists with a value, and whether technically valid or not, floor/ceil/round to the next second doesn't change its valid-ness.\r\n\r\nI think the PR you referenced would make it so that one has an option to use the \\*_temporal methods without it throwing an exception, which is not possible right now. That's better, but it does change the underlying data for something that conceptually should not - consider the ambiguous time of 1:30am on US Eastern Time's daylight savings day. I can create a pyarrow array and scalar with this timestamp. At the time I call floor_temporal, having only an option (via the referenced PR) for that to jump to 3:00:00am or drop to 12:59am isn't very good and will mess up comparisons to timestamps that I don't have to call \\*_timestamp on. Whatever the behavior, I would propose an invariant that a call to \\*_temporal with a unit of 'seconds' should render values within 1 second of the original value.\r\n\r\n\u00a0"
        },
        {
            "created_at": "2022-03-25T13:56:42.286Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16022?focusedCommentId=17512393) by Rok Mihevc (rokm):*\nHey Kevin,\r\n\r\nI agree with you on the first paragraph.\r\n\r\nFor the second - I assume you're referring to this case:\r\n```python\n\r\nimport pyarrow.compute as pc\r\nimport pyarrow as pa\r\n\r\narr = pa.array(pd.to_datetime([\"2022-11-06 05:00:00\"]), pa.timestamp(\"ms\", \"America/New_York\"))\r\npc.floor_temporal(arr, unit=\"second\", multiple=1)\r\n\r\n---------------------------------------------------------------------------\r\nArrowInvalid: Local time is ambiguous: 2022-11-06 01:00:00.000 is ambiguous.  It could be\r\n2022-11-06 01:00:00.000 EDT == 2022-11-06 05:00:00.000 UTC or\r\n2022-11-06 01:00:00.000 EST == 2022-11-06 06:00:00.000 UTC\r\n```\r\n(If you have another example please provide it, the more tests we have the more likely this is to work correctly.)\r\n\r\nThis happens because arrow internally keeps time in UTC and converts to local time to do the rounding there then stores the result back to UTC.\r\nThe autumn UTC->local conversion here fails because of ambiguity. I think in such case we can simply fall back to rounding in UTC (taking the timezone offset into account for e.g. +04:30 offsets) and the result might even be correct. I'm not sure.\r\n\r\nEither way - as a temporary workaround if you keep your timestamp array in UTC you should not see any such issues."
        },
        {
            "created_at": "2022-03-25T14:38:41.517Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16022?focusedCommentId=17512411) by Kevin Crouse (krcrouse):*\nHi Rok,\r\n\r\nThanks for this.\u00a0\r\n\r\nWe are accessing multiple data systems, none of which use UTC to begin with - so we are generally constrained to using local time. Also, to avoid confusing the issue by introducing pandas, here's an example using python core datetime that demonstrates localtime issues in pyarrow.\r\n\r\nAlso, I just realized this is only an issue for ambiguous times. It appears that floor_temporal handles nonexistent times correctly.\u00a0 I'll demonstrate that below as well.\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n```java\n\r\nimport datetime\r\nimport zoneinfo # native in python 3.9+\r\n\r\nimport pyarrow as pa\r\nimport pa.compute as pc\r\n\r\ntz = zoneinfo.ZoneInfo(key='America/New_York')\r\n\r\n# In the US, the 1:00am hour is the ambiguous because the minute after 1:59am Daylight-Savings Time is 1:00am Standard Time\r\n# however, these times exist and \r\ndate_ambig = datetime.datetime(2013, 11, 3, 1, 3, 14, tzinfo = tz)\r\narr = pa.array([ date_ambig ], pa.timestamp(\"s\", \"America/New_York\")) \r\n\r\n#\r\n# Here, let me introspect and annotate the objects created above\r\n#\r\ndate_ambig\r\n# > datetime.datetime(2013, 11, 3, 1, 3, 14, tzinfo=zoneinfo.ZoneInfo(key='America/New_York'))\r\n\r\nprint(date_ambig) \r\n# > 2013-11-03 01:03:14-04:00\r\n# The native datetime object defaults to daylight time. \u00a0\r\n\r\narr[0] \r\n# > <pyarrow.TimestampScalar: datetime.datetime(2013, 11, 3, 1, 3, 14, tzinfo=<DstTzInfo 'America/New_York' EDT-1 day, 20:00:00 DST>)>\r\n\r\narr\r\n# > [\u00a0 2013-11-03 05:03:14 ] \r\n# Notice that pyarrow actually understands the timestamp just fine - That is the UTC value for it.\r\n\r\npc.floor_temporal(arr, unit=\"second\")\r\n\r\n# > pyarrow.lib.ArrowInvalid: Local time is ambiguous ...\r\n\r\n```\r\nI wrote this to demonstrate the issue for nonexistent times, but there's no error. I just went back to my error logs and realize that it indeed only happens at the start of DST.\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n```java\n\r\nimport datetime\r\nimport zoneinfo # native in python 3.9+\r\n\r\nimport pyarrow as pa\r\nimport pa.compute as pc\r\n\r\ntz = zoneinfo.ZoneInfo(key='America/New_York')\r\n\r\n# In the US, the minute after 1:59am standard time is 3:00am in daylight time. \r\n# Native python interprets a timestamp in the 2am hour as standard time, since daylight time does not yet exist.\r\n\r\nbefore_dst = datetime.datetime(2022, 3, 13, 1, 30, 14, tzinfo=zoneinfo.ZoneInfo(key='America/New_York'))\r\nnonext_time = datetime.datetime(2022, 3, 13, 2, 30, 14, tzinfo=zoneinfo.ZoneInfo(key='America/New_York'))\r\nafter_dst = datetime.datetime(2022, 3, 13, 3, 30, 14, tzinfo=zoneinfo.ZoneInfo(key='America/New_York'))\r\n\r\nprint(before_dst)\r\n# > 2022-03-13 01:30:14-05:00\r\nprint(nonext_time)\r\n# > 2022-03-13 02:30:14-05:00\r\nprint(after_dst )\r\n# > 2022-03-13 03:30:14-04:00\r\n\r\npc.floor_temporal(pa.array([ before_dst, nonext_time, after_dst], pa.timestamp(\"s\", \"America/New_York\")), unit=\"second\")\r\n\r\n# <pyarrow.lib.TimestampArray object at 0x7f17eb5ce0a0>\r\n# [\r\n#\u00a0   2022-03-13 06:30:14,\r\n#  \u00a0 2022-03-13 07:30:14,\r\n#\u00a0   2022-03-13 07:30:14\r\n# ]\n```\r\n\u00a0"
        },
        {
            "created_at": "2022-03-25T15:48:04.488Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16022?focusedCommentId=17512449) by Rok Mihevc (rokm):*\nIf you want to switch to UTC from local time and avoid pandas you can use assume_timezone (similar to pandas tz_localize):\r\n```python\n\r\nimport pyarrow.compute as pc\r\nimport pyarrow as pa\r\n\r\narr = pa.array([\"2022-11-06 01:00:00\"]).cast(pa.timestamp(\"ms\"))\r\narr_zoned = pc.assume_timezone(\r\n    arr,\r\n    \"America/New_York\",\r\n    nonexistent=\"earliest\",\r\n    ambiguous=\"earliest\"\r\n)\r\npc.floor_temporal(arr_zoned.cast(pa.timestamp(\"ms\", \"UTC\")), unit=\"second\", multiple=1)\r\npc.floor_temporal(arr_zoned, unit=\"second\", multiple=1)\r\n\r\n---------------------------------------------------------------------------\r\n\r\nArrowInvalid                              Traceback (most recent call last)\r\nInput In [218], in <module>\r\n...\r\n     11 pc.floor_temporal(arr_zoned.cast(pa.timestamp(\"ms\", \"UTC\")), unit=\"second\", multiple=1)\r\n---> 12 pc.floor_temporal(arr_zoned, unit=\"second\", multiple=1)\r\n...\r\nArrowInvalid: Local time is ambiguous: 2022-11-06 01:00:00.000 is ambiguous.  It could be\r\n2022-11-06 01:00:00.000 EDT == 2022-11-06 05:00:00.000 UTC or\r\n2022-11-06 01:00:00.000 EST == 2022-11-06 06:00:00.000 UTC\r\n```\r\nNotice the UTC case works and local time does not.\r\n\r\n\u00a0\r\n\r\nI can try fixing this ambiguity issue by falling back to rounding in UTC. I would just wait for ARROW-15251 to merge to minimise complexity."
        },
        {
            "created_at": "2022-04-07T07:34:30.935Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16022?focusedCommentId=17518650) by Joris Van den Bossche (jorisvandenbossche):*\n> If they must fail, it should be when the pyarrow.Timestamp is created.\r\n\r\nI would like to point out that Arrow actually _does_ \"validate\" the time upon creation. In the sense that we do convert the timezone-aware python datetime object into an unambiguous UTC value (which is guaranteed to exist) when creating the pyarrow timestamp array.\r\n\r\nIt is only that the current implementation of temporal rounding does this in local time, and in your case the unambiguous UTC timestamp is converted to a local time that is ambiguous (in local time), and then the conversion back to unambiguous UTC timestamp after rounding fails. We can solve this specific issue by improving the implementation of the temporal rounding algorithm, and that is what ARROW-15251(<https://github.com/apache/arrow/pull/12528>) is about.\r\n\r\nTo illustrate my first point, let me get back to your example of an ambiguous datetime:\r\n```python\n\r\ntz = zoneinfo.ZoneInfo(key='America/New_York')\r\n\r\n# In the US, the 1:00am hour is the ambiguous because the minute after 1:59am Daylight-Savings Time is 1:00am Standard Time\r\n# however, these times exist and \r\ndate_ambig = datetime.datetime(2013, 11, 3, 1, 3, 14, tzinfo = tz)\r\n```\r\nThis is in fact not an ambiguous datetime. As you show when printing this value, \"native datetime object defaults to daylight time\":\r\n```python\n\r\n>>> print(date_ambig)\r\n2013-11-03 01:03:14-04:00\r\n```\r\nbut this is because the actual datetime defaults to `{}fold=0{`}, which corresponds to the offset of 04:00. This is something you control when _creating_ the actual datetime.datetime object, so we can explicitly construct the \"other\" value for this datetime with offset 05:00:\r\n```python\n\r\n>>> date_ambig2 = datetime.datetime(2013, 11, 3, 1, 3, 14, tzinfo = tz, fold=1)\r\n>>> print(date_ambig2)\r\n2013-11-03 01:03:14-05:00\r\n\r\n>>> pa.array([date_ambig, date_ambig2], pa.timestamp(\"us\", tz=\"America/New_York\"))\r\n<pyarrow.lib.TimestampArray object at 0x7fa58edb79a0>\r\n[\r\n  2013-11-03 05:03:14.000000,\r\n  2013-11-03 06:03:14.000000\r\n]\r\n```\r\n\r\nSo both datetime.datetime values are actually representing a specific moment in time in this case, and are properly converted to UTC when creating the pyarrow array.\r\n\r\nSee https://peps.python.org/pep-0495/ for more details on this \"fold\" that was introduced for datetime.datetime to disambiguate local times."
        },
        {
            "created_at": "2022-04-07T07:40:41.158Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16022?focusedCommentId=17518652) by Joris Van den Bossche (jorisvandenbossche):*\nMaybe something else to point out is that you should best be careful with how you use `pytz` (as some call it \"broken\"). Your initial example might not be doing what you expected:\r\n\r\n```python\n\r\nt = pyarrow.timestamp('s', tz='America/New_York')\r\ndt = datetime.datetime(2013, 11, 3, 1, 3, 14, tzinfo = pytz.timezone('America/New_York'))\r\nza = pyarrow.array([dt], t)\r\n\r\n>>> print(dt)\r\n2013-11-03 01:03:14-04:56\r\n\r\n>>> za\r\n<pyarrow.lib.TimestampArray object at 0x7fa58ecf0fa0>\r\n[\r\n  2013-11-03 05:59:14\r\n]\r\n```\r\n\r\nNote the strange \"04:56\" offset when printing (while we would expect either \"04:00\" or \"05:00\"), and the strange UTC value when converted to a pyarrow array (an hour of \"05:59\", instead of \"05:03\" or \"06:03\"). \r\n\r\nThis is because the `dt` value was created \"incorrectly\" for how pytz works (note that your code above is working fine when using zoneinfo timezones). See https://bugs.launchpad.net/pytz/+bug/1746179 and https://blog.ganssle.io/articles/2018/03/pytz-fastest-footgun.html for a more detailed explanation about this.\r\n\r\nThe \"correct\" way to do this with the pytz library is (but this is a reason many people recommend to stop using pytz):\r\n\r\n```python\n\r\n>>> dt = pytz.timezone('America/New_York').localize(datetime.datetime(2013, 11, 3, 1, 3, 14))\r\n>>> print(dt)\r\n2013-11-03 01:03:14-05:00\r\n>>> pa.array([dt])\r\n<pyarrow.lib.TimestampArray object at 0x7fa58edb4340>\r\n[\r\n  2013-11-03 06:03:14.000000\r\n]\r\n```"
        }
    ]
}