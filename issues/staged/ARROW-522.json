{
    "issue": {
        "title": "[Java] VectorLoader throws exception data schema contains list of maps.",
        "body": "***Note**: This issue was originally created as [ARROW-522](https://issues.apache.org/jira/browse/ARROW-522). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nI encountered this exception\n```java\nException in thread \"main\" java.lang.IllegalArgumentException: should have as many children as in the schema: found 0 expected 2\n    at com.google.common.base.Preconditions.checkArgument(Preconditions.java:122)\n    at org.apache.arrow.vector.VectorLoader.loadBuffers(VectorLoader.java:91)\n    at org.apache.arrow.vector.VectorLoader.loadBuffers(VectorLoader.java:95)\n    at org.apache.arrow.vector.VectorLoader.load(VectorLoader.java:69)\n```\n\nThe test code is\n\n```java\npublic class ArrowTest {\n    public static class ByteArrayReadableSeekableByteChannel implements SeekableByteChannel {\n        private byte[] byteArray;\n        private int position = 0;\n\n        public ByteArrayReadableSeekableByteChannel(byte[] byteArray) {\n            if (byteArray == null) {\n                throw new NullPointerException();\n            }\n            this.byteArray = byteArray;\n        }\n\n        @Override\n        public boolean isOpen() {\n            return byteArray != null;\n        }\n\n        @Override\n        public void close() throws IOException {\n            byteArray = null;\n        }\n\n        @Override\n        public int read(final ByteBuffer dst) throws IOException {\n            int remainingInBuf = byteArray.length - this.position;\n            int length = Math.min(dst.remaining(), remainingInBuf);\n            dst.put(this.byteArray, this.position, length);\n            this.position += length;\n            return length;\n        }\n\n        @Override\n        public long position() throws IOException {\n            return this.position;\n        }\n\n        @Override\n        public SeekableByteChannel position(final long newPosition) throws IOException {\n            this.position = (int) newPosition;\n            return this;\n        }\n\n        @Override\n        public long size() throws IOException {\n            return this.byteArray.length;\n        }\n\n        @Override\n        public int write(final ByteBuffer src) throws IOException {\n            throw new UnsupportedOperationException(\"Read only\");\n        }\n\n        @Override\n        public SeekableByteChannel truncate(final long size) throws IOException {\n            throw new UnsupportedOperationException(\"Read only\");\n        }\n    }\n\n    public static void main(String[] argv) throws Exception {\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n\n        // write\n        try (BufferAllocator allocator = new RootAllocator(Integer.MAX_VALUE);\n                BufferAllocator originalVectorAllocator = allocator\n                        .newChildAllocator(\"child allocator\", 1024, Integer.MAX_VALUE);\n                MapVector parent = new MapVector(\"parent\", originalVectorAllocator, null)\n        ) {\n            writeData(10, parent);\n            write(parent.getChild(\"root\"), Channels.newChannel(byteArrayOutputStream));\n        }\n\n        byte[] data = byteArrayOutputStream.toByteArray();\n\n        // read\n        try (BufferAllocator allocator = new RootAllocator(Integer.MAX_VALUE);\n                BufferAllocator readerAllocator = allocator.newChildAllocator(\"reader\", 0, Integer.MAX_VALUE);\n                ArrowReader arrowReader = new ArrowReader(new ByteArrayReadableSeekableByteChannel(data),\n                        readerAllocator);\n                BufferAllocator vectorAllocator = allocator.newChildAllocator(\"final vectors\", 0, Integer.MAX_VALUE);\n                MapVector parent = new MapVector(\"parent\", vectorAllocator, null)\n        ) {\n            ArrowFooter footer = arrowReader.readFooter();\n            Schema schema = footer.getSchema();\n\n            NullableMapVector root = parent.addOrGet(\"root\", Types.MinorType.MAP, NullableMapVector.class);\n\n            VectorLoader vectorLoader = new VectorLoader(schema, root);\n\n            List<ArrowBlock> recordBatches = footer.getRecordBatches();\n\n            for (ArrowBlock rbBlock : recordBatches) {\n                try (ArrowRecordBatch recordBatch = arrowReader.readRecordBatch(rbBlock)) {\n                    vectorLoader.load(recordBatch);\n                }\n\n                readData(10, parent);\n            }\n        }\n    }\n\n    private static void writeData(int count, MapVector parent) throws Exception {\n        BaseWriter.ComplexWriter writer = new ComplexWriterImpl(\"root\", parent, true);\n        BaseWriter.MapWriter rootWriter = writer.rootAsMap();\n        IntWriter intWriter = rootWriter.integer(\"id\");\n        BaseWriter.ListWriter listWriter = rootWriter.list(\"list\");\n        BaseWriter.MapWriter mapFromList = listWriter.map();\n        for (int i = 0; i < count; i++) {\n            rootWriter.start();\n            intWriter.setPosition(i);\n            intWriter.writeInt(i);\n\n            listWriter.setPosition(i);\n            listWriter.startList();\n            for (int j = 0; j < 2; j++) {\n                mapFromList.start();\n                mapFromList.integer(\"type\").writeInt(j);\n                mapFromList.bigInt(\"id\").writeBigInt(j * 1000L);\n                mapFromList.end();\n            }\n            listWriter.endList();\n            rootWriter.end();\n        }\n        writer.setValueCount(count);\n    }\n\n    private static void readData(int count, MapVector parent) {\n        BaseReader.MapReader rootReader = new SingleMapReaderImpl(parent).reader(\"root\");\n        FieldReader listReader = rootReader.reader(\"list\");\n        for (int i = 0; i < count; i++) {\n            listReader.setPosition(i);\n            while (listReader.next()) {\n                System.out.println(i + \" id \" + listReader.reader().reader(\"id\").readLong());\n                System.out.println(i + \" type \" + listReader.reader().reader(\"type\").readInteger());\n            }\n        }\n    }\n\n    private static void write(FieldVector parent, WritableByteChannel out) throws IOException {\n        VectorUnloader vectorUnloader = new VectorUnloader(parent);\n        Schema schema = vectorUnloader.getSchema();\n        try (\n                ArrowWriter arrowWriter = new ArrowWriter(out, schema);\n                ArrowRecordBatch recordBatch = vectorUnloader.getRecordBatch();\n        ) {\n            arrowWriter.writeRecordBatch(recordBatch);\n        }\n    }\n```",
        "created_at": "2017-02-01T21:37:55.000Z",
        "updated_at": "2022-06-29T16:58:02.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: Java",
            "Type: bug"
        ],
        "closed": true,
        "closed_at": "2022-06-29T16:58:02.000Z"
    },
    "comments": [
        {
            "created_at": "2017-02-01T21:41:41.623Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-522?focusedCommentId=15848971) by Rock Wang (rleiwang):*\nIt seems fixed the exception by adding the following to /org/apache/arrow/vector/complex/ListVector.java\n```java\n    if (!field.getChildren().isEmpty()) {\n      addOrGetVector.getVector().initializeChildrenFromFields(field.getChildren());\n    }\n```\n\nas in \n\n```java\n  @Override\n  public void initializeChildrenFromFields(List<Field> children) {\n    if (children.size() != 1) {\n      throw new IllegalArgumentException(\"Lists have only one child. Found: \" + children);\n    }\n    Field field = children.get(0);\n    MinorType minorType = Types.getMinorTypeForArrowType(field.getType());\n    AddOrGetResult<FieldVector> addOrGetVector = addOrGetVector(minorType);\n    if (!addOrGetVector.isCreated()) {\n      throw new IllegalArgumentException(\"Child vector already existed: \" + addOrGetVector.getVector());\n    }\n    if (!field.getChildren().isEmpty()) {\n      addOrGetVector.getVector().initializeChildrenFromFields(field.getChildren());\n    }\n  }\n```"
        },
        {
            "created_at": "2022-06-29T16:58:02.971Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-522?focusedCommentId=17560380) by Antoine Pitrou (apitrou):*\nSince this issue is against 0.17.0, it's highly likely that it was fixed in the meantime. If it wasn't, feel free to open a new JIRA. Thank you!"
        }
    ]
}