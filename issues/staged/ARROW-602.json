{
    "issue": {
        "title": "[C++] Provide iterator access to primitive elements inside a ChunkedArray",
        "body": "***Note**: This issue was originally created as [ARROW-602](https://issues.apache.org/jira/browse/ARROW-602). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nGiven a ChunkedArray, an Arrow user must currently iterate over all its chunks and then cast them to their types to extract the primitive memory regions to access the values. A convenient way to access the underlying values would be to offer a function that takes a ChunkedArray and returns a C++ iterator over all elements.\n\nWhile this may not be the most performant way to access the underlying data, it should have sufficient performance and adds a convenience layer for new users.",
        "created_at": "2017-03-04T08:23:00.000Z",
        "updated_at": "2022-05-13T08:41:27.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Type: enhancement"
        ],
        "closed": true,
        "closed_at": "2022-05-11T16:54:37.000Z"
    },
    "comments": [
        {
            "created_at": "2017-03-17T13:12:21.510Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-602?focusedCommentId=15929943) by Johan Mabille (JohanMabille):*\nThe problem is a C++ iterator assumes that all the elements of the underlying container have the same type, whereas it may not be the case for elements in a ChunkedArray. I couldn't find the specification of ChunkedArray, but I guess you don't want to force the chunks to have the same value type ?"
        },
        {
            "created_at": "2017-03-17T13:33:54.440Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-602?focusedCommentId=15929977) by Uwe Korn (uwe):*\nA chunked array is just a collection of arrays of the same type, so we should be able to construct instances of `std::iterator<int64_t, ...>`. The iterator would then iterate over all the values in all these underlying arrays.\n\nAs Arrow arrays are nullable, the iterator must either be on `std::pair<bool, value_type>` or we would have to specify that the iterator only iterates over all non-null values."
        },
        {
            "created_at": "2017-03-17T13:47:41.996Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-602?focusedCommentId=15929991) by Johan Mabille (JohanMabille):*\nOk, so it is possible to provide an STL compliant iterator. Cool !\nEDIT: still a little problem, the value_type is unknown at compilation, so it might be usefull to add it as a template parameter of ChunkedArray. Besides, that would allow type checking in its constructor.\n\nI think most of the use cases would be to apply STL-like algorithms, so it makes sense to iterate over non-null values only. Later we can provide a \"full\" iteration interface for the case where iteration over null values is required, what do you think ?"
        },
        {
            "created_at": "2017-03-18T21:48:30.107Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-602?focusedCommentId=15931401) by Wes McKinney (wesm):*\nSince we don't have a 100% consistent scalar value model, this would probably only be useful for types that have a `c_type` member. You could also have an iterator that yields a sequence of `const ARRAY_TYPE& chunk, int64_t relative_offset` pairs, so at least you don't have to do the chunk boundary jumping by hand each time"
        },
        {
            "created_at": "2017-03-21T09:26:37.786Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-602?focusedCommentId=15934324) by Johan Mabille (JohanMabille):*\nIs that something you're open to change ? I mean, providing an interface a la std::vector (that is typedefs + iterators and access operators) for numerical arrays could make Arrow interoperable with the algorithms of the STL and other libraries that follow its idioms.\n\nI understand the need for Arrow arrays to have a entity semantic, so the changes I mention would only apply to leaf classes in the arrays hierarchy (this wouldn't break anything, that would be additional members only). And with the visitor pattern you already provide, I'm pretty sure we could dispatch STL-like algorithms that would rebind to the static ones of the STL, that would be awesome! Let me know your fellings about it, if you think it might be a good idea, I can open a dedicated issue and start to implement it."
        },
        {
            "created_at": "2017-03-21T13:23:12.969Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-602?focusedCommentId=15934618) by Wes McKinney (wesm):*\nI'm definitely open to this at a high level, but we would need to write a design document to work through the questions/problems. It feels like a deep rabbit hole. For example, \n\n- do arrays return `std::optional<T>` or `std::pair<bool, T`?\n- what is `T` for non-numeric data?\n- what about nested data (list, struct, union)?"
        },
        {
            "created_at": "2017-03-21T14:30:31.999Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-602?focusedCommentId=15934712) by Johan Mabille (JohanMabille):*\nI thought I would add this interface to numerical arrays for a start, but I agree it might be complicated to go back if we experience any problem in adding this interface to the other array classes in the future.\n\nBy the way I guess your first question is adressing the handling of missing values ? Sylvain has done some work on it for xtensor, you might be interested in <https://github.com/QuantStack/xtensor/pull/196>.\n\nMore generally, what would be the best process for you? I can open a dedicated issue for this topic, so that we can identify all the possible problems and start trying to solve them. Or I can start a draft and we can iterate (or maybe you already started something I can contribute to). I guess this document could go into arrow/cpp/doc, so I may open a PR with an initial draft."
        },
        {
            "created_at": "2017-03-21T14:43:34.552Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-602?focusedCommentId=15934723) by Wes McKinney (wesm):*\nIt's also OK (and maybe simpler) to start a public Google document and link to on this issue "
        },
        {
            "created_at": "2017-03-22T15:30:21.144Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-602?focusedCommentId=15936532) by Johan Mabille (JohanMabille):*\nOk, I start a Google doc as soon as I can (probably this week end or the beginning of next week)."
        },
        {
            "created_at": "2017-03-31T12:53:01.174Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-602?focusedCommentId=15950806) by Johan Mabille (JohanMabille):*\nHere is a first attempt to specify the interface: https://docs.google.com/document/d/1Jz-DH5KHEBn5SmBaKx67ktEp4NYOx7HRWOqVABleTjo/edit?usp=sharing\n"
        },
        {
            "created_at": "2017-04-03T22:26:02.391Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-602?focusedCommentId=15954254) by Wes McKinney (wesm):*\nhi `[~JohanMabille]`, thank you very much for writing this spec document. \n\nI think using an STL-compatible interface to Arrow data structures would be really useful. As far as the data structures defined in https://github.com/apache/arrow/blob/master/cpp/src/arrow/array.h, my feeling is that they should remain as \"plain old data\" with as few features as necessary beyond access to their metadata and data buffers \u2013 there are a couple of convenience methods on `arrow::Array` and its subclasses for equality, slicing, and simple value access, but beyond that I am not sure we should add very much to these classes (I'd be more in favor of making `array.h` smaller than making it bigger}}. \n\nWhat I'm envisioning is something like:\n\n```Java\nstd::shared_ptr<Array> my_data = ...;\n\narrow::ArrayAccessor<Int64Type> container(*my_data);\n```\n\nFrom here, `container` would unbox the memory in `my_data` and implement the interfaces which you've described in your document. We'll have to make decisions about the return value for `operator[]`, like perhaps it will return `std::optional<int64_t>` for this example, but the return type for nested types may be more complicated. \n\nWhile Arrow memory is intended to be immutable for most applications, if the buffers in an array are mutable (e.g. `my_data->data()->is_mutable()` is true) then this container could permit mutation, subject to const-ness. \n\nDoes this make sense? "
        },
        {
            "created_at": "2017-04-06T08:53:19.854Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-602?focusedCommentId=15958583) by Johan Mabille (JohanMabille):*\nHi `[~wesmckinn]`, thanks for your comment, I see your point. I think this approach could reconciliate the need for a class hierarchy for arrays and the need for value semantic for a container interface (a la STL). I'm very busy because of pydata this weekend, I will make a more detailed answer after our talk on sunday."
        },
        {
            "created_at": "2017-04-18T15:52:19.065Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-602?focusedCommentId=15972949) by Johan Mabille (JohanMabille):*\nHi `[~wesmckinn]`,\n\nSo, as I previously said, this approach would make sense if the wrappers that provide STL-like interface to the array classes are independent, that is, there is no inheritance relation between them. This way they would have pure value semantic, just liske STL-containers. However, some questions:\n\n- how do we handle mutable methods on non-mutable arrays ? Methods such as resize must be in the interface, even when the array is not mutable (since this information cannot be known at compile time). Would you consider throwing an exception as an acceptable behavior ?\n- why using a flag fo handling mutability instead or relying on const-correctness only ? (this is more for my understanding of the design)\n- why do you want to keep arrays the smallest possible ? (again, this is more for my understanding of the design)\n\nAbout the return type for supporting missing values, I am not sure that std::optional is what we need; I assume that we want to read the flag telling if the value is missing or not from the null bitmap, and we do not want to copy that bitmap for performance considerations. In the case of a mutable array, if a missing value becomes available (or the contrary), the corresponding bit in the bitmap must be updated. However, std::optional does not permit this, so we may end up with coding a dedicated type for missing values (a type that allows reference proxy on boolean). This type can provide a similar interface to the one of std::optional.\n"
        },
        {
            "created_at": "2019-01-09T12:28:34.109Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-602?focusedCommentId=16738172) by Antoine Pitrou (apitrou):*\nWe have `ArrayDataVisitor` now that will tackle many of the use cases of iterator access (though with inversion of control, so you have to define a visitor class which may feel like boilerplate).\r\n\r\nThe nice thing with the inversion of control is that we may for example optimize `ArrayDataVisitor` by unrolling the null bitmap reading loop 8 times."
        },
        {
            "created_at": "2019-01-09T13:47:53.037Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-602?focusedCommentId=16738261) by Uwe Korn (uwe):*\n`[~pitrou]` I think we should document this is the faster path but having the STL-compliant will still be a good thing for a first time adoption of Arrow inside of an STL codebase."
        },
        {
            "created_at": "2020-04-17T19:37:48.363Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-602?focusedCommentId=17086017) by Scott Wilson (swilson314):*\n`[~wesm]` I've taken a stab at implementing ChunkedArray covers and iterators to support STL interfaces. My initial implementation returned std::optional<T>, but I didn't like the way this interacted with most stl numeric algorithms which expect iterator dereferences to be double or the like, and std::optional<double> doesn't automatically cast to double. I added a IsNull() member to the iterators, so at least this info is accessible.\r\n\r\nI'm not quite sure how to handle the issue of mutability, so I've simply punted. (Is there some description of the expected semantics of immutability? Is it really the case that I shouldn't write into a raw_value if the array is immutable?) Arrays that return proxys for the underlying memory, e.g. string, require a strange _cached variable in order to return a dereferenced iterator.\r\n\r\nThis my first pass at this code. I've done little testing, and it is not comprehensive. I just wanted to verify that I'm not doing something abnormally stupid ;)\r\n```c++\n\r\n#include <cstdint>\r\n#include <memory>\r\n#include <numeric>\r\n#include <string>\r\n#include <iostream>\r\n#include <optional>\r\n#include <vector>\r\n#include <xutility>\r\n\r\n#include <arrow/api.h>\r\n#include <arrow/filesystem/localfs.h>\r\n#include <arrow/csv/api.h>\r\n#include <arrow/result.h>\r\n#include <arrow/builder.h>\r\n\r\n#include <boost/iterator/iterator_facade.hpp>\r\n#include <boost/range/iterator_range.hpp>\r\n\r\nusing namespace std;\r\nusing namespace arrow;\r\n\r\n// SBW 2020.04.15 For ArrayCoverRaw::iterator, we can simply use the the pointer interface.\r\n// Wes suggests returning std::optional<T>, but sizeof(double) < sizeof(std::optional<double>) and\r\n// is not a drop-in replacement for T, i.e. optional<T> can't be used in expression, need optional<T>.value().\r\n\r\n// STL container-like cover for arrow::Array.\r\n// Only works for Array types that support raw_values().\r\ntemplate<typename ArrType>\r\nclass ArrayCoverRaw\r\n{\r\npublic:\r\n\tusing T = typename ArrType::value_type;\r\n\tusing pointer = T*;\r\n\tusing const_pointer = const T*;\r\n\tusing reference = T&;\r\n\tusing const_reference = const T&;\r\n\t// Match size_type to Array offsets rather than using size_t and ptrdiff_t.\r\n\tusing size_type = int64_t;\r\n\tusing difference_type = int64_t;\r\n\tusing iterator = pointer;\r\n\tusing const_iterator = const_pointer;\r\n\tusing reverse_iterator = pointer;\r\n\tusing const_reverse_iterator = const_pointer;\r\n\r\n\tArrayCoverRaw(std::shared_ptr<ArrType>& array) : _array(array) {}\r\n\r\n\tsize_type size() const { return _array->length(); }\r\n\r\n\t// Should non-const versions fail if Array is immutable?\r\n\titerator begin() { return const_cast<pointer>(_array->raw_values()); }\r\n\titerator end() { return const_cast<pointer>(_array->raw_values()+_array->length()); }\r\n\treverse_iterator rbegin() { return const_cast<pointer>(_array->raw_values()+_array->length()-1); }\r\n\treverse_iterator rend() { return const_cast<pointer>(_array->raw_values()-1); }\r\n\tconst_iterator cbegin() const { return _array->raw_values(); }\r\n\tconst_iterator cend() const { return _array->raw_values()+_array->length(); }\r\n\tconst_reverse_iterator crbegin() const { return _array->raw_values()+_array->length()-1; }\r\n\tconst_reverse_iterator crend() const { return _array->raw_values()-1; }\r\n\r\n\t// We could return std::optional<T> to encapsulate IsNull() info, but this would seem to break the expected semantics.\r\n\treference operator[](const difference_type off) { assert(_array->data()->is_mutable()); return _array->raw_values()+off; }\r\n\tconst_reference operator[](const difference_type off) const { return _array->raw_values()+off; }\r\n\t// ISSUE: is there an interface for setting IsNull() if array is mutable.\r\n\tbool IsNull(difference_type off) const { return _array->IsNull(off); }\r\n\r\nprotected:\r\n\tstd::shared_ptr<ArrType> _array;\r\n};\r\n\r\n// TODO: Add ArrayCoverString and iterators, perhaps others.\r\n\r\n// Use template on Value so we can create iterator and const_iterator by changing Value.\r\n// Only works for Array types that support raw_values().\r\ntemplate <typename ArrType, class Value>\r\nclass ChunkedArrayIteratorRaw\r\n\t: public boost::iterator_facade<ChunkedArrayIteratorRaw<ArrType, Value>, Value, boost::random_access_traversal_tag>\r\n{\r\npublic:\r\n\tusing difference_type = int64_t;\r\n\tusing T = typename ArrType::value_type;\r\n\tusing pointer = T*;\r\n\r\n\texplicit ChunkedArrayIteratorRaw(std::shared_ptr<arrow::ChunkedArray> ch_arr = 0, difference_type pos = 0)\r\n\t\t: _ch_arr(ch_arr)\r\n\t{\r\n\t\tset_position(pos);\r\n\t}\r\n\r\n\tbool IsNull() const\r\n\t{\r\n\t\tauto arr = _ch_arr->chunk(_chunk_index);\r\n\t\treturn arr->IsNull(_current-_first);\r\n\t}\r\n\r\nprivate:\r\n\tfriend class boost::iterator_core_access;\r\n\r\n    bool equal(ChunkedArrayIteratorRaw<ArrType, Value> const& other) const\r\n    {\r\n        return this->_position == other._position;\r\n    }\r\n\r\n    void increment()\r\n\t{\r\n\t\t_position++;\r\n\t\t// Need to move to next chunk?\r\n\t\tif ((_current == _last) && ((_chunk_index+1) < _ch_arr->num_chunks()))\r\n\t\t{\r\n\t\t\t_chunk_index++;\r\n\t\t\tauto arr = _ch_arr->chunk(_chunk_index);\r\n\t\t\tauto typed_arr = std::static_pointer_cast<ArrType>(arr);\r\n\t\t\t_first = const_cast<pointer>(typed_arr->raw_values());\r\n\t\t\t_last = _first + arr->length() - 1;\r\n\t\t\t_current = _first;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t_current++;\r\n\t\t}\r\n\t}\r\n\r\n\tvoid decrement()\r\n\t{\r\n\t\t_position--;\r\n\t\t// Need to move to previous chunk?\r\n\t\tif ((_current == _first) && (_chunk_index > 0))\r\n\t\t{\r\n\t\t\t_chunk_index--;\r\n\t\t\tauto arr = _ch_arr->chunk(_chunk_index);\r\n\t\t\tauto typed_arr = std::static_pointer_cast<ArrType>(arr);\r\n\t\t\t_first = const_cast<pointer>(typed_arr->raw_values());\r\n\t\t\t_last = _first + arr->length() - 1;\r\n\t\t\t_current = _last;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t_current--;\r\n\t\t}\r\n\t}\r\n\r\n    Value& dereference() const { return *_current; }\r\n\r\n\tvoid advance(difference_type n)\r\n\t{\r\n\t\t_position += n;\r\n\t\twhile (n > 0)\r\n\t\t{\r\n\t\t\tdifference_type max_delta = _last - _current;\r\n\t\t\tif ((max_delta >= n) || ((_chunk_index+1) == _ch_arr->num_chunks()))\r\n\t\t\t{\r\n\t\t\t\t_current += n;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// Move to next chunk.\r\n\t\t\tn -= max_delta;\r\n\t\t\t_chunk_index++;\r\n\t\t\tauto arr = _ch_arr->chunk(_chunk_index);\r\n\t\t\tauto typed_arr = std::static_pointer_cast<ArrType>(arr);\r\n\t\t\t_first = const_cast<pointer>(typed_arr->raw_values());\r\n\t\t\t_last = _first + arr->length() - 1;\r\n\t\t\t_current = _first;\r\n\t\t}\r\n\t\twhile (n < 0)\r\n\t\t{\r\n\t\t\tdifference_type max_delta = _first - _current;\r\n\t\t\tif ((max_delta <= n) || (_chunk_index == 0))\r\n\t\t\t{\r\n\t\t\t\t_current += n;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// Move to previous chunk.\r\n\t\t\tn -= max_delta;\r\n\t\t\t_chunk_index--;\r\n\t\t\tassert(_chunk_index >= 0);\r\n\t\t\tauto arr = _ch_arr->chunk(_chunk_index);\r\n\t\t\tauto typed_arr = std::static_pointer_cast<ArrType>(arr);\r\n\t\t\t_first = const_cast<pointer>(typed_arr->raw_values());\r\n\t\t\t_last = _first + arr->length() - 1;\r\n\t\t\t_current = _last;\r\n\t\t}\r\n\t}\r\n\r\n\tdifference_type distance_to(ChunkedArrayIteratorRaw<ArrType, Value> const& other)\r\n\t{\r\n\t\treturn other._position - this->_position;\r\n\t}\r\n\r\n\t// Helper\r\n\tvoid set_position(difference_type pos)\r\n\t{\r\n\t\t_position = pos;\r\n\t\tconst int nchunks = _ch_arr->num_chunks();\r\n\t\tint64_t offset = 0;\r\n\t\tfor (_chunk_index = 0; _chunk_index < nchunks; _chunk_index++)\r\n\t\t{\r\n\t\t\tauto arr = _ch_arr->chunk(_chunk_index);\r\n\t\t\tint64_t arr_rows = arr->length();\r\n\t\t\tif (((offset+arr_rows) > pos) || ((_chunk_index+1)==nchunks))\r\n\t\t\t{\r\n\t\t\t\tauto typed_arr = std::static_pointer_cast<ArrType>(arr);\r\n\t\t\t\t_first = const_cast<T*>(typed_arr->raw_values());\r\n\t\t\t\t_last = _first + arr_rows - 1;\r\n\t\t\t\t_current = _first + (pos-offset);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\toffset += arr_rows;\r\n\t\t}\r\n\t\tassert(false);\r\n\t}\r\n\r\n\tstd::shared_ptr<arrow::ChunkedArray> _ch_arr;\r\n\t// Which Array we're looking at.\r\n\tint _chunk_index = 0;\r\n\t// Pointers into current Array. Use first/last rather than begin/end for symmetry of moving forward/backward.\r\n\tpointer _first = 0;\r\n\tpointer _current = 0;\r\n\tpointer _last = 0;\r\n\t// Cache position across all chunks for support of random access.\r\n\tdifference_type _position = 0;\r\n};\r\n\r\n// This implementation is a subclass for Arrays that use GetView(i), GetString(i), etc.\r\n// Concrete subclass only needs to implement dereference(i).\r\ntemplate <typename ArrType>\r\nclass ChunkedArrayIteratorIndexImpl\r\n{\r\npublic:\r\n\tusing difference_type = int64_t;\r\n\r\n\texplicit ChunkedArrayIteratorIndexImpl(std::shared_ptr<arrow::ChunkedArray> ch_arr = 0, difference_type pos = 0)\r\n\t\t: _ch_arr(ch_arr)\r\n\t{\r\n\t\tset_position(pos);\r\n\t}\r\n\r\n\tbool IsNull() const\r\n\t{\r\n\t\tauto arr = _ch_arr->chunk(_chunk_index);\r\n\t\treturn arr->IsNull(_current);\r\n\t}\r\n\r\nprotected:\r\n\tfriend class boost::iterator_core_access;\r\n\r\n    bool equal(ChunkedArrayIteratorIndexImpl<ArrType> const& other) const\r\n    {\r\n        return this->_position == other._position;\r\n    }\r\n\r\n    void increment()\r\n\t{\r\n\t\t_position++;\r\n\t\t// Need to move to next chunk?\r\n\t\tif ((_current == _last) && ((_chunk_index+1) < _ch_arr->num_chunks()))\r\n\t\t{\r\n\t\t\t_chunk_index++;\r\n\t\t\tauto arr = _ch_arr->chunk(_chunk_index);\r\n\t\t\t_typed_arr = std::static_pointer_cast<ArrType>(arr);\r\n\t\t\t_last = arr->length() - 1;\r\n\t\t\t_current = 0;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t_current++;\r\n\t\t}\r\n\t}\r\n\r\n\tvoid decrement()\r\n\t{\r\n\t\t_position--;\r\n\t\t// Need to move to previous chunk?\r\n\t\tif ((_current == _first) && (_chunk_index > 0))\r\n\t\t{\r\n\t\t\t_chunk_index--;\r\n\t\t\tauto arr = _ch_arr->chunk(_chunk_index);\r\n\t\t\t_typed_arr = std::static_pointer_cast<ArrType>(arr);\r\n\t\t\t_last = arr->length() - 1;\r\n\t\t\t_current = _last;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t_current--;\r\n\t\t}\r\n\t}\r\n\r\n    // Value& dereference() const { return *_current; }\r\n\r\n\tvoid advance(difference_type n)\r\n\t{\r\n\t\t_position += n;\r\n\t\twhile (n > 0)\r\n\t\t{\r\n\t\t\tdifference_type max_delta = _last - _current;\r\n\t\t\tif ((max_delta >= n) || ((_chunk_index+1) == _ch_arr->num_chunks()))\r\n\t\t\t{\r\n\t\t\t\t_current += n;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// Move to next chunk.\r\n\t\t\tn -= max_delta;\r\n\t\t\t_chunk_index++;\r\n\t\t\tauto arr = _ch_arr->chunk(_chunk_index);\r\n\t\t\t_typed_arr = std::static_pointer_cast<ArrType>(arr);\r\n\t\t\t_last = arr->length() - 1;\r\n\t\t\t_current = 0;\r\n\t\t}\r\n\t\twhile (n < 0)\r\n\t\t{\r\n\t\t\tdifference_type max_delta = 0 - _current;\r\n\t\t\tif ((max_delta <= n) || (_chunk_index == 0))\r\n\t\t\t{\r\n\t\t\t\t_current += n;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// Move to previous chunk.\r\n\t\t\tn -= max_delta;\r\n\t\t\t_chunk_index--;\r\n\t\t\tauto arr = _ch_arr->chunk(_chunk_index);\r\n\t\t\t_typed_arr = std::static_pointer_cast<ArrType>(arr);\r\n\t\t\t_last = arr->length() - 1;\r\n\t\t\t_current = _last;\r\n\t\t}\r\n\t}\r\n\r\n\tdifference_type distance_to(ChunkedArrayIteratorIndexImpl<ArrType> const& other)\r\n\t{\r\n\t\treturn other._position - this->_position;\r\n\t}\r\n\r\n\t// Helper\r\n\tvoid set_position(difference_type pos)\r\n\t{\r\n\t\t_position = pos;\r\n\t\tconst int nchunks = _ch_arr->num_chunks();\r\n\t\tint64_t offset = 0;\r\n\t\tfor (_chunk_index = 0; _chunk_index < nchunks; _chunk_index++)\r\n\t\t{\r\n\t\t\tauto arr = _ch_arr->chunk(_chunk_index);\r\n\t\t\tint64_t arr_rows = arr->length();\r\n\t\t\tif (((offset+arr_rows) > pos) || ((_chunk_index+1)==nchunks))\r\n\t\t\t{\r\n\t\t\t\t_typed_arr = std::static_pointer_cast<ArrType>(arr);\r\n\t\t\t\t_last = arr_rows - 1;\r\n\t\t\t\t_current = (pos-offset);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\toffset += arr_rows;\r\n\t\t}\r\n\t\tassert(false);\r\n\t}\r\n\r\n\tstd::shared_ptr<arrow::ChunkedArray> _ch_arr;\r\n\t// Which Array we're looking at.\r\n\tint _chunk_index = 0;\r\n\t// Current Array. Use first/last rather than begin/end for symmetry of moving forward/backward.\r\n\tstd::shared_ptr<ArrType> _typed_arr;\r\n\tdifference_type _current = 0;\r\n\tdifference_type _last = 0;\r\n\t// Cache position across all chunks for support of random access.\r\n\tdifference_type _position = 0;\r\n};\r\n\r\nclass ChunkedArrayIteratorString :\r\n\tpublic ChunkedArrayIteratorIndexImpl<StringArray>,\r\n\tpublic boost::iterator_facade<ChunkedArrayIteratorString, const std::string, boost::random_access_traversal_tag>\r\n{\r\npublic:\r\n\tusing difference_type = int64_t;\r\n\tusing Value = const std::string;\r\n\r\n\texplicit ChunkedArrayIteratorString(std::shared_ptr<arrow::ChunkedArray> ch_arr = 0, difference_type pos = 0)\r\n\t\t: ChunkedArrayIteratorIndexImpl(ch_arr, pos)\r\n\t{\r\n\t}\r\n\r\n\t// Cache value to avoid returning pointer to temp.\r\n    Value& dereference() const { _cached = _typed_arr->GetString(_current); return _cached; }\r\n\r\nprivate:\r\n\tmutable std::string _cached;\r\n};\r\n\r\nclass ChunkedArrayIteratorBoolean :\r\n\tpublic ChunkedArrayIteratorIndexImpl<BooleanArray>,\r\n\tpublic boost::iterator_facade<ChunkedArrayIteratorBoolean, const bool, boost::random_access_traversal_tag>\r\n{\r\npublic:\r\n\tusing difference_type = int64_t;\r\n\tusing Value = const bool;\r\n\r\n\texplicit ChunkedArrayIteratorBoolean(std::shared_ptr<arrow::ChunkedArray> ch_arr = 0, difference_type pos = 0)\r\n\t\t: ChunkedArrayIteratorIndexImpl(ch_arr, pos)\r\n\t{\r\n\t}\r\n\r\n\t// Cache value to avoid returning pointer to temp.\r\n    Value& dereference() const { _cached = _typed_arr->GetView(_current); return _cached; }\r\n\r\nprivate:\r\n\tmutable bool _cached;\r\n};\r\n\r\n// STL container-like cover for arrow::ChunkedArray.\r\n// Only works for ChunkedArrays composed of Array types that support raw_values().\r\ntemplate<typename ArrType>\r\nclass ChunkedArrayCoverRaw\r\n{\r\npublic:\r\n\tusing T = typename ArrType::value_type;\r\n\t// Match size_type to Array offsets rather than using size_t and ptrdiff_t.\r\n\tusing size_type = int64_t;\r\n\tusing difference_type = int64_t;\r\n\tusing iterator = typename ChunkedArrayIteratorRaw<ArrType, T>;\r\n\tusing const_iterator = typename ChunkedArrayIteratorRaw<ArrType, const T>;;\r\n\tusing reverse_iterator = iterator;\r\n\tusing const_reverse_iterator = const_iterator;\r\n\r\n\tChunkedArrayCoverRaw(std::shared_ptr<ChunkedArray>& array) : _array(array) {}\r\n\r\n\tsize_type size() const { return _array->length(); }\r\n\r\n\t// Should non-const versions fail if Array is immutable?\r\n\titerator begin() { return iterator(_array); }\r\n\titerator end() { return iterator(_array, size()); }\r\n\treverse_iterator rbegin() { return iterator(_array, size()-1); }\r\n\treverse_iterator rend() { return iterator(_array, -1); }\r\n\tconst_iterator cbegin() const { return const_iterator(_array); }\r\n\tconst_iterator cend() const { return const_iterator(_array, size()); }\r\n\tconst_reverse_iterator crbegin() const { return const_iterator(_array, size()-1); }\r\n\tconst_reverse_iterator crend() const { return const_iterator(_array, -1); }\r\n\r\nprotected:\r\n\tstd::shared_ptr<ChunkedArray> _array;\r\n};\r\n\r\n\r\nint main(int argc, char *argv[])\r\n{\r\n\tauto fs = make_shared<fs::LocalFileSystem>();\r\n\tauto r_input = fs->OpenInputStream(\"c:/temp/_DatasetP14Seizures.csv\");\r\n\r\n\tauto pool = default_memory_pool();\r\n\tauto read_options = arrow::csv::ReadOptions::Defaults();\r\n\tauto parse_options = arrow::csv::ParseOptions::Defaults();\r\n\tauto convert_options = arrow::csv::ConvertOptions::Defaults();\r\n\r\n\tauto r_table_reader = csv::TableReader::Make(pool, r_input.ValueOrDie(),\r\n\t\tread_options, parse_options, convert_options);\r\n\tauto r_read = r_table_reader.ValueOrDie()->Read();\r\n\tauto pTable = r_read.ValueOrDie();\r\n\r\n\tPrettyPrintOptions options{0};\r\n\tarrow::PrettyPrint(*pTable, options, &std::cout);\r\n\r\n\t// Test covers and iterators.\r\n\tconst Table& tlb = *pTable;\r\n\tconst int64_t rows = tlb.num_rows();\r\n\tconst int cols = tlb.num_columns();\r\n\tfor (int c = 0; c < cols; c++)\r\n\t{\r\n\t\tauto f = tlb.field(c);\r\n\t\tconst string& name = f->name();\r\n\t\tint type_id = f->type()->id();\r\n\t\tauto ch_arr = tlb.column(c);\r\n\t\tswitch (type_id)\r\n\t\t{\r\n\t\tcase Type::DOUBLE:\r\n\t\t\t{\r\n#if 0\r\n\t\t\t\tusing iterator = ChunkedArrayIteratorRaw<arrow::DoubleArray, double>;\r\n\t\t\t\titerator it(ch_arr, 2);\r\n\t\t\t\tcout << it.IsNull() << endl;\r\n\t\t\t\tboost::iterator_range<iterator> range(it-2, it+8);\r\n\t\t\t\tfor (double val : range)\r\n\t\t\t\t \tcout << val << endl;\r\n#else\r\n\t\t\t\tusing cover = ChunkedArrayCoverRaw<arrow::DoubleArray>;\r\n\t\t\t\tusing iterator = typename cover::iterator;\r\n\t\t\t\tusing range = typename boost::iterator_range<iterator>;\r\n\t\t\t\tcover cvr(ch_arr);\r\n\t\t\t\tauto begin = cvr.begin();\r\n\t\t\t\tauto end = cvr.end();\r\n\t\t\t\tauto rbegin = cvr.rbegin();\r\n\t\t\t\tauto rend = cvr.rend();\r\n\t\t\t\tauto it = begin;\r\n\t\t\t\tit += 2;\r\n\t\t\t\tcout << it.IsNull() << endl;\r\n\t\t\t\trange rng(it-2, it+8);\r\n\t\t\t\tfor (double val : rng)\r\n\t\t\t\t \tcout << val << endl;\r\n#endif\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase Type::STRING:\r\n\t\t\t{\r\n\t\t\t\tusing iterator = ChunkedArrayIteratorString;\r\n\t\t\t\titerator it(ch_arr, 2);\r\n\t\t\t\tcout << it.IsNull() << endl;\r\n\t\t\t\tboost::iterator_range<iterator> range(it-2, it+8);\r\n\t\t\t\tfor (std::string val : range)\r\n\t\t\t\t \tcout << val << endl;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase Type::BOOL:\r\n\t\t\t{\r\n\t\t\t\tusing iterator = ChunkedArrayIteratorBoolean;\r\n\t\t\t\titerator it(ch_arr, 2);\r\n\t\t\t\tcout << it.IsNull() << endl;\r\n\t\t\t\tboost::iterator_range<iterator> range(it-2, it+8);\r\n\t\t\t\tfor (bool val : range)\r\n\t\t\t\t \tcout << val << endl;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\treturn 1;\r\n}\r\n\r\n\r\n```"
        },
        {
            "created_at": "2020-11-30T18:13:55.081Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-602?focusedCommentId=17240948) by Antoine Pitrou (apitrou):*\nSee also ARROW-10776"
        },
        {
            "created_at": "2021-12-13T11:48:58.891Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-602?focusedCommentId=17458338) by Antoine Pitrou (apitrou):*\nThere will be an API and code organization aspect to this.\r\n\r\n- API question: there are no typed subclasses for `ChunkedArray`, so we need another solution than simply putting `begin()` and `end()` methods on ChunkedArray\n- code organization issue: we don't want `chunked_array.h` to imply the inclusion of all type-specific array declarations, so probably need another solution\n  \n  My proposal would be to add a generic function `Iterate<Type>` in `stl_iterator.h`:\n  ```c++\n  \n  template <Type>\n  <some return type> Iterate(const Array&) { ... }\n  \n  template <Type>\n  <some return type> Iterate(const ChunkedArray&) { ... }\n  ```\n  \n  Writing the implementation should be reasonably easy."
        },
        {
            "created_at": "2022-05-11T16:54:37.769Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-602?focusedCommentId=17535016) by Antoine Pitrou (apitrou):*\nIssue resolved by pull request 13009\n<https://github.com/apache/arrow/pull/13009>"
        }
    ]
}