{
    "issue": {
        "title": "BaseListBuilder constructor should check the provided type is a list ",
        "body": "***Note**: This issue was originally created as [ARROW-13301](https://issues.apache.org/jira/browse/ARROW-13301). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nI've noticed that I can create a ListBuilder with a type that is not a ListType (in particular a StructType). \r\n\r\nI'm talking about the following constructor:\r\n```java\n\r\nBaseListBuilder(MemoryPool* pool, std::shared_ptr<ArrayBuilder> const& value_builder,\r\n                  const std::shared_ptr<DataType>& type)\r\n \n```\r\n\r\nI think this constructor should enforce that the given type is a ListType. \r\nIt could also possibly enforce that the type of the elements of the given ListType match the element of the value_build. \r\nAlternatively that constructor could be made private (since `BaseListBuilder(MemoryPool\\* pool, std::shared_ptr<ArrayBuilder> const& value_builder)` should be enough for most use case).\r\n\r\n\r\nHere's an example where I'm trying to create a \"ListType(list<item: struct<return_code: int32, message: string>>)\".\r\n\r\nWhen I create the ListBuilder I've noticed that I works with type set to:\r\n1. ListType(list<item: struct<return_code: int32, message: string>>) \n1. StructType(struct<return_code: int32, message: string>)\n   \n   In the first case the underlying type is: ListType(list<item: struct<return_code: int32, message: string>>)\n   \n   But in the second type the underlying type is ListType(list<return_code: struct<return_code: int32, message: string>>). The subtle difference is that the ListType field name has been changed from item to the name of the first element of the list (return_code).\n   \n   I  think it's because BaseListBuilder uses `type->field(0)` to get the name of the list field, but it uses `value_builder_->type()` to get the type.\n   \n   See: \n   \n   ```c++\n   \n     BaseListBuilder(MemoryPool* pool, std::shared_ptr<ArrayBuilder> const& value_builder,\n                     const std::shared_ptr<DataType>& type)\n         : ArrayBuilder(pool),\n           offsets_builder_(pool),\n           value_builder_(value_builder),\n           value_field_(type->field(0)->WithType(NULLPTR)) {}\n   // ...\n   std::shared_ptr<DataType> type() const override {\n       return std::make_shared<TYPE>(value_field_->WithType(value_builder_->type()));\n     }\n   \n   ```\n   \n   Here's an example that reproduce the issue:\n   \n   ```Java\n   \n   \n   \n   BOOST_AUTO_TEST_CASE(IsThereABugWithArrays) {\n     const arrow::FieldVector fields = {\n         arrow::field(\"return_code\", arrow::int32()),\n         arrow::field(\"message\", arrow::utf8())};\n   \n     const std::shared_ptr<arrow::DataType> struct_data_type =\n         arrow::struct_(fields);\n     const std::shared_ptr<arrow::DataType> list_of_struct_data_type =\n         arrow::list(struct_data_type);\n   \n     const std::shared_ptr<arrow::Schema> schema =\n         arrow::schema({arrow::field(\"search_results\", list_of_struct_data_type)});\n   \n     arrow::MemoryPool *pool = arrow::default_memory_pool();\n   \n     std::shared_ptr<arrow::Int32Builder> return_code_builder =\n         std::make_shared<arrow::Int32Builder>(pool);\n     std::shared_ptr<arrow::StringBuilder> message_builder =\n         std::make_shared<arrow::StringBuilder>(pool);\n     std::vector<std::shared_ptr<arrow::ArrayBuilder>> struct_fields_builders = {\n         return_code_builder, message_builder};\n   \n   \n     std::shared_ptr<arrow::StructBuilder> struct_builder =\n         std::make_shared<arrow::StructBuilder>(\n             struct_data_type, pool, struct_fields_builders);\n     std::shared_ptr<arrow::ListBuilder> list_builder(\n         std::make_shared<arrow::ListBuilder>(\n             pool, struct_builder, list_of_struct_data_type));\n   \n     BOOST_REQUIRE(list_builder->type()->Equals(list_of_struct_data_type));\n   \n     // This should not be allowed:\n     std::shared_ptr<arrow::ListBuilder> list_builder_using_struct_dtype(\n         std::make_shared<arrow::ListBuilder>(\n             pool, struct_builder, struct_data_type));\n   \n     std::shared_ptr<arrow::DataType> wrong_data_type = std::make_shared<arrow::ListType> (\n         arrow::field(\"return_code\", struct_data_type)\n         );\n   \n     BOOST_REQUIRE(!list_builder_using_struct_dtype->type()->Equals(list_of_struct_data_type));\n     BOOST_REQUIRE(list_builder_using_struct_dtype->type()->Equals(wrong_data_type));\n   \n   }\n   ```\n   \n   \n   \n   \n   \n",
        "created_at": "2021-07-11T12:12:23.000Z",
        "updated_at": "2021-07-11T12:12:23.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Type: enhancement"
        ],
        "closed": false
    },
    "comments": []
}