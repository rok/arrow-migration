{
    "issue": {
        "title": "[C++] Avoid warnings that ExecBatch::length may be uninitialized",
        "body": "***Note**: This issue was originally created as [ARROW-18135](https://issues.apache.org/jira/browse/ARROW-18135). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nHere is a build log of the master branch that shows the warnings:\r\n```java\n\r\n[131/534] Building CXX object src/arrow/CMakeFiles/arrow_objlib.dir/compute/exec/exec_plan.cc.o\r\nIn file included from /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/exec/exec_plan.cc:25:\r\nIn constructor \u2018arrow::compute::ExecBatch::ExecBatch(arrow::compute::ExecBatch&&)\u2019,\r\n\u00a0 \u00a0 inlined from \u2018arrow::compute::DeclarationToExecBatchesAsync(arrow::compute::Declaration, arrow::compute::ExecContext*)::<lambda()>::<lambda(std::optional<arrow::compute::ExecBatch>)>\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/exec/exec_plan.cc:605:73,\r\n\u00a0 \u00a0 inlined from \u2018_OIter std::transform(_IIter, _IIter, _OIter, _UnaryOperation) [with _IIter = std::move_iterator<__gnu_cxx::__normal_iterator<std::optional<arrow::compute::ExecBatch>*, std::vector<std::optional<arrow::compute::ExecBatch>, std::allocator<std::optional<arrow::compute::ExecBatch> > > > >; _OIter = std::back_insert_iterator<std::vector<arrow::compute::ExecBatch> >; _UnaryOperation = arrow::compute::DeclarationToExecBatchesAsync(arrow::compute::Declaration, arrow::compute::ExecContext*)::<lambda()>::<lambda(std::optional<arrow::compute::ExecBatch>)>]\u2019 at /usr/include/c++/11/bits/stl_algo.h:4296:12,\r\n\u00a0 \u00a0 inlined from \u2018std::vector<To> arrow::internal::MapVector(Fn&&, std::vector<_ValT>&&) [with Fn = arrow::compute::DeclarationToExecBatchesAsync(arrow::compute::Declaration, arrow::compute::ExecContext*)::<lambda()>::<lambda(std::optional<arrow::compute::ExecBatch>)>; From = std::optional<arrow::compute::ExecBatch>; To = arrow::compute::ExecBatch]\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/util/vector.h:102:17,\r\n\u00a0 \u00a0 inlined from \u2018arrow::compute::DeclarationToExecBatchesAsync(arrow::compute::Declaration, arrow::compute::ExecContext*)::<lambda()>\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/exec/exec_plan.cc:604:44,\r\n\u00a0 \u00a0 inlined from \u2018typename std::enable_if<(((! std::is_void<ContinueResult>::value) && (! arrow::detail::is_future<ContinueResult>::value)) && ((! NextFuture::is_empty) || std::is_same<ContinueResult, arrow::Status>::value))>::type arrow::detail::ContinueFuture::operator()(NextFuture, ContinueFunc&&, Args&& ...) const [with ContinueFunc = arrow::compute::DeclarationToExecBatchesAsync(arrow::compute::Declaration, arrow::compute::ExecContext*)::<lambda()>; Args = {}; ContinueResult = arrow::Result<std::vector<arrow::compute::ExecBatch> >; NextFuture = arrow::Future<std::vector<arrow::compute::ExecBatch> >]\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/util/future.h:150:22,\r\n\u00a0 \u00a0 inlined from \u2018void arrow::detail::ContinueFuture::IgnoringArgsIf(std::true_type, NextFuture&&, ContinueFunc&&, Args&& ...) const [with ContinueFunc = arrow::compute::DeclarationToExecBatchesAsync(arrow::compute::Declaration, arrow::compute::ExecContext*)::<lambda()>; NextFuture = arrow::Future<std::vector<arrow::compute::ExecBatch> >; Args = {const arrow::internal::Empty&}]\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/util/future.h:188:15,\r\n\u00a0 \u00a0 inlined from \u2018void arrow::Future<T>::ThenOnComplete<OnSuccess, OnFailure>::operator()(const arrow::Result<T>&) && [with OnSuccess = arrow::compute::DeclarationToExecBatchesAsync(arrow::compute::Declaration, arrow::compute::ExecContext*)::<lambda()>; OnFailure = arrow::Future<>::PassthruOnFailure<arrow::compute::DeclarationToExecBatchesAsync(arrow::compute::Declaration, arrow::compute::ExecContext*)::<lambda()> >; T = arrow::internal::Empty]\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/util/future.h:545:39:\r\n/mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/exec.h:179:21: warning: \u2018*(arrow::compute::ExecBatch*)((char*)&<unnamed> + offsetof(std::optional<arrow::compute::ExecBatch>,std::optional<arrow::compute::ExecBatch>::<unnamed>.std::_Optional_base<arrow::compute::ExecBatch, false, false>::<unnamed>)).arrow::compute::ExecBatch::length\u2019 may be used uninitialized [-Wmaybe-uninitialized]\r\n\u00a0 179 | struct ARROW_EXPORT ExecBatch {\r\n\u00a0 \u00a0 \u00a0 | \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ^~~~~~~~~\r\nIn file included from /usr/include/c++/11/functional:65,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0from /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/exec/exec_plan.h:22,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0from /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/exec/exec_plan.cc:18:\r\n/usr/include/c++/11/bits/stl_algo.h: In member function \u2018void arrow::Future<T>::ThenOnComplete<OnSuccess, OnFailure>::operator()(const arrow::Result<T>&) && [with OnSuccess = arrow::compute::DeclarationToExecBatchesAsync(arrow::compute::Declaration, arrow::compute::ExecContext*)::<lambda()>; OnFailure = arrow::Future<>::PassthruOnFailure<arrow::compute::DeclarationToExecBatchesAsync(arrow::compute::Declaration, arrow::compute::ExecContext*)::<lambda()> >; T = arrow::internal::Empty]\u2019:\r\n/usr/include/c++/11/bits/stl_algo.h:4296:31: note: \u2018<anonymous>\u2019 declared here\r\n\u00a04296 | \u00a0 \u00a0 \u00a0 \u00a0 *__result = __unary_op(*__first);\r\n\u00a0 \u00a0 \u00a0 | \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ~~~~~~~~~~^~~~~~~~~~\r\n[247/534] Building CXX object src/arrow/CMakeFiles/arrow_testing_objlib.dir/compute/exec/test_util.cc.o\r\nIn file included from /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/exec/test_util.h:29,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0from /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/exec/test_util.cc:18:\r\nIn constructor \u2018arrow::compute::ExecBatch::ExecBatch(arrow::compute::ExecBatch&&)\u2019,\r\n\u00a0 \u00a0 inlined from \u2018arrow::compute::StartAndCollect(arrow::compute::ExecPlan*, arrow::AsyncGenerator<std::optional<arrow::compute::ExecBatch> >)::<lambda()>::<lambda(std::optional<arrow::compute::ExecBatch>)>\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/exec/test_util.cc:192:73,\r\n\u00a0 \u00a0 inlined from \u2018_OIter std::transform(_IIter, _IIter, _OIter, _UnaryOperation) [with _IIter = std::move_iterator<__gnu_cxx::__normal_iterator<std::optional<arrow::compute::ExecBatch>*, std::vector<std::optional<arrow::compute::ExecBatch>, std::allocator<std::optional<arrow::compute::ExecBatch> > > > >; _OIter = std::back_insert_iterator<std::vector<arrow::compute::ExecBatch> >; _UnaryOperation = arrow::compute::StartAndCollect(arrow::compute::ExecPlan*, arrow::AsyncGenerator<std::optional<arrow::compute::ExecBatch> >)::<lambda()>::<lambda(std::optional<arrow::compute::ExecBatch>)>]\u2019 at /usr/include/c++/11/bits/stl_algo.h:4296:12,\r\n\u00a0 \u00a0 inlined from \u2018std::vector<To> arrow::internal::MapVector(Fn&&, std::vector<From>&&) [with Fn = arrow::compute::StartAndCollect(arrow::compute::ExecPlan*, arrow::AsyncGenerator<std::optional<arrow::compute::ExecBatch> >)::<lambda()>::<lambda(std::optional<arrow::compute::ExecBatch>)>; From = std::optional<arrow::compute::ExecBatch>; To = arrow::compute::ExecBatch]\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/util/vector.h:102:17,\r\n\u00a0 \u00a0 inlined from \u2018arrow::compute::StartAndCollect(arrow::compute::ExecPlan*, arrow::AsyncGenerator<std::optional<arrow::compute::ExecBatch> >)::<lambda()>\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/exec/test_util.cc:191:44,\r\n\u00a0 \u00a0 inlined from \u2018typename std::enable_if<(((! std::is_void<ContinueResult>::value) && (! arrow::detail::is_future<ContinueResult>::value)) && ((! NextFuture::is_empty) || std::is_same<ContinueResult, arrow::Status>::value))>::type arrow::detail::ContinueFuture::operator()(NextFuture, ContinueFunc&&, Args&& ...) const [with ContinueFunc = arrow::compute::StartAndCollect(arrow::compute::ExecPlan*, arrow::AsyncGenerator<std::optional<arrow::compute::ExecBatch> >)::<lambda()>; Args = {}; ContinueResult = arrow::Result<std::vector<arrow::compute::ExecBatch> >; NextFuture = arrow::Future<std::vector<arrow::compute::ExecBatch> >]\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/util/future.h:150:22,\r\n\u00a0 \u00a0 inlined from \u2018void arrow::detail::ContinueFuture::IgnoringArgsIf(std::true_type, NextFuture&&, ContinueFunc&&, Args&& ...) const [with ContinueFunc = arrow::compute::StartAndCollect(arrow::compute::ExecPlan*, arrow::AsyncGenerator<std::optional<arrow::compute::ExecBatch> >)::<lambda()>; NextFuture = arrow::Future<std::vector<arrow::compute::ExecBatch> >; Args = {const arrow::internal::Empty&}]\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/util/future.h:188:15,\r\n\u00a0 \u00a0 inlined from \u2018void arrow::Future<T>::ThenOnComplete<OnSuccess, OnFailure>::operator()(const arrow::Result<T>&) && [with OnSuccess = arrow::compute::StartAndCollect(arrow::compute::ExecPlan*, arrow::AsyncGenerator<std::optional<arrow::compute::ExecBatch> >)::<lambda()>; OnFailure = arrow::Future<>::PassthruOnFailure<arrow::compute::StartAndCollect(arrow::compute::ExecPlan*, arrow::AsyncGenerator<std::optional<arrow::compute::ExecBatch> >)::<lambda()> >; T = arrow::internal::Empty]\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/util/future.h:545:39,\r\n\u00a0 \u00a0 inlined from \u2018void arrow::Future<T>::WrapResultyOnComplete::Callback<OnComplete>::operator()(const arrow::FutureImpl&) && [with OnComplete = arrow::Future<>::ThenOnComplete<arrow::compute::StartAndCollect(arrow::compute::ExecPlan*, arrow::AsyncGenerator<std::optional<arrow::compute::ExecBatch> >)::<lambda()>, arrow::Future<>::PassthruOnFailure<arrow::compute::StartAndCollect(arrow::compute::ExecPlan*, arrow::AsyncGenerator<std::optional<arrow::compute::ExecBatch> >)::<lambda()> > >; T = arrow::internal::Empty]\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/util/future.h:442:31,\r\n\u00a0 \u00a0 inlined from \u2018R arrow::internal::FnOnce<R(A ...)>::FnImpl<Fn>::invoke(A&& ...) [with Fn = arrow::Future<>::WrapResultyOnComplete::Callback<arrow::Future<>::ThenOnComplete<arrow::compute::StartAndCollect(arrow::compute::ExecPlan*, arrow::AsyncGenerator<std::optional<arrow::compute::ExecBatch> >)::<lambda()>, arrow::Future<>::PassthruOnFailure<arrow::compute::StartAndCollect(arrow::compute::ExecPlan*, arrow::AsyncGenerator<std::optional<arrow::compute::ExecBatch> >)::<lambda()> > > >; R = void; A = {const arrow::FutureImpl&}]\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/util/functional.h:152:56:\r\n/mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/exec.h:179:21: warning: \u2018*(arrow::compute::ExecBatch*)((char*)&<unnamed> + offsetof(std::optional<arrow::compute::ExecBatch>,std::optional<arrow::compute::ExecBatch>::<unnamed>.std::_Optional_base<arrow::compute::ExecBatch, false, false>::<unnamed>)).arrow::compute::ExecBatch::length\u2019 may be used uninitialized [-Wmaybe-uninitialized]\r\n\u00a0 179 | struct ARROW_EXPORT ExecBatch {\r\n\u00a0 \u00a0 \u00a0 | \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ^~~~~~~~~\r\nIn file included from /usr/include/c++/11/algorithm:62,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0from /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/testing/gtest_util.h:20,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0from /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/exec/test_util.h:20,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0from /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/exec/test_util.cc:18:\r\n/usr/include/c++/11/bits/stl_algo.h: In member function \u2018R arrow::internal::FnOnce<R(A ...)>::FnImpl<Fn>::invoke(A&& ...) [with Fn = arrow::Future<>::WrapResultyOnComplete::Callback<arrow::Future<>::ThenOnComplete<arrow::compute::StartAndCollect(arrow::compute::ExecPlan*, arrow::AsyncGenerator<std::optional<arrow::compute::ExecBatch> >)::<lambda()>, arrow::Future<>::PassthruOnFailure<arrow::compute::StartAndCollect(arrow::compute::ExecPlan*, arrow::AsyncGenerator<std::optional<arrow::compute::ExecBatch> >)::<lambda()> > > >; R = void; A = {const arrow::FutureImpl&}]\u2019:\r\n/usr/include/c++/11/bits/stl_algo.h:4296:31: note: \u2018<anonymous>\u2019 declared here\r\n\u00a04296 | \u00a0 \u00a0 \u00a0 \u00a0 *__result = __unary_op(*__first);\r\n\u00a0 \u00a0 \u00a0 | \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ~~~~~~~~~~^~~~~~~~~~\r\n[381/534] Building CXX object src/arrow/compute/kernels/CMakeFiles/arrow-compute-aggregate-test.dir/hash_aggregate_test.cc.o\r\nIn file included from /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/kernel.h:32,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0from /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/function.h:27,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0from /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/api_aggregate.h:23,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0from /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/kernels/hash_aggregate_test.cc:31:\r\nIn constructor \u2018arrow::compute::ExecBatch::ExecBatch(arrow::compute::ExecBatch&&)\u2019,\r\n\u00a0 \u00a0 inlined from \u2018arrow::compute::{anonymous}::GroupByUsingExecPlan(const arrow::compute::BatchesWithSchema&, const std::vector<std::__cxx11::basic_string<char> >&, const std::vector<arrow::compute::Aggregate>&, bool, arrow::compute::ExecContext*)::<lambda()>::<lambda(std::optional<arrow::compute::ExecBatch>)>\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/kernels/hash_aggregate_test.cc:155:77,\r\n\u00a0 \u00a0 inlined from \u2018_OIter std::transform(_IIter, _IIter, _OIter, _UnaryOperation) [with _IIter = std::move_iterator<__gnu_cxx::__normal_iterator<std::optional<arrow::compute::ExecBatch>*, std::vector<std::optional<arrow::compute::ExecBatch>, std::allocator<std::optional<arrow::compute::ExecBatch> > > > >; _OIter = std::back_insert_iterator<std::vector<arrow::compute::ExecBatch> >; _UnaryOperation = arrow::compute::{anonymous}::GroupByUsingExecPlan(const arrow::compute::BatchesWithSchema&, const std::vector<std::__cxx11::basic_string<char> >&, const std::vector<arrow::compute::Aggregate>&, bool, arrow::compute::ExecContext*)::<lambda()>::<lambda(std::optional<arrow::compute::ExecBatch>)>]\u2019 at /usr/include/c++/11/bits/stl_algo.h:4296:12,\r\n\u00a0 \u00a0 inlined from \u2018std::vector<To> arrow::internal::MapVector(Fn&&, std::vector<_ValT>&&) [with Fn = arrow::compute::{anonymous}::GroupByUsingExecPlan(const arrow::compute::BatchesWithSchema&, const std::vector<std::__cxx11::basic_string<char> >&, const std::vector<arrow::compute::Aggregate>&, bool, arrow::compute::ExecContext*)::<lambda()>::<lambda(std::optional<arrow::compute::ExecBatch>)>; From = std::optional<arrow::compute::ExecBatch>; To = arrow::compute::ExecBatch]\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/util/vector.h:102:17,\r\n\u00a0 \u00a0 inlined from \u2018arrow::compute::{anonymous}::GroupByUsingExecPlan(const arrow::compute::BatchesWithSchema&, const std::vector<std::__cxx11::basic_string<char> >&, const std::vector<arrow::compute::Aggregate>&, bool, arrow::compute::ExecContext*)::<lambda()>\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/kernels/hash_aggregate_test.cc:154:48,\r\n\u00a0 \u00a0 inlined from \u2018typename std::enable_if<(((! std::is_void<ContinueResult>::value) && (! arrow::detail::is_future<ContinueResult>::value)) && ((! NextFuture::is_empty) || std::is_same<ContinueResult, arrow::Status>::value))>::type arrow::detail::ContinueFuture::operator()(NextFuture, ContinueFunc&&, Args&& ...) const [with ContinueFunc = arrow::compute::{anonymous}::GroupByUsingExecPlan(const arrow::compute::BatchesWithSchema&, const std::vector<std::__cxx11::basic_string<char> >&, const std::vector<arrow::compute::Aggregate>&, bool, arrow::compute::ExecContext*)::<lambda()>; Args = {}; ContinueResult = arrow::Result<std::vector<arrow::compute::ExecBatch> >; NextFuture = arrow::Future<std::vector<arrow::compute::ExecBatch> >]\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/util/future.h:150:22,\r\n\u00a0 \u00a0 inlined from \u2018void arrow::detail::ContinueFuture::IgnoringArgsIf(std::true_type, NextFuture&&, ContinueFunc&&, Args&& ...) const [with ContinueFunc = arrow::compute::{anonymous}::GroupByUsingExecPlan(const arrow::compute::BatchesWithSchema&, const std::vector<std::__cxx11::basic_string<char> >&, const std::vector<arrow::compute::Aggregate>&, bool, arrow::compute::ExecContext*)::<lambda()>; NextFuture = arrow::Future<std::vector<arrow::compute::ExecBatch> >; Args = {const arrow::internal::Empty&}]\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/util/future.h:188:15,\r\n\u00a0 \u00a0 inlined from \u2018void arrow::Future<T>::ThenOnComplete<OnSuccess, OnFailure>::operator()(const arrow::Result<T>&) && [with OnSuccess = arrow::compute::{anonymous}::GroupByUsingExecPlan(const arrow::compute::BatchesWithSchema&, const std::vector<std::__cxx11::basic_string<char> >&, const std::vector<arrow::compute::Aggregate>&, bool, arrow::compute::ExecContext*)::<lambda()>; OnFailure = arrow::Future<>::PassthruOnFailure<arrow::compute::{anonymous}::GroupByUsingExecPlan(const arrow::compute::BatchesWithSchema&, const std::vector<std::__cxx11::basic_string<char> >&, const std::vector<arrow::compute::Aggregate>&, bool, arrow::compute::ExecContext*)::<lambda()> >; T = arrow::internal::Empty]\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/util/future.h:545:39,\r\n\u00a0 \u00a0 inlined from \u2018void arrow::Future<T>::WrapResultyOnComplete::Callback<OnComplete>::operator()(const arrow::FutureImpl&) && [with OnComplete = arrow::Future<>::ThenOnComplete<arrow::compute::{anonymous}::GroupByUsingExecPlan(const arrow::compute::BatchesWithSchema&, const std::vector<std::__cxx11::basic_string<char> >&, const std::vector<arrow::compute::Aggregate>&, bool, arrow::compute::ExecContext*)::<lambda()>, arrow::Future<>::PassthruOnFailure<arrow::compute::{anonymous}::GroupByUsingExecPlan(const arrow::compute::BatchesWithSchema&, const std::vector<std::__cxx11::basic_string<char> >&, const std::vector<arrow::compute::Aggregate>&, bool, arrow::compute::ExecContext*)::<lambda()> > >; T = arrow::internal::Empty]\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/util/future.h:442:31,\r\n\u00a0 \u00a0 inlined from \u2018R arrow::internal::FnOnce<R(A ...)>::FnImpl<Fn>::invoke(A&& ...) [with Fn = arrow::Future<>::WrapResultyOnComplete::Callback<arrow::Future<>::ThenOnComplete<arrow::compute::{anonymous}::GroupByUsingExecPlan(const arrow::compute::BatchesWithSchema&, const std::vector<std::__cxx11::basic_string<char> >&, const std::vector<arrow::compute::Aggregate>&, bool, arrow::compute::ExecContext*)::<lambda()>, arrow::Future<>::PassthruOnFailure<arrow::compute::{anonymous}::GroupByUsingExecPlan(const arrow::compute::BatchesWithSchema&, const std::vector<std::__cxx11::basic_string<char> >&, const std::vector<arrow::compute::Aggregate>&, bool, arrow::compute::ExecContext*)::<lambda()> > > >; R = void; A = {const arrow::FutureImpl&}]\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/util/functional.h:152:56:\r\n/mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/exec.h:179:21: warning: \u2018*(arrow::compute::ExecBatch*)((char*)&<unnamed> + offsetof(std::optional<arrow::compute::ExecBatch>,std::optional<arrow::compute::ExecBatch>::<unnamed>.std::_Optional_base<arrow::compute::ExecBatch, false, false>::<unnamed>)).arrow::compute::ExecBatch::length\u2019 may be used uninitialized [-Wmaybe-uninitialized]\r\n\u00a0 179 | struct ARROW_EXPORT ExecBatch {\r\n\u00a0 \u00a0 \u00a0 | \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ^~~~~~~~~\r\nIn file included from /usr/include/c++/11/functional:65,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0from /usr/include/gtest/gtest-printers.h:103,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0from /usr/include/gtest/gtest-matchers.h:44,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0from /usr/include/gtest/internal/gtest-death-test-internal.h:39,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0from /usr/include/gtest/gtest-death-test.h:41,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0from /usr/include/gtest/gtest.h:64,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0from /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/kernels/hash_aggregate_test.cc:18:\r\n/usr/include/c++/11/bits/stl_algo.h: In member function \u2018R arrow::internal::FnOnce<R(A ...)>::FnImpl<Fn>::invoke(A&& ...) [with Fn = arrow::Future<>::WrapResultyOnComplete::Callback<arrow::Future<>::ThenOnComplete<arrow::compute::{anonymous}::GroupByUsingExecPlan(const arrow::compute::BatchesWithSchema&, const std::vector<std::__cxx11::basic_string<char> >&, const std::vector<arrow::compute::Aggregate>&, bool, arrow::compute::ExecContext*)::<lambda()>, arrow::Future<>::PassthruOnFailure<arrow::compute::{anonymous}::GroupByUsingExecPlan(const arrow::compute::BatchesWithSchema&, const std::vector<std::__cxx11::basic_string<char> >&, const std::vector<arrow::compute::Aggregate>&, bool, arrow::compute::ExecContext*)::<lambda()> > > >; R = void; A = {const arrow::FutureImpl&}]\u2019:\r\n/usr/include/c++/11/bits/stl_algo.h:4296:31: note: \u2018<anonymous>\u2019 declared here\r\n\u00a04296 | \u00a0 \u00a0 \u00a0 \u00a0 *__result = __unary_op(*__first);\r\n\u00a0 \u00a0 \u00a0 | \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ~~~~~~~~~~^~~~~~~~~~\r\n[466/534] Building CXX object src/arrow/dataset/CMakeFiles/arrow-dataset-scanner-test.dir/scanner_test.cc.o\r\nIn file included from /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/kernel.h:32,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0from /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/function.h:27,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0from /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/api_aggregate.h:23,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0from /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/exec/options.h:26,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0from /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/dataset/scanner.h:29,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0from /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/dataset/scanner_test.cc:18:\r\nIn constructor \u2018arrow::compute::ExecBatch::ExecBatch(arrow::compute::ExecBatch&&)\u2019,\r\n\u00a0 \u00a0 inlined from \u2018arrow::dataset::{anonymous}::TestPlan::Run()::<lambda()>::<lambda(std::optional<arrow::compute::ExecBatch>)>\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/dataset/scanner_test.cc:2160:84,\r\n\u00a0 \u00a0 inlined from \u2018_OIter std::transform(_IIter, _IIter, _OIter, _UnaryOperation) [with _IIter = std::move_iterator<__gnu_cxx::__normal_iterator<std::optional<arrow::compute::ExecBatch>*, std::vector<std::optional<arrow::compute::ExecBatch>, std::allocator<std::optional<arrow::compute::ExecBatch> > > > >; _OIter = std::back_insert_iterator<std::vector<arrow::compute::ExecBatch> >; _UnaryOperation = arrow::dataset::{anonymous}::TestPlan::Run()::<lambda()>::<lambda(std::optional<arrow::compute::ExecBatch>)>]\u2019 at /usr/include/c++/11/bits/stl_algo.h:4296:12,\r\n\u00a0 \u00a0 inlined from \u2018std::vector<To> arrow::internal::MapVector(Fn&&, std::vector<_ValT>&&) [with Fn = arrow::dataset::{anonymous}::TestPlan::Run()::<lambda()>::<lambda(std::optional<arrow::compute::ExecBatch>)>; From = std::optional<arrow::compute::ExecBatch>; To = arrow::compute::ExecBatch]\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/util/vector.h:102:17,\r\n\u00a0 \u00a0 inlined from \u2018arrow::dataset::{anonymous}::TestPlan::Run()::<lambda()>\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/dataset/scanner_test.cc:2159:46,\r\n\u00a0 \u00a0 inlined from \u2018typename std::enable_if<(((! std::is_void<ContinueResult>::value) && (! arrow::detail::is_future<ContinueResult>::value)) && ((! NextFuture::is_empty) || std::is_same<ContinueResult, arrow::Status>::value))>::type arrow::detail::ContinueFuture::operator()(NextFuture, ContinueFunc&&, Args&& ...) const [with ContinueFunc = arrow::dataset::{anonymous}::TestPlan::Run()::<lambda()>; Args = {}; ContinueResult = arrow::Result<std::vector<arrow::compute::ExecBatch> >; NextFuture = arrow::Future<std::vector<arrow::compute::ExecBatch> >]\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/util/future.h:150:22,\r\n\u00a0 \u00a0 inlined from \u2018void arrow::detail::ContinueFuture::IgnoringArgsIf(std::true_type, NextFuture&&, ContinueFunc&&, Args&& ...) const [with ContinueFunc = arrow::dataset::{anonymous}::TestPlan::Run()::<lambda()>; NextFuture = arrow::Future<std::vector<arrow::compute::ExecBatch> >; Args = {const arrow::internal::Empty&}]\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/util/future.h:188:15,\r\n\u00a0 \u00a0 inlined from \u2018void arrow::Future<T>::ThenOnComplete<OnSuccess, OnFailure>::operator()(const arrow::Result<T>&) && [with OnSuccess = arrow::dataset::{anonymous}::TestPlan::Run()::<lambda()>; OnFailure = arrow::Future<>::PassthruOnFailure<arrow::dataset::{anonymous}::TestPlan::Run()::<lambda()> >; T = arrow::internal::Empty]\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/util/future.h:545:39,\r\n\u00a0 \u00a0 inlined from \u2018void arrow::Future<T>::WrapResultyOnComplete::Callback<OnComplete>::operator()(const arrow::FutureImpl&) && [with OnComplete = arrow::Future<>::ThenOnComplete<arrow::dataset::{anonymous}::TestPlan::Run()::<lambda()>, arrow::Future<>::PassthruOnFailure<arrow::dataset::{anonymous}::TestPlan::Run()::<lambda()> > >; T = arrow::internal::Empty]\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/util/future.h:442:31,\r\n\u00a0 \u00a0 inlined from \u2018R arrow::internal::FnOnce<R(A ...)>::FnImpl<Fn>::invoke(A&& ...) [with Fn = arrow::Future<>::WrapResultyOnComplete::Callback<arrow::Future<>::ThenOnComplete<arrow::dataset::{anonymous}::TestPlan::Run()::<lambda()>, arrow::Future<>::PassthruOnFailure<arrow::dataset::{anonymous}::TestPlan::Run()::<lambda()> > > >; R = void; A = {const arrow::FutureImpl&}]\u2019 at /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/util/functional.h:152:56:\r\n/mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/exec.h:179:21: warning: \u2018*(arrow::compute::ExecBatch*)((char*)&<unnamed> + offsetof(std::optional<arrow::compute::ExecBatch>,std::optional<arrow::compute::ExecBatch>::<unnamed>.std::_Optional_base<arrow::compute::ExecBatch, false, false>::<unnamed>)).arrow::compute::ExecBatch::length\u2019 may be used uninitialized [-Wmaybe-uninitialized]\r\n\u00a0 179 | struct ARROW_EXPORT ExecBatch {\r\n\u00a0 \u00a0 \u00a0 | \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ^~~~~~~~~\r\nIn file included from /usr/include/c++/11/functional:65,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0from /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/dataset/scanner.h:22,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0from /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/dataset/scanner_test.cc:18:\r\n/usr/include/c++/11/bits/stl_algo.h: In member function \u2018R arrow::internal::FnOnce<R(A ...)>::FnImpl<Fn>::invoke(A&& ...) [with Fn = arrow::Future<>::WrapResultyOnComplete::Callback<arrow::Future<>::ThenOnComplete<arrow::dataset::{anonymous}::TestPlan::Run()::<lambda()>, arrow::Future<>::PassthruOnFailure<arrow::dataset::{anonymous}::TestPlan::Run()::<lambda()> > > >; R = void; A = {const arrow::FutureImpl&}]\u2019:\r\n/usr/include/c++/11/bits/stl_algo.h:4296:31: note: \u2018<anonymous>\u2019 declared here\r\n\u00a04296 | \u00a0 \u00a0 \u00a0 \u00a0 *__result = __unary_op(*__first);\r\n\u00a0 \u00a0 \u00a0 | \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ~~~~~~~~~~^~~~~~~~~~\r\n[534/534] Linking CXX executable release/parquet-schema-test \n```",
        "created_at": "2022-10-23T06:43:36.000Z",
        "updated_at": "2022-10-28T14:22:44.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Type: enhancement"
        ],
        "closed": true,
        "closed_at": "2022-10-26T12:11:55.000Z"
    },
    "comments": [
        {
            "created_at": "2022-10-26T12:11:55.776Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-18135?focusedCommentId=17624410) by Antoine Pitrou (apitrou):*\nIssue resolved by pull request 14480\n<https://github.com/apache/arrow/pull/14480>"
        }
    ]
}