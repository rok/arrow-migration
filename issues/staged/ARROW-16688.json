{
    "issue": {
        "title": "[R][Python] Extension types cannot be registered in both R and Python",
        "body": "***Note**: This issue was originally created as [ARROW-16688](https://issues.apache.org/jira/browse/ARROW-16688). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nWhen registering extension types as is now possible in the R bindings, it looks as though we cannot register an extension type in R and Python at the same time:\r\n\r\n```R\n\r\n# apache/arrow@master\r\nlibrary(arrow, warn.conflicts = FALSE)\r\nlibrary(reticulate)\r\n\r\n# this is a virtualenv with pyarrow installed against the same commit\r\nuse_virtualenv(\r\n  \"/Users/deweydunnington/Desktop/rscratch/pyarrow-dev\",\r\n  required = TRUE\r\n)\r\n\r\npa <- import(\"pyarrow\")\r\npa[[\"__version__\"]]\r\n#> [1] \"9.0.0.dev131+g8a36f0f6c\"\r\n\r\npy_run_string(\"\r\nimport pyarrow as pa\r\n\r\nclass TestExtensionType(pa.ExtensionType):\r\n    \r\n    def __init__(self):\r\n        super().__init__(pa.int32(), 'arrow.test_type')\r\n    \r\n    def __arrow_ext_serialize__(self):\r\n        return b''\r\n\r\n    @classmethod\r\n    def __arrow_ext_deserialize__(cls, storage_type, serialized):\r\n        return cls()\r\n\r\n\r\npa.register_extension_type(TestExtensionType())\r\n\")\r\n\r\narrow::register_extension_type(\r\n  arrow::new_extension_type(int32(), \"arrow.test_type\")\r\n)\r\n#> Error: Key error: A type extension with name arrow.test_type already defined\r\n```\r\n\r\nI also get a segfault if I try to surface a Python type into R (probably because the R bindings mistakenly assume that if `type.id() == Type::EXTENSION` then it is safe to cast to our own `ExtensionType` C++ subclass that implements R-specific things.\r\n\r\nThis came about because the 'geoarrow' Python and 'geoarrow' R packages both register a number of extension type definitions.\r\n\r\n- geoarrow's Python registration: https://github.com/jorisvandenbossche/python-geoarrow/blob/main/src/geoarrow/extension_types.py#L108-L117\n- geoarrow's R registration: https://github.com/paleolimbot/geoarrow/blob/master/R/pkg-arrow.R#L208-L223\n  \n  I can also force an interaction if I build GDAL against the same Arrow that the arrow R package is linked against and attempt to load a Feather file saved with an extension type using the sf package. I will attempt to recreate that interaction as well in both R and Python.\n  \n  I don't know enough about linking to know to what extent this is linked to my own development setup/build of the R package, although I think there are at least some environments where a shared library is picked up first by the R config script (fedora36, for example). It does look like my own R package build is dynamically linking to libarrow.dylib.",
        "created_at": "2022-05-30T18:41:10.000Z",
        "updated_at": "2022-06-01T10:39:43.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: Python",
            "Component: R",
            "Type: enhancement"
        ],
        "closed": false
    },
    "comments": [
        {
            "created_at": "2022-05-30T18:41:37.607Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16688?focusedCommentId=17544033) by Dewey Dunnington (paleolimbot):*\ncc `[~jorisvandenbossche]`"
        },
        {
            "created_at": "2022-05-30T19:26:43.089Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16688?focusedCommentId=17544038) by Antoine Pitrou (apitrou):*\n> probably because the R bindings mistakenly assume that if type.id() == Type::EXTENSION then it is safe to cast to our own ExtensionType C++ subclass that implements R-specific things\r\n\r\nThat would be the first thing to fix IMHO."
        },
        {
            "created_at": "2022-05-30T19:27:09.245Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16688?focusedCommentId=17544039) by Antoine Pitrou (apitrou):*\nAlso it would be nice if you could test with the published R and Python binary packages instead\r\n(and/or nightly builds thereof)."
        },
        {
            "created_at": "2022-05-31T13:30:07.493Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16688?focusedCommentId=17544382) by Dewey Dunnington (paleolimbot):*\nAgreed that the R bindings need to fix that! The approach I'm thinking of will create a second copy of the extension registry at the R level so that the Arrow -> R conversion defined by the extension type as registered in R will kick in no matter where the extension type was registered. The rules for type equality and printing should be the same in all places and I think that's reasonable to ask of extension type developers hoping to provide support in multiple languages.\r\n\r\nSomewhere in Python must make that assumption as well since registering an extension type will break reading a file:\r\n\r\n```R\n\r\n# apache/arrow@master\r\nlibrary(arrow, warn.conflicts = FALSE)\r\nlibrary(reticulate)\r\n\r\n# this is a virtualenv with pyarrow installed against the same commit\r\nuse_virtualenv(\r\n  \"/Users/deweydunnington/Desktop/rscratch/pyarrow-dev\",\r\n  required = TRUE\r\n)\r\n\r\npa <- import(\"pyarrow\")\r\nfeather <- import(\"pyarrow.feather\")\r\n\r\ntest_type <- arrow::new_extension_type(int32(), \"arrow.test_type\")\r\narrow::register_extension_type(test_type)\r\n\r\ntf <- tempfile()\r\nwrite_feather(record_batch(x = new_extension_array(1:5, test_type)), tf)\r\n\r\nread_feather(tf, as_data_frame = FALSE)\r\n#> Table\r\n#> 5 rows x 1 columns\r\n#> $x <ExtensionType <>>\r\n\r\n# fails if extension type is registered\r\nfeather$read_feather(tf)\r\n#> Error in py_call_impl(callable, dots$args, dots$keywords): KeyError: 'x'\r\n#> \r\n#> Detailed traceback:\r\n#>   File \"/Users/deweydunnington/Desktop/rscratch/pyarrow-dev/lib/python3.9/site-packages/pyarrow/feather.py\", line 230, in read_feather\r\n#>     return (read_table(\r\n#>   File \"pyarrow/array.pxi\", line 823, in pyarrow.lib._PandasConvertible.to_pandas\r\n#>   File \"pyarrow/table.pxi\", line 3897, in pyarrow.lib.Table._to_pandas\r\n#>   File \"/Users/deweydunnington/Desktop/rscratch/pyarrow-dev/lib/python3.9/site-packages/pyarrow/pandas_compat.py\", line 803, in table_to_blockmanager\r\n#>     blocks = _table_to_blocks(options, table, categories, ext_columns_dtypes)\r\n#>   File \"/Users/deweydunnington/Desktop/rscratch/pyarrow-dev/lib/python3.9/site-packages/pyarrow/pandas_compat.py\", line 1155, in _table_to_blocks\r\n#>     return [_reconstruct_block(item, columns, extension_columns)\r\n#>   File \"/Users/deweydunnington/Desktop/rscratch/pyarrow-dev/lib/python3.9/site-packages/pyarrow/pandas_compat.py\", line 1155, in <listcomp>\r\n#>     return [_reconstruct_block(item, columns, extension_columns)\r\n#>   File \"/Users/deweydunnington/Desktop/rscratch/pyarrow-dev/lib/python3.9/site-packages/pyarrow/pandas_compat.py\", line 759, in _reconstruct_block\r\n#>     pandas_dtype = extension_columns[name]\r\narrow::unregister_extension_type(\"arrow.test_type\")\r\nfeather$read_feather(tf)\r\n#>   x\r\n#> 1 1\r\n#> 2 2\r\n#> 3 3\r\n#> 4 4\r\n#> 5 5\r\n```\r\n\r\n> Also it would be nice if you could test with the published R and Python binary packages instead\r\n(and/or nightly builds thereof).\r\n\r\nI also tested this following the install directions for conda (https://arrow.apache.org/install/#c-and-python-conda-packages). It's not the most common way for native R users to interact with arrow, but it is probably the most common method by which GDAL with Arrow will be available. The only extra step I used was `conda install -c conda-forge r-reticulate`` and `reticulate::use_python(\"<the output of `which python` in the conda env>\")`.\r\n\r\nThe interaction that breaks GDAL is that the type is stripped if the extension type is not registered (the most common case). We can PR to fix this in GDAL by checking the storage type if it is an extension array or by registering the extension type there. I could also stop writing files with extension type columns (although then we don't get query engine magic without a custom dataset class)."
        },
        {
            "created_at": "2022-05-31T13:43:40.761Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16688?focusedCommentId=17544398) by Joris Van den Bossche (jorisvandenbossche):*\nI don't think your development setup is related to this. We know that in C++ an extension type can only registered once (at the moment), so if we are using a shared C++ library for the R and Python package, and if those two bindings are used in the same process, then registering an extension type with the same name twice (from each binding) logically will result in that error. \r\n\r\nSo we will need to think about how to deal with the issue of an extension type getting registered from multiple languages, whether we want to allow this and how to do this (I think for the kernel function registry, there are currently also some discussions about having multiple registries, ARROW-16677 / https://github.com/apache/arrow/pull/13214)"
        },
        {
            "created_at": "2022-06-01T10:39:43.451Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16688?focusedCommentId=17544801) by Joris Van den Bossche (jorisvandenbossche):*\n> The interaction that breaks GDAL is that the type is stripped if the extension type is not registered (the most common case). We can PR to fix this in GDAL by checking the storage type if it is an extension array or by registering the extension type there. I could also stop writing files with extension type columns (although then we don't get query engine magic without a custom dataset class).\r\n\r\nFor this specific aspect (which is not directly related to registering the same extension type from two bindings), I opened an issue upstream: https://github.com/OSGeo/gdal/issues/5834"
        }
    ]
}