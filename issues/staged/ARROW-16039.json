{
    "issue": {
        "title": "[JS] Documentation is quite obscure and not useful",
        "body": "***Note**: This issue was originally created as [ARROW-16039](https://issues.apache.org/jira/browse/ARROW-16039). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nI've been looking forward to using Apache Arrow as a data storage component in a frontend application that heavily relies on time series data. However, the syntax seems to have changed quite a lot with version **7.0.0**. Most of the examples on https://observablehq.com seem to be outdated because of that.\r\n\r\nThe two main resources https://arrow.apache.org/docs/js/index.html and https://arrow.apache.org/docs/js/modules/Arrow_dom.html are quite insufficient to understand how to use the project. There are a bunch of examples on how to create a table and a vector. However, it seems that the most important use case in JS is not captured - how to create a table from an array of records\r\n```javascript\n\r\n[{a:1, b:2}, {a:3, b:4}]\r\n```\r\nor how to create a table from an observable that provides one record at a time.\r\n```javascript\n\r\ncallback(record => ???)\r\n```\r\nNo information on how to append data to a table (except the _concat()_ method).\r\n\r\nNo information on how to manipulate the data in a table or an example on how to consume it beyond the fact that a table is an iterable and has a _get()_ method.\r\n\r\nPlease, it will be also quite helpful to add some examples on how to work with time series data.\r\n\r\nCurrent state of the documentation does not provide the ability for the project to be adopted by anyone else except the core developers.",
        "created_at": "2022-03-27T18:31:57.000Z",
        "updated_at": "2022-04-17T21:07:49.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: JavaScript",
            "Type: enhancement"
        ],
        "closed": false
    },
    "comments": [
        {
            "created_at": "2022-04-06T18:14:19.263Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16039?focusedCommentId=17518335) by Dominik Moritz (domoritz):*\nI agree the docs can be improved and we would love your help on it. \r\n\r\nFor creating a table from an array of objects, you can use the struct builder. Yes, we should add an example and maybe even a convenience API. Here is roughly what the code can look like: https://github.com/trxcllnt/csv-to-arrow-js/blob/master/index.js. "
        },
        {
            "created_at": "2022-04-08T08:03:56.914Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16039?focusedCommentId=17519393) by Teodor Kostov (terusus):*\nHello, `[~domoritz]`. I'm sorry, but I do not think I'll be able to help. I'm going through the project code to understand how to use it. So far I've found [your article on Observable](https://observablehq.com/d/9480eccb30a21010) that helps a bit. And I've also figured out that I can use the following code to edit a table in place:\r\n\r\n```javascript\n\r\nfor (const record of table) {\r\n  record.value1 = \"new\" // the record is actually a proxy to the original data\r\n}\r\n```\r\n\r\nI'll check the example you shared about the builders. Unfortunately, that's about it. I do not consider having enough knowledge to write documentation.\r\n\r\nMore info and examples in the official docs would have sped up the process quite a lot."
        },
        {
            "created_at": "2022-04-08T12:51:40.912Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16039?focusedCommentId=17519559) by Dominik Moritz (domoritz):*\nAbsolutely. Please understand that we are a small team of volunteers doing what we can. I appreciate that you took the time to write up the painpoints here as it will help us guide our effort. "
        },
        {
            "created_at": "2022-04-10T15:31:45.505Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16039?focusedCommentId=17520189) by Teodor Kostov (terusus):*\nHey, `[~domoritz]`. I checked the builder code and it's hard to understand what's happening there. I would need some explanation to get it.\r\n\r\nLet's look at the following example:\r\n```javascript\n\r\nconst data = [{a: 1, b: 1}, {a: 2, b: 2}, ...]\r\nconst { type, ...otherBuilderOptions } = jsValueToArrowBuilderOptions(data[0]);\r\nconst transform = builderThroughIterable({\r\n  type, ...otherBuilderOptions,\r\n  queueingStrategy: 'bytes', highWaterMark: 1 << 16,\r\n  nullValues: [null, undefined, 'n/a', 'NULL'],\r\n});\r\nconst generator = transform(data)\r\nconst value = generator.next().value\r\n\r\n// Object { isValid: isValid(index), get: get(index), set: set(index, value2), indexOf: indexOf(index), getByteLength: getByteLength(index), _offsets: (2) [\u2026], data: (1) [\u2026], type: {\u2026}, stride: 1, numChildren: 2, \u2026 }\r\n// _offsets: Array [ 0, 10 ]\r\n// data: Array [ {\u2026} ]\r\n// get: function get(index)\u200b\r\n// getByteLength: function getByteLength(index)\u200b\r\n// indexOf: function indexOf(index)\u200b\r\n// isValid: function isValid(index)\r\n// length: 10\r\n// numChildren: 2\r\n// set: function set(index, value2)\r\n// stride: 1\r\n// type: Object { children: (2) [\u2026] }\r\n// <prototype>: Object { length: 0, stride: 1, numChildren: 0, \u2026 }\r\n//   ArrayType:\r\n//   VectorName:\r\n```\r\n\r\n~~So of what type is `value`? Do I need to create a `RecordBatch` and a `Table` out of it and how? What is the difference in utility between the `value` that we have here and a `Table`?~~\r\n\r\nIn the example `value` is a `Vector`. What's the difference between a `Vector` that holds `Struct` type and a `Table`? What are the advantages and disadvantages of using them?\r\n\r\nEdit:\r\nSo this took a little time to figure out. Found the magic [here](https://github.com/apache/arrow/blob/7d4e93dafdd96c6540d822851ee3ccd10e167a4f/js/src/table.ts#L106).\r\n\r\n```javascript\n\r\nconst data = [{a: 1, b: 1}, {a: 2, b: 2}, ...]\r\nconst { type, ...otherBuilderOptions } = jsValueToArrowBuilderOptions(data[0]);\r\nconst transform = builderThroughIterable({\r\n  type, ...otherBuilderOptions,\r\n  queueingStrategy: 'bytes', highWaterMark: 1 << 16,\r\n  nullValues: [null, undefined, 'n/a', 'NULL'],\r\n});\r\nconst generator = transform(data)\r\nconst value = generator.next().value\r\n\r\nschema = new Schema(value.type.children)\r\nrecord = new RecordBatch(schema, value.data[0])\r\ntable = new Table(record)\r\n// or\r\ntable2 = new Table(value.data)\r\ntable3 = new Table(value.data[0])\r\n\r\nassert(table.get(0).a == 1)\r\nassert(table.get(1).b == 2)\r\n```\r\n\r\nEdit (hopefully last):\r\nA few more questions. What's the purpose of `metadata` in `Schema` and `Field`?\r\n\r\n```javascript\n\r\ncase 'string':\r\n  return { type: new Dictionary(new Utf8(), new Int32()), dictionaryHashFunction: metrohash64 };\r\n```\r\n\r\nIn the async builder example a `string` is represented as a `Dictionary` with `Utf8` keys and `Int32` values. What's the point in that? Why not just use `Utf8`?\r\n\r\nIn the main docs there is an example that shows how `Utf8` works just fine:\r\n\r\n```javascript\n\r\nimport { Builder, Utf8 } from 'apache-arrow';\r\n\r\nconst utf8Builder = makeBuilder({\r\n    type: new Utf8(),\r\n    nullValues: [null, 'n/a']\r\n});\r\n\r\nutf8Builder\r\n    .append('hello')\r\n    .append('n/a')\r\n    .append('world')\r\n    .append(null);\r\n\r\nconst utf8Vector = utf8Builder.finish().toVector();\r\n\r\nconsole.log(utf8Vector.toJSON());\r\n// > [\"hello\", null, \"world\", null]\r\n```\r\n\r\n**PS**: Considerably more information is needed in the documentation. All options and parameters have to be described. For example, every builder could get a bunch of specific options when it is instantiated. Like the `dictionaryHashFunction` for the `DictionaryBuilder`."
        },
        {
            "created_at": "2022-04-17T21:05:17.714Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16039?focusedCommentId=17523442) by Dominik Moritz (domoritz):*\n> In the async builder example a string is represented as a Dictionary with Utf8 keys and Int32 values. What's the point in that? Why not just use Utf8?\r\n\r\nDictionaries are way more efficient since we don't have to repeatedly decode strings. \r\n\r\nI added a method called tableFromJSON in https://github.com/apache/arrow/pull/12908. Thanks for raising this issue. \r\n\r\nIn the code above, you could use `vectorFromArray` to construct the vector instead of calling the builder manually and with the new changes in my pull request, you even get automatic type inference. "
        }
    ]
}