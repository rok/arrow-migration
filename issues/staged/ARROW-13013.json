{
    "issue": {
        "title": "[C++][Compute][Python] Move (majority of) kernel unit tests to python",
        "body": "***Note**: This issue was originally created as [ARROW-13013](https://issues.apache.org/jira/browse/ARROW-13013). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nmailing list discussion: <https://lists.apache.org/thread.html/r09e0e0fbb8b655bbec8cf5662d224f3dfc4fba894a312900f73ae3bf%40%3Cdev.arrow.apache.org%3E>\r\n\r\nWriting unit tests for compute functions in c++ is laborious, entails a lot of boilerplate, and slows iteration since it requires recompilation when adding new tests. The majority of these test cases need not be written in C++ at all and could instead be made part of the pyarrow test suite.\r\n\r\nIn order to make the kernels' C++ implementations easily debuggable from unit tests, we'll have to expose a c++ function named `AssertCallFunction` or so. `AssertCallFunction` will invoke the named compute::Function and compare actual results to expected without crossing the C++/python boundary, allowing a developer to step through all relevant code with a single breakpoint in GDB. Construction of scalars/arrays/function options and any other inputs to the function is amply supported by `pyarrow`, and will happen outside the scope of `AssertCallFunction`.\r\n\r\n`AssertCallFunction` should not try to derive additional assertions from its arguments - for example {{CheckScalar(\"add\",\r\n\r\n{left, right}\r\n\r\n, expected)}} will first assert that `left + right == expected` then `left.slice(1) + right.slice(1) == expected.slice(1)` to ensure that offsets are handled correctly. This has value but can be easily expressed in Python and configuration of such behavior would overcomplicate the interface of `AssertCallFunction`.\r\n\r\nUnit tests for kernels would then be written in `arrow/python/pyarrow/test/kernels/test_*.py`. The C++ unit test for [addition with implicit casts](https://github.com/apache/arrow/blob/b38ab81cb96e393a026d05a22e5a2f62ff6c23d7/cpp/src/arrow/compute/kernels/scalar_arithmetic_test.cc#L897-L918) could then be rewritten as\r\n```python\n\r\ndef test_addition_implicit_casts():\r\n    AssertCallFunction(\"add\", [[ 0,    1,   2,    None],\r\n                               [ 0.25, 1.5, 2.75, None]],\r\n                       expected=[0.25, 1.5, 2.75, None])\r\n\r\n# ...\r\n```\r\nNB: Some unit tests will probably still reside in C++ since we'll need to test things we don't wish to expose in a user facing API, such as \"whether a boolean kernel avoids clobbering bits when outputting into a slice\". These should be far more manageable since they won't need to assert correct logic across all possible input types",
        "created_at": "2021-06-08T17:02:24.000Z",
        "updated_at": "2022-07-12T14:04:50.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Component: Python",
            "Type: enhancement"
        ],
        "closed": false
    },
    "comments": [
        {
            "created_at": "2021-06-08T17:23:57.192Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-13013?focusedCommentId=17359492) by Eduardo Ponce (edponce):*\nWhat implications would this have on C++-only builds?"
        },
        {
            "created_at": "2021-06-08T17:32:14.604Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-13013?focusedCommentId=17359495) by David Li (lidavidm):*\nQuick notes from a discussion: this would mean a pure-C++ build wouldn't be able to run all the tests. But note some kernels are already in this position; the bulk of their tests are in Python for convenience.\r\n\r\nAlso while I was initially concerned about the impact on the local dev workflow, I think this will be a net improvement. For one, you don't have to rebuild PyArrow itself, only libarrow, to get the updated tests. And for another, because the current C++ kernel tests squash all the various tests into one build target (or, well, one target per kernel type), rebuilding (and especially linking) that target takes a long time, and if you touch a common header file, you're rebuilding all the tests for all the kernels - being able to avoid that would be nice. (Of course, you could imagine splitting the C++ test targets further as well.)"
        },
        {
            "created_at": "2021-06-08T17:46:06.244Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-13013?focusedCommentId=17359497) by Weston Pace (westonpace):*\nJust to be pedantic, kernel benchmarks will stay in C++ right?"
        },
        {
            "created_at": "2021-06-09T13:26:01.894Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-13013?focusedCommentId=17360067) by Antoine Pitrou (apitrou):*\nI'm a bit lukewarm about this.\r\n\r\nFirst, if we expose a `AssertCallFunction` function, what kind of boilerplate does writing the tests in Python avoid?\r\n\r\nSecond, we currently aren't able to run Python tests in Valgrind or ASAN/UBSAN-based CI jobs. So this would significantly decrease our test coverage, and compute kernels can do quite a bit of low-level memory accesses that make such checks really useful.\r\n\r\nWhile C++ can be a bit annoying and verbose at times, I don't think it shows up very often in kernel tests. As an exemple, I took a quick look at `scalar_string_test.cc`, and ~90% of that file seems to be actual testing, not boilerplate. For example:\r\n\r\n```c++\n\r\nTYPED_TEST(TestStringKernels, AsciiUpper) {\r\n  this->CheckUnary(\"ascii_upper\", \"[]\", this->type(), \"[]\");\r\n  this->CheckUnary(\"ascii_upper\", \"[\\\"aAazZ\u00e6\u00c6&\\\", null, \\\"\\\", \\\"bbb\\\"]\", this->type(),\r\n                   \"[\\\"AAAZZ\u00e6\u00c6&\\\", null, \\\"\\\", \\\"BBB\\\"]\");\r\n}\r\n\r\nTYPED_TEST(TestStringKernels, AsciiLower) {\r\n  this->CheckUnary(\"ascii_lower\", \"[]\", this->type(), \"[]\");\r\n  this->CheckUnary(\"ascii_lower\", \"[\\\"aAazZ\u00e6\u00c6&\\\", null, \\\"\\\", \\\"BBB\\\"]\", this->type(),\r\n                   \"[\\\"aaazz\u00e6\u00c6&\\\", null, \\\"\\\", \\\"bbb\\\"]\");\r\n}\r\n\r\nTYPED_TEST(TestStringKernels, AsciiReverse) {\r\n  this->CheckUnary(\"ascii_reverse\", \"[]\", this->type(), \"[]\");\r\n  this->CheckUnary(\"ascii_reverse\", R\"([\"abcd\", null, \"\", \"bbb\"])\", this->type(),\r\n                   R\"([\"dcba\", null, \"\", \"bbb\"])\");\r\n\r\n  Datum invalid_input = ArrayFromJSON(this->type(), R\"([\"aAazZ\u00e6\u00c6&\", null, \"\", \"bbb\"])\");\r\n  EXPECT_RAISES_WITH_MESSAGE_THAT(Invalid,\r\n                                  testing::HasSubstr(\"Non-ASCII sequence in input\"),\r\n                                  CallFunction(\"ascii_reverse\", {invalid_input}));\r\n}\r\n\r\nTYPED_TEST(TestStringKernels, Utf8Reverse) {\r\n  this->CheckUnary(\"utf8_reverse\", \"[]\", this->type(), \"[]\");\r\n  this->CheckUnary(\"utf8_reverse\", R\"([\"abcd\", null, \"\", \"bbb\"])\", this->type(),\r\n                   R\"([\"dcba\", null, \"\", \"bbb\"])\");\r\n  this->CheckUnary(\"utf8_reverse\", R\"([\"aAazZ\u00e6\u00c6&\", null, \"\", \"bbb\", \"\u0251\u027d\u2c64\u00e6\u00c6\"])\",\r\n                   this->type(), R\"([\"&\u00c6\u00e6ZzaAa\", null, \"\", \"bbb\", \"\u00c6\u00e6\u2c64\u027d\u0251\"])\");\r\n\r\n  // inputs with malformed utf8 chars would produce garbage output, but the end result\r\n  // would produce arrays with same lengths. Hence checking offset buffer equality\r\n  auto malformed_input = ArrayFromJSON(this->type(), \"[\\\"\u0251\\xFF\u0251a\\\", \\\"\u027d\\xe1\\xbd\u027da\\\"]\");\r\n  const Result<Datum>& res = CallFunction(\"utf8_reverse\", {malformed_input});\r\n  ASSERT_TRUE(res->array()->buffers[1]->Equals(*malformed_input->data()->buffers[1]));\r\n}\r\n```\r\nThis may be slighlier terser when expressed in Python, but I don't think the difference would be enormous (note the last line should use `BufferEquals`).\r\n\r\n"
        },
        {
            "created_at": "2021-08-03T20:52:23.699Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-13013?focusedCommentId=17392537) by David Li (lidavidm):*\nAnother consideration here (from `[~edponce]`) is that it would be nice if we make it easy & consistent to test all the different argument types for a function. Right now, with Googletest, we have some parameterization, but it is not done very consistently, and the parameterization methods we use make it hard to support some types. For instance, we might template a set of tests on all numeric types, but we can't extend those tests to cover decimals, because 1) the literal syntax is different and 2) the type is parameterized (and so just templating on the type's class, as we most commonly do, is insufficient). We can solve this in C+, but if we're going to rewrite all the tests anyways, we should keep this in mind (either if we reorganize the C+ tests or port them elsewhere).\r\n\r\nOn top of that, it would be nice if the solution we had made it easier to track completeness of type support for kernels so we could easily see where support might be lacking. Right now this is sort of encoded into the tests and API docs but these are either hard to read through or get out of sync easily. Ideally every kernel would support every (applicable) type but while we are working towards that goal it would be nice to have an easy way to know how close we are to it."
        },
        {
            "created_at": "2022-07-12T14:04:50.961Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-13013?focusedCommentId=17565789) by @toddfarmer:*\nThis issue was last updated over 90 days ago, which may be an indication it is no longer being actively worked. To better reflect the current state, the issue is being unassigned. Please feel free to re-take assignment of the issue if it is being actively worked, or if you plan to start that work soon."
        }
    ]
}