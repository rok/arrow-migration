{
    "issue": {
        "title": "[Python][C++] Segfaults in UnionArray with null values",
        "body": "***Note**: This issue was originally created as [ARROW-9556](https://issues.apache.org/jira/browse/ARROW-9556). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nExtracting null values from a UnionArray containing nulls and constructing a UnionArray with a bitmask in pyarrow.Array.from_buffers causes segfaults in pyarrow 1.0.0. I have an environment with pyarrow 0.17.0 and all of the following run correctly without segfaults in the older version.\r\n\r\nHere's a UnionArray that works (because there are no nulls):\r\n\r\n\u00a0\r\n```java\n\r\n# GOOD\r\na = pyarrow.UnionArray.from_sparse(\r\n pyarrow.array([0, 1, 0, 0, 1], type=pyarrow.int8()),\r\n [\r\n pyarrow.array([0.0, 1.1, 2.2, 3.3, 4.4]),\r\n pyarrow.array([True, True, False, True, False]),\r\n ],\r\n)\r\na.to_pylist()\n```\r\n\u00a0\r\n\r\nHere's one the fails when you try a.to_pylist() or even just a[2], because one of the children has a null at 2:\r\n\r\n\u00a0\r\n```java\n\r\n# SEGFAULT\r\na = pyarrow.UnionArray.from_sparse(\r\n pyarrow.array([0, 1, 0, 0, 1], type=pyarrow.int8()),\r\n [\r\n pyarrow.array([0.0, 1.1, None, 3.3, 4.4]),\r\n pyarrow.array([True, True, False, True, False]),\r\n ],\r\n)\r\na.to_pylist() # also just a[2] causes a segfault\n```\r\n\u00a0\r\n\r\nHere's another that fails because both children have nulls; the segfault occurs at both positions with nulls:\r\n\r\n\u00a0\r\n```java\n\r\n# SEGFAULT\r\na = pyarrow.UnionArray.from_sparse(\r\n pyarrow.array([0, 1, 0, 0, 1], type=pyarrow.int8()),\r\n [\r\n pyarrow.array([0.0, 1.1, None, 3.3, 4.4]),\r\n pyarrow.array([True, None, False, True, False]),\r\n ],\r\n)\r\na.to_pylist() # also a[1] and a[2] cause segfaults\n```\r\n\u00a0\r\n\r\nHere's one that succeeds, but it's dense, rather than sparse:\r\n\r\n\u00a0\r\n```java\n\r\n# GOOD\r\na = pyarrow.UnionArray.from_dense(\r\n pyarrow.array([0, 1, 0, 0, 0, 1, 1], type=pyarrow.int8()),\r\n pyarrow.array([0, 0, 1, 2, 3, 1, 2], type=pyarrow.int32()),\r\n [pyarrow.array([0.0, 1.1, 2.2, 3.3]), pyarrow.array([True, True, False])],\r\n)\r\na.to_pylist()\n```\r\n\u00a0\r\n\r\nHere's a dense that fails because one child has a null:\r\n\r\n\u00a0\r\n```java\n\r\n# SEGFAULT\r\na = pyarrow.UnionArray.from_dense(\r\n pyarrow.array([0, 1, 0, 0, 0, 1, 1], type=pyarrow.int8()),\r\n pyarrow.array([0, 0, 1, 2, 3, 1, 2], type=pyarrow.int32()),\r\n [pyarrow.array([0.0, 1.1, None, 3.3]), pyarrow.array([True, True, False])],\r\n)\r\na.to_pylist() # also just a[3] causes a segfault\n```\r\n\u00a0\r\n\r\nHere's a dense that fails in two positions because both children have a null:\r\n\r\n\u00a0\r\n```java\n\r\n# SEGFAULT\r\na = pyarrow.UnionArray.from_dense(\r\n pyarrow.array([0, 1, 0, 0, 0, 1, 1], type=pyarrow.int8()),\r\n pyarrow.array([0, 0, 1, 2, 3, 1, 2], type=pyarrow.int32()),\r\n [pyarrow.array([0.0, 1.1, None, 3.3]), pyarrow.array([True, None, False])],\r\n)\r\na.to_pylist() # also a[3] and a[5] cause segfaults\n```\r\n\u00a0\r\n\r\nIn all of the above, we created the UnionArray using its from_dense method. We could instead create it with pyarrow.Array.from_buffers. If created with content0 and content1 that have no nulls, it's fine, but if created with nulls in the content, it segfaults as soon as you view the null value.\r\n\r\n\u00a0\r\n```java\n\r\n# GOOD\r\ncontent0 = pyarrow.array([0.0, 1.1, 2.2, 3.3, 4.4])\r\ncontent1 = pyarrow.array([True, True, False, True, False])\r\n# SEGFAULT\r\ncontent0 = pyarrow.array([0.0, 1.1, 2.2, None, 4.4])\r\ncontent1 = pyarrow.array([True, True, False, True, False])\r\ntypes = pyarrow.union(\r\n [pyarrow.field(\"0\", content0.type), pyarrow.field(\"1\", content1.type)],\r\n \"sparse\",\r\n [0, 1],\r\n)\r\na = pyarrow.Array.from_buffers(\r\n types,\r\n 5,\r\n [\r\n None,\r\n pyarrow.py_buffer(numpy.array([0, 1, 0, 0, 1], numpy.int8)),\r\n ],\r\n children=[content0, content1],\r\n)\r\na.to_pylist() # also just a[3] causes a segfault\n```\r\n\u00a0\r\n\r\nSimilarly for a dense union.\r\n\r\n\u00a0\r\n```java\n\r\n# GOOD\r\ncontent0 = pyarrow.array([0.0, 1.1, 2.2, 3.3])\r\ncontent1 = pyarrow.array([True, True, False])\r\n# SEGFAULT\r\ncontent0 = pyarrow.array([0.0, 1.1, None, 3.3])\r\ncontent1 = pyarrow.array([True, True, False])\r\ntypes = pyarrow.union(\r\n [pyarrow.field(\"0\", content0.type), pyarrow.field(\"1\", content1.type)],\r\n \"dense\",\r\n [0, 1],\r\n)\r\na = pyarrow.Array.from_buffers(\r\n types,\r\n 7,\r\n [\r\n None,\r\n pyarrow.py_buffer(numpy.array([0, 1, 0, 0, 0, 1, 1], numpy.int8)),\r\n pyarrow.py_buffer(numpy.array([0, 0, 1, 2, 3, 1, 2], numpy.int32)),\r\n ],\r\n children=[content0, content1],\r\n)\r\na.to_pylist() # also just a[3] causes a segfault\n```\r\n\u00a0\r\n\r\nThe next segfaults are different: instead of putting the null values in the content, we put the null value in the UnionArray itself. This time, it segfaults when it is being created. It also prints some output (all of the above were silent segfaults).\r\n\r\n\u00a0\r\n```java\n\r\n# SEGFAULT (even to create)\r\ncontent0 = pyarrow.array([0.0, 1.1, 2.2, 3.3, 4.4])\r\ncontent1 = pyarrow.array([True, True, False, True, False])\r\ntypes = pyarrow.union(\r\n [pyarrow.field(\"0\", content0.type), pyarrow.field(\"1\", content1.type)],\r\n \"sparse\",\r\n [0, 1],\r\n)\r\na = pyarrow.Array.from_buffers(\r\n types,\r\n 5,\r\n [\r\n pyarrow.py_buffer(numpy.array([251], numpy.uint8)), # (11111011)\r\n pyarrow.py_buffer(numpy.array([0, 1, 0, 0, 1], numpy.int8)),\r\n# exepct null here -----^\r\n# None <--- placeholder required in pyarrow 0.17.0, not 1.0.0\r\n ],\r\n children=[content0, content1],\r\n)\r\n# /arrow/cpp/src/arrow/array/array_nested.cc:617: Check failed: (data_->buffers[0]) == (nullptr) \r\n# /home/pivarski/miniconda3/envs/test-arrow/lib/python3.8/site-packages/pyarrow/libarrow.so.100(+0x4e9938)[0x7feea9937938]\r\n# /home/pivarski/miniconda3/envs/test-arrow/lib/python3.8/site-packages/pyarrow/libarrow.so.100(_ZN5arrow4util8ArrowLogD1Ev+0xdd)[0x7feea993814d]\r\n# /home/pivarski/miniconda3/envs/test-arrow/lib/python3.8/site-packages/pyarrow/libarrow.so.100(_ZN5arrow16SparseUnionArray7SetDataESt10shared_ptrINS_9ArrayDataEE+0x144)[0x7feea9a869a4]\r\n# /home/pivarski/miniconda3/envs/test-arrow/lib/python3.8/site-packages/pyarrow/libarrow.so.100(_ZN5arrow16SparseUnionArrayC1ESt10shared_ptrINS_9ArrayDataEE+0x5a)[0x7feea9a86a2a]\r\n# /home/pivarski/miniconda3/envs/test-arrow/lib/python3.8/site-packages/pyarrow/libarrow.so.100(_ZN5arrow15VisitTypeInlineINS_8internal16ArrayDataWrapperEEENS_6StatusERKNS_8DataTypeEPT_+0x9fc)[0x7feea9a5145c]\r\n# /home/pivarski/miniconda3/envs/test-arrow/lib/python3.8/site-packages/pyarrow/libarrow.so.100(_ZN5arrow9MakeArrayERKSt10shared_ptrINS_9ArrayDataEE+0x3f)[0x7feea9a2698f]\r\n# /home/pivarski/miniconda3/envs/test-arrow/lib/python3.8/site-packages/pyarrow/lib.cpython-38-x86_64-linux-gnu.so(+0x1c7853)[0x7feeaa998853]\r\n# python(+0x13af9e)[0x56146ee77f9e]\r\n# python(_PyObject_MakeTpCall+0x3bf)[0x56146ee6d30f]\r\n# python(_PyEval_EvalFrameDefault+0x5452)[0x56146ef20602]\r\n# python(_PyEval_EvalCodeWithName+0x260)[0x56146ef06190]\r\n# python(PyEval_EvalCode+0x23)[0x56146ef07a03]\r\n# python(+0x23e2f2)[0x56146ef7b2f2]\r\n# python(+0x251082)[0x56146ef8e082]\r\n# python(+0x1063b9)[0x56146ee433b9]\r\n# python(PyRun_InteractiveLoopFlags+0xea)[0x56146ee43559]\r\n# python(+0x1065f3)[0x56146ee435f3]\r\n# python(+0x106817)[0x56146ee43817]\r\n# python(Py_BytesMain+0x39)[0x56146ef91a19]\r\n# /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xe7)[0x7feeac198b97]\r\n# python(+0x1f8807)[0x56146ef35807]\r\n# Aborted (core dumped)\r\n```\r\n\u00a0\r\n\r\nAnd similarly for dense.\r\n\r\n\u00a0\r\n```java\n\r\n# SEGFAULT (even to create)\r\ncontent0 = pyarrow.array([0.0, 1.1, 2.2, 3.3])\r\ncontent1 = pyarrow.array([True, True, False])\r\ntypes = pyarrow.union(\r\n [pyarrow.field(\"0\", content0.type), pyarrow.field(\"1\", content1.type)],\r\n \"dense\",\r\n [0, 1],\r\n)\r\na = pyarrow.Array.from_buffers(\r\n types,\r\n 7,\r\n [\r\n pyarrow.py_buffer(numpy.array([251], numpy.uint8)), # (11111011)\r\n pyarrow.py_buffer(numpy.array([0, 1, 0, 0, 0, 1, 1], numpy.int8)),\r\n pyarrow.py_buffer(numpy.array([0, 0, 1, 2, 3, 1, 2], numpy.int32)),\r\n# exepct null here -----^\r\n ],\r\n children=[content0, content1],\r\n)\r\n# /arrow/cpp/src/arrow/array/array_nested.cc:627: Check failed: (data_->buffers[0]) == (nullptr) \r\n# /home/pivarski/miniconda3/envs/test-arrow/lib/python3.8/site-packages/pyarrow/libarrow.so.100(+0x4e9938)[0x7f2fb6ad7938]\r\n# /home/pivarski/miniconda3/envs/test-arrow/lib/python3.8/site-packages/pyarrow/libarrow.so.100(_ZN5arrow4util8ArrowLogD1Ev+0xdd)[0x7f2fb6ad814d]\r\n# /home/pivarski/miniconda3/envs/test-arrow/lib/python3.8/site-packages/pyarrow/libarrow.so.100(_ZN5arrow15DenseUnionArray7SetDataERKSt10shared_ptrINS_9ArrayDataEE+0x174)[0x7f2fb6c274a4]\r\n# /home/pivarski/miniconda3/envs/test-arrow/lib/python3.8/site-packages/pyarrow/libarrow.so.100(_ZN5arrow15DenseUnionArrayC2ERKSt10shared_ptrINS_9ArrayDataEE+0x44)[0x7f2fb6c27524]\r\n# /home/pivarski/miniconda3/envs/test-arrow/lib/python3.8/site-packages/pyarrow/libarrow.so.100(_ZN5arrow15VisitTypeInlineINS_8internal16ArrayDataWrapperEEENS_6StatusERKNS_8DataTypeEPT_+0xb14)[0x7f2fb6bf1574]\r\n# /home/pivarski/miniconda3/envs/test-arrow/lib/python3.8/site-packages/pyarrow/libarrow.so.100(_ZN5arrow9MakeArrayERKSt10shared_ptrINS_9ArrayDataEE+0x3f)[0x7f2fb6bc698f]\r\n# /home/pivarski/miniconda3/envs/test-arrow/lib/python3.8/site-packages/pyarrow/lib.cpython-38-x86_64-linux-gnu.so(+0x1c7853)[0x7f2fb7b38853]\r\n# python(+0x13af9e)[0x558cf09edf9e]\r\n# python(_PyObject_MakeTpCall+0x3bf)[0x558cf09e330f]\r\n# python(_PyEval_EvalFrameDefault+0x5452)[0x558cf0a96602]\r\n# python(_PyEval_EvalCodeWithName+0x260)[0x558cf0a7c190]\r\n# python(PyEval_EvalCode+0x23)[0x558cf0a7da03]\r\n# python(+0x23e2f2)[0x558cf0af12f2]\r\n# python(+0x251082)[0x558cf0b04082]\r\n# python(+0x1063b9)[0x558cf09b93b9]\r\n# python(PyRun_InteractiveLoopFlags+0xea)[0x558cf09b9559]\r\n# python(+0x1065f3)[0x558cf09b95f3]\r\n# python(+0x106817)[0x558cf09b9817]\r\n# python(Py_BytesMain+0x39)[0x558cf0b07a19]\r\n# /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xe7)[0x7f2fb9338b97]\r\n# python(+0x1f8807)[0x558cf0aab807]\r\n# Aborted (core dumped)\n```\r\n\u00a0\r\n\r\nIt might be two distinct bugs, but they're both related to UnionArrays and nulls, and they're both newer than 0.17.0.",
        "created_at": "2020-07-24T22:24:44.000Z",
        "updated_at": "2020-08-17T10:20:30.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: Python",
            "Type: bug"
        ],
        "closed": true,
        "closed_at": "2020-08-17T10:20:26.000Z"
    },
    "comments": [
        {
            "created_at": "2020-07-24T22:26:27.347Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-9556?focusedCommentId=17164662) by Jim Pivarski (jpivarski):*\n(JIRA incorrectly formatted my \"expect null here\" comments; they're supposed to be on the third element.)"
        },
        {
            "created_at": "2020-07-25T02:03:35.847Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-9556?focusedCommentId=17164717) by Wes McKinney (wesm):*\nTop-level nulls are no longer permitted in union arrays, this was a non-backwards compatible change that we made for 1.0.0 to resolve long-standing instability of unions in the columnar format. The library should not segfault, though, so appropriate validation checks must be added. "
        },
        {
            "created_at": "2020-07-25T02:45:27.643Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-9556?focusedCommentId=17164722) by Jim Pivarski (jpivarski):*\nThe second case (segfault on construction) is due to top-level nulls, but in the first case (segfault on get-item), the nulls are on the leaf nodes.\r\n\r\nI'll take a look at the revised format specification, but top-level nulls have only been removed from unions, right? (Top-level vs not top-level isn't distinguishable on unions, but it would be visible on records or lists.)"
        },
        {
            "created_at": "2020-07-27T19:49:02.821Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-9556?focusedCommentId=17165933) by Wes McKinney (wesm):*\nThe top-level nulls changes only impact union types. "
        },
        {
            "created_at": "2020-08-13T10:24:52.212Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-9556?focusedCommentId=17176904) by Krisztian Szucs (kszucs):*\nThanks for the detailed bug report!"
        },
        {
            "created_at": "2020-08-17T10:20:26.816Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-9556?focusedCommentId=17178896) by Krisztian Szucs (kszucs):*\nIssue resolved by pull request 7952\n<https://github.com/apache/arrow/pull/7952>"
        }
    ]
}