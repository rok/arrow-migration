{
    "issue": {
        "title": "[C++] Create a scheduler for asynchronous work",
        "body": "***Note**: This issue was originally created as [ARROW-17350](https://issues.apache.org/jira/browse/ARROW-17350). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nNote, in the interest of keeping things simple, this ideally replaces the AsyncTaskGroup.  This is needed to simplify the logic in ARROW-17287.\r\n\r\nThe format and implementation will likely be inspired by the synchronous schedulers, TaskScheduler and TaskGroup but it will remain a separate implementation.  In the future, when we dedicate time to improving our synchronous scheduler, we can decide if it makes sense to merge these two types.\r\n\r\n```\n\r\n/// A utility which keeps tracks of, and schedules, asynchronous tasks\r\n///\r\n/// An asynchronous task has a synchronous component and an asynchronous component.\r\n/// The synchronous component typically schedules some kind of work on an external\r\n/// resource (e.g. the I/O thread pool or some kind of kernel-based asynchronous\r\n/// resource like io_uring).  The asynchronous part represents the work\r\n/// done on that external resource.  Executing the synchronous part will be referred\r\n/// to as \"submitting the task\" since this usually includes submitting the asynchronous\r\n/// portion to the external thread pool.\r\n///\r\n/// By default the scheduler will submit the task (execute the synchronous part) as\r\n/// soon as it is added, assuming the underlying thread pool hasn't terminated or the\r\n/// scheduler hasn't aborted.  In this mode the scheduler is simply acting as\r\n/// a task group, keeping track of the ongoing work.\r\n///\r\n/// This can be used to provide structured concurrency for asynchronous development.\r\n/// A task group created at a high level can be distributed amongst low level components\r\n/// which register work to be completed.  The high level job can then wait for all work\r\n/// to be completed before cleaning up.\r\n///\r\n/// A task scheduler must eventually be ended when all tasks have been added.  Once the\r\n/// scheduler has been ended it is an error to add further tasks.  Note, it is not an\r\n/// error to add additional tasks after a scheduler has aborted (though these tasks\r\n/// will be ignored and never submitted).  The scheduler has a futuer which will complete\r\n/// once the scheduler has been ended AND all remaining tasks have finished executing.\r\n/// Ending a scheduler will NOT cause the scheduler to flush existing tasks.\r\n///\r\n/// Task failure (either the synchronous portion or the asynchronous portion) will cause\r\n/// the scheduler to enter an aborted state.  The first such failure will be reported in\r\n/// the final task future.\r\n///\r\n/// The scheduler can also be manually aborted.  A cancellation status will be reported as\r\n/// the final task future.\r\n///\r\n/// It is also possible to limit the number of concurrent tasks the scheduler will\r\n/// execute. This is done by setting a task limit.  The task limit initially assumes all\r\n/// tasks are equal but a custom cost can be supplied when scheduling a task (e.g. based\r\n/// on the total I/O cost of the task, or the expected RAM utilization of the task)\r\n///\r\n/// When the total number of running tasks is limited then scheduler priority may also\r\n/// become a consideration.  By default the scheduler runs with a FIFO queue but a custom\r\n/// task queue can be provided.  One could, for example, use a priority queue to control\r\n/// the order in which tasks are executed.\r\n///\r\n/// It is common to have multiple stages of execution.  For example, when scanning, we\r\n/// first inspect each fragment (the inspect stage) to figure out the row groups and then\r\n/// we scan row groups (the scan stage) to read in the data.  This sort of multi-stage\r\n/// execution should be represented as two seperate task groups.  The first task group can\r\n/// then have a custom finish callback which ends the second task group.\r\n```",
        "created_at": "2022-08-09T00:38:09.000Z",
        "updated_at": "2022-09-02T09:42:42.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Type: bug"
        ],
        "closed": true,
        "closed_at": "2022-09-02T00:33:31.000Z"
    },
    "comments": [
        {
            "created_at": "2022-09-02T00:33:31.458Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-17350?focusedCommentId=17599205) by Weston Pace (westonpace):*\nIssue resolved by pull request 13912\n<https://github.com/apache/arrow/pull/13912>"
        }
    ]
}