{
    "issue": {
        "title": "JS: tableFromJSON cannot handle nested objects containing strings",
        "body": "***Note**: This issue was originally created as [ARROW-18208](https://issues.apache.org/jira/browse/ARROW-18208). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\n```\r\n\r\n$ node\r\n\r\nconst g = require('apache-arrow')\r\n\r\ng.tableFromJSON([\\{a: [ { b: \"hi\" } ]}])\r\n\r\n```\r\n\r\n\u00a0\r\n\r\nThe dictionary types:\r\n\r\n\u00a0\r\n\r\nTYPE Dictionary \\{indices: Int32, dictionary: Utf8, isOrdered: false, id: 12}dictionary: Utf8 {}id: 12indices: Int32 \\{isSigned: true, bitWidth: 32}isOrdered: falseArrayType: (...)children: (...)typeId: (...)valueType: (...)[[Prototype]]: Dictionary\r\ntypecomparator.ts:191 OTHER\u00a0\r\n\r\n\u00a0\r\n\r\nOTHER Dictionary \\{indices: Int32, dictionary: Utf8, isOrdered: false, id: 14}dictionary: Utf8typeId: (...)[[Prototype]]: Utf8id: 14indices: Int32 \\{isSigned: true, bitWidth: 32}isOrdered: falseArrayType: (...)children: (...)typeId: (...)valueType: (...)[[Prototype]]: Dictionary\r\n\r\n\u00a0\r\n\r\nThis happens here:\r\n\r\n\u00a0 \u00a0 else if (arraysCount + nullsCount === value.length) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 const array = value;\r\n\u00a0 \u00a0 \u00a0 \u00a0 const childType = inferType(array[array.findIndex((ary) => ary != null)]);\r\n\u00a0 \u00a0 \u00a0 \u00a0 if (array.every((ary) => ary == null || (0, typecomparator_js_1.compareTypes)(childType, inferType(ary)))) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return new dtypes.List(new schema_js_1.Field('', childType, true));\r\n\u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 }\r\n\r\n\u00a0\r\n\r\nSo we're always instantiating a new dictionary type, with a new id, when we do inferType(ary), so this is never going to succeed.",
        "created_at": "2022-10-31T23:42:13.000Z",
        "updated_at": "2022-11-01T18:35:01.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: JavaScript",
            "Type: bug"
        ],
        "closed": false
    },
    "comments": [
        {
            "created_at": "2022-11-01T00:38:06.478Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-18208?focusedCommentId=17626887) by Samuel Schneck (mansoonism):*\nJust to document my insanity here....\r\n```java\n\r\n\"use strict\";\r\n// Licensed to the Apache Software Foundation (ASF) under one\r\n// or more contributor license agreements. \u00a0See the NOTICE file\r\n// distributed with this work for additional information\r\n// regarding copyright ownership. \u00a0The ASF licenses this file\r\n// to you under the Apache License, Version 2.0 (the\r\n// \"License\"); you may not use this file except in compliance\r\n// with the License. \u00a0You may obtain a copy of the License at\r\n//\r\n// \u00a0 http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing,\r\n// software distributed under the License is distributed on an\r\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n// KIND, either express or implied. \u00a0See the License for the\r\n// specific language governing permissions and limitations\r\n// under the License.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.builderThroughAsyncIterable = exports.builderThroughIterable = exports.tableFromJSON = exports.vectorFromArray = exports.makeBuilder = void 0;\r\nconst util = require(\"util\")\r\nconst tslib_1 = require(\"tslib\");\r\nconst schema_js_1 = require(\"./schema.js\");\r\nconst dtypes = tslib_1.__importStar(require(\"./type.js\"));\r\nconst data_js_1 = require(\"./data.js\");\r\nconst vector_js_1 = require(\"./vector.js\");\r\nconst builderctor_js_1 = require(\"./visitor/builderctor.js\");\r\nconst table_js_1 = require(\"./table.js\");\r\nconst recordbatch_js_1 = require(\"./recordbatch.js\");\r\nconst typecomparator_js_1 = require(\"./visitor/typecomparator.js\");\r\nfunction makeBuilder(options) {\r\n\u00a0 \u00a0 const type = options.type;\r\n\u00a0 \u00a0 const builder = new (builderctor_js_1.instance.getVisitFn(type)())(options);\r\n\u00a0 \u00a0 if (type.children && type.children.length > 0) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 const children = options['children'] || [];\r\n\u00a0 \u00a0 \u00a0 \u00a0 const defaultOptions = { 'nullValues': options['nullValues'] };\r\n\u00a0 \u00a0 \u00a0 \u00a0 const getChildOptions = Array.isArray(children)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ? ((_, i) => children[i] || defaultOptions)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 : (({ name }) => children[name] || defaultOptions);\r\n\u00a0 \u00a0 \u00a0 \u00a0 for (const [index, field] of type.children.entries()) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 const { type } = field;\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 const opts = getChildOptions(field, index);\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 builder.children.push(makeBuilder(Object.assign(Object.assign({}, opts), { type })));\r\n\u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 }\r\n\u00a0 \u00a0 return builder;\r\n}\r\nexports.makeBuilder = makeBuilder;\r\nfunction vectorFromArray(init, type) {\r\n\u00a0 \u00a0 if (init instanceof data_js_1.Data || init instanceof vector_js_1.Vector || init.type instanceof dtypes.DataType || ArrayBuffer.isView(init)) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 return (0, vector_js_1.makeVector)(init);\r\n\u00a0 \u00a0 }\r\n\u00a0 \u00a0 const options = { type: type !== null && type !== void 0 ? type : inferType(init), nullValues: [null] };\r\n\u00a0 \u00a0 const chunks = [...builderThroughIterable(options)(init)];\r\n\u00a0 \u00a0 const vector = chunks.length === 1 ? chunks[0] : chunks.reduce((a, b) => a.concat(b));\r\n\u00a0 \u00a0 if (dtypes.DataType.isDictionary(vector.type)) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 return vector.memoize();\r\n\u00a0 \u00a0 }\r\n\u00a0 \u00a0 return vector;\r\n}\r\nexports.vectorFromArray = vectorFromArray;\r\n/**\r\n\u00a0* Creates a {@link Table} from an array of objects.\r\n\u00a0*\r\n\u00a0* @param array A table of objects.\r\n\u00a0*/\r\nfunction tableFromJSON(array) {\r\n\u00a0 \u00a0 console.log(\"HONK\", JSON.stringify(array.slice(0, 1)))\r\n\u00a0 \u00a0 const vector = vectorFromArray(array);\r\n\u00a0 \u00a0 const batch = new recordbatch_js_1.RecordBatch(new schema_js_1.Schema(vector.type.children), vector.data[0]);\r\n\u00a0 \u00a0 return new table_js_1.Table(batch);\r\n}\r\nexports.tableFromJSON = tableFromJSON;function inferType(value, path, cache) {\r\n\u00a0 \u00a0 if (!path) {\r\n\u00a0 \u00a0 \u00a0 path = []\r\n\u00a0 \u00a0 }\r\n\u00a0 if (!cache) {\r\n\u00a0 \u00a0 cache = new Map()\r\n\u00a0 }\r\n\u00a0 \u00a0 console.log(\"INFERTRACE\", value)\r\n\u00a0 \u00a0 if (value.length === 0) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 return new dtypes.Null;\r\n\u00a0 \u00a0 }\r\n\u00a0 \u00a0 let nullsCount = 0;\r\n\u00a0 \u00a0 let arraysCount = 0;\r\n\u00a0 \u00a0 let objectsCount = 0;\r\n\u00a0 \u00a0 let numbersCount = 0;\r\n\u00a0 \u00a0 let stringsCount = 0;\r\n\u00a0 \u00a0 let bigintsCount = 0;\r\n\u00a0 \u00a0 let booleansCount = 0;\r\n\u00a0 \u00a0 let datesCount = 0;\r\n\u00a0 \u00a0 for (const val of value) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 if (val == null) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ++nullsCount;\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 continue;\r\n\u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 switch (typeof val) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 case 'bigint':\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ++bigintsCount;\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 continue;\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 case 'boolean':\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ++booleansCount;\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 continue;\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 case 'number':\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ++numbersCount;\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 continue;\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 case 'string':\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ++stringsCount;\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 continue;\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 case 'object':\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (Array.isArray(val)) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ++arraysCount;\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 else if (Object.prototype.toString.call(val) === '[object Date]') {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ++datesCount;\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 else {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ++objectsCount;\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 continue;\r\n\u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 console.log(val)\r\n\u00a0 \u00a0 \u00a0 \u00a0 console.log(\"OH FUCK\", typeof val)\r\n\u00a0 \u00a0 \u00a0 \u00a0 throw new TypeError('Unable to infer Vector type from input values, explicit type declaration expected');\r\n\u00a0 \u00a0 }\u00a0 \u00a0 console.log(\"WE COUNTED\")\r\n\u00a0 \u00a0 console.log(\"gonna hit the array case\", arraysCount + nullsCount === value.length)\r\n\u00a0 \u00a0 console.log(value.length)\r\n\u00a0 \u00a0 console.log(\"nullsCount\", nullsCount)\r\n\u00a0 \u00a0 console.log(\"arraysCount\", arraysCount)\r\n\u00a0 \u00a0 console.log(\"objectsCount\", objectsCount)\r\n\u00a0 \u00a0 console.log(\"numbersCount\", numbersCount)\r\n\u00a0 \u00a0 console.log(\"stringsCount\", stringsCount)\r\n\u00a0 \u00a0 console.log(\"bigintsCount\", bigintsCount)\r\n\u00a0 \u00a0 console.log(\"booleansCount\", booleansCount)\r\n\u00a0 \u00a0 console.log(\"datesCount\", datesCount)\r\n\u00a0 \u00a0 if (numbersCount + nullsCount === value.length) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 return new dtypes.Float64;\r\n\u00a0 \u00a0 }\r\n\u00a0 \u00a0 else if (stringsCount + nullsCount === value.length) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 console.log('STRINGS CASE', value)\r\n\u00a0 \u00a0 \u00a0 \u00a0 if (cache.has(path)) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 console.log(\"CACHED at path\", path)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return cache.get(path)\r\n\u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 const d = \u00a0new dtypes.Dictionary(new dtypes.Utf8, new dtypes.Int32);\r\n\u00a0 \u00a0 \u00a0 \u00a0 cache.set(path, d)\r\n\u00a0 \u00a0 \u00a0 \u00a0 return d\r\n\u00a0 \u00a0 }\r\n\u00a0 \u00a0 else if (bigintsCount + nullsCount === value.length) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 return new dtypes.Int64;\r\n\u00a0 \u00a0 }\r\n\u00a0 \u00a0 else if (booleansCount + nullsCount === value.length) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 return new dtypes.Bool;\r\n\u00a0 \u00a0 }\r\n\u00a0 \u00a0 else if (datesCount + nullsCount === value.length) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 return new dtypes.DateMillisecond;\r\n\u00a0 \u00a0 }\r\n\u00a0 \u00a0 else if ((() => {const res = arraysCount + nullsCount === value.length; console.log(\"EVALUATING ARRAY\", res, value); return res})()) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 console.log(\"arrayVal\", value)\r\n\u00a0 \u00a0 \u00a0 \u00a0 const array = value;\r\n\u00a0 \u00a0 \u00a0 \u00a0 const childType = inferType(array[array.findIndex((ary) => ary != null)], path, cache);\r\n\u00a0 \u00a0 \u00a0 \u00a0 if (array.every((\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ary\r\n\u00a0 \u00a0 \u00a0 \u00a0 ) => ary == null || (() => {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 const c = typecomparator_js_1.compareTypes(childType, (\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 () => {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 const res = (inferType(ary, path, cache)); console.log(\"COMPARING ARRAY TYPE\",util.inspect(res));return res\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 })())\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 console.log(\"THE RESULT OF THE COMPARISON\", c)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return c\r\n\u00a0 \u00a0 \u00a0 \u00a0 })())) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 console.log(\"THE TYPE WE COMPARE:\",util.inspect( childType))\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return new dtypes.List(new schema_js_1.Field('', childType, true));\r\n\u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 console.log(\"THE TYPE WE COMPARE WHEN IT ALL GOES WRONG:\",util.inspect( childType))\r\n\u00a0 \u00a0 \u00a0 console.log(\"bailing out on\", value)\r\n\u00a0 \u00a0 }\r\n\u00a0 \u00a0 else if (objectsCount + nullsCount === value.length) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 const fields = new Map();\r\n\u00a0 \u00a0 \u00a0 \u00a0 for (const row of value) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 for (const key of Object.keys(row)) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (!fields.has(key) && row[key] != null) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // use the type inferred for the first instance of a found key\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 console.log(path)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 path.push(key)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fields.set(key, new schema_js_1.Field(key, inferType([row[key]], path, cache), true));\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 path.pop(key)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 return new dtypes.Struct([...fields.values()]);\r\n\u00a0 \u00a0 }\u00a0 \u00a0 console.log(\"WE CRASHED on value\", value)\r\n\u00a0 \u00a0 console.log(\"gonna hit the array case\", arraysCount + nullsCount === value.length)\r\n\u00a0 \u00a0 console.log(value.length)\r\n\u00a0 \u00a0 console.log(\"nullsCount\", nullsCount)\r\n\u00a0 \u00a0 console.log(\"arraysCount\", arraysCount)\r\n\u00a0 \u00a0 console.log(\"objectsCount\", objectsCount)\r\n\u00a0 \u00a0 console.log(\"numbersCount\", numbersCount)\r\n\u00a0 \u00a0 console.log(\"stringsCount\", stringsCount)\r\n\u00a0 \u00a0 console.log(\"bigintsCount\", bigintsCount)\r\n\u00a0 \u00a0 console.log(\"booleansCount\", booleansCount)\r\n\u00a0 \u00a0 console.log(\"datesCount\", datesCount)\u00a0 \u00a0 throw new TypeError('Unable to infer Vector type from input values, explicit type declaration expected');}\r\n/**\r\n\u00a0* Transform a synchronous `Iterable` of arbitrary JavaScript values into a\r\n\u00a0* sequence of Arrow Vector<T> following the chunking semantics defined in\r\n\u00a0* the supplied `options` argument.\r\n\u00a0*\r\n\u00a0* This function returns a function that accepts an `Iterable` of values to\r\n\u00a0* transform. When called, this function returns an Iterator of `Vector<T>`.\r\n\u00a0*\r\n\u00a0* The resulting `Iterator<Vector<T>>` yields Vectors based on the\r\n\u00a0* `queueingStrategy` and `highWaterMark` specified in the `options` argument.\r\n\u00a0*\r\n\u00a0* * If `queueingStrategy` is `\"count\"` (or omitted), The `Iterator<Vector<T>>`\r\n\u00a0* \u00a0 will flush the underlying `Builder` (and yield a new `Vector<T>`) once the\r\n\u00a0* \u00a0 Builder's `length` reaches or exceeds the supplied `highWaterMark`.\r\n\u00a0* * If `queueingStrategy` is `\"bytes\"`, the `Iterator<Vector<T>>` will flush\r\n\u00a0* \u00a0 the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`\r\n\u00a0* \u00a0 reaches or exceeds the supplied `highWaterMark`.\r\n\u00a0*\r\n\u00a0* @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.\r\n\u00a0* @returns A function which accepts a JavaScript `Iterable` of values to\r\n\u00a0* \u00a0 \u00a0 \u00a0 \u00a0 \u00a0write, and returns an `Iterator` that yields Vectors according\r\n\u00a0* \u00a0 \u00a0 \u00a0 \u00a0 \u00a0to the chunking semantics defined in the `options` argument.\r\n\u00a0* @nocollapse\r\n\u00a0*/\r\nfunction builderThroughIterable(options) {\r\n\u00a0 \u00a0 const { ['queueingStrategy']: queueingStrategy = 'count' } = options;\r\n\u00a0 \u00a0 const { ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? Number.POSITIVE_INFINITY : Math.pow(2, 14) } = options;\r\n\u00a0 \u00a0 const sizeProperty = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';\r\n\u00a0 \u00a0 return function* (source) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 let numChunks = 0;\r\n\u00a0 \u00a0 \u00a0 \u00a0 const builder = makeBuilder(options);\r\n\u00a0 \u00a0 \u00a0 \u00a0 for (const value of source) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (builder.append(value)[sizeProperty] >= highWaterMark) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ++numChunks && (yield builder.toVector());\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 if (builder.finish().length > 0 || numChunks === 0) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 yield builder.toVector();\r\n\u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 };\r\n}\r\nexports.builderThroughIterable = builderThroughIterable;\r\n/**\r\n\u00a0* Transform an `AsyncIterable` of arbitrary JavaScript values into a\r\n\u00a0* sequence of Arrow Vector<T> following the chunking semantics defined in\r\n\u00a0* the supplied `options` argument.\r\n\u00a0*\r\n\u00a0* This function returns a function that accepts an `AsyncIterable` of values to\r\n\u00a0* transform. When called, this function returns an AsyncIterator of `Vector<T>`.\r\n\u00a0*\r\n\u00a0* The resulting `AsyncIterator<Vector<T>>` yields Vectors based on the\r\n\u00a0* `queueingStrategy` and `highWaterMark` specified in the `options` argument.\r\n\u00a0*\r\n\u00a0* * If `queueingStrategy` is `\"count\"` (or omitted), The `AsyncIterator<Vector<T>>`\r\n\u00a0* \u00a0 will flush the underlying `Builder` (and yield a new `Vector<T>`) once the\r\n\u00a0* \u00a0 Builder's `length` reaches or exceeds the supplied `highWaterMark`.\r\n\u00a0* * If `queueingStrategy` is `\"bytes\"`, the `AsyncIterator<Vector<T>>` will flush\r\n\u00a0* \u00a0 the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`\r\n\u00a0* \u00a0 reaches or exceeds the supplied `highWaterMark`.\r\n\u00a0*\r\n\u00a0* @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.\r\n\u00a0* @returns A function which accepts a JavaScript `AsyncIterable` of values\r\n\u00a0* \u00a0 \u00a0 \u00a0 \u00a0 \u00a0to write, and returns an `AsyncIterator` that yields Vectors\r\n\u00a0* \u00a0 \u00a0 \u00a0 \u00a0 \u00a0according to the chunking semantics defined in the `options`\r\n\u00a0* \u00a0 \u00a0 \u00a0 \u00a0 \u00a0argument.\r\n\u00a0* @nocollapse\r\n\u00a0*/\r\nfunction builderThroughAsyncIterable(options) {\r\n\u00a0 \u00a0 const { ['queueingStrategy']: queueingStrategy = 'count' } = options;\r\n\u00a0 \u00a0 const { ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? Number.POSITIVE_INFINITY : Math.pow(2, 14) } = options;\r\n\u00a0 \u00a0 const sizeProperty = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';\r\n\u00a0 \u00a0 return function (source) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 return tslib_1.__asyncGenerator(this, arguments, function* () {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 var e_1, _a;\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 let numChunks = 0;\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 const builder = makeBuilder(options);\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 try {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 for (var source_1 = tslib_1.__asyncValues(source), source_1_1; source_1_1 = yield tslib_1.__await(source_1.next()), !source_1_1.done;) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 const value = source_1_1.value;\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (builder.append(value)[sizeProperty] >= highWaterMark) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ++numChunks && (yield yield tslib_1.__await(builder.toVector()));\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 finally {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 try {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (source_1_1 && !source_1_1.done && (_a = source_1.return)) yield tslib_1.__await(_a.call(source_1));\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 finally { if (e_1) throw e_1.error; }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (builder.finish().length > 0 || numChunks === 0) {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 yield yield tslib_1.__await(builder.toVector());\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 });\r\n\u00a0 \u00a0 };\r\n}\r\nexports.builderThroughAsyncIterable = builderThroughAsyncIterable;//# sourceMappingURL=factories.js.map\n```\r\nfix is in factories.js"
        }
    ]
}