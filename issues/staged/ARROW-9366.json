{
    "issue": {
        "title": "[C#] BinaryArray.Builder Reserve/Resize methods are broken",
        "body": "***Note**: This issue was originally created as [ARROW-9366](https://issues.apache.org/jira/browse/ARROW-9366). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\n# Summary\r\n\r\nThe `Reserve()` and `Resize()` methods on `BinaryArray.Builder` are broken, insofar as the current implementation does not perform the intended function and may corrupt the contents of any array built so far:\r\n\r\n```c#\n\r\n            public TBuilder Reserve(int capacity)\r\n            {\r\n                ValueOffsets.Reserve(capacity + 1);\r\n                ValueBuffer.Reserve(capacity); // Meaningless\r\n                ValidityBuffer.Reserve(capacity + 1); // The +1 is not needed\r\n                return Instance;\r\n            }\r\n\r\n            public TBuilder Resize(int length)\r\n            {\r\n                ValueOffsets.Resize(length + 1);\r\n                ValueBuffer.Resize(length); // Dangerous!\r\n                ValidityBuffer.Resize(length + 1); // The +1 is not needed\r\n                return Instance;\r\n            }\r\n```\r\n\r\nIn the case of `Reserve()`, the `capacity` parameter is expected to refer to the desired number of items for which the array builder must have capacity.  However, it is almost certainly meaningless to call this for `ValueBuffer`, as this holds variable-length items and each item is very likely to be longer than one byte.\r\n\r\nIn the case of `Resize()`, the current implementation is _dangerous_, because:\r\n\r\n1. Resizing down will very likely truncate a variable-length value item somewhere in the middle.\n1. Resizing up will very likely truncate a variable-length value item somewhere too, as most value items are expected to be multiple bytes long, and hence an index equal to the parameter `length` is likely to be \"back\" in some earlier value instead.\n   \n   # Suggested Fix\n   \n   There are two broad approaches:\n   \n1. Make existing functions safe:\n   - `Reserve()` _may_ assume an average length of each value in order to make a sensible memory reservation in the `ValueBuffer`.\n   - Resizing down _must not_ truncate values in the middle but find the appropriate offset for the new smaller number of items and truncate there instead.\n   - Resizing up _must_ add valid value offsets, either with default empty or null values added to pad the array to the desired size.\n1. Remove the functions from the interface:\n   - One could decide that `Reserve()` and `Resize()` only make sense for fixed-size values and change interfaces accordingly.\n     \n     I have a mild personal preference for the former in the short term, mainly because it allows the existing interface to behave in a sensible way without entailing a larger-scale refactoring.",
        "created_at": "2020-07-08T00:08:58.000Z",
        "updated_at": "2020-07-08T00:10:25.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C#",
            "Type: bug"
        ],
        "closed": false
    },
    "comments": []
}