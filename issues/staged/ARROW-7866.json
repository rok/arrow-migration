{
    "issue": {
        "title": "[Rust] How to handle aggregates with Datafusion?",
        "body": "***Note**: This issue was originally created as [ARROW-7866](https://issues.apache.org/jira/browse/ARROW-7866). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nHi,\r\n\r\nI am trying to use the Rust tools and I was running into this interesting behavior.\r\n\r\n```Java\n\r\n\r\nuse std::sync::Arc;\r\n\r\nextern crate arrow;\r\nextern crate datafusion;\r\n\r\nuse arrow::array::\\{StringArray, UInt32Array};\r\nuse arrow::datatypes::\\{DataType, Field, Schema};\r\n\r\nuse datafusion::error::Result;\r\nuse datafusion::execution::context::ExecutionContext;\r\n\r\nfn main() -> Result<()> {\r\n // create local execution context\r\n let mut ctx = ExecutionContext::new();\r\n\r\n// define schema for data source (csv file)\r\n let schema = Arc::new(Schema::new(vec![\r\n Field::new(\"index\", DataType::UInt32, false),\r\n Field::new(\"tablename\", DataType::Utf8, false),\r\n Field::new(\"datetime\", DataType::Utf8, false),\r\n Field::new(\"partition\", DataType::Utf8, false),\r\n Field::new(\"fileSize\", DataType::UInt32, false),\r\n ]));\r\n\r\n// register csv file with the execution context\r\n ctx.register_csv(\r\n \"awesome_table\",\r\n &format!(\r\n \"../tableMetaData/anon/{}\",\r\n \"013ff3245cc90a3394943da0b6552b9f98313288e0a174f94f8dcb10.csv\"\r\n ),\r\n &schema,\r\n true,\r\n );\r\n\r\nlet sql = \"SELECT COUNT(partition) FROM awesome_table\";\r\n\r\n// create the query plan\r\n let plan = ctx.create_logical_plan(&sql)?;\r\n let plan = ctx.optimize(&plan)?;\r\n let plan = ctx.create_physical_plan(&plan, 1024 * 1024)?;\r\n\r\n// execute the query\r\n let results = ctx.collect(plan.as_ref())?;\r\n\r\n// iterate over the results\r\n results.iter().for_each(|batch| {\r\n println!(\r\n \"RecordBatch has {} rows and {} columns\",\r\n batch.num_rows(),\r\n batch.num_columns()\r\n );\r\n\r\nlet retf1 = batch.column(0).as_any().downcast_ref::<StringArray>();\r\n\r\nmatch retf1 {\r\n Some(_) => println!(\"Some retf1\"),\r\n None => println!(\"None retf1\"),\r\n }\r\n\r\nlet retf2 = batch.column(1).as_any().downcast_ref::<StringArray>();\r\n\r\nmatch retf2 {\r\n Some(_) => println!(\"Some retf2\"),\r\n None => println!(\"None retf2\"),\r\n }\r\n \r\n // for i in 0..batch.num_rows() {\r\n // println!(\"P: {}\", pcnt.value(i));\r\n // }\r\n });\r\n\r\nOk(())\r\n}\r\n\r\n```\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n```Java\n\r\n\r\ncargo build --release && ./target/release/cli\r\nRecordBatch has 1 rows and 1 columns\r\nRecordBatch has 1 rows and 2 columns\r\nNone retf1\r\nNone retf2\r\n\r\n```\r\n\r\n\u00a0\r\n\r\nIn case of no aggregation:\r\n\r\n\u00a0\r\n\r\n```Java\n\r\n\r\nlet sql = \"SELECT index FROM awesome_table\";\r\n\r\n// create the query plan\r\n let plan = ctx.create_logical_plan(&sql)?;\r\n let plan = ctx.optimize(&plan)?;\r\n let plan = ctx.create_physical_plan(&plan, 1024 * 1024)?;\r\n\r\n// execute the query\r\n let results = ctx.collect(plan.as_ref())?;\r\n\r\n// iterate over the results\r\n results.iter().for_each(|batch| {\r\n println!(\r\n \"RecordBatch has {} rows and {} columns\",\r\n batch.num_rows(),\r\n batch.num_columns(),\r\n );\r\n\r\nlet retf1 = batch.column(0).as_any().downcast_ref::<UInt32Array>();\r\n\r\nmatch retf1 {\r\n Some(_) => println!(\"Some retf1\"),\r\n None => println!(\"None retf1\"),\r\n }\r\n\r\n// let retf2 = batch.column(1).as_any().downcast_ref::<UInt32Array>();\r\n\r\n// match retf2 {\r\n // Some(_) => println!(\"Some retf2\"),\r\n // None => println!(\"None retf2\"),\r\n // }\r\n\r\nfor i in 0..batch.num_rows() {\r\n println!(\"P: {}\", retf1.unwrap().value(i));\r\n }\r\n });\r\n\r\nOk(())\r\n}\r\n\r\n```\r\n\r\n\u00a0\r\n\r\n```Java\n\r\n\r\n\u00a0\r\n\r\nP: 126436\r\nP: 126437\r\nP: 126438\r\nP: 126439\r\nP: 126440\r\nP: 126441\r\n\r\n```\r\n\r\n\u00a0\u00a0\r\n\r\nIs there a way to access the fields when aggregating?",
        "created_at": "2020-02-16T19:00:02.000Z",
        "updated_at": "2020-02-17T16:26:25.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: Rust - DataFusion",
            "Type: bug"
        ],
        "closed": true,
        "closed_at": "2020-02-17T16:26:25.000Z"
    },
    "comments": [
        {
            "created_at": "2020-02-17T15:10:44.550Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-7866?focusedCommentId=17038425) by Andy Grove (andygrove):*\nAre you able to share the CSV file so I can reproduce?\r\n\r\n`SELECT COUNT(expr)` definitely wouldn't return a StringArray though but a numeric type. You can use the meta data in the RecordBatch to determine the column data types."
        },
        {
            "created_at": "2020-02-17T15:42:02.171Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-7866?focusedCommentId=17038451) by Istvan Szukacs (leccine):*\nHi Andy,\r\n\r\n\u00a0\r\n\r\nThanks for taking a look.\r\n\r\n\u00a0\r\n```java\n\r\n,tablename,datetime,partition,fileSize\r\n0,0e986e1f30da0ccf01a0556e0015c97fa2b4bd5e3bcd91b7bc1eff72,2019-08-18,04ead5e5d6d3d993,28210\r\n1,0e986e1f30da0ccf01a0556e0015c97fa2b4bd5e3bcd91b7bc1eff72,2019-09-23,04ead5e5d6d3d993,30645\r\n2,0e986e1f30da0ccf01a0556e0015c97fa2b4bd5e3bcd91b7bc1eff72,2019-08-01,6742544da69d3303,31446\r\n3,0e986e1f30da0ccf01a0556e0015c97fa2b4bd5e3bcd91b7bc1eff72,2019-08-01,6742544da69d3303,99491\r\n4,0e986e1f30da0ccf01a0556e0015c97fa2b4bd5e3bcd91b7bc1eff72,2019-08-01,6742544da69d3303,139799\r\n5,0e986e1f30da0ccf01a0556e0015c97fa2b4bd5e3bcd91b7bc1eff72,2019-08-01,6742544da69d3303,161406\r\n6,0e986e1f30da0ccf01a0556e0015c97fa2b4bd5e3bcd91b7bc1eff72,2019-08-01,6742544da69d3303,102460\r\n7,0e986e1f30da0ccf01a0556e0015c97fa2b4bd5e3bcd91b7bc1eff72,2019-08-01,6742544da69d3303,86220\r\n8,0e986e1f30da0ccf01a0556e0015c97fa2b4bd5e3bcd91b7bc1eff72,2019-08-01,6742544da69d3303,106352 \n```"
        },
        {
            "created_at": "2020-02-17T15:45:34.779Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-7866?focusedCommentId=17038457) by Istvan Szukacs (leccine):*\n\u00a0>> You can use the meta data in the RecordBatch to determine the column data types.\r\n\r\n\u00a0\r\n\r\nSorry for my ignorance, I am completely new to Rust/Datafusion. How am I supposed to do that? Just try to log the batch variable? I am trying that now."
        },
        {
            "created_at": "2020-02-17T16:02:23.678Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-7866?focusedCommentId=17038474) by Istvan Szukacs (leccine):*\nI guess I start to see what you are saying:\r\n\r\n\u00a0\r\n\r\n```Java\n\r\n\r\nprintln!(\r\n \"RecordBatch has {} rows and {} columns \\{:?}\",\r\n batch.num_rows(),\r\n batch.num_columns(),\r\n batch.column(0)\r\n );\r\n\r\n```\r\n\r\n\u00a0\r\n\r\n```Java\n\r\n\r\nRecordBatch has 1 rows and 1 columns PrimitiveArray<UInt64>\r\n[\r\n 126442,\r\n]\r\n\r\n```"
        },
        {
            "created_at": "2020-02-17T16:26:09.509Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-7866?focusedCommentId=17038490) by Istvan Szukacs (leccine):*\nThanks `[~andygrove]`, with your help I was able to have the value correctly printed.\r\n\r\n\u00a0\r\n\r\n`let retf1 = batch.column(0).as_any().downcast_ref::<UInt64Array>().unwrap();`\r\n\r\n`println!(\"P: \\{:?}\", retf1.value(0));`"
        }
    ]
}