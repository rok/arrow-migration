{
    "issue": {
        "title": "[Java] bug in BaseVariableWidthVector.copyFromSafe results with an index out of bounds exception",
        "body": "***Note**: This issue was originally created as [ARROW-7837](https://issues.apache.org/jira/browse/ARROW-7837). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nThere's a subtle bug in the copySafe method of\u00a0BaseVariableWidthVector that results with an index out of bounds exception.\r\n\r\nThe issue is somewhere between the safeCopy and handleSafe methods,\r\n\r\ncopySafe calls handleSafe in order to assure underlying buffers capacity before appending a value to the vector, however the handleSafe method falsely assumes all 'holes' have been field when checking the next write offset. as a result it reads a stale offset (I believe it's 0 for freshly allocated buffers but may be un-guaranteed when reusing a buffer) and fails to identify the need to resize the values buffer.\r\n\r\n\u00a0\r\n\r\nthe following (scala) test demonstrates the issue (by artificially shrinking the values buffer). it was written after we've hit this in production:\r\n```java\n\r\ntest(\"try to reproduce Arrow issue\"){\r\n    val charVector = new VarCharVector(\"stam\", Allocator.get)\r\n\r\n    val srcCharVector = new VarCharVector(\"src\", Allocator.get)\r\n    srcCharVector.setSafe(0, Array.tabulate(20)(_.toByte))\r\n    srcCharVector.setValueCount(2)\r\n\r\n    for( i <- 0 until 4){\r\n      charVector.copyFromSafe(0, i, srcCharVector)\r\n      charVector.setValueCount(i + 1)\r\n    }\r\n\r\n    val valBuff = charVector.getBuffers(false)(2)\r\n    valBuff.capacity(90)\r\n\r\n    charVector.copyFromSafe(0, 14, srcCharVector)\r\n\r\n    srcCharVector.close()\r\n    charVector.close()\r\n  }\r\n```\r\n\u00a0this test fails with the following exception:\r\n\r\n\u00a0\r\n```java\n\r\nindex: 80, length: 20 (expected: range(0, 90))\r\njava.lang.IndexOutOfBoundsException: index: 80, length: 20 (expected: range(0, 90))\r\n\tat io.netty.buffer.ArrowBuf.getBytes(ArrowBuf.java:929)\r\n\tat org.apache.arrow.vector.BaseVariableWidthVector.copyFromSafe(BaseVariableWidthVector.java:1345)\r\n\tat com.datorama.pluto.arrow.ArroStreamSerializationTest.$anonfun$new$33(ArroStreamSerializationTest.scala:454)\r\n\tat com.datorama.pluto.arrow.ArroStreamSerializationTest$$Lambda$129.00000000F78CFE20.apply$mcV$sp(Unknown Source)\r\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)\r\n\tat org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\r\n\tat org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\r\n\tat org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\r\n\tat org.scalatest.Transformer.apply(Transformer.scala:22)\r\n\tat org.scalatest.Transformer.apply(Transformer.scala:20)\r\n\tat org.scalatest.FunSuiteLike$$anon$1.apply(FunSuiteLike.scala:186)\r\n\tat org.scalatest.TestSuite.withFixture(TestSuite.scala:196)\r\n\tat org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)\r\n\tat org.scalatest.FunSuite.withFixture(FunSuite.scala:1560)\r\n\tat org.scalatest.FunSuiteLike.invokeWithFixture$1(FunSuiteLike.scala:184)\r\n\tat org.scalatest.FunSuiteLike.$anonfun$runTest$1(FunSuiteLike.scala:196)\r\n\tat org.scalatest.FunSuiteLike$$Lambda$367.00000000001B9220.apply(Unknown Source)\r\n\tat org.scalatest.SuperEngine.runTestImpl(Engine.scala:289)\r\n\tat org.scalatest.FunSuiteLike.runTest(FunSuiteLike.scala:196)\r\n\tat org.scalatest.FunSuiteLike.runTest$(FunSuiteLike.scala:178)\r\n\tat com.datorama.pluto.arrow.ArroStreamSerializationTest.org$scalatest$BeforeAndAfterEachTestData$$super$runTest(ArroStreamSerializationTest.scala:32)\r\n\tat org.scalatest.BeforeAndAfterEachTestData.runTest(BeforeAndAfterEachTestData.scala:194)\r\n\tat org.scalatest.BeforeAndAfterEachTestData.runTest$(BeforeAndAfterEachTestData.scala:187)\r\n\tat com.datorama.pluto.arrow.ArroStreamSerializationTest.runTest(ArroStreamSerializationTest.scala:32)\r\n\tat org.scalatest.FunSuiteLike.$anonfun$runTests$1(FunSuiteLike.scala:229)\r\n\tat org.scalatest.FunSuiteLike$$Lambda$358.000000001AAC0020.apply(Unknown Source)\r\n\tat org.scalatest.SuperEngine.$anonfun$runTestsInBranch$1(Engine.scala:396)\r\n\tat org.scalatest.SuperEngine$$Lambda$359.000000001AAC0820.apply(Unknown Source)\r\n\tat scala.collection.immutable.List.foreach(List.scala:388)\r\n\tat org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:384)\r\n\tat org.scalatest.SuperEngine.runTestsInBranch(Engine.scala:379)\r\n\tat org.scalatest.SuperEngine.runTestsImpl(Engine.scala:461)\r\n\tat org.scalatest.FunSuiteLike.runTests(FunSuiteLike.scala:229)\r\n\tat org.scalatest.FunSuiteLike.runTests$(FunSuiteLike.scala:228)\r\n\tat org.scalatest.FunSuite.runTests(FunSuite.scala:1560)\r\n\tat org.scalatest.Suite.run(Suite.scala:1147)\r\n\tat org.scalatest.Suite.run$(Suite.scala:1129)\r\n\tat org.scalatest.FunSuite.org$scalatest$FunSuiteLike$$super$run(FunSuite.scala:1560)\r\n\tat org.scalatest.FunSuiteLike.$anonfun$run$1(FunSuiteLike.scala:233)\r\n\tat org.scalatest.FunSuiteLike$$Lambda$352.0000000019149C20.apply(Unknown Source)\r\n\tat org.scalatest.SuperEngine.runImpl(Engine.scala:521)\r\n\tat org.scalatest.FunSuiteLike.run(FunSuiteLike.scala:233)\r\n\tat org.scalatest.FunSuiteLike.run$(FunSuiteLike.scala:232)\r\n\tat com.datorama.pluto.arrow.ArroStreamSerializationTest.org$scalatest$BeforeAndAfterAll$$super$run(ArroStreamSerializationTest.scala:32)\r\n\tat org.scalatest.BeforeAndAfterAll.liftedTree1$1(BeforeAndAfterAll.scala:213)\r\n\tat org.scalatest.BeforeAndAfterAll.run(BeforeAndAfterAll.scala:210)\r\n\tat org.scalatest.BeforeAndAfterAll.run$(BeforeAndAfterAll.scala:208)\r\n\tat com.datorama.pluto.arrow.ArroStreamSerializationTest.run(ArroStreamSerializationTest.scala:32)\r\n\tat org.scalatest.tools.SuiteRunner.run(SuiteRunner.scala:45)\r\n\tat org.scalatest.tools.Runner$.$anonfun$doRunRunRunDaDoRunRun$13(Runner.scala:1346)\r\n\tat org.scalatest.tools.Runner$.$anonfun$doRunRunRunDaDoRunRun$13$adapted(Runner.scala:1340)\r\n\tat org.scalatest.tools.Runner$$$Lambda$164.0000000017957020.apply(Unknown Source)\r\n\tat scala.collection.immutable.List.foreach(List.scala:388)\r\n\tat org.scalatest.tools.Runner$.doRunRunRunDaDoRunRun(Runner.scala:1340)\r\n\tat org.scalatest.tools.Runner$.$anonfun$runOptionallyWithPassFailReporter$24(Runner.scala:1031)\r\n\tat org.scalatest.tools.Runner$.$anonfun$runOptionallyWithPassFailReporter$24$adapted(Runner.scala:1010)\r\n\tat org.scalatest.tools.Runner$$$Lambda$78.000000001B0D5820.apply(Unknown Source)\r\n\tat org.scalatest.tools.Runner$.withClassLoaderAndDispatchReporter(Runner.scala:1506)\r\n\tat org.scalatest.tools.Runner$.runOptionallyWithPassFailReporter(Runner.scala:1010)\r\n\tat org.scalatest.tools.Runner$.run(Runner.scala:850)\r\n\tat org.scalatest.tools.Runner.run(Runner.scala)\r\n\tat org.jetbrains.plugins.scala.testingSupport.scalaTest.ScalaTestRunner.runScalaTest2(ScalaTestRunner.java:133)\r\n\tat org.jetbrains.plugins.scala.testingSupport.scalaTest.ScalaTestRunner.main(ScalaTestRunner.java:27)\r\n```\r\n\r\nI believe the root cause for this bugs is in [this line](https://github.com/apache/arrow/blob/apache-arrow-0.15.0/java/vector/src/main/java/org/apache/arrow/vector/BaseVariableWidthVector.java#L1237) in the handleSafe method:\r\n\r\n```java\n\r\nfinal int startOffset = getStartOffset(index);\r\n```\r\n\r\nwe've encountered this bug in dremio's HashJoinOperator, where a loop has two cases: in one case it appends to one vector and in the other case it appends to another, when there are 'holes' in this loop it ends up calling copySafe with an index which is several slots away from the last update, in most cases this goes well but it occasionally (quite rare, but happens) misses the need to resize the values buffer.\r\n\r\nwill you be willing to accept a pull request fixing this issue?",
        "created_at": "2020-02-12T07:14:59.000Z",
        "updated_at": "2020-03-06T04:52:19.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: Java",
            "Type: bug"
        ],
        "closed": true,
        "closed_at": "2020-03-06T04:51:59.000Z"
    },
    "comments": [
        {
            "created_at": "2020-02-16T13:42:55.027Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-7837?focusedCommentId=17037836) by Ori Dagan (odagan@dalesforce.com):*\n`[~npr]` \u00a0- This should be a bug (might have been open as Improvement by mistake)\u00a0"
        },
        {
            "created_at": "2020-02-17T13:02:39.516Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-7837?focusedCommentId=17038334) by Liya Fan (fan_li_ya):*\n`[~eyalfa]` Thanks a lot for reporting this issue. I think it is a real bug, which can be triggered when the target vector is not written in consecutive slots. \r\n\r\nIt should be resolved by calling the `fillHoles` method in the `copySafe` method. "
        },
        {
            "created_at": "2020-02-17T13:10:27.653Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-7837?focusedCommentId=17038338) by Eyal Farago (eyalfa):*\n[~fan_li_ya], yes it is a real bug, we've hit this in production.\r\none way toy solve this might be calling fillHoles, another might be considering the lastIndexSet member, read the corresponding offset and use that to decide if the current write requires a resize of the values buffer.\r\n\r\nbtw, what do you mean by non-consecutive slots? in out use-case the code populating the vector simply skipped null slots instead of explicitly setting them to nulls (probably relying on fillHoles) - is this what you mean?\r\n\r\nanother thing, the handleSafe method is used by several other 'safe' methods so I think it should be fixed (not copySafe which is just one of the call sites).\r\n\r\nasking again,\r\nwill you accept a pull request with a fix?"
        },
        {
            "created_at": "2020-02-17T13:36:23.163Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-7837?focusedCommentId=17038355) by Liya Fan (fan_li_ya):*\n> btw, what do you mean by non-consecutive slots? in out use-case the code populating the vector simply skipped null slots instead of explicitly setting them to nulls (probably relying on fillHoles) - is this what you mean?\r\n\r\nYes, this is what I mean.\r\n\r\n> the handleSafe method is used by several other 'safe' methods so I think it should be fixed (not copySafe which is just one of the call sites).\r\n\r\nMaybe we should prepare a unit test for each case, and discuss it case by case.\r\n\r\n> will you accept a pull request with a fix?\r\n\r\nSure. A PR with a fix would be great. \r\n\r\n"
        },
        {
            "created_at": "2020-03-06T04:51:59.297Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-7837?focusedCommentId=17053021) by Micah Kornfield (emkornfield@gmail.com):*\nIssue resolved by pull request 6461\n<https://github.com/apache/arrow/pull/6461>"
        }
    ]
}