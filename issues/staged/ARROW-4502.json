{
    "issue": {
        "title": "[C#] Add support for zero-copy reads",
        "body": "***Note**: This issue was originally created as [ARROW-4502](https://issues.apache.org/jira/browse/ARROW-4502). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nIn the Python (and C++) API, you can create a `RecordBatchStreamReader`, and if you give it an `InputStream` that supports zero-copy reads, you can\u00a0get back `RecordBatch` objects without\u00a0allocating new memory and copying\u00a0all the data.\r\n\r\nThere is currently no way to read Arrow\u00a0RecordBatch instances without allocating new memory and copying all the data. We should enable this scenario in the C# API.\r\n\r\n\u00a0\r\n\r\nMy proposal is to create a new `class ArrowRecordBatchReader : IArrowReader`. It's constructor will take a `ReadOnlyMemory<byte> data` parameter, and it will be able to read `RecordBatch` instances just like the existing `ArrowStreamReader`. As part of this new class, we will refactor\u00a0any common code out of `ArrowStreamReader`\u00a0in order for the parsing logic to be shared, where necessary.",
        "created_at": "2019-02-08T00:18:26.000Z",
        "updated_at": "2019-03-07T15:00:45.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C#",
            "Type: enhancement"
        ],
        "closed": true,
        "closed_at": "2019-03-07T15:00:34.000Z"
    },
    "comments": [
        {
            "created_at": "2019-02-10T22:24:53.125Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-4502?focusedCommentId=16764582) by Eric Erhardt (eerhardt):*\n`[~cshutchinson]` - I've taken a look at this over the weekend, and there are a couple things I wanted to run by you.\r\n1. All of the \"flat buffer\" types are public - is this intentional? They feel more like an \"implementation detail\" to me, and I think we should make them internal. Thoughts?\n1. In order to use `ReadOnlyMemory<byte>` in the API, we will need to split the `ByteBuffer` class into two: an editable version vs. a read-only version. Just like how ReadOnlySpan vs. Span and ReadOnlyMemory vs. Memory are split out. The reason is because I need to pass in a `ReadOnlyMemory<byte>` into a ByteBuffer in order to read \"Messages\". Note: I also needed to change ByteBuffer to be backed by a Memory instead of a managed `byte[]`. The reasoning here is because someone\u00a0may be passing in Arrow RecordBatch data in native memory (for interop scenarios with other languages like C++). It shouldn't be necessary to copy that native memory into a managed `byte[]` just to read the RecordBatch.\n   \n   \u00a0\n   \n   I have some preliminary perf results to share with my investigation. Reading in ~1 million records with 7 number columns and adding up all the numbers is\u00a0a lot faster without doing the\u00a0allocations and copies. Here are some benchmark results of my prototype vs. the current ArrowStreamReader both reading from an in-memory buffer (MemoryStream):\n   \n   Method | Mean | Gen 0/1k Op | Allocated Memory/Op |\n   ----------------------- |----------~~:|~~--------~~:|~~---------:|\n    ArrowStreamReader | 110.018 ms | 21000.0000 |110693.78 KB |\n    ArrowRecordBatchReader | 6.789 ms | - | 63.52 KB |\n   \n   \u00a0"
        },
        {
            "created_at": "2019-02-10T23:10:53.193Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-4502?focusedCommentId=16764593) by Chris Hutchinson (cshutchinson):*\n`[~eerhardt]` \u00a0\r\n\r\n1.\u00a0The intent was to auto-generate the FlatBuffer code at build time\u00a0using the Google FlatBuffer\u00a0schema compiler tooling (<https://google.github.io/flatbuffers/flatbuffers_guide_using_schema_compiler.html).>\u00a0This was never integrated due to initial time constraints and cross-platform concerns. We opted for just including the output of the schema compiler in the interest of producing a working prototype. I\u00a0agree that all of these types should be marked internal. I guess just be aware all of the FlatBuffer code was generated by the schema compiler, and that's why the types are marked public. There wasn't a lot of time invested in\u00a0adjusting\u00a0the compiler to mark the types as internal.\r\n\r\n2. ByteBuffer was auto-generated by the Google FlatBuffer schema compiler (as mentioned above). It seemed advantageous to use the compiler because it would be\u00a0trivial to keep parity with the Arrow specification. It appears that the best course of action here may be to investigate if the FlatBuffer schema compiler can be patched or\u00a0hooked in order to produce\u00a0zero-copy variants of ByteBuffer that use\u00a0Memory/Span.\u00a0Another option may be to forgo the FlatBuffer compiler entirely and write a custom solution for serialization that\u00a0otherwise follows the FlatBuffer spec. Thoughts? You definitely have the correct idea but the problem is you are modifying generated code, so we should be careful with that.\r\n\r\n3. It would be\u00a0great if you could include those benchmarks in the solution to help compare with future improvements. If you have the time for this, consider the file system structure used by Entity Framework Core project: <https://github.com/aspnet/EntityFrameworkCore>\r\n\r\n4. Consider taking a look at recent changes to ArrowBufferBuilder<T>. This was recently changed to use managed memory until the buffer is \"built\". The intention here was\u00a0a) make it possible to build multiple copies of an array backed by separate memory, b) reuse the buffer builder.\u00a0I'm not sure that this was a good idea.\u00a0Do you have any thoughts here? The approach that Rust takes is to build the buffer up\u00a0using the typical Arrow memory allocation strategies, then \"freeze\"\u00a0the buffer memory into a new Arrow buffer. This implies a single builder per buffer. That's not necessarily a bad thing.\u00a0It means\u00a0(essentially) one allocation per buffer instead of\u00a0(possibly) two. It may be better for API usability and in\u00a0the spirit of minimizing allocations.\u00a0Thoughts here?\u00a0\r\n\r\nThanks for taking a look. I'm sure there's many areas of improvement. Let me know if you have any more questions. I look forward to collaborating with you!\r\n\r\n\u00a0"
        },
        {
            "created_at": "2019-02-11T19:37:33.145Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-4502?focusedCommentId=16765331) by Eric Erhardt (eerhardt):*\nI think the first thing that needs to be done is update to the latest\u00a0Google FlatBuffers code. I see they have\u00a0[C# support for directly reading and writing to memory other than byte](https://github.com/google/flatbuffers/pull/4886)\u00a0now. I will get this done today and send a PR. Does that need a separate Jira issue `[~wesmckinn]`? Or can I just reference this issue in the PR, and say the PR is \"working towards ARROW-4502\"?\r\n\r\n\u00a0\r\n\r\n`[~cshutchinson]` - Some thoughts about your reply above:\r\n1. I don't think generating the code during the build is ideal. My main reasoning is for things like\u00a0[Source Link](https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/sourcelink)\u00a0to work correctly, it needs to point to source code contained in a repository. It also becomes a pain for people who are just browsing the code\u00a0on GitHub or in a code editor.\u00a0The arrow schema doesn't change that often does it, to the point where it needs to be re-generated on every build?\n1. See my comment above - I will update the FlatBuffers code to the latest version, which appears to meet my needs.\n1. Yes! I will include the benchmarks (using\u00a0[BenchmarkDotNet](https://github.com/dotnet/benchmarkdotnet)\u00a0a great tool). I will have to modify the current version a bit, since I am currently using a checked-in Arrow Stream file, which I assume we don't want to do.\n1. I will give the changes a look and provide what feedback I can."
        },
        {
            "created_at": "2019-02-12T14:17:54.681Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-4502?focusedCommentId=16766063) by Uwe Korn (uwe):*\n> I think the first thing that needs to be done is update to the latest Google FlatBuffers code. I see they have C# support for directly reading and writing to memory other than byte now. I will get this done today and send a PR. Does that need a separate Jira issue Wes McKinney? Or can I just reference this issue in the PR, and say the PR is \"working towards ARROW-4502\"?\r\n\r\nA PR addressing a ticket should also fully resolve the ticket, better make a new JIRA when you only address parts of a JIRA."
        },
        {
            "created_at": "2019-02-12T15:04:54.332Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-4502?focusedCommentId=16766115) by Wes McKinney (wesm):*\n`[~eerhardt]` you can create a \"Subtask\" of this JIRA. Click on \"More\" above and select the \"Create sub-task\" option, which creates another JIRA number but attaches it to this issue"
        },
        {
            "created_at": "2019-02-12T15:09:37.717Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-4502?focusedCommentId=16766128) by Eric Erhardt (eerhardt):*\nThanks for the information,\u00a0 `[~xhochy]`. I've created https://issues.apache.org/jira/browse/ARROW-4543\u00a0to update the flat buffers code."
        },
        {
            "created_at": "2019-02-12T15:11:50.037Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-4502?focusedCommentId=16766131) by Eric Erhardt (eerhardt):*\n`[~wesmckinn]` - I've marked 4543 as a \"Subtask\" of this. Thanks for the help, from a Jira newbie. :)"
        },
        {
            "created_at": "2019-03-07T15:00:34.364Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-4502?focusedCommentId=16786860) by Wes McKinney (wesm):*\nIssue resolved by pull request 3736\n<https://github.com/apache/arrow/pull/3736>"
        }
    ]
}