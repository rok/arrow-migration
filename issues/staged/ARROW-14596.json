{
    "issue": {
        "title": "[Python] parquet.read_table nested fields in columns does not work for use_legacy_dataset=False",
        "body": "***Note**: This issue was originally created as [ARROW-14596](https://issues.apache.org/jira/browse/ARROW-14596). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nReading nested field does not work with\u00a0use_legacy_dataset=False.\r\n\r\nThis works:\r\n\r\n\u00a0\r\n```java\n\r\nimport pyarrow.parquet as pq\r\nt = pq.read_table(\r\n source=*filename*,\r\n columns=['store_key', 'properties.country'], \r\n use_legacy_dataset=True,\r\n).to_pandas()\r\n```\r\nThis does not work (for the same parquet file):\r\n\r\n\u00a0\r\n```java\n\r\nimport pyarrow.parquet as pq\r\n\r\nt = pq.read_table(\r\n source=*filename*,\r\n columns=['store_key', 'properties.country'], \r\n use_legacy_dataset=False,\r\n).to_pandas()\n```\r\n\u00a0",
        "created_at": "2021-11-04T20:35:54.000Z",
        "updated_at": "2022-10-20T07:35:40.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: Python",
            "Type: bug"
        ],
        "closed": false
    },
    "comments": [
        {
            "created_at": "2021-11-09T15:11:34.073Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14596?focusedCommentId=17441214) by Joris Van den Bossche (jorisvandenbossche):*\n`[~TomScheffers]` that's indeed a current limitation of the new implementation. There is work underway to enable this (the basic feature was just merged for C++ (ARROW-13987), now it still has to be exposed in python (ARROW-11259)), and hopefully this will be possible in the next version 7.0.0"
        },
        {
            "created_at": "2022-04-21T18:49:59.385Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14596?focusedCommentId=17525981) by Krisztian Szucs (kszucs):*\nPostponing to 9.0"
        },
        {
            "created_at": "2022-04-22T12:59:16.326Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14596?focusedCommentId=17526407) by Alenka Frim (alenka):*\nI would like to add observations we got today when pairing with `[~jorisvandenbossche]` on this topic.\r\n\r\nFirst was the result of using `pq.read_table` with legacy implementation vs using `ds.dataset` with column projection. The data can get selected correctly with the dataset implementation but what happens is that the structure of a nested field is not kept (from struct it is flattened to string column). In case of using columns selection with a list in \u00a0`{}ds.dataset{`}, it errors, as reported in the issue.\r\n```python\n\r\n>>> import pandas as pd\r\n>>> import pyarrow as pa\r\n>>> import pyarrow.parquet as pq\r\n>>> \r\n>>> df = pd.DataFrame({\r\n...     'user_id': ['abc123', 'qrs456'],\r\n...     'interaction': [{'type': 'click', 'element': 'button'}, {'type':'scroll', 'element': 'window'}]\r\n... })\r\n>>> \r\n>>> table = pa.Table.from_pandas(df)\r\n>>> pq.write_table(table, 'example.parquet')\r\n```\r\n```python\n\r\n>>> pq.read_table('example.parquet', columns = ['user_id', 'interaction.type'], use_legacy_dataset = True)\r\npyarrow.Table\r\nuser_id: string\r\ninteraction: struct<type: string>\r\n  child 0, type: string\r\n----\r\nuser_id: [[\"abc123\",\"qrs456\"]]\r\ninteraction: [\r\n  -- is_valid: all not null\r\n  -- child 0 type: string\r\n[\"click\",\"scroll\"]]\r\n```\r\n```python\n\r\n>>> import pyarrow.dataset as ds\r\n>>> projection = {\r\n...         'user_id': ds.field('user_id'),\r\n...         'new': ds.field(('interaction', 'type'))\r\n...     }\r\n>>> ds.dataset('example.parquet').to_table(columns=projection)\r\npyarrow.Table\r\nuser_id: string\r\nnew: string\r\n----\r\nuser_id: [[\"abc123\",\"qrs456\"]]\r\nnew: [[\"click\",\"scroll\"]]\r\n```\r\n```python\n\r\n>>> ds.dataset('example.parquet').to_table(columns=['user_id', 'interaction.type'])\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"pyarrow/_dataset.pyx\", line 303, in pyarrow._dataset.Dataset.to_table\r\n    return self.scanner(**kwargs).to_table()\r\n  File \"pyarrow/_dataset.pyx\", line 270, in pyarrow._dataset.Dataset.scanner\r\n    return Scanner.from_dataset(self, **kwargs)\r\n  File \"pyarrow/_dataset.pyx\", line 2322, in pyarrow._dataset.Scanner.from_dataset\r\n    _populate_builder(builder, columns=columns, filter=filter,\r\n  File \"pyarrow/_dataset.pyx\", line 2168, in pyarrow._dataset._populate_builder\r\n    check_status(builder.ProjectColumns([tobytes(c) for c in columns]))\r\n  File \"pyarrow/error.pxi\", line 100, in pyarrow.lib.check_status\r\n    raise ArrowInvalid(message)\r\npyarrow.lib.ArrowInvalid: No match for FieldRef.Name(interaction.type) in user_id: string\r\ninteraction: struct<element: string, type: string>\r\n__fragment_index: int32\r\n__batch_index: int32\r\n__last_in_fragment: bool\r\n__filename: string\r\n/Users/alenkafrim/repos/arrow/cpp/src/arrow/type.h:1722  CheckNonEmpty(matches, root)\r\n/Users/alenkafrim/repos/arrow/cpp/src/arrow/type.h:1757  FindOne(root)\r\n/Users/alenkafrim/repos/arrow/cpp/src/arrow/dataset/scanner.cc:714  ref->GetOne(dataset_schema)\r\n/Users/alenkafrim/repos/arrow/cpp/src/arrow/dataset/scanner.cc:784  ProjectionDescr::FromNames(std::move(columns), *scan_options_->dataset_schema)\r\n```\r\nWhen Scanner object is being created from the dataset class via `to_table` and (through _populate_builder) and in the case of a list of columns the `ProjectColumns` method (\"arrow::dataset::ScannerBuilder\") is being called it only accepts string column names and errors when a column is a struct.\r\n\r\nWe were thinking if it would be a good idea to add a new method in `scanner.cc` that would mimic `FromNames` method but takes `field_ref` as an argument? Afterwords there would also be a need to recreate a struct field for which we are not sure how to approach.\r\n\r\ncc `[~westonpace]` `[~apitrou]` do you think that would be a correct way to go?"
        }
    ]
}