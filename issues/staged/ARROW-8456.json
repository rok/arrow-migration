{
    "issue": {
        "title": "[Release] Add python script to help curating JIRA",
        "body": "***Note**: This issue was originally created as [ARROW-8456](https://issues.apache.org/jira/browse/ARROW-8456). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nThe following script produces reports like https://gist.github.com/kszucs/9857ef69c92a230ce5a5068551b83ed8\r\n\r\n```python\n\r\nfrom jira import JIRA\r\nimport warnings\r\nimport pygit2\r\nimport pandas as pd\r\nfrom io import StringIO\r\n\r\n\r\nclass Patch:\r\n    \r\n    def __init__(self, commit):\r\n        self.commit = commit\r\n        self.issue_key, self.msg = self._parse(commit.message)\r\n        \r\n    def _parse(self, message):\r\n        first_line = message.splitlines()[0]\r\n        \r\n        m = re.match(\"(?P<ticket>((ARROW|PARQUET)\\-\\d+)):?(?P<msg>.*)\", first_line)\r\n        if m is None:\r\n            return None, ''\r\n\r\n        values = m.groupdict()\r\n        return values['ticket'], values['msg']\r\n    \r\n    @property\r\n    def shortmessage(self):\r\n        if not self.msg:\r\n            return self.commit.message.splitlines()[0]\r\n        else:\r\n            return self.msg\r\n\r\n    @property\r\n    def sha(self):\r\n        return self.commit.id\r\n    \r\n    @property\r\n    def issue_url(self):\r\n        return 'https://issues.apache.org/jira/browse/{}'.format(self.issue_key)\r\n    \r\n    @property\r\n    def commit_url(self):\r\n        return 'https://github.com/apache/arrow/commit/{}'.format(self.sha)\r\n    \r\n    def to_markdown(self):\r\n        if self.issue_key is None:\r\n            return \"[{}]({})\\n\".format(\r\n                self.shortmessage, \r\n                self.commit_url\r\n            )\r\n        else:\r\n            return \"[{}]({}): [{}]({})\\n\".format(\r\n                self.issue_key, \r\n                self.issue_url, \r\n                self.shortmessage, \r\n                self.commit_url\r\n            )\r\n    \r\n    \r\nJIRA_SEARCH_LIMIT = 10000\r\n# JIRA_SEARCH_LIMIT = 50\r\n\r\n\r\nclass Release:\r\n    \"\"\"Release object for querying issues and commits\r\n    \r\n    Usage:\r\n        jira = JIRA(\r\n            {'server': 'https://issues.apache.org/jira'}, \r\n            basic_auth=(user, password)\r\n        )\r\n        repo = pygit2.Repository('path/to/arrow/repo')\r\n        \r\n        release = Release(jira, repo, '0.15.1', '0.15.0')\r\n# show the commits in application order\r\n        for commit in release.commits():\r\n            print(commit.oid)\r\n# cherry-pick the patches to a branch\r\n        release.apply_patches_to('a-branch')\r\n    \"\"\"\r\n    \r\n    def __init__(self, jira, repo, version, previous_version):\r\n        self.jira = jira\r\n        self.repo = repo\r\n        self.version = version\r\n        self.previous_version = previous_version\r\n        self._issues = None\r\n        self._patches = None\r\n        \r\n    def _tag(self, version):\r\n        return self.repo.revparse_single(f'refs/tags/apache-arrow-{version}')\r\n    \r\n    def issues(self):\r\n# FIXME(kszucs): paginate instead of maxresults \r\n        if self._issues is None:\r\n            query = f'project=ARROW AND fixVersion={self.version}'\r\n            self._issues = self.jira.search_issues(query, maxResults=JIRA_SEARCH_LIMIT)\r\n        return self._issues\r\n    \r\n    def patches(self):\r\n        \"\"\"Commits belonging to release applied on master branch\r\n        \r\n        The returned commits' order corresponds to the output of\r\n        git log.\r\n        \"\"\"\r\n        if self._patches is None:\r\n            previous_tag = self._tag(self.previous_version)\r\n            master = self.repo.branches['master']\r\n            ordering = pygit2.GIT_SORT_TOPOLOGICAL | pygit2.GIT_SORT_REVERSE\r\n            walker = self.repo.walk(master.target, ordering)        \r\n            walker.hide(previous_tag.oid)\r\n            self._patches = list(map(Patch, walker))\r\n\r\n        return self._patches\r\n    \r\n    def curate(self):\r\n        issues = self.issues()\r\n        patches = self.patches()\r\n        issue_keys = {issue.key for issue in self.issues()}\r\n        \r\n        within, outside, nojira = [], [], []\r\n        for p in patches:\r\n            if p.issue_key is None:\r\n                nojira.append(p)\r\n            elif p.issue_key in issue_keys:\r\n                within.append(p)\r\n                issue_keys.remove(p.issue_key)\r\n            else:\r\n                outside.append(p)\r\n                \r\n# remaining jira tickets\r\n        nopatch = list(issue_keys)\r\n                \r\n        return within, outside, nojira, nopatch\r\n\r\n    def curation_report(self):\r\n        out = StringIO()\r\n        \r\n        out.write('Total number of JIRA tickets assigned to version {}: {}\\n'\r\n                  .format(self.version, len(self.issues())))\r\n        out.write('\\n')\r\n        out.write('Total number of applied patches since {}: {}\\n'\r\n                  .format(self.previous_version, len(self.patches())))\r\n        \r\n        out.write('\\n\\n')\r\n\r\n        within, outside, nojira, nopatch = self.curate()\r\n        \r\n        out.write('Patches with assigned issue in {}:\\n'.format(self.version))\r\n        for p in within:\r\n            out.write(\"- {}\".format(p.to_markdown()))\r\n        \r\n        out.write('\\n\\n')\r\n        \r\n        out.write('Patches with assigned issue outside of {}:\\n'.format(self.version))\r\n        for p in outside:\r\n            out.write(\"- {}\".format(p.to_markdown()))\r\n        \r\n        out.write('\\n\\n')\r\n                      \r\n        out.write('Patches without assigned issue:\\n')\r\n        for p in nojira:\r\n            out.write(\"- {}\".format(p.to_markdown()))\r\n                      \r\n        out.write('\\n\\n')\r\n                      \r\n        out.write('JIRAs in {} without assigned patch:\\n'.format(self.version))\r\n        for issue_key in nopatch:\r\n            url = 'https://issues.apache.org/jira/browse/{}'.format(issue_key)\r\n            out.write(\"- [{}]({})\\n\".format(issue_key, url))\r\n                      \r\n        return out.getvalue()\r\n\r\n            \r\n    def apply_patches_to(self, branch_name):\r\n        previous_tag = self._tag(self.previous_version)\r\n        branch = repo.create_branch(branch_name, previous_tag.get_object())\r\n        try:\r\n            head = branch.target\r\n            for commit in self.patches():\r\n                base = repo.merge_base(commit.oid, head)\r\n                parent_tree = commit.parents[0].tree\r\n                index = repo.merge_trees(parent_tree, head, commit.oid)\r\n                tree_id = index.write_tree(repo)\r\n                head = repo.create_commit(\r\n                    branch.name, \r\n                    commit.author, \r\n                    commit.committer, \r\n                    commit.message,\r\n                    tree_id, \r\n                    [head]\r\n                )\r\n        except pygit2.GitError:\r\n            repo.branches[branch_name].delete()\r\n            raise\r\n\r\n\r\nimport os\r\nimport pygit2\r\nfrom jira import JIRA \r\n\r\njira = JIRA(\r\n    {'server': 'https://issues.apache.org/jira'}, \r\n    basic_auth=(\r\n        os.environ.get('APACHE_JIRA_USER'), \r\n        os.environ.get('APACHE_JIRA_PASSWORD')\r\n    )\r\n)\r\nrepo = pygit2.Repository('.')\r\n\r\nrelease = Release(jira, repo, version='0.17.0', previous_version='0.16.0')\r\n\r\nreport = release.curation_report()\r\n```",
        "created_at": "2020-04-14T18:16:51.000Z",
        "updated_at": "2022-08-29T14:15:18.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: Developer Tools",
            "Type: enhancement"
        ],
        "closed": true,
        "closed_at": "2022-08-29T14:14:03.000Z"
    },
    "comments": []
}