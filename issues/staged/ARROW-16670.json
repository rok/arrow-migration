{
    "issue": {
        "title": "[R] Behaviour of R-specific key/value metadata in the query engine",
        "body": "***Note**: This issue was originally created as [ARROW-16670](https://issues.apache.org/jira/browse/ARROW-16670). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nIn ARROW-16607 there are some changes to metadata handling in the `arrow_dplyr_query`. With extension type support, more column types (like sf::sfc) can be supported, and with growing support for column types comes a greater chance that our current metadata restoration by default policy will cause difficult-to-work-around errors. The latest one I have run across is this one:\r\n\r\n```R\n\r\nlibrary(arrow, warn.conflicts = FALSE)\r\nlibrary(dplyr, warn.conflicts = FALSE)\r\n# required for write_dataset(nc) to work\r\n# remotes::install_github(\"paleolimbot/geoarrow\")\r\nlibrary(geoarrow)\r\nlibrary(sf)\r\n#> Linking to GEOS 3.9.1, GDAL 3.4.2, PROJ 8.2.1; sf_use_s2() is TRUE\r\n\r\nnc <- read_sf(system.file(\"shape/nc.shp\", package = \"sf\"))\r\ntf <- tempfile()\r\nwrite_dataset(nc, tf)\r\n\r\nopen_dataset(tf) %>% \r\n  select(NAME, FIPS) %>% \r\n  collect()\r\n#> Error in st_geometry.sf(x): attr(obj, \"sf_column\") does not point to a geometry column.\r\n#> Did you rename it, without setting st_geometry(obj) <- \"newname\"?\r\n```\r\n\r\nThis causes an error because the restored class has assumptions about the contents of the data frame that we can't necessarily know about (or would have to hard code for every data frame subclass).\r\n\r\nI can see why `arrow::write_parquet()` and `arrow::read_parquet()` (and feather, ipc_stream) might want to do this to faithfully roundtrip a data frame, and because the write/read roundtrip (usually) involves the same columns and the same rows, it's probably safe to restore metadata by default.\r\n\r\n The query engine does a lot of transformations that can break assumptions like the one I've shown above (where sf expects a certain column to exist and errors otherwise in a way that the user can't work around). Rather than hard-code the assumptions of every data.frame and vector subclass, I wonder if ignoring the R metadata for query engine output would be a better strategy. If it's not the default, it would be nice to provide an escape hatch for users or developers that find themselves in this position with no workaround.\r\n\r\nWith the addition of the vctrs extension type, there is a route to preserve attributes through the query engine (although it's a bit verbose). We could make it easier to do (e.g., by interpreting `I()` or `rlang::box()` in some way).\r\n\r\n```R\n\r\nlibrary(arrow, warn.conflicts = FALSE)\r\nlibrary(dplyr, warn.conflicts = FALSE)\r\n\r\ndf <- data.frame(int_col = 1:5)\r\nattr(df$int_col, \"some_attr\") <- \"some_value\"\r\n\r\ntf <- tempfile()\r\n\r\n#  attributes dropped when column is renamed\r\nwrite_dataset(df, tf)\r\n\r\nopen_dataset(tf) %>% \r\n  select(other_int_col = int_col) %>% \r\n  collect() %>% \r\n  pull()\r\n#> [1] 1 2 3 4 5\r\n\r\n# attributes preserved when column is renamed\r\ntable <- arrow_table(int_col = vctrs_extension_array(df$int_col))\r\nwrite_dataset(table, tf)\r\n\r\nopen_dataset(tf) %>% \r\n  select(other_int_col = int_col) %>% \r\n  collect() %>% \r\n  pull()\r\n#> [1] 1 2 3 4 5\r\n#> attr(,\"some_attr\")\r\n#> [1] \"some_value\"\r\n```\r\n",
        "created_at": "2022-05-26T16:46:55.000Z",
        "updated_at": "2022-05-26T20:33:03.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: R",
            "Type: enhancement"
        ],
        "closed": false
    },
    "comments": [
        {
            "created_at": "2022-05-26T20:32:26.017Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16670?focusedCommentId=17542659) by Weston Pace (westonpace):*\n> I wonder if ignoring the R metadata for query engine output would be a better strategy. If it's not the default, it would be nice to provide an escape hatch for users or developers that find themselves in this position with no workaround.\r\n\r\n\r\nThis would be my assumption.  The query engine has no idea what metadata is.  It does not really make any attempt to preserve it.\r\n\r\nSometimes users are doing something like rewriting a file with a different chunk size or repartitioning a dataset.  In this case it can sometimes make sense to persist the origin metadata.  However, I think the best solution for that is to reattach the metadata after it has gone through the query engine.  The write/sink nodes should have options to attach custom metadata.  We can expand on these as needed."
        }
    ]
}