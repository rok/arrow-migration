{
    "issue": {
        "title": "[R] open_dataset() does not work on CSVs without header rows",
        "body": "***Note**: This issue was originally created as [ARROW-14063](https://issues.apache.org/jira/browse/ARROW-14063). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nUsing `open_dataset()` on a CSV without a header row,\u00a0followed by `collect()`, results either in a `tibble`\u00a0of \\`NA`s\u00a0or an error depending on duplication of the first row of data. This affects reading one file or a directory of files.\r\n\r\nHere we use the `diamonds` data, where the first row of data does not have any repeat values.\r\n```java\n\r\nlibrary(arrow)\r\nlibrary(magrittr)\r\n\r\ndata(diamonds, package='ggplot2')\r\n\r\nreadr::write_csv(head(diamonds), file='diamonds_with_header.csv', col_names=TRUE)\r\nreadr::write_csv(head(diamonds), file='diamonds_without_header.csv', col_names=FALSE)\r\n\r\ndiamond_schema <- schema(\r\n    carat=float32()\r\n    , cut=string()\r\n    , color=string()\r\n    , clarity=string()\r\n    , depth=float32()\r\n    , table=float32()\r\n    , price=float32()\r\n    , x=float32()\r\n    , y=float32()\r\n    , z=float32()\r\n)\r\n\r\ndiamonds_with_headers <- open_dataset('diamonds_with_header.csv', schema=diamond_schema, format='csv')\r\ndiamonds_without_headers <- open_dataset('diamonds_without_header.csv', schema=diamond_schema, format='csv')\r\n\r\n# this works\r\ndiamonds_with_headers %>% collect()\r\n# A tibble: 6 x 10\r\n  carat cut       color clarity depth table price     x     y     z\r\n  <dbl> <chr>     <chr> <chr>   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\r\n1 0.230 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\r\n2 0.210 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\r\n3 0.230 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\r\n4 0.290 Premium   I     VS2      62.4    58   334  4.20  4.23  2.63\r\n5 0.310 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\r\n6 0.240 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\r\n\r\n# this gives a tibble with all NA values, though of the correct types\r\ndiamonds_without_headers %>% collect()\r\n# A tibble: 5 x 10\r\n  carat cut   color clarity depth table price     x     y     z\r\n  <dbl> <chr> <chr> <chr>   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\r\n1    NA NA    NA    NA         NA    NA    NA    NA    NA    NA\r\n2    NA NA    NA    NA         NA    NA    NA    NA    NA    NA\r\n3    NA NA    NA    NA         NA    NA    NA    NA    NA    NA\r\n4    NA NA    NA    NA         NA    NA    NA    NA    NA    NA\r\n5    NA NA    NA    NA         NA    NA    NA    NA    NA    NA\r\n```\r\nNow we use a simple dataset where two of the columns in the first row have the same value, 0.0.\r\n\r\n\u00a0\r\n```java\n\r\nrandomDF <- tibble::tibble(\r\n    A=c(0.0, 2.3, 5.1)\r\n    , B=c('a', 'b', 'a')\r\n    , C=c(0.0, 3.1, 4.5)\r\n)\r\n\r\nreadr::write_csv(randomDF, file='random_with_header.csv', col_names=TRUE)\r\nreadr::write_csv(randomDF, file='random_without_header.csv', col_names=FALSE)\r\n\r\nrandom_schema <- schema(\r\n    A=float32()\r\n    , B=string()\r\n    , C=float32()\r\n)\r\n\r\nrandom_with_headers <- open_dataset('random_with_header.csv', schema=random_schema, format='csv')\r\nrandom_without_headers <- open_dataset('random_without_header.csv', schema=random_schema, format='csv')\r\n\r\n# gives a tibble with the proper values\r\nread_with_headers %>% collect()\r\n# A tibble: 3 x 3\r\n      A B         C\r\n  <dbl> <chr> <dbl>\r\n1  0    a      0   \r\n2  2.30 b      3.10\r\n3  5.10 a      4.5 \r\n\r\n# results in an error\r\nread_without_headers %>% collect()\r\nError: Invalid: Could not open CSV input source 'without_header.csv': Invalid: CSV file contained multiple columns named 0\r\n```\r\nInterestingly, `read_csv_arrow()` has the opposite problem. Providing the schema works for CSVs without headers, but not with, despite the help file saying that providing a schema satisfies both `col_nmames` and `col_types`.\r\n\r\n\u00a0\r\n```java\n\r\ndiamonds_read_with_header <- read_csv_arrow('diamonds_with_header.csv', schema=diamond_schema)\r\nError: Invalid: In CSV column #0: CSV conversion error to float: invalid value 'carat'\r\n\r\ndiamonds_read_without_header <- read_csv_arrow('diamonds_without_header.csv', schema=diamond_schema)\r\n# reads normally\r\n\r\n\r\nrandom_read_with_header <- read_csv_arrow('random_with_header.csv', schema=random_schema)\r\nError: Invalid: In CSV column #0: CSV conversion error to float: invalid value 'A'\r\n\r\nrandom_read_without_header <- read_csv_arrow('random_without_header.csv', schema=random_schema)\r\n# reads normally\n```",
        "created_at": "2021-09-21T21:54:52.000Z",
        "updated_at": "2022-03-04T15:41:55.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: R",
            "Type: bug"
        ],
        "closed": true,
        "closed_at": "2021-10-13T22:04:44.000Z"
    },
    "comments": [
        {
            "created_at": "2021-10-02T15:50:18.435Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14063?focusedCommentId=17423548) by Nicola Crane (thisisnic):*\nWe have a ticket open already to address the confusing behaviour for `read_csv_arrow()`, (ARROW-13887), but will look into the `open_dataset()` issue shortly. "
        },
        {
            "created_at": "2021-10-06T15:11:09.235Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14063?focusedCommentId=17425037) by Nicola Crane (thisisnic):*\nThanks for flagging this up `[~jaredlander]`!\r\n\r\nIt looks like we're always assuming that CSVs read in via `open_dataset` have a header row.  Will look into solutions."
        },
        {
            "created_at": "2021-10-06T15:51:17.622Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14063?focusedCommentId=17425052) by Nicola Crane (thisisnic):*\nA short-term solution in the case of `open_dataset()` and CSVs without headers would be to instead specify the column names as such: \r\n\r\n```r\n\r\nrandom_without_headers <- open_dataset(\r\n  'random_without_header.csv',\r\n  schema = random_schema,\r\n  format = 'csv',\r\n  read_options = CsvReadOptions$create(column_names = names(random_schema))\r\n)\r\n```\r\n\r\nHowever, this isn't great - I'll see if I can get this happening automatically."
        },
        {
            "created_at": "2021-10-13T22:04:44.281Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14063?focusedCommentId=17428517) by Neal Richardson (npr):*\nIssue resolved by pull request 11346\n<https://github.com/apache/arrow/pull/11346>"
        },
        {
            "created_at": "2021-10-14T17:06:31.272Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14063?focusedCommentId=17428917) by Jared Lander (jaredlander):*\nJust installed the nightly (5.0.0.20211013) and now it does not work if there are headers. Could be something I'm doing wrong though, haven't tested extensively."
        },
        {
            "created_at": "2021-10-14T17:13:17.683Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14063?focusedCommentId=17428923) by Neal Richardson (npr):*\nLet me see if I understand: before, if you provided a schema, it would work if there was a header row in the CSVs but not if there wasn't. Now, it is flipped? \r\n\r\nIf you add `skip = 1` to open_dataset, does that case work now?"
        },
        {
            "created_at": "2021-10-14T17:59:49.044Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14063?focusedCommentId=17428947) by Jared Lander (jaredlander):*\nYep, it's flipped. If I do skip = 1 I get\r\n\r\n\u00a0\r\n```java\n\r\nError: The following option is supported in \"read_delim_arrow\" functions but not yet supported here: \"skip\"\r\n```"
        },
        {
            "created_at": "2021-10-14T19:23:16.788Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14063?focusedCommentId=17428990) by Neal Richardson (npr):*\nHow about `skip_rows = 1` (trying to see if it's just an argument naming issue or something not implemented in C++)?"
        },
        {
            "created_at": "2021-10-14T21:16:22.413Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14063?focusedCommentId=17429018) by Jared Lander (jaredlander):*\nPlayed some more.\r\n\r\nThis works.\r\n```java\n\r\nall_data <- open_dataset(\r\n    'data_folder',\r\n    format='csv',\r\n    schema=the_schema,\r\n    partitioning=NULL,\r\n    unify_schemas=FALSE,\r\n    skip_rows=1,\r\n)\r\n```\r\nAs does this.\r\n```java\n\r\nall_data <- open_dataset(\r\n    'data_folder', \r\n    format='csv', \r\n    schema=the_schema, \r\n    partitioning=NULL, \r\n    unify_schemas=FALSE, \r\n    read_options=arrow::CsvReadOptions$create(skip_rows=1, column_names=names(the_schema))\r\n)\n```\r\nThis does not.\r\n```java\n\r\nall_data <- open_dataset(\r\n 'data_folder', \r\n format='csv', \r\n schema=the_schema, \r\n partitioning=NULL, \r\n unify_schemas=FALSE, \r\n read_options=arrow::CsvReadOptions$create(skip_rows=1)\r\n)\r\n```\r\nNeither does this.\r\n```java\n\r\nall_data <- open_dataset(\r\n 'data_folder', \r\n format='csv', \r\n schema=the_schema, \r\n partitioning=NULL, \r\n unify_schemas=FALSE, \r\n skip=1\r\n)\n```\r\nBut either way, it should probably behave more like what we expect with read_csv_arrow() and work with or without headers by supplying a schema."
        },
        {
            "created_at": "2021-10-15T21:42:15.388Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14063?focusedCommentId=17429493) by Jared Lander (jaredlander):*\nAlso noticing now that if you write_dataset() with partitioning, reading back with a schema does not go well.\u00a0\r\n\r\nWrite the data with \"cut\" as the partition.\r\n```java\n\r\ndata(diamonds, package='ggplot2')\r\nfs::dir_delete('splits/diamonds')\r\nwrite_dataset(diamonds, path='splits/diamonds', format='csv', partitioning=c('cut'))\r\n\r\nfs::dir_ls('splits/diamonds', recurse=TRUE)\r\n\r\nsplits/diamonds/cut=Fair                 splits/diamonds/cut=Fair/part-0.csv      \r\nsplits/diamonds/cut=Good                 splits/diamonds/cut=Good/part-0.csv      \r\nsplits/diamonds/cut=Ideal                splits/diamonds/cut=Ideal/part-0.csv     \r\nsplits/diamonds/cut=Premium              splits/diamonds/cut=Premium/part-0.csv   \r\nsplits/diamonds/cut=Very Good            splits/diamonds/cut=Very Good/part-0.csv \r\n```\r\nMake a schema\r\n```java\n\r\ndiamond_schema <- schema(\r\n    carat=float64(),\r\n    cut=string(),\r\n    color=string(),\r\n    clarity=string(),\r\n    depth=float64(),\r\n    table=float64(),\r\n    price=float64(),\r\n    x=float64(),\r\n    y=float64(),\r\n    z=float64(),\r\n)\r\n```\r\nOpen the folder.\r\n```java\n\r\nrocks <- open_dataset('splits/diamonds', format='csv', schema=diamond_schema)\r\nrocks %>% dplyr::collect()\r\n\r\nError: Invalid: Could not open CSV input source 'splits/diamonds/cut=Good/part-0.csv': Invalid: CSV parse error: Row #1: Expected 10 columns, got 9: \"carat\",\"color\",\"clarity\",\"depth\",\"table\",\"price\",\"x\",\"y\",\"z\"\r\n```\r\nDifferent error with skip_rows.\r\n```java\n\r\nrocks <- open_dataset('splits/diamonds', format='csv', schema=diamond_schema, skip_rows=1)\r\nrocks %>% dplyr::collect()\r\n\r\nError: Invalid: Could not open CSV input source 'splits/diamonds/cut=Good/part-0.csv': Invalid: CSV parse error: Row #2: Expected 10 columns, got 9: 0.23,\"E\",\"VS1\",56.9,65,327,4.05,4.07,2.31\n```\r\nSo then I looked at the help page for open_dataset() and under the partitioning argument it says we can pass a schema and the path segments will be parsed to match the schema. So I tried that.\r\n\r\nFirst, I supplied a schema too both the schema and partitioning arguments.\r\n```java\n\r\nrocks <- open_dataset('splits/diamonds', format='csv', schema=diamond_schema, partitioning=diamond_schema)\r\n\r\nError: Invalid: error parsing 'cut=Fair' as scalar of type double\n```\r\nThen just to the partitioning argument.\r\n```java\n\r\nrocks <- open_dataset('splits/diamonds', format='csv', schema=diamond_schema)\r\nrocks %>% dplyr::collect()\r\n\r\nError: Invalid: Could not open CSV input source 'splits/diamonds/cut=Fair/part-0.csv': Invalid: CSV parse error: Row #1: Expected 10 columns, got 9: \"carat\",\"color\",\"clarity\",\"depth\",\"table\",\"price\",\"x\",\"y\",\"z\"\n```\r\nAnd I tried both with skip_rows=1."
        },
        {
            "created_at": "2021-11-17T22:35:06.722Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14063?focusedCommentId=17445514) by Nicola Crane (thisisnic):*\nThanks for finding all of these `[~jaredlander]`, that's super-helpful!\r\n\r\nI've opened some new tickets:\r\n- partitioning with schema containing partitioned variable: https://issues.apache.org/jira/browse/ARROW-14743\n- needing to supply both the schema and the column names: https://issues.apache.org/jira/browse/ARROW-14744"
        },
        {
            "created_at": "2022-03-04T04:16:12.118Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14063?focusedCommentId=17501145) by Jared Lander (jaredlander):*\nI know this is marked as resolved, but I just tried with Arrow 7.0 and if I want to use open_dataset() on CSVs with header rows and I want to specify the schema (which I have to because the types are guessed incorrectly), then I have to set skip_rows=1, which seems not awesome, especially for someone who doesn't know about this issue. So I just wanted to put a note here that this is still an open issue."
        },
        {
            "created_at": "2022-03-04T15:41:33.233Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14063?focusedCommentId=17501393) by Drago\u0219 Moldovan-Gr\u00fcnfeld (dragosmg):*\nHi `[~jaredlander]`,\r\n\r\nUsing your reprex, I am seeing the following error message:\r\n```r\n\r\n> diamonds_with_headers %>% collect()\r\nError in `handle_csv_read_error()` at r/R/dplyr-collect.R:33:6:\r\n! Invalid: Could not open CSV input source '/Users/dragos/Desktop/diamonds_with_header.csv': Invalid: In CSV column #0: Row #1: CSV conversion error to float: invalid value 'carat'\r\n/Users/dragos/Documents/arrow/cpp/src/arrow/csv/converter.cc:550  decoder_.Decode(data, size, quoted, &value)\r\n/Users/dragos/Documents/arrow/cpp/src/arrow/csv/parser.h:123  status\r\n/Users/dragos/Documents/arrow/cpp/src/arrow/csv/converter.cc:554  parser.VisitColumn(col_index, visit)\r\n/Users/dragos/Documents/arrow/cpp/src/arrow/csv/reader.cc:464  arrow::internal::UnwrapOrRaise(maybe_decoded_arrays)\r\n/Users/dragos/Documents/arrow/cpp/src/arrow/compute/exec/exec_plan.cc:484  iterator_.Next()\r\n/Users/dragos/Documents/arrow/cpp/src/arrow/record_batch.cc:336  ReadNext(&batch)\r\n/Users/dragos/Documents/arrow/cpp/src/arrow/record_batch.cc:347  ReadAll(&batches)\r\n\u2139 If you have supplied a schema and your data contains a header row, you should supply the argument `skip = 1` to prevent the header being read in as data.\r\nRun `rlang::last_error()` to see where the error occurred.\r\n```\r\nThat penultimate row should be the informative one. Albeit it should say `skip_rows` instead of `{}skip{`}, but we are looking at that as part of ARROW-15743.\r\n\r\nI have tried the above in combinations with `{}filter(){`}, `{}select(){`}, and `mutate()` and all seem to successfully surface the same `i` component of the error message.\r\n\r\nAre you getting a similar error message?"
        }
    ]
}