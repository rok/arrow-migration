{
    "issue": {
        "title": "[Plasma][Java] Java client for Plasma",
        "body": "***Note**: This issue was originally created as [ARROW-1163](https://issues.apache.org/jira/browse/ARROW-1163). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nWe should start thinking about how a Java client for plasma would look like. Given the focus of arrow to support Python, C++ and Java really well, it is the next important target after Python and C++.\n\nMy preliminary thoughts on it are the following ones: We can either go with JNI and wrap the C++ client or (in my opinion preferable) write a pure Java client. It would communicate with the Plasma store via Java flatbuffers over sockets.\n\nIt seems that the only thing blocking a pure Java client at the moment is the way we ship file descriptors for the memory mapped files between store and client (see the file fling.cc in the Plasma repo). We would need to get rid of that because there is no pure Java API that allows transferring file descriptors over a process boundary. So the way to transfer memory mapped files over process boundaries then is probably to use the file system and keep the memory mapped files in the file system instead of unlinking them immediately (as we do at the moment), so they can be opened by the client process via their path.\n\nThe challenge in this case is how to clean the files up and make sure they are not lying around if the plasma store crashes. One option is to store the plasma store PID with the file (i.e. as part of the file name) and let the plasma store clean them up the next time it is started); maybe there is OS level support for temporary files we can reuse.\n\nI probably won't get to this for a while, so if anybody needs this or has free cycles, they should feel free to chime in. Also opinions on the design are appreciated!\n\n\u2013 Philipp.",
        "created_at": "2017-06-29T06:20:12.000Z",
        "updated_at": "2018-08-08T14:22:08.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++ - Plasma",
            "Component: Java",
            "Type: enhancement"
        ],
        "closed": true,
        "closed_at": "2018-05-25T06:57:42.000Z"
    },
    "comments": [
        {
            "created_at": "2017-06-29T14:34:05.567Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-1163?focusedCommentId=16068415) by Wes McKinney (wesm):*\nAlong with the 0.5.0 release, we should have a blog post that explains how the object store works and call for contributions, which might help with recruiting some Java developers to get involved"
        },
        {
            "created_at": "2017-11-07T15:30:40.599Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-1163?focusedCommentId=16242190) by Lu Qi  (luchy0120):*\nHi,Philipp Moritz,\r\nI've been working on reading and writing Tensor in Java for several weeks. I've got Tensor structure like this:\r\nClass Tensor{ private float[] storage; private int[] shape }\r\nI used JNI to leverage plasma C++ client . One good thing is when writing tensor ,there is \r\n\"getPrimitiveArrayCritical\" method which gets the address in Java heap (based on vm impletation),\r\nthus I can construct Tensor in C++ easily without copying, although it stops GC in this process, but \r\nplasma writing is non blocking. On the other side of the world, when reading tensor , I need to copy \r\nthe share memory into java heap, this will cost time.  So, in order to save reading time , pure Java \r\nclient may be a good choice. \r\n\r\nAs to pure Java client , may be we can use jni to get fd first and construct a FileDescriptor .\r\nhttps://stackoverflow.com/questions/4845122/using-a-numbered-file-descriptor-from-java \r\n"
        },
        {
            "created_at": "2017-11-07T16:20:21.215Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-1163?focusedCommentId=16242298) by Philipp Moritz (pcmoritz):*\nHey Lu Qi,\r\n\r\nI have very limited experience with Java, here are some thoughts that are I hope are helpful:\r\n\r\nYou can do zero copy reads in Java using an off-heap method like http://xcorpion.tech/2016/09/10/It-s-all-about-buffers-zero-copy-mmap-and-Java-NIO/. Given the data already lives in (in-memory) memory-mapped files, this might be the best way to go forward here.\r\n\r\nWe would essentially define our own Tensor class and then use code like https://github.com/apache/spark/tree/50ada2a4d31609b6c828158cad8e128c2f605b8d/common/unsafe/src/main/java/org/apache/spark/unsafe (see for example https://github.com/apache/spark/blob/50ada2a4d31609b6c828158cad8e128c2f605b8d/common/unsafe/src/main/java/org/apache/spark/unsafe/array/LongArray.java) to access the data without copies.\r\n\r\nArrow already has a Tensor class in C++ that does similar things and the the current Python serialization code uses that to read Tensors in a zero copy way from the object store and expose them as numpy arrays to the user. On the Java side I think not much is available yet for reading tensors; as a point to get started, the code for parsing Tensor metadata is generated here: https://github.com/apache/arrow/blob/82eea49b3eea6047f53478113ab3ff9a38f0d344/java/format/pom.xml#L108\r\n\r\nIf you look at the code for reading C++ Tensors, you should be able to get a prototype of this working. I'm also cc'ing some of the people who have done most work on the Java implementation for more input.\r\n\r\n`[~bryanc]`  `[~siddteotia]` `[~jnadeau]`\r\n\r\n\u2013 Philipp."
        },
        {
            "created_at": "2017-11-08T05:09:40.322Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-1163?focusedCommentId=16243388) by Lu Qi  (luchy0120):*\nHi, Philipp,\r\nThanks for providing me these material. I see that numpy uses \"PyArray_NewFromDescr\" to wrap a\r\nmemory without copying data. So, on Java side, we will mimic this method and provide a wrapper \r\nclass for viewing or modify the underlying \"mmap\" share memory. But , for now , as in my case,  \r\nI have an already defined Tensor using float array . I have to copy data into it , which is pretty sad.\r\nMaybe one day I can drop my Tensor"
        },
        {
            "created_at": "2017-11-08T05:55:09.874Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-1163?focusedCommentId=16243420) by Philipp Moritz (pcmoritz):*\nThat makes sense for now and I agree it's a little sad; for the future maybe you can get some insights from https://github.com/deeplearning4j/deeplearning4j on how to write the Tensor class in the \"right\" way; unfortunately Java doesn't really have a long tradition of scientific computing like Python has so there is no good standard Tensor classes like numpy.\r\n\r\nEdit: This is also an opportunity for Arrow, if we had a good Java tensor class it could be widely used because of the increasing importance of deep learning. Another project to look at is https://github.com/intel-analytics/BigDL. We also wrote our own in the past: https://github.com/amplab/SparkNet/blob/master/src/main/scala/libs/NDArray.scala and https://github.com/amplab/SparkNet/blob/master/src/main/java/libs/JavaNDArray.java to interop with Caffe and TensorFlow, but it might not be too useful for shared memory."
        },
        {
            "created_at": "2017-11-09T12:30:56.327Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-1163?focusedCommentId=16245562) by Lu Qi  (luchy0120):*\nI work for BigDL and we are looking for solutions to moving data from python to JAVA"
        },
        {
            "created_at": "2018-05-25T06:57:42.284Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-1163?focusedCommentId=16490324) by Philipp Moritz (pcmoritz):*\nIssue resolved by pull request 2065\n<https://github.com/apache/arrow/pull/2065>"
        },
        {
            "created_at": "2018-08-08T14:22:08.340Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-1163?focusedCommentId=16573282) by Adam Gibson (agibsonccc):*\nHey folks - adam from deeplearning4j here. nd4j is likely the closest thing to a \"numpy\" on the jvm you are going to get.\r\n\r\nThis is on top of being able to directly read numpy and tensorflow arrays directly in memory with zero copy, this is on top of being able to work with\r\n\r\nmkl/cuda while also having a fairly friendly managed buffers story: <https://deeplearning4j.org/workspaces>\r\n\r\nApache tika and apache solr have not been afraid to work with us. I'd encourage folks to reach out to us in the future rather than just skimming and making some assumptions.\r\n\r\nWe'd be more than glad to engage the arrow community. We already have our own support for reading/writing apache arrow tensors:\r\n\r\n<https://github.com/deeplearning4j/deeplearning4j/tree/master/nd4j/nd4j-serde/nd4j-arrow>\r\n\r\nApache mahout also uses our underlying JNI stack javacpp: <https://github.com/apache/mahout/blob/master/viennacl-omp/pom.xml>\r\n\r\nWe've also based our ETL software for pre processing data based on arrow as well:\u00a0\r\n\r\nhttps://github.com/deeplearning4j/deeplearning4j/tree/master/datavec/datavec-local/src/main/java/org/datavec/local/transforms\r\n\r\nWe've done quite a few tricks with the javacpp tensorflow bindings as well to coax tensorflow graphs in to the nd4j environment for graph execution:\r\n\r\n<https://github.com/deeplearning4j/deeplearning4j/tree/master/nd4j/nd4j-tensorflow/src/main/java/org/nd4j/tensorflow/conversion>\r\n\r\nThere is some neat work we could do together here if folks are interested.\u00a0 There doesn't seem to be too much interest in making the java\r\n\r\nbindings work well with tensors (mainly because of the focus on python) but if there's anyone interested in making it work well, we'd be more than glad to support folks with such efforts."
        }
    ]
}