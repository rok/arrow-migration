{
    "issue": {
        "title": "C++20 compile arrow get `operator==` ambiguous",
        "body": "***Note**: This issue was originally created as [ARROW-17408](https://issues.apache.org/jira/browse/ARROW-17408). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nWhen compiling arrow-9.0.0 in C++20, I got:\r\n\r\n\u00a0\r\n\r\n```\r\n\r\nIn file included from ../arrow/cpp/src/arrow/ipc/dictionary.cc:32:\r\n../arrow/cpp/src/arrow/record_batch.h:266:21: warning: ISO C++20 considers use of overloaded operator '==' (with operand types 'const Result<std::shared_ptr<RecordBatch>>' and 'const Result<std::shared_ptr<RecordBatch>>') to be ambiguous despite there being a unique best viable function [-Wambiguous-reversed-operator]\r\n\u00a0 \u00a0 \u00a0 return batch_ == other.batch_;\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0~~~~~~ ^ \u00a0~~~~~~~~~~~~\r\n../arrow/cpp/src/arrow/util/compare.h:54:8: note: ambiguity is between a regular call to this operator and a call with the argument order reversed\r\n\u00a0 bool operator==(const T& other) const \\{ return cast().Equals(other); }\r\n\u00a0 \u00a0 \u00a0 \u00a0^\r\nIn file included from ../arrow/cpp/src/arrow/ipc/dictionary.cc:18:\r\nIn file included from ../arrow/cpp/src/arrow/ipc/dictionary.h:27:\r\n../arrow/cpp/src/arrow/result.h:278:20: warning: ISO C++20 considers use of overloaded operator '==' (with operand types 'const arrow::Status' and 'const arrow::Status') to be ambiguous despite there being a unique best viable function [-Wambiguous-reversed-operator]\r\n\u00a0 \u00a0 return status_ == other.status_;\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0~~~~~~~ ^ \u00a0~~~~~~~~~~~~~\r\n../arrow/cpp/src/arrow/util/compare.h:54:57: note: in instantiation of member function 'arrow::Result<std::shared_ptr<arrow::RecordBatch>>::Equals' requested here\r\n\u00a0 bool operator==(const T& other) const \\{ return cast().Equals(other); }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ^\r\n../arrow/cpp/src/arrow/record_batch.h:266:21: note: in instantiation of member function 'arrow::util::EqualityComparable<arrow::Result<std::shared_ptr<arrow::RecordBatch>>>::operator==' requested here\r\n\u00a0 \u00a0 \u00a0 return batch_ == other.batch_;\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ^\r\n../arrow/cpp/src/arrow/util/compare.h:54:8: note: ambiguity is between a regular call to this operator and a call with the argument order reversed\r\n\u00a0 bool operator==(const T& other) const \\{ return cast().Equals(other); }\r\n\u00a0 \u00a0 \u00a0 \u00a0^\r\n2 warnings generated.\r\nIn file included from ../arrow/cpp/src/arrow/ipc/message.cc:33:\r\nIn file included from ../arrow/cpp/src/arrow/ipc/reader.h:32:\r\n../arrow/cpp/src/arrow/record_batch.h:266:21: warning: ISO C++20 considers use of overloaded operator '==' (with operand types 'const Result<std::shared_ptr<RecordBatch>>' and 'const Result<std::shared_ptr<RecordBatch>>') to be ambiguous despite there being a unique best viable function [-Wambiguous-reversed-operator]\r\n\u00a0 \u00a0 \u00a0 return batch_ == other.batch_;\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0~~~~~~ ^ \u00a0~~~~~~~~~~~~\r\n../arrow/cpp/src/arrow/util/compare.h:54:8: note: ambiguity is between a regular call to this operator and a call with the argument order reversed\r\n\u00a0 bool operator==(const T& other) const \\{ return cast().Equals(other); }\r\n\u00a0 \u00a0 \u00a0 \u00a0^\r\nIn file included from ../arrow/cpp/src/arrow/ipc/message.cc:18:\r\nIn file included from ../arrow/cpp/src/arrow/ipc/message.h:30:\r\n../arrow/cpp/src/arrow/result.h:278:20: warning: ISO C++20 considers use of overloaded operator '==' (with operand types 'const arrow::Status' and 'const arrow::Status') to be ambiguous despite there being a unique best viable function [-Wambiguous-reversed-operator]\r\n\u00a0 \u00a0 return status_ == other.status_;\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0~~~~~~~ ^ \u00a0~~~~~~~~~~~~~\r\n../arrow/cpp/src/arrow/util/compare.h:54:57: note: in instantiation of member function 'arrow::Result<std::shared_ptr<arrow::RecordBatch>>::Equals' requested here\r\n\u00a0 bool operator==(const T& other) const \\{ return cast().Equals(other); }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ^\r\n../arrow/cpp/src/arrow/record_batch.h:266:21: note: in instantiation of member function 'arrow::util::EqualityComparable<arrow::Result<std::shared_ptr<arrow::RecordBatch>>>::operator==' requested here\r\n\u00a0 \u00a0 \u00a0 return batch_ == other.batch_;\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ^\r\n../arrow/cpp/src/arrow/util/compare.h:54:8: note: ambiguity is between a regular call to this operator and a call with the argument order reversed\r\n\u00a0 bool operator==(const T& other) const \\{ return cast().Equals(other); }\r\n\r\n```\r\n\r\n\u00a0\r\n\r\nGenerate or hand written `operator==` for `Result` maybe fixing this problem. Seems problems cames from:\u00a0\r\n\r\nhttps://stackoverflow.com/questions/65833022/inherited-synthesized-comparison-operator-produces-warning-error-iso-c20-cons",
        "created_at": "2022-08-15T05:22:03.000Z",
        "updated_at": "2022-11-02T05:55:03.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Type: bug"
        ],
        "closed": false
    },
    "comments": [
        {
            "created_at": "2022-08-16T07:52:57.274Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-17408?focusedCommentId=17580127) by Xuwei Fu (mwish):*\n`[~apitrou]` Hi, mind take a look? My fixing works for C+20, but would not compile in some platforms. Should I add some macros that make it only works in C+20?"
        }
    ]
}