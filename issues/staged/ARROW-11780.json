{
    "issue": {
        "title": "[C++][Python] StructArray.from_arrays() crashes Python interpreter",
        "body": "***Note**: This issue was originally created as [ARROW-11780](https://issues.apache.org/jira/browse/ARROW-11780). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\n`StructArray.from_arrays()` crashes the Python interpreter without error message:\r\n\r\n```none\n\r\n(test_pyarrow) Z:\\test_pyarrow>python\r\nPython 3.8.5 (default, Sep  3 2020, 21:29:08) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> import pyarrow as pa\r\n>>>\r\n>>> table = pa.Table.from_pydict({\r\n...     'foo': pa.array([1, 2, 3]),\r\n...     'bar': pa.array([4, 5, 6])\r\n... })\r\n>>>\r\n>>> pa.StructArray.from_arrays([table['foo'], table['bar']], ['foo', 'bar'])\r\n\r\n(test_pyarrow) Z:\\test_pyarrow>\r\n```",
        "created_at": "2021-02-25T09:16:07.000Z",
        "updated_at": "2021-04-27T09:48:52.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Component: Python",
            "Type: bug"
        ],
        "closed": true,
        "closed_at": "2021-04-27T09:48:48.000Z"
    },
    "comments": [
        {
            "created_at": "2021-02-25T17:21:37.314Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-11780?focusedCommentId=17291063) by Weston Pace (westonpace):*\nRelevant stack trace...\r\n\r\n\r\n```java\n\r\nThread 1 \"python\" received signal SIGSEGV, Segmentation fault.\r\n0x00007ffff5ed7f16 in std::__shared_ptr<arrow::ArrayData, (__gnu_cxx::_Lock_policy)2>::get (this=0x8) at /home/pace/anaconda3/envs/conbench2/x86_64-conda-linux-gnu/include/c++/9.3.0/bits/shared_ptr_base.h:1310\r\n1310\t      { return _M_ptr; }\r\n(gdb) bt\r\n#0  0x00007ffff5ed7f16 in std::__shared_ptr<arrow::ArrayData, (__gnu_cxx::_Lock_policy)2>::get (this=0x8)\r\n    at /home/pace/anaconda3/envs/conbench2/x86_64-conda-linux-gnu/include/c++/9.3.0/bits/shared_ptr_base.h:1310\r\n#1  0x00007ffff5ed4f91 in std::__shared_ptr_access<arrow::ArrayData, (__gnu_cxx::_Lock_policy)2, false, false>::_M_get (this=0x8)\r\n    at /home/pace/anaconda3/envs/conbench2/x86_64-conda-linux-gnu/include/c++/9.3.0/bits/shared_ptr_base.h:1021\r\n#2  0x00007ffff5ed20df in std::__shared_ptr_access<arrow::ArrayData, (__gnu_cxx::_Lock_policy)2, false, false>::operator-> (this=0x8)\r\n    at /home/pace/anaconda3/envs/conbench2/x86_64-conda-linux-gnu/include/c++/9.3.0/bits/shared_ptr_base.h:1015\r\n#3  0x00007ffff5ece259 in arrow::Array::type (this=0x0) at ../src/arrow/array/array_base.h:86\r\n#4  0x00007ffff5f75924 in arrow::StructArray::Make (children=std::vector of length 2, capacity 2 = {...}, field_names=std::vector of length 2, capacity 2 = {...}, \r\n    null_bitmap=std::shared_ptr<arrow::Buffer> (empty) = {...}, null_count=-1, offset=0) at ../src/arrow/array/array_nested.cc:502\r\n#5  0x00007ffff73c7b89 in __pyx_pf_7pyarrow_3lib_11StructArray_4from_arrays(_object*, _object*, _object*) ()\r\n   from /home/pace/anaconda3/envs/conbench2/lib/python3.7/site-packages/pyarrow-4.0.0.dev108+g4b4fb24d3.d20210205-py3.7-linux-x86_64.egg/pyarrow/lib.cpython-37m-x86_64-linux-gnu.so\r\n#6  0x00007ffff73c8ad1 in __pyx_pw_7pyarrow_3lib_11StructArray_5from_arrays(_object*, _object*, _object*) ()\r\n   from /home/pace/anaconda3/envs/conbench2/lib/python3.7/site-packages/pyarrow-4.0.0.dev108+g4b4fb24d3.d20210205-py3.7-linux-x86_64.egg/pyarrow/lib.cpython-37m-x86_64-linux-gnu.so\r\n\r\n```\r\nIt appears `StructArray::Make` is being called with children/field_names each with length 2.\u00a0 The names get passed down but `table['foo']` and `table['bar']` become null pointers.\r\n\r\n\u00a0\r\n\r\n\u00a0"
        },
        {
            "created_at": "2021-04-16T12:33:14.971Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-11780?focusedCommentId=17323776) by Alessandro Molina (amol-):*\nConfirmed I was able to reproduce the issue and saw the same behaviour\r\n\r\n\u00a0\r\n```java\n\r\n\u00a0 * frame #0: 0x000000010534d03c libarrow.400.dylib`std::__1::shared_ptr<arrow::ArrayData>::operator->(this=0x0000000000000008) const at memory:3930:56\r\n\u00a0 \u00a0 frame #1: 0x000000010534fa27 libarrow.400.dylib`arrow::Array::type(this=0x0000000000000000) const at array_base.h:86:51\r\n\u00a0 \u00a0 frame #2: 0x0000000105416bea libarrow.400.dylib`arrow::StructArray::Make(children=size=2, field_names=size=2, null_bitmap=nullptr, null_count=-1, offset=0) at array_nested.cc:501:61\r\n\u00a0 \u00a0 frame #3: 0x000000010510ed09 lib.cpython-39-darwin.so`__pyx_pf_7pyarrow_3lib_11StructArray_4from_arrays(_object*, _object*, _object*) + 6057\r\n```\r\n\u00a0\r\n```java\n\r\n(const std::__1::vector<std::__1::shared_ptr<arrow::Array>, std::__1::allocator<std::__1::shared_ptr<arrow::Array> > >) $0 = size=2 {\r\n\u00a0 [0] = nullptr {\r\n\u00a0 \u00a0 __ptr_ = 0x0000000000000000\r\n\u00a0 }\r\n\u00a0 [1] = nullptr {\r\n\u00a0 \u00a0 __ptr_ = 0x0000000000000000\r\n\u00a0 }\r\n}\r\n```\r\n\u00a0\r\n\r\nThe names of the keys are instead correctly propagated\r\n\r\n\u00a0\r\n```java\n\r\n(const std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > >) $1 = size=2 {\r\n\u00a0 [0] = \"foo\"\r\n\u00a0 [1] = \"bar\"\r\n}\r\n```\r\n\u00a0"
        },
        {
            "created_at": "2021-04-16T13:36:45.319Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-11780?focusedCommentId=17323820) by Alessandro Molina (amol-):*\nThe issue seems to origin from `pyarrow_unwrap_array` not recognising the two values as arrays.\r\n\r\nAn empty shared_ptr is returned when unwrapping something that is not an array, see <https://github.com/apache/arrow/pull/827/files#diff-fd3f36df959d5f57664e7c4ca21a59515d5649679e188e77a220af490ab2b601R126-R132>\u00a0\r\n\r\nThe two arrays are in fact `ChunkedArray`, thus the `pyarrow_unwrap_array` doesn't deal with them.\r\n\r\n```python\n\r\n<class 'pyarrow.lib.ChunkedArray'> [[1, 2, 3]]\r\n```\r\n\r\n I'm not sure on the impact over the rest of the codebase, but it seems it would be more robust to have `pyarrow_unwrap_array` (and similar methods) throwing an exception when they face unsupported types instead of returning NULL values that might trigger an action at a distance that is then hard to debug.\r\n\r\n\u00a0\r\n\r\n\u00a0"
        },
        {
            "created_at": "2021-04-27T09:48:48.893Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-11780?focusedCommentId=17333082) by Joris Van den Bossche (jorisvandenbossche):*\nIssue resolved by pull request 10097\n<https://github.com/apache/arrow/pull/10097>"
        }
    ]
}