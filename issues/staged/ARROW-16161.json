{
    "issue": {
        "title": "[C++] Overhead of std::shared_ptr<DataType> copies is causing thread contention",
        "body": "***Note**: This issue was originally created as [ARROW-16161](https://issues.apache.org/jira/browse/ARROW-16161). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nWe created a benchmark to measure ExecuteScalarExpression performance in ARROW-16014.  We noticed significant thread contention (even though there shouldn't be much, if any, for this task) As part of ARROW-16138 we have been investigating possible causes.\r\n\r\nOne cause seems to be contention from copying shared_ptr<DataType> objects.\r\n\r\nTwo possible solutions jump to mind and I'm sure there are many more.\r\n\r\nExecBatch is an internal type and used inside of ExecuteScalarExpression as well as inside of the execution engine.  In the former we can safely assume the data types will exist for the duration of the call.  In the latter we can safely assume the data types will exist for the duration of the execution plan.  Thus we can probably take a more targetted fix and migrate only ExecBatch to using DataType\\* (or const DataType&).\r\n\r\nOn the other hand, we might consider a more global approach.  All of our \"stock\" data types are assumed to have static storage duration.  However, we must use std::shared_ptr<DataType> because users could create their own extension types.  We could invent an \"extension type registration\" system where extension types must first be registered with the C++ lib before being used.  Then we could have long-lived DataType instances and we could replace std::shared_ptr<DataType> with DataType\\* (or const DataType&) throughout most of the entire code base.\r\n\r\nBut, as I mentioned, I'm sure there are many approaches to take.  CC `[~lidavidm]` and `[~apitrou]` and `[~yibocai]` for thoughts but this might be interesting for just about any C++ dev.",
        "created_at": "2022-04-09T03:25:59.000Z",
        "updated_at": "2022-09-04T16:50:13.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Type: task"
        ],
        "closed": false
    },
    "comments": [
        {
            "created_at": "2022-04-09T09:46:47.410Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16161?focusedCommentId=17519941) by Antoine Pitrou (apitrou):*\n> All of our \"stock\" data types are assumed to have static storage duration.\r\n\r\nNot really, parametric types generally cannot use static instances."
        },
        {
            "created_at": "2022-04-09T09:48:12.068Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16161?focusedCommentId=17519942) by Antoine Pitrou (apitrou):*\nI think the right approach would be to introduce a lighter-weight ExecSpan that would not have ownership of the carried data and types. This assumes the execution machinery keeps ownership to those independently."
        },
        {
            "created_at": "2022-04-09T09:50:10.704Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16161?focusedCommentId=17519943) by Antoine Pitrou (apitrou):*\nNote that ExecBatch holds shared_ptr to DataTypes indirectly through the Datums as well. So doing this is more involved that it seems, IMHO."
        },
        {
            "created_at": "2022-04-09T11:58:01.561Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16161?focusedCommentId=17519969) by David Li (lidavidm):*\nCan we start by making a function to duplicate a DataType (instead of copying the shared_ptr) and see if using that in targeted places helps? Since that shouldn't need to manipulate a shared reference count, and will be a much less involved refactor. Otherwise I agree with Antoine, the extensive use of Datum will also complicate things. We have been talking about redesigning all this for a while, so it might be a worthwhile, if very involved, project for 9.0.0."
        },
        {
            "created_at": "2022-04-12T22:46:03.963Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16161?focusedCommentId=17521369) by Weston Pace (westonpace):*\n> Not really, parametric types generally cannot use static instances.\r\n\r\nYes, this renders my registry suggestion pretty much invalid.  I like the idea of duplicating DataType to start with but I don't know if that gets us closer to an eventual solution.  For ExecBatch for example we might be able to state that ExecBatch cannot outlive the producing ExecPlan and do references/pointers.\r\n\r\nDatum does complicate things.  Datums can be created independently of an ExecPlan and are a pretty established part of the public API.\r\n\r\nI spoke with `[~zagto]` and he is going to try prototyping something to see what kind of effect it has on this benchmark."
        },
        {
            "created_at": "2022-04-12T23:23:06.450Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16161?focusedCommentId=17521378) by Tobias Zagorni (zagto):*\nOne of the bottlenecks can already be improved by making `Expression::type()` return a reference instead of copying the `{}shared_ptr{`}.\r\n\r\nBefore:\r\n\r\n------------------------------------------------------------------------------------------------------------------------------------------ \r\nBenchmark \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Time \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CPU \u00a0\u00a0Iterations UserCounters... \r\n------------------------------------------------------------------------------------------------------------------------------------------ \r\nExecuteScalarExpressionOverhead/simple_expression/rows_per_batch:100/threads:1 \u00a0\u00a0\u00a084196667 ns \u00a0\u00a0\u00a0\u00a084133137 ns \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a08 rows_per_second=118.859M/s \r\nExecuteScalarExpressionOverhead/simple_expression/rows_per_batch:100/threads:16 \u00a0\u00a037440825 ns \u00a0\u00a0\u00a0596181958 ns \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a016 rows_per_second=16.7734M/s\r\n\r\n\r\nAfter:\r\n\r\n------------------------------------------------------------------------------------------------------------------------------------------ \r\nBenchmark \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Time \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CPU \u00a0\u00a0Iterations UserCounters... \r\n------------------------------------------------------------------------------------------------------------------------------------------ \r\nExecuteScalarExpressionOverhead/simple_expression/rows_per_batch:100/threads:1 \u00a0\u00a0\u00a075623644 ns \u00a0\u00a0\u00a0\u00a075585333 ns \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a09 rows_per_second=132.301M/s \r\nExecuteScalarExpressionOverhead/simple_expression/rows_per_batch:100/threads:16 \u00a0\u00a023834056 ns \u00a0\u00a0\u00a0380139943 ns \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a016 rows_per_second=26.3061M/s\r\n\r\n\r\n\r\n\u00a0\r\n\r\nThe rest seem to be involved with Datum, I'll try what `[~lidavidm]` suggested tomorrow"
        },
        {
            "created_at": "2022-04-14T13:59:10.588Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16161?focusedCommentId=17522325) by Tobias Zagorni (zagto):*\nI managed to make all data types required to compile the benchmark copyable (shallow for now), and it looks this can indeed speed things up. The best configuration of when to copy the DataType so far is on constructing any ArrayData\r\n\r\nWith this I already get between 35-40 M/s\r\n\r\nI'm sure this is still is not optimal since I still see atomic operations in shared_ptr<DataType> take significant amounts of time, but less than before.\u00a0\r\n\r\nI'll try if I can replace all shared_ptr<DataType> uses with an own class for some more extreme experiments, like copying every single time, or neither copy nor reference count and just leak instances for comparision.\r\n\r\nThat said I still expect the solution to be to rebuild ExecBatch in a way it doesn't constantly reference count (or copy) in Datum/ValueDescr."
        },
        {
            "created_at": "2022-04-14T14:06:00.576Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16161?focusedCommentId=17522329) by David Li (lidavidm):*\nI agree the ideal is to refactor ExecBatch. I suggested copying as just a way to test the impact without having to refactor to start with."
        },
        {
            "created_at": "2022-04-27T23:10:21.924Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16161?focusedCommentId=17529119) by Tobias Zagorni (zagto):*\nI created a hacky prototype of an ExecArrayData class that does not hold a shared_ptr to DataType. It is used in Datum as an alternative to ArrayData. I can currently run all the ExecuteScalarExpressionOverhead benchmarks with it.\r\n\r\nThere are noticeable performance improvements in multi-threaded runs with small (e.g. 1000) batch sizes. The best is in zero_copy_expression:\r\n\r\n`old: ExecuteScalarExpressionOverhead/zero_copy_expression/rows_per_batch:1000/threads:16 \u00a0 \u00a0 \u00a0 \u00a01613271 ns \u00a0 \u00a0 25730049 ns \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 32 rows_per_second=388.651M/s`\r\n`new: ExecuteScalarExpressionOverhead/zero_copy_expression/rows_per_batch:1000/threads:16 \u00a0 \u00a0 \u00a0 \u00a01121647 ns \u00a0 \u00a0 17913402 ns \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 32 rows_per_second=558.241M/s`\r\n\r\n(full results are attached: [ExecArrayData-difference.txt](ExecArrayData-difference.txt))\r\n\r\nIn other places I see a small performance reduction, and also the simple_expression/100 improvement is smaller than with the first copyable DataType experiment. Probably due to the additional code paths in this implementation and my way of getting a shared_ptr<DataType> back from ExecArrayData, cloning the DataType object, which is far from optimal. I'm still looking into this.\r\n\r\nmost of the remaining reference counting overhead seems to come from 3 places:\r\n \\* ValueDescr / resolving output types using it\r\n \\* Scalar datums\r\n \\* pointers to the CPUDevice instance, because CPUMemeoryManager instances are recreated a lot. I'll create a diffrent subtask for this\r\n\r\n[Code](https://github.com/zagto/arrow/compare/datatype-performance-execarraydata-baseline...zagto:datatype-performance?expand=1) - (ignore the weird mix of template and subclassing for ExecArrayData)"
        },
        {
            "created_at": "2022-05-04T19:04:54.352Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16161?focusedCommentId=17531899) by Tobias Zagorni (zagto):*\nIn the last few days I experimented with this a bit more and came up with some additional smaller modifications to reduce thread contention:\r\n1. make `CPUMemoryManager` objects exist once in the respective pool, and use raw pointers to reference them, instead of re-creating `CPUMemoryManager` instances all the time and reference them by `{}shared_ptr{`}. This should be valid in all cases for CPUMemoryManager, since a `CPUMemoryManager` has a raw pointer to it's pool, and using this shared_ptr'd `CPUMemoryManager` beyond the pool's lifetime wouldn't make much sense anyways. Still need to check if this all works on the CUDA side.\n1. make `CPUDevice::Instance() `return a reference to it's `shared_ptr` instead of copying it (shouldn't matter much once we have the above)\n1. make `ExecBatchIterator::Next()` not use `Slice()` on small batches that would only result in one slice. Instead move the input\n   \n   The performance improvement of each of these should only be a few percent (at least in the 1000/10000 items batch sizes we use in master). I had trouble benchmarking them individually on top of the master branch, where there is a lot of contention anyways. On my work laptop general variance is just too high, probably due to things like thermal throteling and power budgets. By applying all three of these on top of the `{}ExecBatchIterator{`}, I currently get 40-50 M/s compared to ~27 on `simple_expression/rows_per_batch:100/threads:16` for example.\n   \n   I think these 3 could be good canidates to create a PR soon once can confirm that they are beneficial on a more reliable benchmarking setup.\n   \n   I noticed a reason why the `ExecArrayData` modification alone did not lead to an as big performance improvement. I did still use a regular array as input and started using `ExecArrayData` from the first operator onwards. It turns out the `ArrayData` is already copied twice in the setup before the execution (or once, if we stop slicing the input using the third modification)\n   \n   Additionally, at this stage, ValueDescrs are created from the `ArrayData` type. Using `ExecArrayData` here would likely go hand-in-hand with also modifying `ValueDescr` to not contain a `{}shared_ptr{`}.\n   \n   Modifying `ValueDescr` to not contain a `shared_ptr` is probably desireable on its own. `ValueDescr` seems to be responsible for about half the `shared_ptr<DataType>` copies, mostly in `GetDescriptors()` and `OutputType::Resolve().`\n   I played with it a bit today, but couldn't get it to work yet, since, there are a lot of places that use `ValueDescr::type` directly, of which some need to be modified."
        },
        {
            "created_at": "2022-05-18T15:59:09.994Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16161?focusedCommentId=17538927) by Tobias Zagorni (zagto):*\nI created a PR for avoiding calls to Slice() as ARROW-16562"
        },
        {
            "created_at": "2022-09-04T16:50:12.953Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16161?focusedCommentId=17600083) by @toddfarmer:*\nThis issue was last updated over 90 days ago, which may be an indication it is no longer being actively worked. To better reflect the current state, the issue is being unassigned per [project policy](https://arrow.apache.org/docs/dev/developers/bug_reports.html#issue-assignment). Please feel free to re-take assignment of the issue if it is being actively worked, or if you plan to start that work soon."
        }
    ]
}