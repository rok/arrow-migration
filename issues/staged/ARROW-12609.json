{
    "issue": {
        "title": "[Python] TypeError when accessing length of an invalid ListScalar",
        "body": "***Note**: This issue was originally created as [ARROW-12609](https://issues.apache.org/jira/browse/ARROW-12609). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nFor List-like data types, the scalar corresponding to a missing value has '___len___' attribute, but TypeError is raised when it is accessed\r\n```java\n\r\nimport pyarrow as pa\r\n\r\ndata_type = pa.list_(pa.struct([\r\n    ('a', pa.int64()),\r\n    ('b', pa.bool_())\r\n]))\r\ndata = [[{'a': 1, 'b': False}, {'a': 2, 'b': True}], None]\r\narr = pa.array(data, type=data_type)\r\nmissing_scalar = arr[1]  # <pyarrow.ListScalar: None>\r\nassert hasattr(missing_scalar, '__len__')\r\nassert len(missing_scalar) == 0\u00a0 # -->\u00a0TypeError: object of type 'NoneType' has no len()\r\n```\r\nExpected behavior: length is expected to be 0.\r\n\r\nThis issue causes several pandas unit tests to fail when an ExtensionArray backed by arrow array with this data type is built.\r\n\r\nThis behavior is also inconsistent with a similar example where the data type is a struct:\r\n```java\n\r\nimport pyarrow as pa\r\n\r\ndata_type = pa.struct([\r\n    ('a', pa.int64()),\r\n    ('b', pa.bool_())\r\n])\r\ndata = [{'a': 1, 'b': False}, None]\r\narr = pa.array(data, type=data_type)\r\nmissing_scalar = arr[1]  # <pyarrow.StructScalar: None>\r\nassert hasattr(missing_scalar, '__len__')\r\nassert len(missing_scalar) == 0  # Ok\r\n```\r\n\u00a0In this second example the TypeError is not raised.",
        "created_at": "2021-04-30T12:29:42.000Z",
        "updated_at": "2021-05-19T00:49:56.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: Python",
            "Type: bug"
        ],
        "closed": false
    },
    "comments": [
        {
            "created_at": "2021-04-30T15:20:54.796Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-12609?focusedCommentId=17337452) by Sergey Mozharov (mosalx):*\nIteration of invalid list scalars is also broken. In the first example from the description:\r\n```java\n\r\nassert hasattr(missing_scalar, '__iter__')\r\nassert len(list(missing_scalar)) == 0  # -> TypeError: 'NoneType' object is not iterable\r\n```\r\nI assume that an invalid ListScalar should be iterable and should produce an empty iterable object. But I am not sure if this is the right way to think about it and if it is specified anywhere.\r\n\r\nAnother example: should __getitem__ with an invalid ListScalar raise an IndexError instead of TypeError?\r\n```java\n\r\nmissing_scalar[0]  # -> TypeError: 'NoneType' object is not subscriptable\n```"
        },
        {
            "created_at": "2021-05-03T14:01:39.166Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-12609?focusedCommentId=17338383) by Alessandro Molina (amol-):*\nThis looks like an interesting question in term of possible behaviours.\r\n\r\nI mean, the moment we declare an `Array` as containing lists (thus `Array[x]` is `ListScalar`) what's the proper behaviour when `Array[x]` in reality is not a list?\r\n\r\nNormally when the value doesn't respect the schema it seems we throw an error\r\n```java\n\r\n>>> pa.array([[1], 1], type=pa.list_(pa.int32()))\r\n...\r\npyarrow.lib.ArrowTypeError: Could not convert 1 with type int: was not a sequence or recognized null for conversion to list type\r\n```\r\nfor `None` that is not true by the way as it's necessary to nulls\r\n```java\n\r\n>>> pa.array([[1], None], type=pa.list_(pa.int32()))\r\n<pyarrow.lib.ListArray object at 0x120e69e20>\r\n[\r\n  [\r\n    1\r\n  ],\r\n  null\r\n]\r\n```\r\nThe question at that point is what should `Array[x]` return? Does it make sense to return a `ListScalar` when in reality it's not a list?\r\n```java\n\r\n>>> pa.array([[1], None], type=pa.list_(pa.int32()))[1]\r\n<pyarrow.ListScalar: None>\r\n```\r\nwhy not return `NullScalar` in such case? It seems to me that `pa.list_(pa.int32())` means a schema that supports null values in the list, then the array should just return a null value when it hits one."
        },
        {
            "created_at": "2021-05-03T14:54:38.732Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-12609?focusedCommentId=17338409) by Sergey Mozharov (mosalx):*\nTo me it makes sense to wrap null into a ListScalar in this case. One benefit of doing it is that it makes the interface simpler: the array type defines the type of its scalar that is returned during iteration, and there is a single type instead of a union of valid type and invalid type. This is consistent with the behavior of primitive arrays, which have one scalar type instead of Union[Int32Scalar, NullScalar].\r\n\r\nI would expect the behavior of ListScalar<null> to be identical to the behavior of ListScalar<[]> (wrapping an empty list) with the only difference that the first scalar is invalid (scalar.is_valid -> False) while the second one is valid.\u00a0I understand that there may be many other nuances I am not aware of. I am very curious to know what other alternatives can be suggested."
        },
        {
            "created_at": "2021-05-03T15:13:51.010Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-12609?focusedCommentId=17338414) by Sergey Mozharov (mosalx):*\nAnother question to think about is what does the \"length\" of a ListScalar mean? If it can defined is as \"how many wrapped objects can I get from this list scalar?\", then the validity of the wrapped object is irrelevant. Both an empty list and null have no wrapped objects in them so the length of both scalars would be 0."
        },
        {
            "created_at": "2021-05-17T10:29:43.296Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-12609?focusedCommentId=17346055) by Joris Van den Bossche (jorisvandenbossche):*\n> why not return `NullScalar` in such case? It seems to me that `pa.list_(pa.int32())` means a schema that supports null values in the list, then the array should just return a null value when it hits one.\r\n\r\n`[~amol-]` The returned ListScalar _is_ a null value, though. Because each type supports null values, each scalar type also supports it's own null scalars. A `NullScalar` is what you would get when accessing a single element of a `NullArray`:\r\n\r\n```Java\n\r\n>>> arr = pa.array([None, None])\r\n>>> arr\r\n<pyarrow.lib.NullArray object at 0x7fee45555940>\r\n2 nulls\r\n>>> arr[0]\r\n<pyarrow.NullScalar: None>\r\n```\r\n\r\n> Expected behavior: length is expected to be 0.\r\n\r\n`[~mosalx]` I think you could also argue that a missing list scalar has \"no defined length\" (why would it be zero? it's an empty list that has zero length) \r\nThe problem, though, is that Python doesn't support this kind of missing or undefined values for integers (`\\_\\_len\\_\\_` needs to return an integer, or error)\r\n\r\nFor example, if not using Python's builtin `len`, but using the pyarrow compute kernel to get the length of list element, we actually \"propagate\" the null, and the null list has a null length:\r\n\r\n```Java\n\r\n>>> import pyarrow.compute as pc\r\n>>> pc.list_value_length(pa.scalar([1, 2], type=pa.list_(pa.int32())))\r\n<pyarrow.Int32Scalar: 2>\r\n>>> pc.list_value_length(pa.scalar(None, type=pa.list_(pa.int32())))\r\n<pyarrow.Int32Scalar: None>\r\n```"
        },
        {
            "created_at": "2021-05-19T00:49:56.234Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-12609?focusedCommentId=17347226) by Sergey Mozharov (mosalx):*\n`[~jorisvandenbossche]` My original thinking (which I am questioning now) was based on the following thoughts/assumptions:\r\n \\* All properties of `ListScalar`s and the concept of \"validity\" (null or not null) are independent. That is, the `ListScalar`\u00a0API could guarantee that all instances will have length, will be iterable, etc - with some not perfect but reasonable behavior assigned to null scalars\r\n \\* the benefit of this approach is that users can write simpler code with pyarrow by not having to worry about handling exceptions when a Null\u00a0`ListScalar`\u00a0is encountered, when the presence/absence of null scalars is not important for what the user is trying to achieve\r\n \\* in cases when validity of scalars is important, `is_valid`\u00a0property could be used to tell apart an empty `ListScalar`\u00a0from a Null\u00a0`ListScalar`\r\n\r\n<q>you could also argue that a missing list scalar has \"no defined length\"</q>\r\n\r\nAgreed. This argument makes perfect sense if we think about Null scalars as undefined values (it can be anything, we just don't know). In this case a dedicated error may be needed to communicate this. I think `AttributeError`\u00a0would be confusing here because `hasattr(null_scalar, '__len__')`\u00a0returns True. `TypeError`\u00a0definitely does not seem right.\r\n\r\nI think pyarrow API consistency is probably the most important criterion. Assigning length 0 to a Null `ListScalar`\u00a0would make API inconsistent with the behavior of pyarrow compute kernel. Raising the right kind of error seems like a reasonable solution because the root cause is that Python does not support undefined values.\r\n\r\nIf the arrow developers prefer this direction, then I hope the issue can be resolved in pandas. My use case is integration of list-like and struct-like arrow arrays with pandas Extension Arrays API. I believe this is a very powerful integration that deserves some attention. At the pandas side the problem seems to be that pandas attempts to analyze internal structure of scalars, and the non-standard behavior of arrow Null scalars breaks some important assumptions. I created a [pandas issue 41377](https://github.com/pandas-dev/pandas/issues/41377) related to this with a concrete example."
        }
    ]
}