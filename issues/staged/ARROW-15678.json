{
    "issue": {
        "title": "[C++][CI] a crossbow job with MinRelSize enabled",
        "body": "***Note**: This issue was originally created as [ARROW-15678](https://issues.apache.org/jira/browse/ARROW-15678). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\n",
        "created_at": "2022-02-14T17:46:30.000Z",
        "updated_at": "2022-10-11T20:52:00.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Component: Continuous Integration",
            "Type: enhancement"
        ],
        "closed": true,
        "closed_at": "2022-10-10T21:18:56.000Z"
    },
    "comments": [
        {
            "created_at": "2022-03-02T17:44:33.093Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17500305) by Jonathan Keane (jonkeane):*\nThe pull request linked has the starts of this \u2014 but there's still an unidentified segfault in one of the tests "
        },
        {
            "created_at": "2022-04-17T08:39:05.922Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17523302) by Weston Pace (westonpace):*\nOk, so I was finally able to track this down.  Fortunately (unfortunately?) it is not really a compiler bug (or maybe it is, I'm not sure).  At the very least, I think we can avoid it.\r\n\r\n`level_comparison.cc` is compiled with `-msse4.2`.\r\n\r\n`level_comparison_avx2.cc` is compiled with `-mavx2`\r\n\r\nThis is expected and the functions they generate are housed in separate namespaces so they don't get confused.  However, both functions rely on the function arrow::internal::FirstTimeBitmapWriter::AppendWord.  The function is not templated but it is defined in the header file (and is not marked inline).  I'm not really sure how we aren't getting a duplicate symbol error but some reading suggests it is implicitly inlined at link time.\r\n\r\nIn the object file (libparquet.a), there are two identical symbols named `__ZN5arrow8internal21FirstTimeBitmapWriter10AppendWordEyx`.  One of them has `SHLX` and one of them has `SHL`.  This disassembly of the `SHLX` version matches exactly the disassembly in the stack trace that `[~jonkeane]` posted in the PR.  The two calling functions are (`parquet::internal::standard::DefLevelsBatchToBitmap` and `parquet::internal::bmi2::DefLevelsBatchToBitmap`.\r\n\r\nSo I think, the -O3 version is inlining the functions.  The -Os version is not (-Os seems to discourage inlining in general).  The linker is then faced with two identical symbols and just picks one (again, trying to optimize for size).  It just so happens the version it picked was the one with `SHLX`.\r\n\r\nSo, as a test, we can try splitting the implementation part of `bitmap_writer.h` into `bitmap_writer.cc` (at least for `FirstTimeBitmapWriter`).  The .cc file should then only be compiled once (with sse4.2).  However, it's very possible we are just hitting the tip of the iceberg here, as any header file linked in by these avx2 compiled versions could be a ticking time bomb."
        },
        {
            "created_at": "2022-04-19T12:37:39.958Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17524280) by David Li (lidavidm):*\nGood catch. This is exactly the same problem we ran into before with kernels: <https://github.com/apache/arrow/blob/6c10a389bbc35b67187930dc0db2a88671e76c2d/cpp/src/arrow/compute/kernels/aggregate_internal.h#L135-L138> (ARROW-13382). I wonder if we should reconsider the plan of vectorizing kernels by rebuilding the same source multiple times given this potential pitfall."
        },
        {
            "created_at": "2022-04-19T17:21:14.029Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17524443) by Weston Pace (westonpace):*\nWe can perhaps add a static check that reports symbols outside the appropriate namespace.  We might need some configurable suppression.  For example, `level_conversion_bmi2.cc.o` would report:\r\n\r\n```\n\r\n0000000000000000 W arrow::util::ArrowLogBase& arrow::util::ArrowLogBase::operator<< <char [51]>(char const (&) [51])\r\n0000000000000000 W std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > arrow::util::StringBuilder<char const (&) [33]>(char const (&) [33])\r\n0000000000000000 W void arrow::util::StringBuilderRecursive<char const (&) [33]>(std::ostream&, char const (&) [33])\r\n0000000000000000 W arrow::util::detail::StringStreamWrapper::stream()\r\n0000000000000000 W arrow::util::Voidify::operator&(arrow::util::ArrowLogBase&)\r\n0000000000000000 W arrow::util::Voidify::Voidify()\r\n0000000000000000 W arrow::bit_util::BytesForBits(long)\r\n0000000000000000 W arrow::internal::FirstTimeBitmapWriter::AppendWord(unsigned long, long)\r\n0000000000000000 W arrow::internal::FirstTimeBitmapWriter::Finish()\r\n0000000000000000 W arrow::internal::FirstTimeBitmapWriter::FirstTimeBitmapWriter(unsigned char*, long, long)\r\n0000000000000000 W parquet::ParquetException::ParquetException<char const (&) [33]>(char const (&) [33])\r\n0000000000000000 W parquet::ParquetException::~ParquetException()\r\n0000000000000000 W parquet::ParquetException::~ParquetException()\r\n0000000000000000 W arrow::internal::FirstTimeBitmapWriter::position() const\r\n0000000000000000 W parquet::ParquetException::what() const\r\n0000000000000000 W std::exception::exception()\r\n0000000000000000 W char const (&std::forward<char const (&) [33]>(std::remove_reference<char const (&) [33]>::type&)) [33]\r\n```\r\n\r\n`level_comparison_avx.cc.o` looks to be in better shape:\r\n\r\n```\n\r\n0000000000000000 W short const& std::max<short>(short const&, short const&)\r\n0000000000000000 W short const& std::min<short>(short const&, short const&)\r\n```\r\n\r\nBut yes, if we have a better solution for this problem it might be safer."
        },
        {
            "created_at": "2022-04-21T19:07:55.868Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17525995) by Antoine Pitrou (apitrou):*\nWow, thanks for the diagnosis `[~westonpace]`.\r\nSo, it turns out that our method for compiling multiple versions of code is violating the one-definition-rule for any inline function or method used in the caller code."
        },
        {
            "created_at": "2022-04-21T19:08:32.674Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17525996) by Antoine Pitrou (apitrou):*\n`[~bkietz]` You may have some idea about how to fix this cleanly and reliably."
        },
        {
            "created_at": "2022-04-21T19:50:52.172Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17526053) by Antoine Pitrou (apitrou):*\nSo, currently we are doing something such as:\r\n```Java\n\r\nclang -c something_avx2.cc -mavx2 \r\n```\r\n\r\nAn alternative would be not to pass the optimization flag on the command line but enable it selectively inside the source code, e.g.:\r\n```Java\n\r\nclang -c something_avx2.cc -DARROW_SPECIALIZED_SIMD_TARGET=avx2\r\n```\r\n\r\n```c++\n\r\nnamespace parquet {\r\nnamespace internal {\r\nnamespace PARQUET_IMPL_NAMESPACE {\r\n\r\n#ifdef ARROW_SPECIALIZED_SIMD_TARGET\r\n\r\n#define STRINGIFY_EXPANDED(a) ARROW_STRINGIFY(a)\r\n#pragma clang attribute push (__attribute__((target( STRINGIFY_EXPANDED(ARROW_SPECIALIZED_SIMD_TARGET)) )), apply_to=function)\r\n\r\n#endif\r\n\r\n...\r\n\r\n#ifdef ARROW_SPECIALIZED_SIMD_TARGET\r\n#pragma clang attribute pop\r\n#endif\r\n\r\n}  // namespace PARQUET_IMPL_NAMESPACE\r\n}  // namespace internal\r\n}  // namespace parquet\r\n```\r\n\r\nThis way we would avoid enabling the particular instruction set on code inlined from other headers. Of course, perhaps that's not actually desirable..."
        },
        {
            "created_at": "2022-04-21T19:54:11.906Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17526055) by Antoine Pitrou (apitrou):*\nIn any case, this is probably too involved a change for 8.0.0, so the 8.0.0 fix would simply to disable SIMD optimizations for Homebrew?"
        },
        {
            "created_at": "2022-04-21T19:58:06.131Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17526058) by Weston Pace (westonpace):*\nThat seems like an good solution to me.  I had no idea it was possible.\r\n\r\nIf we want the other headers to be included then we already have a bit of a solution demonstrated in `level_conversion_inc.h`.  In the common header file you require some kind of `target` namespace to be defined.\r\n\r\n```\n\r\nnamespace parquet {\r\nnamespace internal {\r\n#ifndef PARQUET_IMPL_NAMESPACE\r\n#error \"PARQUET_IMPL_NAMESPACE must be defined\"\r\n#endif\r\nnamespace PARQUET_IMPL_NAMESPACE {\r\n...\r\n}  // namespace PARQUET_IMPL_NAMESPACE\r\n}  // namespace internal\r\n}  // namespace parquet\r\n```\r\n\r\nHowever, anything that includes one of these \"common headers\" must define that namespace...\r\n\r\n```\n\r\n#define PARQUET_IMPL_NAMESPACE standard\r\n#include \"parquet/level_conversion_inc.h\"\r\n#undef PARQUET_IMPL_NAMESPACE\r\n```"
        },
        {
            "created_at": "2022-05-18T22:02:12.281Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17539107) by Jonathan Keane (jonkeane):*\n`[~kou]` Do you think you might be able to take a look at this?\r\n\r\nThe comment at https://github.com/apache/arrow/pull/12928#issuecomment-1105955726 has a good explanation of what's going on and following that there are a few possible fixes (though none of them were fully implemented or decided"
        },
        {
            "created_at": "2022-05-19T00:44:10.785Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17539142) by Kouhei Sutou (kou):*\nHow about using template to distinct implementation for each architecture?\r\n\r\n```\n\r\ndiff --git a/cpp/src/arrow/compute/kernels/codegen_internal.h b/cpp/src/arrow/compute/kernels/codegen_internal.h\r\nindex fa50427bc3..a4bd0eb586 100644\r\n--- a/cpp/src/arrow/compute/kernels/codegen_internal.h\r\n+++ b/cpp/src/arrow/compute/kernels/codegen_internal.h\r\n@@ -710,8 +710,8 @@ struct ScalarUnaryNotNullStateful {\r\n                        Datum* out) {\r\n       Status st = Status::OK();\r\n       ArrayData* out_arr = out->mutable_array();\r\n-      FirstTimeBitmapWriter out_writer(out_arr->buffers[1]->mutable_data(),\r\n-                                       out_arr->offset, out_arr->length);\r\n+      FirstTimeBitmapWriter<> out_writer(out_arr->buffers[1]->mutable_data(),\r\n+                                         out_arr->offset, out_arr->length);\r\n       VisitArrayValuesInline<Arg0Type>(\r\n           arg0,\r\n           [&](Arg0Value v) {\r\ndiff --git a/cpp/src/arrow/compute/kernels/row_encoder.cc b/cpp/src/arrow/compute/kernels/row_encoder.cc\r\nindex 10a1f4cda5..26316ec315 100644\r\n--- a/cpp/src/arrow/compute/kernels/row_encoder.cc\r\n+++ b/cpp/src/arrow/compute/kernels/row_encoder.cc\r\n@@ -42,7 +42,7 @@ Status KeyEncoder::DecodeNulls(MemoryPool* pool, int32_t length, uint8_t** encod\r\n     ARROW_ASSIGN_OR_RAISE(*null_bitmap, AllocateBitmap(length, pool));\r\n     uint8_t* validity = (*null_bitmap)->mutable_data();\r\n \r\n-    FirstTimeBitmapWriter writer(validity, 0, length);\r\n+    FirstTimeBitmapWriter<> writer(validity, 0, length);\r\n     for (int32_t i = 0; i < length; ++i) {\r\n       if (encoded_bytes[i][0] == kValidByte) {\r\n         writer.Set();\r\ndiff --git a/cpp/src/arrow/compute/kernels/scalar_set_lookup.cc b/cpp/src/arrow/compute/kernels/scalar_set_lookup.cc\r\nindex 7d8d2edc4b..433df0f1b7 100644\r\n--- a/cpp/src/arrow/compute/kernels/scalar_set_lookup.cc\r\n+++ b/cpp/src/arrow/compute/kernels/scalar_set_lookup.cc\r\n@@ -353,8 +353,8 @@ struct IsInVisitor {\r\n     const auto& state = checked_cast<const SetLookupState<Type>&>(*ctx->state());\r\n     ArrayData* output = out->mutable_array();\r\n \r\n-    FirstTimeBitmapWriter writer(output->buffers[1]->mutable_data(), output->offset,\r\n-                                 output->length);\r\n+    FirstTimeBitmapWriter<> writer(output->buffers[1]->mutable_data(), output->offset,\r\n+                                   output->length);\r\n \r\n     VisitArrayDataInline<Type>(\r\n         this->data,\r\ndiff --git a/cpp/src/arrow/compute/kernels/scalar_string_ascii.cc b/cpp/src/arrow/compute/kernels/scalar_string_ascii.cc\r\nindex 611601cab8..da7de1c277 100644\r\n--- a/cpp/src/arrow/compute/kernels/scalar_string_ascii.cc\r\n+++ b/cpp/src/arrow/compute/kernels/scalar_string_ascii.cc\r\n@@ -1456,7 +1456,7 @@ struct MatchSubstringImpl {\r\n         [&matcher](const void* raw_offsets, const uint8_t* data, int64_t length,\r\n                    int64_t output_offset, uint8_t* output) {\r\n           const offset_type* offsets = reinterpret_cast<const offset_type*>(raw_offsets);\r\n-          FirstTimeBitmapWriter bitmap_writer(output, output_offset, length);\r\n+          FirstTimeBitmapWriter<> bitmap_writer(output, output_offset, length);\r\n           for (int64_t i = 0; i < length; ++i) {\r\n             const char* current_data = reinterpret_cast<const char*>(data + offsets[i]);\r\n             int64_t current_length = offsets[i + 1] - offsets[i];\r\ndiff --git a/cpp/src/arrow/util/bit_util_benchmark.cc b/cpp/src/arrow/util/bit_util_benchmark.cc\r\nindex 258fd27785..66a81b4e04 100644\r\n--- a/cpp/src/arrow/util/bit_util_benchmark.cc\r\n+++ b/cpp/src/arrow/util/bit_util_benchmark.cc\r\n@@ -386,7 +386,7 @@ static void BitmapWriter(benchmark::State& state) {\r\n }\r\n \r\n static void FirstTimeBitmapWriter(benchmark::State& state) {\r\n-  BenchmarkBitmapWriter<internal::FirstTimeBitmapWriter>(state, state.range(0));\r\n+  BenchmarkBitmapWriter<internal::FirstTimeBitmapWriter<>>(state, state.range(0));\r\n }\r\n \r\n struct GenerateBitsFunctor {\r\ndiff --git a/cpp/src/arrow/util/bit_util_test.cc b/cpp/src/arrow/util/bit_util_test.cc\r\nindex 6c2aff4fbe..9b9f19feb1 100644\r\n--- a/cpp/src/arrow/util/bit_util_test.cc\r\n+++ b/cpp/src/arrow/util/bit_util_test.cc\r\n@@ -832,14 +832,14 @@ TEST(FirstTimeBitmapWriter, NormalOperation) {\r\n     const uint8_t fill_byte = static_cast<uint8_t>(fill_byte_int);\r\n     {\r\n       uint8_t bitmap[] = {fill_byte, fill_byte, fill_byte, fill_byte};\r\n-      auto writer = internal::FirstTimeBitmapWriter(bitmap, 0, 12);\r\n+      auto writer = internal::FirstTimeBitmapWriter<>(bitmap, 0, 12);\r\n       WriteVectorToWriter(writer, {0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1});\r\n       //                      {0b00110110, 0b1010, 0, 0}\r\n       ASSERT_BYTES_EQ(bitmap, {0x36, 0x0a});\r\n     }\r\n     {\r\n       uint8_t bitmap[] = {fill_byte, fill_byte, fill_byte, fill_byte};\r\n-      auto writer = internal::FirstTimeBitmapWriter(bitmap, 4, 12);\r\n+      auto writer = internal::FirstTimeBitmapWriter<>(bitmap, 4, 12);\r\n       WriteVectorToWriter(writer, {0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1});\r\n       //                      {0b00110110, 0b1010, 0, 0}\r\n       ASSERT_BYTES_EQ(bitmap, {static_cast<uint8_t>(0x60 | (fill_byte & 0x0f)), 0xa3});\r\n@@ -848,15 +848,15 @@ TEST(FirstTimeBitmapWriter, NormalOperation) {\r\n     {\r\n       uint8_t bitmap[] = {fill_byte, fill_byte, fill_byte, fill_byte};\r\n       {\r\n-        auto writer = internal::FirstTimeBitmapWriter(bitmap, 0, 6);\r\n+        auto writer = internal::FirstTimeBitmapWriter<>(bitmap, 0, 6);\r\n         WriteVectorToWriter(writer, {0, 1, 1, 0, 1, 1});\r\n       }\r\n       {\r\n-        auto writer = internal::FirstTimeBitmapWriter(bitmap, 6, 3);\r\n+        auto writer = internal::FirstTimeBitmapWriter<>(bitmap, 6, 3);\r\n         WriteVectorToWriter(writer, {0, 0, 0});\r\n       }\r\n       {\r\n-        auto writer = internal::FirstTimeBitmapWriter(bitmap, 9, 3);\r\n+        auto writer = internal::FirstTimeBitmapWriter<>(bitmap, 9, 3);\r\n         WriteVectorToWriter(writer, {1, 0, 1});\r\n       }\r\n       ASSERT_BYTES_EQ(bitmap, {0x36, 0x0a});\r\n@@ -864,23 +864,23 @@ TEST(FirstTimeBitmapWriter, NormalOperation) {\r\n     {\r\n       uint8_t bitmap[] = {fill_byte, fill_byte, fill_byte, fill_byte};\r\n       {\r\n-        auto writer = internal::FirstTimeBitmapWriter(bitmap, 4, 0);\r\n+        auto writer = internal::FirstTimeBitmapWriter<>(bitmap, 4, 0);\r\n         WriteVectorToWriter(writer, {});\r\n       }\r\n       {\r\n-        auto writer = internal::FirstTimeBitmapWriter(bitmap, 4, 6);\r\n+        auto writer = internal::FirstTimeBitmapWriter<>(bitmap, 4, 6);\r\n         WriteVectorToWriter(writer, {0, 1, 1, 0, 1, 1});\r\n       }\r\n       {\r\n-        auto writer = internal::FirstTimeBitmapWriter(bitmap, 10, 3);\r\n+        auto writer = internal::FirstTimeBitmapWriter<>(bitmap, 10, 3);\r\n         WriteVectorToWriter(writer, {0, 0, 0});\r\n       }\r\n       {\r\n-        auto writer = internal::FirstTimeBitmapWriter(bitmap, 13, 0);\r\n+        auto writer = internal::FirstTimeBitmapWriter<>(bitmap, 13, 0);\r\n         WriteVectorToWriter(writer, {});\r\n       }\r\n       {\r\n-        auto writer = internal::FirstTimeBitmapWriter(bitmap, 13, 3);\r\n+        auto writer = internal::FirstTimeBitmapWriter<>(bitmap, 13, 3);\r\n         WriteVectorToWriter(writer, {1, 0, 1});\r\n       }\r\n       ASSERT_BYTES_EQ(bitmap, {static_cast<uint8_t>(0x60 | (fill_byte & 0x0f)), 0xa3});\r\n@@ -900,8 +900,8 @@ TEST(FirstTimeBitmapWriter, AppendWordOffsetOverwritesCorrectBitsOnExistingByte)\r\n   auto check_append = [](const std::string& expected_bits, int64_t offset) {\r\n     std::vector<uint8_t> valid_bits = {0x00};\r\n     constexpr int64_t kBitsAfterAppend = 8;\r\n-    internal::FirstTimeBitmapWriter writer(valid_bits.data(), offset,\r\n-                                           /*length=*/(8 * valid_bits.size()) - offset);\r\n+    internal::FirstTimeBitmapWriter<> writer(valid_bits.data(), offset,\r\n+                                             /*length=*/(8 * valid_bits.size()) - offset);\r\n     writer.AppendWord(/*word=*/0xFF, /*number_of_bits=*/kBitsAfterAppend - offset);\r\n     writer.Finish();\r\n     EXPECT_EQ(BitmapToString(valid_bits, kBitsAfterAppend), expected_bits);\r\n@@ -918,8 +918,8 @@ TEST(FirstTimeBitmapWriter, AppendWordOffsetOverwritesCorrectBitsOnExistingByte)\r\n   auto check_with_set = [](const std::string& expected_bits, int64_t offset) {\r\n     std::vector<uint8_t> valid_bits = {0x1};\r\n     constexpr int64_t kBitsAfterAppend = 8;\r\n-    internal::FirstTimeBitmapWriter writer(valid_bits.data(), offset,\r\n-                                           /*length=*/(8 * valid_bits.size()) - offset);\r\n+    internal::FirstTimeBitmapWriter<> writer(valid_bits.data(), offset,\r\n+                                             /*length=*/(8 * valid_bits.size()) - offset);\r\n     writer.AppendWord(/*word=*/0xFF, /*number_of_bits=*/kBitsAfterAppend - offset);\r\n     writer.Finish();\r\n     EXPECT_EQ(BitmapToString(valid_bits, kBitsAfterAppend), expected_bits);\r\n@@ -936,8 +936,8 @@ TEST(FirstTimeBitmapWriter, AppendWordOffsetOverwritesCorrectBitsOnExistingByte)\r\n   auto check_with_preceding = [](const std::string& expected_bits, int64_t offset) {\r\n     std::vector<uint8_t> valid_bits = {0xFF};\r\n     constexpr int64_t kBitsAfterAppend = 8;\r\n-    internal::FirstTimeBitmapWriter writer(valid_bits.data(), offset,\r\n-                                           /*length=*/(8 * valid_bits.size()) - offset);\r\n+    internal::FirstTimeBitmapWriter<> writer(valid_bits.data(), offset,\r\n+                                             /*length=*/(8 * valid_bits.size()) - offset);\r\n     writer.AppendWord(/*word=*/0xFF, /*number_of_bits=*/kBitsAfterAppend - offset);\r\n     writer.Finish();\r\n     EXPECT_EQ(BitmapToString(valid_bits, kBitsAfterAppend), expected_bits);\r\n@@ -954,8 +954,8 @@ TEST(FirstTimeBitmapWriter, AppendWordOffsetOverwritesCorrectBitsOnExistingByte)\r\n \r\n TEST(FirstTimeBitmapWriter, AppendZeroBitsHasNoImpact) {\r\n   std::vector<uint8_t> valid_bits(/*count=*/1, 0);\r\n-  internal::FirstTimeBitmapWriter writer(valid_bits.data(), /*start_offset=*/1,\r\n-                                         /*length=*/valid_bits.size() * 8);\r\n+  internal::FirstTimeBitmapWriter<> writer(valid_bits.data(), /*start_offset=*/1,\r\n+                                           /*length=*/valid_bits.size() * 8);\r\n   writer.AppendWord(/*word=*/0xFF, /*number_of_bits=*/0);\r\n   writer.AppendWord(/*word=*/0xFF, /*number_of_bits=*/0);\r\n   writer.AppendWord(/*word=*/0x01, /*number_of_bits=*/1);\r\n@@ -966,8 +966,8 @@ TEST(FirstTimeBitmapWriter, AppendZeroBitsHasNoImpact) {\r\n TEST(FirstTimeBitmapWriter, AppendLessThanByte) {\r\n   {\r\n     std::vector<uint8_t> valid_bits(/*count*/ 8, 0);\r\n-    internal::FirstTimeBitmapWriter writer(valid_bits.data(), /*start_offset=*/1,\r\n-                                           /*length=*/8);\r\n+    internal::FirstTimeBitmapWriter<> writer(valid_bits.data(), /*start_offset=*/1,\r\n+                                             /*length=*/8);\r\n     writer.AppendWord(0xB, 4);\r\n     writer.Finish();\r\n     EXPECT_EQ(BitmapToString(valid_bits, /*bit_count=*/8), \"01101000\");\r\n@@ -975,8 +975,8 @@ TEST(FirstTimeBitmapWriter, AppendLessThanByte) {\r\n   {\r\n     // Test with all bits initially set.\r\n     std::vector<uint8_t> valid_bits(/*count*/ 8, 0xFF);\r\n-    internal::FirstTimeBitmapWriter writer(valid_bits.data(), /*start_offset=*/1,\r\n-                                           /*length=*/8);\r\n+    internal::FirstTimeBitmapWriter<> writer(valid_bits.data(), /*start_offset=*/1,\r\n+                                             /*length=*/8);\r\n     writer.AppendWord(0xB, 4);\r\n     writer.Finish();\r\n     EXPECT_EQ(BitmapToString(valid_bits, /*bit_count=*/8), \"11101000\");\r\n@@ -986,8 +986,8 @@ TEST(FirstTimeBitmapWriter, AppendLessThanByte) {\r\n TEST(FirstTimeBitmapWriter, AppendByteThenMore) {\r\n   {\r\n     std::vector<uint8_t> valid_bits(/*count*/ 8, 0);\r\n-    internal::FirstTimeBitmapWriter writer(valid_bits.data(), /*start_offset=*/0,\r\n-                                           /*length=*/9);\r\n+    internal::FirstTimeBitmapWriter<> writer(valid_bits.data(), /*start_offset=*/0,\r\n+                                             /*length=*/9);\r\n     writer.AppendWord(0xC3, 8);\r\n     writer.AppendWord(0x01, 1);\r\n     writer.Finish();\r\n@@ -995,8 +995,8 @@ TEST(FirstTimeBitmapWriter, AppendByteThenMore) {\r\n   }\r\n   {\r\n     std::vector<uint8_t> valid_bits(/*count*/ 8, 0xFF);\r\n-    internal::FirstTimeBitmapWriter writer(valid_bits.data(), /*start_offset=*/0,\r\n-                                           /*length=*/9);\r\n+    internal::FirstTimeBitmapWriter<> writer(valid_bits.data(), /*start_offset=*/0,\r\n+                                             /*length=*/9);\r\n     writer.AppendWord(0xC3, 8);\r\n     writer.AppendWord(0x01, 1);\r\n     writer.Finish();\r\n@@ -1012,8 +1012,8 @@ TEST(FirstTimeBitmapWriter, AppendWordShiftsBitsCorrectly) {\r\n     ASSERT_GE(offset, 8);\r\n     std::vector<uint8_t> valid_bits(/*count=*/10, preset_buffer_bits ? 0xFF : 0);\r\n     valid_bits[0] = 0x99;\r\n-    internal::FirstTimeBitmapWriter writer(valid_bits.data(), offset,\r\n-                                           /*length=*/(9 * sizeof(kPattern)) - offset);\r\n+    internal::FirstTimeBitmapWriter<> writer(valid_bits.data(), offset,\r\n+                                             /*length=*/(9 * sizeof(kPattern)) - offset);\r\n     writer.AppendWord(/*word=*/kPattern, /*number_of_bits=*/64);\r\n     writer.Finish();\r\n     EXPECT_EQ(valid_bits[0], 0x99);  // shouldn't get changed.\r\n@@ -1051,15 +1051,15 @@ TEST(TestAppendBitmap, AppendWordOnlyAppropriateBytesWritten) {\r\n \r\n   uint64_t bitmap = 0x1FF;\r\n   {\r\n-    internal::FirstTimeBitmapWriter writer(valid_bits.data(), /*start_offset=*/1,\r\n-                                           /*length=*/(8 * valid_bits.size()) - 1);\r\n+    internal::FirstTimeBitmapWriter<> writer(valid_bits.data(), /*start_offset=*/1,\r\n+                                             /*length=*/(8 * valid_bits.size()) - 1);\r\n     writer.AppendWord(bitmap, /*number_of_bits*/ 7);\r\n     writer.Finish();\r\n     EXPECT_THAT(valid_bits, ElementsAreArray(std::vector<uint8_t>{0xFE, 0x00}));\r\n   }\r\n   {\r\n-    internal::FirstTimeBitmapWriter writer(valid_bits.data(), /*start_offset=*/1,\r\n-                                           /*length=*/(8 * valid_bits.size()) - 1);\r\n+    internal::FirstTimeBitmapWriter<> writer(valid_bits.data(), /*start_offset=*/1,\r\n+                                             /*length=*/(8 * valid_bits.size()) - 1);\r\n     writer.AppendWord(bitmap, /*number_of_bits*/ 8);\r\n     writer.Finish();\r\n     EXPECT_THAT(valid_bits, ElementsAreArray(std::vector<uint8_t>{0xFE, 0x03}));\r\ndiff --git a/cpp/src/arrow/util/bitmap_writer.h b/cpp/src/arrow/util/bitmap_writer.h\r\nindex 65d0d188d7..7a70b16f15 100644\r\n--- a/cpp/src/arrow/util/bitmap_writer.h\r\n+++ b/cpp/src/arrow/util/bitmap_writer.h\r\n@@ -21,6 +21,8 @@\r\n #include <cstring>\r\n \r\n #include \"arrow/util/bit_util.h\"\r\n+#include \"arrow/util/config.h\"\r\n+#include \"arrow/util/dispatch.h\"\r\n #include \"arrow/util/endian.h\"\r\n #include \"arrow/util/macros.h\"\r\n \r\n@@ -78,6 +80,7 @@ class BitmapWriter {\r\n   int64_t byte_offset_;\r\n };\r\n \r\n+template <DispatchLevel level = ARROW_COMPILE_TIME_DISPATCH_LEVEL>\r\n class FirstTimeBitmapWriter {\r\n   // Like BitmapWriter, but any bit values *following* the bits written\r\n   // might be clobbered.  It is hence faster than BitmapWriter, and can\r\ndiff --git a/cpp/src/arrow/util/config.h.cmake b/cpp/src/arrow/util/config.h.cmake\r\nindex 55bc2d0100..1ecb4f39f3 100644\r\n--- a/cpp/src/arrow/util/config.h.cmake\r\n+++ b/cpp/src/arrow/util/config.h.cmake\r\n@@ -36,6 +36,8 @@\r\n \r\n #define ARROW_PACKAGE_KIND \"@ARROW_PACKAGE_KIND@\"\r\n \r\n+#define ARROW_COMPILE_TIME_DISPATCH_LEVEL ::arrow::internal::DispatchLevel::@ARROW_SIMD_LEVEL@\r\n+\r\n #cmakedefine ARROW_COMPUTE\r\n #cmakedefine ARROW_CSV\r\n #cmakedefine ARROW_CUDA\r\ndiff --git a/cpp/src/arrow/util/dispatch.h b/cpp/src/arrow/util/dispatch.h\r\nindex fae9293f9e..d6f4dbb028 100644\r\n--- a/cpp/src/arrow/util/dispatch.h\r\n+++ b/cpp/src/arrow/util/dispatch.h\r\n@@ -33,6 +33,7 @@ enum class DispatchLevel : int {\r\n   SSE4_2,\r\n   AVX2,\r\n   AVX512,\r\n+  BMI2,\r\n   NEON,\r\n   MAX\r\n };\r\n@@ -105,6 +106,8 @@ class DynamicDispatch {\r\n         return cpu_info->IsSupported(CpuInfo::AVX2);\r\n       case DispatchLevel::AVX512:\r\n         return cpu_info->IsSupported(CpuInfo::AVX512);\r\n+      case DispatchLevel::BMI2:\r\n+        return cpu_info->IsSupported(CpuInfo::BMI2);\r\n       default:\r\n         return false;\r\n     }\r\ndiff --git a/cpp/src/parquet/encoding.cc b/cpp/src/parquet/encoding.cc\r\nindex af0e543c3e..34f0eef3b5 100644\r\n--- a/cpp/src/parquet/encoding.cc\r\n+++ b/cpp/src/parquet/encoding.cc\r\n@@ -348,8 +348,8 @@ class PlainEncoder<BooleanType> : public EncoderImpl, virtual public BooleanEnco\r\n     } else {\r\n       auto n_valid = bit_util::BytesForBits(data.length() - data.null_count());\r\n       PARQUET_THROW_NOT_OK(sink_.Reserve(n_valid));\r\n-      ::arrow::internal::FirstTimeBitmapWriter writer(sink_.mutable_data(),\r\n-                                                      sink_.length(), n_valid);\r\n+      ::arrow::internal::FirstTimeBitmapWriter<> writer(sink_.mutable_data(),\r\n+                                                        sink_.length(), n_valid);\r\n \r\n       for (int64_t i = 0; i < data.length(); i++) {\r\n         if (data.IsValid(i)) {\r\ndiff --git a/cpp/src/parquet/level_comparison_avx2.cc b/cpp/src/parquet/level_comparison_avx2.cc\r\nindex b33eb2e295..521cf96520 100644\r\n--- a/cpp/src/parquet/level_comparison_avx2.cc\r\n+++ b/cpp/src/parquet/level_comparison_avx2.cc\r\n@@ -16,7 +16,9 @@\r\n // under the License.\r\n \r\n #define PARQUET_IMPL_NAMESPACE avx2\r\n+#define PARQUET_DISPATCH_LEVEL ::arrow::internal::DispatchLevel::AVX2\r\n #include \"parquet/level_comparison_inc.h\"\r\n+#undef PARQUET_DISPATCH_LEVEL\r\n #undef PARQUET_IMPL_NAMESPACE\r\n \r\n namespace parquet {\r\ndiff --git a/cpp/src/parquet/level_conversion.cc b/cpp/src/parquet/level_conversion.cc\r\nindex ffdca476dd..ab440af95a 100644\r\n--- a/cpp/src/parquet/level_conversion.cc\r\n+++ b/cpp/src/parquet/level_conversion.cc\r\n@@ -28,7 +28,9 @@\r\n \r\n #include \"parquet/level_comparison.h\"\r\n #define PARQUET_IMPL_NAMESPACE standard\r\n+#define PARQUET_DISPATCH_LEVEL ARROW_COMPILE_TIME_DISPATCH_LEVEL\r\n #include \"parquet/level_conversion_inc.h\"\r\n+#undef PARQUET_DISPATCH_LEVEL\r\n #undef PARQUET_IMPL_NAMESPACE\r\n \r\n namespace parquet {\r\n@@ -43,7 +45,7 @@ void DefRepLevelsToListInfo(const int16_t* def_levels, const int16_t* rep_levels\r\n                             int64_t num_def_levels, LevelInfo level_info,\r\n                             ValidityBitmapInputOutput* output, OffsetType* offsets) {\r\n   OffsetType* orig_pos = offsets;\r\n-  optional<::arrow::internal::FirstTimeBitmapWriter> valid_bits_writer;\r\n+  optional<::arrow::internal::FirstTimeBitmapWriter<>> valid_bits_writer;\r\n   if (output->valid_bits) {\r\n     valid_bits_writer.emplace(output->valid_bits, output->valid_bits_offset,\r\n                               output->values_read_upper_bound);\r\ndiff --git a/cpp/src/parquet/level_conversion_bmi2.cc b/cpp/src/parquet/level_conversion_bmi2.cc\r\nindex 274d54e503..679d01d0c9 100644\r\n--- a/cpp/src/parquet/level_conversion_bmi2.cc\r\n+++ b/cpp/src/parquet/level_conversion_bmi2.cc\r\n@@ -17,7 +17,9 @@\r\n #include \"parquet/level_conversion.h\"\r\n \r\n #define PARQUET_IMPL_NAMESPACE bmi2\r\n+#define PARQUET_DISPATCH_LEVEL ::arrow::internal::DispatchLevel::BMI2\r\n #include \"parquet/level_conversion_inc.h\"\r\n+#undef PARQUET_DISPATCH_LEVEL\r\n #undef PARQUET_IMPL_NAMESPACE\r\n \r\n namespace parquet {\r\ndiff --git a/cpp/src/parquet/level_conversion_inc.h b/cpp/src/parquet/level_conversion_inc.h\r\nindex 710d2f6237..4b5a9def80 100644\r\n--- a/cpp/src/parquet/level_conversion_inc.h\r\n+++ b/cpp/src/parquet/level_conversion_inc.h\r\n@@ -296,7 +296,10 @@ static constexpr int64_t kExtractBitsSize = 8 * sizeof(extract_bitmap_t);\r\n template <bool has_repeated_parent>\r\n int64_t DefLevelsBatchToBitmap(const int16_t* def_levels, const int64_t batch_size,\r\n                                int64_t upper_bound_remaining, LevelInfo level_info,\r\n-                               ::arrow::internal::FirstTimeBitmapWriter* writer) {\r\n+#ifndef PARQUET_DISPATCH_LEVEL\r\n+#error \"PARQUET_DISPATCH_LEVEL must be defined\"\r\n+#endif\r\n+                               ::arrow::internal::FirstTimeBitmapWriter<PARQUET_DISPATCH_LEVEL>* writer) {\r\n   DCHECK_LE(batch_size, kExtractBitsSize);\r\n \r\n   // Greater than level_info.def_level - 1 implies >= the def_level\r\n@@ -330,7 +333,7 @@ int64_t DefLevelsBatchToBitmap(const int16_t* def_levels, const int64_t batch_si\r\n template <bool has_repeated_parent>\r\n void DefLevelsToBitmapSimd(const int16_t* def_levels, int64_t num_def_levels,\r\n                            LevelInfo level_info, ValidityBitmapInputOutput* output) {\r\n-  ::arrow::internal::FirstTimeBitmapWriter writer(\r\n+  ::arrow::internal::FirstTimeBitmapWriter<PARQUET_DISPATCH_LEVEL> writer(\r\n       output->valid_bits,\r\n       /*start_offset=*/output->valid_bits_offset,\r\n       /*length=*/output->values_read_upper_bound);\r\n```"
        },
        {
            "created_at": "2022-05-19T07:39:53.409Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17539368) by Antoine Pitrou (apitrou):*\n`[~kou]` We can do that for the specific symptoms here. However, a more general solution will have to be found since other files have the same problem: compiling SIMD-specific code which calls into other routines."
        },
        {
            "created_at": "2022-05-25T20:35:45.403Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17542232) by Ben Kietzman (bkietz):*\n`[~apitrou]` The most robust solution I can think of is to avoid linking between objects with differing instruction sets altogether. We'd have something like\r\n```Java\n\r\n$ nm libarrow_compute_avx2.so | grep DefLevelsBitmapSimd\r\n0000000000404ff0 t DefLevelsBitmapSimd\r\n```\r\n\r\nThat library would be acquired with `dlopen(path, RTLD_LOCAL)/LoadLibrary(path)` which would guarantee that any functions like `FirstTimeBitmapWriter::*` which might have been recompiled with illegal instructions are not available outside `libarrow_compute_avx2.so`."
        },
        {
            "created_at": "2022-05-25T20:50:18.490Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17542235) by Ben Kietzman (bkietz):*\nIIUC, we'll still need to pass `-mavx2` so that we can include immintrin.h so the attribute described in the `ARROW_SPECIALIZED_SIMD_TARGET` approach would need to be attached to the {**}non{**}-SIMD functions to ensure that they're compiled with no special instructions\r\n\r\n... or I suppose we could try to declare all the intrinsics manually at function scope\r\n```java\n\r\nARROW_SIMD_FUNCTION(avx2) void SimdThing() {\r\n  // inlined from immintrin.h:\r\n  typedef unsigned short __mmask16;\r\n  extern\r\n    __inline\r\n    __mmask16\r\n    __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\r\n        _mm512_int2mask (int __M);\r\n}\n```"
        },
        {
            "created_at": "2022-05-25T21:19:40.273Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17542244) by Ben Kietzman (bkietz):*\nOn further investigation, we can include immintrin.h with or without -mavx2 and clang at least will not complain unless the intrinsics are referenced, so\r\n\r\n```Java\n\r\n#include <immintrin.h>\r\n\r\n[[gnu::target(\"avx2\")]]\r\nvoid use_simd() {\r\n  __m256i arg;\r\n  _mm256_abs_epi16 (arg);\r\n}\r\n\r\nint main() { use_simd(); }\r\n```\r\n\r\ncompiles and runs happily without any special compilation flags. Using an attribute like this seems viable provided we can be certain that the modified target isn't transitively applied to functions which might be invoked for the first time inside a SIMD enabled function"
        },
        {
            "created_at": "2022-07-07T14:55:01.210Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17563824) by Ian Cook (icook):*\n`[~jonkeane]` \u00a0this issue is marked as a blocker for 9.0.0. Should this block the release?"
        },
        {
            "created_at": "2022-07-07T22:48:53.273Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17564018) by Jonathan Keane (jonkeane):*\nLast I checked, the homebrew maintainers have said that they will disable all optimization for arrow if we don't get this sorted on our own. So not required if we're ok with that (though we should engage with them on this)"
        },
        {
            "created_at": "2022-07-08T08:09:56.097Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17564152) by Antoine Pitrou (apitrou):*\nDisabling all optimizations for Arrow is brutal. It would be **much** better to simply disable runtime SIMD optimizations (by passing `-DARROW_RUNTIME_SIMD_LEVEL=NONE` to CMake, AFAIR)."
        },
        {
            "created_at": "2022-07-22T10:23:06.442Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17569933) by Ra\u00fal Cumplido (raulcd):*\nIs this still a blocker?"
        },
        {
            "created_at": "2022-07-22T11:47:42.931Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17569968) by Antoine Pitrou (apitrou):*\nIdeally it would... But there's little chance for it to be fixed in time for 9.0.0.\r\n\r\nAs I said above, the workaround should be to disable runtime SIMD optimizations on the affected builds. Somehow has to validate that suggestion, though (i.e. someone who's able to reproduce this issue)."
        },
        {
            "created_at": "2022-07-22T12:29:41.411Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17569991) by Jacob Wujciak-Jens (assignUser):*\nLooking at [ARROW-15664] and this [PR](https://github.com/apache/arrow/pull/12364/files#diff-ca50d864d033146f9135f2fc25ae337322982dd340c6fa25b1efe9f0c02db870) it seems like a workaround has been implemented for homebrew IIUC, so this is still an issue but as the real fix wont happen for 9.0.0 it shouldn't be a blocker anymore?"
        },
        {
            "created_at": "2022-07-22T12:39:00.827Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17569996) by Antoine Pitrou (apitrou):*\nIf that was actually accepted by Homebrew then fine."
        },
        {
            "created_at": "2022-07-22T16:59:19.197Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17570126) by Jacob Wujciak-Jens (assignUser):*\nThat was my impression: [issue](https://github.com/Homebrew/homebrew-core/issues/94724) and [PR](https://github.com/Homebrew/homebrew-core/pull/94958) in homebrew-core. \r\nMaybe `[~jonkeane]` can confirm?\r\n"
        },
        {
            "created_at": "2022-07-22T19:26:30.185Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17570163) by Jonathan Keane (jonkeane):*\nHomebrew only accepted that as a temporary workaround and has threatened to turn off optimizations if we don't resolve this. They haven't yet followed through yet, though. https://github.com/Homebrew/homebrew-core/issues/94724#issuecomment-1063031123 "
        },
        {
            "created_at": "2022-07-22T19:27:54.592Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17570164) by Antoine Pitrou (apitrou):*\nNote that I suggested a perhaps more acceptable workaround above."
        },
        {
            "created_at": "2022-07-25T08:38:09.115Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17570777) by Krisztian Szucs (kszucs):*\n`[~jonkeane]` can you give an update on this issue?"
        },
        {
            "created_at": "2022-07-25T21:11:07.997Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17571097) by Krisztian Szucs (kszucs):*\nPostponing to 10.0 for now."
        },
        {
            "created_at": "2022-07-25T22:50:01.637Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17571125) by Jonathan Keane (jonkeane):*\nI have no updates beyond what's discussed above: there are a few approaches, none of them ideal, we need someone to champion this (or risk the homebrew maintainers turning off optimizations on us)"
        },
        {
            "created_at": "2022-10-06T09:17:09.593Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17613392) by Ra\u00fal Cumplido (raulcd):*\nThis was a blocker for the last release and is still a blocker for the 10.0.0 release. `[~jonkeane]` do you know if there has been any move?"
        },
        {
            "created_at": "2022-10-06T13:06:46.595Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17613507) by Jonathan Keane (jonkeane):*\nI thought that `[~kou]` was going to take a look at this (or at least the underlying multiple SIMD instruction ordering issue that causes the failures...)\r\n\r\nThe only update I have is that I continue to run into the segfault in CI for downstream projects I'm working on, so it continues to be an issue for pre-built libarrow on machines like github's macos runners. "
        },
        {
            "created_at": "2022-10-06T20:59:50.822Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17613789) by Kouhei Sutou (kou):*\nYes. I will fix this before the 10.0.0 release. Sorry for not working on this yet.\r\n"
        },
        {
            "created_at": "2022-10-07T07:05:48.379Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17613909) by Kouhei Sutou (kou):*\nSummary of this problem:\r\n\r\nProblem:\r\n\r\n- Parquet module is crashed with `-DCMAKE_BUILD_TYPE=MinSizeRel`\n  \n  Why the problem is happened:\n  \n- We compile the same code (`level_conversion_inc.h`) multiple times with different optimization flags such as `-msse4.2` and `-mavx2`\n- The code calls the same function (`arrow::internal::FirstTimeBitmapWriter::AppendWord()`) that is defined in header file\n- The called function isn't inlined with `-DCMAKE_BUILD_TYPE=MinSizeRel`\n- It generates multiple definitions for the called (not-inlined) function (`arrow::internal::FirstTimeBitmapWriter::AppendWord()`)\n  \n  Proposed solutions so far:\n  \n1. Force to inline functions that are called from the code that are compiled with SIMD related optimization flags\n1. Restrict SIMD related optimization area to only the target function\n   \n   For 1., we have two approaches for it:\n- Use template:\n  - https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17524280&#comment-17524280 : It's used in our compute module\n  - https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17539142&#comment-17539142 : A patch for this case\n- Use `\\_\\_attribute\\_\\_((always\\_inline))`\n  - https://github.com/apache/arrow/pull/12928#issuecomment-1104621952\n    \n    This approach seems ad-hoc. We need to apply this approach to called functions when we find this problem in other codes.\n    \n    For 2., we have one approach for it:\n- Use `target` attribute:\n  - https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17526053#comment-17526053 : A sample code that shows this approach\n    \n    (I'm not sure that this approach is portable. For example, can we use this approach with MSVC?) "
        },
        {
            "created_at": "2022-10-07T07:18:56.735Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17613912) by Kouhei Sutou (kou):*\nI propose one more approach for the proposed solution 1.:\r\n\r\nHow about always enabling inline optimization for SIMD optimized compile units (`level_conversion_bmi2.cc`) even when an user specifies `-DCMAKE_BUILD_TYPE=MinSizeRel`?\r\n\r\nIt may increases binary size but it may be better that SIMD related code prioritizes performance than binary size.\r\n\r\nWe don't need to write manual `template`/`\\_\\_attribute\\_\\_((always\\_inline))` s with this approach."
        },
        {
            "created_at": "2022-10-07T07:44:18.985Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17613930) by Antoine Pitrou (apitrou):*\nWell, I don't think we can force the compiler to inline _everything_."
        },
        {
            "created_at": "2022-10-07T07:56:05.854Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17613939) by Kouhei Sutou (kou):*\nWe don't have this problem with `-DCMAKE_BUILD_TYPE=Release`. So it may work with most cases."
        },
        {
            "created_at": "2022-10-10T21:18:56.022Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15678?focusedCommentId=17615352) by Kouhei Sutou (kou):*\nIssue resolved by pull request 14342\n<https://github.com/apache/arrow/pull/14342>"
        }
    ]
}