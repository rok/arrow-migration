{
    "issue": {
        "title": "[C++][Gandiva] Add parser frontend for Gandiva",
        "body": "***Note**: This issue was originally created as [ARROW-17668](https://issues.apache.org/jira/browse/ARROW-17668). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\n## Background\r\n\r\nMy team uses an expression computation library for our C++ feature engineering pipeline. We currently use\u00a0[Exprtk](https://github.com/ArashPartow/exprtk). We recently tried out Gandiva and wrote some benchmarks. We discovered that Gandiva is several times faster than Exprtk in our use cases. Therefore we decided to switch to Gandiva for computing expressions.\r\n## Objective\r\n\r\nAs of current, due to its lack of a frontend, we need to manually construct an AST to use Gandiva. This is inconvenient and requires extra learning costs. We also want to enable our ML engineers to dynamically create/update an expression with runtime hot-loaded configs without restarting our server. This is currently impossible with Gandiva because the Expression tree is statically created with C++ and must be compiled in the server binary.\r\n\r\nTherefore, we would like to implement a parser frontend for Gandiva, so that Gandiva becomes a standalone complete expression compiler and evaluator, and a drop-in replacement for the existing libraries like\u00a0[Exprtk](https://github.com/ArashPartow/exprtk)\u00a0and\u00a0[TinyExpr](https://github.com/codeplea/tinyexpr). The goal is to enable the following functionality:\r\n\r\n\u00a0\r\n\r\n``\r\n```java\n\r\n// Create schema for gandiva\r\nauto field_x = arrow::field(\"x\", arrow::uint64());\r\nauto field_y = arrow::field(\"y\", arrow::float64());\r\nauto field_z = arrow::field(\"z\", arrow::boolean());\r\nauto schema = arrow::schema({field_x, field_y, field_z});\r\n\r\n/** BEGIN CHANGE **/\r\n// Use the Parser to generate a NodePtr\r\nstd::string expr_str = \"if(z, castFloat8(x), y * 1000.0)\";\r\nauto parser = gandiva::Parser(schema);\r\ngandiva::NodePtr root_node;\r\nauto status = parser.Parse(expr_str, &root_node);\r\n/** END CHANGE **/\r\n\r\n// The rest is normal usage of Gandiva projector\r\nauto expr_ptr = std::make_shared<gandiva::Expression>(root_node, result_field);\r\nstd::shared_ptr<gandiva::Projector> projector;\r\nauto status = gandiva::Projector::Make(schema, {expr_ptr}, &projector);\r\n\r\nauto in_batch = arrow::RecordBatch::Make(schema, size, input_arr);\r\nauto* pool = arrow::default_memory_pool();\r\narrow::ArrayVector outputs;\r\nauto status = projector->Evaluate(*in_batch, pool, &outputs);\n```\r\n`\u00a0`\r\n\r\nThe code block enclosed by \u201cBEGIN CHANGE\u201d and \u201cEND CHANGE\u201d is the proposed usage of the parser. It offers two benefits:\r\n1. It\u2019s more intuitive to write math expressions compared to constructing trees, thus easier to use.\n1. It allows dynamically adding new expressions or and changing existing ones with a runtime hot-loaded config file without restarting our server.\n   \n   ## Syntax\n   \n   The goal is to design a succinct and intuitive grammar for both schema and Gandiva expressions. We will need a corresponding grammar for each Node type in Gandiva.\n    \\* Literals: We find Rust\u2019s literal representation(<https://doc.rust-lang.org/rust-by-example/types/literals.html>) very intuitive. We\u2019ll support suffixes such as\u00a0`{}i32{`},\u00a0`{}u64{`},\u00a0`f32`\u00a0to denote a literal node\u2019s type. The types of unsuffixed literals are inferred by their usage. Otherwise, the default type for integers is\u00a0`int32`\u00a0and\u00a0`float32`\u00a0for floating points. String and binary literals are wrapped with single or double quotes. Decimal128 literals will not be supported in the first version.\n   \n    \\* Fields: Just their names as defined in the schema. To avoid conflicts with other node types, field names must start with alphabetical letters.\n   \n    \\* Functions:\u00a0`{}<function_name>(<param1>, <param2>, ...){`}. For functions with multiple overloads, their return type is inferred from input types. For commonly used functions, we would also like to support infix forms. They include:\n   \n    \\*\\* Comparisons: equal(==), not equal(!=), greater than(>), greater than or equal to(>=), less than(<), less than or equal to(<=)\n    \\*\\* Arithmetics: add(+), subtract(-), multiply(\\*), divide(/), modulo(%), power(<sup>), bitwise and(&), bitwise or(|), bitwise xor(</sup>), bitwise not(~)\n   Function aliases with spaces in their names won\u2019t be supported such as \u201cis not false\u201d are not supported.\n   \n    \\* Ifs: We would like to support two grammars for if expressions:\n   \n    \\*\\* `if(<cond>, <then>, <else>)`\u00a0for its simplicity and functional feel;\n    \\*\\* `if(<cond>) \\{ <then> } else \\{ <else> `}\u00a0since it\u2019s the C++\u00a0`if`\u00a0grammar and has better formatting for complex expressions.\n    \\* Booleans: We would like to support both\u00a0`&& ||`\u00a0and\u00a0`and or`\u00a0keywords the same as C++.\n   \n    \\* InExpressions:\u00a0`<eval> in (<member1>, <member2>, ...)`\u00a0. Its type is also inferred.\n   \n   The grammar can be roughly represented as:\n   \n   \u00a0\n   \n   ``\n   ```java\n   \n   // Create schema for gandiva\n   auto field_x = arrow::field(\"x\", arrow::uint64());\n   auto field_y = arrow::field(\"y\", arrow::float64());\n   auto field_z = arrow::field(\"z\", arrow::boolean());\n   auto schema = arrow::schema({field_x, field_y, field_z});\n   \n   /** BEGIN CHANGE **/\n   // Use the Parser to generate a NodePtr\n   std::string expr_str = \"if(z, castFloat8(x), y * 1000.0)\";\n   auto parser = gandiva::Parser(schema);\n   gandiva::NodePtr root_node;\n   auto status = parser.Parse(expr_str, &root_node);\n   /** END CHANGE **/\n   \n   // The rest is normal usage of Gandiva projector\n   auto expr_ptr = std::make_shared<gandiva::Expression>(root_node, result_field);\n   std::shared_ptr<gandiva::Projector> projector;\n   auto status = gandiva::Projector::Make(schema, {expr_ptr}, &projector);\n   \n   auto in_batch = arrow::RecordBatch::Make(schema, size, input_arr);\n   auto* pool = arrow::default_memory_pool();\n   arrow::ArrayVector outputs;\n   auto status = projector->Evaluate(*in_batch, pool, &outputs);\n   ```\n   `\u00a0`\n   \n   lower cases are non-terminals and upper cases are tokens.\n   ## Implementation\n   ### Lexing and Parsing\n   \n   We would like to use flex and bison for lexing and parsing. They have several advantages compared to other options like Antlr4 and Boost::Spirit.\n1. They are the most classical and popular parsing library in the cpp world.\n1. They allow us to precompile the parser codes and have no runtime dependencies.\n   \n   Flex&bison takes a string and outputs a\u00a0`gandiva::node`\u00a0tree. The tree may contain untyped nodes, e.g., unsuffixed literals and functions.\n   ### Type Inference\n   \n   We\u2019ll have a TypeInferenceVisitor class that inherits node visitor, implementing a 2-pass DFS algorithm to do type inference. In each pass, the visitor tries to infer current node\u2019s and its children\u2019s types from currently available info:\n   \n   If it\u2019s a non-leaf node such as\u00a0`function`\u00a0,`{}if{`}\u00a0,`{}boolean{`}:\n1. First visit each child: let them infer their own types as much as they can.\n1. Create a\u00a0`SignaturePattern`\u00a0based on currently known types. The pattern includes the current node\u2019s type and children\u2019s types. The types can be\u00a0`nullptr`\u00a0meaning the type is currently unknown. For example, the\u00a0`SignaturePattern`\u00a0for\u00a0`func(x: u64, 5: untyped)`\u00a0will be\u00a0`(u64, nullptr)\u2014>nullptr.`\n1. Get all available signatures of the current node. For\u00a0`{}function{`}s, it\u2019s the signatures registered at the function registry. For\u00a0`{}if{`}, it\u2019s\u00a0`(bool, <type>, <type>)\u2014><type>`\u00a0for any type etc.\n1. Try to match each signature with the current pattern\u00a0`SignaturePattern`\n   1. If no one matches, it\u2019s a type error.\n   1. If only one matches, it\u2019s the matched signature. We then update current node\u2019s and their children\u2019s types based on this signature.\n   1. If more than one matches, we extract a common pattern from the set of matched signatures. For example,\u00a0`(nullptr, nullptr)\u2014>bool`\u00a0can be extracted from\u00a0`(double, double)\u2014>bool`\u00a0and\u00a0`(int32, int32)\u2014>bool`\u00a0. We then update types based on this common pattern.\n      \n      If it\u2019s a leaf node, just update its value if its type is set by its parent. We need to do this because untyped literals\u2019 values are saved in a generic container.\n      \n      We run this procedure 2 times, with the second pass a bit different. In the second pass, if a literal node is still untyped, give it a default type (`{}int32{`}\u00a0for ints and\u00a0`float32`\u00a0for floats).\n1. The first pass is bottom up propagation of types. A parent\u2019s type is inferred from its children.\n1. The second pass is both:\n   1. top down propagation of first pass\u2019 info. Once a parent\u2019s type is known in the first pass, it may set it\u2019s children\u2019s type\n   1. bottom up of default literal types. A literal is given a default type.\n      \n      In the second pass, since all leaf nodes\u2019 types are known. The types of all nodes are guaranteed to be inferred.\n      ### Proof of correctness\n      \n      I have a proof of correctness of this inference procedure in mind, but it\u2019s too long to be written down here. (Fermat did it too :)) But the correctness is based on these two facts:\n1. There are no overloads that differ only on their return types. E.g. there are no\u00a0`func := (int32, int32)-->int32`\u00a0and\u00a0`func := (int32, int32)-->double`\u00a0in the Gandiva registry. Therefore we can always know a function\u2019s type if its children\u2019s types are known.\n1. There are no overloads that accept only non-default numeric types. For example, if there is a\u00a0`func := (int16, int16)-->int16`\u00a0and\u00a0`{}func := (int64, int64)-->int64{`}, but no\u00a0`{}func := (int32, int32)-->int32{`}, then the inference procedure will fail on expression\u00a0`func(1, 2)`\u00a0because it cannot tell the types of\u00a0`1`\u00a0and\u00a0`{}2{`}, and giving them default types won't work.\n   \n   ## Prototype and Examples\n   \n   I\u2019ve already written a mostly working prototype of the parser and type inference visitor and unit tests for them. They are on the branch\u00a0<https://github.com/js8544/arrow/tree/jinshang/gandiva/type_inference>.\n   \n   You can checkout the diffs here:\u00a0<https://github.com/apache/arrow/compare/master...js8544:arrow:jinshang/gandiva/type_inference>\n   \n   The main files are:\n1. cpp/src/gandiva/grammar.yy: grammar rules for Bison.\n1. cpp/src/gandiva/lex.ll: lex rules for Flex.\n1. cpp/src/gandiva/typeinference.h/cc: type inference procedure.\n1. cpp/src/gandiva/parser.cc: the driver class that combines the three components.\n1. cpp/src/gandiva/parser_test.cc: unit tests containing examples of the proposed syntax and the result expression trees the parser generates. You can run the tests by running\u00a0`cmake .. --preset=ninja-debug-gandiva`\u00a0and\u00a0`{}ninja test-gandiva-tests{`}.\n   \n   Any suggestion/question is appreciated!",
        "created_at": "2022-09-09T17:46:30.000Z",
        "updated_at": "2022-10-11T07:17:18.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++ - Gandiva",
            "Type: enhancement"
        ],
        "closed": false
    },
    "comments": [
        {
            "created_at": "2022-09-15T20:00:20.806Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-17668?focusedCommentId=17605508) by Kouhei Sutou (kou):*\nCould you post this proposal to `dev@arrow.apache.org` to get more feedback?"
        }
    ]
}