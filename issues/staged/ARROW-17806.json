{
    "issue": {
        "title": "pyarrow fails to write and read a dataframe with MultiIndex containing a RangeIndex with Pandas 1.5.0",
        "body": "***Note**: This issue was originally created as [ARROW-17806](https://issues.apache.org/jira/browse/ARROW-17806). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nA dataframe with a MultiIndex built in this way:\r\n```java\n\r\nimport pandas as pd\r\ndf1 = pd.DataFrame({\"a\": [10, 11, 12], \"b\": [20, 21, 22]}, index=pd.RangeIndex(3, name=\"idx0\"))\r\ndf1 = df1.set_index(\"b\", append=True)\r\nprint(df1)\r\nprint(df1.index.get_level_values(\"idx0\")) \n```\r\ngives with Pandas 1.5.0:\r\n```java\n\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 a\r\nidx0 b\u00a0 \u00a0 \u00a0\r\n0\u00a0 \u00a0 20\u00a0 10\r\n1\u00a0 \u00a0 21\u00a0 11\r\n2\u00a0 \u00a0 22\u00a0 12\r\n\r\nRangeIndex(start=0, stop=3, step=1, name='idx0')\n```\r\nwhile with Pandas 1.4.4:\r\n```java\n\r\n  \u00a0 \u00a0 \u00a0 \u00a0 a\r\nidx0 b\u00a0 \u00a0 \u00a0\r\n0\u00a0 \u00a0 20\u00a0 10\r\n1\u00a0 \u00a0 21\u00a0 11\r\n2\u00a0 \u00a0 22\u00a0 12\r\n\r\nInt64Index([0, 1, 2], dtype='int64', name='idx0')\n```\r\ni.e. the result is RangeIndex instead of Int64Index.\r\n\r\nWith pandas 1.5.0 and pyarrow 9.0.0, writing this DataFrame with index=None (i.e. the default value) as in:\r\n```java\n\r\ndf1.to_parquet(path, engine=\"pyarrow\", index=None) \n```\r\nthen reading the same file with:\r\n```java\n\r\npd.read_parquet(path, engine=\"pyarrow\") \n```\r\nraises an exception:\r\n```java\n\r\n File /<venv>/lib/python3.9/site-packages/pyarrow/pandas_compat.py:997, in _extract_index_level(table, result_table, field_name, field_name_to_metadata)\r\n\u00a0 \u00a0 995 def _extract_index_level(table, result_table, field_name,\r\n\u00a0 \u00a0 996 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0field_name_to_metadata):\r\n--> 997 \u00a0 \u00a0 logical_name = field_name_to_metadata[field_name]['name']\r\n\u00a0 \u00a0 998 \u00a0 \u00a0 index_name = _backwards_compatible_index_name(field_name, logical_name)\r\n\u00a0 \u00a0 999 \u00a0 \u00a0 i = table.schema.get_field_index(field_name)\r\n\r\nKeyError: 'b'\r\n```\r\nwhile with pandas 1.4.4 and pyarrow 9.0.0 it works correctly.\u00a0\r\n\r\nNote that the problem disappears if the parquet file is written with index=True (that is not the default value), probably because the RangeIndex is converted to Int64Index:\r\n```java\n\r\ndf1.to_parquet(path, engine=\"pyarrow\", index=True)  \n```\r\nI suspect that the issue is caused by the change from Int64Index to RangeIndex and it may be related to <https://github.com/pandas-dev/pandas/issues/46675>\r\n\r\nShould pyarrow be able to handle this case? Or is it an issue with Pandas?",
        "created_at": "2022-09-21T15:29:19.000Z",
        "updated_at": "2022-09-21T16:19:37.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: Parquet",
            "Component: Python",
            "Type: bug"
        ],
        "closed": false
    },
    "comments": [
        {
            "created_at": "2022-09-21T16:16:49.496Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-17806?focusedCommentId=17607849) by Gianluca Ficarelli (gianluca313):*\nAnother example maybe related, but no exceptions are raised, and the resulting dataframe misses a MultiIndex level in Pandas 1.5.0 (to make the commands work, /tmp/folder00 must already exist):\r\n```java\n\r\nimport pandas as pd\r\nfrom pathlib import Path\r\npath = \"/tmp/folder00/simple_00.parquet\"\r\ndf1 = pd.DataFrame({\"a\": [10, 11, 12], \"b\": [20, 21, 22]}, index=pd.RangeIndex(3, name=\"idx0\"))\r\ndf1 = pd.concat([df1], axis=\"index\", keys=[(100, 200)], names=[\"idx1\", \"idx2\"])\r\nprint(df1)\r\nprint(df1.index.get_level_values(\"idx0\"))\r\ndf1.to_parquet(path, engine=\"pyarrow\", index=None)\r\n\r\npath = \"/tmp/folder00/simple_01.parquet\"\r\ndf1 = pd.DataFrame({\"a\": [30, 31, 32], \"b\": [40, 41, 42]}, index=pd.RangeIndex(3, name=\"idx0\"))\r\ndf1 = pd.concat([df1], axis=\"index\", keys=[(1000, 2000)], names=[\"idx1\", \"idx2\"])\r\ndf1.to_parquet(path, engine=\"pyarrow\", index=None)\r\nprint(df1)\r\nprint(df1.index.get_level_values(\"idx0\"))\r\n \n```\r\nPrinted result with Pandas 1.5.0:\r\n```java\n\r\n                 a   b\r\nidx1 idx2 idx0        \r\n100  200  0     10  20\r\n          1     11  21\r\n          2     12  22\r\nRangeIndex(start=0, stop=3, step=1, name='idx0')\r\n\r\n                 a   b\r\nidx1 idx2 idx0        \r\n1000 2000 0     30  40\r\n          1     31  41\r\n          2     32  42\r\nRangeIndex(start=0, stop=3, step=1, name='idx0')\r\n \n```\r\nThen:\r\n```java\n\r\n# pass the base dir to read and concatenate both the files\r\ndf2 = pd.read_parquet(Path(path).parent, engine=\"pyarrow\")\r\nprint(df2) \n```\r\nresult with pandas 1.5.0 (pyarrow 9.0.0): the resulting dataframe misses the `idx0` level\r\n```java\n\r\n             a   b\r\nidx1 idx2        \r\n100  200   10  20\r\n     200   11  21\r\n     200   12  22\r\n1000 2000  30  40\r\n     2000  31  41\r\n     2000  32  42\r\n```\r\nresult with pandas 1.4.4 (pyarrow 9.0.0): the resulting dataframe is complete\r\n```java\n\r\n \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 a \u00a0 b\r\nidx1 idx2 idx0 \u00a0 \u00a0 \u00a0 \u00a0\r\n100\u00a0 200\u00a0 0 \u00a0 \u00a0 10\u00a0 20\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 1 \u00a0 \u00a0 11\u00a0 21\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2 \u00a0 \u00a0 12\u00a0 22\r\n1000 2000 0 \u00a0 \u00a0 30\u00a0 40\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 1 \u00a0 \u00a0 31\u00a0 41\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2 \u00a0 \u00a0 32\u00a0 42\n```\r\nInstead, reading only a single file:\r\n```java\n\r\ndf2 = pd.read_parquet(path, engine=\"pyarrow\")\r\nprint(df2) \r\ndf2.index.get_level_values(\"idx0\")\n```\r\nworks with both pandas 1.4.4:\r\n```java\n\r\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 a \u00a0 b\r\nidx1 idx2 idx0 \u00a0 \u00a0 \u00a0 \u00a0\r\n1000 2000 0 \u00a0 \u00a0 30\u00a0 40\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 1 \u00a0 \u00a0 31\u00a0 41\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2 \u00a0 \u00a0 32\u00a0 42\r\nInt64Index([0, 1, 2], dtype='int64', name='idx0')\n```\r\nand pandas 1.5.0\r\n```java\n\r\n \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 a \u00a0 b\r\nidx1 idx2 idx0 \u00a0 \u00a0 \u00a0 \u00a0\r\n1000 2000 0 \u00a0 \u00a0 30\u00a0 40\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 1 \u00a0 \u00a0 31\u00a0 41\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2 \u00a0 \u00a0 32\u00a0 42\r\nRangeIndex(start=0, stop=3, step=1, name='idx0')\n```\r\nwith a difference in the type of the index at level idx0."
        }
    ]
}