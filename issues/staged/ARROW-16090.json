{
    "issue": {
        "title": "Unable to connect to flight server in container using self-signed certificate",
        "body": "***Note**: This issue was originally created as [ARROW-16090](https://issues.apache.org/jira/browse/ARROW-16090). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nhi\u00a0\r\n\r\nI'm busy trying to build a python Arrow server on a docker container. The rationale for moving it into a container is to isolate components of my program so if there's an exception/performance issue where something gobbles all the memory I'm able to quickly kill the container without bringing down the entire program.\r\n\r\nI'm having problems connecting a local python script client to the server in the container. I'm not sure if it's a certificate issue /grpc issue/arrow server config issue. Going to break down what I've done below. Any help would be appreciated :)\r\n1. Grabbed the [arrow python server](https://github.com/apache/arrow/tree/master/python/examples/flight) from the github repo.\n1. Since I want to implement secure communication I'll need a certificate - self-signed should be fine for development. Generate development certificate using dotnet dev-certs. After trusting certificate, export it using cmd in windows.\n   \n   ```java\n   \n   dotnet dev-certs https --trust\n   dotnet dev-certs https -ep \"test.pfx\" -p testpassword\n   ```\n   1. My understanding is that the Arrow server only accepts .crt and .key files for public private key. I used WSL and SSL to convert the pfx file using this article from [IBM.](https://www.ibm.com/docs/en/arl/9.7?topic=certification-extracting-certificate-keys-from-pfx-file)\n   \n   2. Placing the public and private key in the same folder as my server script - I adjust the code as follows to not need to pass things in via args.\n   ```java\n   \n   scheme = \"grpc+tls\"        \n   \n   with open(\"testPublicKey.crt\", \"rb\") as cert_file:\n        tls_cert_chain = cert_file.read()        \n   with open(\"testPrivateKey.key\", \"rb\") as key_file:            \n       tls_private_key = key_file.read()        \n   \n   tls_certificates.append((tls_cert_chain, tls_private_key)) \n   ```\n   My client code is a slimmed-down version of the one on the repo as a test I want to push some dummy data into the server.\n   ```java\n   \n   import pyarrow\n   import pyarrow.flight\n   import pandas as pd# Assumes that data is a Dataframe\n   \n   def pushToServer(name, data, client):\n   \u00a0 \u00a0 objectToSend = pyarrow.Table.from_pandas(data)\n   \u00a0 \u00a0 writer, _ = client.do_put(pyarrow.flight.FlightDescriptor.for_path(name), objectToSend.schema)\n   \u00a0 \u00a0 writer.write_table(objectToSend)\n   \u00a0 \u00a0 writer.close()\n   \n   def getClient():\n   \u00a0 \u00a0\u00a0return pyarrow.flight.FlightClient(\"grpc+tcp://localhost:5005\")\n   def main():\n   \u00a0 \u00a0 client = getClient()\n   \u00a0 \u00a0 data = {'Country': ['Belgium', 'India', 'Brazil'],\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'Capital': ['Brussels', 'New Delhi', 'Brasilia'],\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'Population': [11190846, 1303171035, 207847528]}\u00a0 \u00a0 df = pd.DataFrame(data, columns=['Country', 'Capital', 'Population'])\n   \u00a0 \u00a0 pushToServer(\"PredictedValues\", df, client)if __name__ == '__main__':\n   \u00a0 \u00a0 try:\n   \u00a0 \u00a0 \u00a0 \u00a0 main()\n   \u00a0 \u00a0 except Exception as e:\n   \u00a0 \u00a0 \u00a0 \u00a0 print(e) \n   ```\n   3. Running this on my local machine is fine- now I want to move the server into the container. I set up the docker file in the same folder as server script. See below (I know it's not ideal, but it does the job)\n   ```java\n   \n   FROM mcr.microsoft.com/dotnet/sdk\n   EXPOSE 5005\n   COPY server.py /home\n   ```\n   build the image\u00a0 and run the container as below\n   ```java\n   \n   docker build -t test .\n   docker run -it -p 5005:5005 test\n   ```\n   4. In the container, I quickly get python and pyarrow installed and then start the server\n   ```java\n   \n   apt-get update\n   apt-get install python3.10 python3-pip\n   pip install pyarrow\n   //start server time\n   cd home\n   python3 server.py\n   //responds with \"Serving on grpc+tls://localhost:5005\"\n   ```\n   5. Since the ports are mapped when we started the container, I rerun the client on my local and I'm greeted with this error on the client end.\n   ```java\n   \n   gRPC returned unavailable error, with message: failed to connect to all addresses. Client context: IOError: Could not write record batch to stream. Detail: Internal. gRPC client debug context: {\"created\":\"@1648805430.279000000\",\"description\":\"Failed to pick subchannel\",\"file\":\"C:\\vcpkg\\buildtrees\\grpc\\src\\2180080eb4-87c05d756b.clean\\src\\core\\ext\\filters\\client_channel\\client_channel.cc\",\"file_line\":3159,\"referenced_errors\":[{\"created\":\"@1648805430.279000000\",\"description\":\"failed to connect to all addresses\",\"file\":\"C:\\vcpkg\\buildtrees\\grpc\\src\\2180080eb4-87c05d756b.clean\\src\\core\\lib\\transport\\error_utils.cc\",\"file_line\":147,\"grpc_status\":14}]}. Additionally, could not finish writing record batches before closing \n   ```\n   Putting a try-catch on the server-side doesn't provide any more info, unfortunately.\n   \n   I've already ruled out that I might have a dodgy certificate. I've used the same certificate to set up a basic C# kestrel server in a container using HTTPS. I've also tried the above using a C# server with the same issue.\n   \n   Is there any obvious I'm missing in the config? I haven't found any examples where people use certificates with pyarrow, so a bit at a loss.\n   \n   \u00a0\n   \n   \u00a0",
        "created_at": "2022-04-01T10:45:59.000Z",
        "updated_at": "2022-08-27T14:41:48.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: FlightRPC",
            "Component: Python",
            "Type: bug"
        ],
        "closed": true,
        "closed_at": "2022-04-04T13:19:20.000Z"
    },
    "comments": [
        {
            "created_at": "2022-04-01T21:12:54.903Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16090?focusedCommentId=17516129) by David Li (lidavidm):*\nTry binding the server to 0.0.0.0 instead of localhost (I don't see the full server code but that would explain why it works outside the container but not inside, I think, and the Flight example binds to localhost indeed)"
        },
        {
            "created_at": "2022-04-02T01:38:00.088Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16090?focusedCommentId=17516190) by Yibo Cai (yibocai):*\nAgree with David that the localhost inside a container is not accessible from the host.\r\nThat said, I think we should use host network `docker run --net=host ...` (only supported on Linux). The default network goes through iptable NAT for each packet, bad for fast data plane traffic.\r\n<https://docs.docker.com/network/host/>"
        },
        {
            "created_at": "2022-04-04T13:17:57.441Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16090?focusedCommentId=17516810) by Chris Dunderdale (ThatStatsGuy):*\nThank you `[~lidavidm]` (once again) and `[~yibocai]` ! That did the trick."
        },
        {
            "created_at": "2022-08-27T14:41:48.899Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16090?focusedCommentId=17585860) by @toddfarmer:*\nTransitioning issue from Resolved to Closed to based on resolution field value."
        }
    ]
}