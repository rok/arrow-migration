{
    "issue": {
        "title": "[Java] Unable to read IPC file in master",
        "body": "***Note**: This issue was originally created as [ARROW-15144](https://issues.apache.org/jira/browse/ARROW-15144). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nI think that PR https://github.com/apache/arrow/pull/11709 may have caused a regression in reading IPC files.\r\n\r\nAttached is an arrow file that can't be read by the Java implementation, but it can be read by all other implementations. Its contents correspond exactly to the generated_primitive.json.gz used in integration tests.\r\n\r\nBackground:\r\nThe integration CI pipeline in Rust's arrow2 started failing after the PR mentioned above. The logs show that all but the Java implementation are able to consume the attached file (and more generally the files created by arrow2's implementation). The PR broke almost all tests, suggesting that it is not something specific to the file but a broader issue.\r\n\r\nLog: https://pipelines.actions.githubusercontent.com/RJ1isxNgLS0jQX3HKOGkLQjJSEMqOm4RfxnyKHS4o90jAsObvY/_apis/pipelines/1/runs/14655/signedlogcontent/2?urlExpires=2021-12-17T05%3A35%3A25.6055769Z&urlSigningMethod=HMACV1&urlSignature=Nx7nRNdrcUCbtvOnnXAYGDEuSEJUiDT%2BU2jNcqqp%2FEs%3D\r\n\r\nThe logs also suggest that the Java implementation may be leaking memory when such an event happens.\r\n\r\n```java\n\r\n2021-12-16T05:38:33.1575113Z 05:38:33.055 [main] DEBUG org.apache.arrow.vector.ipc.message.ArrowRecordBatch - Buffer in RecordBatch at 5088, length: 2040\r\n2021-12-16T05:38:33.1577399Z 05:38:33.076 [main] ERROR org.apache.arrow.memory.BaseAllocator - Memory was leaked by query. Memory leaked: (8928)\r\n2021-12-16T05:38:33.1578667Z Allocator(ROOT) 0/8928/1771528/2147483647 (res/actual/peak/limit)\r\n2021-12-16T05:38:33.1579193Z \r\n2021-12-16T05:38:33.1579792Z Incompatible files\r\n2021-12-16T05:38:33.1580427Z Different values in column:\r\n2021-12-16T05:38:33.1595138Z bool_nonnullable: Bool not null at index 0: null != false\r\n2021-12-16T05:38:33.1597137Z 05:38:33.078 [main] ERROR org.apache.arrow.tools.Integration - Incompatible files\r\n2021-12-16T05:38:33.1598669Z java.lang.IllegalArgumentException: Different values in column:\r\n2021-12-16T05:38:33.1599788Z bool_nonnullable: Bool not null at index 0: null != false\r\n2021-12-16T05:38:33.1601330Z \tat org.apache.arrow.vector.util.Validator.compareFieldVectors(Validator.java:133)\r\n2021-12-16T05:38:33.1603803Z \tat org.apache.arrow.vector.util.Validator.compareVectorSchemaRoot(Validator.java:107)\r\n2021-12-16T05:38:33.1605836Z \tat org.apache.arrow.tools.Integration$Command$3.execute(Integration.java:209)\r\n2021-12-16T05:38:33.1607342Z \tat org.apache.arrow.tools.Integration.run(Integration.java:119)\r\n2021-12-16T05:38:33.1608817Z \tat org.apache.arrow.tools.Integration.main(Integration.java:70)\r\n2021-12-16T05:38:33.1610327Z \tSuppressed: java.lang.IllegalStateException: Memory was leaked by query. Memory leaked: (8928)\r\n2021-12-16T05:38:33.1611471Z Allocator(ROOT) 0/8928/1771528/2147483647 (res/actual/peak/limit)\r\n2021-12-16T05:38:33.1612372Z \r\n2021-12-16T05:38:33.1613537Z \t\tat org.apache.arrow.memory.BaseAllocator.close(BaseAllocator.java:437)\r\n2021-12-16T05:38:33.1615288Z \t\tat org.apache.arrow.memory.RootAllocator.close(RootAllocator.java:29)\r\n2021-12-16T05:38:33.1616926Z \t\tat org.apache.arrow.tools.Integration$Command$3.$closeResource(Integration.java:228)\r\n2021-12-16T05:38:33.1618454Z \t\tat org.apache.arrow.tools.Integration$Command$3.execute(Integration.java:228)\r\n2021-12-16T05:38:33.1619500Z \t\t... 2 common frames omitted\r\n2021-12-16T05:38:33.1619935Z \r\n2021-12-16T05:38:33.1620598Z --------------\r\n```\r\n\r\nI can't discard the possibility that this is an issue in arrow2 and an undefined issue in the implementation - I am raising it here because all other implementations can read the files.\r\n\r\nFor reference, the offending field (second column, bool_nonnullable), contains the following values buffer:\r\n\r\n```\r\nvalidity buffer: [0, 0, 0, 0, 0, 0, 0, 0]\r\nvalues buffer: [0b11011110, 0b1110010, 0, 0, 0, 0, 0, 0]\r\n```\r\nand the FieldNode has null_count = 0. I would expect this situation to yield an array without null values.\r\n",
        "created_at": "2021-12-17T06:19:58.000Z",
        "updated_at": "2021-12-19T07:37:01.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: Java",
            "Type: bug"
        ],
        "closed": true,
        "closed_at": "2021-12-19T07:37:01.000Z"
    },
    "comments": [
        {
            "created_at": "2021-12-18T17:03:56.609Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15144?focusedCommentId=17461938) by Chao Sun (csun):*\nThanks for the report `[~jorgecarleitao]`! \r\n\r\nThe Java side change assumes that when validity buffer is present, it contains valid content even if null count is 0 (since it wants to reuse the buffer instead of allocating new ones). Looks like this is not the case for the above example?"
        },
        {
            "created_at": "2021-12-19T07:36:49.517Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15144?focusedCommentId=17462094) by Jorge Leit\u00e3o (jorgecarleitao):*\nThanks, `[~csun]`. You are right, I think that that is the correct interpretation of the spec - null count is a hint. Closing as not an issue."
        }
    ]
}