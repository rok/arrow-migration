{
    "issue": {
        "title": "VectorSchemaRoot is not refreshed when value is null",
        "body": "***Note**: This issue was originally created as [ARROW-14549](https://issues.apache.org/jira/browse/ARROW-14549). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nI'm using `arrow-jdbc` to convert query result from JDBC to arrow.\r\n But the following code, unexpected behaivor happens.\r\n\r\nAssuming a sqlite db, the 2nd row of col_2 and col_3 are null.\r\n\n|col_1|col_2|col_3|\r|\n|-|-|-|-|\n|1|abc|3.14|\r|\n|2|NULL|NULL|\r<br>\r<br>As document suggests,\r<br>> populated data over and over into the same VectorSchemaRoot in a stream of batches rather than creating a new VectorSchemaRoot instance each time.\r<br>**JdbcToArrowConfig** is set to reuse root.\r<br>```java<br>\r<br>public void querySql(String query, QueryOption option) throws Exception {\r<br> try (final java.sql.Connection conn = connectContainer.getConnection();\r<br>     final Statement stmt = conn.createStatement();\r<br>     final ResultSet rs = stmt.executeQuery(query)\r<br> ) {\r<br> // create config with reuse schema root and custom batch size from option\r<br>     final JdbcToArrowConfig config = new JdbcToArrowConfigBuilder().setAllocator(new RootAllocator()).setCalendar(JdbcToArrowUtils.getUtcCalendar())\r<br>     .setTargetBatchSize(option.getBatchSize()).setReuseVectorSchemaRoot(true).build();\r<br>\r<br>  final ArrowVectorIterator iterator = JdbcToArrow.sqlToArrowVectorIterator(rs, config);\r<br>   while (iterator.hasNext()){ // retrieve result from iterator \r<br>\u00a0\u00a0\u00a0\u00a0\u00a0final VectorSchemaRoot root = iterator.next(); option.getCallback().handleBatchResult(root); \r<br>     root.allocateNew(); // it has to be allocate new \r<br>\u00a0\u00a0\u00a0}\r<br>  } catch (java.lang.Exception e){ throw new Exception(e.getMessage()); }\r<br> }\r<br> \r<br> ......\r<br> // batch_size is set to 1, then callback is called twice.\r<br> QueryOptions options = new QueryOption(1, \r<br>     root -> {\r<br> // if printer is not set, get schema, write header\r<br> if (printer == null) { \r<br>      final String[] headers = root.getSchema().getFields().stream().map(Field::getName).toArray(String[]::new); \r<br>      printer = new CSVPrinter(writer, CSVFormat.Builder.create(CSVFormat.DEFAULT).setHeader(headers).build()); \r<br>  }\r<br> \r<br> final int rows = root.getRowCount();\r<br> final List<FieldVector> fieldVectors = root.getFieldVectors();\r<br> \r<br> // iterate over rows\r<br> for (int i = 0; i < rows; i++) { \r<br>      final int rowId = i; \r<br>      final List<String> row = fieldVectors.stream().map(v -> v.getObject(rowId)).map(String::valueOf).collect(Collectors.toList()); printer.printRecord(row); \r<br>  }\r<br> });\r<br> \r<br> connection.querySql(\"SELECT * FROM test_db\", options);\r<br> ......\r<br>```\r<br>if `root.allocateNew()` is called, the csv file is expected,\r<br> ```\r<br> column_1,column_2,column_3\r<br> 1,abc,3.14\r<br> 2,null,null\r<br> ```\r<br> Otherwise, null values of 2nd row are remaining the same values of 1st row\r<br> ```\r<br> column_1,column_2,column_3\r<br> 1,abc,3.14\r<br> 2,abc,3.14\r<br> ```\r<br>\r<br>\\***Question: Is expected to call `allocateNew` every time when the schema root is reused?**\\*\r<br>\r<br>By without reusing schemaroot, the following code works as expected.\r<br>```java<br>\r<br> public void querySql(String query, QueryOption option) throws Exception {\r<br> try (final java.sql.Connection conn = connectContainer.getConnection();\r<br>     final Statement stmt = conn.createStatement();\r<br>     final ResultSet rs = stmt.executeQuery(query)) {\r<br>     // create config without reuse schema root and custom batch size from option\r<br>     final JdbcToArrowConfig config = new JdbcToArrowConfigBuilder().setAllocator(new RootAllocator()).setCalendar(JdbcToArrowUtils.getUtcCalendar())\r<br>     .setTargetBatchSize(option.getBatchSize()).setReuseVectorSchemaRoot(false).build();\r<br> \r<br>     final ArrowVectorIterator iterator = JdbcToArrow.sqlToArrowVectorIterator(rs, config);\r<br>     while (iterator.hasNext()) {\r<br>     // retrieve result from iterator\r<br>     try (VectorSchemaRoot root = iterator.next()) { \r<br>          option.getCallback().handleBatchResult(root); root.allocateNew(); \r<br>      }\r<br>   }\r<br> } catch (java.lang.Exception e) { throw new Exception(e.getMessage()); }\r<br>\r<br>}\r<br>\r<br>```|\n",
        "created_at": "2021-11-02T07:45:55.000Z",
        "updated_at": "2022-08-27T14:41:43.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: Java",
            "Type: bug"
        ],
        "closed": true,
        "closed_at": "2022-02-25T18:22:33.000Z"
    },
    "comments": [
        {
            "created_at": "2022-02-25T18:21:49.335Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14549?focusedCommentId=17498249) by Bryan Cutler (bryanc):*\n`[~hu6360567]` Calling `allocateNew()` will create new buffers, which is one way to clear previous results. If you don't want to allocate any new memory, you would need to to zero out all the vectors by calling `zeroVector()` and `setValueCount(0)`. If you don't do either of these, the incorrect data you see is expected."
        },
        {
            "created_at": "2022-08-27T14:41:43.385Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14549?focusedCommentId=17585806) by @toddfarmer:*\nTransitioning issue from Resolved to Closed to based on resolution field value."
        }
    ]
}