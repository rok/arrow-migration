{
    "issue": {
        "title": "[Python] timestamp[ms] and date64 data types not working as expected on write",
        "body": "***Note**: This issue was originally created as [ARROW-8100](https://issues.apache.org/jira/browse/ARROW-8100). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nI expect that either timestamp[ms] or date64 will give me a millisecond presicion datetime/timestamp as written to a parquet file, instead this is the behavior I see:\r\n\r\n`\u00a0`\r\n\r\n>>> arr = pa.array([datetime(2020, 12, 20)])\r\n\r\n(have used pa.array([datetime(2020, 12, 20), type=pa.timestamp('ms')]) with no later casting as well)\r\n\r\n>>> arr.cast(pa.timestamp('ms'), safe=False)\r\n\r\n<pyarrow.lib.TimestampArray object at 0x117f3d4c8>\r\n [\r\n 2020-12-20 00:00:00.000\r\n ]\r\n\r\n\u00a0\r\n\r\n>>> table = pa.Table.from_arrays([arr],\r\n\r\n`\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 names=[\"start_date\"])`\r\n\r\n`>>> table`\r\n pyarrow.Table\r\n start_date: timestamp[us]\r\n\r\n\u00a0\r\n\r\n`// just to make sure`\r\n\r\n\u00a0\r\n\r\n`>>> table.column(\"start_date\").cast(pa.timestamp('ms'), safe=False)`\r\n <pyarrow.lib.ChunkedArray object at 0x117f5e9a8>\r\n [\r\n [\r\n 2020-12-20 00:00:00.000\r\n ]\r\n ]\r\n\r\n\u00a0\r\n\r\n`// just to make extra sure`\r\n\r\n\u00a0\r\n\r\n`>>> schema = pa.schema([pa.field(\"start_date\", pa.timestamp(\"ms\"))])`\r\n\r\n>>> table.cast(schema, safe=False)parquet.write_table(table,\r\n\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"sldkfjasldkfj.parquet\",\u00a0\u00a0\r\n\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0coerce_timestamps=\"ms\",\u00a0\r\n\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 compression=\"SNAPPY\",\u00a0\r\n\r\n`\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 allow_truncated_timestamps=True)`\r\n\r\nResult for the written file:\r\n\r\nSchema:\r\n\r\n{\r\n \"type\" : \"record\",\r\n \"name\" : \"schema\",\r\n \"fields\" : [ {\r\n \"name\" : \"start_date\",\r\n \"type\" : [ \"null\",\r\n\r\n{ \"type\" : \"long\", \"logicalType\" : \"timestamp-millis\" }\r\n\r\n],\r\n \"default\" : null\r\n } ]\r\n }\r\n\r\nData:\r\n\n|start_date|\u00a0|\r|\n|-|-|-|\n|1608422400000|\u00a0|\r<br>\r<br>\u00a0\r<br>\r<br>that is a microsecond [us] value, despite casting to [ms] and setting the appropriate config on the write_table method. If it was a millisecond timestamp it would be accurate to translate back to a datetime with fromtimestamp, but:\r<br> >>> from datetime import datetime\r<br> >>>\r<br> >>>\r<br> >>>\r<br> >>>\r<br> >>> datetime.fromtimestamp(1608422400000)\r<br> Traceback (most recent call last):\r<br> File \"<stdin>\", line 1, in <module>\r<br> ValueError: year 52938 is out of range\r<br> >>> datetime.fromtimestamp(1608422400000 /1000)\r<br> datetime.datetime(2020, 12, 19, 16, 0)\r<br> \u00a0\r<br>\r<br>\u00a0\r<br>\r<br>Ok, so then we should use date64() type, after all the docs say **_Create instance of 64-bit date (milliseconds since UNIX epoch 1970-01-01)_**\r<br>\r<br>\u00a0\r<br> >>> arr = pa.array([datetime(2020, 12, 20, 0, 0, 0, 123)], type=pa.date64())\r<br> >>> arr\r<br> <pyarrow.lib.Date64Array object at 0x11da877c8>\r<br> [\r<br> 2020-12-20\r<br> ]\r<br>\r<br>>>> table = pa.Table.from_arrays([arr], names=[\"start_date\"])\r<br> >>> table\r<br> pyarrow.Table\r<br>\r<br>start_date: date64[ms]\r<br>\r<br>parquet.write_table(table,\r<br>\r<br>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\"bebedabeep.parquet\",\r<br>\r<br>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 coerce_timestamps=\"ms\",\r<br>\r<br>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 compression=\"SNAPPY\",\r<br>\r<br>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 allow_truncated_timestamps=True)\r<br>\r<br>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\r<br> \u00a0\r<br>\r<br>Result for the written file:\r<br>\r<br>Schema:\r<br>\r<br>{\r<br> \"type\" : \"record\",\r<br> \"name\" : \"schema\",\r<br> \"fields\" : [ {\r<br> \"name\" : \"start_date\",\r<br> \"type\" : [ \"null\",\r<br>\r<br>{ \"type\" : \"int\", \"logicalType\" : \"date\" }\r<br>\r<br>],\r<br> \"default\" : null\r<br> } ]\r<br> }\r<br>\r<br>Data:\r<br>\r<br>\u00a0\r|\n|start_date|\u00a0|\r|\n|18616|\u00a0|\r<br>\r<br>\u00a0\r<br> That is \"days since UNIX epoch 1970-01-01\" just like date32() type, the time info is stripped off, we can confirm this:\r<br> >>> arr.to_pylist()\r<br> [datetime.date(2020, 12, 20)]\r<br> \u00a0\r<br>\r<br>How do I write a millisecond precision timestamp with pyarrow.parquet?|\n",
        "created_at": "2020-03-12T19:54:30.000Z",
        "updated_at": "2020-03-13T02:25:55.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: Python",
            "Type: bug"
        ],
        "closed": true,
        "closed_at": "2020-03-13T01:58:41.000Z"
    },
    "comments": [
        {
            "created_at": "2020-03-12T22:49:37.940Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-8100?focusedCommentId=17058282) by Wes McKinney (wesm):*\nUsing https://www.unixtimestamp.com/ I am told that the timestamp \"1608422400\" is 12/20/2020. \r\n\r\nI see also\r\n\r\n```Java\n\r\n>>> datetime.datetime.utcfromtimestamp(1608422400)\r\ndatetime.datetime(2020, 12, 20, 0, 0)\r\n```\r\n\r\nI think you need to be using `utcfromtimestamp` (assumes a UTC framing) instead of `fromtimestamp` (which uses the system locale time zone to convert)."
        },
        {
            "created_at": "2020-03-13T00:36:46.293Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-8100?focusedCommentId=17058315) by paul hess (phess):*\nYou are correct `[~wesm]` \u00a0I should have used utcfromtimestamp in my example. The offset difference is not the issue I am trying to present however, the issue is that the output is not 1608422400 but\u00a01608422400000 which is not the expected millisecond precision timestamp but the microsecond precision\r\n\r\n\u00a0\r\n\r\nData:\r\n\n|start_date|\r|\n|-|-|\n|1608422400000|\r<br>\r<br>\u00a0\r<br>\r<br>>>> from datetime import datetime\r<br>>>> datetime.utcfromtimestamp(1608422400000)\r<br>Traceback (most recent call last):\r<br> File \"<stdin>\", line 1, in <module>\r<br>ValueError: year is out of range|\n"
        },
        {
            "created_at": "2020-03-13T01:50:21.075Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-8100?focusedCommentId=17058344) by Wes McKinney (wesm):*\n`utcfromtimestamp` accepts a POSIX timestamp which is in second resolution, so you have to divide milliseconds by 1000. \r\n\r\n```Java\n\r\n\r\nIn [1]: arr = pa.array([1608422400000], type='int64')                          \r\n\r\nIn [2]: arr                                                                    \r\nOut[2]: \r\n<pyarrow.lib.Int64Array object at 0x7f054971b440>\r\n[\r\n  1608422400000\r\n]\r\n\r\nIn [3]: arr.cast(pa.timestamp('ms'))                                           \r\nOut[3]: \r\n<pyarrow.lib.TimestampArray object at 0x7f05497724b0>\r\n[\r\n  2020-12-20 00:00:00.000\r\n]\r\n\r\nIn [4]: arr.cast(pa.timestamp('ms'))[0]                                        \r\nOut[4]: datetime.datetime(2020, 12, 20, 0, 0)\r\n```"
        },
        {
            "created_at": "2020-03-13T01:58:41.559Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-8100?focusedCommentId=17058349) by Wes McKinney (wesm):*\nClosing. The current UNIX time (in seconds) on my machine is\r\n\r\n```Java\n\r\n$ date +%s\r\n1584064589\r\n```\r\n\r\nIn milliseconds it's 1584064589000. That's the same number of\r\ndigits as 1608422400000"
        },
        {
            "created_at": "2020-03-13T02:25:55.995Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-8100?focusedCommentId=17058361) by paul hess (phess):*\nThis is my fault, I thought that UNIX/POSIX was milliseconds since epoch not seconds, I need to use pa.timestamp('s').\r\n\r\nThank you. closing this"
        }
    ]
}