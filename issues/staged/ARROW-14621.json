{
    "issue": {
        "title": "[Python] read_feather's \"columns\" argument claims to support any iterable but does not accept pandas series",
        "body": "***Note**: This issue was originally created as [ARROW-14621](https://issues.apache.org/jira/browse/ARROW-14621). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nFrom https://github.com/apache/arrow/issues/11500:\r\n\r\n> According to the read_feather documentation it accepts any sequence type ( https://arrow.apache.org/docs/python/generated/pyarrow.feather.read_feather.html ) so not strictly lists, but also tuples etc... As far as they contain int or str.\n> \n> While a pandas.Index adheres to the sequence protocol it provides custom implementation of many methods you would expect in a container. I personally think that supporting all possible implementations of classes that adheres to sequence protocol even when they are heavily custom is probably out of scope, so I would personally change the docstring to mention list|tuple and avoid confusion.\n> \n> Implementing support for pandas.Index is fairly quick but that would probably end up casting the index to a tuple or list if we want to keep the code generic. And that would mean introducing an extra cost that the user doesn't know it's paying when invoking that method. I guess it's more reasonable to make that cost explicit and have user cast to list or tuple\r\n`[~amol-]`\r\n\r\n> Technically the sequence protocol does not define equality. The problem seems to originate from the line sorted(set(columns)) == columns. We are relying on list == sequence => bool which is not valid when the sequence is a numpy array (list == np.ndarray => np.ndarray).\n> \n> The correct method for comparing sequences seems to be converting both sides to list or using imap (although given we are already doing sorted(set(columns)) I think imap would be overkill).\n> \n> I'm in favor of @amol- 's general point though. Changing the docs to mention list|tuple is probably a good solution.\r\n`[~westonpace]`\r\n\r\n> On the other hand, supporting numpy arrays for those kind of arguments that expect a list is also relatively easy. We have quite some other methods that document a certain argument as list, while still accepting a numpy array (because in most cases we just rely on 1) length check and 2) iteration through the values).\n> \n> I think the most important would be to have consistency. But if we have some APIs that are currently strict on requiring a list, and others loose on requiring any iterable, then there are two options: make everything strict, or fix those cases that are now strict to have them work with any iterable.\n> But to me it would also feel strange to start adding strict isinstance(.., list) checks in several places that currently are perfectly fine with accepting a numpy array or any iterable ...\r\n`[~jorisvandenbossche]`",
        "created_at": "2021-11-06T02:20:57.000Z",
        "updated_at": "2021-11-09T15:14:18.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: Python",
            "Type: bug"
        ],
        "closed": false
    },
    "comments": [
        {
            "created_at": "2021-11-09T15:13:28.234Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14621?focusedCommentId=17441215) by Joris Van den Bossche (jorisvandenbossche):*\nProposal: coerce arguments that accept a list-like to list (`list(...)`) where needed (so where not just iterating through the object).  For example for the read_feather case that triggered this issue.\r\n\r\nThat seems more generally useful and cleaner (compared to eg explicitly starting to check for list as argument type)"
        }
    ]
}