{
    "issue": {
        "title": "[C++][Parquet] Writing DictionaryArrays with ExtensionType to Parquet",
        "body": "***Note**: This issue was originally created as [ARROW-14525](https://issues.apache.org/jira/browse/ARROW-14525). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nThanks to some help I got from `[~jorisvandenbossche]`, I can create DictionaryArrays with ExtensionType (on just the dictionary, the dictionary array itself, or both). However, these extended-DictionaryArrays can't be written to Parquet files.\r\n\r\nTo start, let's set up my minimal reproducer ExtensionType, this time with an explicit ExtensionArray:\r\n```python\n\r\n>>> import json\r\n>>> import numpy as np\r\n>>> import pyarrow as pa\r\n>>> import pyarrow.parquet\r\n>>> \r\n>>> class AnnotatedArray(pa.ExtensionArray):\r\n...     pass\r\n... \r\n>>> class AnnotatedType(pa.ExtensionType):\r\n...     def __init__(self, storage_type, annotation):\r\n...         self.annotation = annotation\r\n...         super().__init__(storage_type, \"my:app\")\r\n...     def __arrow_ext_serialize__(self):\r\n...         return json.dumps(self.annotation).encode()\r\n...     @classmethod\r\n...     def __arrow_ext_deserialize__(cls, storage_type, serialized):\r\n...         annotation = json.loads(serialized.decode())\r\n...         return cls(storage_type, annotation)\r\n...     def __arrow_ext_class__(self):\r\n...         return AnnotatedArray\r\n... \r\n>>> pa.register_extension_type(AnnotatedType(pa.null(), None))\r\n```\r\nA non-extended DictionaryArray could be built like this:\r\n```python\n\r\n>>> dictarray = pa.DictionaryArray.from_arrays(\r\n...     np.array([3, 2, 2, 2, 0, 1, 3], np.int32),\r\n...     pa.Array.from_buffers(\r\n...         pa.float64(),\r\n...         4,\r\n...         [\r\n...             None,\r\n...             pa.py_buffer(np.array([0.0, 1.1, 2.2, 3.3])),\r\n...         ],\r\n...     ),\r\n... )\r\n>>> dictarray\r\n<pyarrow.lib.DictionaryArray object at 0x7f8c71f593c0>\r\n\r\n-- dictionary:\r\n  [\r\n    0,\r\n    1.1,\r\n    2.2,\r\n    3.3\r\n  ]\r\n-- indices:\r\n  [\r\n    3,\r\n    2,\r\n    2,\r\n    2,\r\n    0,\r\n    1,\r\n    3\r\n  ]\r\n```\r\nI can write it to a file and read it back, though the fact that it comes back as a non-DictionaryArray might be part of the problem. Is some decision being made about the array of indices being too short to warrant dictionary encoding?\r\n```python\n\r\n>>> pa.parquet.write_table(pa.table({\"\": dictarray}), \"tmp.parquet\")\r\n>>> pa.parquet.read_table(\"tmp.parquet\")\r\npyarrow.Table\r\n: double\r\n----\r\n: [[3.3,2.2,2.2,2.2,0,1.1,3.3]]\r\n```\r\nAnyway, the next step is to make a DictionaryArray with ExtensionTypes. In this example, I'm making both the dictionary and the outer DictionaryArray itself be extended:\r\n```python\n\r\n>>> dictionary_type = AnnotatedType(pa.float64(), \"inner annotation\")\r\n>>> dictarray_type = AnnotatedType(\r\n...     pa.dictionary(pa.int32(), dictionary_type), \"outer annotation\"\r\n... )\r\n>>> dictarray_ext = AnnotatedArray.from_storage(\r\n...     dictarray_type,\r\n...     pa.DictionaryArray.from_arrays(\r\n...         np.array([3, 2, 2, 2, 0, 1, 3], np.int32),\r\n...         pa.Array.from_buffers(\r\n...             dictionary_type,\r\n...             4,\r\n...             [\r\n...                 None,\r\n...                 pa.py_buffer(np.array([0.0, 1.1, 2.2, 3.3])),\r\n...             ],\r\n...         ),\r\n...     )\r\n... )\r\n>>> dictarray_ext\r\n<__main__.AnnotatedArray object at 0x7f8c71ec7ee0>\r\n\r\n-- dictionary:\r\n  [\r\n    0,\r\n    1.1,\r\n    2.2,\r\n    3.3\r\n  ]\r\n-- indices:\r\n  [\r\n    3,\r\n    2,\r\n    2,\r\n    2,\r\n    0,\r\n    1,\r\n    3\r\n  ]\r\n```\r\nThis can't be written to a Parquet file:\r\n```python\n\r\n>>> pa.parquet.write_table(pa.table({\"\": dictarray_ext}), \"tmp2.parquet\")\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"/home/jpivarski/miniconda3/lib/python3.9/site-packages/pyarrow/parquet.py\", line 2034, in write_table\r\n    writer.write_table(table, row_group_size=row_group_size)\r\n  File \"/home/jpivarski/miniconda3/lib/python3.9/site-packages/pyarrow/parquet.py\", line 701, in write_table\r\n    self.writer.write_table(table, row_group_size=row_group_size)\r\n  File \"pyarrow/_parquet.pyx\", line 1451, in pyarrow._parquet.ParquetWriter.write_table\r\n  File \"pyarrow/error.pxi\", line 120, in pyarrow.lib.check_status\r\npyarrow.lib.ArrowNotImplementedError: Unsupported cast from dictionary<values=extension<my:app<AnnotatedType>>, indices=int32, ordered=0> to extension<my:app<AnnotatedType>> (no available cast function for target type)\r\n```\r\nMy first thought was maybe the data used in the dictionary must be simple (it's usually strings). So how about making the outer DictionaryArray extended, but the inner dictionary not extended? The type definitions are now inline.\r\n```python\n\r\n>>> dictarray_partial = AnnotatedArray.from_storage(\r\n...     AnnotatedType(          # extended, but the content is not\r\n...         pa.dictionary(pa.int32(), pa.float64()), \"only annotation\"\r\n...     ),\r\n...     pa.DictionaryArray.from_arrays(\r\n...         np.array([3, 2, 2, 2, 0, 1, 3], np.int32),\r\n...         pa.Array.from_buffers(\r\n...             pa.float64(),   # not extended\r\n...             4,\r\n...             [\r\n...                 None,\r\n...                 pa.py_buffer(np.array([0.0, 1.1, 2.2, 3.3])),\r\n...             ],\r\n...         ),\r\n...     )\r\n... )\r\n>>> dictarray_partial\r\n<__main__.AnnotatedArray object at 0x7f8c71ee5100>\r\n\r\n-- dictionary:\r\n  [\r\n    0,\r\n    1.1,\r\n    2.2,\r\n    3.3\r\n  ]\r\n-- indices:\r\n  [\r\n    3,\r\n    2,\r\n    2,\r\n    2,\r\n    0,\r\n    1,\r\n    3\r\n  ]\r\n```\r\nI can write this, but it comes back as a non-extended type, maybe because it's a non-DictionaryArray with the type of the original's dictionary (non-extended).\r\n```python\n\r\n>>> pa.parquet.write_table(pa.table({\"\": dictarray_partial}), \"tmp3.parquet\")\r\n>>> pa.parquet.read_table(\"tmp3.parquet\")\r\npyarrow.Table\r\n: double\r\n----\r\n: [[3.3,2.2,2.2,2.2,0,1.1,3.3]]\r\n```\r\nOkay, since there's four possibilities here, what about making the dictionary an ExtensionType, but the outer DictionaryArray is not?\r\n```python\n\r\n>>> dictarray_other = pa.DictionaryArray.from_arrays(\r\n...     np.array([3, 2, 2, 2, 0, 1, 3], np.int32),\r\n...     pa.Array.from_buffers(\r\n...         AnnotatedType(pa.float64(), \"only annotation\"),\r\n...         4,\r\n...         [\r\n...             None,\r\n...             pa.py_buffer(np.array([0.0, 1.1, 2.2, 3.3])),\r\n...         ],\r\n...     )\r\n... )\r\n>>> dictarray_other\r\n<pyarrow.lib.DictionaryArray object at 0x7f8c71ee62e0>\r\n\r\n-- dictionary:\r\n  [\r\n    0,\r\n    1.1,\r\n    2.2,\r\n    3.3\r\n  ]\r\n-- indices:\r\n  [\r\n    3,\r\n    2,\r\n    2,\r\n    2,\r\n    0,\r\n    1,\r\n    3\r\n  ]\r\n```\r\nNope, can't write this, either:\r\n```python\n\r\n>>> pa.parquet.write_table(pa.table({\"\": dictarray_other}), \"tmp4.parquet\")\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"/home/jpivarski/miniconda3/lib/python3.9/site-packages/pyarrow/parquet.py\", line 2034, in write_table\r\n    writer.write_table(table, row_group_size=row_group_size)\r\n  File \"/home/jpivarski/miniconda3/lib/python3.9/site-packages/pyarrow/parquet.py\", line 701, in write_table\r\n    self.writer.write_table(table, row_group_size=row_group_size)\r\n  File \"pyarrow/_parquet.pyx\", line 1451, in pyarrow._parquet.ParquetWriter.write_table\r\n  File \"pyarrow/error.pxi\", line 120, in pyarrow.lib.check_status\r\npyarrow.lib.ArrowNotImplementedError: Unsupported cast from dictionary<values=extension<my:app<AnnotatedType>>, indices=int32, ordered=0> to extension<my:app<AnnotatedType>> (no available cast function for target type)\r\n```\r\nI'm pretty sure I aligned all the types right. Perhaps only one of these cases should be supported as the way it ought to work, but there ought to be some way to get the annotations into a Parquet file and read them back. (Other than un-dictencoding the array.)",
        "created_at": "2021-10-30T00:27:55.000Z",
        "updated_at": "2022-02-03T10:09:17.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: Python",
            "Type: bug"
        ],
        "closed": false
    },
    "comments": [
        {
            "created_at": "2021-11-05T09:23:39.925Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14525?focusedCommentId=17439117) by Joris Van den Bossche (jorisvandenbossche):*\n> This can't be written to a Parquet file:\r\n\r\nSimilarly as `[~lidavidm]` mentioned in ARROW-14569, it seems we need to implement a cast from dictionary<extension> to extension.\r\n\r\nNow, the reason this is needed for Parquet is that, currently, only dictionary with string/binary type is supported to be stored as is in Parquet. All other dictionary types are stored as materialized values (still with some parquet encoding of course, but not necessarily using dictionary encoding, or at least not directly writing/reading from/to arrow's dictionary type to parquet dictionary encoding without additional conversion). See ARROW-6140"
        }
    ]
}