{
    "issue": {
        "title": "[C++] [R] [Datasets] aggregates on partitioning columns",
        "body": "***Note**: This issue was originally created as [ARROW-16700](https://issues.apache.org/jira/browse/ARROW-16700). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nWhen summarizing a whole dataset (without group_by) with an aggregate, and summarizing a partitioned column, arrow returns wrong data:\r\n\r\n```r\n\r\nlibrary(arrow, warn.conflicts = FALSE)\r\nlibrary(dplyr, warn.conflicts = FALSE)\r\n\r\ndf <- expand.grid(\r\n  some_nulls = c(0L, 1L, 2L),\r\n  year = 2010:2023,\r\n  month = 1:12,\r\n  day = 1:30\r\n)\r\n\r\npath <- tempfile()\r\ndir.create(path)\r\nwrite_dataset(df, path, partitioning = c(\"year\", \"month\"))\r\n\r\nds <- open_dataset(path)\r\n\r\n# with arrow the mins/maxes are off for partitioning columns\r\nds %>%\r\n  summarise(n = n(), min_year = min(year), min_month = min(month), min_day = min(day), max_year = max(year), max_month = max(month), max_day = max(day)) %>% \r\n  collect()\r\n#> # A tibble: 1 \u00d7 7\r\n#>       n min_year min_month min_day max_year max_month max_day\r\n#>   <int>    <int>     <int>   <int>    <int>     <int>   <int>\r\n#> 1 15120     2023         1       1     2023        12      30\r\n\r\n# comapred to what we get with dplyr\r\ndf %>%\r\n  summarise(n = n(), min_year = min(year), min_month = min(month), min_day = min(day), max_year = max(year), max_month = max(month), max_day = max(day)) %>% \r\n  collect()\r\n#>       n min_year min_month min_day max_year max_month max_day\r\n#> 1 15120     2010         1       1     2023        12      30\r\n\r\n# even min alone is off:\r\nds %>%\r\n  summarise(min_year = min(year)) %>% \r\n  collect()\r\n#> # A tibble: 1 \u00d7 1\r\n#>   min_year\r\n#>      <int>\r\n#> 1     2016\r\n  \r\n# but non-partitioning columns are fine:\r\nds %>%\r\n  summarise(min_day = min(day)) %>% \r\n  collect()\r\n#> # A tibble: 1 \u00d7 1\r\n#>   min_day\r\n#>     <int>\r\n#> 1       1\r\n  \r\n  \r\n# But with a group_by, this seems ok\r\nds %>%\r\n  group_by(some_nulls) %>%\r\n  summarise(min_year = min(year)) %>% \r\n  collect()\r\n#> # A tibble: 3 \u00d7 2\r\n#>   some_nulls min_year\r\n#>        <int>    <int>\r\n#> 1          0     2010\r\n#> 2          1     2010\r\n#> 3          2     2010\r\n```",
        "created_at": "2022-05-31T20:08:39.000Z",
        "updated_at": "2022-10-03T15:32:54.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Component: R",
            "Type: bug"
        ],
        "closed": true,
        "closed_at": "2022-07-22T16:24:41.000Z"
    },
    "comments": [
        {
            "created_at": "2022-06-29T21:32:01.299Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16700?focusedCommentId=17560667) by Jonathan Keane (jonkeane):*\n`[~westonpace]` not sure if this is related to ARROW-16904 or ARROW-16807 but another wrong-data ticket we should take a look at"
        },
        {
            "created_at": "2022-07-01T00:18:59.448Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16700?focusedCommentId=17561218) by Weston Pace (westonpace):*\nSo the root cause here is how partition columns are handed to the exec plan.  In the datasets API a partitioning doesn't necessarily yield a single value for a batch, but rather an expression.\r\n\r\nFor example, the folder `/foo=7/chunk-0.parquet` will yield the expression `foo == 7` instead of the value `foo:7`.  This allow for rather novel partitioning schemes like `/temp=med/chunk-0.parquet` which could attach the expression `25 < temp < 75`.\r\n\r\nUnfortunately, this cleverness cannot really be utilized by the execution engine.  For example, how does one resolve the query `SELECT \\* FROM measurements WHERE temp == 50` when all they know for a batch is `25 < temp < 75`.\r\n\r\nAt the moment, these expressions are attached to the incoming batch as a \"guarantee\".  In addition, we also add a new column to the batch (e.g. `foo` or `temp`).  However, no value is ever set on this column and so it ends up getting set implicitly to `NULL`.  This guarantee is then used by project and filter nodes to simplify an expression.\r\n\r\nThis is why the query `SELECT foo from dataset WHERE foo == 7` works.  The expression `foo == 7` gets simplified by the guarantee (`foo ==7`) to `true` and so the row is included (even though the value of the row is null).  The projection `field_ref('foo')` gets simplified to `scalar(7)` and so the underlying array (which is full of nulls) is not looked at.\r\n\r\nHowever, aggregate nodes do not simplify with a guarantee.  So, instead, they see the raw underlying value (null) and it doesn't get processed correctly by the aggregate node.\r\n\r\nOne quick fix would be to get rid of the guarantee concept entirely.  When we have an incoming partition expression we should:\r\n\r\n \\* If the expression is an equality we replace it with a scalar.\r\n \\* If the expression is not an equality we raise an error."
        },
        {
            "created_at": "2022-07-01T00:19:26.595Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16700?focusedCommentId=17561219) by Weston Pace (westonpace):*\nCC `[~bkietz]` for second opinion"
        },
        {
            "created_at": "2022-07-04T14:06:26.452Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16700?focusedCommentId=17562191) by Jeroen van Straten (jvanstraten):*\ntl;dr it looks like min/max itself is broken and only aggregates only the last partition it sees (in each thread); every Consume call casually ignores and overrides this->state. Extraordinary claims demand extraordinary evidence, especially since I only started looking at Acero in-depth and installed R about five hours ago, so here's my complete analysis for posterity...\r\n\r\n> For example, how does one resolve the query `SELECT * FROM measurements WHERE temp == 50` when all they know for a batch is `{}25 < temp < 75{`}.\r\n\r\nI would assume that in the case of a guarantee like `25 < temp < 75` the column `temp` is not optimized out of the physical schema as it would be for `{}temp = 50{`}, otherwise the data simply isn't there anymore. So, I don't see how\r\n\r\n> However, no value is ever set on this column and so it ends up getting set implicitly to `{}NULL{`}.\r\n\r\nwould apply in this case, and would expect that aggregation would work correctly under those circumstances. But I'm not sure how to verify this.\r\n\r\nIf above assessment is true, it seems to me that the problem is that either:\r\n \\* \"trivial\" guarantees aren't respected consistently throughout Acero, which is invalid because columns may already have been optimized out of the physical schema under the assumption that all values are known via the guarantee; or\r\n \\* if you take the [this](https://github.com/apache/arrow/blob/897a4c0ce73c3fe07872beee2c1d2128e44f6dd4/cpp/src/arrow/compute/exec.h#L201) description of ExecBatch::guarantee at face value, the problem is that the guarantee doesn't actually evaluate to true at all in this case, because the columns it asserts a constant value for are in fact optimized out and would thus evaluate to null. This conflicts with [the way Scanner deals with guarantees](https://github.com/apache/arrow/blob/897a4c0ce73c3fe07872beee2c1d2128e44f6dd4/cpp/src/arrow/dataset/scanner.cc#L911-L914), though.\r\n\r\nPut differently, different parts of the codebase seem to treat `guarantee` in two incompatible ways (at least according to the comments).\r\n\r\nLooking through the code I don't see _any_ mention of guarantees in nodes other than filter and project, so I would expect all nodes to fail on this, _unless_ they end up following a projection node, which would materialize the columns based on the expressions derived from the guarantee. It looks like the group-by example only works because a projection is inserted in that case:\r\n```java\n\r\n 5:SinkNode{}\r\n  4:ProjectNode{projection=[some_nulls, min_year]}\r\n    3:ProjectNode{projection=[some_nulls, min_year]}\r\n      2:GroupByNode{keys=[\"some_nulls\"], aggregates=[\r\n      \thash_min(min_year, {skip_nulls=false, min_count=0}),\r\n      ]}\r\n        1:ProjectNode{projection=[\"min_year\": year, some_nulls]}\r\n          0:SourceNode{}\r\n```\r\n... but something isn't adding up for the failing case, because I'm getting:\r\n```java\n\r\n4:SinkNode{}\r\n  3:ProjectNode{projection=[n, min_year, min_month, min_day, max_year, max_month, max_day]}\r\n    2:ScalarAggregateNode{aggregates=[\r\n\tsum(n, {skip_nulls=true, min_count=1}),\r\n\tmin(min_year, {skip_nulls=false, min_count=0}),\r\n\tmin(min_month, {skip_nulls=false, min_count=0}),\r\n\tmin(min_day, {skip_nulls=false, min_count=0}),\r\n\tmax(max_year, {skip_nulls=false, min_count=0}),\r\n\tmax(max_month, {skip_nulls=false, min_count=0}),\r\n\tmax(max_day, {skip_nulls=false, min_count=0}),\r\n]}\r\n      1:ProjectNode{projection=[\"n\": 1, \"min_year\": year, \"min_month\": month, \"min_day\": day, \"max_year\": year, \"max_month\": month, \"max_day\": day]}\r\n        0:SourceNode{}\r\n```\r\nIn fact, judging by the input and output of 1:ProjectNode in either case, it looks like it'd be difficult to make a plan that doesn't need one, since it would normally at least get rid of the fragment source information.\r\n\r\nAnd indeed, if I spam sufficient debug output, I see that 1:ProjectNode _is_ indeed materializing the columns accordingly, and 2:ScalarAggregateNode _is_ actually getting completely-materialized inputs passed to InputReceived. Hmmm...\r\n\r\nSome more debug prints and clicking through code later I find that the bad minima and maxima are originating from [here](https://github.com/apache/arrow/blob/897a4c0ce73c3fe07872beee2c1d2128e44f6dd4/cpp/src/arrow/compute/kernels/aggregate_basic_internal.h#L440-L451). Each partition corresponds to its own call. I expected something to be subtly wrong here, but it doesn't appear to be subtle at all: local is created [here](https://github.com/apache/arrow/blob/897a4c0ce73c3fe07872beee2c1d2128e44f6dd4/cpp/src/arrow/compute/kernels/aggregate_basic_internal.h#L440) and is later used to override this->state [here](https://github.com/apache/arrow/blob/897a4c0ce73c3fe07872beee2c1d2128e44f6dd4/cpp/src/arrow/compute/kernels/aggregate_basic_internal.h#L445) or [here](https://github.com/apache/arrow/blob/897a4c0ce73c3fe07872beee2c1d2128e44f6dd4/cpp/src/arrow/compute/kernels/aggregate_basic_internal.h#L450), without any reference to the previous value of this->state! I suppose what those `this->state = local` lines _should_ read is `this->state \\+= local`, since operator+= is overloaded for combining states, so that's what I'll make a PR for.\r\n\r\nThe issue Weston pointed out _may_ still be an issue after that though, just a far less likely one to hit (if it's possible at all) because of how likely it is that a project node will be placed immediately after a scan node. So I guess there should be a followup issue for that?"
        },
        {
            "created_at": "2022-07-05T15:28:33.703Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16700?focusedCommentId=17562721) by Weston Pace (westonpace):*\n> tl;dr it looks like min/max itself is broken and only aggregates only the last partition it sees (in each thread); every Consume call casually ignores and overrides this->state. Extraordinary claims demand extraordinary evidence, especially since I only started looking at Acero in-depth and installed R about five hours ago, so here's my complete analysis for posterity...\r\n\r\nYes, min/max is broken in the way you describe.  This is captured in ARROW-16904.  `[~octalene]` is working on updating the unit tests so that we can reproduce this issue correctly.  Sorry, I hadn't realized this JIRA also involved a min/max and I hadn't realized the project workaround you mentioned.  However, that is excellent analysis.\r\n\r\nYou are correct that a project node would fix this issue.  However, a project node isn't normally inserted immediately after a scan node.  In fact, what is happening here, is that R always inserts a project node immediately _before_ an aggregate node.  Either way, that is a pretty significant workaround, as the project & filter nodes are already satisfied by the guarantee.\r\n\r\nStill, I'd like to leave this issue in place for the moment, though maybe it doesn't need to be a blocker.  Future Substrait queries would, in theory, be able to create plans without the preceding project node.  At some point the scan node will not emit these columns unless they are asked for so I don't think a project to satisfy the column-dropping emit will always be necessary either."
        },
        {
            "created_at": "2022-07-05T15:56:41.250Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16700?focusedCommentId=17562732) by Jeroen van Straten (jvanstraten):*\nSo I guess that basically means that my PR is linked to the wrong issue? I'm not sure how to neatly resolve that, at least not without closing my PR and waiting for `[~octalene]` \u00a0to fix min/max (and test it appropriately) instead.\r\n\r\nFor the guarantee issue that remains, I'm inclined to place the blame on Scanner rather than all the nodes other than filter and project, and to just insert the code for a trivial projection into Scanner to leverage the existing SimplifyWithGuarantee implementation. I'm assuming that an expression that only selects an existing field will just result in a pointer copy, and that evaluating a literal expression to a scalar is also cheap (at least if the literal isn't massive). What do you think?\r\n\r\n> Future Substrait queries would, in theory, be able to create plans without the preceding project node.\r\n\r\nI'm not 100% sure on that one because of the tag fields that Scanner normally adds, which Substrait wouldn't know about. It feels fragile to leave them in because I imagine they would affect column indices after a join if not treated carefully. But I get your point."
        },
        {
            "created_at": "2022-07-05T17:05:21.346Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16700?focusedCommentId=17562762) by Weston Pace (westonpace):*\n> So I guess that basically means that my PR is linked to the wrong issue? I'm not sure how to neatly resolve that\r\n\r\nI think you just need to update the title of the PR.  I'm not sure if that removes the linkage to this issue but that's probably ok.  It should add linkage to the correct PR.\r\n\r\n> For the guarantee issue that remains, I'm inclined to place the blame on Scanner rather than all the nodes other than filter and project, and to just insert the code for a trivial projection into Scanner to leverage the existing SimplifyWithGuarantee implementation\r\n\r\nI agree the best fix is on the scanner and this change should happen within the scan node.\r\n\r\n> I'm assuming that an expression that only selects an existing field will just result in a pointer copy, and that evaluating a literal expression to a scalar is also cheap (at least if the literal isn't massive). What do you think?\r\n\r\nI think you are correct here.  It should be cheap.\r\n\r\n> I'm not 100% sure on that one because of the tag fields that Scanner normally adds, which Substrait wouldn't know about. It feels fragile to leave them in because I imagine they would affect column indices after a join if not treated carefully. But I get your point.\r\n\r\nI'm not entirely sure I understand your point on the join.  The partition columns I think can just be normal columns as far as Substrait is considered.  Are you maybe thinking of the __fragment_index, __filename, etc. columns?"
        },
        {
            "created_at": "2022-07-05T17:34:18.157Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16700?focusedCommentId=17562771) by Jeroen van Straten (jvanstraten):*\n> I think you just need to update the title of the PR. I'm not sure if that removes the linkage to this issue but that's probably ok. It should add linkage to the correct PR.\r\n\r\nThe (more) correct issue being [ARROW-16904](https://issues.apache.org/jira/projects/ARROW/issues/ARROW-16904), right?\r\n\r\n> I'm not entirely sure I understand your point on the join. The partition columns I think can just be normal columns as far as Substrait is considered. Are you maybe thinking of the __fragment_index, __filename, etc. columns?\r\n\r\nThe latter, I think ([these](https://github.com/apache/arrow/blob/c1a1f47b8a2772fc270832902e7d788ee467ea08/cpp/src/arrow/dataset/scanner.cc#L917-L920) to be specific). I don't know if it would actually be an issue at all, but it doesn't feel right that Scanner makes more columns than ReadRel if we're going to be treating them as if they map one-to-one to each other.\r\n\r\nAs for a resolution to this issue, I've now locally rewritten MakeExecBatch to take the guarantee as its argument, use ExtractKnownFieldValues to turn it into the map of constant columns (helper of SimplifyWithGuarantee; turned out to be way easier to just use that, and it's also more fit for this purpose), and prefer the constant scalar from that over the actual incoming data if known. It's currently giving me failures, but my code is also still a mess from all the debug printing so it's not that surprising."
        },
        {
            "created_at": "2022-07-06T02:40:30.814Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16700?focusedCommentId=17562926) by Weston Pace (westonpace):*\n> but it doesn't feel right that Scanner makes more columns than ReadRel if we're going to be treating them as if they map one-to-one to each other.\r\n\r\nI agree there.  The ReadRel should be able to specify these columns and, if it doesn't, these columns should not be included."
        },
        {
            "created_at": "2022-07-22T16:24:41.627Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16700?focusedCommentId=17570110) by Weston Pace (westonpace):*\nIssue resolved by pull request 13518\n<https://github.com/apache/arrow/pull/13518>"
        }
    ]
}