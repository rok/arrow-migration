{
    "issue": {
        "title": "[C++/Java] Error when reading inner lists within a struct in empty outer lists from C++/Python in Java",
        "body": "***Note**: This issue was originally created as [ARROW-15971](https://issues.apache.org/jira/browse/ARROW-15971). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nWhen using C++ (or Python) to construct a null or empty outer array of type **array_1: list<item: struct<array_sub_col: list<item: string>>>**, either:\r\n```\n\r\n-  array_1: null\r\n-  array_1: []\r\n```\r\n\r\n\r\n\r\nan out of bounds exceptions (see stack trace below) follows when later retrieving the field reader for the inner list (**array_sub_col**) in Java, when trying to access the subsequent offset buffer: https://github.com/apache/arrow/blob/master/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/UnionListReader.java#L64\r\n## Reproduction\r\n\r\n**Java**: 7.0.0\r\n**C++**: 7.0.0\r\n**Python**: 7.0.0\r\n\r\nCreating a stream on C++ of type **array_1: list<item: struct<array_sub_col: list<item: string>>>** with an empty (or null) outer list:\r\n```c++\narrow::MemoryPool* pool = arrow::default_memory_pool();\r\narrow::Result<std::shared_ptr<arrow::io::BufferOutputStream>> stream_buffer =\r\n\u00a0 \u00a0 arrow::io::BufferOutputStream::Create(1, pool);\r\n\r\nstd::vector<std::shared_ptr<arrow::Field>> inner_list_field{std::make_shared<arrow::Field>(\"array_sub_col\", arrow::list(arrow::utf8()))};\r\n\r\n// Datatype for the builder: list<struct<list<string>>>\r\nstd::shared_ptr<DataType> data_type = list(struct_(inner_list_field));\r\n\r\nstd::unique_ptr<arrow::ArrayBuilder> builder;\r\narrow::MakeBuilder(pool, data_type, &builder);\r\nauto* list_builder = dynamic_cast<arrow::ListBuilder*>(builder.get());\r\n\r\n// Append a null or an empty list to the outer list\r\nlist_builder->AppendNull(); // or list_builder->AppendEmptyValue()\r\n\r\nstd::vector<std::shared_ptr<arrow::Array>> value_batch;\r\nvalue_batch.resize(1);\r\nlist_builder->Finish(&value_batch[0]);\r\n\r\nstd::vector<std::shared_ptr<arrow::Field>> outer_list_field{std::make_shared<arrow::Field>(\"array_1\",data_type)};\r\nauto schema = std::make_shared<arrow::Schema>(outer_list_field);\r\n\r\n// Build a single row record batch\r\nstd::shared_ptr<arrow::RecordBatch> batch = RecordBatch::Make(schema, 1, value_batch);\r\nASSERT_OK(batch->Validate());\r\n\r\n// Stream the batch to a file to later read on the Java side\r\narrow::Result<std::shared_ptr<ipc::RecordBatchWriter>> stream_writer =\u00a0\r\n\u00a0 \u00a0 arrow::ipc::MakeStreamWriter(stream_buffer.ValueOrDie().get(), schema, arrow::ipc::IpcWriteOptions::Defaults());\r\nstream_writer.ValueOrDie()->WriteRecordBatch(*batch);\r\n\r\narrow::Result<std::shared_ptr<arrow::Buffer>> buffer_result = stream_buffer.ValueOrDie()->Finish();\r\nstd::shared_ptr<arrow::Buffer> buffer = buffer_result.ValueOrDie();\r\nauto file_output = arrow::io::FileOutputStream::Open(\"/tmp/batch_stream.out\").ValueOrDie();\r\nfile_output->Write(buffer->data(), buffer->size());\r\nfile_output->Close();\r\n```\r\nAs expected, Python holds the same memory layout for the field vectors as the C++ code above:\r\n```python\narray = pa.array([None], type=pa.list_(pa.struct([pa.field(\"array_sub_col\", pa.list_(pa.utf8()))])))\r\nbatch = pa.record_batch([struct_array], names=[\"array_1\"])\r\n\r\nsink = pa.BufferOutputStream()\r\nwith pa.ipc.new_stream(sink, batch.schema) as writer:\r\n\u00a0 \u00a0 writer.write_batch(batch)\r\nbuf = sink.getvalue()\r\n\r\nwith open('/tmp/batch_stream.out', 'wb') as f:\r\n\u00a0 \u00a0 f.write(buf)\r\n```\r\n**Java fails when then trying to access the inner list's field reader:**\r\n```java\nFile file = new File(\"/tmp/batch_stream.out\");\r\nbyte[] bytes = FileUtils.readFileToByteArray(file);\r\ntry (ArrowStreamReader reader = new ArrowStreamReader(new ByteArrayInputStream(bytes), allocator)) {\r\n\u00a0 \u00a0 \u00a0Schema schema = reader.getVectorSchemaRoot().getSchema();\r\n\u00a0 \u00a0 \u00a0reader.loadNextBatch();\r\n\u00a0 \u00a0 \u00a0readBatch.getVector(\"array_1\").getReader().reader().reader(\"array_sub_col\"); \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // <- fails: reader(\"array_sub_col\") fails with OOB\r\n\r\n\u00a0 \u00a0 \u00a0// Concrete readers:\r\n\u00a0 \u00a0 \u00a0// FieldVector array_1 = readBatch.getVector(\"array_1\");\r\n\u00a0 \u00a0 \u00a0// UnionListReader array_1_reader = (UnionListReader) array_1.getReader();\r\n\u00a0 \u00a0 \u00a0// NullableStructReaderImpl struct_reader = (NullableStructReaderImpl) array_1_reader.reader();\r\n\u00a0 \u00a0 \u00a0// FieldReader union_list_reader = struct_reader.reader(\"array_sub_col\"); \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// <- fails: OOB\r\n```\r\n### Stack trace:\r\n```\n\r\njava.lang.reflect.InvocationTargetException\r\n\u00a0 \u00a0 at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)\r\n\u00a0 \u00a0 at jdk.internal.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)\r\n\u00a0 \u00a0 at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)\r\n\u00a0 \u00a0 at java.lang.reflect.Method.invoke (Method.java:566)\r\n\u00a0 \u00a0 at org.codehaus.mojo.exec.ExecJavaMojo$1.run (ExecJavaMojo.java:297)\r\n\u00a0 \u00a0 at java.lang.Thread.run (Thread.java:829)\r\nCaused by: java.lang.IndexOutOfBoundsException: index: 4, length: 4 (expected: range(0, 4))\r\n\u00a0 \u00a0 at org.apache.arrow.memory.ArrowBuf.checkIndexD (ArrowBuf.java:318)\r\n\u00a0 \u00a0 at org.apache.arrow.memory.ArrowBuf.chk (ArrowBuf.java:305)\r\n\u00a0 \u00a0 at org.apache.arrow.memory.ArrowBuf.getInt (ArrowBuf.java:424)\r\n\u00a0 \u00a0 at com.test.arrow.ValidateArrow.testArrow (ValidateArrow.java:433)\r\n\u00a0 \u00a0 at com.test.arrow.ValidateArrow.main (ValidateArrow.java:440)\r\n\u00a0 \u00a0 at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)\r\n\u00a0 \u00a0 at jdk.internal.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)\r\n\u00a0 \u00a0 at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)\r\n\u00a0 \u00a0 at java.lang.reflect.Method.invoke (Method.java:566)\r\n\u00a0 \u00a0 at org.codehaus.mojo.exec.ExecJavaMojo$1.run (ExecJavaMojo.java:297)\r\n\u00a0 \u00a0 at java.lang.Thread.run (Thread.java:829)\r\n```",
        "created_at": "2022-03-18T15:17:27.000Z",
        "updated_at": "2022-03-21T13:32:46.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Component: Java",
            "Component: Python",
            "Type: bug"
        ],
        "closed": false
    },
    "comments": [
        {
            "created_at": "2022-03-18T15:31:09.604Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15971?focusedCommentId=17508876) by Arrow User (ArrowUser):*\nPerformed some early investigation on the potential issue, if it helps:\r\nIn C++, the inner list consists of a single offset buffer [0], as no append is ever called on the inner list. Note that, in this case, the outer list is empty, and therefore struct does not append empty values to its children.\r\n\r\nThe memory layout for the list items is shown as:\r\n```\n\r\narray_1: list<item: struct<array_sub_col: list<item: string>>>         < -         offset: [0, 0] ; offset capacity: 8;  value size/capacity: 1;\r\n  child 0, item: struct<array_sub_col: list<item: string>>             \r\n      child 0, array_sub_col: list<item: string>                       < -         offset: [0]    ; offset capacity: 4;  value size/capacity: 0;\r\n          child 0, item: string\r\n```\r\n\r\nC++ explicitly fails on zero length offsets: https://github.com/apache/arrow/blob/master/cpp/src/arrow/array/array_nested.cc#L111, which means that populating a single int32 offset buffer on lists that are never appended to before finishing the builder to an array is expected. C++ also relies on the offset length (offset length - 1) to denote the length of the array to construct during reading on various parts (e.g. ListArrayFromArrays).\r\nA fix for Java on 7.0.0 was introduced: https://github.com/apache/arrow/commit/13b66b57b454d2b6c4ea35e3d19adbdd85b17810 to handle 0 offset capacity, but the issue remains with the latest versions.\r\nTherefore, would it be expected that the Java code assigns a current and max offset positioning of 0, when encountered with offset builders of capacity **<=4 (or ==0 || ==4)**? See https://github.com/apache/arrow/blob/master/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/UnionListReader.java#L59:\r\n\r\n ```java\npublic void setPosition(int index) {\r\n    super.setPosition(index);\r\n-   if (vector.getOffsetBuffer().capacity() == 0) {\r\n+   if (vector.getOffsetBuffer().capacity() <= OFFSET_WIDTH) {\r\n      currentOffset = 0;\r\n      maxOffset = 0;\r\n    } else { ...\r\n```"
        },
        {
            "created_at": "2022-03-21T10:25:36.016Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15971?focusedCommentId=17509752) by Alessandro Molina (amol-):*\n`[~dsusanibara]` `[~lidavidm]` what do you think?\u00a0"
        },
        {
            "created_at": "2022-03-21T13:16:10.407Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15971?focusedCommentId=17509838) by David Li (lidavidm):*\nI think Java is incorrect, yes. The \u00a0[specification](https://arrow.apache.org/docs/format/Columnar.html#variable-size-binary-layout) states\r\n> The offsets buffer contains <q>length + 1</q> signed integers (either 32-bit or 64-bit, depending on the logical type), which encode the start position of each slot in the data buffer.\r\nSo for a List type, a length 0 list should have 1 32-bit offset value, but Java appears to assume either the offsets buffer will be _empty_ or that it will have at least _two_ values."
        },
        {
            "created_at": "2022-03-21T13:32:20.482Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15971?focusedCommentId=17509875) by David Li (lidavidm):*\nThis is basically the same, but I guess now it's a question of semantics: what should `setPosition(0);` do when the length is 0? Arguably, `IndexOutOfBounds` exception is logical and the special-casing for an empty buffer is only for an edge case in Java.\r\n```\n\r\n>>> pa.array([], pa.list_(pa.int64())).buffers()\r\n[None, <pyarrow.lib.Buffer object at 0x7f8aaf2b8c30>, None, <pyarrow.lib.Buffer object at 0x7f8aaf2b8cb0>]\r\n>>> pa.array([], pa.list_(pa.int64())).buffers()[1].to_pybytes()\r\nb'\\x00\\x00\\x00\\x00' \r\n>>> rb = pa.record_batch([pa.array([], pa.list_(pa.int64()))], names=[\"a\"])\r\n>>> writer = pa.ipc.new_stream('foo.arrows', rb.schema)\r\n>>> writer.write_batch(rb)\r\n>>> writer.close()\n```\r\n```java\n\r\nimport org.apache.arrow.memory.RootAllocator;\r\nimport org.apache.arrow.vector.ipc.ArrowStreamReader;\r\nimport org.apache.arrow.vector.VectorSchemaRoot;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.IOException;var allocator = new RootAllocator();\r\nFile file = new File(\"foo.arrows\");\r\nFileInputStream inputStream = new FileInputStream(file);\r\nArrowStreamReader reader = new ArrowStreamReader(inputStream, allocator);\r\nreader.loadNextBatch()\r\nreader.getVectorSchemaRoot().getVector(\"a\").getReader()\r\nvar listReader = reader.getVectorSchemaRoot().getVector(\"a\").getReader();\r\nlistReader.setPosition(0); \n```\r\nfails with\r\n```\n\r\n| \u00a0Exception java.lang.IndexOutOfBoundsException: index: 4, length: 4 (expected: range(0, 4))\r\n| \u00a0 \u00a0 \u00a0 \u00a0at ArrowBuf.checkIndexD (ArrowBuf.java:318)\r\n| \u00a0 \u00a0 \u00a0 \u00a0at ArrowBuf.chk (ArrowBuf.java:305)\r\n| \u00a0 \u00a0 \u00a0 \u00a0at ArrowBuf.getInt (ArrowBuf.java:424)\r\n| \u00a0 \u00a0 \u00a0 \u00a0at UnionListReader.setPosition (UnionListReader.java:64)\r\n| \u00a0 \u00a0 \u00a0 \u00a0at (#14:1) \n```"
        },
        {
            "created_at": "2022-03-21T13:32:46.820Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15971?focusedCommentId=17509876) by David Li (lidavidm):*\nSo maybe Java isn't wrong then (though, the exception message could be much better!)"
        }
    ]
}