{
    "issue": {
        "title": "[C++] [Python] Does a sliced StructArray roundtrip on c data interface?",
        "body": "***Note**: This issue was originally created as [ARROW-14383](https://issues.apache.org/jira/browse/ARROW-14383). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nI am struggling to roundtrip a sliced StructArray over the c data interface.\r\n\r\nConsider the array:\r\n\r\n```python\n\r\nfields = [\r\n            (\"f1\", pyarrow.int32()),\r\n            (\"f2\", pyarrow.string()),\r\n        ]\r\n        a = pyarrow.array(\r\n            [\r\n                {\"f1\": 1, \"f2\": \"a\"},\r\n                None,\r\n                {\"f1\": 3, \"f2\": None},\r\n                {\"f1\": None, \"f2\": \"d\"},\r\n                {\"f1\": None, \"f2\": None},\r\n            ],\r\n            pyarrow.struct(fields),\r\n        ).slice(1, 2)\r\n```\r\n\r\nWhen reading this array from the c data interface, I get:\r\n\r\n```java\n\r\narray: Ffi_ArrowArray {\r\n    length: 2,\r\n    null_count: 1,\r\n    offset: 1,\r\n    n_buffers: 1,\r\n    n_children: 2,\r\n    buffers: 0x00007f61796091c0,\r\n    children: 0x00007f6179609280,\r\n    dictionary: 0x0000000000000000,\r\n    release: Some(\r\n        0x00007f617aef2ba0,\r\n    ),\r\n    private_data: 0x00007f617960b3c0,\r\n}\r\n\r\nchild #0: Ffi_ArrowArray {\r\n    length: 5,\r\n    null_count: 2,\r\n    offset: 0,\r\n    n_buffers: 2,\r\n    n_children: 0,\r\n    buffers: 0x00007f0f49609200,\r\n    children: 0x0000000000000000,\r\n    dictionary: 0x0000000000000000,\r\n    release: Some(\r\n        0x00007f0f4aec9ba0,\r\n    ),\r\n    private_data: 0x00007f0f4960b480,\r\n}\r\n\r\nchild #1: Ffi_ArrowArray {\r\n    length: 5,\r\n    null_count: 2,\r\n    offset: 0,\r\n    n_buffers: 3,\r\n    n_children: 0,\r\n    buffers: 0x00007f0f49609240,\r\n    children: 0x0000000000000000,\r\n    dictionary: 0x0000000000000000,\r\n    release: Some(\r\n        0x00007f0f4aec9ba0,\r\n    ),\r\n    private_data: 0x00007f0f4960b540,\r\n}\r\n```\r\n\r\nThis does not seem consistent with what the Python API offers:\r\n```python\n\r\nprint(a.field(0).offset, len(a.field(0))) # 1 2 <- shouldn't it be 0 5? (or better, vice-versa)\r\n```\r\n\r\nSecondly and most importantly, the condition that each child's length must equal the array's own length is violated (children length is 5, array's length is 2 in the example above).\r\n\r\nWe could argue that a consumer MUST slice each child to achieve the desired behavior, but that won't roundtrip because, when writing the StructArray (after consuming it), we would now write\r\n\r\n```Java\n\r\nwrite child: Ffi_ArrowArray {\r\n    length: 2,\r\n    null_count: 0,\r\n    offset: 1,\r\n    n_buffers: 2,\r\n    n_children: 0,\r\n    buffers: 0x00000000021c8b20,\r\n    children: 0x0000000000000008,\r\n    dictionary: 0x0000000000000000,\r\n    release: Some(\r\n        0x00007fb1f8d536c0,\r\n    ),\r\n    private_data: 0x00000000024f0db0,\r\n}\r\nwrite child: Ffi_ArrowArray {\r\n    length: 2,\r\n    null_count: 1,\r\n    offset: 1,\r\n    n_buffers: 3,\r\n    n_children: 0,\r\n    buffers: 0x00000000024998f0,\r\n    children: 0x0000000000000008,\r\n    dictionary: 0x0000000000000000,\r\n    release: Some(\r\n        0x00007fb1f8d536c0,\r\n    ),\r\n    private_data: 0x0000000002499910,\r\n}\r\nFfi_ArrowArray {\r\n    length: 2,\r\n    null_count: 1,\r\n    offset: 1,\r\n    n_buffers: 1,\r\n    n_children: 2,\r\n    buffers: 0x00000000024f12d0,\r\n    children: 0x00000000021c8ae0,\r\n    dictionary: 0x0000000000000000,\r\n    release: Some(\r\n        0x00007fb1f8d536c0,\r\n    ),\r\n    private_data: 0x00000000024999c0,\r\n}\r\n```\r\n\r\nis consumed as \r\n\r\n```Java\n\r\nprint(b.field(0).offset, len(b.field(0))) # 2 1 <------------ why?\r\nprint(b.offset, len(b))  # 1 2 <-- OK\r\n```\r\n\r\nwhich causes the check in [this line](https://github.com/apache/arrow/blob/b73af9a1607caa4a04e1a11896aed6669847a4d4/cpp/src/arrow/array/validate.cc#L115) to fail.\r\n\r\nI was unable to find a test for a roundtrip of a sliced struct [in pyarrow tests](https://github.com/apache/arrow/blob/5ead37593472c42f61c76396dde7dcb8954bde70/python/pyarrow/tests/test_cffi.py) to compare my test with a reference test, but it seems to me that when we slice a StructArray, we should slice its children accordingly so that its C data interface yields a consistent result?",
        "created_at": "2021-10-19T16:12:48.000Z",
        "updated_at": "2021-11-02T18:32:48.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Component: Python",
            "Type: bug"
        ],
        "closed": false
    },
    "comments": [
        {
            "created_at": "2021-11-02T16:18:13.337Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14383?focusedCommentId=17437454) by Jorge Leit\u00e3o (jorgecarleitao):*\nThis behavior (of slicing the child) is also present in `FixedSizeListArray`."
        },
        {
            "created_at": "2021-11-02T18:31:29.825Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14383?focusedCommentId=17437532) by Weston Pace (westonpace):*\nThis is a good question as for what is expected via the C data interface.\r\n\r\nI can maybe offer some insights as to why you're getting this behavior as I recently explored some of these cases as part of https://github.com/apache/arrow/pull/11542:\r\n\r\nThe C++ impl considers array offsets to be inherited by children (note, I don't see any description of this in the C data interface docs so we should clarify intent).  This allows for (as you have noticed) slicing parent arrays without having to mutate child arrays.  I also don't know of any requirement that the child arrays must have the same length as the parent arrays.  This is similar to buffers not being required to have the same length as the containing array.\r\n\r\nFor most data types this is pretty straightforward to implement.  It's a bit trickier for variable length data types (you need to use the parent array's offsets AND indices maps to determine the referenced portion of the child array).\r\n\r\nIt's a downright pain for dense unions.  There is no way to easy way know what the appropriate offset of the children arrays if you are trying to determine which portion of the child arrays is referenced by the union without iterating the type ids array of the union.\r\n\r\nThe last notable exception is ArrowArray.dictionary.  Slicing an arrow array in C++ does not modify the ArrowArray.dictionary field at all and ArrowArray.dictionary does not inherit the offsets of the containing array."
        },
        {
            "created_at": "2021-11-02T18:32:48.366Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14383?focusedCommentId=17437533) by Weston Pace (westonpace):*\nI don't think I wrote that first sentence clearly.  The above comment is \"This is what the C++ implementation currently does\" and not \"this is how the C data interface should behave\".  It seems we need more documentation in the C data interface docs around this behavior."
        }
    ]
}