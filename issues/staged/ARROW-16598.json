{
    "issue": {
        "title": "[R][Doc] Document how sorting etc. can affect Parquet file size",
        "body": "***Note**: This issue was originally created as [ARROW-16598](https://issues.apache.org/jira/browse/ARROW-16598). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nWhen using the arrow R package, sorting a data.frame prior to using write_parquet() results in different file sizes, depending on how the data.frame is sorted. I have attached a reproducible example showing how a few different sorting methods can lead to 2-3 fold changes in .parquet file size.\r\n\r\nIt may be that I don't know enough about Parquet internals, but at the very least, I think this behavior should be documented on the arrow R package site. Most R users tend to approach sorting as a convenience and don't expect it to lead to performance changes when writing to a file.\r\n```java\n\r\nlibrary(tidyverse)\r\n\r\nd <- expand_grid(group = letters[1:4],\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0id = 1:100) %>%\u00a0\r\n\u00a0 mutate(id_f = paste(group, id, sep = \"_\")) %>%\u00a0\r\n\u00a0 mutate(time = rep(list(1:100)), 400) %>%\u00a0\r\n\u00a0 unnest(time) %>%\u00a0\r\n\u00a0 group_by(group) %>%\r\n\u00a0 mutate(id_n = list(sample(id_f, size = 5, replace = F))) %>%\u00a0\r\n\u00a0 unnest(id_n) %>%\u00a0\r\n\u00a0 ungroup()\r\n\r\nf1 <- tempfile(fileext = \".parquet\")\r\nf2 <- tempfile(fileext = \".parquet\")\r\nf3 <- tempfile(fileext = \".parquet\")\r\nf4 <- tempfile(fileext = \".parquet\")\r\nf5 <- tempfile(fileext = \".parquet\")\r\n\r\nd %>%\u00a0\r\n\u00a0 arrow::write_parquet(f1)\r\n\r\nd %>%\u00a0\r\n\u00a0 arrange(id_n) %>%\u00a0\r\n\u00a0 arrow::write_parquet(f2)\r\n\r\nd %>%\u00a0\r\n\u00a0 arrange(id_n, time) %>%\u00a0\r\n\u00a0 arrow::write_parquet(f3)\r\n\r\nd %>%\u00a0\r\n\u00a0 arrange(time, id_f) %>%\u00a0\r\n\u00a0 arrow::write_parquet(f4)\r\n\r\nd %>%\u00a0\r\n\u00a0 arrange(group, time, id_n, id_f) %>%\u00a0\r\n\u00a0 arrow::write_parquet(f5)\r\n\r\nfs::file_info(c(f1, f2, f3, f4, f5))[, \"size\"]\r\n\r\n#> # A tibble: 5 \u00d7 1\r\n#> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0size\r\n#> \u00a0 <fs::bytes>\r\n#> 1 \u00a0 \u00a0 \u00a0 25.4K\r\n#> 2 \u00a0 \u00a0 \u00a0 17.3K\r\n#> 3 \u00a0 \u00a0 \u00a0 28.4K\r\n#> 4 \u00a0 \u00a0 \u00a0 45.6K\r\n#> 5 \u00a0 \u00a0 \u00a0 30.1K\r\n\r\nsessioninfo::session_info()\r\n\r\n#> \u2500 Session info \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n#> \u00a0setting \u00a0value \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\u00a0\r\n#> \u00a0version \u00a0R version 4.1.3 (2022-03-10)\r\n#> \u00a0os \u00a0 \u00a0 \u00a0 macOS Big Sur/Monterey 10.16\r\n#> \u00a0system \u00a0 x86_64, darwin17.0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\r\n#> \u00a0ui \u00a0 \u00a0 \u00a0 X11 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\u00a0\r\n#> \u00a0language (EN) \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\r\n#> \u00a0collate \u00a0en_US.UTF-8 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\u00a0\r\n#> \u00a0ctype \u00a0 \u00a0en_US.UTF-8 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\u00a0\r\n#> \u00a0tz \u00a0 \u00a0 \u00a0 America/Chicago \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\u00a0\r\n#> \u00a0date \u00a0 \u00a0 2022-05-17 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\r\n#>\u00a0\r\n#> \u2500 Packages \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n#> \u00a0package \u00a0 \u00a0 * version date \u00a0 \u00a0 \u00a0 lib source \u00a0 \u00a0 \u00a0 \u00a0\r\n#> \u00a0arrow \u00a0 \u00a0 \u00a0 \u00a0 8.0.0 \u00a0 2022-05-09 [1] CRAN (R 4.1.2)\r\n#> \u00a0assertthat \u00a0 \u00a00.2.1 \u00a0 2019-03-21 [1] CRAN (R 4.1.0)\r\n#> \u00a0backports \u00a0 \u00a0 1.4.1 \u00a0 2021-12-13 [1] CRAN (R 4.1.0)\r\n#> \u00a0bit \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 4.0.4 \u00a0 2020-08-04 [1] CRAN (R 4.1.0)\r\n#> \u00a0bit64 \u00a0 \u00a0 \u00a0 \u00a0 4.0.5 \u00a0 2020-08-30 [1] CRAN (R 4.1.0)\r\n#> \u00a0broom \u00a0 \u00a0 \u00a0 \u00a0 0.7.9 \u00a0 2021-07-27 [1] CRAN (R 4.1.0)\r\n#> \u00a0cellranger \u00a0 \u00a01.1.0 \u00a0 2016-07-27 [1] CRAN (R 4.1.0)\r\n#> \u00a0cli \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3.3.0 \u00a0 2022-04-25 [1] CRAN (R 4.1.2)\r\n#> \u00a0colorspace \u00a0 \u00a02.0-3 \u00a0 2022-02-21 [1] CRAN (R 4.1.2)\r\n#> \u00a0crayon \u00a0 \u00a0 \u00a0 \u00a01.5.1 \u00a0 2022-03-26 [1] CRAN (R 4.1.2)\r\n#> \u00a0DBI \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 1.1.1 \u00a0 2021-01-15 [1] CRAN (R 4.1.0)\r\n#> \u00a0dbplyr \u00a0 \u00a0 \u00a0 \u00a02.1.1 \u00a0 2021-04-06 [1] CRAN (R 4.1.0)\r\n#> \u00a0digest \u00a0 \u00a0 \u00a0 \u00a00.6.29 \u00a02021-12-01 [1] CRAN (R 4.1.0)\r\n#> \u00a0dplyr \u00a0 \u00a0 \u00a0 * 1.0.9 \u00a0 2022-04-28 [1] CRAN (R 4.1.2)\r\n#> \u00a0ellipsis \u00a0 \u00a0 \u00a00.3.2 \u00a0 2021-04-29 [1] CRAN (R 4.1.0)\r\n#> \u00a0evaluate \u00a0 \u00a0 \u00a00.14 \u00a0 \u00a02019-05-28 [1] CRAN (R 4.1.0)\r\n#> \u00a0fansi \u00a0 \u00a0 \u00a0 \u00a0 1.0.3 \u00a0 2022-03-24 [1] CRAN (R 4.1.2)\r\n#> \u00a0fastmap \u00a0 \u00a0 \u00a0 1.1.0 \u00a0 2021-01-25 [1] CRAN (R 4.1.0)\r\n#> \u00a0forcats \u00a0 \u00a0 * 0.5.1 \u00a0 2021-01-27 [1] CRAN (R 4.1.0)\r\n#> \u00a0fs \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a01.5.2 \u00a0 2021-12-08 [1] CRAN (R 4.1.0)\r\n#> \u00a0generics \u00a0 \u00a0 \u00a00.1.2 \u00a0 2022-01-31 [1] CRAN (R 4.1.2)\r\n#> \u00a0ggplot2 \u00a0 \u00a0 * 3.3.6 \u00a0 2022-05-03 [1] CRAN (R 4.1.3)\r\n#> \u00a0glue \u00a0 \u00a0 \u00a0 \u00a0 \u00a01.6.2 \u00a0 2022-02-24 [1] CRAN (R 4.1.2)\r\n#> \u00a0gtable \u00a0 \u00a0 \u00a0 \u00a00.3.0 \u00a0 2019-03-25 [1] CRAN (R 4.1.0)\r\n#> \u00a0haven \u00a0 \u00a0 \u00a0 \u00a0 2.4.3 \u00a0 2021-08-04 [1] CRAN (R 4.1.0)\r\n#> \u00a0highr \u00a0 \u00a0 \u00a0 \u00a0 0.9 \u00a0 \u00a0 2021-04-16 [1] CRAN (R 4.1.0)\r\n#> \u00a0hms \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 1.1.0 \u00a0 2021-05-17 [1] CRAN (R 4.1.0)\r\n#> \u00a0htmltools \u00a0 \u00a0 0.5.2 \u00a0 2021-08-25 [1] CRAN (R 4.1.0)\r\n#> \u00a0httr \u00a0 \u00a0 \u00a0 \u00a0 \u00a01.4.2 \u00a0 2020-07-20 [1] CRAN (R 4.1.0)\r\n#> \u00a0jsonlite \u00a0 \u00a0 \u00a01.8.0 \u00a0 2022-02-22 [1] CRAN (R 4.1.2)\r\n#> \u00a0knitr \u00a0 \u00a0 \u00a0 \u00a0 1.37 \u00a0 \u00a02021-12-16 [1] CRAN (R 4.1.0)\r\n#> \u00a0lifecycle \u00a0 \u00a0 1.0.1 \u00a0 2021-09-24 [1] CRAN (R 4.1.0)\r\n#> \u00a0lubridate \u00a0 \u00a0 1.7.10 \u00a02021-02-26 [1] CRAN (R 4.1.0)\r\n#> \u00a0magrittr \u00a0 \u00a0 \u00a02.0.3 \u00a0 2022-03-30 [1] CRAN (R 4.1.2)\r\n#> \u00a0modelr \u00a0 \u00a0 \u00a0 \u00a00.1.8 \u00a0 2020-05-19 [1] CRAN (R 4.1.0)\r\n#> \u00a0munsell \u00a0 \u00a0 \u00a0 0.5.0 \u00a0 2018-06-12 [1] CRAN (R 4.1.0)\r\n#> \u00a0pillar \u00a0 \u00a0 \u00a0 \u00a01.7.0 \u00a0 2022-02-01 [1] CRAN (R 4.1.2)\r\n#> \u00a0pkgconfig \u00a0 \u00a0 2.0.3 \u00a0 2019-09-22 [1] CRAN (R 4.1.0)\r\n#> \u00a0purrr \u00a0 \u00a0 \u00a0 * 0.3.4 \u00a0 2020-04-17 [1] CRAN (R 4.1.0)\r\n#> \u00a0R6 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a02.5.1 \u00a0 2021-08-19 [1] CRAN (R 4.1.0)\r\n#> \u00a0Rcpp \u00a0 \u00a0 \u00a0 \u00a0 \u00a01.0.8.3 2022-03-17 [1] CRAN (R 4.1.2)\r\n#> \u00a0readr \u00a0 \u00a0 \u00a0 * 2.0.1 \u00a0 2021-08-10 [1] CRAN (R 4.1.0)\r\n#> \u00a0readxl \u00a0 \u00a0 \u00a0 \u00a01.3.1 \u00a0 2019-03-13 [1] CRAN (R 4.1.0)\r\n#> \u00a0reprex \u00a0 \u00a0 \u00a0 \u00a02.0.1 \u00a0 2021-08-05 [1] CRAN (R 4.1.0)\r\n#> \u00a0rlang \u00a0 \u00a0 \u00a0 \u00a0 1.0.2 \u00a0 2022-03-04 [1] CRAN (R 4.1.2)\r\n#> \u00a0rmarkdown \u00a0 \u00a0 2.11 \u00a0 \u00a02021-09-14 [1] CRAN (R 4.1.0)\r\n#> \u00a0rstudioapi \u00a0 \u00a00.13 \u00a0 \u00a02020-11-12 [1] CRAN (R 4.1.0)\r\n#> \u00a0rvest \u00a0 \u00a0 \u00a0 \u00a0 1.0.1 \u00a0 2021-07-26 [1] CRAN (R 4.1.0)\r\n#> \u00a0scales \u00a0 \u00a0 \u00a0 \u00a01.2.0 \u00a0 2022-04-13 [1] CRAN (R 4.1.2)\r\n#> \u00a0sessioninfo \u00a0 1.1.1 \u00a0 2018-11-05 [1] CRAN (R 4.1.0)\r\n#> \u00a0stringi \u00a0 \u00a0 \u00a0 1.7.6 \u00a0 2021-11-29 [1] CRAN (R 4.1.0)\r\n#> \u00a0stringr \u00a0 \u00a0 * 1.4.0 \u00a0 2019-02-10 [1] CRAN (R 4.1.0)\r\n#> \u00a0styler \u00a0 \u00a0 \u00a0 \u00a01.4.1 \u00a0 2021-03-30 [1] CRAN (R 4.1.0)\r\n#> \u00a0tibble \u00a0 \u00a0 \u00a0* 3.1.7 \u00a0 2022-05-03 [1] CRAN (R 4.1.3)\r\n#> \u00a0tidyr \u00a0 \u00a0 \u00a0 * 1.1.3 \u00a0 2021-03-03 [1] CRAN (R 4.1.0)\r\n#> \u00a0tidyselect \u00a0 \u00a01.1.2 \u00a0 2022-02-21 [1] CRAN (R 4.1.2)\r\n#> \u00a0tidyverse \u00a0 * 1.3.1 \u00a0 2021-04-15 [1] CRAN (R 4.1.0)\r\n#> \u00a0tzdb \u00a0 \u00a0 \u00a0 \u00a0 \u00a00.1.2 \u00a0 2021-07-20 [1] CRAN (R 4.1.0)\r\n#> \u00a0utf8 \u00a0 \u00a0 \u00a0 \u00a0 \u00a01.2.2 \u00a0 2021-07-24 [1] CRAN (R 4.1.0)\r\n#> \u00a0vctrs \u00a0 \u00a0 \u00a0 \u00a0 0.4.1 \u00a0 2022-04-13 [1] CRAN (R 4.1.2)\r\n#> \u00a0withr \u00a0 \u00a0 \u00a0 \u00a0 2.5.0 \u00a0 2022-03-03 [1] CRAN (R 4.1.2)\r\n#> \u00a0xfun \u00a0 \u00a0 \u00a0 \u00a0 \u00a00.30 \u00a0 \u00a02022-03-02 [1] CRAN (R 4.1.2)\r\n#> \u00a0xml2 \u00a0 \u00a0 \u00a0 \u00a0 \u00a01.3.2 \u00a0 2020-04-23 [1] CRAN (R 4.1.0)\r\n#> \u00a0yaml \u00a0 \u00a0 \u00a0 \u00a0 \u00a02.3.5 \u00a0 2022-02-21 [1] CRAN (R 4.1.2)\r\n#>\u00a0\r\n#> [1] /Users/MJ/R_Packages_4.1\r\n#> [2] /Library/Frameworks/R.framework/Versions/4.1/Resources/library \n```",
        "created_at": "2022-05-17T15:26:05.000Z",
        "updated_at": "2022-07-02T14:06:05.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: R",
            "Type: enhancement"
        ],
        "closed": false
    },
    "comments": [
        {
            "created_at": "2022-05-17T20:14:44.426Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16598?focusedCommentId=17538446) by Will Jones (willjones127):*\nYes, that's very much expected. The likely main reason is the column encodings are sensitive to the sort order of the table, RLE in particular. (0,0,0,1,1 is easy to describe succinctly: 3 zeros, 2 1's; 0,1,0,1,0 is a little harder.) I've seen Spark talks about Parquet that discuss this more directly (though can't find them at the moment). But here's a R blog post that can give you a little intuition about the encodings and I think you can infer how sort order affects them: <https://www.jumpingrivers.com/blog/parquet-file-format-big-data-r/>\r\n\r\nIt's actually a common micro-optimization to carefully choose the sort order of data prior to saving to files, so maybe worth discussing in the docs. A good sort order can separate values across row groups, sort of like how directory partitioning allows for data skipping. And good sorting of values can also lead to more compact encoded columns."
        },
        {
            "created_at": "2022-05-17T20:23:38.542Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16598?focusedCommentId=17538452) by Michael Culshaw-Maurer (michaelc-m):*\nI've actually read that blog post, and I figured that the RLE encoding would lead to some differences, which is why I started looking at sorting my data in the first place. I guess I was just surprised by which columns affected the size the most.\r\n\r\nIn these data there are 50,000 rows for each value of group, 2000 rows for each value of time, but only 500 rows for each id_f. To me, it would seem that sorting by group would matter the most, since you could just say \"50,000 replicates of each group\", as in your example with 0,0,0,1,1. However, sorting by group was not the best option.\r\n\r\nI ran this issue by a couple other very experienced R users and they were just as surprised, they figured group or time would be the ideal columns as well."
        },
        {
            "created_at": "2022-05-17T20:43:43.277Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16598?focusedCommentId=17538464) by Will Jones (willjones127):*\nYeah. I say column encodings are likely the biggest influence, but columns are also run through compression algorithms like Snappy, LZ4, and GZIP, and so I bet there are surprising interactions there. That's why it's hard to give generic advice.\r\n\r\nI don't think we're setup to do this now, but it makes me wonder if we couldn't make something that does for parquet what [https://www.squoosh.app](https://www.squoosh.app/) does for images: provide an easy interface to try out different compression, sort, and partitioning options and see how they impact file size / access patterns. Could be prototyped as a Shiny app, but would be cool eventually to have as a WASM in-browser app like Squoosh."
        },
        {
            "created_at": "2022-05-17T21:42:59.321Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16598?focusedCommentId=17538491) by Michael Culshaw-Maurer (michaelc-m):*\nHmmmm, I tried running them all uncompressed, and the results are still the same as far as which types of sorting led to the greatest compression.\r\n\r\nI definitely agree that an interactive approach to this would be really cool, if you wanted to talk about putting together something in Shiny I'd be down to help with that! I also wonder if there would be a way to do what I've been doing programatically. Some sort of search for the best combination of pre-sorting and compression, saved to tempfiles and sizes written as output.\r\n\r\nIn the meantime, I'm still somewhat curious what's going on with the sorting even without compression, as it does seem to clash with what I expect to happen with RLE. I think it might also be worth adding some line about this to the `write_arrow()` documentation, just so people are aware that they might be inadvertently changing their file sizes by quite a bit (or might be able to optimize quite a bit!)."
        },
        {
            "created_at": "2022-05-17T22:20:46.999Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16598?focusedCommentId=17538498) by Will Jones (willjones127):*\nWell if you want to investigate further in your Parquet files, I'd suggest writing a Python script to print out the column metadata. (pyarrow has more low-level APIs exposed for viewing metadata than the R package.)\r\n\r\nSomething like this should be helpful:\r\n```python\n\r\nimport pyarrow.parquet as pq\r\n\r\nmetadata = pq.ParquetFile(\"path/to/data.parquet\").metadata\r\n\r\nfor row_group_i in range(metadata.num_row_groups):\r\n    group_meta = metadata.row_group(row_group_i)\r\n    for col_i in range(group_meta.num_columns):\r\n        col_meta = group_meta.column(col_i)\r\n        print(f\"{col_meta.path_in_schema:<24} {col_meta.num_values:>12,} values {col_meta.total_compressed_size:>12,} bytes (encodings: {col_meta.encodings})\")\r\n```"
        }
    ]
}