{
    "issue": {
        "title": "[C++][Plasma] Broken Record Batch returned from a function call",
        "body": "***Note**: This issue was originally created as [ARROW-7522](https://issues.apache.org/jira/browse/ARROW-7522). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nScenario: retrieving Record Batch from Plasma with known Object ID.\r\n\r\nThe following code snippet works well:\r\n```java\n\r\nint main(int argc, char **argv)\r\n{\r\n    plasma::ObjectID object_id = plasma::ObjectID::from_binary(\"0FF1CE00C0FFEE00BEEF\");\r\n\r\n    // Start up and connect a Plasma client.\r\n    plasma::PlasmaClient client;\r\n    ARROW_CHECK_OK(client.Connect(\"/tmp/store\"));\r\n\r\n    plasma::ObjectBuffer object_buffer;\r\n    ARROW_CHECK_OK(client.Get(&object_id, 1, -1, &object_buffer));\r\n\r\n    // Retrieve object data.\r\n    auto buffer = object_buffer.data;\r\n\r\n    arrow::io::BufferReader buffer_reader(buffer); \r\n    std::shared_ptr<arrow::ipc::RecordBatchReader> record_batch_stream_reader;\r\n    ARROW_CHECK_OK(arrow::ipc::RecordBatchStreamReader::Open(&buffer_reader, &record_batch_stream_reader));\r\n\r\n    std::shared_ptr<arrow::RecordBatch> record_batch;\r\n    arrow::Status status = record_batch_stream_reader->ReadNext(&record_batch);\r\n\r\n    std::cout << \"record_batch->column_name(0): \" << record_batch->column_name(0) << std::endl;\r\n    std::cout << \"record_batch->num_columns(): \" << record_batch->num_columns() << std::endl;\r\n    std::cout << \"record_batch->num_rows(): \" << record_batch->num_rows() << std::endl;\r\n    std::cout << \"record_batch->column(0)->length(): \"\r\n              << record_batch->column(0)->length() << std::endl;\r\n    std::cout << \"record_batch->column(0)->ToString(): \"\r\n              << record_batch->column(0)->ToString() << std::endl;\r\n}\r\n```\r\n`record_batch->column(0)->ToString()` would incur a segmentation fault if retrieving Record Batch is wrapped in a function:\r\n```java\n\r\nstd::shared_ptr<arrow::RecordBatch> GetRecordBatchFromPlasma(plasma::ObjectID object_id)\r\n{\r\n    // Start up and connect a Plasma client.\r\n    plasma::PlasmaClient client;\r\n    ARROW_CHECK_OK(client.Connect(\"/tmp/store\"));\r\n\r\n    plasma::ObjectBuffer object_buffer;\r\n    ARROW_CHECK_OK(client.Get(&object_id, 1, -1, &object_buffer));\r\n\r\n    // Retrieve object data.\r\n    auto buffer = object_buffer.data;\r\n\r\n    arrow::io::BufferReader buffer_reader(buffer);\r\n    std::shared_ptr<arrow::ipc::RecordBatchReader> record_batch_stream_reader;\r\n    ARROW_CHECK_OK(arrow::ipc::RecordBatchStreamReader::Open(&buffer_reader, &record_batch_stream_reader));\r\n\r\n    std::shared_ptr<arrow::RecordBatch> record_batch;\r\n    arrow::Status status = record_batch_stream_reader->ReadNext(&record_batch);\r\n\r\n    // Disconnect the client.\r\n    ARROW_CHECK_OK(client.Disconnect());\r\n\r\n    return record_batch;\r\n}\r\n\r\nint main(int argc, char **argv)\r\n{\r\n    plasma::ObjectID object_id = plasma::ObjectID::from_binary(\"0FF1CE00C0FFEE00BEEF\");\r\n\r\n    std::shared_ptr<arrow::RecordBatch> record_batch = GetRecordBatchFromPlasma(object_id);\r\n\r\n    std::cout << \"record_batch->column_name(0): \" << record_batch->column_name(0) << std::endl;\r\n    std::cout << \"record_batch->num_columns(): \" << record_batch->num_columns() << std::endl;\r\n    std::cout << \"record_batch->num_rows(): \" << record_batch->num_rows() << std::endl;\r\n    std::cout << \"record_batch->column(0)->length(): \"\r\n              << record_batch->column(0)->length() << std::endl;\r\n    std::cout << \"record_batch->column(0)->ToString(): \"\r\n              << record_batch->column(0)->ToString() << std::endl;\r\n}\r\n```\r\nThe meta info of the Record Batch such as number of columns and rows is still available, but I can't see the content of the columns.\r\n\r\n`lldb` says that the stop reason is `EXC_BAD_ACCESS`, so I think the Record Batch is destroyed after `GetRecordBatchFromPlasma` finishes. But why can I still see the meta info of this Record Batch?\r\n What is the proper way to get the Record Batch if we insist using a function?",
        "created_at": "2020-01-08T21:54:19.000Z",
        "updated_at": "2020-01-13T00:02:35.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Component: C++ - Plasma",
            "Type: bug"
        ],
        "closed": false
    },
    "comments": [
        {
            "created_at": "2020-01-09T16:43:25.483Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-7522?focusedCommentId=17012031) by Wes McKinney (wesm):*\nSeems like that any Plasma memory accessed by the client is invalidated as soon as the client is disconnected or destroyed. If you keep the PlasmaClient alive I'm guessing it will not happen. \r\n\r\n`[~robertnishihara]` or `[~pcmoritz]` may be able to comment on whether this is by design or something that could be fixed potentially. It seems like keeping the mmaps alive could be doable"
        },
        {
            "created_at": "2020-01-11T22:08:53.800Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-7522?focusedCommentId=17013588) by Philipp Moritz (pcmoritz):*\nDisconnecting from the PlasmaClient and letting it go out of scope is fine, the memory mapped files will still be kept alive. The problem in this code example is that the buffer of the object is not kept alive (the buffer in the `auto buffer = object_buffer.data;` line). If that buffer is kept alive, this shared pointer here <https://github.com/apache/arrow/blob/b218a7fdae0792e185579d8cd20748ed0752b9ff/cpp/src/plasma/client.cc#L137> will make sure the PlasmaClient is kept alive, which will make sure the memory maps are kept alive.\r\n\r\nTo fix this, we would need some way to set a \"base\" object of an `arrow::RecordBatch` (similar to numpy base objects) which will make sure the backing buffer is kept alive. As a workaround you can also keep the PlasmaClient alive, but that feel very brittle."
        },
        {
            "created_at": "2020-01-12T23:57:30.496Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-7522?focusedCommentId=17013926) by Wes McKinney (wesm):*\n> the buffer of the object is not kept alive\r\n\r\nIt should be kept alive, though. This buffer is sliced by the IPC read path so there should be many shared_ptr values referencing this buffer after the call to `ReadNext` (this is the equivalent of the \"base\" strategy that NumPy uses, so such additional thing is not needed here)"
        }
    ]
}