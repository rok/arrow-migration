{
    "issue": {
        "title": "[R] SafeCallIntoR on 3.4",
        "body": "***Note**: This issue was originally created as [ARROW-16201](https://issues.apache.org/jira/browse/ARROW-16201). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nIn the R versions test, we're seeing a segfault on 3.4:\r\n\r\n```Java\n\r\nStart test: SafeCallIntoR errors from the non-R thread\r\n\r\n *** caught segfault ***\r\naddress 0x2b, cause 'memory not mapped'\r\n\r\nTraceback:\r\n 1: .Call(`_arrow_TestSafeCallIntoR`, r_fun_that_returns_a_string,     opt)\r\n 2: TestSafeCallIntoR(function() \"string one!\", opt = \"async_without_executor\")\r\n 3: eval_bare(quo_get_expr(.quo), quo_get_env(.quo))\r\n 4: withCallingHandlers(expr, condition = function(cnd) {    if (!is.null(matched) || !matches(cnd)) {        return()    }    if (can_entrace(cnd)) {        cnd <- cnd_entrace(cnd)    }    matched <<- cnd    if (inherits(cnd, \"message\") || inherits(cnd, \"warning\")) {        cnd_muffle(cnd)    }    else if (inherits(cnd, \"error\") || inherits(cnd, \"skip\")) {        return_from(tl, cnd)    }})\r\n 5: .capture(act$val <- eval_bare(quo_get_expr(.quo), quo_get_env(.quo)),     ...)\r\n 6: quasi_capture(enquo(object), label, capture_matching_condition,     matches = matcher)\r\n 7: expect_condition_matching(\"error\", {    {        object    }}, regexp = regexp, class = class, ..., inherit = inherit, info = info,     label = label)\r\n 8: expect_error(TestSafeCallIntoR(function() \"string one!\", opt = \"async_without_executor\"),     \"Call to R from a non-R thread\")\r\n 9: eval(code, test_env)\r\n10: eval(code, test_env)\r\n11: withCallingHandlers({    eval(code, test_env)    if (!handled && !is.null(test)) {        skip_empty()    }}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,     message = handle_message, error = handle_error)\r\n12: doTryCatch(return(expr), name, parentenv, handler)\r\n13: tryCatchOne(expr, names, parentenv, handlers[[1L]])\r\n14: tryCatchList(expr, names[-nh], parentenv, handlers[-nh])\r\n15: doTryCatch(return(expr), name, parentenv, handler)\r\n16: tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]),     names[nh], parentenv, handlers[[nh]])\r\n17: tryCatchList(expr, classes, parentenv, handlers)\r\n18: tryCatch(withCallingHandlers({    eval(code, test_env)    if (!handled && !is.null(test)) {        skip_empty()    }}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,     message = handle_message, error = handle_error), error = handle_fatal,     skip = function(e) {    })\r\n19: test_code(desc, code, env = parent.frame(), reporter = reporter)\r\n20: testthat::test_that(what, {    skip_if(getOption(\"..skip.tests\", TRUE), \"arrow C++ library not available\")    code})\r\n21: test_that(\"SafeCallIntoR errors from the non-R thread\", {    skip_on_cran()    expect_error(TestSafeCallIntoR(function() \"string one!\",         opt = \"async_without_executor\"), \"Call to R from a non-R thread\")    expect_error(TestSafeCallIntoR(function() stop(\"an error!\"),         opt = \"async_without_executor\"), \"Call to R from a non-R thread\")})\r\n22: eval(code, test_env)\r\n23: eval(code, test_env)\r\n24: withCallingHandlers({    eval(code, test_env)    if (!handled && !is.null(test)) {        skip_empty()    }}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,     message = handle_message, error = handle_error)\r\n25: doTryCatch(return(expr), name, parentenv, handler)\r\n26: tryCatchOne(expr, names, parentenv, handlers[[1L]])\r\n27: tryCatchList(expr, names[-nh], parentenv, handlers[-nh])\r\n28: doTryCatch(return(expr), name, parentenv, handler)\r\n29: tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]),     names[nh], parentenv, handlers[[nh]])\r\n30: tryCatchList(expr, classes, parentenv, handlers)\r\n31: tryCatch(withCallingHandlers({    eval(code, test_env)    if (!handled && !is.null(test)) {        skip_empty()    }}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,     message = handle_message, error = handle_error), error = handle_fatal,     skip = function(e) {    })\r\n32: test_code(NULL, exprs, env)\r\n33: source_file(path, child_env(env), wrap = wrap)\r\n34: FUN(X[[i]], ...)\r\n35: lapply(test_paths, test_one_file, env = env, wrap = wrap)\r\n36: doTryCatch(return(expr), name, parentenv, handler)\r\n37: tryCatchOne(expr, names, parentenv, handlers[[1L]])\r\n38: tryCatchList(expr, classes, parentenv, handlers)\r\n39: tryCatch(code, testthat_abort_reporter = function(cnd) {    cat(conditionMessage(cnd), \"\\n\")    NULL})\r\n40: with_reporter(reporters$multi, lapply(test_paths, test_one_file,     env = env, wrap = wrap))\r\n41: test_files(test_dir = test_dir, test_package = test_package,     test_paths = test_paths, load_helpers = load_helpers, reporter = reporter,     env = env, stop_on_failure = stop_on_failure, stop_on_warning = stop_on_warning,     wrap = wrap, load_package = load_package)\r\n42: test_files(test_dir = path, test_paths = test_paths, test_package = package,     reporter = reporter, load_helpers = load_helpers, env = env,     stop_on_failure = stop_on_failure, stop_on_warning = stop_on_warning,     wrap = wrap, load_package = load_package, parallel = parallel)\r\n43: test_dir(\"testthat\", package = package, reporter = reporter,     ..., load_package = \"installed\")\r\n44: test_check(\"arrow\", reporter = arrow_reporter)\r\nAn irrecoverable exception occurred. R is aborting now ...\r\nSegmentation fault (core dumped)\r\n```\r\n\r\nhttps://github.com/ursacomputing/crossbow/runs/6017815299?check_suite_focus=true",
        "created_at": "2022-04-14T14:55:00.000Z",
        "updated_at": "2022-04-16T06:31:11.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: R",
            "Type: enhancement"
        ],
        "closed": true,
        "closed_at": "2022-04-14T20:28:53.000Z"
    },
    "comments": [
        {
            "created_at": "2022-04-14T20:28:53.916Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16201?focusedCommentId=17522529) by Jonathan Keane (jonkeane):*\nIssue resolved by pull request 12887\n<https://github.com/apache/arrow/pull/12887>"
        }
    ]
}