{
    "issue": {
        "title": "[R] Troubles with using augmented columns",
        "body": "***Note**: This issue was originally created as [ARROW-18286](https://issues.apache.org/jira/browse/ARROW-18286). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nWe can project to add augmented fields like `__filename`, but there are a few catches. Given:\r\n\r\n```Java\n\r\nlibrary(arrow, warn.conflicts = FALSE)\r\nlibrary(dplyr, warn.conflicts = FALSE)\r\n\r\nds <- InMemoryDataset$create(mtcars) %>%\r\n  mutate(f = add_filename())\r\n\r\nshow_query(ds)\r\n#> ExecPlan with 3 nodes:\r\n#> 2:SinkNode{}\r\n#>   1:ProjectNode{projection=[mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb, \"f\": __filename]}\r\n#>     0:SourceNode{}\r\n\r\ncollect(ds)\r\n#>     mpg cyl  disp  hp drat    wt  qsec vs am gear carb         f\r\n#> 1  21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4 in-memory\r\n#> 2  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4 in-memory\r\n#> 3  22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1 in-memory\r\n...\r\n```\r\n\r\nIssue #1: you can't filter on that column because (my theory, based on the evidence) the ScanNode takes a projection and filter, but the filter is not evaluated with the augmented schema, so it doesn't find `__filename`. This seems fixable in C++.\r\n\r\n```Java\n\r\nds %>%\r\n  filter(f == \"in-memory\") %>%\r\n  collect()\r\n#> Error in `collect()`:\r\n#> ! Invalid: No match for FieldRef.Name(__filename) in mpg: double\r\n#> cyl: double\r\n#> disp: double\r\n#> hp: double\r\n#> drat: double\r\n#> wt: double\r\n#> qsec: double\r\n#> vs: double\r\n#> am: double\r\n#> gear: double\r\n#> carb: double\r\n#> \u2139 `add_filename()` or use of the `__filename` augmented field can only be used with with Dataset objects, and can only be added before doing an aggregation or a join.\r\n\r\n#> Backtrace:\r\n#>      \u2586\r\n#>   1. \u251c\u2500ds %>% filter(f == \"in-memory\") %>% collect()\r\n#>   2. \u251c\u2500dplyr::collect(.)\r\n#>   3. \u2514\u2500arrow:::collect.arrow_dplyr_query(.)\r\n#>   4.   \u2514\u2500base::tryCatch(...)\r\n#>   5.     \u2514\u2500base (local) tryCatchList(expr, classes, parentenv, handlers)\r\n#>   6.       \u2514\u2500base (local) tryCatchOne(expr, names, parentenv, handlers[[1L]])\r\n#>   7.         \u2514\u2500value[[3L]](cond)\r\n#>   8.           \u2514\u2500arrow:::augment_io_error_msg(e, call, schema = x$.data$schema)\r\n#>   9.             \u2514\u2500arrow:::handle_augmented_field_misuse(msg, call)\r\n#>  10.               \u2514\u2500rlang::abort(msg, call = call)\r\n```\r\n\r\nProof that it is in the ScanNode: If we `collapse()` the query after projecting to include filename but before the filter, the filter doesn't get included in the ScanNode, it's only applied after, as a FilterNode. This works:\r\n\r\n```Java\n\r\nds %>%\r\n  collapse() %>%\r\n  filter(f == \"in-memory\") %>%\r\n  collect()\r\n#>     mpg cyl  disp  hp drat    wt  qsec vs am gear carb         f\r\n#> 1  21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4 in-memory\r\n#> 2  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4 in-memory\r\n#> 3  22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1 in-memory\r\n...\r\n```\r\n\r\nA related failure mode: you have to first project to include the augmented column, you can't just include it in a filter:\r\n\r\n```Java\n\r\nInMemoryDataset$create(mtcars) %>%\r\n  filter(add_filename() == \"in-memory\") %>%\r\n  collect()\r\n#> Error in `collect()`:\r\n#> ! Invalid: No match for FieldRef.Name(__filename) in mpg: double\r\n#> cyl: double\r\n#> disp: double\r\n#> hp: double\r\n#> drat: double\r\n#> wt: double\r\n#> qsec: double\r\n#> vs: double\r\n#> am: double\r\n#> gear: double\r\n#> carb: double\r\n#> \u2139 `add_filename()` or use of the `__filename` augmented field can only be used with with Dataset objects, and can only be added before doing an aggregation or a join.\r\n\r\n#> Backtrace:\r\n#>      \u2586\r\n#>   1. \u251c\u2500... %>% collect()\r\n#>   2. \u251c\u2500dplyr::collect(.)\r\n#>   3. \u2514\u2500arrow:::collect.arrow_dplyr_query(.)\r\n#>   4.   \u2514\u2500base::tryCatch(...)\r\n#>   5.     \u2514\u2500base (local) tryCatchList(expr, classes, parentenv, handlers)\r\n#>   6.       \u2514\u2500base (local) tryCatchOne(expr, names, parentenv, handlers[[1L]])\r\n#>   7.         \u2514\u2500value[[3L]](cond)\r\n#>   8.           \u2514\u2500arrow:::augment_io_error_msg(e, call, schema = x$.data$schema)\r\n#>   9.             \u2514\u2500arrow:::handle_augmented_field_misuse(msg, call)\r\n#>  10.               \u2514\u2500rlang::abort(msg, call = call)\r\n```\r\n\r\nIssue #2, following on that: you can only add the augmented fields at the start of the query, something that goes in the ScanNode. This seems like something we would have to catch in R and error at the time add_filename() is called. That could probably be covered in ARROW-17356.\r\n\r\n```Java\n\r\nInMemoryDataset$create(mtcars) %>%\r\n  collapse() %>%\r\n  collapse() %>%\r\n  filter(add_filename() == \"in-memory\") %>%\r\n  collect()\r\n#> Error in `collect()`:\r\n#> ! Invalid: No match for FieldRef.Name(__filename) in mpg: double\r\n#> cyl: double\r\n#> disp: double\r\n#> hp: double\r\n#> drat: double\r\n#> wt: double\r\n#> qsec: double\r\n#> vs: double\r\n#> am: double\r\n#> gear: double\r\n#> carb: double\r\n#> \u2139 `add_filename()` or use of the `__filename` augmented field can only be used with with Dataset objects, and can only be added before doing an aggregation or a join.\r\n\r\n#> Backtrace:\r\n#>      \u2586\r\n#>   1. \u251c\u2500... %>% collect()\r\n#>   2. \u251c\u2500dplyr::collect(.)\r\n#>   3. \u2514\u2500arrow:::collect.arrow_dplyr_query(.)\r\n#>   4.   \u2514\u2500base::tryCatch(...)\r\n#>   5.     \u2514\u2500base (local) tryCatchList(expr, classes, parentenv, handlers)\r\n#>   6.       \u2514\u2500base (local) tryCatchOne(expr, names, parentenv, handlers[[1L]])\r\n#>   7.         \u2514\u2500value[[3L]](cond)\r\n#>   8.           \u2514\u2500arrow:::augment_io_error_msg(e, call, schema = x$.data$schema)\r\n#>   9.             \u2514\u2500arrow:::handle_augmented_field_misuse(msg, call)\r\n#>  10.               \u2514\u2500rlang::abort(msg, call = call)\r\n```",
        "created_at": "2022-11-08T14:30:45.000Z",
        "updated_at": "2022-11-08T14:30:45.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Component: R",
            "Type: bug"
        ],
        "closed": false
    },
    "comments": []
}