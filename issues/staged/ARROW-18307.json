{
    "issue": {
        "title": "[C++] Read list/array data from ChunkedArray with multiple chunks",
        "body": "***Note**: This issue was originally created as [ARROW-18307](https://issues.apache.org/jira/browse/ARROW-18307). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nI am reading a parquet file with arrow::RecordBatchReader and the arrow::Table returned contains columns with multiple chunks (column->num_chunks() > 1). The column in question, although not limited to, is of type Array(Int64).\r\n\r\n\u00a0\r\n\r\nI want to convert this arrow column into an internal structure that contains a contiguous chunk of memory for the data and a vector of offsets, very similar to arrow's structure. The code I have so far works in two \"phases\":\r\n\r\n1. Get nested arrow column data. In that case, get Int64 data out of Array(Int64).\r\n2. Get offsets from Array(Int64).\r\n\r\nTo achieve the #1, I am looping over the chunks and storing arrow::Array::values into a new arrow::ChunkedArray.\r\n\r\n\u00a0\r\n```java\n\r\nstatic std::shared_ptr<arrow::ChunkedArray> getNestedArrowColumn(std::shared_ptr<arrow::ChunkedArray> & arrow_column)\r\n{\r\narrow::ArrayVector array_vector;\r\narray_vector.reserve(arrow_column->num_chunks());\r\nfor (size_t chunk_i = 0, num_chunks = static_cast<size_t>(arrow_column->num_chunks()); chunk_i < num_chunks; ++chunk_i)\r\n{\r\narrow::ListArray & list_chunk = dynamic_cast<arrow::ListArray &>(*(arrow_column->chunk(chunk_i)));\r\nstd::shared_ptr<arrow::Array> chunk = list_chunk.values();\r\narray_vector.emplace_back(std::move(chunk));\r\n}\r\nreturn std::make_shared<arrow::ChunkedArray>(array_vector);\r\n}\n```\r\nThis does not work as expected, tho. Even though there are multiple chunks, the arrow::Array::values method returns the very same buffer for all of them, which ends up duplicating the data on my side. One pattern I noticed is that if I read only the Array(Int64) column, I get only one chunk. If I read both columns, I get two chunks. It looks like all columns will, inevitably, have the same number of chunks, even though its buffer is not chunked accordingly.\r\n\r\nI then looked through more examples and came across the [ColumnarTableToVector example](https://github.com/apache/arrow/blob/master/cpp/examples/arrow/row_wise_conversion_example.cc#L121). It looks like this example assumes there is only on chunk and ignores the possibility of it having multiple chunks. It's probably just a detail and the test wasn't actually intended to cover multiple chunks.\r\n\r\nI managed to get the expected output doing something like the below:\r\n```java\n\r\nauto & list_chunk1 = dynamic_cast<::arrow::ListArray &>(*(arrow_column->chunk(0)));\r\nauto & list_chunk2 = dynamic_cast<::arrow::ListArray &>(*(arrow_column->chunk(1)));\r\n\r\nauto l1_offset = *list_chunk1.raw_value_offsets();\r\nauto l2_offset = *list_chunk2.raw_value_offsets();\r\n\r\nauto l1_end_offset = list_chunk1.value_offset(list_chunk1.data()->length);\r\nauto l2_end_offset = list_chunk2.value_offset(list_chunk2.data()->length);\r\n\r\nauto lcv1 = dynamic_cast<::arrow::ListArray &>(*(arrow_column->chunk(0))).values()->SliceSafe(l1_offset, l1_end_offset - l1_offset).ValueOrDie();\r\nauto lcv2 = dynamic_cast<::arrow::ListArray &>(*(arrow_column->chunk(1))).values()->SliceSafe(l2_offset, l2_end_offset - l2_offset).ValueOrDie();\n```\r\nThis looks too hackish and I feel like there is a much better way.\r\n\r\nHence, my question: How do I properly extract the data & offsets out of such column? A more generic version of this is: how to extract the data out of ChunkedArrays with multiple chunks?",
        "created_at": "2022-11-10T20:37:46.000Z",
        "updated_at": "2022-11-11T13:42:48.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Type: test"
        ],
        "closed": false
    },
    "comments": []
}