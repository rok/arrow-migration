{
    "issue": {
        "title": "[C++][R] r-autobrew nightly failing with 'caught illegal operation'",
        "body": "***Note**: This issue was originally created as [ARROW-14707](https://issues.apache.org/jira/browse/ARROW-14707). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\n[Full log](https://github.com/ursacomputing/crossbow/runs/4197210588?check_suite_focus=true):\r\n```\n\r\n> library(tibble)\r\n> \r\n> if (identical(tolower(Sys.getenv(\"ARROW_R_DEV\", \"false\")), \"true\")) {\r\n+   arrow_reporter <- MultiReporter$new(list(CheckReporter$new(), LocationReporter$new()))\r\n+ } else {\r\n+   arrow_reporter <- check_reporter()\r\n+ }\r\n> test_check(\"arrow\", reporter = arrow_reporter)\r\n\r\n *** caught illegal operation ***\r\naddress 0x10f68cc40, cause 'illegal opcode'\r\n\r\nTraceback:\r\n 1: compute__CallFunction(function_name, args, options)\r\n 2: call_function(\"filter\", self, i, options = list(keep_na = keep_na))\r\n 3: x$Filter(i, keep_na)\r\n 4: `[.ArrowDatum`(a, rep(c(TRUE, FALSE), 5))\r\n 5: a[rep(c(TRUE, FALSE), 5)]\r\n 6: as.vector(x)\r\n 7: inherits(object, \"ArrowObject\")\r\n 8: expect_equal(as.vector(x), y, ...)\r\n 9: expect_as_vector(a[rep(c(TRUE, FALSE), 5)], vec[c(1, 3, 5, 7,     9)])\r\n10: eval(code, test_env)\r\n11: eval(code, test_env)\r\n12: withCallingHandlers({    eval(code, test_env)    if (!handled && !is.null(test)) {        skip_empty()    }}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,     message = handle_message, error = handle_error)\r\n13: doTryCatch(return(expr), name, parentenv, handler)\r\n14: tryCatchOne(expr, names, parentenv, handlers[[1L]])\r\n15: tryCatchList(expr, names[-nh], parentenv, handlers[-nh])\r\n16: doTryCatch(return(expr), name, parentenv, handler)\r\n17: tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]),     names[nh], parentenv, handlers[[nh]])\r\n18: tryCatchList(expr, classes, parentenv, handlers)\r\n19: tryCatch(withCallingHandlers({    eval(code, test_env)    if (!handled && !is.null(test)) {        skip_empty()    }}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,     message = handle_message, error = handle_error), error = handle_fatal,     skip = function(e) {    })\r\n20: test_code(desc, code, env = parent.frame(), reporter = reporter)\r\n21: testthat::test_that(what, {    skip_if(getOption(\"..skip.tests\", TRUE), \"arrow C++ library not available\")    code})\r\n22: test_that(\"[ method on Array\", {    vec <- 11:20    a <- Array$create(vec)    expect_as_vector(a[5:9], vec[5:9])    expect_as_vector(a[c(9, 3, 5)], vec[c(9, 3, 5)])    expect_as_vector(a[rep(c(TRUE, FALSE), 5)], vec[c(1, 3, 5,         7, 9)])    expect_as_vector(a[rep(c(TRUE, FALSE, NA, FALSE, TRUE), 2)],         c(11, NA, 15, 16, NA, 20))    expect_as_vector(a[-4], vec[-4])    expect_as_vector(a[-1], vec[-1])})\r\n23: eval(code, test_env)\r\n24: eval(code, test_env)\r\n25: withCallingHandlers({    eval(code, test_env)    if (!handled && !is.null(test)) {        skip_empty()    }}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,     message = handle_message, error = handle_error)\r\n26: doTryCatch(return(expr), name, parentenv, handler)\r\n27: tryCatchOne(expr, names, parentenv, handlers[[1L]])\r\n28: tryCatchList(expr, names[-nh], parentenv, handlers[-nh])\r\n29: doTryCatch(return(expr), name, parentenv, handler)\r\n30: tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]),     names[nh], parentenv, handlers[[nh]])\r\n31: tryCatchList(expr, classes, parentenv, handlers)\r\n32: tryCatch(withCallingHandlers({    eval(code, test_env)    if (!handled && !is.null(test)) {        skip_empty()    }}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,     message = handle_message, error = handle_error), error = handle_fatal,     skip = function(e) {    })\r\n33: test_code(NULL, exprs, env)\r\n34: source_file(path, child_env(env), wrap = wrap)\r\n35: FUN(X[[i]], ...)\r\n36: lapply(test_paths, test_one_file, env = env, wrap = wrap)\r\n37: doTryCatch(return(expr), name, parentenv, handler)\r\n38: tryCatchOne(expr, names, parentenv, handlers[[1L]])\r\n39: tryCatchList(expr, classes, parentenv, handlers)\r\n40: tryCatch(code, testthat_abort_reporter = function(cnd) {    cat(conditionMessage(cnd), \"\\n\")    NULL})\r\n41: with_reporter(reporters$multi, lapply(test_paths, test_one_file,     env = env, wrap = wrap))\r\n42: test_files(test_dir = test_dir, test_package = test_package,     test_paths = test_paths, load_helpers = load_helpers, reporter = reporter,     env = env, stop_on_failure = stop_on_failure, stop_on_warning = stop_on_warning,     wrap = wrap, load_package = load_package)\r\n43: test_files(test_dir = path, test_paths = test_paths, test_package = package,     reporter = reporter, load_helpers = load_helpers, env = env,     stop_on_failure = stop_on_failure, stop_on_warning = stop_on_warning,     wrap = wrap, load_package = load_package, parallel = parallel)\r\n44: test_dir(\"testthat\", package = package, reporter = reporter,     ..., load_package = \"installed\")\r\n45: test_check(\"arrow\", reporter = arrow_reporter)\r\nAn irrecoverable exception occurred. R is aborting now ...\r\n```",
        "created_at": "2021-11-13T18:48:00.000Z",
        "updated_at": "2022-07-29T18:37:37.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Component: R",
            "Type: bug"
        ],
        "closed": true,
        "closed_at": "2021-11-23T21:34:13.000Z"
    },
    "comments": [
        {
            "created_at": "2021-11-15T13:03:08.572Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14707?focusedCommentId=17443812) by David Li (lidavidm):*\nStill occuring on 2021/11/15: <https://github.com/ursacomputing/crossbow/runs/4208123248?check_suite_focus=true>"
        }
    ]
}