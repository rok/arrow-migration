{
    "issue": {
        "title": "how to do resampling of arrow table using cython",
        "body": "***Note**: This issue was originally created as [ARROW-13939](https://issues.apache.org/jira/browse/ARROW-13939). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nPlease can someone point me to resources, how to write a resampling code in cython for Arrow table.\r\n1. Will iterating the whole table be slow in cython?\n1. which is the best to use to append new elements to. Is there a way i create an empty table of same schema and keep appending to it. Or should I use vectors/list and then pass them to create a table.\n   \n   Performance is very important for me. Any help is highly appreciated.",
        "created_at": "2021-09-08T19:33:22.000Z",
        "updated_at": "2021-09-13T22:12:41.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Component: Python",
            "Type: enhancement"
        ],
        "closed": false
    },
    "comments": [
        {
            "created_at": "2021-09-09T02:45:09.146Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-13939?focusedCommentId=17412298) by Will Jones (willjones127):*\nHi Krishna,\r\n\r\nCould you provide an example of what you mean by \"resampling\"? Are you trying to create a new table that is a subset of rows of the existing table? Or do you mean time series resampling like in Pandas DataFrame.resample?\r\n\r\n> Is there a way i create an empty table of same schema and keep appending to it. Or should I use vectors/list and then pass them to create a table.\r\n\r\nArrow tables aren't meant to be appended row-wise. You can build the arrays and then create a table out of them.\r\n"
        },
        {
            "created_at": "2021-09-09T09:45:32.687Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-13939?focusedCommentId=17412481) by krishna deepak (krsna):*\nHi Will,\r\n\r\nYes, resampling timeseries table, eg 1min buckets to 5 min buckets table etc. Same as dataframe.resample. Does arrow provide this functionality already?\r\n\r\n\r\nSo how to go about iterating the table. from documentation all I could use is only **Slice**\u00a0function. But does not feel like a proper iterator of sorts. Is there anything better to iterate properly?\r\n\r\nBy \"build arrays\", you mean arrow chunkedarrays, arraybuilders or cpp vectors?\r\n\r\n\u00a0\r\n\r\nThanks\r\n\r\n\u00a0\r\n\r\n\u00a0"
        },
        {
            "created_at": "2021-09-09T18:56:28.631Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-13939?focusedCommentId=17412781) by krishna deepak (krsna):*\nPlease can you tell, what's the time complexity of cpp Slice function, and pyarrow table[x:y]?"
        },
        {
            "created_at": "2021-09-09T19:18:41.954Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-13939?focusedCommentId=17412791) by Weston Pace (westonpace):*\nThe slice function should be O(1).  It does not actually copy memory or create a new array.  It simply creates a new view of the same data.  The same goes for \"table[x:y]\" which calls slice under the hood."
        },
        {
            "created_at": "2021-09-10T14:47:10.113Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-13939?focusedCommentId=17413224) by krishna deepak (krsna):*\n`[~westonpace]` `[~willjones127]`\r\n\r\nPlease can you go through my second question about iterating the arrow table in cython?\r\n\r\n\u00a0\r\n\r\n\u00a0"
        },
        {
            "created_at": "2021-09-10T14:54:18.330Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-13939?focusedCommentId=17413228) by krishna deepak (krsna):*\nI tried the following to start with \r\n```python\n\r\n\r\n    cdef shared_ptr[CTable] table = pyarrow_unwrap_table(obj)\r\n    cdef CTable *table_ptr = table.get()\r\n    cdef list timeframes = [3, 5, 15]\r\n\r\n    if table_ptr == NULL:\r\n        raise TypeError(\"not an array\")\r\n\r\n    cdef CChunkedArray *column1\r\n    cdef CChunkedArray *column2\r\n    cdef CArray *array1\r\n    cdef CArray *array2\r\n    cdef int num_rows = table_ptr.num_rows()\r\n    cdef shared_ptr[CSchema] schema = table_ptr.schema()\r\n\r\n    cdef CResult[shared_ptr[CScalar]] val\r\n\r\n    column1 = table_ptr.column(0).get()\r\n    column2 = table_ptr.column(1).get()\r\n\r\n    chunk_i = 0\r\n    while True:\r\n        array1 = column1.chunk(chunk_i).get()\r\n\r\n        if array1 == NULL:\r\n            break\r\n\r\n        length = array1.length()\r\n        val = array1.GetScalar(0)\r\n        if val.ok():\r\n            val.ValueOrDie()\r\n```\r\n\r\nThis gives the following error upon compiling\r\n\r\n\r\n```java\n\r\nObject of type 'CResult[shared_ptr[CScalar]]' has no attribute 'ValueOrDie'\r\n```\r\n\r\nContradictory to the documentation. \r\n\r\n`[~willjones127]` `[~westonpace]`"
        },
        {
            "created_at": "2021-09-10T19:08:09.172Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-13939?focusedCommentId=17413344) by Weston Pace (westonpace):*\nHmm, I'm not sure what documentation you are referring to.  If you are looking at the C++ documentation then the Cython API does not fully mirror the C++ API.  In other words, CResult does not have every method that Result has.  If you want the value from a result the proper thing to do is GetResultValue(val) which will check the status of the result and, if valid, returns the value.  If it isn't valid, it converts the invalid status into the appropriate python exception and raises it.\r\n\r\n> Will iterating the whole table be slow in cython?\r\n\r\nIf you are going through every value with GetScalar then yes, it probably will be but I don't know for sure.  Ideally, if you want to process every value, you will want to get access to the raw buffers and operate on them.  Can you give an example of the transformation you want to do?  Your best bet might be to create compute kernels in C++ to do the manipulation you desire and then call those kernel functions from python.\r\n\r\n> which is the best to use to append new elements to. Is there a way i create an empty table of same schema and keep appending to it. Or should I use vectors/list and then pass them to create a table.\r\n\r\nWhere are these elements coming from?  For example, if you are receiving them already in python (via some on_new_event method or something) then a simple and reasonably efficient approach would be to just gather them in a python list and, when the list is large enough, convert the list to an arrow array.  If the elements you are receiving are in C++ then you probably don't want to marshal them to python and add them to a python list.  Using the C++ array builders would be a better choice."
        },
        {
            "created_at": "2021-09-11T06:15:23.656Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-13939?focusedCommentId=17413477) by krishna deepak (krsna):*\n`[~westonpace]` \r\n\r\nThanks this is very helpful,\r\n\r\nRegarding documentation, it makes sense. But then, the cython documentation is single page with not much useful info. The function\r\n```java\n\r\n\u00a0GetResultValue(val)\n```\r\nis no where to be found.\r\nI'm still stuck after using this. It outputs a 'shared_ptr[CScalar]' and therefore 'CScalar \\*'. But still stuck with extracting value out of it. \r\nlets say i know that its of IntScalar, how to extract it int a = doSomethingOnCResult(val)\r\n\r\n---------------------------------------------------------------------------------------------------------------------------------------------------------------\r\nWhat im trying to do is converting data from [[11:01, 3], [11:02,4], [11:03:,2], [11:04,1], [11:05, 3], [11:06,6]] to [[11:03:3], [11:06:6]], just resampling 1 min data to 3min data. Here the transformation function was max of all values\r\nSo I have to iterate through all values.\r\n> Your best bet might be to create compute kernels in C++ to do the manipulation you desire and then call those kernel functions from python.\r\nI believe this resembles to what i'm doing, having this resampling code in Cython. If I'm wrong please let me know.\r\n\r\n> if you want to process every value, you will want to get access to the raw buffers and operate on them.\r\nI have no idea how to do this. Please can you point me to some resources.\r\n\r\n---------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n> Where are these elements coming from?\r\nEverything is in cython. so I pass my larger table from python to cython resampling function. This function iterates over the whole table and builds a new table as it iterates. \r\nMy plan is to use cpp vector to build individual columns and pass it to Arrow Table constructor and then return back to python .\r\n\r\n"
        },
        {
            "created_at": "2021-09-13T22:11:59.325Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-13939?focusedCommentId=17414611) by Weston Pace (westonpace):*\n> the cython documentation is single page with not much useful info.\r\n\r\nPRs are always welcome.\r\n\r\n> lets say i know that its of IntScalar, how to extract it int a = doSomethingOnCResult(val)\r\n\r\nScalar's have an \"as_py\" method.  You can inspect that to see how it is working in Cython.\r\n\r\n>  I believe this resembles to what i'm doing, having this resampling code in Cython. If I'm wrong please let me know.\r\n\r\nYou are not wrong, but no one else is doing this in Cython so you will need to come up with a lot of functionality yourself and it will be a considerable amount of work.  The pyarrow philosophy has been to keep all array manipulation in cpp.  The existing Cython code is pretty much limited to metadata manipulation.  The easiest path forward (in terms of man-hours of effort) is likely to be extending Arrow-cpp.  Alternatively, you could investigate if something like this is supported by datafusion.  There is some initial support for python bindings for datafusion in development.  I do believe that these kinds of functions will come to Arrow-cpp (and thus pyarrow) someday but I can't give you any kind of estimate as there is no open JIRA ticket for them. \r\n\r\n>  I have no idea how to do this. Please can you point me to some resources.\r\n\r\n- To access an Array's buffers in python (as a bytes object) you can do arr.buffers()[buffer_index].to_pybytes()\n- To access an Array's buffers in cython you can do something similar but the method to call on the buffer is \"data()\" (for const uint8_t\\*) or \"mutable_data()\" (for uint8_t\\*)\n  \n  The format of these buffers is described in the [Arrow Columnar Format](https://arrow.apache.org/docs/format/Columnar.html) and advice on how to manipulate them is beyond the scope of a JIRA issue.\n  \n  > Everything is in cython. so I pass my larger table from python to cython resampling function.\n  \n  It sounds like your starting data is a pyarrow \"Table\" and so the data will be in C++ (there are no python objects for the individual array elements).  You will probably want to use the [array builders](https://arrow.apache.org/docs/cpp/api/builder.html) to build up your result API but I do not believe there is any Cython API for these.\n"
        }
    ]
}