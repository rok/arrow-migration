{
    "issue": {
        "title": "[R] Allow functions with {{pkg::}} prefixes",
        "body": "***Note**: This issue was originally created as [ARROW-14575](https://issues.apache.org/jira/browse/ARROW-14575). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\n{**}Proposed approach{**}:\r\n \\* add functionality to allow binding registration with the `pkg::fun()` name;\r\n \\*\\* Modify register_binding() to register 2 identical copies for each pkg::fun binding, fun and pkg::fun.\r\n \\*\\* Add a binding for the :: operator, which helps with retrieving bindings from the function registry.\r\n \\*\\* Add generic unit tests for the pkg::fun functionality.\r\n \\* register `nse_funcs` requiring indirect mapping\r\n\\*\\* register each binding with and without the pkg:: prefix\r\n\\*\\* add / update unit tests for the nse_funcs bindings to include at least one pkg::fun() call for each binding\r\n \\* register `nse_funcs` requiring direct mapping (unary and binary bindings)\r\n\\*\\* register each binding with and without the pkg:: prefix\r\n\\*\\* add / update unit tests for the nse_funcs bindings to include at least one pkg::fun() call for each binding\r\n- register `agg_funcs` for use with `summarise()`\n   \\* document changes in the _Writing bindings_ documentation\n  - going forward we should be using pkg::fun when defining a binding, which will register 2 copies of the same binding.\n    \n    Different implementation options are outlined and discussed in the [design document](https://docs.google.com/document/d/1Om-vYb31b6p_u4tyl86SGW1DrtWBfksq8NYG1Seqaxg/edit?usp=sharing).\n    \n    {**}Description{**}:\n    Currently we implement a number of functions from packages like `lubridate` which work well when called without namespacing (e.g. `{}year(){`}), however if someone calls `lubridate::year()` we get a not-implemented method (e.g. `{}Warning: Expression lubridate::year(time_hour) not supported in Arrow{`}). Is it possible for us to look and see if we have an arrow function that matches the function itself.\n    {code:r}\n    library(arrow, warn.conflicts = FALSE)\n    library(dplyr, warn.conflicts = FALSE)\n    \n    ds <- InMemoryDataset$create(nycflights13::flights)\n    \n    ds %>% \n      mutate(year = lubridate::year(time_hour)) %>%\n      collect()\n#> Warning: Expression lubridate::year(time_hour) not supported in Arrow; pulling\r\n#> data into R\r\n#> # A tibble: 336,776 \u00d7 19\r\n#>     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r\n#>    <dbl> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\r\n#>  1  2013     1     1      517            515         2      830            819\r\n#>  2  2013     1     1      533            529         4      850            830\r\n#>  3  2013     1     1      542            540         2      923            850\r\n#>  4  2013     1     1      544            545        -1     1004           1022\r\n#>  5  2013     1     1      554            600        -6      812            837\r\n#>  6  2013     1     1      554            558        -4      740            728\r\n#>  7  2013     1     1      555            600        -5      913            854\r\n#>  8  2013     1     1      557            600        -3      709            723\r\n#>  9  2013     1     1      557            600        -3      838            846\r\n#> 10  2013     1     1      558            600        -2      753            745\r\n#> # \u2026 with 336,766 more rows, and 11 more variables: arr_delay <dbl>,\r\n#> #   carrier <chr>, flight <int>, tailnum <chr>, origin <chr>, dest <chr>,\r\n#> #   air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>\r\n\r\nds %>% \r\n  mutate(year = year(time_hour)) %>%\r\n  collect()\r\n#> # A tibble: 336,776 \u00d7 19\r\n#>     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r\n#>    <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\r\n#>  1  2013     1     1      517            515         2      830            819\r\n#>  2  2013     1     1      533            529         4      850            830\r\n#>  3  2013     1     1      542            540         2      923            850\r\n#>  4  2013     1     1      544            545        -1     1004           1022\r\n#>  5  2013     1     1      554            600        -6      812            837\r\n#>  6  2013     1     1      554            558        -4      740            728\r\n#>  7  2013     1     1      555            600        -5      913            854\r\n#>  8  2013     1     1      557            600        -3      709            723\r\n#>  9  2013     1     1      557            600        -3      838            846\r\n#> 10  2013     1     1      558            600        -2      753            745\r\n#> # \u2026 with 336,766 more rows, and 11 more variables: arr_delay <dbl>,\r\n#> #   carrier <chr>, flight <int>, tailnum <chr>, origin <chr>, dest <chr>,\r\n#> #   air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>\r\n{code}",
        "created_at": "2021-11-03T14:02:18.000Z",
        "updated_at": "2022-07-20T11:38:14.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: R",
            "Type: bug"
        ],
        "closed": true,
        "closed_at": "2022-07-15T21:23:54.000Z"
    },
    "comments": [
        {
            "created_at": "2021-11-03T15:35:15.138Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14575?focusedCommentId=17438151) by Neal Richardson (npr):*\nWe could pre-process the expression/quosure and remove any `::`, though that might not be safe? We could also include an allowlist/mapping of functions we would do this for (e.g. `list(lubridate = c(\"year\", \"month\", ...), dplyr = c(\"case_when\", \"n\", ...), stringr = c(\"str_stuff\", ...))`. \r\n"
        },
        {
            "created_at": "2021-11-03T15:45:46.332Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14575?focusedCommentId=17438159) by Jonathan Keane (jonkeane):*\nYeah, there is certainly some edgecases/unsafeness that we need to consider. Though hard-coding is frustrating, the allowlist would make it explicit what our intention is with the binding. I wonder if it is possible to mask with the {pkg::} included so that we would get the right behavior if someone had a custom-defined function that collides with a function we have made a binding for (e.g. I've defined a custom `year()` in my code, I know that that will mask lubridate's `year()`, so I put `lubridate::year()` in all my pipelines, but sometimes need to / want to call my custom year \u2014 this wouldn't (possibly) work until ARROW-14071 anyway). \r\n\r\nGetting the execution exactly right and being able to select the right `year()` here is probably less important than erroring loudly and not using the bindings version when that's not what dplyr would do in that case. Though I will say that I have definitely seen things like this and worse in actuality!"
        },
        {
            "created_at": "2021-11-03T20:11:36.997Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14575?focusedCommentId=17438279) by Dewey Dunnington (paleolimbot):*\nIt might be nice for clarity to register the package name with the function (i.e., `arrow_register_translation(\"year\", function(...) {}, package = \"lubridate\")` instead of `nse_funcs$year <- function(...) {}`. \r\n\r\nErroring out could look like this (only slightly better than the current error, though).\r\n```\n\r\nlibrary(arrow, warn.conflicts = FALSE)\r\nlibrary(dplyr, warn.conflicts = FALSE)\r\n\r\nds <- InMemoryDataset$create(nycflights13::flights)\r\nfuns <- arrow:::.cache$functions\r\nfuns[[\"::\"]] <- function(lhs, rhs) {\r\n  arrow:::arrow_not_supported(\"`::`\")\r\n}\r\n\r\nassign(\"functions\", funs, envir = arrow:::.cache)\r\nds %>% \r\n  mutate(year = lubridate::year(time_hour)) %>%\r\n  collect()\r\n#> Warning: In lubridate::year(time_hour), `::` not supported by Arrow; pulling\r\n#> data into R\r\n#> # A tibble: 336,776 \u00d7 19\n```\r\nA slightly different definition of `::` could ignore it with a warning, although this is possibly a bit too magical.\r\n```\n\r\nlibrary(arrow, warn.conflicts = FALSE)\r\nlibrary(dplyr, warn.conflicts = FALSE)\r\n\r\nds <- InMemoryDataset$create(nycflights13::flights)\r\nfuns <- arrow:::.cache$functions\r\n\r\nfuns[[\"::\"]] <- function(lhs, rhs) {\r\n# already evaluated to an Expression?\r\n  rhs <- rhs$field_name\r\n  warning(paste0(\"Replacing `\", as.character(substitute(lhs)), \"::\", rhs, \"` with `\", rhs, \"`\"))\r\n  get(rhs, envir = parent.frame(), mode = \"function\")\r\n}\r\n\r\nassign(\"functions\", funs, envir = arrow:::.cache)\r\nds %>% \r\n  mutate(year = lubridate::year(time_hour)) %>%\r\n  collect()\r\n#> Warning in lubridate::year: Replacing `lubridate::year` with `year`\r\n#> # A tibble: 336,776 \u00d7 19\r\n#>     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\r\n#>    <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\r\n#>  1  2013     1     1      517            515         2      830            819\r\n#>  2  2013     1     1      533            529         4      850            830\r\n#>  3  2013     1     1      542            540         2      923            850\r\n#>  4  2013     1     1      544            545        -1     1004           1022\r\n#>  5  2013     1     1      554            600        -6      812            837\r\n#>  6  2013     1     1      554            558        -4      740            728\r\n#>  7  2013     1     1      555            600        -5      913            854\r\n#>  8  2013     1     1      557            600        -3      709            723\r\n#>  9  2013     1     1      557            600        -3      838            846\r\n#> 10  2013     1     1      558            600        -2      753            745\r\n#> # \u2026 with 336,766 more rows, and 11 more variables: arr_delay <dbl>,\r\n#> #   carrier <chr>, flight <int>, tailnum <chr>, origin <chr>, dest <chr>,\r\n#> #   air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>\n```\r\n\u00a0\r\n\r\n\u00a0"
        },
        {
            "created_at": "2021-11-08T20:29:14.712Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14575?focusedCommentId=17440738) by Dewey Dunnington (paleolimbot):*\nA few ideas related to this that may or may not help organize the increasing set of functions from different packages.\r\n\r\nTranslations for specific packages as R6 classes? Advantage here just that we get documentation that isn\u2019t checked by CRAN for free. \r\n\r\n```R\n\r\nBaseTranslations <- R6::R6Class(\r\n  \"BaseTranslations\",\r\n  public = list(\r\n    \r\n    #' Arrow compute translation for `base::sum()`\r\n    #' \r\n    #' @param x A field reference or scalar\r\n    sum = function(x) {\r\n      arrow::Expression$create(\r\n        \"sum\",\r\n        if (inherits(x, \"Expression\")) x else sum(x)\r\n      )\r\n    }\r\n  )\r\n)\r\n```\r\n\r\n...and a totally untested interface for keeping track of function translations from multiple packages.\r\n\r\nHelper to detect the package that a user intended based on their current search path \r\n\r\n```R\n\r\ndetect_package_name <- function(name, env = parent.frame()) {\r\n  tryCatch({\r\n    obj <- get(name, env = env, mode = \"function\", inherits = TRUE)\r\n    obj_env <- environment(obj)\r\n    if (is.null(obj_env)) {\r\n      \"base\"\r\n    } else if (\".packageName\" %in% names(obj_env)) {\r\n      obj_env$.packageName\r\n    } else {\r\n      NULL\r\n    }\r\n  }, error = function(e) {\r\n    NULL\r\n  })\r\n}\r\n```\r\n\r\n\r\nUsing R6 for my basic implementation of a function registry that includes the intended package for a translation. These can be stacked and recombined similar to how environments can be stacked and combined so that each set of translations can have a limited scope. \r\n\r\n```R\n\r\nTranslationRegistry <- R6::R6Class(\r\n  \"TranslationRegistry\",\r\n  public = list(\r\n    initialize = function(parent = NULL) {\r\n      private$parent <- parent\r\n      private$functions <- new.env(parent = emptyenv())\r\n      private$functions$`_all_functions` <- new.env(parent = emptyenv())\r\n    },\r\n\r\n    register_translation = function(name, fun, package = NULL, env = parent.frame()) {\r\n      if (is.null(package)) {\r\n        package <- detect_package_name(name)\r\n      }\r\n\r\n      if (!is.null(package) && !(package %in% names(private$functions))) {\r\n        private$functions[[package]] <- new.env(parent = emptyenv())\r\n      }\r\n\r\n      if (!is.null(package)) {\r\n        private$functions[[package]][[name]] <- fun\r\n      }\r\n\r\n      private$functions$`_all_functions`[[name]] <- fun\r\n\r\n      invisible(self)\r\n    },\r\n\r\n    get_translation = function(name, package = NULL, env = parent.frame()) {\r\n      if (is.null(package)) {\r\n        package_det <- detect_package_name(name, env = env)\r\n      } else {\r\n        package_det <- package\r\n      }\r\n\r\n      if (is.null(package_det)) {\r\n        package_det <- \"_all_functions\"\r\n      }\r\n\r\n      if (is.null(private$parent)) {\r\n        tryCatch(get(name, envir = get(package_det, envir = private$functions)), error = function(e) {\r\n          self$abort_function_not_found(name, package)\r\n        })\r\n      } else {\r\n        tryCatch(\r\n          get(name, envir = get(package_det, envir = private$functions)),\r\n          error = function(e) private$parent$get_translation(name, package = package, env = env)\r\n        )\r\n      }\r\n    },\r\n\r\n    with_search = function(order = search()) {\r\n      order <- rev(intersect(gsub(\"package:\", \"\", order), names(private$functions)))\r\n      funs_with_pkg <- unlist(\r\n        lapply(\r\n          setdiff(names(order), \"_all_functions\"),\r\n          function(pkg) names(private$functions[[pkg]])\r\n        )\r\n      )\r\n      funs_without_pkg <- setdiff(names(private$functions$`_all_functions`), funs_with_pkg)\r\n\r\n      out_names <- c(funs_without_pkg, funs_with_pkg)\r\n      out <- vector(\"list\", length(out_names))\r\n      names(out) <- out_names\r\n\r\n      i <- 1L\r\n      for (pkg in order) {\r\n        for (name in names(private$functions[[pkg]])) {\r\n          out[[i]] <-  private$functions[[pkg]][[name]]\r\n          i <- i + 1L\r\n        }\r\n      }\r\n\r\n      out\r\n    },\r\n\r\n    abort_function_not_found = function(name, package) {\r\n      if (is.null(package)) {\r\n        msg <- glue::glue(\"No translations registered for function `{ name }()`\")\r\n      } else if (!(package %in% names(private$functions))) {\r\n        msg <- glue::glue(\"No translations registered for package '{ package }'\")\r\n      } else {\r\n        msg <- glue::glue(\"No translations registered for function `{ package }::{ name }()`\")\r\n      }\r\n\r\n      rlang::abort(msg , class = \"function_not_found\")\r\n    }\r\n  ),\r\n\r\n  private = list(\r\n    parent = NULL,\r\n    functions = NULL\r\n  )\r\n)\r\n```\r\n\r\n\r\nIn practice this would be an under-the-hood thing accessed by regular functions \r\n\r\n```R\n\r\ntranslations <- TranslationRegistry$new()\r\nregister_translation <- function(name, fun, package = NULL, env = parent.frame()) {\r\n  translations$register_translation(name, fun, package = package, env = env)\r\n}\r\nget_translation <- function(name, package = NULL, env = parent.frame()) {\r\n  translations$get_translation(name, package = package, env = env)\r\n}\r\ntranslations_with_search <- function(order = search()) {\r\n  translations$with_search(order)\r\n}\r\n```\r\n\r\n\r\nThe basic idea is that you can register some functions and get a decent error when requesting one that doesn\u2019t exist. \r\n\r\n```R\n\r\nregister_translation(\"sum\", function(x) {\r\n  arrow::Expression$create(\r\n    \"sum\",\r\n    if (inherits(x, \"Expression\")) x else sum(x)\r\n  )\r\n})\r\n\r\nget_translation(\"sum\")\r\n#> function(x) {\r\n#>   arrow::Expression$create(\r\n#>     \"sum\",\r\n#>     if (inherits(x, \"Expression\")) x else sum(x)\r\n#>   )\r\n#> }\r\nget_translation(\"sum\", package = \"base\")\r\n#> function(x) {\r\n#>   arrow::Expression$create(\r\n#>     \"sum\",\r\n#>     if (inherits(x, \"Expression\")) x else sum(x)\r\n#>   )\r\n#> }\r\n\r\nget_translation(\"summ\")\r\n#> Error: No translations registered for function `summ()`\r\nget_translation(\"sum\", package = \"basee\")\r\n#> Error: No translations registered for package 'basee'\r\nget_translation(\"summ\", package = \"base\")\r\n#> Error: No translations registered for function `base::summ()`\r\n```\r\n\r\n\r\nNeed to override `::` for the nice errors \r\n\r\n```R\n\r\nregister_translation(\"::\", function(lhs, rhs) {\r\n  get_translation(\r\n    as.character(substitute(rhs)),\r\n    as.character(substitute(lhs))\r\n  )\r\n})\r\n```\r\n\r\n\r\nUse `translations_with_search()` to resolve the list of translations based on the current search path (so that we can use it for a data mask). \r\n\r\n```R\n\r\nrlang::eval_tidy(\r\n  rlang::quo(base::sum(some_field)),\r\n  data = c(\r\n    list(some_field = arrow::Expression$field_ref(\"some_field\")),\r\n    translations_with_search()\r\n  )\r\n)\r\n#> Expression\r\n#> sum(some_field, {skip_nulls=true, min_count=1})\r\n```\r\n"
        },
        {
            "created_at": "2022-05-16T08:40:41.554Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14575?focusedCommentId=17537402) by Drago\u0219 Moldovan-Gr\u00fcnfeld (dragosmg):*\nI have an draft [PR](https://github.com/apache/arrow/pull/13160) for allowing\u00a0`pkg::` prefixes. What do you think of this approach?\r\n- change the naming convention for bindings, by adding `\"package_\"` before the function name. For example `\"as_datetime\"` becomes `{}\"lubridate_as_datetime\"{`}. Doing this mainly for 2 reasons:\n   \\*\\* it gives us an indication of the package / namespace we're linking to\n   \\*\\* it avoids the use of the double-colon (`{}::{`}) operator (easier dealing with strings only)\n- we register each binding both with its _short_ name (`{}\"as_datetime\"{`}) and its _full_ name (`{}\"lubridate_as_datetime\"{`})\n- we change the expressions supplied by the user by replacing the double colon (`{}::{`}) with an underscore (`{}_{`})\n- we can still include the original expression (containing `::` in the error message)\n- we don't have to define an allow list as the user will get the same message they are getting: \"now `pkg::fun() not supported in Arrow`\"."
        },
        {
            "created_at": "2022-07-08T20:16:39.709Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14575?focusedCommentId=17564452) by Drago\u0219 Moldovan-Gr\u00fcnfeld (dragosmg):*\nI went in a slightly different direction from the one sketched-out by `[~paleolimbot]` for several reasons:\r\n- chronologically, the above was outlined before the implementation of the new function registry (ARROW-15010), which diverged from the above sketch.\n- the proposed implementation is somewhat simpler and, thus, easier to maintain \n- it integrates well with the current function registry.\n"
        },
        {
            "created_at": "2022-07-15T21:23:54.807Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14575?focusedCommentId=17567394) by Neal Richardson (npr):*\nIssue resolved by pull request 13160\n<https://github.com/apache/arrow/pull/13160>"
        }
    ]
}