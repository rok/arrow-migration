{
    "issue": {
        "title": "[C++] Extending STL API to support row-wise conversion",
        "body": "***Note**: This issue was originally created as [ARROW-6377](https://issues.apache.org/jira/browse/ARROW-6377). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nUsing array builders is the recommended way in the documentation for converting rowwise data to arrow tables currently. However, array builders has a low level interface to support various use cases in the library. They require additional boilerplate due to type erasure, although some of these boilerplate could be avoided in compile time if the schema is already known and fixed (also discussed in ARROW-4067).\r\n\r\nIn some other part of the library, STL API provides a nice abstraction over builders by inferring data type and builders from values provided, reducing the boilerplate significantly. It handles automatically converting tuples with a limited set of native types currently: numeric types, string and vector (+ nullable variations of these in case\u00a0ARROW-6326 is merged). It also allows passing references in tuple values (implemented recently in ARROW-6284).\r\n\r\nAs a more concrete example, this is the code which can be used to convert\u00a0`row_data` provided in examples:\r\n \u00a0\r\n```cpp\n\r\narrow::Status VectorToColumnarTableSTL(const std::vector<struct data_row>& rows,\r\n                                       std::shared_ptr<arrow::Table>* table) {\r\n    auto rng = rows | ranges::views::transform([](const data_row& row) {\r\n                   return std::tuple<int, double, const std::vector<double>&>(\r\n                       row.id, row.cost, row.cost_components);\r\n               });\r\n    return arrow::stl::TableFromTupleRange(arrow::default_memory_pool(), rng,\r\n                                           {\"id\", \"cost\", \"cost_components\"},\r\n                                           table);\r\n}\r\n\r\n```\r\nSo, it allows more concise code for consumers of the API compared to using builders directly.\r\n\r\nThere is no direct support by the library for other types (binary, struct, union etc. types or converting iterable objects other than vectors to lists). Users are provided a way to specialize their own data structures. One limitation for implicit inference is that it is hard (or even impossible) to infer exact type to use in some cases. For example, should `std::string_view` value be inferred as string, binary, large binary or list? This ambiguity can be avoided by providing some way for user to explicitly state correct type for storing a column. For example a user can return a so called `BinaryCell` class to return binary values.\r\n\r\nProposed changes:\r\n \\* Implementing cell \"adapters\": Cells are non-owning references for each type. It's user's responsibility keep pointed values alive. (Can scalars be used in this context?)\r\n \\*\\* BinaryCell\r\n \\*\\* StringCell\r\n \\*\\* ListCell (fo adapting any Range)\r\n \\*\\* StructCell\r\n \\*\\* ...\r\n \\* Primitive types don't need such adapters since their values are trivial to cast (e.g. just use int8_t(value) to use Int8Type).\r\n \\* Adding benchmarks for comparing with builder performance. There is likely to be some performance penalty due to hindering compiler optimizations. Yet, this is acceptable in exchange of a more concise code IMHO. For fine-grained control over performance, it will be still possible to directly use builders.\r\n\r\nI have implemented something similar to BinaryCell for my use case. If above changes sound reasonable, I will go ahead and start implementing other cells to submit.\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0",
        "created_at": "2019-08-28T17:01:33.000Z",
        "updated_at": "2020-03-10T22:25:16.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Type: enhancement"
        ],
        "closed": false
    },
    "comments": [
        {
            "created_at": "2019-08-28T17:08:27.046Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-6377?focusedCommentId=16917936) by Omer Ozarslan (ozars):*\nOn a side note, this _might_ have a better performance due to use of compile time knowledge, but it eventually comes down to benchmarking."
        }
    ]
}