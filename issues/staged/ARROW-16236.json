{
    "issue": {
        "title": "[Python] [Packaging] test_s3fs_limited_permissions_create_bucket fails with Permission denied on MAC OS wheel builds ",
        "body": "***Note**: This issue was originally created as [ARROW-16236](https://issues.apache.org/jira/browse/ARROW-16236). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nNightly-packaging jobs for wheels on MAC OS have started failing with PermissionError:\r\n\r\nBuild example:\r\n\r\n<https://github.com/ursacomputing/crossbow/runs/6074813901?check_suite_focus=true>\r\n\r\n\u00a0\r\n\r\nThe error is related with the following S3 test\r\n```java\n\r\n==================================== ERRORS ====================================\r\n________ ERROR at setup of test_s3fs_limited_permissions_create_bucket _________request = <SubRequest 'limited_s3_user' for <Function test_s3fs_limited_permissions_create_bucket>>\r\ns3_server = {'connection': ('localhost', 57493, 'arrow', 'apachearrow'), 'process': <Popen: returncode: None args: ['minio', '--compat', 'server', '--quiet', '-...>, 'tempdir': '/var/folders/cn/d0vdy6t94_77fwckh55bz2300000gq/T/tmpor9puihr'}\u00a0 \u00a0 @pytest.fixture(scope='session')\r\n\u00a0 \u00a0 def limited_s3_user(request, s3_server):\r\n\u00a0 \u00a0 \u00a0 \u00a0 if sys.platform == 'win32':\r\n# Can't rely on FileNotFound check because\r\n# there is sometimes an mc command on Windows\r\n# which is unrelated to the minio mc\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 pytest.skip('The mc command is not installed on Windows')\r\n\u00a0 \u00a0 \u00a0 \u00a0 request.config.pyarrow.requires('s3')\r\n\u00a0 \u00a0 \u00a0 \u00a0 tempdir = s3_server['tempdir']\r\n\u00a0 \u00a0 \u00a0 \u00a0 host, port, access_key, secret_key = s3_server['connection']\r\n\u00a0 \u00a0 \u00a0 \u00a0 address = '{}:{}'.format(host, port)\r\n> \u00a0 \u00a0 \u00a0 if not _configure_limited_user(tempdir, address, access_key, secret_key):test-arm64-env/lib/python3.9/site-packages/pyarrow/tests/test_fs.py:358:\u00a0\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\u00a0\r\ntest-arm64-env/lib/python3.9/site-packages/pyarrow/tests/test_fs.py:317: in _configure_limited_user\r\n\u00a0 \u00a0 if not _ensure_minio_component_version('mc', 2021):\r\ntest-arm64-env/lib/python3.9/site-packages/pyarrow/tests/test_fs.py:292: in _ensure_minio_component_version\r\n\u00a0 \u00a0 proc = subprocess.Popen(full_args, stdout=subprocess.PIPE,\r\n/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/subprocess.py:951: in __init__\r\n\u00a0 \u00a0 self._execute_child(args, executable, preexec_fn, close_fds,\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\u00a0self = <Popen: returncode: 255 args: ['mc', '--version']>\r\nargs = ['mc', '--version'], executable = b'mc', preexec_fn = None\r\nclose_fds = True, pass_fds = (), cwd = None, env = None, startupinfo = None\r\ncreationflags = 0, shell = False, p2cread = -1, p2cwrite = -1, c2pread = 12\r\nc2pwrite = 13, errread = 14, errwrite = 15, restore_signals = True, gid = None\r\ngids = None, uid = None, umask = -1, start_new_session = False\u00a0 \u00a0 def _execute_child(self, args, executable, preexec_fn, close_fds,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0pass_fds, cwd, env,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0startupinfo, creationflags, shell,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0p2cread, p2cwrite,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0c2pread, c2pwrite,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0errread, errwrite,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0restore_signals,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0gid, gids, uid, umask,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0start_new_session):\r\n\u00a0 \u00a0 \u00a0 \u00a0 \"\"\"Execute program (POSIX version)\"\"\"\r\n\u00a0 \u00a0\u00a0\r\n\u00a0 \u00a0 \u00a0 \u00a0 if isinstance(args, (str, bytes)):\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 args = [args]\r\n\u00a0 \u00a0 \u00a0 \u00a0 elif isinstance(args, os.PathLike):\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if shell:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 raise TypeError('path-like args is not allowed when '\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'shell is true')\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 args = [args]\r\n\u00a0 \u00a0 \u00a0 \u00a0 else:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 args = list(args)\r\n\u00a0 \u00a0\u00a0\r\n\u00a0 \u00a0 \u00a0 \u00a0 if shell:\r\n# On Android the default shell is at '/system/bin/sh'.\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 unix_shell = ('/system/bin/sh' if\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 hasattr(sys, 'getandroidapilevel') else '/bin/sh')\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 args = [unix_shell, \"-c\"] + args\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if executable:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 args[0] = executable\r\n\u00a0 \u00a0\u00a0\r\n\u00a0 \u00a0 \u00a0 \u00a0 if executable is None:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 executable = args[0]\r\n\u00a0 \u00a0\u00a0\r\n\u00a0 \u00a0 \u00a0 \u00a0 sys.audit(\"subprocess.Popen\", executable, args, cwd, env)\r\n\u00a0 \u00a0\u00a0\r\n\u00a0 \u00a0 \u00a0 \u00a0 if (_USE_POSIX_SPAWN\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 and os.path.dirname(executable)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 and preexec_fn is None\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 and not close_fds\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 and not pass_fds\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 and cwd is None\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 and (p2cread == -1 or p2cread > 2)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 and (c2pwrite == -1 or c2pwrite > 2)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 and (errwrite == -1 or errwrite > 2)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 and not start_new_session\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 and gid is None\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 and gids is None\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 and uid is None\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 and umask < 0):\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 self._posix_spawn(args, executable, env, restore_signals,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p2cread, p2cwrite,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 c2pread, c2pwrite,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 errread, errwrite)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return\r\n\u00a0 \u00a0\u00a0\r\n\u00a0 \u00a0 \u00a0 \u00a0 orig_executable = executable\r\n\u00a0 \u00a0\u00a0\r\n# For transferring possible exec failure from child to parent.\r\n# Data format: \"exception name:hex errno:description\"\r\n# Pickle is not used; it is complex and involves memory allocation.\r\n\u00a0 \u00a0 \u00a0 \u00a0 errpipe_read, errpipe_write = os.pipe()\r\n# errpipe_write must not be in the standard io 0, 1, or 2 fd range.\r\n\u00a0 \u00a0 \u00a0 \u00a0 low_fds_to_close = []\r\n\u00a0 \u00a0 \u00a0 \u00a0 while errpipe_write < 3:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 low_fds_to_close.append(errpipe_write)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 errpipe_write = os.dup(errpipe_write)\r\n\u00a0 \u00a0 \u00a0 \u00a0 for low_fd in low_fds_to_close:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 os.close(low_fd)\r\n\u00a0 \u00a0 \u00a0 \u00a0 try:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 try:\r\n# We must avoid complex work that could involve\r\n# malloc or free in the child process to avoid\r\n# potential deadlocks, thus we do all this here.\r\n# and pass it to fork_exec()\r\n\u00a0 \u00a0\u00a0\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if env is not None:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 env_list = []\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 for k, v in env.items():\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 k = os.fsencode(k)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if b'=' in k:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 raise ValueError(\"illegal environment variable name\")\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 env_list.append(k + b'=' + os.fsencode(v))\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 else:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 env_list = None \u00a0# Use execv instead of execve.\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 executable = os.fsencode(executable)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if os.path.dirname(executable):\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 executable_list = (executable,)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 else:\r\n# This matches the behavior of os._execvpe().\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 executable_list = tuple(\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 os.path.join(os.fsencode(dir), executable)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 for dir in os.get_exec_path(env))\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fds_to_keep = set(pass_fds)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fds_to_keep.add(errpipe_write)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 self.pid = _posixsubprocess.fork_exec(\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 args, executable_list,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 close_fds, tuple(sorted(map(int, fds_to_keep))),\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cwd, env_list,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p2cread, p2cwrite, c2pread, c2pwrite,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 errread, errwrite,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 errpipe_read, errpipe_write,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 restore_signals, start_new_session,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 gid, gids, uid, umask,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 preexec_fn)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 self._child_created = True\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 finally:\r\n# be sure the FD is closed no matter what\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 os.close(errpipe_write)\r\n\u00a0 \u00a0\u00a0\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 self._close_pipe_fds(p2cread, p2cwrite,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0c2pread, c2pwrite,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0errread, errwrite)\r\n\u00a0 \u00a0\u00a0\r\n# Wait for exec to fail or succeed; possibly raising an\r\n# exception (limited in size)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 errpipe_data = bytearray()\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 while True:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 part = os.read(errpipe_read, 50000)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 errpipe_data += part\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if not part or len(errpipe_data) > 50000:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break\r\n\u00a0 \u00a0 \u00a0 \u00a0 finally:\r\n# be sure the FD is closed no matter what\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 os.close(errpipe_read)\r\n\u00a0 \u00a0\u00a0\r\n\u00a0 \u00a0 \u00a0 \u00a0 if errpipe_data:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 try:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 pid, sts = os.waitpid(self.pid, 0)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if pid == self.pid:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 self._handle_exitstatus(sts)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 else:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 self.returncode = sys.maxsize\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 except ChildProcessError:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 pass\r\n\u00a0 \u00a0\u00a0\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 try:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 exception_name, hex_errno, err_msg = (\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 errpipe_data.split(b':', 2))\r\n# The encoding here should match the encoding\r\n# written in by the subprocess implementations\r\n# like _posixsubprocess\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 err_msg = err_msg.decode()\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 except ValueError:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 exception_name = b'SubprocessError'\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 hex_errno = b'0'\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 err_msg = 'Bad exception data from child: {!r}'.format(\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bytes(errpipe_data))\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 child_exception_type = getattr(\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 builtins, exception_name.decode('ascii'),\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 SubprocessError)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if issubclass(child_exception_type, OSError) and hex_errno:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 errno_num = int(hex_errno, 16)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 child_exec_never_called = (err_msg == \"noexec\")\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if child_exec_never_called:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 err_msg = \"\"\r\n# The error must be from chdir(cwd).\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 err_filename = cwd\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 else:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 err_filename = orig_executable\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if errno_num != 0:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 err_msg = os.strerror(errno_num)\r\n> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 raise child_exception_type(errno_num, err_msg, err_filename)\r\nE \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 PermissionError: [Errno 13] Permission denied: 'mc'\r\n\r\n```\r\nAll the failed tasks with this error:\r\nFailed Tasks:\r\n- wheel-macos-big-sur-cp310-arm64:\n  \u00a0 URL: <https://github.com/ursacomputing/crossbow/tree/nightly-packaging-2022-04-19-0-github-wheel-macos-big-sur-cp310-arm64>\n- wheel-macos-big-sur-cp310-universal2:\n  \u00a0 URL: <https://github.com/ursacomputing/crossbow/tree/nightly-packaging-2022-04-19-0-github-wheel-macos-big-sur-cp310-universal2>\n- wheel-macos-big-sur-cp38-arm64:\n  \u00a0 URL: <https://github.com/ursacomputing/crossbow/tree/nightly-packaging-2022-04-19-0-github-wheel-macos-big-sur-cp38-arm64>\n- wheel-macos-big-sur-cp39-arm64:\n  \u00a0 URL: <https://github.com/ursacomputing/crossbow/tree/nightly-packaging-2022-04-19-0-github-wheel-macos-big-sur-cp39-arm64>\n  \n  \u00a0",
        "created_at": "2022-04-19T15:34:21.000Z",
        "updated_at": "2022-04-23T08:24:49.000Z",
        "labels": [
            "Migrated from Jira",
            "Type: bug"
        ],
        "closed": true,
        "closed_at": "2022-04-23T08:24:49.000Z"
    },
    "comments": [
        {
            "created_at": "2022-04-19T15:35:07.185Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16236?focusedCommentId=17524392) by Ra\u00fal Cumplido (raulcd):*\ncc - `[~jorisvandenbossche]` \u00a0"
        },
        {
            "created_at": "2022-04-23T08:24:43.854Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16236?focusedCommentId=17526800) by Krisztian Szucs (kszucs):*\nIt could have been caused by running the self-hosted github agent with the wrong user, at least the nightly big-sur builds pass.\r\n\r\nClosing as not reproducible."
        }
    ]
}