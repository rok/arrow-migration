{
    "issue": {
        "title": "[Python] When converting nested types to pandas, use tuples",
        "body": "***Note**: This issue was originally created as [ARROW-3806](https://issues.apache.org/jira/browse/ARROW-3806). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nWhen converting to pandas, convert nested types (e.g. list) to tuples.  Columns with lists are difficult to query.  Here are a few unsuccessful attempts:\r\n\r\n```Java\n\r\n>>> mini\r\n    CHROM    POS           ID            REF    ALTS  QUAL\r\n80     20  63521  rs191905748              G     [A]   100\r\n81     20  63541  rs117322527              C     [A]   100\r\n82     20  63548  rs541129280              G    [GT]   100\r\n83     20  63553  rs536661806              T     [C]   100\r\n84     20  63555  rs553463231              T     [C]   100\r\n85     20  63559  rs138359120              C     [A]   100\r\n86     20  63586  rs545178789              T     [G]   100\r\n87     20  63636  rs374311122              G     [A]   100\r\n88     20  63696  rs149160003              A     [G]   100\r\n89     20  63698  rs544072005              A     [C]   100\r\n90     20  63729  rs181483669              G     [A]   100\r\n91     20  63733   rs75670495              C     [T]   100\r\n92     20  63799    rs1418258              C     [T]   100\r\n93     20  63808   rs76004960              G     [C]   100\r\n94     20  63813  rs532151719              G     [A]   100\r\n95     20  63857  rs543686274  CCTGGAAAGGATT     [C]   100\r\n96     20  63865  rs551938596              G     [A]   100\r\n97     20  63902  rs571779099              A     [T]   100\r\n98     20  63963  rs531152674              G     [A]   100\r\n99     20  63967  rs116770801              A     [G]   100\r\n100    20  63977  rs199703510              C     [G]   100\r\n101    20  64016  rs143263863              G     [A]   100\r\n102    20  64062  rs148297240              G     [A]   100\r\n103    20  64139  rs186497980              G  [A, T]   100\r\n104    20  64150    rs7274499              C     [A]   100\r\n105    20  64151  rs190945171              C     [T]   100\r\n106    20  64154  rs537656456              T     [G]   100\r\n107    20  64175  rs116531220              A     [G]   100\r\n108    20  64186  rs141793347              C     [G]   100\r\n109    20  64210  rs182418654              G     [C]   100\r\n110    20  64303  rs559929739              C     [A]   100\r\n```\r\n\r\n1. I think this one fails because it tries to broadcast the comparison.\n   ```Java\n   \n   >>> mini[mini.ALTS == [\"A\", \"T\"]]\n   Traceback (most recent call last):\n     File \"<stdin>\", line 1, in <module>\n     File \"/home/user/miniconda3/lib/python3.6/site-packages/pandas/core/ops.py\", line 1283, in wrapper\n       res = na_op(values, other)\n     File \"/home/user/miniconda3/lib/python3.6/site-packages/pandas/core/ops.py\", line 1143, in na_op\n       result = _comp_method_OBJECT_ARRAY(op, x, y)\n     File \"/home/user/miniconda3/lib/python3.6/site-packages/pandas/core/ops.py\", line 1120, in _comp_method_OBJECT_ARRAY\n       result = libops.vec_compare(x, y, op)\n     File \"pandas/_libs/ops.pyx\", line 128, in pandas._libs.ops.vec_compare\n   ValueError: Arrays were different lengths: 31 vs 2\n   ```\n1. I think this fails due to a similar reason, but the broadcasting is happening at a different place.\n   ```Java\n   \n   >>> mini[mini.ALTS.apply(lambda x: x == [\"A\", \"T\"])]\n   Traceback (most recent call last):\n     File \"<stdin>\", line 1, in <module>\n     File \"/home/user/miniconda3/lib/python3.6/site-packages/pandas/core/frame.py\", line 2682, in __getitem__\n       return self._getitem_array(key)\n     File \"/home/user/miniconda3/lib/python3.6/site-packages/pandas/core/frame.py\", line 2726, in _getitem_array\n       indexer = self.loc._convert_to_indexer(key, axis=1)\n     File \"/home/user/miniconda3/lib/python3.6/site-packages/pandas/core/indexing.py\", line 1314, in _convert_to_indexer\n       indexer = check = labels.get_indexer(objarr)\n     File \"/home/user/miniconda3/lib/python3.6/site-packages/pandas/core/indexes/base.py\", line 3259, in get_indexer\n       indexer = self._engine.get_indexer(target._ndarray_values)\n     File \"pandas/_libs/index.pyx\", line 301, in pandas._libs.index.IndexEngine.get_indexer\n     File \"pandas/_libs/hashtable_class_helper.pxi\", line 1544, in pandas._libs.hashtable.PyObjectHashTable.lookup\n   TypeError: unhashable type: 'numpy.ndarray'\n   >>> mini.ALTS.apply(lambda x: x == [\"A\", \"T\"]).head()\n   80     [True, False]\n   81     [True, False]\n   82    [False, False]\n   83    [False, False]\n   84    [False, False]\n   ```\n1. Unfortunately this clever hack fails as well!\n   ```Java\n   \n   >>> c = np.empty(1, object)\n   >>> c[0] = [\"A\", \"T\"]\n   >>> mini[mini.ALTS.values == c]\n   Traceback (most recent call last):\n     File \"/home/user/miniconda3/lib/python3.6/site-packages/pandas/core/indexes/base.py\", line 3078, in get_loc\n       return self._engine.get_loc(key)\n     File \"pandas/_libs/index.pyx\", line 140, in pandas._libs.index.IndexEngine.get_loc\n     File \"pandas/_libs/index.pyx\", line 162, in pandas._libs.index.IndexEngine.get_loc\n     File \"pandas/_libs/hashtable_class_helper.pxi\", line 1492, in pandas._libs.hashtable.PyObjectHashTable.get_item\n     File \"pandas/_libs/hashtable_class_helper.pxi\", line 1500, in pandas._libs.hashtable.PyObjectHashTable.get_item\n   KeyError: False\n   >>> mini.ALTS.values == c\n   False\n   ```\n   \n   Finally, what succeeds is the following (probably because of the immutability of tuple):\n   ```Java\n   \n   >>> mini[\"ALTS2\"] = mini.ALTS.apply(tuple)\n   >>> mini.head()\n      CHROM    POS           ID REF  ALTS  QUAL  ALTS2\n   80    20  63521  rs191905748   G   [A]   100   (A,)\n   81    20  63541  rs117322527   C   [A]   100   (A,)\n   82    20  63548  rs541129280   G  [GT]   100  (GT,)\n   83    20  63553  rs536661806   T   [C]   100   (C,)\n   84    20  63555  rs553463231   T   [C]   100   (C,)\n   >>> mini[mini[\"ALTS2\"] == (\"A\", \"T\")]\n       CHROM    POS           ID REF    ALTS  QUAL   ALTS2\n   103    20  64139  rs186497980   G  [A, T]   100  (A, T)\n   >>> mini[mini[\"ALTS2\"] == (\"GT\",)]\n      CHROM    POS           ID REF  ALTS  QUAL  ALTS2\n   82    20  63548  rs541129280   G  [GT]   100  (GT,)\n   >>> mini[mini[\"ALTS2\"] == tuple(\"C\")]\n       CHROM    POS           ID            REF ALTS  QUAL ALTS2\n   83     20  63553  rs536661806              T  [C]   100  (C,)\n   84     20  63555  rs553463231              T  [C]   100  (C,)\n   89     20  63698  rs544072005              A  [C]   100  (C,)\n   93     20  63808   rs76004960              G  [C]   100  (C,)\n   95     20  63857  rs543686274  CCTGGAAAGGATT  [C]   100  (C,)\n   109    20  64210  rs182418654              G  [C]   100  (C,)\n   ```",
        "created_at": "2018-11-16T10:00:51.000Z",
        "updated_at": "2020-01-07T19:11:37.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: Python",
            "Type: enhancement"
        ],
        "closed": false
    },
    "comments": [
        {
            "created_at": "2018-11-16T13:56:57.353Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-3806?focusedCommentId=16689438) by Wes McKinney (wesm):*\nHm, I don't have a particularly strong opinion about our use of lists. Do we have type inference for tuples on the round trip? `[~xhochy]` `[~pitrou]` what do you think about this?"
        },
        {
            "created_at": "2019-04-29T12:46:49.753Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-3806?focusedCommentId=16829231) by Joris Van den Bossche (jorisvandenbossche):*\nThere is currently no automatic type inference for tuples to ListArray:\r\n\r\n```Java\n\r\nIn [41]: pyarrow.array(np.array([(1, 2), (1, 2, 3), (3,)]))                                                                                                   \r\n---------------------------------------------------------------------------\r\nArrowInvalid                              Traceback (most recent call last)\r\n<ipython-input-41-ca2c4b264383> in <module>\r\n----> 1 pyarrow.array(np.array([(1, 2), (1, 2, 3), (3,)]))\r\n\r\n~/scipy/repos/arrow/python/pyarrow/array.pxi in pyarrow.lib.array()\r\n\r\n~/scipy/repos/arrow/python/pyarrow/array.pxi in pyarrow.lib._ndarray_to_array()\r\n\r\n~/scipy/repos/arrow/python/pyarrow/error.pxi in pyarrow.lib.check_status()\r\n\r\nArrowInvalid: Could not convert (1, 2) with type tuple: did not recognize Python value type when inferring an Arrow data type\r\n```\r\n\r\nbut conversion from tuples is implemented when specifying the proper type:\r\n\r\n```Java\n\r\nIn [42]: pyarrow.array(np.array([(1, 2), (1, 2, 3), (3,)]), type=pyarrow.list_(pyarrow.int64()))                                                              \r\nOut[42]: \r\n<pyarrow.lib.ListArray object at 0x7fad2254d9f8>\r\n[\r\n  [\r\n    1,\r\n    2\r\n  ],\r\n  [\r\n    1,\r\n    2,\r\n    3\r\n  ],\r\n  [\r\n    3\r\n  ]\r\n]\r\n```"
        },
        {
            "created_at": "2019-09-18T15:52:16.561Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-3806?focusedCommentId=16932584) by Antoine Pitrou (apitrou):*\nWell, we could add proper inference for tuples. ListArray is the only applicable type AFAICT (StructArray cannot apply since the field names are not known)."
        }
    ]
}