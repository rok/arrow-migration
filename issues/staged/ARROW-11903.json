{
    "issue": {
        "title": "[Python] Stored data to parquet do not fit values before the storing",
        "body": "***Note**: This issue was originally created as [ARROW-11903](https://issues.apache.org/jira/browse/ARROW-11903). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nDear,\r\n\r\n\u00a0\r\n\r\nI have a strange behavior, indeed data do not keep their same values once stored to parquet.\r\n\r\n\u00a0\r\n\r\nthe schema is:\r\n\r\n\u00a0\r\n```python\n\r\nvariations = struct((field('start', int64(), nullable=False),\r\n                     field('stop', int64(), nullable=False),\r\n                     field('reference', string(), nullable=False),\r\n                     field('alternative', string(), nullable=False),\r\n                     field('category', int8(), nullable=False)))\r\nvariations_field = field('variations', list_(variations))\r\nmetadata = {b'pandas': b'{\"index_columns\": [\"sample\"], '\r\n b'\"column_indexes\": [{\"name\": null, \"field_name\": \"sample\", \"pandas_type\": \"int64\", \"numpy_type\": \"int64\"}], '\r\n b'\"columns\": ['\r\n b'{\"name\": \"variations\", \"field_name\": \"variations\", \"pandas_type\": \"list[object]\", \"numpy_type\": \"object\", \"metadata\": null}, '\r\n b'{\"name\": \"sample\", \"field_name\": \"sample\", \"pandas_type\": \"int64\", \"numpy_type\": \"int64\", \"metadata\": null}], '\r\n b'\"pandas_version\": \"1.2.0\"}'}\r\nsample_to_variations_schema = schema((sample_field, variations_field), metadata=metadata)\r\n```\r\n\u00a0\r\n\r\nTo store data I do:\r\n```python\n\r\ntable = Table.from_arrays([samples, variations_by_sample], schema=sample_to_variations_schema)\r\ndataset_dir = path.join(outdir, f'contig={contig}')\r\nmakedirs(dataset_dir, exist_ok=True)\r\nwith ParquetWriter(where=path.join(dataset_dir, 'variant_to_samples'),\r\nversion='2.0', schema=table.schema, compression='SNAPPY') as pw:\r\n    pw.write_table(table)\n```\r\n\r\n\r\nI put a breakpoint just after table is assigned, in order to check values in memory:\r\n\r\nExample for the row n\u00b0210027\r\n\r\n\r\n```python\n\r\n>>> samples[210027]\r\n831028\r\n>>> variations_by_sample[210027]\r\n[(241, 241, 'C', 'T', 0), (445, 445, 'T', 'C', 0), (3037, 3037, 'C', 'T', 0), (6286, 6286, 'C', 'T', 0), (11024, 11024, 'A', 'G', 0), (14408, 14408, 'C', 'T', 0), (21255, 21255, 'G', 'C', 0), (22227, 22227, 'C', 'T', 0), (23403, 23403, 'A', 'G', 0), (24140, 24140, 'G', 'A', 0), (25496, 25496, 'T', 'C', 0), (26801, 26801, 'C', 'G', 0), (27840, 27840, 'T', 'C', 0), (27944, 27944, 'C', 'T', 0), (27948, 27948, 'G', 'T', 0), (28932, 28932, 'C', 'T', 0), (29645, 29645, 'G', 'T', 0)]\r\n```\r\n\r\n\r\nNow the application end successfully and data are stored into a parquet dataset.\r\nSo, I load those data and check their consistencies.\r\n\r\n\r\n```python\n\r\n$ ipython\r\nIn [1]: from pyarrow.parquet import read_table\r\n   ...: sample_to_variants = read_table('sample_to_variants_db')\r\n\r\nIn [2]: row_num = 0\r\n   ...: an_id = 0\r\n   ...: while an_id != 831028:\r\n   ...:     an_id = sample_to_variants.column(0)[row_num].as_py()\r\n   ...:     row_num += 1\r\n   ...: \r\nIn [3]: sample_to_variants.column(0)[row_num-1].as_py()\r\nOut[3]: 831028\r\nIn [4]: sample_to_variants.column(1)[row_num-1].as_py()\r\nOut[4]: \r\n[{'start': 241,\r\n  'stop': 241,\r\n  'reference': 'C',\r\n  'alternative': 'T',\r\n  'category': 0},\r\n {'start': 445,\r\n  'stop': 445,\r\n  'reference': 'G',\r\n  'alternative': 'T',\r\n  'category': 0},\r\n {'start': 3037,\r\n  'stop': 3037,\r\n  'reference': 'G',\r\n  'alternative': 'T',\r\n  'category': 0},\r\n {'start': 6286,\r\n  'stop': 6286,\r\n  'reference': 'C',\r\n  'alternative': 'T',\r\n  'category': 0},\r\n {'start': 11024,\r\n  'stop': 11024,\r\n  'reference': 'C',\r\n  'alternative': 'T',\r\n  'category': 0},\r\n {'start': 14408,\r\n  'stop': 14408,\r\n  'reference': 'C',\r\n  'alternative': 'T',\r\n  'category': 0},\r\n {'start': 21255,\r\n  'stop': 21255,\r\n  'reference': 'G',\r\n  'alternative': 'T',\r\n  'category': 0},\r\n {'start': 22227,\r\n  'stop': 22227,\r\n  'reference': 'G',\r\n  'alternative': 'A',\r\n  'category': 0},\r\n {'start': 23403,\r\n  'stop': 23403,\r\n  'reference': 'C',\r\n  'alternative': 'T',\r\n  'category': 0},\r\n {'start': 24140,\r\n  'stop': 24140,\r\n  'reference': 'C',\r\n  'alternative': 'T',\r\n  'category': 0},\r\n {'start': 25496,\r\n  'stop': 25496,\r\n  'reference': 'A',\r\n  'alternative': 'G',\r\n  'category': 0},\r\n {'start': 26801,\r\n  'stop': 26801,\r\n  'reference': 'G',\r\n  'alternative': 'T',\r\n  'category': 0},\r\n {'start': 27840,\r\n  'stop': 27840,\r\n  'reference': 'C',\r\n  'alternative': 'T',\r\n  'category': 0},\r\n {'start': 27944,\r\n  'stop': 27944,\r\n  'reference': 'T',\r\n  'alternative': 'C',\r\n  'category': 0},\r\n {'start': 27948,\r\n  'stop': 27948,\r\n  'reference': 'G',\r\n  'alternative': 'A',\r\n  'category': 0},\r\n {'start': 28932,\r\n  'stop': 28932,\r\n  'reference': 'C',\r\n  'alternative': 'T',\r\n  'category': 0},\r\n {'start': 29645,\r\n  'stop': 29645,\r\n  'reference': 'G',\r\n  'alternative': 'A',\r\n  'category': 0}]\r\n```\r\n\r\nWe can see that the column 1 (0 based) do not have the same value before to be written in parquet. \r\nAs example into parquet dataset I\u00a0have this value:\r\n\r\n```python\n\r\n {'start': 24140,\r\n  'stop': 24140,\r\n  'reference': 'C',\r\n  'alternative': 'T',\r\n  'category': 0},\r\n```\r\n\r\nwhile from the memory before to be stored:\r\n\r\n\r\n```python\n\r\n(24140, 24140, 'G', 'A', 0)\r\n```\r\n\r\nI do not understand what is the mechanism which lead to this inconsistency.\r\nSo I am not able to make a minimal example case (sorry)\r\n\r\nThanks\r\n",
        "created_at": "2021-03-08T13:39:01.000Z",
        "updated_at": "2021-08-23T09:52:11.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Component: Python",
            "Type: bug"
        ],
        "closed": true,
        "closed_at": "2021-08-23T09:52:11.000Z"
    },
    "comments": [
        {
            "created_at": "2021-03-08T15:02:04.537Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-11903?focusedCommentId=17297431) by Jonathan mercier (bioinfornatics):*\nI have updated to the release 3.0.0 and that seem to be fixed \u2026 to be confirmed soon"
        },
        {
            "created_at": "2021-05-11T12:12:50.222Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-11903?focusedCommentId=17342514) by David Li (lidavidm):*\n`[~bioinfornatics]` did 3.0.0 solve your problem? There's also 4.0.0 which released recently."
        },
        {
            "created_at": "2021-08-23T09:50:57.798Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-11903?focusedCommentId=17403090) by Joris Van den Bossche (jorisvandenbossche):*\nWe indeed had several issues regarding nested data that have been fixed in recent releases. I am going to assume this is fixed and close the issue. But if not, `[~bioinfornatics]` please comment and if possible provide a reproducible example."
        }
    ]
}