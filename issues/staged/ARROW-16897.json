{
    "issue": {
        "title": "[R][C++] Full join on Arrow objects is incorrect",
        "body": "***Note**: This issue was originally created as [ARROW-16897](https://issues.apache.org/jira/browse/ARROW-16897). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nHello,\r\n\r\nI am trying to do a full join on a dataset. It produces the correct number of observations, but not the correct result (the resulting data.frame is just filled up with NA-rows).\r\n\r\nMy use case: I want to include the 'full' year range for every factor value:\r\n```java\n\r\nlibrary(data.table)\r\nlibrary(arrow)\r\nlibrary(dplyr)\r\n\r\nyear_range <- 2000:2019\r\ngroup_n <- 100\r\nN <- 1000 ## the resulting data should have 100 groups * 20 years\r\n\r\ndt <- data.table(value = rnorm(N),\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0group = rep(paste0(\"g\", 1:group_n), length.out = N))\r\n## there are only observations for some years in every group\r\ndt[, year := sample(year_range, size = N / group_n), by = .(group)]\r\ndt[group == \"g1\", ]\r\n\r\n## this would be the 'full' data.table\r\ngroup_years <- data.table(group = rep(unique(dt$group), each = 20),\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 year = rep(year_range, times = 10))\r\ngroup_years[group == \"g1\", ]\r\n\r\nwrite_dataset(dt, path = \"parquet_db\")\r\ndb <- open_dataset(sources = \"parquet_db\")\r\n\r\n## full_join using data.table -> expected result\r\ndb_full <- merge(dt, group_years,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0by = c(\"group\", \"year\"),\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0all = TRUE)\r\nsetorder(db_full, group, year)\r\ndb_full[group == \"g1\", ]\r\n\r\n## try to do the full_join with arrow -> incorrect result\r\ndb_full_arrow <- db |>\r\n\u00a0 full_join(group_years, by = c(\"group\", \"year\")) |>\r\n\u00a0 collect() |>\r\n\u00a0 setDT()\r\nsetorder(db_full_arrow, group, year)\r\ndb_full_arrow[group == \"g1\", ]\r\n\r\n## or: convert data.table to arrow_table beforehand -> incorrect result\r\ngroup_years_arrow <- group_years |>\r\n\u00a0 as_arrow_table()\r\ndb_full_arrow <- db |>\r\n\u00a0 full_join(group_years_arrow, by = c(\"group\", \"year\")) |>\r\n\u00a0 collect() |>\r\n\u00a0 setDT()\r\nsetorder(db_full_arrow, group, year)\r\ndb_full_arrow[group == \"g1\", ]\n```\r\nThe [documentation](https://arrow.apache.org/docs/r/) says equality joins are supported, which should hold also for `full_join` I guess?\r\n\r\nThanks for your time and work!\r\n\r\n\u00a0\r\n\r\nOliver",
        "created_at": "2022-06-23T20:05:30.000Z",
        "updated_at": "2022-10-06T16:47:41.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Component: R",
            "Type: bug"
        ],
        "closed": true,
        "closed_at": "2022-10-06T16:47:41.000Z"
    },
    "comments": [
        {
            "created_at": "2022-06-28T18:35:17.439Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16897?focusedCommentId=17559912) by Nicola Crane (thisisnic):*\nI was able to reproduce this error when I tried it locally.\u00a0 I ran through the join in debug mode, and the schemas for the dataset and the table match, so I don't think that is the source of the error.\u00a0\r\n\r\nHere's a slightly simpler reprex showing the same issue:\r\n```r\n\r\nlibrary(dplyr)\r\nlibrary(arrow)\r\n\r\n# this dataset contains every possible combination of x and y\r\nfull_data <- tibble::tibble(\r\n\u00a0 x = rep(c(\"a\", \"b\"), each = 5),\r\n\u00a0 y = rep(1:5, 2)\r\n)\r\n\r\n# this dataset contains a subset of x and y combinations and new column \"value\"\r\nsmall_dataset <- tibble::tibble(\r\n\u00a0 value = c(0.1, 0.2, 0.3, 0.4, 0.5),\r\n\u00a0 x = c(rep(\"a\", 3), rep(\"b\", 2)),\r\n\u00a0 y = 1:5\r\n)\r\n\r\n# expected result; 10 rows with NA values for some values of \"value\"\r\nfull_join(small_dataset, full_data, by = c(\"y\", \"x\"))\r\n#> # A tibble: 10 \u00d7 3\r\n#> \u00a0 \u00a0value x \u00a0 \u00a0 \u00a0 \u00a0 y\r\n#> \u00a0 \u00a0<dbl> <chr> <int>\r\n#> \u00a01 \u00a0 0.1 a \u00a0 \u00a0 \u00a0 \u00a0 1\r\n#> \u00a02 \u00a0 0.2 a \u00a0 \u00a0 \u00a0 \u00a0 2\r\n#> \u00a03 \u00a0 0.3 a \u00a0 \u00a0 \u00a0 \u00a0 3\r\n#> \u00a04 \u00a0 0.4 b \u00a0 \u00a0 \u00a0 \u00a0 4\r\n#> \u00a05 \u00a0 0.5 b \u00a0 \u00a0 \u00a0 \u00a0 5\r\n#> \u00a06 \u00a0NA \u00a0 a \u00a0 \u00a0 \u00a0 \u00a0 4\r\n#> \u00a07 \u00a0NA \u00a0 a \u00a0 \u00a0 \u00a0 \u00a0 5\r\n#> \u00a08 \u00a0NA \u00a0 b \u00a0 \u00a0 \u00a0 \u00a0 1\r\n#> \u00a09 \u00a0NA \u00a0 b \u00a0 \u00a0 \u00a0 \u00a0 2\r\n#> 10 \u00a0NA \u00a0 b \u00a0 \u00a0 \u00a0 \u00a0 3\r\n\r\n# convert \"small_dataset\" into a ...dataset\r\ntmpdir <- tempfile()\r\ndir.create(tmpdir)\r\nwrite_dataset(small_dataset, tmpdir)\r\n\r\n# full_join with the dataset is incorrect - now we get all of small_dataset but \r\n# NA values for all columns in full_dataset\u00a0\r\n# which don't have a match\r\nopen_dataset(tmpdir) %>%\r\n\u00a0 full_join(full_data, by = c(\"x\", \"y\")) %>%\r\n\u00a0 collect()\r\n#> # A tibble: 10 \u00d7 3\r\n#> \u00a0 \u00a0value x \u00a0 \u00a0 \u00a0 \u00a0 y\r\n#> \u00a0 \u00a0<dbl> <chr> <int>\r\n#> \u00a01 \u00a0 0.1 a \u00a0 \u00a0 \u00a0 \u00a0 1\r\n#> \u00a02 \u00a0 0.2 a \u00a0 \u00a0 \u00a0 \u00a0 2\r\n#> \u00a03 \u00a0 0.3 a \u00a0 \u00a0 \u00a0 \u00a0 3\r\n#> \u00a04 \u00a0 0.4 b \u00a0 \u00a0 \u00a0 \u00a0 4\r\n#> \u00a05 \u00a0 0.5 b \u00a0 \u00a0 \u00a0 \u00a0 5\r\n#> \u00a06 \u00a0NA \u00a0 <NA> \u00a0 \u00a0 NA\r\n#> \u00a07 \u00a0NA \u00a0 <NA> \u00a0 \u00a0 NA\r\n#> \u00a08 \u00a0NA \u00a0 <NA> \u00a0 \u00a0 NA\r\n#> \u00a09 \u00a0NA \u00a0 <NA> \u00a0 \u00a0 NA\r\n#> 10 \u00a0NA \u00a0 <NA> \u00a0 \u00a0 NA\r\n\r\n```"
        },
        {
            "created_at": "2022-06-28T18:56:07.308Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16897?focusedCommentId=17559916) by Nicola Crane (thisisnic):*\nCC `[~westonpace]` \u00a0"
        },
        {
            "created_at": "2022-06-30T03:59:24.555Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16897?focusedCommentId=17560809) by Weston Pace (westonpace):*\nI believe I have found the root cause.\u00a0 I'll give some more detail.\u00a0 In Acero a join node has a left output and a right output.\u00a0 Key columns can be output on both the left and the right side.\u00a0 In an inner join this just leads to duplicate data.\u00a0 In an outer join it's a bit more subtle.\r\n\r\nFor example, consider the inner join of the above (years 2000 - 2005 but only 2005 has a match in both):\r\n\n|left.group|left.year|right.group|right.year|value|\r|\n|-|-|-|-|-|-|\n|g1|2005|g1|2005|-1.008|\r<br>\r<br>In an inner join you only get rows that have matches in both tables and so the two key columns will always be identical.\u00a0 However, in an outer join, things are different.\u00a0 Here is the same outer join for the above five years:\r|\n|left.group|left.year|right.group|right.year|value|\r|\n|NA|NA|g1|2000|NA|\r|\n|NA|NA|g1|2001|NA|\r|\n|NA|NA|g1|2002|NA|\r|\n|NA|NA|g1|2003|NA|\r|\n|NA|NA|g1|2004|NA|\r|\n|g1|2005|g1|2005|-1.008|\r<br>\r<br>Note that it would be possible to get values in the left keys with NA in the right keys if the right table was missing data (in this particular example the right table has the full set of keys and so it is never missing rows).\r<br>\r<br>Acero is actually giving you more information that you would normally get out of a standard SQL server.\u00a0 In a standard SQL server you would never know whether a row simple did not have a match or the row matched but all the payload columns were null.\u00a0 And, if a row didn't have a match and all the payload columns were null you wouldn't know which side had they key columns.\u00a0 Still, this information isn't generally useful and one could portray this as calling a bug a feature :)\r<br>\r<br>R currently deals with this duplication of key columns by always excluding the key columns from the right output.\u00a0 So, given the above, R throws away `right.group` and `left.group` and you end up with:\r<br>\r<br>\u00a0\r|\n|left.group|left.year|value|\r|\n|NA|NA|NA|\r|\n|NA|NA|NA|\r|\n|NA|NA|NA|\r|\n|NA|NA|NA|\r|\n|NA|NA|NA|\r|\n|g1|2005|-1.008|\r<br>\r<br>I'm not sure if Acero's join node is dropping the rows with all nulls or if that is happening later on in some further node but these aren't very useful rows anyways.\u00a0 If I reverse R's logic so that left_output is \"let fields minus keys\" and right_output is \"right fields\" then I get the correct result.\r<br>\r<br>However, the correct answer is not to always drop the keys from the right side or to always drop the keys from the left side but instead to always coalesce the key columns.\r<br>\r<br>\u00a0\r<br>\r<br>Fortunately, we have a PR that adds this as an option (append_consolidated_key) to the hash join node options and will take care of the coalescing for you: <https://github.com/michalursa/arrow/pull/7/files#diff-985b684376a17de896e07a2ff2362934dbf8fa2483edeaeff6910907f6f96733>\r<br>\r<br>\u00a0\r<br>\r<br>Unfortunately, this PR was built on top of the improved hash-join node which hasn't yet merged.|\n"
        },
        {
            "created_at": "2022-06-30T12:04:30.267Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16897?focusedCommentId=17561004) by Neal Richardson (npr):*\nThanks `[~westonpace]` for the detailed explanation. Sounds like ARROW-15838 is the issue that will resolve this in R, right? So can we close this as duplicate of that?"
        },
        {
            "created_at": "2022-06-30T17:08:04.947Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16897?focusedCommentId=17561127) by Weston Pace (westonpace):*\nThat sounds reasonable.  Although this is a great test case for ARROW-15838 so lets not lose that."
        },
        {
            "created_at": "2022-07-26T13:12:57.421Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16897?focusedCommentId=17571413) by Ra\u00fal Cumplido (raulcd):*\nThis is identified as one of the tickets required to create the first 9.0.0 RC, should this block the release?"
        },
        {
            "created_at": "2022-07-27T12:20:52.835Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16897?focusedCommentId=17571887) by Krisztian Szucs (kszucs):*\nPostponing to 10.0 since it depends on several other unresolved issues."
        }
    ]
}