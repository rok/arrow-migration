{
    "issue": {
        "title": "[C++] Infer project nodes lazily to avoid unnecessary chains when consuming Substrait",
        "body": "***Note**: This issue was originally created as [ARROW-16986](https://issues.apache.org/jira/browse/ARROW-16986). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nNaively converting everything projection-like in Substrait (ProjectRel, emit clauses, and complex expressions in non-project and non-filter relations) to individual project nodes would lead to conversion of optimal(-ish) Substrait plans to suboptimal Acero plans. Let's use this (more-or-less optimal) Substrait plan as an example (column indices are as Substrait would see them, column names between parens to make it a little easier to see what's going on):\r\n \\* Read column 2 (=A), 3 (=B), and 4 (=C) from a Parquet file (emit: [2 (=A), 3 (=B), 4 (=C)])\r\n \\* Project column 1 (B) + column 2 (=C) to get column 3 (=B+C), then drop column 1 (=B) (emit: [0 (=A), 2 (=C), 3 (=B+C)])\r\n \\* Order by column 0 (=A) - column 2 (=B+C), so effectively by A-B-C, then drop column 0 (=A) (emit: [1 (=C), 2 (=B+C)])\r\n\r\nConverting this naively, without exceptions to collapse the emit clause of ReadRel and ProjectRel, would probably yield:\r\n \\* For the ReadRel:\r\n \\*\\* Scanner that reads all columns\r\n \\*\\* Project [field(2), field(3), field(4)] for the emit clause\r\n \\* For the ProjectRel:\r\n \\*\\* Project [field(0), field(1), field(2), add(field(1), field(2))] for the body\r\n \\*\\* Project [field(0), field(2), field(3)] for the emit clause\r\n \\* For the SortRel:\r\n \\*\\* Project [field(0), field(1), field(2), sub(field(0), field(2))] to get the sort key\r\n \\*\\* Order by field(3)\r\n \\*\\* Project [field(0), field(1), field(2)] to revert adding the temporary column\r\n \\*\\* Project [field(1), field(2)] for the emit clause\r\n\r\nThat's a lot of project nodes, when the user would probably expect something like this:\r\n \\* Scanner\r\n \\* Project [field(2) (=A), field(4) (=C), add(field(3), field(4)) (=B+C)] to drop unneeded columns and compute B+C\r\n \\* Project [field(0) (=A), field(1) (=C), field(2) (=B+C), sub(field(0), field(2)) (=A-B-C)] to compute the sort key (not collapsed with previous because that would repeat the B+C subexpression)\r\n \\* Sort on field(3)\r\n \\* Project [field(1) (=C), field(2) (=B+C)] to drop the temporary field and column A\r\n\r\nI suggest the following for future me (or someone else, but feel free to do what you think is best in that case). For relation ToProtos, rather than returning a Declaration, return a new class that tracks:\r\n \\* declaration: the compute::Declaration up to this point;\r\n \\* pending_projection: a vector of Substrait expressions that represent the schema Substrait expects based on the schema returned by the compute::Declaration, using empty expressions to signal that no change is needed;\r\n \\* temporaries: a vector of Substrait expressions that will be needed as temporaries to express the next relation, such as complex expressions encountered in a join condition.\r\n\r\nThe class would need functions to:\r\n \\* construct from a scanner declaration and number of columns.\r\n \\*\\* post-condition: declaration is set to the given declaration.\r\n \\*\\* post-condition: pending_declarations.size() equals the number of columns.\r\n \\*\\* post-condition: all expressions in pending_declarations are simply field references to their own column index.\r\n \\*\\* post-condition: temporaries is empty.\r\n \\* update the state based on an emit clause.\r\n \\*\\* pre-condition: temporaries is empty (otherwise column indices will desync).\r\n \\*\\* if the emit clause is no-op, do nothing.\r\n \\*\\* swizzle/remove elements in pending_declaration based on the emit clause.\r\n \\* update the state based on the body of a ProjectRel.\r\n \\*\\* pre-condition: temporaries is empty (otherwise column indices will desync).\r\n \\*\\* some heuristic to determine whether to commit pending expressions into a Project node before appending the incoming expressions or not [?]; being too lazy may result in duplicated subexpressions, while being too eager may yield unnecessary project relations. It probably pays to be eager here, unless all pending expressions are any combination of only literals or field references.\r\n \\*\\* append the incoming expressions to the pending expression vector.\r\n \\* force a commit of the pending expressions to a Project node (if any are pending).\r\n \\*\\* post-condition: all expressions in pending_declarations are simply field references to their own column index.\r\n \\*\\* post-condition: temporaries is empty.\r\n \\* append a temporary expression, yielding a FieldRef for the next relation to make use of; to be used whenever Substrait allows an arbitrary expression in a place where Acero only supports FieldRefs.\r\n \\*\\* expression is appended to the back of temporaries.\r\n \\*\\* FieldRef returned simply references the index of the added temporary + pending_projection.size().\r\n \\* update the declaration by means of a (Declaration) -> Result<Declaration> closure, which may make use of the FieldRefs returned by previous add_temporary() calls.\r\n \\*\\* commit pending expressions to a Project node (if necessary).\r\n \\*\\* clear the list of temporaries.\r\n \\*\\* update declaration using the closure.\r\n \\*\\* post-condition: all expressions in pending_declarations are simply field references to their own column index.\r\n \\*\\* post-condition: temporaries is empty.\r\n \\* yield the final declaration.\r\n \\*\\* pre-condition: temporaries is empty (caller is doing something weird if it's not).\r\n \\*\\* commit pending expressions to a Project node (if necessary).\r\n \\*\\* return move(declaration).",
        "created_at": "2022-07-06T12:42:25.000Z",
        "updated_at": "2022-10-12T17:51:26.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Type: enhancement"
        ],
        "closed": false
    },
    "comments": [
        {
            "created_at": "2022-07-06T20:13:37.277Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16986?focusedCommentId=17563419) by Weston Pace (westonpace):*\n`[~jvanstraten]` and I briefly talked about this offline yesterday.  I was initially concerned that this was introducing planning/optimizing into Acero which I have been trying to avoid.  However, Jeroen brought up a good point.  This optimization could not be done in Substrait because it is fixing issues that arise in the Acero plan as a result of conversion from Substrait.\r\n\r\nSo this is not generic query plan optimization but instead an improvement on how we convert Substrait plans to Acero."
        },
        {
            "created_at": "2022-10-12T17:51:26.323Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-16986?focusedCommentId=17616621) by Apache Arrow JIRA Bot (arrowjira):*\nThis issue was last updated over 90 days ago, which may be an indication it is no longer being actively worked. To better reflect the current state, the issue is being unassigned per [project policy](https://arrow.apache.org/docs/dev/developers/bug_reports.html#issue-assignment). Please feel free to re-take assignment of the issue if it is being actively worked, or if you plan to start that work soon."
        }
    ]
}