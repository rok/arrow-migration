{
    "issue": {
        "title": "[C++][Dataset] CountRows occasionally segfaulting",
        "body": "***Note**: This issue was originally created as [ARROW-12668](https://issues.apache.org/jira/browse/ARROW-12668). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\n<https://github.com/apache/arrow/pull/9656/checks?check_run_id=2518312525>\r\n```\n\r\nStart test: dim() correctly determine numbers of rows and columns on arrow_dplyr_query object\r\n\r\n *** caught segfault ***\r\naddress 0x7ff7cf2cf8f8, cause 'invalid permissions'\r\n\r\nTraceback:\r\n 1: dataset___Scanner__CountRows(self)\r\n 2: scanner$CountRows()\r\n 3: dim.arrow_dplyr_query(.)\r\n 4: dim(.)\r\n 5: ds %>% filter(chr == \"a\") %>% dim()\r\n 6: eval_bare(expr, quo_get_env(quo))\r\n 7: quasi_label(enquo(object), label, arg = \"object\")\r\n 8: expect_identical(ds %>% filter(chr == \"a\") %>% dim(), c(2L, 7L))\r\n 9: eval(code, test_env)\r\n10: eval(code, test_env)\r\n11: withCallingHandlers({    eval(code, test_env)    if (!handled && !is.null(test)) {        skip_empty()    }}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,     message = handle_message, error = handle_error)\r\n12: doTryCatch(return(expr), name, parentenv, handler)\r\n13: tryCatchOne(expr, names, parentenv, handlers[[1L]])\r\n14: tryCatchList(expr, names[-nh], parentenv, handlers[-nh])\r\n15: doTryCatch(return(expr), name, parentenv, handler)\r\n16: tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]),     names[nh], parentenv, handlers[[nh]])\r\n17: tryCatchList(expr, classes, parentenv, handlers)\r\n18: tryCatch(withCallingHandlers({    eval(code, test_env)    if (!handled && !is.null(test)) {        skip_empty()    }}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,     message = handle_message, error = handle_error), error = handle_fatal,     skip = function(e) {    })\r\n19: test_code(desc, code, env = parent.frame(), reporter = reporter)\r\n20: testthat::test_that(what, {    skip_if(getOption(\"..skip.tests\", TRUE), \"arrow C++ library not available\")    code})\r\n21: test_that(\"dim() correctly determine numbers of rows and columns on arrow_dplyr_query object\",     {        skip_if_not_available(\"parquet\")        ds <- open_dataset(dataset_dir, partitioning = schema(part = uint8()))        expect_identical(ds %>% filter(chr == \"a\") %>% dim(),             c(2L, 7L))        expect_equal(ds %>% select(chr, fct, int) %>% dim(),             c(20L, 3L))        expect_identical(ds %>% select(chr, fct, int) %>% filter(chr ==             \"a\") %>% dim(), c(2L, 3L))    })\r\n22: eval(code, test_env)\r\n23: eval(code, test_env)\r\n24: withCallingHandlers({    eval(code, test_env)    if (!handled && !is.null(test)) {        skip_empty()    }}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,     message = handle_message, error = handle_error)\r\n25: doTryCatch(return(expr), name, parentenv, handler)\r\n26: tryCatchOne(expr, names, parentenv, handlers[[1L]])\r\n27: tryCatchList(expr, names[-nh], parentenv, handlers[-nh])\r\n28: doTryCatch(return(expr), name, parentenv, handler)\r\n29: tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]),     names[nh], parentenv, handlers[[nh]])\r\n30: tryCatchList(expr, classes, parentenv, handlers)\r\n31: tryCatch(withCallingHandlers({    eval(code, test_env)    if (!handled && !is.null(test)) {        skip_empty()    }}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,     message = handle_message, error = handle_error), error = handle_fatal,     skip = function(e) {    })\r\n32: test_code(NULL, exprs, env)\r\n33: source_file(path, child_env(env), wrap = wrap)\r\n34: FUN(X[[i]], ...)\r\n35: lapply(test_paths, test_one_file, env = env, wrap = wrap)\r\n36: force(code)\r\n37: doWithOneRestart(return(expr), restart)\r\n38: withOneRestart(expr, restarts[[1L]])\r\n39: withRestarts(testthat_abort_reporter = function() NULL, force(code))\r\n40: with_reporter(reporters$multi, lapply(test_paths, test_one_file,     env = env, wrap = wrap))\r\n41: test_files(test_dir = test_dir, test_package = test_package,     test_paths = test_paths, load_helpers = load_helpers, reporter = reporter,     env = env, stop_on_failure = stop_on_failure, stop_on_warning = stop_on_warning,     wrap = wrap, load_package = load_package)\r\n42: test_files(test_dir = path, test_paths = test_paths, test_package = package,     reporter = reporter, load_helpers = load_helpers, env = env,     stop_on_failure = stop_on_failure, stop_on_warning = stop_on_warning,     wrap = wrap, load_package = load_package, parallel = parallel)\r\n43: test_dir(\"testthat\", package = package, reporter = reporter,     ..., load_package = \"installed\")\r\n44: test_check(\"arrow\", reporter = arrow_reporter)\r\nAn irrecoverable exception occurred. R is aborting now ...\n```\r\nThe test also seems to give the wrong results sometimes (<https://github.com/apache/arrow/pull/9656/checks?check_run_id=2518312803>)\r\n```\n\r\n== Failed tests ================================================================\r\n-- Failure (test-dataset.R:148:3): dim() correctly determine numbers of rows and columns on arrow_dplyr_query object --\r\nds %>% filter(chr == \"a\") %>% dim() not identical to c(2L, 7L).\r\n1/2 mismatches\r\n[1] 1 - 2 == -1\r\n \n```",
        "created_at": "2021-05-06T14:20:03.000Z",
        "updated_at": "2021-05-06T22:34:29.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Type: bug"
        ],
        "closed": true,
        "closed_at": "2021-05-06T22:34:16.000Z"
    },
    "comments": [
        {
            "created_at": "2021-05-06T15:26:31.873Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-12668?focusedCommentId=17340263) by David Li (lidavidm):*\nThe bug is because this block is incredibly wrong:\r\n\r\n```cpp\n\r\n  FragmentVector fragments;\r\n  for (auto maybe_fragment : fragment_it) {\r\n    ARROW_ASSIGN_OR_RAISE(auto fragment, maybe_fragment);\r\n    auto count_fut = fragment->CountRows(scan_options_->filter, scan_options_);\r\n    // Take fragments by reference since future must complete before method returns\r\n    futures.push_back(\r\n        count_fut.Then([&fragments, fragment](util::optional<int64_t> count) -> int64_t {\r\n          if (count.has_value()) {\r\n            return *count;\r\n          }\r\n          fragments.push_back(fragment);\r\n          return 0;\r\n        }));\r\n  }\r\n```\r\n\u00a0\r\n- The stated assumption won't hold if one of the fragments raises\n- The callbacks are concurrently mutating something which is not thread-safe"
        },
        {
            "created_at": "2021-05-06T22:34:16.649Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-12668?focusedCommentId=17340461) by David Li (lidavidm):*\nIssue resolved by pull request 10259\n<https://github.com/apache/arrow/pull/10259>"
        }
    ]
}