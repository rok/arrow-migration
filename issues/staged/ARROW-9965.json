{
    "issue": {
        "title": "[Java] Buffer capacity calculations are slow for fixed-width vectors",
        "body": "***Note**: This issue was originally created as [ARROW-9965](https://issues.apache.org/jira/browse/ARROW-9965). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nIt turns out that setSafe performs a very expensive integer division when trying to compute buffer capacity; specifically, it divides by the field size, which isn't hardcoded. Although it is typically a power of 2 for alignment reasons, this doesn't compile down to a bitshift.\r\n\r\nThis is done here: https://github.com/apache/arrow/blob/175c53d0b17708312bfd1494c65824f690a6cc9a/java/vector/src/main/java/org/apache/arrow/vector/BaseFixedWidthVector.java#L189\r\n \r\nForcing a bitshift operation results in a large speedup in benchmarks. When turning off bounds checks (which affects another portion of set), microbenchmarks indicate that setting the elements of a vector via setSafe is increased by ~174% (almost 3 times faster). With bounds checks on, this is reduced to a 73% increase (Amdahl's).\r\n\r\nWe use setSafe right now in a hot loop to set Arrow vectors in an internal data-intensive service (for now), although in the future, we would prefer a more specialized vector append interface to skip all the other indirection and bit manipulation instructions, while not directly manipulating the exposed (native) memory.\r\n\r\nHere is the detailed analysis:\r\nTests were run on a machine with an Intel 8700k. Compiled with JDK 8, and run with the latest repo-provided JDK 14 on Ubuntu 20.04.\r\n```Java\n\r\nBenchmark results with arrow.enable_unsafe_memory_access=false, patch NOT applied\r\n# JMH version: 1.21\r\n# VM version: JDK 14.0.1, OpenJDK 64-Bit Server VM, 14.0.1+7-Ubuntu-1ubuntu1\r\n# VM invoker: /usr/lib/jvm/java-14-openjdk-amd64/bin/java\r\n# VM options: -Darrow.enable_unsafe_memory_access=false\r\n# Warmup: 5 iterations, 10 s each\r\n# Measurement: 5 iterations, 10 s each\r\n# Timeout: 10 min per iteration\r\n# Threads: 1 thread, will synchronize iterations\r\n# Benchmark mode: Average time, time/op\r\n# Benchmark: org.apache.arrow.vector.IntBenchmarks.setIntDirectly\r\n*snip*\r\nBenchmark Mode Cnt Score Error Units\r\nIntBenchmarks.setIntDirectly avgt 15 13.853 \u00b1 0.058 us/op\r\nIntBenchmarks.setWithValueHolder avgt 15 15.045 \u00b1 0.040 us/op\r\nIntBenchmarks.setWithWriter avgt 15 21.621 \u00b1 0.197 us/op\r\n\r\nBenchmark results with arrow.enable_unsafe_memory_access=false, patch applied\r\n\r\n# JMH version: 1.21\r\n# VM version: JDK 14.0.1, OpenJDK 64-Bit Server VM, 14.0.1+7-Ubuntu-1ubuntu1\r\n# VM invoker: /usr/lib/jvm/java-14-openjdk-amd64/bin/java\r\n# VM options: -Darrow.enable_unsafe_memory_access=false\r\n# Warmup: 5 iterations, 10 s each\r\n# Measurement: 5 iterations, 10 s each\r\n# Timeout: 10 min per iteration\r\n# Threads: 1 thread, will synchronize iterations\r\n# Benchmark mode: Average time, time/op\r\n# Benchmark: org.apache.arrow.vector.IntBenchmarks.setIntDirectly\r\n*snip*\r\nBenchmark Mode Cnt Score Error Units\r\nIntBenchmarks.setIntDirectly avgt 15 7.964 \u00b1 0.030 us/op\r\nIntBenchmarks.setWithValueHolder avgt 15 9.145 \u00b1 0.031 us/op\r\nIntBenchmarks.setWithWriter avgt 15 8.029 \u00b1 0.051 us/op\r\n\r\nBenchmark results with arrow.enable_unsafe_memory_access=true, patch NOT applied\r\n\r\n# JMH version: 1.21\r\n# VM version: JDK 14.0.1, OpenJDK 64-Bit Server VM, 14.0.1+7-Ubuntu-1ubuntu1\r\n# VM invoker: /usr/lib/jvm/java-14-openjdk-amd64/bin/java\r\n# VM options: -Darrow.enable_unsafe_memory_access=true\r\n# Warmup: 5 iterations, 10 s each\r\n# Measurement: 5 iterations, 10 s each\r\n# Timeout: 10 min per iteration\r\n# Threads: 1 thread, will synchronize iterations\r\n# Benchmark mode: Average time, time/op\r\n# Benchmark: org.apache.arrow.vector.IntBenchmarks.setIntDirectl\r\n\r\nBenchmark Mode Cnt Score Error Units\r\nIntBenchmarks.setIntDirectly avgt 15 9.563 \u00b1 0.335 us/op\r\nIntBenchmarks.setWithValueHolder avgt 15 9.266 \u00b1 0.064 us/op\r\nIntBenchmarks.setWithWriter avgt 15 18.806 \u00b1 0.154 us/op\r\n\r\nBenchmark results with arrow.enable_unsafe_memory_access=true, patch applied\r\n# JMH version: 1.21\r\n# VM version: JDK 14.0.1, OpenJDK 64-Bit Server VM, 14.0.1+7-Ubuntu-1ubuntu1\r\n# VM invoker: /usr/lib/jvm/java-14-openjdk-amd64/bin/java\r\n# VM options: -Darrow.enable_unsafe_memory_access=true\r\n# Warmup: 5 iterations, 10 s each\r\n# Measurement: 5 iterations, 10 s each\r\n# Timeout: 10 min per iteration\r\n# Threads: 1 thread, will synchronize iterations\r\n# Benchmark mode: Average time, time/op\r\n# Benchmark: org.apache.arrow.vector.IntBenchmarks.setIntDirectly\r\nBenchmark Mode Cnt Score Error Units\r\nIntBenchmarks.setIntDirectly avgt 15 3.490 \u00b1 0.175 us/op\r\nIntBenchmarks.setWithValueHolder avgt 15 3.806 \u00b1 0.015 us/op\r\nIntBenchmarks.setWithWriter avgt 15 5.490 \u00b1 0.304 us/op\r\n```\r\n\r\nI determined this by running the built-in Arrow JMH benchmarks on an 8700k. I left the CPU frequency scaling in the default state. The numbers seemed off for setting a value. I reran the benchmarks with the `prof=perfasm` option in JMH, which emitted annotated assembly for detected hotspots. Here is the relevant section:\r\n\r\n```Java\n\r\n0.06% \u2502 \u2502\u2502 0x00007f5a7f7beb6f: mov 0x30(%r12,%rsi,8),%rax ; implicit exception: dispatches to 0x00007f5a7f7bef28\r\n\u2502 \u2502\u2502 ;*getfield length {reexecute=0 rethrow=0 return_oop=0}\r\n\u2502 \u2502\u2502 ; - org.apache.arrow.memory.ArrowBuf::capacity@1 (line 138)\r\n\u2502 \u2502\u2502 ; - org.apache.arrow.vector.BaseFixedWidthVector::getValueBufferValueCapacity@4 (line 189)\r\n\u2502 \u2502\u2502 ; - org.apache.arrow.vector.BaseFixedWidthVector::getValueCapacity@1 (line 185)\r\n\u2502 \u2502\u2502 ; - org.apache.arrow.vector.BaseFixedWidthVector::handleSafe@2 (line 817)\r\n\u2502 \u2502\u2502 ; - org.apache.arrow.vector.IntVector::setSafe@2 (line 223)\r\n\u2502 \u2502\u2502 ; - org.apache.arrow.vector.IntBenchmarks::setWithValueHolder@51 (line 77)\r\n\u2502 \u2502\u2502 ; - org.apache.arrow.vector.generated.IntBenchmarks_setWithValueHolder_jmhTest::setWithValueHolder_avgt_jmhStub@15 (line 234)\r\n0.14% \u2502 \u2502\u2502 0x00007f5a7f7beb74: movsxd 0x10(%r12,%rdi,8),%rcx ;*i2l {reexecute=0 rethrow=0 return_oop=0}\r\n\u2502 \u2502\u2502 ; - org.apache.arrow.vector.BaseFixedWidthVector::getValueBufferValueCapacity@11 (line 189)\r\n\u2502 \u2502\u2502 ; - org.apache.arrow.vector.BaseFixedWidthVector::getValueCapacity@1 (line 185)\r\n\u2502 \u2502\u2502 ; - org.apache.arrow.vector.BaseFixedWidthVector::handleSafe@2 (line 817)\r\n\u2502 \u2502\u2502 ; - org.apache.arrow.vector.IntVector::setSafe@2 (line 223)\r\n\u2502 \u2502\u2502 ; - org.apache.arrow.vector.IntBenchmarks::setWithValueHolder@51 (line 77)\r\n\u2502 \u2502\u2502 ; - org.apache.arrow.vector.generated.IntBenchmarks_setWithValueHolder_jmhTest::setWithValueHolder_avgt_jmhStub@15 (line 234)\r\n*snip*\r\n1.43% \u2502\u2502 \u2502 \u2502\u2502 0x00007f5a7f7beb9b: idivq %rcx,%rax ;*ldiv {reexecute=0 rethrow=0 return_oop=0}\r\n\u2502\u2502 \u2502 \u2502\u2502 ; - org.apache.arrow.vector.BaseFixedWidthVector::getValueBufferValueCapacity@12 (line 189)\r\n\u2502\u2502 \u2502 \u2502\u2502 ; - org.apache.arrow.vector.BaseFixedWidthVector::getValueCapacity@1 (line 185)\r\n\u2502\u2502 \u2502 \u2502\u2502 ; - org.apache.arrow.vector.BaseFixedWidthVector::handleSafe@2 (line 817)\r\n\u2502\u2502 \u2502 \u2502\u2502 ; - org.apache.arrow.vector.IntVector::setSafe@2 (line 223)\r\n\u2502\u2502 \u2502 \u2502\u2502 ; - org.apache.arrow.vector.IntBenchmarks::setWithValueHolder@51 (line 77)\r\n\u2502\u2502 \u2502 \u2502\u2502 ; - org.apache.arrow.vector.generated.IntBenchmarks_setWithValueHolder_jmhTest::setWithValueHolder_avgt_jmhStub@15 (line 234)\r\n68.16% \u2502\u2502 \u2198 \u2502\u2502 0x00007f5a7f7beb9e: cmp $0x7fffffff,%rax\r\n\u2502\u2502 \u2502\u2502 0x00007f5a7f7beba5: jnle 0x7f5a7f7bec8c ;*ifgt {reexecute=0 rethrow=0 return_oop=0}\r\n\u2502\u2502 \u2502\u2502 ; - java.lang.Math::min@3 (line 1552)\r\n\u2502\u2502 \u2502\u2502 ; - org.apache.arrow.memory.util.LargeMemoryUtil::capAtMaxInt@4 (line 44)\r\n\u2502\u2502 \u2502\u2502 ; - org.apache.arrow.vector.BaseFixedWidthVector::getValueBufferValueCapacity@13 (line 189)\r\n\u2502\u2502 \u2502\u2502 ; - org.apache.arrow.vector.BaseFixedWidthVector::getValueCapacity@1 (line 185)\r\n\u2502\u2502 \u2502\u2502 ; - org.apache.arrow.vector.BaseFixedWidthVector::handleSafe@2 (line 817)\r\n\u2502\u2502 \u2502\u2502 ; - org.apache.arrow.vector.IntVector::setSafe@2 (line 223)\r\n\u2502\u2502 \u2502\u2502 ; - org.apache.arrow.vector.IntBenchmarks::setWithValueHolder@51 (line 77)\r\n\u2502\u2502 \u2502\u2502 ; - org.apache.arrow.vector.generated.IntBenchmarks_setWithValueHolder_jmhTest::setWithValueHolder_avgt_jmhStub@15 (line 234)\r\n```\r\n\r\nThe hot instruction is misattributed, probably due to event instruction skid. But integer division is known to be expensive to implement. We can verify this with Agner Fog's instruction tables: https://www.agner.org/optimize/instruction_tables.pdf . Searching for idiv gives high numbers in the table provided, as expected.\r\n\r\nAfter noting all of this, we can apply the following patch, which produces the speedup as above:\r\n```Java\n\r\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/BaseFixedWidthVector.java b/java/vector/src/main/java/org/apache/arrow/vector/BaseFixedWidthVector.java\r\nindex ee47f6dd8..0c9a57bf9 100644\r\n--- a/java/vector/src/main/java/org/apache/arrow/vector/BaseFixedWidthVector.java\r\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/BaseFixedWidthVector.java\r\n@@ -47,6 +47,7 @@ import io.netty.util.internal.PlatformDependent;\r\npublic abstract class BaseFixedWidthVector extends BaseValueVector\r\nimplements FixedWidthVector, FieldVector, VectorDefinitionSetter {\r\nprivate final int typeWidth;\r\n+ private final int typeWidthAsExactBitShiftOrNegOne;\r\n\r\nprotected int lastValueCapacity;\r\n\r\n@@ -66,6 +67,7 @@ public abstract class BaseFixedWidthVector extends BaseValueVector\r\npublic BaseFixedWidthVector(Field field, final BufferAllocator allocator, final int typeWidth) {\r\nsuper(allocator);\r\nthis.typeWidth = typeWidth;\r\n+ this.typeWidthAsExactBitShiftOrNegOne = log2ExactOrNeg1(typeWidth);\r\nthis.field = field;\r\nvalueCount = 0;\r\nallocationMonitor = 0;\r\n@@ -186,7 +188,13 @@ public abstract class BaseFixedWidthVector extends BaseValueVector\r\n}\r\n\r\nprivate int getValueBufferValueCapacity() {\r\n- return capAtMaxInt(valueBuffer.capacity() / typeWidth);\r\n+ if (typeWidthAsExactBitShiftOrNegOne == -1) {\r\n+ // Slow path - integral division is very very expensive, and code here is part of\r\n+ // setSafe's hot loop\r\n+ // The JVM did not optimize integral division into bit shifts\r\n+ return capAtMaxInt(valueBuffer.capacity() / typeWidth);\r\n+ }\r\n+ return capAtMaxInt(valueBuffer.capacity() >> typeWidthAsExactBitShiftOrNegOne);\r\n}\r\n\r\nprivate int getValidityBufferValueCapacity() {\r\n@@ -903,4 +911,12 @@ public abstract class BaseFixedWidthVector extends BaseValueVector\r\nreturn visitor.visit(this, value);\r\n}\r\n\r\n+ private int log2ExactOrNeg1(int x) {\r\n+ final boolean isPowerOfTwo = x > 0 & (x & (x - 1)) == 0;\r\n+ if (!isPowerOfTwo) {\r\n+ return -1;\r\n+ }\r\n+ return (Integer.SIZE - 1) - Integer.numberOfLeadingZeros(x);\r\n+ }\r\n+\r\n}\r\n```\r\n\r\nAttached is the generated assembly as printed by JMH, before and after. I renamed some variables for clarity after generating the results, but the logic is unchanged.\r\n\r\nI also did a quick test with JDK 8 - this was where I originally ran the benchmarks. The idiv instruction was present there too.\r\n\r\nAn initial version of this patch cached the value - this produces about the same speedup.\r\n\r\nAre people fine with this approach?",
        "created_at": "2020-09-10T15:17:01.000Z",
        "updated_at": "2020-09-28T15:14:50.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: Java",
            "Type: enhancement"
        ],
        "closed": true,
        "closed_at": "2020-09-28T02:09:24.000Z"
    },
    "comments": [
        {
            "created_at": "2020-09-28T02:09:24.620Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-9965?focusedCommentId=17202962) by Liya Fan (fan_li_ya):*\nIssue resolved by pull request 8214\n<https://github.com/apache/arrow/pull/8214>"
        }
    ]
}