{
    "issue": {
        "title": "[Python] Tests are failed with fsspec-0.8.5",
        "body": "***Note**: This issue was originally created as [ARROW-10934](https://issues.apache.org/jira/browse/ARROW-10934). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nhttps://ci.appveyor.com/project/ApacheSoftwareFoundation/arrow/builds/36851219/job/lwywl76d82coawpd?fullLog=true#L2284\r\n\r\n```\n\r\n================================== FAILURES ===================================\r\n_ test_get_file_info_with_selector[PyFileSystem(FSSpecHandler(fsspec.filesystem(\"memory\")))] _\r\nfs = <pyarrow._fs.PyFileSystem object at 0x00000140F4C0A3A0>\r\npathfn = <function py_fsspec_memoryfs.<locals>.<lambda> at 0x00000140F4BFBB58>\r\n    def test_get_file_info_with_selector(fs, pathfn):\r\n        base_dir = pathfn('selector-dir/')\r\n        file_a = pathfn('selector-dir/test_file_a')\r\n        file_b = pathfn('selector-dir/test_file_b')\r\n        dir_a = pathfn('selector-dir/test_dir_a')\r\n        file_c = pathfn('selector-dir/test_dir_a/test_file_c')\r\n        dir_b = pathfn('selector-dir/test_dir_b')\r\n    \r\n        try:\r\n            fs.create_dir(base_dir)\r\n            with fs.open_output_stream(file_a):\r\n                pass\r\n            with fs.open_output_stream(file_b):\r\n                pass\r\n            fs.create_dir(dir_a)\r\n            with fs.open_output_stream(file_c):\r\n                pass\r\n            fs.create_dir(dir_b)\r\n    \r\n# recursive selector\r\n            selector = FileSelector(base_dir, allow_not_found=False,\r\n                                    recursive=True)\r\n            assert selector.base_dir == base_dir\r\n    \r\n            infos = fs.get_file_info(selector)\r\n            if fs.type_name == \"py::fsspec+s3\":\r\n# s3fs only lists directories if they are not empty\r\n                assert len(infos) == 4\r\n            else:\r\n                assert len(infos) == 5\r\n    \r\n            for info in infos:\r\n                if (info.path.endswith(file_a) or info.path.endswith(file_b) or\r\n                        info.path.endswith(file_c)):\r\n                    assert info.type == FileType.File\r\n                elif (info.path.rstrip(\"/\").endswith(dir_a) or\r\n                      info.path.rstrip(\"/\").endswith(dir_b)):\r\n                    assert info.type == FileType.Directory\r\n                else:\r\n                    raise ValueError('unexpected path {}'.format(info.path))\r\n                check_mtime_or_absent(info)\r\n    \r\n# non-recursive selector -> not selecting the nested file_c\r\n            selector = FileSelector(base_dir, recursive=False)\r\n    \r\n            infos = fs.get_file_info(selector)\r\n            if fs.type_name == \"py::fsspec+s3\":\r\n# s3fs only lists directories if they are not empty\r\n                assert len(infos) == 3\r\n            else:\r\n                assert len(infos) == 4\r\n    \r\n        finally:\r\n>           fs.delete_dir(base_dir)\r\npyarrow\\tests\\test_fs.py:716: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\npyarrow\\_fs.pyx:472: in pyarrow._fs.FileSystem.delete_dir\r\n    check_status(self.fs.DeleteDir(directory))\r\npyarrow\\_fs.pyx:1035: in pyarrow._fs._cb_delete_dir\r\n    handler.delete_dir(frombytes(path))\r\npyarrow\\fs.py:262: in delete_dir\r\n    self.fs.rm(path, recursive=True)\r\nC:\\Miniconda37-x64\\envs\\arrow\\lib\\site-packages\\fsspec\\implementations\\memory.py:176: in rm\r\n    self.rm_file(p)\r\nC:\\Miniconda37-x64\\envs\\arrow\\lib\\site-packages\\fsspec\\spec.py:840: in rm_file\r\n    self._rm(path)\r\nC:\\Miniconda37-x64\\envs\\arrow\\lib\\site-packages\\fsspec\\implementations\\memory.py:163: in _rm\r\n    self.rmdir(path)\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\nself = <fsspec.implementations.memory.MemoryFileSystem object at 0x00000140F4ABBC58>\r\npath = 'selector-dir'\r\n    def rmdir(self, path):\r\n        path = path.rstrip(\"/\")\r\n        if path in self.pseudo_dirs:\r\n            if not self.ls(path):\r\n                self.pseudo_dirs.remove(path)\r\n            else:\r\n>               raise OSError(ENOTEMPTY, \"Directory not empty\", path)\r\nE               OSError: [Errno 41] Directory not empty: 'selector-dir'\r\nC:\\Miniconda37-x64\\envs\\arrow\\lib\\site-packages\\fsspec\\implementations\\memory.py:110: OSError\r\n__ test_delete_dir[PyFileSystem(FSSpecHandler(fsspec.filesystem(\"memory\")))] __\r\nfs = <pyarrow._fs.PyFileSystem object at 0x00000140F4C1CDC0>\r\npathfn = <function py_fsspec_memoryfs.<locals>.<lambda> at 0x00000140F50BC738>\r\n    def test_delete_dir(fs, pathfn):\r\n        skip_fsspec_s3fs(fs)\r\n    \r\n        d = pathfn('directory/')\r\n        nd = pathfn('directory/nested/')\r\n    \r\n        fs.create_dir(nd)\r\n>       fs.delete_dir(d)\r\npyarrow\\tests\\test_fs.py:743: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\npyarrow\\_fs.pyx:472: in pyarrow._fs.FileSystem.delete_dir\r\n    check_status(self.fs.DeleteDir(directory))\r\npyarrow\\_fs.pyx:1035: in pyarrow._fs._cb_delete_dir\r\n    handler.delete_dir(frombytes(path))\r\npyarrow\\fs.py:262: in delete_dir\r\n    self.fs.rm(path, recursive=True)\r\nC:\\Miniconda37-x64\\envs\\arrow\\lib\\site-packages\\fsspec\\implementations\\memory.py:176: in rm\r\n    self.rm_file(p)\r\nC:\\Miniconda37-x64\\envs\\arrow\\lib\\site-packages\\fsspec\\spec.py:840: in rm_file\r\n    self._rm(path)\r\nC:\\Miniconda37-x64\\envs\\arrow\\lib\\site-packages\\fsspec\\implementations\\memory.py:163: in _rm\r\n    self.rmdir(path)\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\nself = <fsspec.implementations.memory.MemoryFileSystem object at 0x00000140F4ABBC58>\r\npath = 'directory'\r\n    def rmdir(self, path):\r\n        path = path.rstrip(\"/\")\r\n        if path in self.pseudo_dirs:\r\n            if not self.ls(path):\r\n                self.pseudo_dirs.remove(path)\r\n            else:\r\n>               raise OSError(ENOTEMPTY, \"Directory not empty\", path)\r\nE               OSError: [Errno 41] Directory not empty: 'directory'\r\nC:\\Miniconda37-x64\\envs\\arrow\\lib\\site-packages\\fsspec\\implementations\\memory.py:110: OSError\r\n```",
        "created_at": "2020-12-16T03:23:30.000Z",
        "updated_at": "2020-12-16T10:08:41.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: Python",
            "Type: enhancement"
        ],
        "closed": true,
        "closed_at": "2020-12-16T10:08:18.000Z"
    },
    "comments": [
        {
            "created_at": "2020-12-16T03:26:19.540Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-10934?focusedCommentId=17250079) by Kouhei Sutou (kou):*\n`[~jorisvandenbossche]` Could you take a look at this?"
        },
        {
            "created_at": "2020-12-16T08:16:44.954Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-10934?focusedCommentId=17250161) by Joris Van den Bossche (jorisvandenbossche):*\nThanks for the ping, will take a look"
        },
        {
            "created_at": "2020-12-16T09:01:30.866Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-10934?focusedCommentId=17250179) by Joris Van den Bossche (jorisvandenbossche):*\nA regression in fsspec 0.8.5 (but only for the in-memory filesystem), reported this as https://github.com/intake/filesystem_spec/issues/500"
        },
        {
            "created_at": "2020-12-16T10:08:18.413Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-10934?focusedCommentId=17250218) by Antoine Pitrou (apitrou):*\nIssue resolved by pull request 8935\n<https://github.com/apache/arrow/pull/8935>"
        }
    ]
}