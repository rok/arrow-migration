{
    "issue": {
        "title": "[C++] Add support for aggregation to the Substrait consumer",
        "body": "***Note**: This issue was originally created as [ARROW-15591](https://issues.apache.org/jira/browse/ARROW-15591). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nThe streaming execution engine supports aggregation (i.e. group by).  The Substrait consumer does not currently consume aggregation relations.  We should add support for this.",
        "created_at": "2022-02-05T02:37:49.000Z",
        "updated_at": "2022-07-26T09:21:54.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Type: enhancement"
        ],
        "closed": true,
        "closed_at": "2022-07-25T23:59:22.000Z"
    },
    "comments": [
        {
            "created_at": "2022-05-12T02:47:20.339Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15591?focusedCommentId=17535821) by Vibhatha Lakmal Abeykoon (vibhatha):*\n`[~westonpace]` \u00a0\r\n\r\nI have a few doubts about this.\r\n\r\nLooking into this sample Substrait plan generated by `<font color=\"#FF0000\">isthmus</font>`\r\n```java\n\r\n\"relations\": [{\r\n\u00a0 \u00a0 \u00a0 \"rel\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \"aggregate\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"input\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"read\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"base_schema\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"names\": [\"A\", \"B\", \"C\"],\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"struct\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"types\": [{\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"i32\": {}\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }, {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"i32\": {}\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }, {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"i32\": {}\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }]\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"local_files\": {\u00a0\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"items\": [\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"uri_file\": \"file:///tmp/dat.parquet\",\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"format\": \"FILE_FORMAT_PARQUET\"\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ]\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"groupings\": [{\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"groupingExpressions\": [{\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"selection\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"directReference\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"structField\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"field\": 0\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }]\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }],\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"measures\": [{\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"measure\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"functionReference\": 0,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"args\": [],\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"sorts\": [],\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"phase\": \"AGGREGATION_PHASE_INITIAL_TO_RESULT\",\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"outputType\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"i64\": {}\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }]\r\n\u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 }],\r\n\u00a0 \u00a0 \"extensionUris\": [{\r\n\u00a0 \u00a0 \u00a0 \"extension_uri_anchor\": 0,\r\n\u00a0 \u00a0 \u00a0 \"uri\": \"https://github.com/apache/arrow/blob/master/format/substrait/extension_types.yaml\"\r\n\u00a0 \u00a0 }],\r\n\u00a0 \u00a0 \"extensions\": [{\r\n\u00a0 \u00a0 \u00a0 \"extension_function\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \"extension_uri_reference\": 0,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \"function_anchor\": 0,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \"name\": \"count\"\r\n\u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 }],\n```\r\n\u00a0\r\n\r\nThis is a sample Substrait Plan for a Groupby operation based on the query\r\n\r\n\u00a0\r\n```java\n\r\nselect count(a) from T1 group by b\n```\r\n\u00a0\r\n\r\nIn here, we can clearly extract the targets and may be names from `groupings`.\r\nBut extracting the `<font color=\"#FF0000\">aggregates</font>` is not very clear.\u00a0\r\n\r\nBecause `measures` include list of `<font color=\"#FF0000\">AggregateFunction</font>` which is not a 1:1 mapping with `<font color=\"#FF0000\">Aggregate</font>` defined in Arrow.\u00a0\r\n```java\n\r\nstruct ARROW_EXPORT Aggregate {  \r\n  /// the name of the aggregation function  \r\n  std::string function;\r\n  /// options for the aggregation function\r\n  const FunctionOptions* options;\r\n}; \n```\r\nIf we take a look at the measures(Optional, required if no grouping sets), it contains the `<font color=\"#FF0000\">functionReference</font>` which can be\u00a0\r\nextracted from the extensions where the `<font color=\"#FF0000\">function_anchor</font>` is what is referred by `<font color=\"#FF0000\">functionReference</font>`.\r\n\r\nIs this a valid statement?\u00a0\r\n\r\nTo extract aggregates, I think we can iterate through measures and get the `<font color=\"#FF0000\">functionReferences</font>` and then\r\nfrom the extensions we can get the corresponding ones. There can be a two measures, but it would point to\u00a0\r\nthe same `<font color=\"#FF0000\">extension_function</font>`.\u00a0\r\n\r\nIs this thought process accurate with the Substrait definition? Is there a cleaner way than this to extract this information?"
        },
        {
            "created_at": "2022-05-12T07:17:01.473Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15591?focusedCommentId=17535917) by Weston Pace (westonpace):*\nFirst of all, how did you get that cool red text?\r\n\r\nThe measure:\r\n```\n\r\n\"measure\": {\r\n              \"functionReference\": 0,\r\n              \"args\": [],\r\n              \"sorts\": [],\r\n              \"phase\": \"AGGREGATION_PHASE_INITIAL_TO_RESULT\",\r\n              \"outputType\": {\r\n                \"i64\": {}\r\n              }\r\n            }\r\n```\r\n\r\nwill have to map to:\r\n\r\n```\n\r\nAggregate{\"hash_count\", CountOptions{}}\r\n```\r\n\r\n> If we take a look at the measures(Optional, required if no grouping sets), it contains the `functionReference` which can be \n> extracted from the extensions where the `function_anchor` is what is referred by `functionReference`.\r\n\r\nYes.  We have to do the same thing for scalar functions.  We should reuse code where we can.  Mapping aggregate functions is probably a separate JIRA all on its own.  You might want to take a look at ARROW-15582 where I propose a general way of doing this.  I believe `[~sanjibansg]` has a prototype for scalar functions but he is out until next week so this ticket might be best to wait until he is back and we can collaborate."
        },
        {
            "created_at": "2022-05-12T07:26:07.910Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15591?focusedCommentId=17535923) by Vibhatha Lakmal Abeykoon (vibhatha):*\n`[~westonpace]` \u00a0\r\n\r\n> First of all, how did you get that cool red text?\r\n\r\nUnfortunately this is manual labor :D\u00a0(I selected the text and colored it, don't know if there is a shortcut for catching ``)\r\n\r\nAnother issue I am having is how to identify the keys (aggregation applied columns). It is not included within the Substrait very neatly. There are expressions which falls inside the aggregator relation, but that is not a clear way to extract items. I generated the query from an old fork (`<font color=\"#FF0000\">isthmus</font>`). I am re-checking it now."
        },
        {
            "created_at": "2022-07-25T23:59:22.541Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15591?focusedCommentId=17571139) by Weston Pace (westonpace):*\nIssue resolved by pull request 13130\n<https://github.com/apache/arrow/pull/13130>"
        }
    ]
}