{
    "issue": {
        "title": "[C++] Crash of out-of-bounds memory accessing in key_hash if a key is smaller than int64",
        "body": "***Note**: This issue was originally created as [ARROW-14898](https://issues.apache.org/jira/browse/ARROW-14898). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nI encountered a crash when executing GroupBy on specific data with ARROW_JEMALLOC=ON. I can't use a simple test to reproduce the crash. So I put the code and data here. I think the root cause is the tail process in `Hashing::hash_varlen` of `key_hash.cc.`\r\n\r\nThe steps of related code are as follows:\r\n1. `Hashing::hash_varlen` calls `helper_tail`\u00a0for the tail part of the key\n1. `helper_tail` calls `util::SafeLoadAs` to load 8 bytes data of the key\n1. `util::SafeLoadAs` calls `std::memcpy` to copy 8 bytes of data from the key\n   \n   If the key is less than 8 bytes, the `std::memcpy` still copies 8 bytes which may access illegal memory.\n   \n   Stacktrace:\n   ```\n   \n   Thread 0 Crashed:: Dispatch queue: com.apple.main-thread\n   0 \u00a0 libarrow.700.0.0.dylib \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a00x000000010a77af2c std::__1::enable_if<std::is_trivial<unsigned long long const>::value, unsigned long long const>::type arrow::util::SafeLoadAs<unsigned long long const>(unsigned char const*) + 12 (ubsan.h:59)\n   1 \u00a0 libarrow.700.0.0.dylib \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a00x000000010a779c95 arrow::compute::Hashing::helper_tail(unsigned int, unsigned long long, unsigned char const*, unsigned int) + 37 (key_hash.cc:130)\n   2 \u00a0 libarrow.700.0.0.dylib \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a00x000000010a77a62d arrow::compute::Hashing::hash_varlen(long long, unsigned int, unsigned int const*, unsigned char const*, unsigned int*, unsigned int*) + 381 (key_hash.cc:234)\n   3 \u00a0 libarrow.700.0.0.dylib \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a00x000000010a77abb8 arrow::compute::Hashing::HashMultiColumn(std::__1::vector<arrow::compute::KeyEncoder::KeyColumnArray, std::__1::allocator<arrow::compute::KeyEncoder::KeyColumnArray> > const&, arrow::compute::KeyEncoder::KeyEncoderContext*, unsigned int*) + 1176 (key_hash.cc:292)\n   4 \u00a0 libarrow.700.0.0.dylib \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a00x000000010a9ee135 arrow::compute::internal::(anonymous namespace)::GrouperFastImpl::ConsumeImpl(arrow::compute::ExecBatch const&) + 2149 (hash_aggregate.cc:355)\n   5 \u00a0 libarrow.700.0.0.dylib \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a00x000000010a9ea0d9 arrow::compute::internal::(anonymous namespace)::GrouperFastImpl::Consume(arrow::compute::ExecBatch const&) + 1001 (hash_aggregate.cc:297)\n   6 \u00a0 libarrow.700.0.0.dylib \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a00x000000010aa856ef arrow::compute::internal::GroupBy(std::__1::vector<arrow::Datum, std::__1::allocator<arrow::Datum> > const&, std::__1::vector<arrow::Datum, std::__1::allocator<arrow::Datum> > const&, std::__1::vector<arrow::compute::internal::Aggregate, std::__1::allocator<arrow::compute::internal::Aggregate> > const&, bool, arrow::compute::ExecContext*)::$_2::operator()() const + 607 (hash_aggregate.cc:2501)\n   7 \u00a0 libarrow.700.0.0.dylib \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a00x000000010aa85414 arrow::internal::FnOnce<arrow::Status ()>::FnImpl<arrow::compute::internal::GroupBy(std::__1::vector<arrow::Datum, std::__1::allocator<arrow::Datum> > const&, std::__1::vector<arrow::Datum, std::__1::allocator<arrow::Datum> > const&, std::__1::vector<arrow::compute::internal::Aggregate, std::__1::allocator<arrow::compute::internal::Aggregate> > const&, bool, arrow::compute::ExecContext*)::$_2>::invoke() + 52 (functional.h:152)\n   8 \u00a0 libarrow.700.0.0.dylib \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a00x000000010a46ab0d arrow::internal::FnOnce<arrow::Status ()>::operator()() && + 77 (functional.h:140)\n   9 \u00a0 libarrow.700.0.0.dylib \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a00x000000010a46911f arrow::internal::(anonymous namespace)::SerialTaskGroup::AppendReal(arrow::internal::FnOnce<arrow::Status ()>) + 335 (task_group.cc:49)\n   10 \u00a0libarrow.700.0.0.dylib \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a00x000000010a9d8856 void arrow::internal::TaskGroup::Append<arrow::compute::internal::GroupBy(std::__1::vector<arrow::Datum, std::__1::allocator<arrow::Datum> > const&, std::__1::vector<arrow::Datum, std::__1::allocator<arrow::Datum> > const&, std::__1::vector<arrow::compute::internal::Aggregate, std::__1::allocator<arrow::compute::internal::Aggregate> > const&, bool, arrow::compute::ExecContext*)::$_2>(arrow::compute::internal::GroupBy(std::__1::vector<arrow::Datum, std::__1::allocator<arrow::Datum> > const&, std::__1::vector<arrow::Datum, std::__1::allocator<arrow::Datum> > const&, std::__1::vector<arrow::compute::internal::Aggregate, std::__1::allocator<arrow::compute::internal::Aggregate> > const&, bool, arrow::compute::ExecContext*)::$_2&&) + 102 (task_group.h:59)\n   11 \u00a0libarrow.700.0.0.dylib \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a00x000000010a9d6e18 arrow::compute::internal::GroupBy(std::__1::vector<arrow::Datum, std::__1::allocator<arrow::Datum> > const&, std::__1::vector<arrow::Datum, std::__1::allocator<arrow::Datum> > const&, std::__1::vector<arrow::compute::internal::Aggregate, std::__1::allocator<arrow::compute::internal::Aggregate> > const&, bool, arrow::compute::ExecContext*) + 4472 (hash_aggregate.cc:2489)\n   12 \u00a0arrow-compute-aggregate-test \u00a0 \u00a0 \u00a00x000000010242d549 run_group_by(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&) + 1001 (hash_aggregate_test.cc:2901)\n   13 \u00a0arrow-compute-aggregate-test \u00a0 \u00a0 \u00a00x000000010242d124 GroupBy_wtf_Test::TestBody() + 68 (hash_aggregate_test.cc:2909)\n   14 \u00a0libarrow_testing.700.0.0.dylib \u00a0 \u00a00x0000000102fb3344 void testing::internal::HandleSehExceptionsInMethodIfSupported<testing::Test, void>(testing::Test*, void (testing::Test::*)(), char const*) + 132\n   15 \u00a0libarrow_testing.700.0.0.dylib \u00a0 \u00a00x0000000102f75d3b void testing::internal::HandleExceptionsInMethodIfSupported<testing::Test, void>(testing::Test*, void (testing::Test::*)(), char const*) + 123\n   16 \u00a0libarrow_testing.700.0.0.dylib \u00a0 \u00a00x0000000102f75c73 testing::Test::Run() + 195\n   17 \u00a0libarrow_testing.700.0.0.dylib \u00a0 \u00a00x0000000102f76e54 testing::TestInfo::Run() + 244\n   18 \u00a0libarrow_testing.700.0.0.dylib \u00a0 \u00a00x0000000102f77f95 testing::TestSuite::Run() + 261\n   19 \u00a0libarrow_testing.700.0.0.dylib \u00a0 \u00a00x0000000102f8725d testing::internal::UnitTestImpl::RunAllTests() + 1021\n   20 \u00a0libarrow_testing.700.0.0.dylib \u00a0 \u00a00x0000000102fb8894 bool testing::internal::HandleSehExceptionsInMethodIfSupported<testing::internal::UnitTestImpl, bool>(testing::internal::UnitTestImpl*, bool (testing::internal::UnitTestImpl::*)(), char const*) + 132\n   21 \u00a0libarrow_testing.700.0.0.dylib \u00a0 \u00a00x0000000102f86bfb bool testing::internal::HandleExceptionsInMethodIfSupported<testing::internal::UnitTestImpl, bool>(testing::internal::UnitTestImpl*, bool (testing::internal::UnitTestImpl::*)(), char const*) + 123\n   22 \u00a0libarrow_testing.700.0.0.dylib \u00a0 \u00a00x0000000102f86acd testing::UnitTest::Run() + 205\n   23 \u00a0arrow-compute-aggregate-test \u00a0 \u00a0 \u00a00x00000001024adab1 RUN_ALL_TESTS() + 17\n   24 \u00a0arrow-compute-aggregate-test \u00a0 \u00a0 \u00a00x00000001024ada90 main + 64\n   25 \u00a0libdyld.dylib \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 0x00007fff204def3d start + 1\n   ```\n   The code and data file [arrow_14898.arr](arrow_14898.arr) to reproduce the crash. You can paste it into the end of\u00a0\n   `arrow/cpp/src/arrow/compute/kernels/hash_aggregate_test.cc`\n   {code:c++}\n#include \"arrow/ipc/api.h\"\r\n#include \"arrow/io/file.h\"\r\n\r\n#include <string>\r\n#include <vector>\r\n\r\nTEST(GroupBy, ARROW_14898) {\r\n  // Repeat enough times\r\n  for (int i = 0; i < 100; i++) {\r\n    // Read file\r\n    auto file_patch = \"arrow_14898.arr\";\r\n    auto mmap_file =\r\n        arrow::io::MemoryMappedFile::Open(file_patch, arrow::io::FileMode::READ)\r\n            .ValueOrDie();\r\n    auto record_batch_reader =\r\n        arrow::ipc::RecordBatchFileReader::Open(mmap_file.get(),\r\n                                                arrow::ipc::IpcReadOptions::Defaults())\r\n            .ValueOrDie();\r\n    auto record_batch = record_batch_reader->ReadRecordBatch(0).ValueOrDie();\r\n\r\n    // Create data for GroupBy\r\n    // If the size is close to 8192, the crash happens\r\n    int size = 8192;\r\n    std::vector<std::string> vec(size, \"a\");\r\n    std::shared_ptr<arrow::Array> array;\r\n    arrow::StringBuilder builder;\r\n    auto _ = builder.AppendValues(vec);\r\n    _ = builder.Finish(&array);\r\n\r\n    // Call GroupBy will crash in Hashing::helper_tail\r\n    arrow::compute::CountOptions all(arrow::compute::CountOptions::ALL);\r\n    auto res =\r\n        arrow::compute::internal::GroupBy({array}, {array}, `\"hash_count\", &all`, false);\r\n  }\r\n}\r\n{code}",
        "created_at": "2021-11-29T06:31:28.000Z",
        "updated_at": "2021-12-16T19:41:37.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Type: bug"
        ],
        "closed": true,
        "closed_at": "2021-12-14T16:16:04.000Z"
    },
    "comments": [
        {
            "created_at": "2021-12-14T16:16:04.942Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-14898?focusedCommentId=17459280) by Antoine Pitrou (apitrou):*\nIssue resolved by pull request 11789\n<https://github.com/apache/arrow/pull/11789>"
        }
    ]
}