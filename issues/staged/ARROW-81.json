{
    "issue": {
        "title": "[Format] Add a Category logical type (distinct from dictionary-encoding)",
        "body": "***Note**: This issue was originally created as [ARROW-81](https://issues.apache.org/jira/browse/ARROW-81). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nA Category (or \"factor\") is a dictionary-encoded array whose dictionary has semantic meaning. The data consists of\n\n- An array of integer \"codes\"\n- A child array of some other type, known as the \"categories\" or \"levels\" of the array. Typically there is an \"ordered\" boolean flag indicating whether the order of the categories is meaningful.\n\nCategory/factor types are used in a number of common statistical analyses. See, for example, http://www.voteview.com/R_Ordered_Logistic_or_Probit_Regression.htm. It is a basic requirement for Python and R, at least, as Arrow C++ consumers, to have this type. Separately, we should consider what is necessary to be able to transmit category data in IPCs \u2013 possible an expansion of the Arrow format. ",
        "created_at": "2016-03-28T00:56:44.000Z",
        "updated_at": "2017-02-13T16:34:48.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Type: enhancement"
        ],
        "closed": true,
        "closed_at": "2017-01-23T14:13:48.000Z",
        "milestone": 14
    },
    "comments": [
        {
            "created_at": "2016-08-09T23:31:42.293Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-81?focusedCommentId=15414445) by Wes McKinney (wesm):*\nA couple more notes on this:\n\nWhile creating the Feather format, which utilizes Arrow for much of its memory layout, we (Hadley Wickham and I) ran into this limitation in the current draft of Arrow metadata (https://github.com/apache/arrow/blob/master/format/Message.fbs).\n\nIt would be great to reconcile this need to make progress toward a canonical metadata.\n\nThis data type also has the benefit of reducing memory usage for arrays (e.g. with string logical type) containing many duplicate values. "
        },
        {
            "created_at": "2016-08-17T11:35:52.964Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-81?focusedCommentId=15424330) by Julian Hyde (julianhyde):*\nSince Arrow is a general-purpose data format, this requirement seems to me to be too closely targeted at a particular problem domain.\n\nTo illustrate, consider another domain, OLAP, where a dimension has a key, a name, a caption (localized name), a localized description, an order key and perhaps user-defined properties. I'm not claiming that OLAP dimensions are the \"right\" model either.\n\nI suspect that the \"right\" model is to allow additional attributes in the dictionary (in addition to the single \"value\" attribute at present). By convention, there would be one or more attribute names that define a category/factor when Python or R reads the dictionary."
        },
        {
            "created_at": "2016-08-17T16:54:32.309Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-81?focusedCommentId=15424893) by Mohit Jaggi (mohitjaggi):*\nWhen I was working on feature engineering earlier I struggled with this question too. My conclusion was to let the semantic of \"category\" be left for interpretation by a higher layer (typically feature engineering or machine learning). In \"raw\" data a category might be represented in several ways (string, boolean=one hot encoding, number etc) anyway so supporting this at a lower layer would impose constraints on the \"raw\" data. And then whose responsibility will it be to \"prepare\" the data to satisfy this constraint?\nMoreover, concepts like \"ordered\" are also fuzzy. A set of categories may be unordered for machine learning code but may be ordered for display in a UI. If Arrow is below both layers then this would be confusing."
        },
        {
            "created_at": "2016-08-17T17:52:12.496Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-81?focusedCommentId=15425026) by Wes McKinney (wesm):*\nThere is no doubt that a Category logical type / metadata is necessary for many use cases  (because it is semantically distinct from dictionary-encoded data, even though the physical representation is the same). For example: statistics and machine learning users from many communities would not be able to faithfully round trip data to Arrow metadata without it. I will ask others to give their perspective on this if you would like to hear from others. \n\nThe implementation (physical representation) of Category is the open question. I would propose for it to be a dictionary-encoded struct with a single child. For example:\n\n`Category[string] -> Struct<levels: String>`\n\nThe additional metadata requirement is orderedness. This needs to be stored in the schema as it needs to be a part of schema negotiation (rather than only observed in the realization of the data in the dictionary). \n\nBy using dictionary encoding for the implementation, one can also easily share dictionaries used by multiple fields (having the same category/factor levels). "
        },
        {
            "created_at": "2016-08-17T18:02:34.023Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-81?focusedCommentId=15425061) by Wes McKinney (wesm):*\nThe other question I have is the category / dictionary indices. For small cardinality levels it is not uncommon to store the indices in a smaller integer (like int8 / uint8). "
        },
        {
            "created_at": "2016-08-18T21:58:48.880Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-81?focusedCommentId=15427245) by Micah Kornfield (emkornfield@gmail.com):*\nFor the structure would it pay to not have a specific metadata type?\n\nAt an abstract level a category type indicates a variable that can take on a fixed number of values.  Sometimes these values have mnemonic/semantic meanings to them.   I think it is equally valid to have a categorical type, represented by a string vector, and communicate them as fixed types in metadata.  this leads me to think that categorical information should be additional metadata on the Field table in Message.fbs.  We might want to consider two ways of doing this:\n1.  Generic key/value metadata with a convention for categorical information (this will allow some level extensibility for other use-cases, None come to mind at the moment).\n2.  A specific model of something like:\n```Java\ntable IntCategoryList { // specify the universe of values as a list of integers (non dictionary encoded)\n   value_universe: [int]\n}\ntable StringCategoryList { // specify the universe of value via a list of strings (non dictionary encoded)\n   value_universe: [string]\n}\ntable DictionaryCategory { // the universe of values is provided via a dictionary\n}\nunion CategoryUniverseDescription {\n    IntCategoryList,\n    StringCategoryList,\n    DictionaryCategory\n}\ntable CategoryInfo  {\n    ordered: Boolean\n    category_universe: CategoryUniverseDescription\n}\n```\nthis could be simplified via to always assume factors are dictionary encoded (names are not well though out either).  But in either case we could add a optional category member to the Field table of type CategoryInfo.\n\nRegarding the indexing, I would vote to stick with int32s for V1.  Sizing the integer type and other more advanced features like bitweaving can be left for V2."
        },
        {
            "created_at": "2016-08-19T15:02:06.896Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-81?focusedCommentId=15428308) by Hadley Wickham (hadley):*\nI agree with Wes that factors/categories are a fundamental data type - yes, they share similarities with labelled integers or strings constrained to a set of specified values, but they are an important fundamental data type for data analysis. Yes, factors/categories are some what domain specific, but given that the tagline of Arrow is \"Powering Columnar In-Memory Analytics\", I think this is the domain that arrow should be concerning itself with."
        },
        {
            "created_at": "2016-08-19T15:12:07.433Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-81?focusedCommentId=15428316) by Jacques Nadeau (jnadeau):*\nCan you guys provide two small example datasets in JSON format here?"
        },
        {
            "created_at": "2016-08-19T19:02:33.747Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-81?focusedCommentId=15428657) by Wes McKinney (wesm):*\nHere's a couple examples from Python and R (I believe SAS / Stata / SPSS / Julia all have similar concepts)\n\nPython (pandas)\n\n```Java\nIn [1]: import pandas as pd\n\nIn [2]: s = pd.Series(pd.Categorical.from_array(['foo', 'bar', 'foo', 'bar']))\n\nIn [3]: s\nOut[3]: \n0    foo\n1    bar\n2    foo\n3    bar\ndtype: category\nCategories (2, object): [bar, foo]\n\nIn [4]: s.dtype\nOut[4]: category\n\nIn [5]: s.cat.codes\nOut[5]: \n0    1\n1    0\n2    1\n3    0\ndtype: int8\n\nIn [6]: s.cat.categories\nOut[6]: Index(['bar', 'foo'], dtype='object')\n```\n\n(take note of the int8 storage class...)\n\nIn Python, the categories can be any data type that is valid in other pandas contexts:\n\n```Java\nIn [9]: s = pd.Series(pd.Categorical.from_array(pd.date_range('2000-01-01', periods=5).repeat(2\n   ...: )))\n\nIn [10]: s\nOut[10]: \n0   2000-01-01\n1   2000-01-01\n2   2000-01-02\n3   2000-01-02\n4   2000-01-03\n5   2000-01-03\n6   2000-01-04\n7   2000-01-04\n8   2000-01-05\n9   2000-01-05\ndtype: category\nCategories (5, datetime64[ns]): [2000-01-01, 2000-01-02, 2000-01-03, 2000-01-04, 2000-01-05]\n\nIn [11]: s = pd.Series(pd.Categorical.from_array([(100, 1000), (0, 100)] * 4))\n\nIn [12]: s\nOut[12]: \n0    (100, 1000)\n1       (0, 100)\n2    (100, 1000)\n3       (0, 100)\n4    (100, 1000)\n5       (0, 100)\n6    (100, 1000)\n7       (0, 100)\ndtype: category\nCategories (2, object): [(0, 100), (100, 1000)]\n```\n\nIn R, the category values are constrained to be strings:\n\n```Java\n> f1 <- factor(c(\"foo\", \"bar\", \"foo\", \"bar\"))\n> f1\n[1] foo bar foo bar\nLevels: bar foo\n> as.integer(f1)\n[1] 2 1 2 1\n> levels(f1)\n[1] \"bar\" \"foo\"\n> f2 <- factor(c(\"foo\", \"bar\", \"foo\", \"bar\"), levels=c(\"foo\", \"bar\"), ordered=T)\n> f2\n[1] foo bar foo bar\nLevels: foo < bar\n> levels(f2)\n[1] \"foo\" \"bar\"\n```\n\nIf the categories have ordering indicated, these can be used automatically in different modeling contexts (for example, in a multinomial logistic regression: https://en.wikipedia.org/wiki/Multinomial_logistic_regression)\n\nIt's hard to estimate exactly, but based on the data we have (maybe Hadley / RStudio has a better estimate) it suggests that these two communities alone represent several million users worldwide. \n\nTo [~emkornfield@gmail.com] comment, there's a couple of things that come immediately to mind:\n\n- The category \"levels\" in general need to be able to accommodate any logical type. For example, we could use `Struct<lower: Float64, upper: Float64>` to represent numerical intervals (e.g. the result of a histogram operation)\n\n- \"High cardinality\" categories frequently occur in the wild, so if the categories are part of the schema, then the schema could be arbitrarily large (up to the 2GB limit in leaf nodes). This will eventually cause problems in schema negotiation. \n\n- Analytics involving categorical data may apply transformations to the categories (combining similar categories, reordering, etc.). It would seem more parsimonious to me to write a new dictionary and change the dictionary ID in the schema versus generating a new schema with the new dictionary\n\n- Dictionaries / categories may be shared by multiple columns. \n\nA JSON representation of this type might look like\n\n```Java\n{codes: [0, 0, 0, 0, 1, 1, 1, 1], levels: ['foo', 'bar'], ordered: true}\n```"
        },
        {
            "created_at": "2016-08-19T21:10:16.901Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-81?focusedCommentId=15428834) by Micah Kornfield (emkornfield@gmail.com):*\nThanks @wesm, I was going to post that I think dictionary encoding is the way to go for these types of columns everything else just adds complications.  I apologize for adding noise in that respect.\n\nOn that note I would like to take a step back and ask the question implicit on my last post.  Should Category be its own first class type, or should it be communicated via a metadata side channel?\n\nI lean towards the latter because it allows for compliant implementations to still handle Categorical values without having to write additional code to handle them explicitly (i.e. if its a Category[UTF16], I need to know how to convert this to something my implementation supports.  However, if its just  dictionary encoded Utf16 that happens to be a categorical variable, then the implementation can handle fine, and for systems that care about explicit categorical values, they can inspect the metadata and treat it normally.\n\nOne other question in regards to one of your points:  I assumed Schemas were immutable, does that match your understanding as well? "
        },
        {
            "created_at": "2016-08-19T22:38:38.052Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-81?focusedCommentId=15428957) by Wes McKinney (wesm):*\nWe're running into what \"first class type\" means again. I'm going to change the JIRA title to \"Add a Category logical type\" to be more clear (I don't think any changes to Layout.md are necessary). \n\nMy preferred representation of Category would be as a dictionary-encoded Struct. This has the benefit of allowing systems that don't know about what a Category is to still manipulate / examine the data normally. In other words, if we had the data:\n\n```Java\nCategory[String]\n\ncodes: [0, 0, 0, 0, 1, 1, 1, 1]\ncategories: ['foo', 'bar']\n```\n\nThen the Arrow representation would be as\n\n```Java\nStruct<levels: String> dictionary-encoded\ndictionary indices: [0, 0, 0, 0, 1, 1, 1, 1]\ndictionary_id: i\n\ndictionary i: \ntype=Struct<levels: String>\nfields: \n  levels (type=[String]) : ['foo', 'bar']\n```\n\nAny other ideas for this?\n\nI could have been more clear about my point about the schema \u2013 if the categories are embedded in the metadata, then generating a new Schema after a transformation could be arbitrarily expensive. In theory the size in-memory of the Schema should be small, so that modifications (yielding new schemas, due to schema object immutability) are cheap."
        },
        {
            "created_at": "2016-08-19T23:19:48.657Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-81?focusedCommentId=15429030) by Micah Kornfield (emkornfield@gmail.com):*\nYeah, sorry, I should be more consistent with terminology.  In this case I meant a logical type (i.e.  new specific type in Message.fbs).   For the physical layout s the desire to represent this as a Struct to allow extensibility with addition data in the enumeration (per Julien's suggestion) or for some other reason?  It seems to be easier for system non aware of categorical types to interact with the type if we don't add the extra level of nesting.\n\nI was imagining something more in the order of the below for a categorical string (like R). The general idea is you can have a categorical variable of an arbitrary type, but don't add the extra nesting in the structure proposed above.  A Column's categoricalness becomes and extra piece of metadata on the field.\n\n```Java\nString: dictionary-encoded\ndictionary indices: [0, 0, 0, 0, 1, 1, 1, 1]\ndictionary_id: i\n// new member\nCategorical_type: Ordered|Unordered|None\n\ndictionary i: \ntype=[String]\nvalues= ['foo', 'bar']\n```\n\nThe new member above could either be a specific explicitly modeled flatbuffer element, or we can create a general extension for key-value pairs on fields. Another example, of where a key-value pair field might be useful is to pass along metadata about list types, indicating that they are sorted/and or contain contain unique values."
        },
        {
            "created_at": "2016-08-20T02:01:30.542Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-81?focusedCommentId=15429156) by Wes McKinney (wesm):*\n[~emkornfield@gmail.com] what you've proposed has the nice property that a system without any Category-specific code could treat it as simple dictionary-encoded data. This seems OK to me, if adding this field does not offend others' sensibilities. We could make it more general as dictionary metadata (to avoid having to add more attributes to the Field table should we want to add more interpretations / metadata about the dictionary) \n\n`[~julienledem]` curious what you think on these proposals?  "
        },
        {
            "created_at": "2016-08-20T04:53:09.600Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-81?focusedCommentId=15429218) by Julien Le Dem (julienledem):*\n`[~wesmckinn]` and [~emkornfield@gmail.com]: the proposal of adding a categorical_type field to Field sounds good to me.\nwhen it is set then it is required that the field is dictionary encoded."
        },
        {
            "created_at": "2016-08-20T06:24:08.225Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-81?focusedCommentId=15429254) by Micah Kornfield (emkornfield@gmail.com):*\nDo we want to make an exception for requiring dictionary encoding for Categorical[ints]? "
        },
        {
            "created_at": "2016-08-20T20:42:21.488Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-81?focusedCommentId=15429507) by Julien Le Dem (julienledem):*\nints can also be dictionary encoded (benefits compactness or speed if performing aggregation for example as the ids are contiguous).\nSo the exception would be only if it's ints and all the values between 0 and n ? is this a common use case? `[~wesmckinn]` `[~hadley]` ?"
        },
        {
            "created_at": "2016-08-22T05:03:40.171Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-81?focusedCommentId=15430047) by Wes McKinney (wesm):*\nYou could have a case of redundancy if the span of dictionary indices and dictionary values is the same. In practice, dictionary encoding integers with a wide span (for example \u2013 if max(values) - min(values) is some large number) can have significant performance benefits as you can do things normally requiring a hash table (e.g. computing a frequency table) with much less effort."
        },
        {
            "created_at": "2017-01-22T20:41:38.363Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-81?focusedCommentId=15833682) by Wes McKinney (wesm):*\nPR, finally: https://github.com/apache/arrow/pull/297"
        },
        {
            "created_at": "2017-01-23T14:13:48.226Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-81?focusedCommentId=15834625) by Wes McKinney (wesm):*\nIssue resolved by pull request 297\n<https://github.com/apache/arrow/pull/297>"
        }
    ]
}