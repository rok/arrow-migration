{
    "issue": {
        "title": "[Python] pa.array() doesn't respect specified dictionary type",
        "body": "***Note**: This issue was originally created as [ARROW-7168](https://issues.apache.org/jira/browse/ARROW-7168). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nThis might be related to\u00a0ARROW-6548 and others dealing with all NaN columns. When creating a dictionary array, even when fully specifying the desired type, this type is not respected when the data contains only NaNs:\r\n\r\n\r\n```python\n\r\n# This may look a little artificial but easily occurs when processing categorial data in batches and a particular batch containing only NaNs\r\nser = pd.Series([None, None]).astype('object').astype('category')\r\ntyp = pa.dictionary(index_type=pa.int8(), value_type=pa.string(), ordered=False)\r\npa.array(ser, type=typ).type\r\n```\r\n\r\nresults in\r\n\r\n```\n\r\n>> DictionaryType(dictionary<values=null, indices=int8, ordered=0>)\r\n```\r\n\r\nwhich means that one cannot e.g. serialize batches of categoricals if the possibility of all-NaN batches exists, even when trying to enforce that each batch has the same schema (because the schema is not respected).\r\n\r\nI understand that inferring the type in this case would be difficult, but I'd imagine that a fully specified type should be respected in this case?\r\n\r\nIn the meantime, is there a workaround to manually create a dictionary array of the desired type containing only NaNs?\r\n",
        "created_at": "2019-11-14T12:21:15.000Z",
        "updated_at": "2019-11-21T10:18:39.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Component: Python",
            "Type: bug"
        ],
        "closed": true,
        "closed_at": "2019-11-21T10:18:16.000Z"
    },
    "comments": [
        {
            "created_at": "2019-11-14T16:21:28.302Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-7168?focusedCommentId=16974399) by Thomas Buhrmann (buhrmann):*\nOk, I think I found a workaround for converting an all-NaN categorical pd.Series to dictionary array:\r\n```python\n\r\n# Should be astype('string'), but pandas doesn't preserve NaNs\r\nser = pd.Series([np.nan, np.nan]).astype('object').astype('category')\r\n\r\narr = pa.DictionaryArray.from_arrays(\r\n    indices=-np.ones(len(ser), dtype=ser.cat.codes.dtype),\r\n    dictionary=np.array([], dtype='str'),\r\n    mask=np.ones(len(ser), dtype='bool'),\r\n    ordered=ser.cat.ordered)\r\n\r\nprint(arr.type)\r\npd.Series(arr.to_pandas())\r\n```\r\nwhich produces:\r\n```\n\r\ndictionary<values=string, indices=int8, ordered=0>\r\n\r\n0    NaN\r\n1    NaN\r\ndtype: category\r\nCategories (0, object): []\r\n```\r\ni.e. the 'str' value_type is now respected and the roundtrip produces the correct result."
        },
        {
            "created_at": "2019-11-14T16:51:17.166Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-7168?focusedCommentId=16974427) by Thomas Buhrmann (buhrmann):*\nSince I'm already at it, and in case somebody faces the same problem... To safely convert pandas categoricals to arrow, ensuring a constant type across batches, something like the following would work:\r\n```python\n\r\ndef categorical_to_arrow(ser, known_categories=None, ordered=None):\r\n    \"\"\"Safely create a pa.array from a categorial pd.Series.\r\n    \r\n    Args:\r\n        ser (pd.Series): should be of CategorialDtype\r\n        known_categories (np.array): force known categories. If None, and \r\n            the Series doesn't have any values to infer it from, will use \r\n            an empty array of the same dtype as the categories attribute\r\n            of the Series\r\n        ordered (bool): whether categories should be ordered \r\n    \"\"\"\r\n    n = len(ser)\r\n    all_nan = ser.isna().sum() == n\r\n       \r\n# Enforce provided categories, use the original ones, or enforce\r\n# the correct value_type if Arrow would otherwise change it to 'null'\r\n    if isinstance(known_categories, np.ndarray):\r\n        dictionary = known_categories\r\n    elif all_nan:\r\n# value_type may be known, but Arrow doesn't understand 'object' dtype\r\n        value_type = ser.cat.categories.dtype\r\n        if value_type == 'object':\r\n            value_type = 'str'\r\n        dictionary = np.array([], dtype=value_type)\r\n    else:\r\n        dictionary = ser.cat.categories\r\n        \r\n# Allow overwriting of ordered attribute\r\n    if ordered is None:\r\n        ordered = ser.cat.ordered\r\n\r\n    if all_nan:\r\n        return pa.DictionaryArray.from_arrays(\r\n            indices=-np.ones(n, dtype=ser.cat.codes.dtype),\r\n            dictionary=dictionary,\r\n            mask=np.ones(n, dtype='bool'),\r\n            ordered=ordered)\r\n    else:\r\n        return pa.DictionaryArray.from_arrays(\r\n            indices=ser.cat.codes,\r\n            dictionary=dictionary,\r\n            ordered=ordered,\r\n            from_pandas=True\r\n        )\r\n```\r\nThis seems to be the only ( ?)\u00a0way to have control over the resulting dictionary type. E.g.:\r\n```python\n\r\n# String categories with and without non-NaN values\r\nsers = [\r\n    pd.Series([None, None]).astype('object').astype('category'),\r\n    pd.Series(['a', None, None]).astype('category')\r\n]\r\n\r\n# The categorical types we may want\r\nknown_categories = [\r\n    None,\r\n    np.array(['a', 'b', 'c'], dtype='str'),\r\n    np.array([1, 2, 3], dtype='int8')\r\n]\r\n\r\n# Convert each series with each of the desired category types\r\nfor ser in sers:\r\n    for cats in categories:\r\n        arr = categorical_to_arrow(ser, known_categories=cats)\r\n        ser2 = pd.Series(arr.to_pandas())\r\n        print(f\"Series: {list(ser)} | Known categories: {cats}\")\r\n        print(f\"Dictionary type: {arr.type}\")\r\n        print(f\"Roundtripped Series: \\n{ser2}\", \"\\n\")\r\n```\r\nwhich produces:\r\n```\n\r\nSeries: [nan, nan] | Known categories: None\r\nDictionary type: dictionary<values=string, indices=int8, ordered=0>\r\nRoundtripped Series: \r\n0    NaN\r\n1    NaN\r\ndtype: category\r\nCategories (0, object): [] \r\n\r\nSeries: [nan, nan] | Known categories: ['a' 'b' 'c']\r\nDictionary type: dictionary<values=string, indices=int8, ordered=0>\r\nRoundtripped Series: \r\n0    NaN\r\n1    NaN\r\ndtype: category\r\nCategories (3, object): [a, b, c] \r\n\r\nSeries: [nan, nan] | Known categories: [1 2 3]\r\nDictionary type: dictionary<values=int8, indices=int8, ordered=0>\r\nRoundtripped Series: \r\n0    NaN\r\n1    NaN\r\ndtype: category\r\nCategories (3, int64): [1, 2, 3] \r\n\r\nSeries: ['a', nan, nan] | Known categories: None\r\nDictionary type: dictionary<values=string, indices=int8, ordered=0>\r\nRoundtripped Series: \r\n0      a\r\n1    NaN\r\n2    NaN\r\ndtype: category\r\nCategories (1, object): [a] \r\n\r\nSeries: ['a', nan, nan] | Known categories: ['a' 'b' 'c']\r\nDictionary type: dictionary<values=string, indices=int8, ordered=0>\r\nRoundtripped Series: \r\n0      a\r\n1    NaN\r\n2    NaN\r\ndtype: category\r\nCategories (3, object): [a, b, c] \r\n\r\nSeries: ['a', nan, nan] | Known categories: [1 2 3]\r\nDictionary type: dictionary<values=int8, indices=int8, ordered=0>\r\nRoundtripped Series: \r\n0      1\r\n1    NaN\r\n2    NaN\r\ndtype: category\r\nCategories (3, int64): [1, 2, 3] \r\n```\r\n(the last example would correspond to a recoding of the categories, but that'd be a usage problem...)"
        },
        {
            "created_at": "2019-11-14T18:22:14.364Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-7168?focusedCommentId=16974511) by Joris Van den Bossche (jorisvandenbossche):*\n`[~buhrmann]` thanks for the report. When passing a type like that, I agree it should be honoured.\r\n\r\nSome other observations:\r\n\r\nAlso when it's not all-NaN, the specified type gets ignored:\r\n\r\n```Java\n\r\nIn [19]: cat = pd.Categorical(['a', 'b']) \r\n\r\nIn [20]: typ = pa.dictionary(index_type=pa.int8(), value_type=pa.int64(), ordered=False)  \r\n\r\nIn [21]: pa.array(cat, type=typ) \r\nOut[21]: \r\n<pyarrow.lib.DictionaryArray object at 0x7ff87b6a50b8>\r\n\r\n-- dictionary:\r\n  [\r\n    \"a\",\r\n    \"b\"\r\n  ]\r\n-- indices:\r\n  [\r\n    0,\r\n    1\r\n  ]\r\n\r\nIn [22]: pa.array(cat, type=typ).type  \r\nOut[22]: DictionaryType(dictionary<values=string, indices=int8, ordered=0>)\r\n```\r\n\r\nSo I suppose it's a more general problem, not specifically related to this all-NaN case (it only appears for you in this case, as otherwise the specified type and the type from the data will probably match).\r\n\r\nIn the example I show here above, we should probably raise an error is the specified type is not compatible (string vs int categories)."
        },
        {
            "created_at": "2019-11-15T09:41:27.430Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-7168?focusedCommentId=16974964) by Thomas Buhrmann (buhrmann):*\nYes, that's right. I didn't notice it silently 'failing' in other cases because I usually construct the type explicitly to match.\r\n\r\nI guess it should be a relatively easy fix, since as I show above, one can construct an all-NaN DictionaryArray using\u00a0from_arrays() with negative indices, a np.array with desired type as dictionary, and setting the mask. I haven't checked under the hood why using -1 as indices works without setting from_pandas=True, and so I'm not sure if this is the best way to create the array, but it seems to work in practice..."
        },
        {
            "created_at": "2019-11-21T10:18:16.790Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-7168?focusedCommentId=16979154) by Antoine Pitrou (apitrou):*\nIssue resolved by pull request 5866\n<https://github.com/apache/arrow/pull/5866>"
        }
    ]
}