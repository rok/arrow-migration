{
    "issue": {
        "title": "[Java] Investigate potential performance improvement of compression codec",
        "body": "***Note**: This issue was originally created as [ARROW-11901](https://issues.apache.org/jira/browse/ARROW-11901). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nIn response to the discussion in https://github.com/apache/arrow/pull/8949/files#r588046787\r\n\r\nThere are some performance penalties in the implementation of the compression codecs (e.g. data copying between heap/off-heap data). We need to revise the code to improve the performance. \r\n\r\nWe should also provide some benchmarks to validate that the performance actually improves. ",
        "created_at": "2021-03-08T06:41:08.000Z",
        "updated_at": "2021-11-25T02:49:24.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: Java",
            "Type: enhancement"
        ],
        "closed": false
    },
    "comments": [
        {
            "created_at": "2021-03-18T09:13:40.149Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-11901?focusedCommentId=17303953) by Benjamin Wilhelm (benjamin.wilhelm@knime.com):*\nNote that there is a discussion about the LZ4 library selection on the mailing list:\r\n\r\nhttps://lists.apache.org/thread.html/reb8ae01ad544072ce1dd77feea640aab2e9834f55ccee04292e9da42%40%3Cdev.arrow.apache.org%3E"
        },
        {
            "created_at": "2021-03-19T00:40:32.887Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-11901?focusedCommentId=17304543) by Bob Tinsman (bobtinsman):*\nHi, noticed that you were working on the LZ4 issue, which I was curious about, since Java and performance are both interests of mine.\r\n\r\nI am happy to help by profiling code.\r\n\r\n`[~emkornfield]` mentioned airlift as being Java based but still fast, so I checked it out.\r\n\r\nIts core code uses off-heap access which could explain its speed.\r\n\r\nFor example, check out the core decompressor code: <https://github.com/airlift/aircompressor/blob/master/src/main/java/io/airlift/compress/lz4/Lz4RawDecompressor.java>\r\n\r\nThis is similar to Arrow's vector implementations, which allocate an off-heap chunk of memory, then use Unsafe methods to access it."
        },
        {
            "created_at": "2021-03-19T10:03:35.817Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-11901?focusedCommentId=17304790) by Liya Fan (fan_li_ya):*\n`[~bobtinsman]` Thanks for your valuable input. It seems Airlift could solve the problem. "
        },
        {
            "created_at": "2021-03-26T21:27:39.330Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-11901?focusedCommentId=17309741) by Micah Kornfield (emkornfield):*\nAs noted in the discussion on ML Airlift seems to only support Raw not framed (and is slower then JNI).\r\n\r\n\u00a0\r\n\r\n[~benjamin.wilhelm@knime.com]\u00a0for this specific Jira as starting place maybe we can checkin the benchmarks that you made for LZ4 compression.\u00a0 \u00a0 I think there a few follow-up issues (not asking any one in particular to work on them):\r\n\r\n1.\u00a0 Provide JNI bindings that support framed compression\u00a0\r\n\r\n2.\u00a0 Provide a performant pure java decompression for those that don't want to use JNI\u00a0\r\n\r\n3.\u00a0 Use the existing LZ4 java bindings for compression.\r\n\r\n\u00a0"
        },
        {
            "created_at": "2021-10-26T12:12:21.421Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-11901?focusedCommentId=17434313) by Benjamin Wilhelm (benjamin.wilhelm@knime.com):*\nFor JNI bindings that support frame compression, I created a PR in the project javacpp-presets: <https://github.com/bytedeco/javacpp-presets/pull/1094>. Once this is merged I can implement an instance of `CompressionCodec` using these bindings."
        },
        {
            "created_at": "2021-10-27T03:10:46.146Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-11901?focusedCommentId=17434646) by Micah Kornfield (emkornfield):*\nDoes the presets library add a lot of value?  Could this be done in a new package within Arrow.  I'm a little hesitant to take a new dependency (or would at least want to do more research in terms of viability of the project/how widely used the packages in the repo are used)."
        },
        {
            "created_at": "2021-10-27T04:50:02.055Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-11901?focusedCommentId=17434659) by Samuel Audet (saudet):*\n`[~emkornfield]`, since the C++ builds of Arrow already include LZ4, it is indeed pretty trivial to expose a few JNI methods to access it. The larger picture though is that the overall Java API of Arrow itself is still pretty limited and inefficient, even after 5 years in development! And there _are_ users such as [~benjamin.wilhelm@knime.com] that require more performance, and that's why there are also JavaCPP Presets for the C++ API of Arrow: <https://github.com/bytedeco/javacpp-presets/tree/master/arrow>\r\n\r\nNow, the C++ API doesn't always map very elegantly to Java, but it is tons faster, and maps a lot more functionality. This would be a discussion for another thread, but if the Java API of Arrow were to be based on JavaCPP, it would allow users to fall back easily on that API, instead of forcing them to start hacking stuff in JNI. Case in point, the `arrow::util::Codec` class has been usable from Java for almost 2 years now:\r\n<https://github.com/bytedeco/javacpp-presets/blob/master/arrow/src/gen/java/org/bytedeco/arrow/Codec.java>\r\n\r\nI would be happy to maintain those presets as part of the Arrow project, just like I'm currently doing in the case of TensorFlow for Java: <https://github.com/tensorflow/java/search?q=javacpp>\r\n\r\nPrevious discussions with people from Apache Arrow didn't elicit much interest, but in time the need for a tool like Cython in Java will become obvious to all, and JavaCPP already provides that!"
        },
        {
            "created_at": "2021-10-27T10:03:13.387Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-11901?focusedCommentId=17434765) by Benjamin Wilhelm (benjamin.wilhelm@knime.com):*\nWe at KNIME are currently using the official Java Arrow library for our upcoming table backend (<https://www.knime.com/blog/improved-performance-with-new-table-backend>\u00a0). It works for us, and we will keep using it. As Samuel pointed out, it might be a valid idea to base the Java API on JavaCPP, but this is not the right place for this discussion (a thread in the mailing list?).\r\n\r\nHowever, a significant problem with the Java API was/is the missing fast compression using LZ4. The JavaCPP project was the easiest and fastest way to get a very fast LZ4 API for Java (supporting frame compression as needed). I already implemented `CompressionCodec` using these bindings, and we (at KNIME) will use it with the next release.\r\n\r\nSeeing where the JavaCPP is used I think it is a viable project. I could contribute my `CompressionCodec` implementation to Arrow if this is desired. Creating JNI bindings for LZ4 in the Arrow repository would take more time and I won't be able to do this soon."
        },
        {
            "created_at": "2021-11-05T23:32:55.915Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-11901?focusedCommentId=17439561) by Micah Kornfield (emkornfield):*\n> As Samuel pointed out, it might be a valid idea to base the Java API on JavaCPP, but this is not the right place for this discussion (a thread in the mailing list?).\r\nThis would be a mailing dev@ mailing list discussion.\u00a0 I don't think we would eliminate the existing API, but there might be some interest alternative Java APIs.\r\n\r\n\u00a0\r\n> Seeing where the JavaCPP is used I think it is a viable project. I could contribute my\u00a0`CompressionCodec`\u00a0implementation to Arrow if this is desired. Creating JNI bindings for LZ4 in the Arrow repository would take more time and I won't be able to do this soon.\r\n[~benjamin.wilhelm@knime.com] Do you have pointers?\u00a0 I looked maybe too quickly and didn't see it used in other Apache projects for instance.\u00a0 If you have something that works for your use-case that is great, and if you want to open-source it also great, but it might need to live in a KNIME hosted project for the time being.\u00a0 I believe Arrow is now building JNI bindings for all major platforms, so the release story is a little bit better for a JNI code hosted by Arrow, I'll see how hard it would be to make the bindings at this point."
        },
        {
            "created_at": "2021-11-16T08:03:06.960Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-11901?focusedCommentId=17444339) by Samuel Audet (saudet):*\n> This would be a mailing dev@ mailing list discussion. \u00a0I don't think we would eliminate the existing API, but there might be some interest alternative Java APIs.\r\nIt's not about eliminating anything, it's about developing the existing Java API, such as this very specific use case for compression codecs. [~benjamin.wilhelm@knime.com] was able to wrap LZ4 using JavaCPP, all by himself! it's a lot easier to do than code everything manually with JNI:\r\n<https://github.com/bytedeco/javacpp-presets/pull/1094>\r\n\r\nThe Python API of Arrow isn't just automatically generated wrappers around the C++ API using Cython, right? It's the same for Java. We can use tools like Cython to make the life of Python developers easier, so why not do the same for Java developers?\r\n\r\nWe were able to cut the wrapping code in half by rebasing the Java API of TensorFlow on JavaCPP, and performance increased to boot:\r\n<https://github.com/tensorflow/java/pull/18#issuecomment-579600568> \r\n\r\nWe could do the same for Arrow!\r\n\r\n\r\n> [~benjamin.wilhelm@knime.com] Do you have pointers?\u00a0 I looked maybe too quickly and didn't see it used in other Apache projects for instance.\u00a0 If you have something that works for your use-case that is great, and if you want to open-source it also great, but it might need to live in a KNIME hosted project for the time being.\u00a0 I believe Arrow is now building JNI bindings for all major platforms, so the release story is a little bit better for a JNI code hosted by Arrow, I'll see how hard it would be to make the bindings at this point.\r\nWhen it comes to Apache projects, I tried to donate the JavaCPP Presets for MXNet, but they don't seem interested anymore:\r\n<https://github.com/apache/incubator-mxnet/pull/19797> \r\n\r\nI'm also publishing builds for Apache TVM as well, but again, not getting much traction:\r\n<http://bytedeco.org/news/2020/12/12/deploy-models-with-javacpp-and-tvm/>\r\n\r\nIf you have some ideas as to why most engineers are OK using Cython in the case of Python, but not the equivalent in the case of Java, I would be very much interested in hearing your opinions."
        },
        {
            "created_at": "2021-11-17T09:35:51.691Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-11901?focusedCommentId=17445041) by Micah Kornfield (emkornfield):*\n> It's not about eliminating anything, it's about developing the existing Java API, such as this very specific use case for compression codecs.\u00a0[~benjamin.wilhelm@knime.com]\u00a0was able to wrap LZ4 using JavaCPP, all by himself! it's a lot easier to do than code everything manually with JNI:\n> <https://github.com/bytedeco/javacpp-presets/pull/1094>\r\nI think there is some miscommunication, on what I thought were 2 separate issues.\u00a0 How to implement an efficient LZ4 decoder and whether to base the Java API as a wrapper on the C++ API.\u00a0 The second would essentially would need a heavy rewrite of the Java API as it is fundamentally different than the design of the C++ API.\u00a0 I think there could be some interest from consumers of Arrow in an API that more accurately mimics the C++ version, but again that is a different thread.\u00a0 It could be for some of the more complex bindings (DataSets) JavaCPP might be a better choice then hand-coded JNI.\r\n\r\n\u00a0\r\n> `[~emkornfield]`, since the C++ builds of Arrow already include LZ4, it is indeed pretty trivial to expose a few JNI methods to access it.\r\nI was not referring to binding to the C++ implementation here but directly to the LZ4 library.\u00a0 It looks like JavaCPP makes this efficient from a developer perspective.\u00a0 But the [API](https://github.com/bytedeco/javacpp-presets/pull/1094/files#diff-3d9af736e997982d68098d986670f05ff40ae0cc62773a1dd0eb418e55990317R38) isn't quite what I imagined, it looks like it goes through ByteBuffer, when all we really need is something like [ZSTD API](https://github.com/luben/zstd-jni/blob/master/src/main/java/com/github/luben/zstd/Zstd.java#L454).\u00a0 For such a minimal API I'm ambivalent on taking on a new dependency here.\r\n\r\n\u00a0\r\n> If you have some ideas as to why most engineers are OK using Cython in the case of Python, but not the equivalent in the case of Java, I would be very much interested in hearing your opinions.\r\nI'm not an expert but a few thoughts:\r\n1. Cython is more then just a C++ wrapper.\u00a0 It speeds up python even if you never want to write native code by effectively allowing one to write C code as python.\u00a0 In Java, at least in theory, the JIT can do some heavy lifting here.\n1. The Python GIL is a pain point that Java doesn't have and Cython + Native code can effectively work around it.\n1. There has always been a tight relationship between Python and Native code where as JNI is much more esoteric, and can cause unexpected deployment issues (e.g. correctly pointing the JVM to .so files, correctly integrating with the JVM's memory capacity features, etc).\u00a0\n1. Cython was also a pretty easy way to get compatibility between python 2.x and python 3.x\n   \n   Sometimes there is watershed moment, more mature projects can be reluctant to try new technologies unless they are proven elsewhere and they solve a significant pain-point.\u00a0\u00a0\n   > We could do the same for Arrow!\n   The dev@ mailing list is the place to discuss this.\u00a0 I tried searching and couldn't find any previous discussions on the topic there."
        },
        {
            "created_at": "2021-11-17T10:48:48.223Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-11901?focusedCommentId=17445095) by Benjamin Wilhelm (benjamin.wilhelm@knime.com):*\nI will just add one small comment for now:\r\n> But the [API](https://github.com/bytedeco/javacpp-presets/pull/1094/files#diff-3d9af736e997982d68098d986670f05ff40ae0cc62773a1dd0eb418e55990317R38)\u00a0isn't quite what I imagined, it looks like it goes through ByteBuffer, when all we really need is something like\u00a0[ZSTD API](https://github.com/luben/zstd-jni/blob/master/src/main/java/com/github/luben/zstd/Zstd.java#L454)\r\nI just used `ByteBuffer` for the example code. If the memory address is known (which it is for `{}ArrowBuf{`}) a Pointer to this memory address can be used (which I do in my implementation of `{}CompressionCodec{`}). The API is still a bit annoying to use (mainly because decompression cannot be done with one call and it does not feel like a Java API) but it is not limited to `Integer.MAX_VALUE` bytes. Maybe, there could be a convenience layer in the `org.bytedeco.lz4` lib."
        },
        {
            "created_at": "2021-11-25T02:49:24.218Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-11901?focusedCommentId=17448907) by Samuel Audet (saudet):*\n> I was not referring to binding to the C++ implementation here but directly to the LZ4 library.\u00a0 It looks like JavaCPP makes this efficient from a developer perspective.\u00a0 But the [API](https://github.com/bytedeco/javacpp-presets/pull/1094/files#diff-3d9af736e997982d68098d986670f05ff40ae0cc62773a1dd0eb418e55990317R38) isn't quite what I imagined, it looks like it goes through ByteBuffer, when all we really need is something like [ZSTD API](https://github.com/luben/zstd-jni/blob/master/src/main/java/com/github/luben/zstd/Zstd.java#L454).\u00a0 For such a minimal API I'm ambivalent on taking on a new dependency here.\r\nCould you expand on this point? Why do you consider zstd-jni to be minimal, but not code generated with JavaCPP? To me it looks like zstd-jni is a lot larger in size than the JavaCPP Presets for LZ4, even when considering only the builds in common:\r\n<https://repo1.maven.org/maven2/com/github/luben/zstd-jni/1.5.0-4/>\r\n<https://repo1.maven.org/maven2/org/bytedeco/lz4/1.9.3-1.5.6/>\r\n\r\nAs for the non-ByteBuffer API, what you are looking for are the overloads taking Pointer, which is just a fancy wrapper around a long value:\r\n<https://github.com/bytedeco/javacpp-presets/blob/master/lz4/src/gen/java/org/bytedeco/lz4/global/lz4.java#L188> \r\nThat does exactly like zstd-jni!"
        }
    ]
}