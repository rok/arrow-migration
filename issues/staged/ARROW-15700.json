{
    "issue": {
        "title": "[C++] Compilation error on Ubuntu 18.04",
        "body": "***Note**: This issue was originally created as [ARROW-15700](https://issues.apache.org/jira/browse/ARROW-15700). Please see the [migration documentation](https://gist.github.com/toddfarmer/12aa88361532d21902818a6044fda4c3) for further details.*\n\n### Original Issue Description:\nSee Crossbow build logs here:\r\n\r\nhttps://github.com/ursacomputing/crossbow/runs/5211900067?check_suite_focus=true#step:5:1389\r\n\r\n```Java\n\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc: In member function 'arrow::Status arrow::engine::{anonymous}::ScalarToProtoImpl::Visit(const arrow::StringScalar&)':\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc:469:78: error: no matching function for call to 'arrow::engine::{anonymous}::ScalarToProtoImpl::FromBuffer(<unresolved overloaded function type>, const arrow::StringScalar&)'\r\n   Status Visit(const StringScalar& s) { return FromBuffer(&Lit::set_string, s); }\r\n                                                                              ^\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc:447:10: note: candidate: template<class ScalarWithBufferValue> arrow::Status arrow::engine::{anonymous}::ScalarToProtoImpl::FromBuffer(void (substrait::Expression_Literal::*)(std::__cxx11::string&&), const ScalarWithBufferValue&)\r\n   Status FromBuffer(void (substrait::Expression::Literal::*set)(std::string&&),\r\n          ^~~~~~~~~~\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc:447:10: note:   template argument deduction/substitution failed:\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc:469:59: note:   cannot convert '& substrait::Expression_Literal::set_string' (type '<unresolved overloaded function type>') to type 'void (substrait::Expression_Literal::*)(std::__cxx11::string&&) {aka void (substrait::Expression_Literal::*)(std::__cxx11::basic_string<char>&&)}'\r\n   Status Visit(const StringScalar& s) { return FromBuffer(&Lit::set_string, s); }\r\n                                                           ^~~~\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc: In member function 'arrow::Status arrow::engine::{anonymous}::ScalarToProtoImpl::Visit(const arrow::BinaryScalar&)':\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc:470:78: error: no matching function for call to 'arrow::engine::{anonymous}::ScalarToProtoImpl::FromBuffer(<unresolved overloaded function type>, const arrow::BinaryScalar&)'\r\n   Status Visit(const BinaryScalar& s) { return FromBuffer(&Lit::set_binary, s); }\r\n                                                                              ^\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc:447:10: note: candidate: template<class ScalarWithBufferValue> arrow::Status arrow::engine::{anonymous}::ScalarToProtoImpl::FromBuffer(void (substrait::Expression_Literal::*)(std::__cxx11::string&&), const ScalarWithBufferValue&)\r\n   Status FromBuffer(void (substrait::Expression::Literal::*set)(std::string&&),\r\n          ^~~~~~~~~~\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc:447:10: note:   template argument deduction/substitution failed:\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc:470:59: note:   cannot convert '& substrait::Expression_Literal::set_binary' (type '<unresolved overloaded function type>') to type 'void (substrait::Expression_Literal::*)(std::__cxx11::string&&) {aka void (substrait::Expression_Literal::*)(std::__cxx11::basic_string<char>&&)}'\r\n   Status Visit(const BinaryScalar& s) { return FromBuffer(&Lit::set_binary, s); }\r\n                                                           ^~~~\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc: In member function 'arrow::Status arrow::engine::{anonymous}::ScalarToProtoImpl::Visit(const arrow::FixedSizeBinaryScalar&)':\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc:473:48: error: no matching function for call to 'arrow::engine::{anonymous}::ScalarToProtoImpl::FromBuffer(<unresolved overloaded function type>, const arrow::FixedSizeBinaryScalar&)'\r\n     return FromBuffer(&Lit::set_fixed_binary, s);\r\n                                                ^\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc:447:10: note: candidate: template<class ScalarWithBufferValue> arrow::Status arrow::engine::{anonymous}::ScalarToProtoImpl::FromBuffer(void (substrait::Expression_Literal::*)(std::__cxx11::string&&), const ScalarWithBufferValue&)\r\n   Status FromBuffer(void (substrait::Expression::Literal::*set)(std::string&&),\r\n          ^~~~~~~~~~\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc:447:10: note:   template argument deduction/substitution failed:\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc:473:23: note:   cannot convert '& substrait::Expression_Literal::set_fixed_binary' (type '<unresolved overloaded function type>') to type 'void (substrait::Expression_Literal::*)(std::__cxx11::string&&) {aka void (substrait::Expression_Literal::*)(std::__cxx11::basic_string<char>&&)}'\r\n     return FromBuffer(&Lit::set_fixed_binary, s);\r\n                       ^~~~\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc: In member function 'arrow::Status arrow::engine::{anonymous}::ScalarToProtoImpl::Visit(const arrow::ExtensionScalar&)':\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc:598:77: error: no matching function for call to 'arrow::engine::{anonymous}::ScalarToProtoImpl::FromBuffer(<unresolved overloaded function type>, const arrow::FixedSizeBinaryScalar&)'\r\n                         checked_cast<const FixedSizeBinaryScalar&>(*s.value));\r\n                                                                             ^\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc:447:10: note: candidate: template<class ScalarWithBufferValue> arrow::Status arrow::engine::{anonymous}::ScalarToProtoImpl::FromBuffer(void (substrait::Expression_Literal::*)(std::__cxx11::string&&), const ScalarWithBufferValue&)\r\n   Status FromBuffer(void (substrait::Expression::Literal::*set)(std::string&&),\r\n          ^~~~~~~~~~\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc:447:10: note:   template argument deduction/substitution failed:\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc:597:25: note:   cannot convert '& substrait::Expression_Literal::set_uuid' (type '<unresolved overloaded function type>') to type 'void (substrait::Expression_Literal::*)(std::__cxx11::string&&) {aka void (substrait::Expression_Literal::*)(std::__cxx11::basic_string<char>&&)}'\r\n       return FromBuffer(&Lit::set_uuid,\r\n                         ^~~~\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc:603:77: error: no matching function for call to 'arrow::engine::{anonymous}::ScalarToProtoImpl::FromBuffer(<unresolved overloaded function type>, const arrow::FixedSizeBinaryScalar&)'\r\n                         checked_cast<const FixedSizeBinaryScalar&>(*s.value));\r\n                                                                             ^\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc:447:10: note: candidate: template<class ScalarWithBufferValue> arrow::Status arrow::engine::{anonymous}::ScalarToProtoImpl::FromBuffer(void (substrait::Expression_Literal::*)(std::__cxx11::string&&), const ScalarWithBufferValue&)\r\n   Status FromBuffer(void (substrait::Expression::Literal::*set)(std::string&&),\r\n          ^~~~~~~~~~\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc:447:10: note:   template argument deduction/substitution failed:\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc:602:25: note:   cannot convert '& substrait::Expression_Literal::set_fixed_char' (type '<unresolved overloaded function type>') to type 'void (substrait::Expression_Literal::*)(std::__cxx11::string&&) {aka void (substrait::Expression_Literal::*)(std::__cxx11::basic_string<char>&&)}'\r\n       return FromBuffer(&Lit::set_fixed_char,\r\n                         ^~~~\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc: In function 'arrow::Result<std::unique_ptr<substrait::Expression> > arrow::engine::ToProto(const arrow::compute::Expression&, arrow::engine::ExtensionSet*)':\r\n/arrow/cpp/src/arrow/engine/substrait/expression_internal.cc:860:74: error: 'bool substrait::Expression_Literal::has_i32() const' is private within this context\r\n       if (arguments[1]->has_literal() && arguments[1]->literal().has_i32()) {\r\n                                                                          ^\r\nIn file included from /arrow/cpp/src/arrow/engine/substrait/expression_internal.h:29:0,\r\n                 from /arrow/cpp/src/arrow/engine/substrait/expression_internal.cc:20:\r\nsrc/arrow/engine/generated/substrait/expression.pb.h:6207:13: note: declared private here\r\n inline bool Expression_Literal::has_i32() const {\r\n             ^~~~~~~~~~~~~~~~~~\r\n```",
        "created_at": "2022-02-16T10:42:22.000Z",
        "updated_at": "2022-02-18T07:52:30.000Z",
        "labels": [
            "Migrated from Jira",
            "Component: C++",
            "Component: Compute IR",
            "Component: Continuous Integration",
            "Type: bug"
        ],
        "closed": true,
        "closed_at": "2022-02-17T21:38:46.000Z"
    },
    "comments": [
        {
            "created_at": "2022-02-16T10:43:00.861Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15700?focusedCommentId=17493166) by Antoine Pitrou (apitrou):*\ncc `[~jvanstraten]` \u00a0 `[~westonpace]` \u00a0"
        },
        {
            "created_at": "2022-02-16T15:27:17.441Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15700?focusedCommentId=17493291) by Jeroen van Straten (jvanstraten):*\nI've yet to reproduce the problem locally, but I'm on it (copying the CMake flags into my local build compiles just fine, so I'll have to do a better job mimicking the build environment)."
        },
        {
            "created_at": "2022-02-16T22:05:41.469Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15700?focusedCommentId=17493525) by Weston Pace (westonpace):*\nThe root cause is that the protoc on Ubuntu is too old.  If I specify a minimum version of 3.15.0 then the compilation fails with a nicer message (protoc is too old).\r\n\r\nIf I specify Protobuf_SOURCE=BUNDLED or ARROW_ENGINE=OFF then the compilation succeeds.\r\n\r\nI can update the crossbow job to specify Protobuf_SOURCE=BUNDLED.  Is this the correct fix?  Or is there some way we can fall back to bundled if the system version is too old?"
        },
        {
            "created_at": "2022-02-17T10:14:32.360Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15700?focusedCommentId=17493835) by Jeroen van Straten (jvanstraten):*\n> Or is there some way we can fall back to bundled if the system version is too old?\r\n\r\nI don't think that would work right in general. If:\r\n \\* libprotobuf is installed on the system but is too old,\r\n \\* libarrow builds with a statically-linked bundled version, and\r\n \\* a user tries to build a library/application that directly or transitively links to both the system libprotobuf and libarrow,\r\n\r\nI'm pretty sure you'd either get link errors for duplicate symbols, or undefined behavior due to libprotobuf's shared global state in conjunction with different class definitions from the different versions. So, if libprotobuf is found but too old, the build system should fail, unless the user explicitly specifies they want to use a bundled version. From your description that seems to be what it's doing already, except that the Substrait consumer code code fails to build with the minimum acceptable version.\r\n\r\nBefore we just increase that minimum version I'm going to try rewriting the code to make it work with it. After all... Ubuntu 18.04 LTS only end-of-lifes in 2028. There should probably be a CI/nightly to cover the minimum version case as well."
        },
        {
            "created_at": "2022-02-17T10:18:19.340Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15700?focusedCommentId=17493837) by Antoine Pitrou (apitrou):*\nI'm curious: a too old protoc produces C++ compilation errors? What is the mechanism?"
        },
        {
            "created_at": "2022-02-17T11:57:07.374Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15700?focusedCommentId=17493897) by Jeroen van Straten (jvanstraten):*\nThe files generated by this protoc (and/or the classes in libprotobuf they're based on) simply don't have some of the methods/overloads that the consumer code was using."
        },
        {
            "created_at": "2022-02-17T21:38:46.383Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15700?focusedCommentId=17494249) by Weston Pace (westonpace):*\nIssue resolved by pull request 12448\n<https://github.com/apache/arrow/pull/12448>"
        },
        {
            "created_at": "2022-02-17T21:39:59.479Z",
            "body": "***Note**: [Comment](https://issues.apache.org/jira/browse/ARROW-15700?focusedCommentId=17494251) by Weston Pace (westonpace):*\nClosing the loop on this discussion, `[~jvanstraten]` produced a PR that modified our usage of the generated code so that it was compliant with older protoc versions (at least back to 3.0.0). "
        }
    ]
}