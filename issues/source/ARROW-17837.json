{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13482995",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482995",
    "key": "ARROW-17837",
    "fields": {
        "fixVersions": [],
        "resolution": null,
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=sakras",
            "name": "sakras",
            "key": "sakras",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Sasha Krassovsky",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/3",
            "description": "This issue is being actively worked on at the moment by the assignee.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/inprogress.png",
            "name": "In Progress",
            "id": "3",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/4",
                "id": 4,
                "key": "indeterminate",
                "colorName": "yellow",
                "name": "In Progress"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=sakras",
            "name": "sakras",
            "key": "sakras",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Sasha Krassovsky",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=sakras",
            "name": "sakras",
            "key": "sakras",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Sasha Krassovsky",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 2400,
            "total": 2400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 2400,
            "total": 2400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-17837/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 4,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482995/worklog/811785",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #14227:\nURL: https://github.com/apache/arrow/pull/14227#issuecomment-1256840239\n\n   https://issues.apache.org/jira/browse/ARROW-17837\n\n\n",
                    "created": "2022-09-24T02:47:00.280+0000",
                    "updated": "2022-09-24T02:47:00.280+0000",
                    "started": "2022-09-24T02:47:00.279+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "811785",
                    "issueId": "13482995"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482995/worklog/811786",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #14227:\nURL: https://github.com/apache/arrow/pull/14227#issuecomment-1256840243\n\n   :warning: Ticket **has no components in JIRA**, make sure you assign one.\n\n\n",
                    "created": "2022-09-24T02:47:01.513+0000",
                    "updated": "2022-09-24T02:47:01.513+0000",
                    "started": "2022-09-24T02:47:01.512+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "811786",
                    "issueId": "13482995"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482995/worklog/811787",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #14227:\nURL: https://github.com/apache/arrow/pull/14227#issuecomment-1256840244\n\n   :warning: Ticket **has not been started in JIRA**, please click 'Start Progress'.\n\n\n",
                    "created": "2022-09-24T02:47:02.331+0000",
                    "updated": "2022-09-24T02:47:02.331+0000",
                    "started": "2022-09-24T02:47:02.331+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "811787",
                    "issueId": "13482995"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482995/worklog/825140",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #14227:\nURL: https://github.com/apache/arrow/pull/14227#discussion_r1019672803\n\n\n##########\ncpp/src/arrow/compute/exec/query_context.h:\n##########\n@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/util/async_util.h\"\n+\n+#pragma once\n+\n+namespace arrow {\n+namespace internal {\n+class CpuInfo;\n\nReview Comment:\n   This seems to be forward declared in a few places (not just from this PR).  Maybe we can add it to `util/type_fwd.h`?\n\n\n\n##########\ncpp/src/arrow/compute/exec/query_context.h:\n##########\n@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/util/async_util.h\"\n+\n+#pragma once\n+\n+namespace arrow {\n+namespace internal {\n+class CpuInfo;\n+}\n+\n+using io::IOContext;\n+namespace compute {\n+struct ARROW_EXPORT QueryOptions {\n+  QueryOptions();\n+  // 0 means unlimited\n+  size_t max_memory_bytes;\n+\n+  /// \\brief Should the plan use a legacy batching strategy\n+  ///\n+  /// This is currently in place only to support the Scanner::ToTable\n+  /// method.  This method relies on batch indices from the scanner\n+  /// remaining consistent.  This is impractical in the ExecPlan which\n+  /// might slice batches as needed (e.g. for a join)\n+  ///\n+  /// However, it still works for simple plans and this is the only way\n+  /// we have at the moment for maintaining implicit order.\n+  bool use_legacy_batching;\n+};\n+\n+class ARROW_EXPORT QueryContext {\n+ public:\n+  QueryContext(QueryOptions opts = {},\n+               ExecContext exec_context = *default_exec_context());\n+\n+  Status Init(size_t max_num_threads);\n+\n+  const ::arrow::internal::CpuInfo* cpu_info() const;\n+  int64_t hardware_flags() const { return cpu_info()->hardware_flags(); }\n+  const QueryOptions& options() const { return options_; }\n+  MemoryPool* memory_pool() const { return exec_context_.memory_pool(); }\n+  ::arrow::internal::Executor* executor() const { return exec_context_.executor(); }\n+  ExecContext* exec_context() { return &exec_context_; }\n+  IOContext* io_context() { return &io_context_; }\n+  TaskScheduler* scheduler() { return task_scheduler_.get(); }\n+  util::AsyncTaskScheduler* async_scheduler() { return async_scheduler_.get(); }\n+\n+  size_t GetThreadIndex();\n+  size_t max_concurrency() const;\n+  Result<util::TempVectorStack*> GetTempStack(size_t thread_index);\n\nReview Comment:\n   This feels a little odd that it would lead to code like:\r\n   \r\n   ```\r\n   query_context->GetTempStack(query_context->GetThreadIndex());\r\n   ```\r\n   \r\n   In other words...why would the query context need the `thread_index` if it is the one providing the thread index?  My current best guess is because we expect the call to `GetThreadIndex()` to be somewhat costly?\n\n\n\n##########\ncpp/src/arrow/compute/exec/query_context.h:\n##########\n@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/util/async_util.h\"\n+\n+#pragma once\n+\n+namespace arrow {\n+namespace internal {\n+class CpuInfo;\n+}\n+\n+using io::IOContext;\n+namespace compute {\n+struct ARROW_EXPORT QueryOptions {\n+  QueryOptions();\n+  // 0 means unlimited\n+  size_t max_memory_bytes;\n\nReview Comment:\n   Also...we will need to be very clear how we document this field :laughing:\r\n   \r\n   Users don't often have a solid understanding of all the places RAM could be used (scratch buffer, incoming I/O, outgoing I/O, fragmentation, etc.) and if we just leave this as `max_memory_bytes` then people will complain as soon as RSS goes above this number.\n\n\n\n##########\ncpp/src/arrow/compute/exec/query_context.h:\n##########\n@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/util/async_util.h\"\n+\n+#pragma once\n+\n+namespace arrow {\n+namespace internal {\n+class CpuInfo;\n+}\n+\n+using io::IOContext;\n+namespace compute {\n+struct ARROW_EXPORT QueryOptions {\n+  QueryOptions();\n+  // 0 means unlimited\n+  size_t max_memory_bytes;\n+\n+  /// \\brief Should the plan use a legacy batching strategy\n+  ///\n+  /// This is currently in place only to support the Scanner::ToTable\n+  /// method.  This method relies on batch indices from the scanner\n+  /// remaining consistent.  This is impractical in the ExecPlan which\n+  /// might slice batches as needed (e.g. for a join)\n+  ///\n+  /// However, it still works for simple plans and this is the only way\n+  /// we have at the moment for maintaining implicit order.\n+  bool use_legacy_batching;\n+};\n+\n+class ARROW_EXPORT QueryContext {\n+ public:\n+  QueryContext(QueryOptions opts = {},\n+               ExecContext exec_context = *default_exec_context());\n+\n+  Status Init(size_t max_num_threads);\n+\n+  const ::arrow::internal::CpuInfo* cpu_info() const;\n+  int64_t hardware_flags() const { return cpu_info()->hardware_flags(); }\n\nReview Comment:\n   I'm pretty sure accessing `cpu_info()` in this way requires a fully defined type so maybe just get rid of the forward declaration above or move this method into a `.cc` file?\n\n\n\n##########\ncpp/src/arrow/compute/exec/query_context.h:\n##########\n@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/util/async_util.h\"\n+\n+#pragma once\n+\n+namespace arrow {\n+namespace internal {\n+class CpuInfo;\n+}\n+\n+using io::IOContext;\n+namespace compute {\n+struct ARROW_EXPORT QueryOptions {\n+  QueryOptions();\n+  // 0 means unlimited\n+  size_t max_memory_bytes;\n+\n+  /// \\brief Should the plan use a legacy batching strategy\n+  ///\n+  /// This is currently in place only to support the Scanner::ToTable\n+  /// method.  This method relies on batch indices from the scanner\n+  /// remaining consistent.  This is impractical in the ExecPlan which\n+  /// might slice batches as needed (e.g. for a join)\n+  ///\n+  /// However, it still works for simple plans and this is the only way\n+  /// we have at the moment for maintaining implicit order.\n+  bool use_legacy_batching;\n+};\n+\n+class ARROW_EXPORT QueryContext {\n+ public:\n+  QueryContext(QueryOptions opts = {},\n+               ExecContext exec_context = *default_exec_context());\n+\n+  Status Init(size_t max_num_threads);\n+\n+  const ::arrow::internal::CpuInfo* cpu_info() const;\n+  int64_t hardware_flags() const { return cpu_info()->hardware_flags(); }\n+  const QueryOptions& options() const { return options_; }\n+  MemoryPool* memory_pool() const { return exec_context_.memory_pool(); }\n+  ::arrow::internal::Executor* executor() const { return exec_context_.executor(); }\n+  ExecContext* exec_context() { return &exec_context_; }\n+  IOContext* io_context() { return &io_context_; }\n+  TaskScheduler* scheduler() { return task_scheduler_.get(); }\n+  util::AsyncTaskScheduler* async_scheduler() { return async_scheduler_.get(); }\n+\n+  size_t GetThreadIndex();\n+  size_t max_concurrency() const;\n+  Result<util::TempVectorStack*> GetTempStack(size_t thread_index);\n+\n+  /// \\brief Start an external task\n+  ///\n+  /// This should be avoided if possible.  It is kept in for now for legacy\n+  /// purposes.  This should be called before the external task is started.  If\n+  /// a valid future is returned then it should be marked complete when the\n+  /// external task has finished.\n+  ///\n+  /// \\return an invalid future if the plan has already ended, otherwise this\n+  ///         returns a future that must be completed when the external task\n+  ///         finishes.\n+  Result<Future<>> BeginExternalTask();\n+\n+  /// \\brief Add a single function as a task to the query's task group\n+  ///        on the compute threadpool.\n+  ///\n+  /// \\param fn The task to run. Takes no arguments and returns a Status.\n+  Status ScheduleTask(std::function<Status()> fn);\n+  /// \\brief Add a single function as a task to the query's task group\n+  ///        on the compute threadpool.\n+  ///\n+  /// \\param fn The task to run. Takes the thread index and returns a Status.\n+  Status ScheduleTask(std::function<Status(size_t)> fn);\n+  /// \\brief Add a single function as a task to the query's task group on\n+  ///        the IO thread pool\n+  ///\n+  /// \\param fn The task to run. Returns a status.\n+  Status ScheduleIOTask(std::function<Status()> fn);\n+\n+  // Register/Start TaskGroup is a way of performing a \"Parallel For\" pattern:\n+  // - The task function takes the thread index and the index of the task\n+  // - The on_finished function takes the thread index\n+  // Returns an integer ID that will be used to reference the task group in\n+  // StartTaskGroup. At runtime, call StartTaskGroup with the ID and the number of times\n+  // you'd like the task to be executed. The need to register a task group before use will\n+  // be removed after we rewrite the scheduler.\n+  /// \\brief Register a \"parallel for\" task group with the scheduler\n+  ///\n+  /// \\param task The function implementing the task. Takes the thread_index and\n+  ///             the task index.\n+  /// \\param on_finished The function that gets run once all tasks have been completed.\n+  /// Takes the thread_index.\n+  ///\n+  /// Must be called inside of ExecNode::Init.\n+  int RegisterTaskGroup(std::function<Status(size_t, int64_t)> task,\n+                        std::function<Status(size_t)> on_finished);\n+\n+  /// \\brief Start the task group with the specified ID. This can only\n+  ///        be called once per task_group_id.\n+  ///\n+  /// \\param task_group_id The ID  of the task group to run\n+  /// \\param num_tasks The number of times to run the task\n+  Status StartTaskGroup(int task_group_id, int64_t num_tasks);\n+\n+  // This is an RAII class for keeping track of in-flight file IO. Useful for getting\n+  // an estimate of memory use, and how much memory we expect to be freed soon.\n+  // Returned by ReportTempFileIO.\n+  struct [[nodiscard]] TempFileIOMark {\n+    QueryContext* ctx_;\n+    size_t bytes_;\n+\n+    TempFileIOMark(QueryContext* ctx, size_t bytes) : ctx_(ctx), bytes_(bytes) {\n+      ctx_->in_flight_bytes_to_disk_.fetch_add(bytes_, std::memory_order_acquire);\n+    }\n+\n+    ~TempFileIOMark() {\n+      ctx_->in_flight_bytes_to_disk_.fetch_sub(bytes_, std::memory_order_release);\n+    }\n+  };\n+\n+  TempFileIOMark ReportTempFileIO(size_t bytes) { return {this, bytes}; }\n+\n+  size_t GetCurrentTempFileIO() { return in_flight_bytes_to_disk_.load(); }\n+\n+ private:\n+  QueryOptions options_;\n+  // To be replaced with Acero-specific context once scheduler is done and\n+  // we don't need ExecContext for kernels\n+  ExecContext exec_context_;\n+  IOContext io_context_;\n+\n+  std::unique_ptr<util::AsyncTaskScheduler> async_scheduler_ =\n+      util::AsyncTaskScheduler::Make();\n\nReview Comment:\n   This will need rebase as there is no longer a unique_ptr to an async task scheduler (it is owned by itself and destroyed when all tasks have finished).\n\n\n\n##########\ncpp/src/arrow/compute/exec/query_context.h:\n##########\n@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/util/async_util.h\"\n+\n+#pragma once\n+\n+namespace arrow {\n+namespace internal {\n+class CpuInfo;\n+}\n+\n+using io::IOContext;\n+namespace compute {\n+struct ARROW_EXPORT QueryOptions {\n+  QueryOptions();\n+  // 0 means unlimited\n+  size_t max_memory_bytes;\n+\n+  /// \\brief Should the plan use a legacy batching strategy\n+  ///\n+  /// This is currently in place only to support the Scanner::ToTable\n+  /// method.  This method relies on batch indices from the scanner\n+  /// remaining consistent.  This is impractical in the ExecPlan which\n+  /// might slice batches as needed (e.g. for a join)\n+  ///\n+  /// However, it still works for simple plans and this is the only way\n+  /// we have at the moment for maintaining implicit order.\n+  bool use_legacy_batching;\n+};\n+\n+class ARROW_EXPORT QueryContext {\n\nReview Comment:\n   This won't be \"user facing\" but it will be pretty relevant to anyone working on exec nodes.  We might want some docstrings explaining what these various fields are.  This could be deferred to a more general purpose \"create documentation for custom node authors\" PR though.\n\n\n\n##########\ncpp/src/arrow/compute/exec/query_context.h:\n##########\n@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/util/async_util.h\"\n+\n+#pragma once\n+\n+namespace arrow {\n+namespace internal {\n+class CpuInfo;\n+}\n+\n+using io::IOContext;\n+namespace compute {\n+struct ARROW_EXPORT QueryOptions {\n+  QueryOptions();\n+  // 0 means unlimited\n+  size_t max_memory_bytes;\n\nReview Comment:\n   I agree we will want this but let's remove it until we're ready to support it in some way (sorry, I guess you probably moved it here from the hash spilling PR and now it will have to move back :grimacing: )\n\n\n\n##########\ncpp/src/arrow/compute/exec/query_context.h:\n##########\n@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/util/async_util.h\"\n+\n+#pragma once\n+\n+namespace arrow {\n+namespace internal {\n+class CpuInfo;\n+}\n+\n+using io::IOContext;\n+namespace compute {\n+struct ARROW_EXPORT QueryOptions {\n+  QueryOptions();\n+  // 0 means unlimited\n+  size_t max_memory_bytes;\n+\n+  /// \\brief Should the plan use a legacy batching strategy\n+  ///\n+  /// This is currently in place only to support the Scanner::ToTable\n+  /// method.  This method relies on batch indices from the scanner\n+  /// remaining consistent.  This is impractical in the ExecPlan which\n+  /// might slice batches as needed (e.g. for a join)\n+  ///\n+  /// However, it still works for simple plans and this is the only way\n+  /// we have at the moment for maintaining implicit order.\n+  bool use_legacy_batching;\n+};\n+\n+class ARROW_EXPORT QueryContext {\n+ public:\n+  QueryContext(QueryOptions opts = {},\n+               ExecContext exec_context = *default_exec_context());\n+\n+  Status Init(size_t max_num_threads);\n+\n+  const ::arrow::internal::CpuInfo* cpu_info() const;\n+  int64_t hardware_flags() const { return cpu_info()->hardware_flags(); }\n+  const QueryOptions& options() const { return options_; }\n+  MemoryPool* memory_pool() const { return exec_context_.memory_pool(); }\n+  ::arrow::internal::Executor* executor() const { return exec_context_.executor(); }\n+  ExecContext* exec_context() { return &exec_context_; }\n+  IOContext* io_context() { return &io_context_; }\n+  TaskScheduler* scheduler() { return task_scheduler_.get(); }\n+  util::AsyncTaskScheduler* async_scheduler() { return async_scheduler_.get(); }\n+\n+  size_t GetThreadIndex();\n+  size_t max_concurrency() const;\n+  Result<util::TempVectorStack*> GetTempStack(size_t thread_index);\n+\n+  /// \\brief Start an external task\n+  ///\n+  /// This should be avoided if possible.  It is kept in for now for legacy\n+  /// purposes.  This should be called before the external task is started.  If\n+  /// a valid future is returned then it should be marked complete when the\n+  /// external task has finished.\n+  ///\n+  /// \\return an invalid future if the plan has already ended, otherwise this\n+  ///         returns a future that must be completed when the external task\n+  ///         finishes.\n+  Result<Future<>> BeginExternalTask();\n+\n+  /// \\brief Add a single function as a task to the query's task group\n+  ///        on the compute threadpool.\n+  ///\n+  /// \\param fn The task to run. Takes no arguments and returns a Status.\n+  Status ScheduleTask(std::function<Status()> fn);\n+  /// \\brief Add a single function as a task to the query's task group\n+  ///        on the compute threadpool.\n+  ///\n+  /// \\param fn The task to run. Takes the thread index and returns a Status.\n+  Status ScheduleTask(std::function<Status(size_t)> fn);\n+  /// \\brief Add a single function as a task to the query's task group on\n+  ///        the IO thread pool\n+  ///\n+  /// \\param fn The task to run. Returns a status.\n+  Status ScheduleIOTask(std::function<Status()> fn);\n+\n+  // Register/Start TaskGroup is a way of performing a \"Parallel For\" pattern:\n+  // - The task function takes the thread index and the index of the task\n+  // - The on_finished function takes the thread index\n+  // Returns an integer ID that will be used to reference the task group in\n+  // StartTaskGroup. At runtime, call StartTaskGroup with the ID and the number of times\n+  // you'd like the task to be executed. The need to register a task group before use will\n+  // be removed after we rewrite the scheduler.\n+  /// \\brief Register a \"parallel for\" task group with the scheduler\n+  ///\n+  /// \\param task The function implementing the task. Takes the thread_index and\n+  ///             the task index.\n+  /// \\param on_finished The function that gets run once all tasks have been completed.\n+  /// Takes the thread_index.\n+  ///\n+  /// Must be called inside of ExecNode::Init.\n+  int RegisterTaskGroup(std::function<Status(size_t, int64_t)> task,\n+                        std::function<Status(size_t)> on_finished);\n+\n+  /// \\brief Start the task group with the specified ID. This can only\n+  ///        be called once per task_group_id.\n+  ///\n+  /// \\param task_group_id The ID  of the task group to run\n+  /// \\param num_tasks The number of times to run the task\n+  Status StartTaskGroup(int task_group_id, int64_t num_tasks);\n+\n+  // This is an RAII class for keeping track of in-flight file IO. Useful for getting\n+  // an estimate of memory use, and how much memory we expect to be freed soon.\n+  // Returned by ReportTempFileIO.\n+  struct [[nodiscard]] TempFileIOMark {\n\nReview Comment:\n   Add `ARROW_DISALLOW_COPY_AND_ASSIGN(TempFileIOMark);`?\n\n\n\n##########\ncpp/src/arrow/compute/exec/query_context.h:\n##########\n@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/util/async_util.h\"\n+\n+#pragma once\n+\n+namespace arrow {\n+namespace internal {\n+class CpuInfo;\n+}\n+\n+using io::IOContext;\n+namespace compute {\n+struct ARROW_EXPORT QueryOptions {\n+  QueryOptions();\n+  // 0 means unlimited\n+  size_t max_memory_bytes;\n+\n+  /// \\brief Should the plan use a legacy batching strategy\n+  ///\n+  /// This is currently in place only to support the Scanner::ToTable\n+  /// method.  This method relies on batch indices from the scanner\n+  /// remaining consistent.  This is impractical in the ExecPlan which\n+  /// might slice batches as needed (e.g. for a join)\n+  ///\n+  /// However, it still works for simple plans and this is the only way\n+  /// we have at the moment for maintaining implicit order.\n+  bool use_legacy_batching;\n+};\n+\n+class ARROW_EXPORT QueryContext {\n+ public:\n+  QueryContext(QueryOptions opts = {},\n+               ExecContext exec_context = *default_exec_context());\n+\n+  Status Init(size_t max_num_threads);\n+\n+  const ::arrow::internal::CpuInfo* cpu_info() const;\n+  int64_t hardware_flags() const { return cpu_info()->hardware_flags(); }\n+  const QueryOptions& options() const { return options_; }\n+  MemoryPool* memory_pool() const { return exec_context_.memory_pool(); }\n+  ::arrow::internal::Executor* executor() const { return exec_context_.executor(); }\n+  ExecContext* exec_context() { return &exec_context_; }\n+  IOContext* io_context() { return &io_context_; }\n+  TaskScheduler* scheduler() { return task_scheduler_.get(); }\n+  util::AsyncTaskScheduler* async_scheduler() { return async_scheduler_.get(); }\n+\n+  size_t GetThreadIndex();\n+  size_t max_concurrency() const;\n+  Result<util::TempVectorStack*> GetTempStack(size_t thread_index);\n+\n+  /// \\brief Start an external task\n+  ///\n+  /// This should be avoided if possible.  It is kept in for now for legacy\n+  /// purposes.  This should be called before the external task is started.  If\n+  /// a valid future is returned then it should be marked complete when the\n+  /// external task has finished.\n+  ///\n+  /// \\return an invalid future if the plan has already ended, otherwise this\n+  ///         returns a future that must be completed when the external task\n+  ///         finishes.\n+  Result<Future<>> BeginExternalTask();\n+\n+  /// \\brief Add a single function as a task to the query's task group\n+  ///        on the compute threadpool.\n+  ///\n+  /// \\param fn The task to run. Takes no arguments and returns a Status.\n+  Status ScheduleTask(std::function<Status()> fn);\n+  /// \\brief Add a single function as a task to the query's task group\n+  ///        on the compute threadpool.\n+  ///\n+  /// \\param fn The task to run. Takes the thread index and returns a Status.\n+  Status ScheduleTask(std::function<Status(size_t)> fn);\n+  /// \\brief Add a single function as a task to the query's task group on\n+  ///        the IO thread pool\n+  ///\n+  /// \\param fn The task to run. Returns a status.\n+  Status ScheduleIOTask(std::function<Status()> fn);\n+\n+  // Register/Start TaskGroup is a way of performing a \"Parallel For\" pattern:\n+  // - The task function takes the thread index and the index of the task\n+  // - The on_finished function takes the thread index\n+  // Returns an integer ID that will be used to reference the task group in\n+  // StartTaskGroup. At runtime, call StartTaskGroup with the ID and the number of times\n+  // you'd like the task to be executed. The need to register a task group before use will\n+  // be removed after we rewrite the scheduler.\n+  /// \\brief Register a \"parallel for\" task group with the scheduler\n+  ///\n+  /// \\param task The function implementing the task. Takes the thread_index and\n+  ///             the task index.\n+  /// \\param on_finished The function that gets run once all tasks have been completed.\n+  /// Takes the thread_index.\n+  ///\n+  /// Must be called inside of ExecNode::Init.\n+  int RegisterTaskGroup(std::function<Status(size_t, int64_t)> task,\n+                        std::function<Status(size_t)> on_finished);\n+\n+  /// \\brief Start the task group with the specified ID. This can only\n+  ///        be called once per task_group_id.\n+  ///\n+  /// \\param task_group_id The ID  of the task group to run\n+  /// \\param num_tasks The number of times to run the task\n+  Status StartTaskGroup(int task_group_id, int64_t num_tasks);\n+\n+  // This is an RAII class for keeping track of in-flight file IO. Useful for getting\n+  // an estimate of memory use, and how much memory we expect to be freed soon.\n+  // Returned by ReportTempFileIO.\n+  struct [[nodiscard]] TempFileIOMark {\n+    QueryContext* ctx_;\n+    size_t bytes_;\n+\n+    TempFileIOMark(QueryContext* ctx, size_t bytes) : ctx_(ctx), bytes_(bytes) {\n+      ctx_->in_flight_bytes_to_disk_.fetch_add(bytes_, std::memory_order_acquire);\n+    }\n+\n+    ~TempFileIOMark() {\n+      ctx_->in_flight_bytes_to_disk_.fetch_sub(bytes_, std::memory_order_release);\n+    }\n\nReview Comment:\n   I could very well be wrong but, I think, if you're simplly using `in_flight_bytes_to_disk_` as a counter, then you can do relaxed memory ordering.\n\n\n\n##########\ncpp/src/arrow/compute/exec/query_context.cc:\n##########\n@@ -0,0 +1,96 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/exec/query_context.h\"\n+#include \"arrow/util/cpu_info.h\"\n+#include \"arrow/util/io_util.h\"\n+\n+namespace arrow {\n+using internal::CpuInfo;\n+namespace compute {\n+QueryOptions::QueryOptions()\n+    : max_memory_bytes(\n+          static_cast<size_t>(0.75f * ::arrow::internal::GetTotalMemoryBytes())),\n+      use_legacy_batching(false) {}\n+\n+QueryContext::QueryContext(QueryOptions opts, ExecContext exec_context)\n+    : options_(opts),\n+      exec_context_(exec_context),\n+      io_context_(exec_context_.memory_pool()) {}\n+\n+const CpuInfo* QueryContext::cpu_info() const { return CpuInfo::GetInstance(); }\n+\n+Status QueryContext::Init(size_t max_num_threads) {\n+  tld_.resize(max_num_threads);\n+  return Status::OK();\n+}\n+\n+size_t QueryContext::GetThreadIndex() { return thread_indexer_(); }\n+\n+size_t QueryContext::max_concurrency() const { return thread_indexer_.Capacity(); }\n\nReview Comment:\n   Is `thread_indexer_` based on the `exec_context.executor()` somehow?  I kind of expected this to be `exec_context.executor()->Capacity()`\n\n\n\n##########\ncpp/src/arrow/dataset/scanner.cc:\n##########\n@@ -408,8 +408,11 @@ Result<EnumeratedRecordBatchGenerator> AsyncScanner::ScanBatchesUnorderedAsync(\n   auto exec_context =\n       std::make_shared<compute::ExecContext>(scan_options_->pool, cpu_executor);\n \n-  ARROW_ASSIGN_OR_RAISE(auto plan, compute::ExecPlan::Make(exec_context.get()));\n-  plan->SetUseLegacyBatching(use_legacy_batching);\n+  compute::QueryOptions query_options;\n+  query_options.use_legacy_batching = true;\n\nReview Comment:\n   ```suggestion\r\n     query_options.use_legacy_batching = use_legacy_batching;\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/query_context.cc:\n##########\n@@ -0,0 +1,96 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/exec/query_context.h\"\n+#include \"arrow/util/cpu_info.h\"\n+#include \"arrow/util/io_util.h\"\n+\n+namespace arrow {\n+using internal::CpuInfo;\n+namespace compute {\n+QueryOptions::QueryOptions()\n+    : max_memory_bytes(\n+          static_cast<size_t>(0.75f * ::arrow::internal::GetTotalMemoryBytes())),\n+      use_legacy_batching(false) {}\n+\n+QueryContext::QueryContext(QueryOptions opts, ExecContext exec_context)\n+    : options_(opts),\n+      exec_context_(exec_context),\n+      io_context_(exec_context_.memory_pool()) {}\n\nReview Comment:\n   This means we are always using the default I/O thread pool...which is probably ok for now.  I'm not sure who is supposed to be providing the I/O context anyways (e.g. filesystem?)\n\n\n\n",
                    "created": "2022-11-11T01:16:39.389+0000",
                    "updated": "2022-11-11T01:16:39.389+0000",
                    "started": "2022-11-11T01:16:39.388+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "825140",
                    "issueId": "13482995"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 2400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@28f6f415[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@50bd8d1d[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@9eaf455[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@35834510[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@75976161[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@7cdb86a7[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@22cd8d35[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@dc9f7b9[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@431b0308[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@63d55b72[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2dbfd618[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@6f898829[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 2400,
        "customfield_12312520": null,
        "customfield_12312521": "2022-09-24 02:41:43.0",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": null,
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-17837/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2022-09-24T02:41:43.000+0000",
        "updated": "2022-11-11T01:16:39.000+0000",
        "timeoriginalestimate": null,
        "description": "As we begin to include more and more plan-global stuff (such as Scheduler, AsyncScheduler, IO thread pool, ExecContext), ExecPlan's definition is becoming cluttered. ExecPlan should store and organize nodes, and store these structures elsewhere. We thus introduce QueryContext which will store any information related to the currently executing plan.\r\n\r\nAn added bonus is that now more components can be decoupled from ExecPlan and rely only on QueryContext (useful for e.g. testing, or just reusing a component in a non-ExecPlan context).\r\n\r\nAlso, this QueryContext can introduce options for the query such as maximum memory used and this legacy batching thingy.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 2400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Create ExecPlan-owned QueryContext that will store a plan's shared data structures",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [],
            "maxResults": 0,
            "total": 0,
            "startAt": 0
        },
        "customfield_12311820": "0|z18t1s:",
        "customfield_12314139": null
    }
}