{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13480461",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480461",
    "key": "ARROW-17642",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12352360",
                "id": "12352360",
                "description": "",
                "name": "11.0.0",
                "archived": false,
                "released": false
            }
        ],
        "resolution": null,
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=rtpsw",
            "name": "rtpsw",
            "key": "JIRAUSER284707",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=JIRAUSER284707&avatarId=49322",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=JIRAUSER284707&avatarId=49322",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=JIRAUSER284707&avatarId=49322",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=JIRAUSER284707&avatarId=49322"
            },
            "displayName": "Yaron Gvili",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
            "description": "The issue is open and ready for the assignee to start work on it.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
            "name": "Open",
            "id": "1",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                "id": 2,
                "key": "new",
                "colorName": "blue-gray",
                "name": "To Do"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=rtpsw",
            "name": "rtpsw",
            "key": "JIRAUSER284707",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=JIRAUSER284707&avatarId=49322",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=JIRAUSER284707&avatarId=49322",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=JIRAUSER284707&avatarId=49322",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=JIRAUSER284707&avatarId=49322"
            },
            "displayName": "Yaron Gvili",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=rtpsw",
            "name": "rtpsw",
            "key": "JIRAUSER284707",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=JIRAUSER284707&avatarId=49322",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=JIRAUSER284707&avatarId=49322",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=JIRAUSER284707&avatarId=49322",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=JIRAUSER284707&avatarId=49322"
            },
            "displayName": "Yaron Gvili",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 27600,
            "total": 27600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 27600,
            "total": 27600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-17642/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 46,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480461/worklog/814978",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw opened a new pull request, #14352:\nURL: https://github.com/apache/arrow/pull/14352\n\n   See https://issues.apache.org/jira/browse/ARROW-17642\n\n\n",
                    "created": "2022-10-08T21:22:59.390+0000",
                    "updated": "2022-10-08T21:22:59.390+0000",
                    "started": "2022-10-08T21:22:59.390+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "814978",
                    "issueId": "13480461"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480461/worklog/814979",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #14352:\nURL: https://github.com/apache/arrow/pull/14352#issuecomment-1272399626\n\n   https://issues.apache.org/jira/browse/ARROW-17642\n\n\n",
                    "created": "2022-10-08T21:23:19.347+0000",
                    "updated": "2022-10-08T21:23:19.347+0000",
                    "started": "2022-10-08T21:23:19.347+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "814979",
                    "issueId": "13480461"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480461/worklog/814980",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on PR #14352:\nURL: https://github.com/apache/arrow/pull/14352#issuecomment-1272400060\n\n   This PR implements a generalization of ordered aggregation called segmented aggregation, in which the segment-keys split the input rows into segments of consecutive rows with common values for these segment-keys. In other words, the extra keys are not required to be ordered but only to change from one segment to the next. I opted to generalize this way because the extra implementation effort is quite small and the result is useful.\n\n\n",
                    "created": "2022-10-08T21:27:22.608+0000",
                    "updated": "2022-10-08T21:27:22.608+0000",
                    "started": "2022-10-08T21:27:22.607+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "814980",
                    "issueId": "13480461"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480461/worklog/814981",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on PR #14352:\nURL: https://github.com/apache/arrow/pull/14352#issuecomment-1272400666\n\n   Note that the current implementation does not support streaming. In particular, the segment-aggregation operation produces the entire output after processing the entire input. However, the current implementation gets close enough to allow a future PR to add support for streaming without too much effort.\r\n   \r\n   cc @icexelloss\n\n\n",
                    "created": "2022-10-08T21:32:23.687+0000",
                    "updated": "2022-10-08T21:32:23.687+0000",
                    "started": "2022-10-08T21:32:23.686+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "814981",
                    "issueId": "13480461"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480461/worklog/814982",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on PR #14352:\nURL: https://github.com/apache/arrow/pull/14352#issuecomment-1272401934\n\n   Note that this PR includes code from [this](https://github.com/apache/arrow/pull/14347) and [this PR](https://github.com/apache/arrow/pull/14348), which are pending at this time.\n\n\n",
                    "created": "2022-10-08T21:42:58.721+0000",
                    "updated": "2022-10-08T21:42:58.721+0000",
                    "started": "2022-10-08T21:42:58.721+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "814982",
                    "issueId": "13480461"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480461/worklog/815355",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "icexelloss commented on PR #14352:\nURL: https://github.com/apache/arrow/pull/14352#issuecomment-1273733018\n\n   Thanks @rtpsw! Will try to take a look\n\n\n",
                    "created": "2022-10-10T19:38:18.850+0000",
                    "updated": "2022-10-10T19:38:18.850+0000",
                    "started": "2022-10-10T19:38:18.850+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "815355",
                    "issueId": "13480461"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480461/worklog/817258",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on PR #14352:\nURL: https://github.com/apache/arrow/pull/14352#issuecomment-1279701634\n\n   @lidavidm, are you a good person to review this? or can you suggest someone? Also, note this PR includes a new [SWMR gadget](https://github.com/apache/arrow/pull/14352/files#diff-f53040e5fc284581263737f96238c8a76ef54d13f01e34305c1d1d9de5e6e34bR47-R86) which may be of wider interest and could be upgraded to a visible internal API, WDYT?\n\n\n",
                    "created": "2022-10-15T09:09:28.753+0000",
                    "updated": "2022-10-15T09:09:28.753+0000",
                    "started": "2022-10-15T09:09:28.752+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "817258",
                    "issueId": "13480461"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480461/worklog/817274",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on PR #14352:\nURL: https://github.com/apache/arrow/pull/14352#issuecomment-1279748556\n\n   Weston would probably be best, but he's going to be busy with release things. Do you need a review soon?\r\n   \r\n   The link to the gadget is dead, so I'm not sure what you're referencing\n\n\n",
                    "created": "2022-10-15T13:42:18.660+0000",
                    "updated": "2022-10-15T13:42:18.660+0000",
                    "started": "2022-10-15T13:42:18.659+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "817274",
                    "issueId": "13480461"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480461/worklog/817279",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on PR #14352:\nURL: https://github.com/apache/arrow/pull/14352#issuecomment-1279750410\n\n   > Weston would probably be best, but he's going to be busy with release things. Do you need a review soon?\r\n   \r\n   Personally, I can hold. @icexelloss should answer if he needs this sooner. \r\n   \r\n   > The link to the gadget is dead, so I'm not sure what you're referencing\r\n   \r\n   Sorry about that. Please see `GatedSharedMutex` and related code in `cpp/src/arrow/compute/exec/aggregate_node.cc`.\n\n\n",
                    "created": "2022-10-15T13:52:24.040+0000",
                    "updated": "2022-10-15T13:52:24.040+0000",
                    "started": "2022-10-15T13:52:24.039+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "817279",
                    "issueId": "13480461"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480461/worklog/817309",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on PR #14352:\nURL: https://github.com/apache/arrow/pull/14352#issuecomment-1279817334\n\n   > > The link to the gadget is dead, so I'm not sure what you're referencing\r\n   > \r\n   > Sorry about that. Please see `GatedSharedMutex` and related code in `cpp/src/arrow/compute/exec/aggregate_node.cc`.\r\n   \r\n   Turns out the link is OK but GitHub avoids scrolling it into view when the containing file has a large diff. When I click `Load diff` for this file I see GitHub highlights the correct block of code for the link. I'm not sure whether this is a bug or a feature of GitHub.\n\n\n",
                    "created": "2022-10-15T19:33:36.798+0000",
                    "updated": "2022-10-15T19:33:36.798+0000",
                    "started": "2022-10-15T19:33:36.797+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "817309",
                    "issueId": "13480461"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480461/worklog/817310",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on PR #14352:\nURL: https://github.com/apache/arrow/pull/14352#issuecomment-1279817920\n\n   Notes about the recent commit:\r\n   - The PyArrow `GroupBy` API currently does not expose the `segment_keys` parameter. I think this should be done in a separate task.\r\n   - The C++ `GroupBy` API currently does not support streaming. While the `Grouper` class it relies on has been refactored to make it easy to add streaming support, I think this is not a priority for the current PR because the important API is the aggregate node.\r\n   - The aggregate node API supports streaming. However, the existing tests only cover the case of an empty `segment_keys` parameter. These tests do cover the aggregate node's code in the PR but not that of all `GroupingSegment` implementations. I intend to add more tests here.\r\n   - The `SegmentKeyWithChunkedArray` test only covers chunked arrays and a single-key segmenter. I intend to add tests for other datum kinds and segmenter types.\r\n   \r\n   I would be good to get feedback on the approach for this PR even before I add further tests.\n\n\n",
                    "created": "2022-10-15T19:35:49.648+0000",
                    "updated": "2022-10-15T19:35:49.648+0000",
                    "started": "2022-10-15T19:35:49.648+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "817310",
                    "issueId": "13480461"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480461/worklog/817571",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on code in PR #14352:\nURL: https://github.com/apache/arrow/pull/14352#discussion_r996936872\n\n\n##########\ncpp/src/arrow/compute/exec/aggregate.h:\n##########\n@@ -37,6 +37,7 @@ namespace internal {\n /// and use an aggregate node.\n\nReview Comment:\n   I think this comment is not right because `GroupBy` is also used by `pyarrow._compute._group_by`, which is also exposed in `pyarrow.compute`.\n\n\n\n",
                    "created": "2022-10-17T11:20:45.696+0000",
                    "updated": "2022-10-17T11:20:45.696+0000",
                    "started": "2022-10-17T11:20:45.696+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "817571",
                    "issueId": "13480461"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480461/worklog/817573",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on code in PR #14352:\nURL: https://github.com/apache/arrow/pull/14352#discussion_r996938948\n\n\n##########\ncpp/src/arrow/compute/exec/aggregate.h:\n##########\n@@ -37,6 +37,7 @@ namespace internal {\n /// and use an aggregate node.\n\nReview Comment:\n   I think the comment ending here is not right because `GroupBy` is also used by `pyarrow._compute._group_by`, which is also exposed in `pyarrow.compute`.\n\n\n\n",
                    "created": "2022-10-17T11:23:05.903+0000",
                    "updated": "2022-10-17T11:23:05.903+0000",
                    "started": "2022-10-17T11:23:05.903+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "817573",
                    "issueId": "13480461"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480461/worklog/817608",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "icexelloss commented on PR #14352:\nURL: https://github.com/apache/arrow/pull/14352#issuecomment-1280848037\n\n   @lidavidm We do not need this soon. This can wait a little bit (2 weeks or so)\n\n\n",
                    "created": "2022-10-17T13:18:56.015+0000",
                    "updated": "2022-10-17T13:18:56.015+0000",
                    "started": "2022-10-17T13:18:56.014+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "817608",
                    "issueId": "13480461"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480461/worklog/817696",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on PR #14352:\nURL: https://github.com/apache/arrow/pull/14352#issuecomment-1281037032\n\n   Pushed a change I had in flight. Holding for now.\n\n\n",
                    "created": "2022-10-17T15:18:09.978+0000",
                    "updated": "2022-10-17T15:18:09.978+0000",
                    "started": "2022-10-17T15:18:09.977+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "817696",
                    "issueId": "13480461"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480461/worklog/819409",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on PR #14352:\nURL: https://github.com/apache/arrow/pull/14352#issuecomment-1288067166\n\n   > @lidavidm, are you a good person to review this? or can you suggest someone? Also, note this PR includes a new [SWMR gadget](https://github.com/apache/arrow/pull/14352/files#diff-f53040e5fc284581263737f96238c8a76ef54d13f01e34305c1d1d9de5e6e34bR47-R86) which may be of wider interest and could be upgraded to a visible internal API, WDYT?\r\n   \r\n   To be fair, there are plenty of possible mutex policies ([example discussion](https://stackoverflow.com/questions/57706952/does-stdshared-mutex-favor-writers-over-readers)). I think the first question is whether the usefulness to Arrow of the proposed policy and its implementation are worth a (separate) discussion.\n\n\n",
                    "created": "2022-10-23T09:41:03.646+0000",
                    "updated": "2022-10-23T09:41:03.646+0000",
                    "started": "2022-10-23T09:41:03.645+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "819409",
                    "issueId": "13480461"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480461/worklog/823728",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on PR #14352:\nURL: https://github.com/apache/arrow/pull/14352#issuecomment-1304808093\n\n   @lidavidm, it may be a good time to get back to this. cc @icexelloss\n\n\n",
                    "created": "2022-11-06T14:00:54.113+0000",
                    "updated": "2022-11-06T14:00:54.113+0000",
                    "started": "2022-11-06T14:00:54.113+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "823728",
                    "issueId": "13480461"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480461/worklog/823900",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on PR #14352:\nURL: https://github.com/apache/arrow/pull/14352#issuecomment-1305550862\n\n   Yes, sorry. I'll see if I can get to this soon. Or CC @westonpace.\n\n\n",
                    "created": "2022-11-07T12:41:53.933+0000",
                    "updated": "2022-11-07T12:41:53.933+0000",
                    "started": "2022-11-07T12:41:53.932+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "823900",
                    "issueId": "13480461"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480461/worklog/824215",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #14352:\nURL: https://github.com/apache/arrow/pull/14352#discussion_r1015921757\n\n\n##########\ncpp/src/arrow/compare.cc:\n##########\n@@ -305,6 +305,11 @@ class RangeDataEqualsImpl {\n   Status Visit(const StructType& type) {\n     const int32_t num_fields = type.num_fields();\n \n+    if (left_.child_data.size() != static_cast<size_t>(num_fields) ||\n+        right_.child_data.size() != static_cast<size_t>(num_fields)) {\n+      result_ = false;\n+      return Status::OK();\n+    }\n\nReview Comment:\n   Was something like this discussed on another PR? Didn't we resolve it there?\n\n\n\n##########\ncpp/src/arrow/compute/exec/aggregate.h:\n##########\n@@ -32,14 +32,24 @@ namespace arrow {\n namespace compute {\n namespace internal {\n \n-/// Internal use only: helper function for testing HashAggregateKernels.\n+/// Internal use only: helpers for PyArrow and testing HashAggregateKernels.\n /// For public use see arrow::compute::Grouper or create an execution plan\n /// and use an aggregate node.\n+\n ARROW_EXPORT\n Result<Datum> GroupBy(const std::vector<Datum>& arguments, const std::vector<Datum>& keys,\n+                      const std::vector<Datum>& segment_keys,\n                       const std::vector<Aggregate>& aggregates, bool use_threads = false,\n                       ExecContext* ctx = default_exec_context());\n \n+using GroupByCallback = std::function<Status(const Datum&)>;\n+\n+ARROW_EXPORT\n+Status GroupBy(const std::vector<Datum>& arguments, const std::vector<Datum>& keys,\n+               const std::vector<Datum>& segment_keys,\n+               const std::vector<Aggregate>& aggregates, GroupByCallback callback,\n+               bool use_threads = false, ExecContext* ctx = default_exec_context());\n\nReview Comment:\n   This overload is only used in tests?\n\n\n\n##########\ncpp/src/arrow/compute/row/grouper.cc:\n##########\n@@ -44,7 +45,406 @@ namespace compute {\n \n namespace {\n \n-struct GrouperImpl : Grouper {\n+inline const uint8_t* GetValuesAsBytes(const ArrayData& data, int64_t offset = 0) {\n+  int64_t absolute_byte_offset = (data.offset + offset) * data.type->byte_width();\n+  return data.GetValues<uint8_t>(1, absolute_byte_offset);\n+}\n+\n+inline const uint8_t* GetValuesAsBytes(const ArraySpan& data, int64_t offset = 0) {\n+  int64_t absolute_byte_offset = (data.offset + offset) * data.type->byte_width();\n+  return data.GetValues<uint8_t>(1, absolute_byte_offset);\n+}\n+\n+template <typename Value>\n+Status CheckForGetNextSegment(const std::vector<Value>& values, int64_t length,\n+                              int64_t offset, const std::vector<TypeHolder>& key_types) {\n+  if (offset < 0 || offset > length) {\n+    return Status::Invalid(\"invalid grouping segmenter offset: \", offset);\n+  }\n+  if (values.size() != key_types.size()) {\n+    return Status::Invalid(\"expected batch size \", key_types.size(), \" but got \",\n+                           values.size());\n+  }\n+  for (size_t i = 0; i < key_types.size(); i++) {\n+    const auto& value = values[i];\n+    const auto& key_type = key_types[i];\n+    if (*value.type() != *key_type.type) {\n+      return Status::Invalid(\"expected batch value \", i, \" of type \", *key_type.type,\n+                             \" but got \", *value.type());\n+    }\n+  }\n+  return Status::OK();\n+}\n+\n+Status CheckForGetNextSegment(const ExecSpan& batch, int64_t offset,\n+                              const std::vector<TypeHolder>& key_types) {\n+  return CheckForGetNextSegment(batch.values, batch.length, offset, key_types);\n+}\n+\n+Status CheckForGetNextSegment(const ExecBatch& batch, int64_t offset,\n+                              const std::vector<TypeHolder>& key_types) {\n+  return CheckForGetNextSegment(batch.values, batch.length, offset, key_types);\n+}\n+\n+struct StatelessGroupingSegmenter : public GroupingSegmenter {\n+  Status Reset() override { return Status::OK(); }\n+};\n+\n+GroupingSegment MakeSegment(int64_t batch_length, int64_t offset, int64_t length) {\n+  return GroupingSegment{offset, length, offset + length >= batch_length};\n+}\n+\n+int64_t GetMatchLength(const uint8_t* match_bytes, int64_t match_width,\n+                       const uint8_t* array_bytes, int64_t offset, int64_t length) {\n+  int64_t cursor, byte_cursor;\n+  for (cursor = offset, byte_cursor = match_width * cursor; cursor < length;\n+       cursor++, byte_cursor += match_width) {\n+    if (memcmp(match_bytes, array_bytes + byte_cursor,\n+               static_cast<size_t>(match_width)) != 0) {\n+      break;\n+    }\n+  }\n+  return std::min(cursor, length - offset);\n+}\n+\n+Result<GroupingSegment> GetNextSegmentChunked(\n+    const std::shared_ptr<ChunkedArray>& chunked_array, int64_t offset) {\n+  if (offset >= chunked_array->length()) {\n+    return MakeSegment(chunked_array->length(), chunked_array->length(), 0);\n+  }\n+  int64_t remaining_offset = offset;\n+  const auto& arrays = chunked_array->chunks();\n+  for (size_t i = 0; remaining_offset >= 0 && i < arrays.size(); i++) {\n+    // look up chunk containing offset\n+    int64_t array_length = arrays[i]->length();\n+    if (remaining_offset < array_length) {\n+      // found - switch to matching\n+      int64_t match_width = arrays[i]->type()->byte_width();\n+      const uint8_t* match_bytes = GetValuesAsBytes(*arrays[i]->data(), remaining_offset);\n+      int64_t total_match_length = 0;\n+      for (; i < arrays.size(); i++) {\n+        int64_t array_length = arrays[i]->length();\n+        if (array_length <= 0) continue;\n+        const uint8_t* array_bytes = GetValuesAsBytes(*arrays[i]->data());\n+        int64_t match_length = GetMatchLength(match_bytes, match_width, array_bytes,\n+                                              remaining_offset, array_length);\n+        total_match_length += match_length;\n+        remaining_offset = 0;\n+        if (match_length < array_length - remaining_offset) break;\n+      }\n+      return MakeSegment(chunked_array->length(), offset, total_match_length);\n+    }\n+    remaining_offset -= array_length;\n+  }\n+  return Status::Invalid(\"segmenting invalid chunked array value\");\n+}\n+\n+struct NoKeysGroupingSegmenter : public StatelessGroupingSegmenter {\n+  static Result<std::unique_ptr<GroupingSegmenter>> Make() {\n+    return std::make_unique<NoKeysGroupingSegmenter>();\n+  }\n+\n+  template <typename Batch>\n+  Result<GroupingSegment> GetNextSegmentImpl(const Batch& batch, int64_t offset) {\n+    ARROW_RETURN_NOT_OK(CheckForGetNextSegment(batch, offset, {}));\n+    return MakeSegment(batch.length, offset, batch.length - offset);\n+  }\n+\n+  Result<GroupingSegment> GetNextSegment(const ExecSpan& batch, int64_t offset) override {\n+    return GetNextSegmentImpl(batch, offset);\n+  }\n+\n+  Result<GroupingSegment> GetNextSegment(const ExecBatch& batch,\n+                                         int64_t offset) override {\n+    return GetNextSegmentImpl(batch, offset);\n+  }\n+};\n+\n+struct SimpleKeyGroupingSegmenter : public StatelessGroupingSegmenter {\n+  static Result<std::unique_ptr<GroupingSegmenter>> Make(\n+      std::vector<TypeHolder> key_types) {\n+    return std::make_unique<SimpleKeyGroupingSegmenter>(key_types);\n+  }\n+\n+  explicit SimpleKeyGroupingSegmenter(std::vector<TypeHolder> key_types)\n+      : key_types_(std::move(key_types)) {}\n+\n+  Status CheckType(const DataType& type) {\n+    if (!is_fixed_width(type)) {\n+      return Status::Invalid(\"SimpleKeyGroupingSegmenter does not support type \", type);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<GroupingSegment> GetNextSegment(const Scalar& scalar, int64_t offset,\n+                                         int64_t length) {\n+    ARROW_RETURN_NOT_OK(CheckType(*scalar.type));\n+    if (!scalar.is_valid) {\n+      return Status::Invalid(\"segmenting an invalid scalar\");\n+    }\n+    return MakeSegment(length, 0, length);\n+  }\n+\n+  Result<GroupingSegment> GetNextSegment(const DataType& array_type,\n+                                         const uint8_t* array_bytes, int64_t offset,\n+                                         int64_t length) {\n+    RETURN_NOT_OK(CheckType(array_type));\n+    int64_t byte_width = array_type.byte_width();\n+    int64_t match_length = GetMatchLength(array_bytes + offset * byte_width, byte_width,\n+                                          array_bytes, offset, length);\n+    return MakeSegment(length, offset, match_length);\n+  }\n+\n+  Result<GroupingSegment> GetNextSegment(const ExecSpan& batch, int64_t offset) override {\n+    ARROW_RETURN_NOT_OK(CheckForGetNextSegment(batch, offset, key_types_));\n+    const auto& value = batch.values[0];\n+    if (value.is_scalar()) {\n+      return GetNextSegment(*value.scalar, offset, batch.length);\n+    }\n+    ARROW_DCHECK(value.is_array());\n+    const auto& array = value.array;\n+    if (array.GetNullCount() > 0) {\n+      return Status::NotImplemented(\"segmenting a nullable array\");\n+    }\n+    return GetNextSegment(*array.type, GetValuesAsBytes(array), offset, batch.length);\n+  }\n+\n+  Result<GroupingSegment> GetNextSegment(const ExecBatch& batch,\n+                                         int64_t offset) override {\n+    ARROW_RETURN_NOT_OK(CheckForGetNextSegment(batch, offset, key_types_));\n+    const auto& value = batch.values[0];\n+    if (value.is_scalar()) {\n+      return GetNextSegment(*value.scalar(), offset, batch.length);\n+    }\n+    if (value.is_array()) {\n+      auto array = value.array();\n+      if (array->GetNullCount() > 0) {\n+        return Status::NotImplemented(\"segmenting a nullable array\");\n+      }\n+      return GetNextSegment(*array->type, GetValuesAsBytes(*array), offset, batch.length);\n+    }\n+    if (value.is_chunked_array()) {\n+      auto array = value.chunked_array();\n+      if (array->null_count() > 0) {\n+        return Status::NotImplemented(\"segmenting a nullable array\");\n+      }\n+      return GetNextSegmentChunked(array, offset);\n+    }\n+    return Status::Invalid(\"segmenting unsupported value kind \", value.kind());\n+  }\n+\n+ private:\n+  const std::vector<TypeHolder> key_types_;\n+};\n+\n+struct AnyKeysGroupingSegmenter : public StatelessGroupingSegmenter {\n+  static Result<std::unique_ptr<GroupingSegmenter>> Make(\n+      std::vector<TypeHolder> key_types, ExecContext* ctx) {\n+    ARROW_RETURN_NOT_OK(Grouper::Make(key_types, ctx));  // check types\n+    return std::make_unique<AnyKeysGroupingSegmenter>(key_types, ctx);\n+  }\n+\n+  AnyKeysGroupingSegmenter(std::vector<TypeHolder> key_types, ExecContext* ctx)\n+      : key_types_(std::move(key_types)), ctx_(ctx) {}\n+\n+  template <typename Batch>\n+  Result<GroupingSegment> GetNextSegmentImpl(const Batch& batch, int64_t offset) {\n+    ARROW_RETURN_NOT_OK(CheckForGetNextSegment(batch, offset, key_types_));\n+    // TODO: make Grouper support Reset(), so it can be cached instead of recreated here\n+    ARROW_ASSIGN_OR_RAISE(auto grouper, Grouper::Make(key_types_, ctx_));\n+    ARROW_ASSIGN_OR_RAISE(auto datum, grouper->Consume(batch, offset));\n+    if (datum.is_array()) {\n+      const std::shared_ptr<ArrayData>& data = datum.array();\n+      ARROW_DCHECK(data->GetNullCount() == 0);\n+      ARROW_DCHECK(*data->type == *uint32());  // as long as Grouper::Consume gives uint32\n\nReview Comment:\n   nit, use things like `DCHECK_EQ(data->type->id(), Type::UINT32)`\n\n\n\n##########\ncpp/src/arrow/compute/row/grouper.cc:\n##########\n@@ -44,7 +45,406 @@ namespace compute {\n \n namespace {\n \n-struct GrouperImpl : Grouper {\n+inline const uint8_t* GetValuesAsBytes(const ArrayData& data, int64_t offset = 0) {\n+  int64_t absolute_byte_offset = (data.offset + offset) * data.type->byte_width();\n+  return data.GetValues<uint8_t>(1, absolute_byte_offset);\n+}\n+\n+inline const uint8_t* GetValuesAsBytes(const ArraySpan& data, int64_t offset = 0) {\n+  int64_t absolute_byte_offset = (data.offset + offset) * data.type->byte_width();\n+  return data.GetValues<uint8_t>(1, absolute_byte_offset);\n+}\n+\n+template <typename Value>\n+Status CheckForGetNextSegment(const std::vector<Value>& values, int64_t length,\n+                              int64_t offset, const std::vector<TypeHolder>& key_types) {\n+  if (offset < 0 || offset > length) {\n+    return Status::Invalid(\"invalid grouping segmenter offset: \", offset);\n+  }\n+  if (values.size() != key_types.size()) {\n+    return Status::Invalid(\"expected batch size \", key_types.size(), \" but got \",\n+                           values.size());\n+  }\n+  for (size_t i = 0; i < key_types.size(); i++) {\n+    const auto& value = values[i];\n+    const auto& key_type = key_types[i];\n+    if (*value.type() != *key_type.type) {\n+      return Status::Invalid(\"expected batch value \", i, \" of type \", *key_type.type,\n+                             \" but got \", *value.type());\n+    }\n+  }\n+  return Status::OK();\n+}\n+\n+Status CheckForGetNextSegment(const ExecSpan& batch, int64_t offset,\n+                              const std::vector<TypeHolder>& key_types) {\n+  return CheckForGetNextSegment(batch.values, batch.length, offset, key_types);\n+}\n+\n+Status CheckForGetNextSegment(const ExecBatch& batch, int64_t offset,\n+                              const std::vector<TypeHolder>& key_types) {\n+  return CheckForGetNextSegment(batch.values, batch.length, offset, key_types);\n+}\n+\n+struct StatelessGroupingSegmenter : public GroupingSegmenter {\n+  Status Reset() override { return Status::OK(); }\n+};\n+\n+GroupingSegment MakeSegment(int64_t batch_length, int64_t offset, int64_t length) {\n+  return GroupingSegment{offset, length, offset + length >= batch_length};\n+}\n+\n+int64_t GetMatchLength(const uint8_t* match_bytes, int64_t match_width,\n+                       const uint8_t* array_bytes, int64_t offset, int64_t length) {\n+  int64_t cursor, byte_cursor;\n+  for (cursor = offset, byte_cursor = match_width * cursor; cursor < length;\n+       cursor++, byte_cursor += match_width) {\n+    if (memcmp(match_bytes, array_bytes + byte_cursor,\n+               static_cast<size_t>(match_width)) != 0) {\n+      break;\n+    }\n+  }\n+  return std::min(cursor, length - offset);\n+}\n+\n+Result<GroupingSegment> GetNextSegmentChunked(\n+    const std::shared_ptr<ChunkedArray>& chunked_array, int64_t offset) {\n+  if (offset >= chunked_array->length()) {\n+    return MakeSegment(chunked_array->length(), chunked_array->length(), 0);\n+  }\n+  int64_t remaining_offset = offset;\n+  const auto& arrays = chunked_array->chunks();\n+  for (size_t i = 0; remaining_offset >= 0 && i < arrays.size(); i++) {\n+    // look up chunk containing offset\n+    int64_t array_length = arrays[i]->length();\n+    if (remaining_offset < array_length) {\n+      // found - switch to matching\n+      int64_t match_width = arrays[i]->type()->byte_width();\n+      const uint8_t* match_bytes = GetValuesAsBytes(*arrays[i]->data(), remaining_offset);\n+      int64_t total_match_length = 0;\n+      for (; i < arrays.size(); i++) {\n+        int64_t array_length = arrays[i]->length();\n+        if (array_length <= 0) continue;\n+        const uint8_t* array_bytes = GetValuesAsBytes(*arrays[i]->data());\n+        int64_t match_length = GetMatchLength(match_bytes, match_width, array_bytes,\n+                                              remaining_offset, array_length);\n+        total_match_length += match_length;\n+        remaining_offset = 0;\n+        if (match_length < array_length - remaining_offset) break;\n+      }\n+      return MakeSegment(chunked_array->length(), offset, total_match_length);\n+    }\n+    remaining_offset -= array_length;\n+  }\n+  return Status::Invalid(\"segmenting invalid chunked array value\");\n+}\n+\n+struct NoKeysGroupingSegmenter : public StatelessGroupingSegmenter {\n+  static Result<std::unique_ptr<GroupingSegmenter>> Make() {\n+    return std::make_unique<NoKeysGroupingSegmenter>();\n+  }\n+\n+  template <typename Batch>\n+  Result<GroupingSegment> GetNextSegmentImpl(const Batch& batch, int64_t offset) {\n+    ARROW_RETURN_NOT_OK(CheckForGetNextSegment(batch, offset, {}));\n+    return MakeSegment(batch.length, offset, batch.length - offset);\n+  }\n+\n+  Result<GroupingSegment> GetNextSegment(const ExecSpan& batch, int64_t offset) override {\n+    return GetNextSegmentImpl(batch, offset);\n+  }\n+\n+  Result<GroupingSegment> GetNextSegment(const ExecBatch& batch,\n+                                         int64_t offset) override {\n+    return GetNextSegmentImpl(batch, offset);\n+  }\n+};\n+\n+struct SimpleKeyGroupingSegmenter : public StatelessGroupingSegmenter {\n+  static Result<std::unique_ptr<GroupingSegmenter>> Make(\n+      std::vector<TypeHolder> key_types) {\n+    return std::make_unique<SimpleKeyGroupingSegmenter>(key_types);\n+  }\n+\n+  explicit SimpleKeyGroupingSegmenter(std::vector<TypeHolder> key_types)\n+      : key_types_(std::move(key_types)) {}\n+\n+  Status CheckType(const DataType& type) {\n+    if (!is_fixed_width(type)) {\n+      return Status::Invalid(\"SimpleKeyGroupingSegmenter does not support type \", type);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<GroupingSegment> GetNextSegment(const Scalar& scalar, int64_t offset,\n+                                         int64_t length) {\n+    ARROW_RETURN_NOT_OK(CheckType(*scalar.type));\n+    if (!scalar.is_valid) {\n+      return Status::Invalid(\"segmenting an invalid scalar\");\n+    }\n+    return MakeSegment(length, 0, length);\n+  }\n+\n+  Result<GroupingSegment> GetNextSegment(const DataType& array_type,\n+                                         const uint8_t* array_bytes, int64_t offset,\n+                                         int64_t length) {\n+    RETURN_NOT_OK(CheckType(array_type));\n+    int64_t byte_width = array_type.byte_width();\n+    int64_t match_length = GetMatchLength(array_bytes + offset * byte_width, byte_width,\n+                                          array_bytes, offset, length);\n+    return MakeSegment(length, offset, match_length);\n+  }\n+\n+  Result<GroupingSegment> GetNextSegment(const ExecSpan& batch, int64_t offset) override {\n+    ARROW_RETURN_NOT_OK(CheckForGetNextSegment(batch, offset, key_types_));\n+    const auto& value = batch.values[0];\n+    if (value.is_scalar()) {\n+      return GetNextSegment(*value.scalar, offset, batch.length);\n+    }\n+    ARROW_DCHECK(value.is_array());\n+    const auto& array = value.array;\n+    if (array.GetNullCount() > 0) {\n+      return Status::NotImplemented(\"segmenting a nullable array\");\n+    }\n+    return GetNextSegment(*array.type, GetValuesAsBytes(array), offset, batch.length);\n+  }\n+\n+  Result<GroupingSegment> GetNextSegment(const ExecBatch& batch,\n+                                         int64_t offset) override {\n+    ARROW_RETURN_NOT_OK(CheckForGetNextSegment(batch, offset, key_types_));\n+    const auto& value = batch.values[0];\n+    if (value.is_scalar()) {\n+      return GetNextSegment(*value.scalar(), offset, batch.length);\n+    }\n+    if (value.is_array()) {\n+      auto array = value.array();\n+      if (array->GetNullCount() > 0) {\n+        return Status::NotImplemented(\"segmenting a nullable array\");\n+      }\n+      return GetNextSegment(*array->type, GetValuesAsBytes(*array), offset, batch.length);\n+    }\n+    if (value.is_chunked_array()) {\n+      auto array = value.chunked_array();\n+      if (array->null_count() > 0) {\n+        return Status::NotImplemented(\"segmenting a nullable array\");\n+      }\n+      return GetNextSegmentChunked(array, offset);\n+    }\n+    return Status::Invalid(\"segmenting unsupported value kind \", value.kind());\n+  }\n+\n+ private:\n+  const std::vector<TypeHolder> key_types_;\n+};\n+\n+struct AnyKeysGroupingSegmenter : public StatelessGroupingSegmenter {\n+  static Result<std::unique_ptr<GroupingSegmenter>> Make(\n+      std::vector<TypeHolder> key_types, ExecContext* ctx) {\n+    ARROW_RETURN_NOT_OK(Grouper::Make(key_types, ctx));  // check types\n+    return std::make_unique<AnyKeysGroupingSegmenter>(key_types, ctx);\n+  }\n+\n+  AnyKeysGroupingSegmenter(std::vector<TypeHolder> key_types, ExecContext* ctx)\n+      : key_types_(std::move(key_types)), ctx_(ctx) {}\n+\n+  template <typename Batch>\n+  Result<GroupingSegment> GetNextSegmentImpl(const Batch& batch, int64_t offset) {\n+    ARROW_RETURN_NOT_OK(CheckForGetNextSegment(batch, offset, key_types_));\n+    // TODO: make Grouper support Reset(), so it can be cached instead of recreated here\n+    ARROW_ASSIGN_OR_RAISE(auto grouper, Grouper::Make(key_types_, ctx_));\n+    ARROW_ASSIGN_OR_RAISE(auto datum, grouper->Consume(batch, offset));\n+    if (datum.is_array()) {\n+      const std::shared_ptr<ArrayData>& data = datum.array();\n+      ARROW_DCHECK(data->GetNullCount() == 0);\n+      ARROW_DCHECK(*data->type == *uint32());  // as long as Grouper::Consume gives uint32\n+      const uint32_t* values = data->GetValues<uint32_t>(1);\n+      int64_t cursor;\n+      for (cursor = 1; cursor < data->length; cursor++) {\n+        if (values[0] != values[cursor]) break;\n+      }\n+      return MakeSegment(batch.length, offset, std::min(cursor, batch.length - offset));\n+    } else if (datum.is_chunked_array()) {\n+      return GetNextSegmentChunked(datum.chunked_array(), offset);\n+    } else {\n+      return Status::Invalid(\"segmenting unsupported datum kind \", datum.kind());\n+    }\n+  }\n+\n+  Result<GroupingSegment> GetNextSegment(const ExecSpan& batch, int64_t offset) override {\n+    return GetNextSegmentImpl(batch, offset);\n+  }\n+\n+  Result<GroupingSegment> GetNextSegment(const ExecBatch& batch,\n+                                         int64_t offset) override {\n+    return GetNextSegmentImpl(batch, offset);\n+  }\n+\n+ private:\n+  const std::vector<TypeHolder> key_types_;\n+  ExecContext* const ctx_;\n+};\n+\n+Status CheckForConsume(const ExecSpan& batch, int64_t& consume_offset,\n+                       int64_t& consume_length) {\n+  if (consume_offset < 0) {\n+    return Status::Invalid(\"invalid grouper consume offset: \", consume_offset);\n+  }\n+  if (consume_length < 0) {\n+    consume_length = batch.length - consume_offset;\n+  }\n+  return Status::OK();\n+}\n+\n+}  // namespace\n+\n+Result<std::unique_ptr<GroupingSegmenter>> GroupingSegmenter::Make(\n+    std::vector<TypeHolder> key_types, ExecContext* ctx) {\n+  if (key_types.size() == 0) {\n+    return NoKeysGroupingSegmenter::Make();\n+  } else if (key_types.size() == 1) {\n+    const DataType* type = key_types[0].type;\n+    if (type != NULLPTR && is_fixed_width(*type)) {\n+      return SimpleKeyGroupingSegmenter::Make(std::move(key_types));\n+    }\n+  }\n+  return AnyKeysGroupingSegmenter::Make(std::move(key_types), ctx);\n+}\n+\n+namespace {\n+\n+struct BaseGrouper : public Grouper {\n+  int IndexOfChunk(const ExecBatch& batch) {\n+    int i = 0;\n+    for (const auto& value : batch.values) {\n+      if (value.is_chunked_array()) {\n+        return i;\n+      }\n+      ++i;\n+    }\n+    return -1;\n+  }\n+\n+  bool HasConsistentChunks(const ExecBatch& batch, int index_of_chunk) {\n\nReview Comment:\n   Not necessarily an issue here, but maybe something like MultipleChunkIterator would let us avoid having to do this check? https://github.com/apache/arrow/blob/5889c78e344688f8fa8100ecdf254cd701ee3445/cpp/src/arrow/chunked_array.h#L198-L237\n\n\n\n##########\ncpp/src/arrow/compute/kernels/hash_aggregate_test.cc:\n##########\n@@ -71,6 +71,31 @@ using internal::checked_pointer_cast;\n namespace compute {\n namespace {\n \n+Result<Datum> AlternatorGroupBy(const std::vector<Datum>& arguments,\n\nReview Comment:\n   What is the purpose of this? The implicit mutable state isn't great, and it seems both code paths it tests are effectively identical anyways?\n\n\n\n##########\ncpp/src/arrow/compute/kernels/hash_aggregate_test.cc:\n##########\n@@ -253,17 +300,23 @@ Result<Datum> GroupByTest(const std::vector<Datum>& arguments,\n     idx = idx + 1;\n   }\n   if (use_exec_plan) {\n-    return GroupByUsingExecPlan(arguments, keys, internal_aggregates, use_threads,\n-                                small_chunksize_context(use_threads));\n+    return GroupByUsingExecPlan(arguments, keys, segment_keys, internal_aggregates,\n+                                use_threads, small_chunksize_context(use_threads));\n   } else {\n-    return internal::GroupBy(arguments, keys, internal_aggregates, use_threads,\n-                             default_exec_context());\n+    return AlternatorGroupBy(arguments, keys, segment_keys, internal_aggregates,\n+                             use_threads, default_exec_context());\n   }\n }\n \n-}  // namespace\n+Result<Datum> GroupByTest(const std::vector<Datum>& arguments,\n+                          const std::vector<Datum>& keys,\n+                          const std::vector<TestAggregate>& aggregates, bool use_threads,\n+                          bool use_exec_plan = false) {\n+  return GroupByTest(arguments, keys, {}, aggregates, use_threads, use_exec_plan);\n+}\n \n-TEST(Grouper, SupportedKeys) {\n+template <typename GroupClass>\n+void test_group_class_supported_keys() {\n\nReview Comment:\n   Why does this refactoring only replace some instances of Grouper with GroupClass?\n\n\n\n##########\ncpp/src/arrow/compute/row/grouper.cc:\n##########\n@@ -44,7 +45,406 @@ namespace compute {\n \n namespace {\n \n-struct GrouperImpl : Grouper {\n+inline const uint8_t* GetValuesAsBytes(const ArrayData& data, int64_t offset = 0) {\n+  int64_t absolute_byte_offset = (data.offset + offset) * data.type->byte_width();\n+  return data.GetValues<uint8_t>(1, absolute_byte_offset);\n+}\n+\n+inline const uint8_t* GetValuesAsBytes(const ArraySpan& data, int64_t offset = 0) {\n+  int64_t absolute_byte_offset = (data.offset + offset) * data.type->byte_width();\n+  return data.GetValues<uint8_t>(1, absolute_byte_offset);\n+}\n+\n+template <typename Value>\n+Status CheckForGetNextSegment(const std::vector<Value>& values, int64_t length,\n+                              int64_t offset, const std::vector<TypeHolder>& key_types) {\n+  if (offset < 0 || offset > length) {\n+    return Status::Invalid(\"invalid grouping segmenter offset: \", offset);\n+  }\n+  if (values.size() != key_types.size()) {\n+    return Status::Invalid(\"expected batch size \", key_types.size(), \" but got \",\n+                           values.size());\n+  }\n+  for (size_t i = 0; i < key_types.size(); i++) {\n+    const auto& value = values[i];\n+    const auto& key_type = key_types[i];\n+    if (*value.type() != *key_type.type) {\n+      return Status::Invalid(\"expected batch value \", i, \" of type \", *key_type.type,\n+                             \" but got \", *value.type());\n+    }\n+  }\n+  return Status::OK();\n+}\n+\n+Status CheckForGetNextSegment(const ExecSpan& batch, int64_t offset,\n+                              const std::vector<TypeHolder>& key_types) {\n+  return CheckForGetNextSegment(batch.values, batch.length, offset, key_types);\n+}\n+\n+Status CheckForGetNextSegment(const ExecBatch& batch, int64_t offset,\n+                              const std::vector<TypeHolder>& key_types) {\n+  return CheckForGetNextSegment(batch.values, batch.length, offset, key_types);\n+}\n+\n+struct StatelessGroupingSegmenter : public GroupingSegmenter {\n+  Status Reset() override { return Status::OK(); }\n+};\n+\n+GroupingSegment MakeSegment(int64_t batch_length, int64_t offset, int64_t length) {\n+  return GroupingSegment{offset, length, offset + length >= batch_length};\n+}\n+\n+int64_t GetMatchLength(const uint8_t* match_bytes, int64_t match_width,\n+                       const uint8_t* array_bytes, int64_t offset, int64_t length) {\n+  int64_t cursor, byte_cursor;\n+  for (cursor = offset, byte_cursor = match_width * cursor; cursor < length;\n+       cursor++, byte_cursor += match_width) {\n+    if (memcmp(match_bytes, array_bytes + byte_cursor,\n+               static_cast<size_t>(match_width)) != 0) {\n+      break;\n+    }\n+  }\n+  return std::min(cursor, length - offset);\n+}\n+\n+Result<GroupingSegment> GetNextSegmentChunked(\n+    const std::shared_ptr<ChunkedArray>& chunked_array, int64_t offset) {\n+  if (offset >= chunked_array->length()) {\n+    return MakeSegment(chunked_array->length(), chunked_array->length(), 0);\n+  }\n+  int64_t remaining_offset = offset;\n+  const auto& arrays = chunked_array->chunks();\n+  for (size_t i = 0; remaining_offset >= 0 && i < arrays.size(); i++) {\n+    // look up chunk containing offset\n+    int64_t array_length = arrays[i]->length();\n+    if (remaining_offset < array_length) {\n+      // found - switch to matching\n+      int64_t match_width = arrays[i]->type()->byte_width();\n+      const uint8_t* match_bytes = GetValuesAsBytes(*arrays[i]->data(), remaining_offset);\n+      int64_t total_match_length = 0;\n+      for (; i < arrays.size(); i++) {\n+        int64_t array_length = arrays[i]->length();\n+        if (array_length <= 0) continue;\n+        const uint8_t* array_bytes = GetValuesAsBytes(*arrays[i]->data());\n+        int64_t match_length = GetMatchLength(match_bytes, match_width, array_bytes,\n+                                              remaining_offset, array_length);\n+        total_match_length += match_length;\n+        remaining_offset = 0;\n+        if (match_length < array_length - remaining_offset) break;\n+      }\n+      return MakeSegment(chunked_array->length(), offset, total_match_length);\n+    }\n+    remaining_offset -= array_length;\n+  }\n+  return Status::Invalid(\"segmenting invalid chunked array value\");\n+}\n+\n+struct NoKeysGroupingSegmenter : public StatelessGroupingSegmenter {\n+  static Result<std::unique_ptr<GroupingSegmenter>> Make() {\n+    return std::make_unique<NoKeysGroupingSegmenter>();\n+  }\n+\n+  template <typename Batch>\n+  Result<GroupingSegment> GetNextSegmentImpl(const Batch& batch, int64_t offset) {\n+    ARROW_RETURN_NOT_OK(CheckForGetNextSegment(batch, offset, {}));\n+    return MakeSegment(batch.length, offset, batch.length - offset);\n+  }\n+\n+  Result<GroupingSegment> GetNextSegment(const ExecSpan& batch, int64_t offset) override {\n+    return GetNextSegmentImpl(batch, offset);\n+  }\n+\n+  Result<GroupingSegment> GetNextSegment(const ExecBatch& batch,\n+                                         int64_t offset) override {\n+    return GetNextSegmentImpl(batch, offset);\n+  }\n+};\n+\n+struct SimpleKeyGroupingSegmenter : public StatelessGroupingSegmenter {\n+  static Result<std::unique_ptr<GroupingSegmenter>> Make(\n+      std::vector<TypeHolder> key_types) {\n+    return std::make_unique<SimpleKeyGroupingSegmenter>(key_types);\n+  }\n+\n+  explicit SimpleKeyGroupingSegmenter(std::vector<TypeHolder> key_types)\n+      : key_types_(std::move(key_types)) {}\n+\n+  Status CheckType(const DataType& type) {\n+    if (!is_fixed_width(type)) {\n+      return Status::Invalid(\"SimpleKeyGroupingSegmenter does not support type \", type);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<GroupingSegment> GetNextSegment(const Scalar& scalar, int64_t offset,\n+                                         int64_t length) {\n+    ARROW_RETURN_NOT_OK(CheckType(*scalar.type));\n+    if (!scalar.is_valid) {\n+      return Status::Invalid(\"segmenting an invalid scalar\");\n+    }\n+    return MakeSegment(length, 0, length);\n+  }\n+\n+  Result<GroupingSegment> GetNextSegment(const DataType& array_type,\n+                                         const uint8_t* array_bytes, int64_t offset,\n+                                         int64_t length) {\n+    RETURN_NOT_OK(CheckType(array_type));\n+    int64_t byte_width = array_type.byte_width();\n+    int64_t match_length = GetMatchLength(array_bytes + offset * byte_width, byte_width,\n+                                          array_bytes, offset, length);\n+    return MakeSegment(length, offset, match_length);\n+  }\n+\n+  Result<GroupingSegment> GetNextSegment(const ExecSpan& batch, int64_t offset) override {\n+    ARROW_RETURN_NOT_OK(CheckForGetNextSegment(batch, offset, key_types_));\n+    const auto& value = batch.values[0];\n+    if (value.is_scalar()) {\n+      return GetNextSegment(*value.scalar, offset, batch.length);\n+    }\n+    ARROW_DCHECK(value.is_array());\n+    const auto& array = value.array;\n+    if (array.GetNullCount() > 0) {\n+      return Status::NotImplemented(\"segmenting a nullable array\");\n+    }\n+    return GetNextSegment(*array.type, GetValuesAsBytes(array), offset, batch.length);\n+  }\n+\n+  Result<GroupingSegment> GetNextSegment(const ExecBatch& batch,\n+                                         int64_t offset) override {\n+    ARROW_RETURN_NOT_OK(CheckForGetNextSegment(batch, offset, key_types_));\n+    const auto& value = batch.values[0];\n+    if (value.is_scalar()) {\n+      return GetNextSegment(*value.scalar(), offset, batch.length);\n+    }\n+    if (value.is_array()) {\n+      auto array = value.array();\n+      if (array->GetNullCount() > 0) {\n+        return Status::NotImplemented(\"segmenting a nullable array\");\n+      }\n+      return GetNextSegment(*array->type, GetValuesAsBytes(*array), offset, batch.length);\n+    }\n+    if (value.is_chunked_array()) {\n+      auto array = value.chunked_array();\n+      if (array->null_count() > 0) {\n+        return Status::NotImplemented(\"segmenting a nullable array\");\n+      }\n+      return GetNextSegmentChunked(array, offset);\n+    }\n+    return Status::Invalid(\"segmenting unsupported value kind \", value.kind());\n+  }\n+\n+ private:\n+  const std::vector<TypeHolder> key_types_;\n+};\n+\n+struct AnyKeysGroupingSegmenter : public StatelessGroupingSegmenter {\n+  static Result<std::unique_ptr<GroupingSegmenter>> Make(\n+      std::vector<TypeHolder> key_types, ExecContext* ctx) {\n+    ARROW_RETURN_NOT_OK(Grouper::Make(key_types, ctx));  // check types\n+    return std::make_unique<AnyKeysGroupingSegmenter>(key_types, ctx);\n+  }\n+\n+  AnyKeysGroupingSegmenter(std::vector<TypeHolder> key_types, ExecContext* ctx)\n+      : key_types_(std::move(key_types)), ctx_(ctx) {}\n+\n+  template <typename Batch>\n+  Result<GroupingSegment> GetNextSegmentImpl(const Batch& batch, int64_t offset) {\n+    ARROW_RETURN_NOT_OK(CheckForGetNextSegment(batch, offset, key_types_));\n+    // TODO: make Grouper support Reset(), so it can be cached instead of recreated here\n\nReview Comment:\n   nit: file a jira for this?\n\n\n\n##########\ncpp/src/arrow/compute/kernels/hash_aggregate_test.cc:\n##########\n@@ -4167,5 +4362,197 @@ TEST(GroupBy, OnlyKeys) {\n     }\n   }\n }\n+\n+void TestSegmentKey(const std::shared_ptr<Table>& table, Datum output,\n+                    const std::vector<Datum>& segment_keys) {\n+  ASSERT_OK_AND_ASSIGN(Datum aggregated_and_grouped,\n+                       AlternatorGroupBy(\n+                           {\n+                               table->GetColumnByName(\"argument\"),\n+                               table->GetColumnByName(\"argument\"),\n+                               table->GetColumnByName(\"argument\"),\n+                           },\n+                           {\n+                               table->GetColumnByName(\"key\"),\n+                           },\n+                           segment_keys,\n+                           {\n+                               {\"hash_count\", nullptr, \"agg_0\", \"hash_count\"},\n+                               {\"hash_sum\", nullptr, \"agg_1\", \"hash_sum\"},\n+                               {\"hash_min_max\", nullptr, \"agg_2\", \"hash_min_max\"},\n+                           }));\n+\n+  AssertDatumsEqual(output, aggregated_and_grouped, /*verbose=*/true);\n+}\n+\n+Result<std::shared_ptr<Table>> GetSingleSegmentKeyInputAsChunked() {\n+  auto table = TableFromJSON(schema({field(\"argument\", float64()), field(\"key\", int64()),\n\nReview Comment:\n   TableFromJSON and the other FooFromJSON functions don't return Result, so you can avoid a layer of wrapping down below\n\n\n\n",
                    "created": "2022-11-08T14:10:12.793+0000",
                    "updated": "2022-11-08T14:10:12.793+0000",
                    "started": "2022-11-08T14:10:12.793+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "824215",
                    "issueId": "13480461"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480461/worklog/824216",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #14352:\nURL: https://github.com/apache/arrow/pull/14352#discussion_r1016640128\n\n\n##########\ncpp/src/arrow/compute/row/grouper.h:\n##########\n@@ -30,6 +30,40 @@\n namespace arrow {\n namespace compute {\n \n+struct ARROW_EXPORT GroupingSegment {\n+  int64_t offset;\n+  int64_t length;\n+  bool is_open;\n+};\n+\n+inline bool operator==(const GroupingSegment& segment1, const GroupingSegment& segment2) {\n+  return segment1.offset == segment2.offset && segment1.length == segment2.length &&\n+         segment1.is_open == segment2.is_open;\n+}\n+inline bool operator!=(const GroupingSegment& segment1, const GroupingSegment& segment2) {\n+  return !(segment1 == segment2);\n+}\n+\n+class ARROW_EXPORT GroupingSegmenter {\n\nReview Comment:\n   nit: docstring?\n\n\n\n##########\ncpp/src/arrow/compute/kernels/hash_aggregate_test.cc:\n##########\n@@ -253,17 +300,23 @@ Result<Datum> GroupByTest(const std::vector<Datum>& arguments,\n     idx = idx + 1;\n   }\n   if (use_exec_plan) {\n-    return GroupByUsingExecPlan(arguments, keys, internal_aggregates, use_threads,\n-                                small_chunksize_context(use_threads));\n+    return GroupByUsingExecPlan(arguments, keys, segment_keys, internal_aggregates,\n+                                use_threads, small_chunksize_context(use_threads));\n   } else {\n-    return internal::GroupBy(arguments, keys, internal_aggregates, use_threads,\n-                             default_exec_context());\n+    return AlternatorGroupBy(arguments, keys, segment_keys, internal_aggregates,\n+                             use_threads, default_exec_context());\n   }\n }\n \n-}  // namespace\n+Result<Datum> GroupByTest(const std::vector<Datum>& arguments,\n+                          const std::vector<Datum>& keys,\n+                          const std::vector<TestAggregate>& aggregates, bool use_threads,\n+                          bool use_exec_plan = false) {\n+  return GroupByTest(arguments, keys, {}, aggregates, use_threads, use_exec_plan);\n+}\n \n-TEST(Grouper, SupportedKeys) {\n+template <typename GroupClass>\n+void test_group_class_supported_keys() {\n\nReview Comment:\n   nit: please follow CamelCase naming convention for functions\n\n\n\n##########\ncpp/src/arrow/compute/exec/aggregate.h:\n##########\n@@ -37,6 +37,7 @@ namespace internal {\n /// and use an aggregate node.\n\nReview Comment:\n   Hmm, yeah, plus \"internal use only\" things should go in an `_internal.h` header. Maybe this is more like, \"this is exposed for use by PyArrow but we make no guarantees for use outside this codebase\"\n\n\n\n",
                    "created": "2022-11-08T14:10:27.695+0000",
                    "updated": "2022-11-08T14:10:27.695+0000",
                    "started": "2022-11-08T14:10:27.694+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "824216",
                    "issueId": "13480461"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 27600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@2ecae2d2[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@39b1ab24[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@704db681[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@4411db27[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@405c0da0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@935cc4e[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@14d19a57[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@5e53a309[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7e42846e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@59327054[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@41294a07[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@221f2c0[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 27600,
        "customfield_12312520": null,
        "customfield_12312521": "2022-09-07 11:10:19.0",
        "customfield_12314422": null,
        "customfield_12314421": [
            "C++"
        ],
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": null,
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-17642/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2022-09-07T11:10:19.000+0000",
        "updated": "2022-11-14T18:17:33.000+0000",
        "timeoriginalestimate": null,
        "description": "{color:#000000}Ordered aggregation is similar to grouped aggregation except that one column in the grouping key is (known to be) ordered. The result of both types of aggregations is the same but the existence of an ordered column enables optimizing.{color}",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "7h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 27600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Add ordered aggregation",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [],
            "maxResults": 0,
            "total": 0,
            "startAt": 0
        },
        "customfield_12311820": "0|z18dkw:",
        "customfield_12314139": null
    }
}