{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13360364",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360364",
    "key": "ARROW-11745",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349493",
                "id": "12349493",
                "description": "",
                "name": "4.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-04-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12609080",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12609080",
                "type": {
                    "id": "12310051",
                    "name": "Supercedes",
                    "inward": "is superceded by",
                    "outward": "supercedes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310051"
                },
                "outwardIssue": {
                    "id": "13311785",
                    "key": "ARROW-9149",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311785",
                    "fields": {
                        "summary": "[C++] Improve configurability of RandomArrayGenerator::ArrayOf",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12612252",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12612252",
                "type": {
                    "id": "12310051",
                    "name": "Supercedes",
                    "inward": "is superceded by",
                    "outward": "supercedes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310051"
                },
                "outwardIssue": {
                    "id": "13359113",
                    "key": "ARROW-11674",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13359113",
                    "fields": {
                        "summary": "[C++] Add tests for RandomArrayGenerator",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
                            "name": "Minor",
                            "id": "4"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 7800,
            "total": 7800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 7800,
            "total": 7800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11745/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 13,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360364/worklog/566577",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm opened a new pull request #9715:\nURL: https://github.com/apache/arrow/pull/9715\n\n\n   This adds a vaguely Hypothesis-esque helper to generate a random record batch from a list of fields, whose metadata is inspected and used to set generation parameters (e.g. min/max value).\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-15T22:05:29.777+0000",
                    "updated": "2021-03-15T22:05:29.777+0000",
                    "started": "2021-03-15T22:05:29.777+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "566577",
                    "issueId": "13360364"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360364/worklog/566585",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #9715:\nURL: https://github.com/apache/arrow/pull/9715#issuecomment-799791495\n\n\n   https://issues.apache.org/jira/browse/ARROW-11745\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-15T22:16:48.478+0000",
                    "updated": "2021-03-15T22:16:48.478+0000",
                    "started": "2021-03-15T22:16:48.477+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "566585",
                    "issueId": "13360364"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360364/worklog/567707",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #9715:\nURL: https://github.com/apache/arrow/pull/9715#discussion_r596029757\n\n\n\n##########\nFile path: cpp/src/arrow/testing/random.h\n##########\n@@ -358,6 +362,10 @@ class ARROW_TESTING_EXPORT RandomArrayGenerator {\n   std::default_random_engine seed_rng_;\n };\n \n+ARROW_TESTING_EXPORT\n+std::shared_ptr<arrow::RecordBatch> Generate(const FieldVector& fields, int64_t size,\n+                                             SeedType seed);\n\nReview comment:\n       What do you think about replacing explicit seed arguments (which are usually repeated within a suite) with\r\n   ```c++\r\n   /// The seed used for random generation. Non const to support customizing the seed for a suite\r\n   static SeedType kSeed = 0xDEADBEEF;\r\n   ```\r\n   \r\n   or\r\n   \r\n   ```c++\r\n   /// Sets the seed used for random generation while it is in scope.\r\n   /// May be constructed at static scope to set the seed for an entire\r\n   /// test/benchmark suite. If no SeedGuard is in scope, the seed will\r\n   /// be kDefaultSeed\r\n   struct SeedGuard {\r\n     explicit SeedGuard(SeedType seed) { PushSeed(seed); }\r\n     ~SeedGuard() { PopSeed(); }\r\n   \r\n     static constexpr SeedType kDefaultSeed = 0xDEADBEEF;\r\n   \r\n     static void PopSeed();\r\n     static void PushSeed(SeedType);\r\n   };\r\n   ```\r\n   ?\n\n##########\nFile path: cpp/src/arrow/testing/random.cc\n##########\n@@ -369,12 +371,16 @@ std::shared_ptr<Array> RandomArrayGenerator::FixedSizeBinary(int64_t size,\n                                                 std::move(null_bitmap), null_count);\n }\n \n-std::shared_ptr<Array> RandomArrayGenerator::Offsets(int64_t size, int32_t first_offset,\n-                                                     int32_t last_offset,\n-                                                     double null_probability,\n-                                                     bool force_empty_nulls) {\n-  using GenOpt = GenerateOptions<int32_t, std::uniform_int_distribution<int32_t>>;\n-  GenOpt options(seed(), first_offset, last_offset, null_probability);\n+namespace {\n+template <typename ArrayType>\n\nReview comment:\n       When I read this first, I was looking for `typename ArrayType::TypeClass::offset_type` because I assumed this parameter referred to `StringArray` or so\r\n   ```suggestion\r\n   template <typename OffsetArrayType>\r\n   ```\n\n##########\nFile path: cpp/src/arrow/testing/random_test.cc\n##########\n@@ -0,0 +1,195 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+\n+namespace arrow {\n+namespace random {\n+\n+class RandomArrayTest : public ::testing::TestWithParam<std::shared_ptr<Field>> {\n+ protected:\n+  std::shared_ptr<Field> GetField() { return GetParam(); }\n+};\n+\n+template <typename T>\n+class RandomNumericArrayTest : public ::testing::Test {\n+ protected:\n+  std::shared_ptr<Field> GetField() { return field(\"field0\", std::make_shared<T>()); }\n+\n+  std::shared_ptr<NumericArray<T>> Downcast(std::shared_ptr<Array> array) {\n+    return internal::checked_pointer_cast<NumericArray<T>>(array);\n+  }\n+};\n+\n+TEST_P(RandomArrayTest, GenerateArray) {\n+  auto field = GetField();\n+  auto batch = Generate({field}, 128, 0xDEADBEEF);\n+  AssertSchemaEqual(schema({field}), batch->schema());\n+  auto array = batch->column(0);\n+  ASSERT_EQ(128, array->length());\n+  ASSERT_OK(array->ValidateFull());\n+}\n+\n+TEST_P(RandomArrayTest, GenerateNonNullArray) {\n+  auto field =\n+      GetField()->WithMetadata(key_value_metadata({{\"null_probability\", \"0.0\"}}));\n+  if (field->type()->id() == Type::type::NA) {\n+    GTEST_SKIP() << \"Cannot generate non-null null arrays\";\n+  }\n+  auto batch = Generate({field}, 128, 0xDEADBEEF);\n+  AssertSchemaEqual(schema({field}), batch->schema());\n+  auto array = batch->column(0);\n+  ASSERT_OK(array->ValidateFull());\n+  ASSERT_EQ(0, array->null_count());\n+}\n+\n+TEST_P(RandomArrayTest, GenerateNonNullableArray) {\n+  auto field = GetField()->WithNullable(false);\n+  if (field->type()->id() == Type::type::NA) {\n+    GTEST_SKIP() << \"Cannot generate non-null null arrays\";\n+  }\n+  auto batch = Generate({field}, 128, 0xDEADBEEF);\n+  AssertSchemaEqual(schema({field}), batch->schema());\n+  auto array = batch->column(0);\n+  ASSERT_OK(array->ValidateFull());\n+  ASSERT_EQ(0, array->null_count());\n+}\n+\n+struct FieldParamName {\n+  template <class ParamType>\n+  std::string operator()(const ::testing::TestParamInfo<ParamType>& info) const {\n+    return std::to_string(info.index) + info.param->name();\n+  }\n+};\n+\n+auto values = ::testing::Values(\n+    field(\"null\", null()), field(\"bool\", boolean()), field(\"uint8\", uint8()),\n+    field(\"int8\", int8()), field(\"uint16\", uint16()), field(\"int16\", int16()),\n+    field(\"uint32\", uint32()), field(\"int32\", int32()), field(\"uint64\", uint64()),\n+    field(\"int64\", int64()), field(\"float16\", float16()), field(\"float32\", float32()),\n+    field(\"float64\", float64()), field(\"string\", utf8()), field(\"binary\", binary()),\n+    field(\"fixed_size_binary\", fixed_size_binary(8)),\n+    field(\"decimal128\", decimal128(8, 3)), field(\"decimal256\", decimal256(16, 4)),\n+    field(\"date32\", date32()), field(\"date64\", date64()),\n+    field(\"timestampns\", timestamp(TimeUnit::NANO)),\n+    field(\"timestamps\", timestamp(TimeUnit::SECOND, \"America/Phoenix\")),\n+    field(\"time32ms\", time32(TimeUnit::MILLI)), field(\"time64ns\", time64(TimeUnit::NANO)),\n+    field(\"time32s\", time32(TimeUnit::SECOND)),\n+    field(\"time64us\", time64(TimeUnit::MICRO)), field(\"month_interval\", month_interval()),\n+    field(\"daytime_interval\", day_time_interval()), field(\"listint8\", list(int8())),\n+    field(\"listlistint8\", list(list(int8()))),\n+    field(\"listint8emptynulls\", list(int8()), true,\n+          key_value_metadata({{\"force_empty_nulls\", \"true\"}})),\n+    field(\"listint81024values\", list(int8()), true,\n+          key_value_metadata({{\"values\", \"1024\"}})),\n+    field(\"structints\", struct_({\n+                            field(\"int8\", int8()),\n+                            field(\"int16\", int16()),\n+                            field(\"int32\", int32()),\n+                        })),\n+    field(\"structnested\", struct_({\n+                              field(\"string\", utf8()),\n+                              field(\"list\", list(int64())),\n+                              field(\"timestamp\", timestamp(TimeUnit::MILLI)),\n+                          })),\n+    field(\"sparseunion\", sparse_union({\n+                             field(\"int8\", int8()),\n+                             field(\"int16\", int16()),\n+                             field(\"int32\", int32()),\n+                         })),\n+    field(\"denseunion\", dense_union({\n+                            field(\"int8\", int8()),\n+                            field(\"int16\", int16()),\n+                            field(\"int32\", int32()),\n+                        })),\n+    field(\"dictionary\", dictionary(int8(), utf8())), field(\"map\", map(int8(), utf8())),\n+    field(\"fixedsizelist\", fixed_size_list(int8(), 4)),\n+    field(\"durationns\", duration(TimeUnit::NANO)), field(\"largestring\", large_utf8()),\n+    field(\"largebinary\", large_binary()),\n+    field(\"largelistlistint8\", large_list(list(int8()))));\n+\n+INSTANTIATE_TEST_SUITE_P(\n+    TestRandomArrayGeneration, RandomArrayTest, values,\n+    [](const ::testing::TestParamInfo<RandomArrayTest::ParamType>& info) {\n+      return std::to_string(info.index) + info.param->name();\n+    });\n+\n+using NumericTypes =\n+    ::testing::Types<UInt8Type, Int8Type, UInt16Type, Int16Type, UInt32Type, Int32Type,\n+                     HalfFloatType, FloatType, DoubleType>;\n+TYPED_TEST_SUITE(RandomNumericArrayTest, NumericTypes);\n+\n+TYPED_TEST(RandomNumericArrayTest, GenerateMinMax) {\n+  auto field = this->GetField()->WithMetadata(\n+      key_value_metadata({{\"min\", \"0\"}, {\"max\", \"127\"}, {\"nan_probability\", \"0.0\"}}));\n+  auto batch = Generate({field}, 128, 0xDEADBEEF);\n+  AssertSchemaEqual(schema({field}), batch->schema());\n+  auto array = this->Downcast(batch->column(0));\n+  auto it = array->begin();\n+  while (it != array->end()) {\n+    if ((*it).has_value()) {\n+      ASSERT_GE(**it, typename TypeParam::c_type(0));\n+      ASSERT_LE(**it, typename TypeParam::c_type(127));\n+    }\n+    it++;\n+  }\n+}\n+\n+TEST(TypeSpecificTests, FloatNan) {\n+  auto field = arrow::field(\"float32\", float32())\n+                   ->WithMetadata(key_value_metadata({{\"nan_probability\", \"1.0\"}}));\n+  auto batch = Generate({field}, 128, 0xDEADBEEF);\n+  AssertSchemaEqual(schema({field}), batch->schema());\n+  auto array = internal::checked_pointer_cast<NumericArray<FloatType>>(batch->column(0));\n+  auto it = array->begin();\n+  while (it != array->end()) {\n+    if ((*it).has_value()) {\n+      ASSERT_TRUE(std::isnan(**it));\n+    }\n+    it++;\n+  }\n+}\n+\n+TEST(TypeSpecificTests, RepeatedStrings) {\n+  auto field =\n+      arrow::field(\"string\", utf8())->WithMetadata(key_value_metadata({{\"unique\", \"1\"}}));\n+  auto batch = Generate({field}, 128, 0xDEADBEEF);\n+  AssertSchemaEqual(schema({field}), batch->schema());\n+  auto array = internal::checked_pointer_cast<StringArray>(batch->column(0));\n+  auto it = array->begin();\n+  util::optional<util::string_view> singular_value;\n+  while (it != array->end()) {\n+    if ((*it).has_value()) {\n+      if (!singular_value.has_value()) {\n+        singular_value = *it;\n+      } else {\n+        ASSERT_EQ(*singular_value, **it);\n+      }\n+    }\n+    it++;\n+  }\n\nReview comment:\n       ```suggestion\r\n     util::string_view singular_value = array->GetView(0);\r\n     for (auto slot : *array) {\r\n       if (!slot.has_value()) continue;\r\n       ASSERT_EQ(slot, singular_value);\r\n     }\r\n   ```\n\n##########\nFile path: cpp/src/arrow/testing/random.cc\n##########\n@@ -558,5 +584,248 @@ std::shared_ptr<Array> RandomArrayGenerator::ArrayOf(std::shared_ptr<DataType> t\n   return RandomArrayGeneratorOfImpl{this, type, size, null_probability, nullptr}.Finish();\n }\n \n+namespace {\n+template <typename T>\n+typename T::c_type GetMetadata(const KeyValueMetadata* metadata, const std::string& key,\n+                               typename T::c_type default_value) {\n+  if (!metadata) return default_value;\n+  const auto index = metadata->FindKey(key);\n+  if (index < 0) return default_value;\n+  const auto& value = metadata->value(index);\n+  typename T::c_type output{};\n+  auto type = checked_pointer_cast<T>(TypeTraits<T>::type_singleton());\n+  if (!internal::ParseValue(*type, value.data(), value.length(), &output)) {\n+    ABORT_NOT_OK(Status::Invalid(\"Could not parse \", key, \" = \", value));\n+  }\n+  return output;\n+}\n+\n+Result<std::shared_ptr<Array>> GenerateArray(const Field& field, int64_t length,\n+                                             RandomArrayGenerator* generator) {\n+#define GENERATE_INTEGRAL_CASE_VIEW(BASE_TYPE, VIEW_TYPE)                                \\\n+  case VIEW_TYPE::type_id: {                                                             \\\n+    const BASE_TYPE::c_type min_value = GetMetadata<BASE_TYPE>(                          \\\n+        field.metadata().get(), \"min\", std::numeric_limits<BASE_TYPE::c_type>::min());   \\\n+    const BASE_TYPE::c_type max_value = GetMetadata<BASE_TYPE>(                          \\\n+        field.metadata().get(), \"max\", std::numeric_limits<BASE_TYPE::c_type>::max());   \\\n+    return generator->Numeric<BASE_TYPE>(length, min_value, max_value, null_probability) \\\n+        ->View(field.type());                                                            \\\n+  }\n+#define GENERATE_INTEGRAL_CASE(ARROW_TYPE) \\\n+  GENERATE_INTEGRAL_CASE_VIEW(ARROW_TYPE, ARROW_TYPE)\n+#define GENERATE_FLOATING_CASE(ARROW_TYPE, GENERATOR_FUNC)                              \\\n+  case ARROW_TYPE::type_id: {                                                           \\\n+    const ARROW_TYPE::c_type min_value = GetMetadata<ARROW_TYPE>(                       \\\n+        field.metadata().get(), \"min\", std::numeric_limits<ARROW_TYPE::c_type>::min()); \\\n+    const ARROW_TYPE::c_type max_value = GetMetadata<ARROW_TYPE>(                       \\\n+        field.metadata().get(), \"max\", std::numeric_limits<ARROW_TYPE::c_type>::max()); \\\n+    const double nan_probability =                                                      \\\n+        GetMetadata<DoubleType>(field.metadata().get(), \"nan_probability\", 0);          \\\n+    return generator->GENERATOR_FUNC(length, min_value, max_value, null_probability,    \\\n+                                     nan_probability);                                  \\\n+  }\n+\n+  const double null_probability =\n+      field.nullable()\n+          ? GetMetadata<DoubleType>(field.metadata().get(), \"null_probability\", 0.01)\n+          : 0.0;\n+  switch (field.type()->id()) {\n+    case Type::type::NA:\n+      return std::make_shared<NullArray>(length);\n+\n+    case Type::type::BOOL: {\n+      const double true_probability =\n+          GetMetadata<DoubleType>(field.metadata().get(), \"true_probability\", 0.5);\n+      return generator->Boolean(length, true_probability, null_probability);\n+    }\n+\n+      GENERATE_INTEGRAL_CASE(UInt8Type);\n+      GENERATE_INTEGRAL_CASE(Int8Type);\n+      GENERATE_INTEGRAL_CASE(UInt16Type);\n+      GENERATE_INTEGRAL_CASE(Int16Type);\n+      GENERATE_INTEGRAL_CASE(UInt32Type);\n+      GENERATE_INTEGRAL_CASE(Int32Type);\n+      GENERATE_INTEGRAL_CASE(UInt64Type);\n+      GENERATE_INTEGRAL_CASE(Int64Type);\n+      GENERATE_INTEGRAL_CASE_VIEW(Int16Type, HalfFloatType);\n+      GENERATE_FLOATING_CASE(FloatType, Float32);\n+      GENERATE_FLOATING_CASE(DoubleType, Float64);\n+\n+    case Type::type::STRING:\n+    case Type::type::BINARY: {\n+      const int32_t min_length = GetMetadata<Int32Type>(field.metadata().get(), \"min\", 0);\n+      const int32_t max_length =\n+          GetMetadata<Int32Type>(field.metadata().get(), \"max\", 1024);\n+      const int32_t unique_values =\n+          GetMetadata<Int32Type>(field.metadata().get(), \"unique\", -1);\n+      if (unique_values > 0) {\n+        return generator\n+            ->StringWithRepeats(length, unique_values, min_length, max_length,\n+                                null_probability)\n+            ->View(field.type());\n+      }\n+      return generator->String(length, min_length, max_length, null_probability)\n+          ->View(field.type());\n+    }\n+\n+    case Type::type::DECIMAL128:\n+    case Type::type::DECIMAL256:\n+    case Type::type::FIXED_SIZE_BINARY: {\n+      auto byte_width =\n+          internal::checked_pointer_cast<FixedSizeBinaryType>(field.type())->byte_width();\n+      return generator->FixedSizeBinary(length, byte_width, null_probability)\n+          ->View(field.type());\n+    }\n+\n+      GENERATE_INTEGRAL_CASE_VIEW(Int32Type, Date32Type);\n+      GENERATE_INTEGRAL_CASE_VIEW(Int64Type, Date64Type);\n+      GENERATE_INTEGRAL_CASE_VIEW(Int64Type, TimestampType);\n+      GENERATE_INTEGRAL_CASE_VIEW(Int32Type, Time32Type);\n+      GENERATE_INTEGRAL_CASE_VIEW(Int64Type, Time64Type);\n+      GENERATE_INTEGRAL_CASE_VIEW(Int32Type, MonthIntervalType);\n+\n+      // This isn't as flexible as it could be, but the array-of-structs layout of this\n+      // type means it's not a (useful) composition of other generators\n+      GENERATE_INTEGRAL_CASE_VIEW(Int64Type, DayTimeIntervalType);\n+\n+    case Type::type::LIST: {\n+      const int32_t values_length = GetMetadata<Int32Type>(\n+          field.metadata().get(), \"values\", static_cast<int32_t>(length));\n\nReview comment:\n       It's slightly odd that list's options aren't more similar to string's: here we specify the total length of the child whereas for strings we specify min/max length.\n\n##########\nFile path: cpp/src/arrow/testing/random.h\n##########\n@@ -358,6 +362,10 @@ class ARROW_TESTING_EXPORT RandomArrayGenerator {\n   std::default_random_engine seed_rng_;\n };\n \n+ARROW_TESTING_EXPORT\n+std::shared_ptr<arrow::RecordBatch> Generate(const FieldVector& fields, int64_t size,\n\nReview comment:\n       It'd probably be better to name this GenerateBatch in case we add similar methods later (GenerateTable(fields, ...), GenerateArray(field, ...), ...)\r\n   ```suggestion\r\n   std::shared_ptr<arrow::RecordBatch> GenerateBatch(const FieldVector& fields, int64_t size,\r\n   ```\r\n   GenerateArray would probably be worth making public now.\r\n   \r\n   Additionally, please provide a (default null) schema-level metadata argument.\n\n##########\nFile path: cpp/src/arrow/testing/random.cc\n##########\n@@ -558,5 +584,248 @@ std::shared_ptr<Array> RandomArrayGenerator::ArrayOf(std::shared_ptr<DataType> t\n   return RandomArrayGeneratorOfImpl{this, type, size, null_probability, nullptr}.Finish();\n }\n \n+namespace {\n+template <typename T>\n+typename T::c_type GetMetadata(const KeyValueMetadata* metadata, const std::string& key,\n+                               typename T::c_type default_value) {\n+  if (!metadata) return default_value;\n+  const auto index = metadata->FindKey(key);\n+  if (index < 0) return default_value;\n+  const auto& value = metadata->value(index);\n+  typename T::c_type output{};\n+  auto type = checked_pointer_cast<T>(TypeTraits<T>::type_singleton());\n+  if (!internal::ParseValue(*type, value.data(), value.length(), &output)) {\n+    ABORT_NOT_OK(Status::Invalid(\"Could not parse \", key, \" = \", value));\n+  }\n+  return output;\n+}\n+\n+Result<std::shared_ptr<Array>> GenerateArray(const Field& field, int64_t length,\n+                                             RandomArrayGenerator* generator) {\n+#define GENERATE_INTEGRAL_CASE_VIEW(BASE_TYPE, VIEW_TYPE)                                \\\n+  case VIEW_TYPE::type_id: {                                                             \\\n+    const BASE_TYPE::c_type min_value = GetMetadata<BASE_TYPE>(                          \\\n+        field.metadata().get(), \"min\", std::numeric_limits<BASE_TYPE::c_type>::min());   \\\n+    const BASE_TYPE::c_type max_value = GetMetadata<BASE_TYPE>(                          \\\n+        field.metadata().get(), \"max\", std::numeric_limits<BASE_TYPE::c_type>::max());   \\\n+    return generator->Numeric<BASE_TYPE>(length, min_value, max_value, null_probability) \\\n+        ->View(field.type());                                                            \\\n+  }\n+#define GENERATE_INTEGRAL_CASE(ARROW_TYPE) \\\n+  GENERATE_INTEGRAL_CASE_VIEW(ARROW_TYPE, ARROW_TYPE)\n+#define GENERATE_FLOATING_CASE(ARROW_TYPE, GENERATOR_FUNC)                              \\\n+  case ARROW_TYPE::type_id: {                                                           \\\n+    const ARROW_TYPE::c_type min_value = GetMetadata<ARROW_TYPE>(                       \\\n+        field.metadata().get(), \"min\", std::numeric_limits<ARROW_TYPE::c_type>::min()); \\\n+    const ARROW_TYPE::c_type max_value = GetMetadata<ARROW_TYPE>(                       \\\n+        field.metadata().get(), \"max\", std::numeric_limits<ARROW_TYPE::c_type>::max()); \\\n+    const double nan_probability =                                                      \\\n+        GetMetadata<DoubleType>(field.metadata().get(), \"nan_probability\", 0);          \\\n+    return generator->GENERATOR_FUNC(length, min_value, max_value, null_probability,    \\\n+                                     nan_probability);                                  \\\n+  }\n+\n+  const double null_probability =\n+      field.nullable()\n+          ? GetMetadata<DoubleType>(field.metadata().get(), \"null_probability\", 0.01)\n+          : 0.0;\n+  switch (field.type()->id()) {\n+    case Type::type::NA:\n\nReview comment:\n       should we check that `null_probability` is nonzero? Or `field.nullable()`?\n\n##########\nFile path: cpp/src/arrow/testing/random.cc\n##########\n@@ -558,5 +584,248 @@ std::shared_ptr<Array> RandomArrayGenerator::ArrayOf(std::shared_ptr<DataType> t\n   return RandomArrayGeneratorOfImpl{this, type, size, null_probability, nullptr}.Finish();\n }\n \n+namespace {\n+template <typename T>\n+typename T::c_type GetMetadata(const KeyValueMetadata* metadata, const std::string& key,\n+                               typename T::c_type default_value) {\n\nReview comment:\n       This doesn't need an explicit template argument; it can infer from `default_value`\r\n   ```suggestion\r\n   template <typename T, typename ArrowType = typename CTypeTraits<T>::ArrowType>\r\n   enable_if_parameter_free<ArrowType, T> GetMetadata(const KeyValueMetadata* metadata, const std::string& key, T default_value) {\r\n   ```\r\n   (not necessary if you prefer to be explicit)\n\n##########\nFile path: cpp/src/arrow/filesystem/s3fs_benchmark.cc\n##########\n@@ -146,32 +147,25 @@ class MinioFixture : public benchmark::Fixture {\n   /// Appends integer columns to the beginning (to act as indices).\n   Status MakeParquetObject(const std::string& path, int num_columns, int num_rows) {\n     std::vector<std::shared_ptr<ChunkedArray>> columns;\n-    std::vector<std::shared_ptr<Field>> fields;\n-\n-    {\n-      arrow::random::RandomArrayGenerator generator(0);\n-      std::shared_ptr<Array> values = generator.Int64(num_rows, 0, 1e10, 0);\n-      columns.push_back(std::make_shared<ChunkedArray>(values));\n-      fields.push_back(::arrow::field(\"timestamp\", values->type()));\n-    }\n-    {\n-      arrow::random::RandomArrayGenerator generator(1);\n-      std::shared_ptr<Array> values = generator.Int32(num_rows, 0, 1e9, 0);\n-      columns.push_back(std::make_shared<ChunkedArray>(values));\n-      fields.push_back(::arrow::field(\"val\", values->type()));\n-    }\n-\n+    FieldVector fields{::arrow::field(\"timestamp\", int64(), /*nullable=*/true,\n\nReview comment:\n       Nit: I think the explicit namespaces are not necessary here\r\n   ```suggestion\r\n       FieldVector fields{field(\"timestamp\", int64(), /*nullable=*/true,\r\n   ```\n\n##########\nFile path: cpp/src/arrow/testing/random_test.cc\n##########\n@@ -0,0 +1,195 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+\n+namespace arrow {\n+namespace random {\n+\n+class RandomArrayTest : public ::testing::TestWithParam<std::shared_ptr<Field>> {\n+ protected:\n+  std::shared_ptr<Field> GetField() { return GetParam(); }\n+};\n+\n+template <typename T>\n+class RandomNumericArrayTest : public ::testing::Test {\n+ protected:\n+  std::shared_ptr<Field> GetField() { return field(\"field0\", std::make_shared<T>()); }\n+\n+  std::shared_ptr<NumericArray<T>> Downcast(std::shared_ptr<Array> array) {\n+    return internal::checked_pointer_cast<NumericArray<T>>(array);\n+  }\n+};\n+\n+TEST_P(RandomArrayTest, GenerateArray) {\n+  auto field = GetField();\n+  auto batch = Generate({field}, 128, 0xDEADBEEF);\n+  AssertSchemaEqual(schema({field}), batch->schema());\n+  auto array = batch->column(0);\n+  ASSERT_EQ(128, array->length());\n+  ASSERT_OK(array->ValidateFull());\n+}\n+\n+TEST_P(RandomArrayTest, GenerateNonNullArray) {\n\nReview comment:\n       Nit: too similar to the next case's name\r\n   ```suggestion\r\n   TEST_P(RandomArrayTest, GenerateArrayWithZeroNullProbability) {\r\n   ```\n\n##########\nFile path: cpp/src/arrow/testing/random_test.cc\n##########\n@@ -0,0 +1,195 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+\n+namespace arrow {\n+namespace random {\n+\n+class RandomArrayTest : public ::testing::TestWithParam<std::shared_ptr<Field>> {\n+ protected:\n+  std::shared_ptr<Field> GetField() { return GetParam(); }\n+};\n+\n+template <typename T>\n+class RandomNumericArrayTest : public ::testing::Test {\n+ protected:\n+  std::shared_ptr<Field> GetField() { return field(\"field0\", std::make_shared<T>()); }\n+\n+  std::shared_ptr<NumericArray<T>> Downcast(std::shared_ptr<Array> array) {\n+    return internal::checked_pointer_cast<NumericArray<T>>(array);\n+  }\n+};\n+\n+TEST_P(RandomArrayTest, GenerateArray) {\n+  auto field = GetField();\n+  auto batch = Generate({field}, 128, 0xDEADBEEF);\n+  AssertSchemaEqual(schema({field}), batch->schema());\n+  auto array = batch->column(0);\n+  ASSERT_EQ(128, array->length());\n+  ASSERT_OK(array->ValidateFull());\n+}\n+\n+TEST_P(RandomArrayTest, GenerateNonNullArray) {\n+  auto field =\n+      GetField()->WithMetadata(key_value_metadata({{\"null_probability\", \"0.0\"}}));\n+  if (field->type()->id() == Type::type::NA) {\n+    GTEST_SKIP() << \"Cannot generate non-null null arrays\";\n+  }\n+  auto batch = Generate({field}, 128, 0xDEADBEEF);\n+  AssertSchemaEqual(schema({field}), batch->schema());\n+  auto array = batch->column(0);\n+  ASSERT_OK(array->ValidateFull());\n+  ASSERT_EQ(0, array->null_count());\n+}\n+\n+TEST_P(RandomArrayTest, GenerateNonNullableArray) {\n+  auto field = GetField()->WithNullable(false);\n+  if (field->type()->id() == Type::type::NA) {\n+    GTEST_SKIP() << \"Cannot generate non-null null arrays\";\n+  }\n+  auto batch = Generate({field}, 128, 0xDEADBEEF);\n+  AssertSchemaEqual(schema({field}), batch->schema());\n+  auto array = batch->column(0);\n+  ASSERT_OK(array->ValidateFull());\n+  ASSERT_EQ(0, array->null_count());\n+}\n+\n+struct FieldParamName {\n+  template <class ParamType>\n+  std::string operator()(const ::testing::TestParamInfo<ParamType>& info) const {\n+    return std::to_string(info.index) + info.param->name();\n+  }\n+};\n+\n+auto values = ::testing::Values(\n+    field(\"null\", null()), field(\"bool\", boolean()), field(\"uint8\", uint8()),\n+    field(\"int8\", int8()), field(\"uint16\", uint16()), field(\"int16\", int16()),\n+    field(\"uint32\", uint32()), field(\"int32\", int32()), field(\"uint64\", uint64()),\n+    field(\"int64\", int64()), field(\"float16\", float16()), field(\"float32\", float32()),\n+    field(\"float64\", float64()), field(\"string\", utf8()), field(\"binary\", binary()),\n+    field(\"fixed_size_binary\", fixed_size_binary(8)),\n+    field(\"decimal128\", decimal128(8, 3)), field(\"decimal256\", decimal256(16, 4)),\n+    field(\"date32\", date32()), field(\"date64\", date64()),\n+    field(\"timestampns\", timestamp(TimeUnit::NANO)),\n+    field(\"timestamps\", timestamp(TimeUnit::SECOND, \"America/Phoenix\")),\n+    field(\"time32ms\", time32(TimeUnit::MILLI)), field(\"time64ns\", time64(TimeUnit::NANO)),\n+    field(\"time32s\", time32(TimeUnit::SECOND)),\n+    field(\"time64us\", time64(TimeUnit::MICRO)), field(\"month_interval\", month_interval()),\n+    field(\"daytime_interval\", day_time_interval()), field(\"listint8\", list(int8())),\n+    field(\"listlistint8\", list(list(int8()))),\n+    field(\"listint8emptynulls\", list(int8()), true,\n+          key_value_metadata({{\"force_empty_nulls\", \"true\"}})),\n+    field(\"listint81024values\", list(int8()), true,\n+          key_value_metadata({{\"values\", \"1024\"}})),\n+    field(\"structints\", struct_({\n+                            field(\"int8\", int8()),\n+                            field(\"int16\", int16()),\n+                            field(\"int32\", int32()),\n+                        })),\n+    field(\"structnested\", struct_({\n+                              field(\"string\", utf8()),\n+                              field(\"list\", list(int64())),\n+                              field(\"timestamp\", timestamp(TimeUnit::MILLI)),\n+                          })),\n+    field(\"sparseunion\", sparse_union({\n+                             field(\"int8\", int8()),\n+                             field(\"int16\", int16()),\n+                             field(\"int32\", int32()),\n+                         })),\n+    field(\"denseunion\", dense_union({\n+                            field(\"int8\", int8()),\n+                            field(\"int16\", int16()),\n+                            field(\"int32\", int32()),\n+                        })),\n+    field(\"dictionary\", dictionary(int8(), utf8())), field(\"map\", map(int8(), utf8())),\n+    field(\"fixedsizelist\", fixed_size_list(int8(), 4)),\n+    field(\"durationns\", duration(TimeUnit::NANO)), field(\"largestring\", large_utf8()),\n+    field(\"largebinary\", large_binary()),\n+    field(\"largelistlistint8\", large_list(list(int8()))));\n+\n+INSTANTIATE_TEST_SUITE_P(\n+    TestRandomArrayGeneration, RandomArrayTest, values,\n+    [](const ::testing::TestParamInfo<RandomArrayTest::ParamType>& info) {\n+      return std::to_string(info.index) + info.param->name();\n+    });\n+\n+using NumericTypes =\n+    ::testing::Types<UInt8Type, Int8Type, UInt16Type, Int16Type, UInt32Type, Int32Type,\n+                     HalfFloatType, FloatType, DoubleType>;\n+TYPED_TEST_SUITE(RandomNumericArrayTest, NumericTypes);\n+\n+TYPED_TEST(RandomNumericArrayTest, GenerateMinMax) {\n+  auto field = this->GetField()->WithMetadata(\n+      key_value_metadata({{\"min\", \"0\"}, {\"max\", \"127\"}, {\"nan_probability\", \"0.0\"}}));\n+  auto batch = Generate({field}, 128, 0xDEADBEEF);\n+  AssertSchemaEqual(schema({field}), batch->schema());\n+  auto array = this->Downcast(batch->column(0));\n+  auto it = array->begin();\n+  while (it != array->end()) {\n+    if ((*it).has_value()) {\n+      ASSERT_GE(**it, typename TypeParam::c_type(0));\n+      ASSERT_LE(**it, typename TypeParam::c_type(127));\n+    }\n+    it++;\n+  }\n\nReview comment:\n       You can use range-for and I believe `optional` supports direct comparison\r\n   ```suggestion\r\n     for (auto slot : *array) {\r\n       if (!slot.has_value()) continue;\r\n       ASSERT_GE(slot, 0);\r\n       ASSERT_LE(slot, 127);\r\n     }\r\n   ```\n\n##########\nFile path: cpp/src/arrow/testing/random.h\n##########\n@@ -358,6 +362,10 @@ class ARROW_TESTING_EXPORT RandomArrayGenerator {\n   std::default_random_engine seed_rng_;\n };\n \n\nReview comment:\n       This function warrants a sprawling docstring.\n\n##########\nFile path: cpp/src/arrow/testing/random.cc\n##########\n@@ -558,5 +584,248 @@ std::shared_ptr<Array> RandomArrayGenerator::ArrayOf(std::shared_ptr<DataType> t\n   return RandomArrayGeneratorOfImpl{this, type, size, null_probability, nullptr}.Finish();\n }\n \n+namespace {\n+template <typename T>\n+typename T::c_type GetMetadata(const KeyValueMetadata* metadata, const std::string& key,\n+                               typename T::c_type default_value) {\n+  if (!metadata) return default_value;\n+  const auto index = metadata->FindKey(key);\n+  if (index < 0) return default_value;\n+  const auto& value = metadata->value(index);\n+  typename T::c_type output{};\n+  auto type = checked_pointer_cast<T>(TypeTraits<T>::type_singleton());\n+  if (!internal::ParseValue(*type, value.data(), value.length(), &output)) {\n+    ABORT_NOT_OK(Status::Invalid(\"Could not parse \", key, \" = \", value));\n\nReview comment:\n       ```suggestion\r\n     T output{};\r\n     if (!internal::ParseValue<ArrowType>(value.data(), value.length(), &output)) {\r\n       ABORT_NOT_OK(Status::Invalid(\"Could not parse \", key, \" = \", value));\r\n   ```\n\n##########\nFile path: cpp/src/arrow/testing/random_test.cc\n##########\n@@ -0,0 +1,195 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+\n+namespace arrow {\n+namespace random {\n+\n+class RandomArrayTest : public ::testing::TestWithParam<std::shared_ptr<Field>> {\n+ protected:\n+  std::shared_ptr<Field> GetField() { return GetParam(); }\n+};\n+\n+template <typename T>\n+class RandomNumericArrayTest : public ::testing::Test {\n+ protected:\n+  std::shared_ptr<Field> GetField() { return field(\"field0\", std::make_shared<T>()); }\n+\n+  std::shared_ptr<NumericArray<T>> Downcast(std::shared_ptr<Array> array) {\n+    return internal::checked_pointer_cast<NumericArray<T>>(array);\n+  }\n+};\n+\n+TEST_P(RandomArrayTest, GenerateArray) {\n+  auto field = GetField();\n+  auto batch = Generate({field}, 128, 0xDEADBEEF);\n+  AssertSchemaEqual(schema({field}), batch->schema());\n+  auto array = batch->column(0);\n+  ASSERT_EQ(128, array->length());\n+  ASSERT_OK(array->ValidateFull());\n+}\n+\n+TEST_P(RandomArrayTest, GenerateNonNullArray) {\n+  auto field =\n+      GetField()->WithMetadata(key_value_metadata({{\"null_probability\", \"0.0\"}}));\n+  if (field->type()->id() == Type::type::NA) {\n+    GTEST_SKIP() << \"Cannot generate non-null null arrays\";\n+  }\n+  auto batch = Generate({field}, 128, 0xDEADBEEF);\n+  AssertSchemaEqual(schema({field}), batch->schema());\n+  auto array = batch->column(0);\n+  ASSERT_OK(array->ValidateFull());\n+  ASSERT_EQ(0, array->null_count());\n+}\n+\n+TEST_P(RandomArrayTest, GenerateNonNullableArray) {\n+  auto field = GetField()->WithNullable(false);\n+  if (field->type()->id() == Type::type::NA) {\n+    GTEST_SKIP() << \"Cannot generate non-null null arrays\";\n+  }\n+  auto batch = Generate({field}, 128, 0xDEADBEEF);\n+  AssertSchemaEqual(schema({field}), batch->schema());\n+  auto array = batch->column(0);\n+  ASSERT_OK(array->ValidateFull());\n+  ASSERT_EQ(0, array->null_count());\n+}\n+\n+struct FieldParamName {\n+  template <class ParamType>\n+  std::string operator()(const ::testing::TestParamInfo<ParamType>& info) const {\n+    return std::to_string(info.index) + info.param->name();\n+  }\n+};\n+\n+auto values = ::testing::Values(\n+    field(\"null\", null()), field(\"bool\", boolean()), field(\"uint8\", uint8()),\n+    field(\"int8\", int8()), field(\"uint16\", uint16()), field(\"int16\", int16()),\n+    field(\"uint32\", uint32()), field(\"int32\", int32()), field(\"uint64\", uint64()),\n+    field(\"int64\", int64()), field(\"float16\", float16()), field(\"float32\", float32()),\n+    field(\"float64\", float64()), field(\"string\", utf8()), field(\"binary\", binary()),\n+    field(\"fixed_size_binary\", fixed_size_binary(8)),\n+    field(\"decimal128\", decimal128(8, 3)), field(\"decimal256\", decimal256(16, 4)),\n+    field(\"date32\", date32()), field(\"date64\", date64()),\n+    field(\"timestampns\", timestamp(TimeUnit::NANO)),\n+    field(\"timestamps\", timestamp(TimeUnit::SECOND, \"America/Phoenix\")),\n+    field(\"time32ms\", time32(TimeUnit::MILLI)), field(\"time64ns\", time64(TimeUnit::NANO)),\n+    field(\"time32s\", time32(TimeUnit::SECOND)),\n+    field(\"time64us\", time64(TimeUnit::MICRO)), field(\"month_interval\", month_interval()),\n+    field(\"daytime_interval\", day_time_interval()), field(\"listint8\", list(int8())),\n+    field(\"listlistint8\", list(list(int8()))),\n+    field(\"listint8emptynulls\", list(int8()), true,\n+          key_value_metadata({{\"force_empty_nulls\", \"true\"}})),\n+    field(\"listint81024values\", list(int8()), true,\n+          key_value_metadata({{\"values\", \"1024\"}})),\n+    field(\"structints\", struct_({\n+                            field(\"int8\", int8()),\n+                            field(\"int16\", int16()),\n+                            field(\"int32\", int32()),\n+                        })),\n+    field(\"structnested\", struct_({\n+                              field(\"string\", utf8()),\n+                              field(\"list\", list(int64())),\n+                              field(\"timestamp\", timestamp(TimeUnit::MILLI)),\n+                          })),\n+    field(\"sparseunion\", sparse_union({\n+                             field(\"int8\", int8()),\n+                             field(\"int16\", int16()),\n+                             field(\"int32\", int32()),\n+                         })),\n+    field(\"denseunion\", dense_union({\n+                            field(\"int8\", int8()),\n+                            field(\"int16\", int16()),\n+                            field(\"int32\", int32()),\n+                        })),\n+    field(\"dictionary\", dictionary(int8(), utf8())), field(\"map\", map(int8(), utf8())),\n+    field(\"fixedsizelist\", fixed_size_list(int8(), 4)),\n+    field(\"durationns\", duration(TimeUnit::NANO)), field(\"largestring\", large_utf8()),\n+    field(\"largebinary\", large_binary()),\n+    field(\"largelistlistint8\", large_list(list(int8()))));\n+\n+INSTANTIATE_TEST_SUITE_P(\n+    TestRandomArrayGeneration, RandomArrayTest, values,\n+    [](const ::testing::TestParamInfo<RandomArrayTest::ParamType>& info) {\n+      return std::to_string(info.index) + info.param->name();\n+    });\n+\n+using NumericTypes =\n+    ::testing::Types<UInt8Type, Int8Type, UInt16Type, Int16Type, UInt32Type, Int32Type,\n+                     HalfFloatType, FloatType, DoubleType>;\n+TYPED_TEST_SUITE(RandomNumericArrayTest, NumericTypes);\n+\n+TYPED_TEST(RandomNumericArrayTest, GenerateMinMax) {\n+  auto field = this->GetField()->WithMetadata(\n+      key_value_metadata({{\"min\", \"0\"}, {\"max\", \"127\"}, {\"nan_probability\", \"0.0\"}}));\n+  auto batch = Generate({field}, 128, 0xDEADBEEF);\n+  AssertSchemaEqual(schema({field}), batch->schema());\n+  auto array = this->Downcast(batch->column(0));\n+  auto it = array->begin();\n+  while (it != array->end()) {\n+    if ((*it).has_value()) {\n+      ASSERT_GE(**it, typename TypeParam::c_type(0));\n+      ASSERT_LE(**it, typename TypeParam::c_type(127));\n+    }\n+    it++;\n+  }\n+}\n+\n+TEST(TypeSpecificTests, FloatNan) {\n+  auto field = arrow::field(\"float32\", float32())\n+                   ->WithMetadata(key_value_metadata({{\"nan_probability\", \"1.0\"}}));\n+  auto batch = Generate({field}, 128, 0xDEADBEEF);\n+  AssertSchemaEqual(schema({field}), batch->schema());\n+  auto array = internal::checked_pointer_cast<NumericArray<FloatType>>(batch->column(0));\n+  auto it = array->begin();\n+  while (it != array->end()) {\n+    if ((*it).has_value()) {\n+      ASSERT_TRUE(std::isnan(**it));\n+    }\n+    it++;\n+  }\n+}\n+\n+TEST(TypeSpecificTests, RepeatedStrings) {\n+  auto field =\n+      arrow::field(\"string\", utf8())->WithMetadata(key_value_metadata({{\"unique\", \"1\"}}));\n+  auto batch = Generate({field}, 128, 0xDEADBEEF);\n+  AssertSchemaEqual(schema({field}), batch->schema());\n+  auto array = internal::checked_pointer_cast<StringArray>(batch->column(0));\n+  auto it = array->begin();\n+  util::optional<util::string_view> singular_value;\n+  while (it != array->end()) {\n+    if ((*it).has_value()) {\n+      if (!singular_value.has_value()) {\n+        singular_value = *it;\n+      } else {\n+        ASSERT_EQ(*singular_value, **it);\n+      }\n+    }\n+    it++;\n+  }\n+}\n+\n\nReview comment:\n       There are numerous untested options, please ensure each recognized metadata key is hit at least once\n\n##########\nFile path: cpp/src/arrow/testing/random_test.cc\n##########\n@@ -0,0 +1,195 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+\n+namespace arrow {\n+namespace random {\n+\n+class RandomArrayTest : public ::testing::TestWithParam<std::shared_ptr<Field>> {\n+ protected:\n+  std::shared_ptr<Field> GetField() { return GetParam(); }\n+};\n+\n+template <typename T>\n+class RandomNumericArrayTest : public ::testing::Test {\n+ protected:\n+  std::shared_ptr<Field> GetField() { return field(\"field0\", std::make_shared<T>()); }\n+\n+  std::shared_ptr<NumericArray<T>> Downcast(std::shared_ptr<Array> array) {\n+    return internal::checked_pointer_cast<NumericArray<T>>(array);\n+  }\n+};\n+\n+TEST_P(RandomArrayTest, GenerateArray) {\n+  auto field = GetField();\n+  auto batch = Generate({field}, 128, 0xDEADBEEF);\n+  AssertSchemaEqual(schema({field}), batch->schema());\n+  auto array = batch->column(0);\n+  ASSERT_EQ(128, array->length());\n+  ASSERT_OK(array->ValidateFull());\n+}\n+\n+TEST_P(RandomArrayTest, GenerateNonNullArray) {\n+  auto field =\n+      GetField()->WithMetadata(key_value_metadata({{\"null_probability\", \"0.0\"}}));\n+  if (field->type()->id() == Type::type::NA) {\n+    GTEST_SKIP() << \"Cannot generate non-null null arrays\";\n+  }\n+  auto batch = Generate({field}, 128, 0xDEADBEEF);\n+  AssertSchemaEqual(schema({field}), batch->schema());\n+  auto array = batch->column(0);\n+  ASSERT_OK(array->ValidateFull());\n+  ASSERT_EQ(0, array->null_count());\n+}\n+\n+TEST_P(RandomArrayTest, GenerateNonNullableArray) {\n+  auto field = GetField()->WithNullable(false);\n+  if (field->type()->id() == Type::type::NA) {\n+    GTEST_SKIP() << \"Cannot generate non-null null arrays\";\n+  }\n+  auto batch = Generate({field}, 128, 0xDEADBEEF);\n+  AssertSchemaEqual(schema({field}), batch->schema());\n+  auto array = batch->column(0);\n+  ASSERT_OK(array->ValidateFull());\n+  ASSERT_EQ(0, array->null_count());\n+}\n+\n+struct FieldParamName {\n+  template <class ParamType>\n+  std::string operator()(const ::testing::TestParamInfo<ParamType>& info) const {\n+    return std::to_string(info.index) + info.param->name();\n+  }\n+};\n\nReview comment:\n       Looks like you replaced this with a lambda?\r\n   ```suggestion\r\n   ```\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-17T14:35:20.804+0000",
                    "updated": "2021-03-17T14:35:20.804+0000",
                    "started": "2021-03-17T14:35:20.804+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "567707",
                    "issueId": "13360364"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360364/worklog/567713",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #9715:\nURL: https://github.com/apache/arrow/pull/9715#discussion_r596084830\n\n\n\n##########\nFile path: cpp/src/arrow/testing/random.h\n##########\n@@ -358,6 +362,10 @@ class ARROW_TESTING_EXPORT RandomArrayGenerator {\n   std::default_random_engine seed_rng_;\n };\n \n+ARROW_TESTING_EXPORT\n+std::shared_ptr<arrow::RecordBatch> Generate(const FieldVector& fields, int64_t size,\n\nReview comment:\n       Might it be better to just allow passing an explicit schema instead?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-17T14:44:17.084+0000",
                    "updated": "2021-03-17T14:44:17.084+0000",
                    "started": "2021-03-17T14:44:17.084+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "567713",
                    "issueId": "13360364"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360364/worklog/567715",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #9715:\nURL: https://github.com/apache/arrow/pull/9715#discussion_r596085481\n\n\n\n##########\nFile path: cpp/src/arrow/testing/random.h\n##########\n@@ -358,6 +362,10 @@ class ARROW_TESTING_EXPORT RandomArrayGenerator {\n   std::default_random_engine seed_rng_;\n };\n \n+ARROW_TESTING_EXPORT\n+std::shared_ptr<arrow::RecordBatch> Generate(const FieldVector& fields, int64_t size,\n+                                             SeedType seed);\n\nReview comment:\n       I am not particularly for magic like that. But maybe we could make Generate{Batch,Table,Array,...} methods of Generator to allow them to share a seed?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-17T14:45:03.320+0000",
                    "updated": "2021-03-17T14:45:03.320+0000",
                    "started": "2021-03-17T14:45:03.320+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "567715",
                    "issueId": "13360364"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360364/worklog/567716",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #9715:\nURL: https://github.com/apache/arrow/pull/9715#discussion_r596086831\n\n\n\n##########\nFile path: cpp/src/arrow/testing/random.cc\n##########\n@@ -558,5 +584,248 @@ std::shared_ptr<Array> RandomArrayGenerator::ArrayOf(std::shared_ptr<DataType> t\n   return RandomArrayGeneratorOfImpl{this, type, size, null_probability, nullptr}.Finish();\n }\n \n+namespace {\n+template <typename T>\n+typename T::c_type GetMetadata(const KeyValueMetadata* metadata, const std::string& key,\n+                               typename T::c_type default_value) {\n+  if (!metadata) return default_value;\n+  const auto index = metadata->FindKey(key);\n+  if (index < 0) return default_value;\n+  const auto& value = metadata->value(index);\n+  typename T::c_type output{};\n+  auto type = checked_pointer_cast<T>(TypeTraits<T>::type_singleton());\n+  if (!internal::ParseValue(*type, value.data(), value.length(), &output)) {\n+    ABORT_NOT_OK(Status::Invalid(\"Could not parse \", key, \" = \", value));\n+  }\n+  return output;\n+}\n+\n+Result<std::shared_ptr<Array>> GenerateArray(const Field& field, int64_t length,\n+                                             RandomArrayGenerator* generator) {\n+#define GENERATE_INTEGRAL_CASE_VIEW(BASE_TYPE, VIEW_TYPE)                                \\\n+  case VIEW_TYPE::type_id: {                                                             \\\n+    const BASE_TYPE::c_type min_value = GetMetadata<BASE_TYPE>(                          \\\n+        field.metadata().get(), \"min\", std::numeric_limits<BASE_TYPE::c_type>::min());   \\\n+    const BASE_TYPE::c_type max_value = GetMetadata<BASE_TYPE>(                          \\\n+        field.metadata().get(), \"max\", std::numeric_limits<BASE_TYPE::c_type>::max());   \\\n+    return generator->Numeric<BASE_TYPE>(length, min_value, max_value, null_probability) \\\n+        ->View(field.type());                                                            \\\n+  }\n+#define GENERATE_INTEGRAL_CASE(ARROW_TYPE) \\\n+  GENERATE_INTEGRAL_CASE_VIEW(ARROW_TYPE, ARROW_TYPE)\n+#define GENERATE_FLOATING_CASE(ARROW_TYPE, GENERATOR_FUNC)                              \\\n+  case ARROW_TYPE::type_id: {                                                           \\\n+    const ARROW_TYPE::c_type min_value = GetMetadata<ARROW_TYPE>(                       \\\n+        field.metadata().get(), \"min\", std::numeric_limits<ARROW_TYPE::c_type>::min()); \\\n+    const ARROW_TYPE::c_type max_value = GetMetadata<ARROW_TYPE>(                       \\\n+        field.metadata().get(), \"max\", std::numeric_limits<ARROW_TYPE::c_type>::max()); \\\n+    const double nan_probability =                                                      \\\n+        GetMetadata<DoubleType>(field.metadata().get(), \"nan_probability\", 0);          \\\n+    return generator->GENERATOR_FUNC(length, min_value, max_value, null_probability,    \\\n+                                     nan_probability);                                  \\\n+  }\n+\n+  const double null_probability =\n+      field.nullable()\n+          ? GetMetadata<DoubleType>(field.metadata().get(), \"null_probability\", 0.01)\n+          : 0.0;\n+  switch (field.type()->id()) {\n+    case Type::type::NA:\n\nReview comment:\n       Yeah, I will add more validation for these things - I also noticed that a null_probability outside [0,1] on MSVC leads to runtime errors (which do not appear to apply to GCC).\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-17T14:46:26.575+0000",
                    "updated": "2021-03-17T14:46:26.575+0000",
                    "started": "2021-03-17T14:46:26.575+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "567716",
                    "issueId": "13360364"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360364/worklog/567719",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #9715:\nURL: https://github.com/apache/arrow/pull/9715#discussion_r596087724\n\n\n\n##########\nFile path: cpp/src/arrow/testing/random.cc\n##########\n@@ -558,5 +584,248 @@ std::shared_ptr<Array> RandomArrayGenerator::ArrayOf(std::shared_ptr<DataType> t\n   return RandomArrayGeneratorOfImpl{this, type, size, null_probability, nullptr}.Finish();\n }\n \n+namespace {\n+template <typename T>\n+typename T::c_type GetMetadata(const KeyValueMetadata* metadata, const std::string& key,\n+                               typename T::c_type default_value) {\n+  if (!metadata) return default_value;\n+  const auto index = metadata->FindKey(key);\n+  if (index < 0) return default_value;\n+  const auto& value = metadata->value(index);\n+  typename T::c_type output{};\n+  auto type = checked_pointer_cast<T>(TypeTraits<T>::type_singleton());\n+  if (!internal::ParseValue(*type, value.data(), value.length(), &output)) {\n+    ABORT_NOT_OK(Status::Invalid(\"Could not parse \", key, \" = \", value));\n+  }\n+  return output;\n+}\n+\n+Result<std::shared_ptr<Array>> GenerateArray(const Field& field, int64_t length,\n+                                             RandomArrayGenerator* generator) {\n+#define GENERATE_INTEGRAL_CASE_VIEW(BASE_TYPE, VIEW_TYPE)                                \\\n+  case VIEW_TYPE::type_id: {                                                             \\\n+    const BASE_TYPE::c_type min_value = GetMetadata<BASE_TYPE>(                          \\\n+        field.metadata().get(), \"min\", std::numeric_limits<BASE_TYPE::c_type>::min());   \\\n+    const BASE_TYPE::c_type max_value = GetMetadata<BASE_TYPE>(                          \\\n+        field.metadata().get(), \"max\", std::numeric_limits<BASE_TYPE::c_type>::max());   \\\n+    return generator->Numeric<BASE_TYPE>(length, min_value, max_value, null_probability) \\\n+        ->View(field.type());                                                            \\\n+  }\n+#define GENERATE_INTEGRAL_CASE(ARROW_TYPE) \\\n+  GENERATE_INTEGRAL_CASE_VIEW(ARROW_TYPE, ARROW_TYPE)\n+#define GENERATE_FLOATING_CASE(ARROW_TYPE, GENERATOR_FUNC)                              \\\n+  case ARROW_TYPE::type_id: {                                                           \\\n+    const ARROW_TYPE::c_type min_value = GetMetadata<ARROW_TYPE>(                       \\\n+        field.metadata().get(), \"min\", std::numeric_limits<ARROW_TYPE::c_type>::min()); \\\n+    const ARROW_TYPE::c_type max_value = GetMetadata<ARROW_TYPE>(                       \\\n+        field.metadata().get(), \"max\", std::numeric_limits<ARROW_TYPE::c_type>::max()); \\\n+    const double nan_probability =                                                      \\\n+        GetMetadata<DoubleType>(field.metadata().get(), \"nan_probability\", 0);          \\\n+    return generator->GENERATOR_FUNC(length, min_value, max_value, null_probability,    \\\n+                                     nan_probability);                                  \\\n+  }\n+\n+  const double null_probability =\n+      field.nullable()\n+          ? GetMetadata<DoubleType>(field.metadata().get(), \"null_probability\", 0.01)\n+          : 0.0;\n+  switch (field.type()->id()) {\n+    case Type::type::NA:\n+      return std::make_shared<NullArray>(length);\n+\n+    case Type::type::BOOL: {\n+      const double true_probability =\n+          GetMetadata<DoubleType>(field.metadata().get(), \"true_probability\", 0.5);\n+      return generator->Boolean(length, true_probability, null_probability);\n+    }\n+\n+      GENERATE_INTEGRAL_CASE(UInt8Type);\n+      GENERATE_INTEGRAL_CASE(Int8Type);\n+      GENERATE_INTEGRAL_CASE(UInt16Type);\n+      GENERATE_INTEGRAL_CASE(Int16Type);\n+      GENERATE_INTEGRAL_CASE(UInt32Type);\n+      GENERATE_INTEGRAL_CASE(Int32Type);\n+      GENERATE_INTEGRAL_CASE(UInt64Type);\n+      GENERATE_INTEGRAL_CASE(Int64Type);\n+      GENERATE_INTEGRAL_CASE_VIEW(Int16Type, HalfFloatType);\n+      GENERATE_FLOATING_CASE(FloatType, Float32);\n+      GENERATE_FLOATING_CASE(DoubleType, Float64);\n+\n+    case Type::type::STRING:\n+    case Type::type::BINARY: {\n+      const int32_t min_length = GetMetadata<Int32Type>(field.metadata().get(), \"min\", 0);\n+      const int32_t max_length =\n+          GetMetadata<Int32Type>(field.metadata().get(), \"max\", 1024);\n+      const int32_t unique_values =\n+          GetMetadata<Int32Type>(field.metadata().get(), \"unique\", -1);\n+      if (unique_values > 0) {\n+        return generator\n+            ->StringWithRepeats(length, unique_values, min_length, max_length,\n+                                null_probability)\n+            ->View(field.type());\n+      }\n+      return generator->String(length, min_length, max_length, null_probability)\n+          ->View(field.type());\n+    }\n+\n+    case Type::type::DECIMAL128:\n+    case Type::type::DECIMAL256:\n+    case Type::type::FIXED_SIZE_BINARY: {\n+      auto byte_width =\n+          internal::checked_pointer_cast<FixedSizeBinaryType>(field.type())->byte_width();\n+      return generator->FixedSizeBinary(length, byte_width, null_probability)\n+          ->View(field.type());\n+    }\n+\n+      GENERATE_INTEGRAL_CASE_VIEW(Int32Type, Date32Type);\n+      GENERATE_INTEGRAL_CASE_VIEW(Int64Type, Date64Type);\n+      GENERATE_INTEGRAL_CASE_VIEW(Int64Type, TimestampType);\n+      GENERATE_INTEGRAL_CASE_VIEW(Int32Type, Time32Type);\n+      GENERATE_INTEGRAL_CASE_VIEW(Int64Type, Time64Type);\n+      GENERATE_INTEGRAL_CASE_VIEW(Int32Type, MonthIntervalType);\n+\n+      // This isn't as flexible as it could be, but the array-of-structs layout of this\n+      // type means it's not a (useful) composition of other generators\n+      GENERATE_INTEGRAL_CASE_VIEW(Int64Type, DayTimeIntervalType);\n+\n+    case Type::type::LIST: {\n+      const int32_t values_length = GetMetadata<Int32Type>(\n+          field.metadata().get(), \"values\", static_cast<int32_t>(length));\n\nReview comment:\n       I was mostly mirroring the existing generator functions which presented different APIs, but I'll see if I can't consolidate the cases further for list/string and their large variants. (And maybe then map can delegate to the list case.)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-17T14:47:31.828+0000",
                    "updated": "2021-03-17T14:47:31.828+0000",
                    "started": "2021-03-17T14:47:31.828+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "567719",
                    "issueId": "13360364"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360364/worklog/567720",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #9715:\nURL: https://github.com/apache/arrow/pull/9715#discussion_r596088841\n\n\n\n##########\nFile path: cpp/src/arrow/testing/random.cc\n##########\n@@ -558,5 +584,248 @@ std::shared_ptr<Array> RandomArrayGenerator::ArrayOf(std::shared_ptr<DataType> t\n   return RandomArrayGeneratorOfImpl{this, type, size, null_probability, nullptr}.Finish();\n }\n \n+namespace {\n+template <typename T>\n+typename T::c_type GetMetadata(const KeyValueMetadata* metadata, const std::string& key,\n+                               typename T::c_type default_value) {\n\nReview comment:\n       Nice, I admit I'm not as up to speed on my template metaprogramming as I'd like to be.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-17T14:48:44.789+0000",
                    "updated": "2021-03-17T14:48:44.789+0000",
                    "started": "2021-03-17T14:48:44.789+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "567720",
                    "issueId": "13360364"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360364/worklog/568493",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #9715:\nURL: https://github.com/apache/arrow/pull/9715#discussion_r597071913\n\n\n\n##########\nFile path: cpp/src/arrow/filesystem/s3fs_benchmark.cc\n##########\n@@ -146,32 +147,25 @@ class MinioFixture : public benchmark::Fixture {\n   /// Appends integer columns to the beginning (to act as indices).\n   Status MakeParquetObject(const std::string& path, int num_columns, int num_rows) {\n     std::vector<std::shared_ptr<ChunkedArray>> columns;\n-    std::vector<std::shared_ptr<Field>> fields;\n-\n-    {\n-      arrow::random::RandomArrayGenerator generator(0);\n-      std::shared_ptr<Array> values = generator.Int64(num_rows, 0, 1e10, 0);\n-      columns.push_back(std::make_shared<ChunkedArray>(values));\n-      fields.push_back(::arrow::field(\"timestamp\", values->type()));\n-    }\n-    {\n-      arrow::random::RandomArrayGenerator generator(1);\n-      std::shared_ptr<Array> values = generator.Int32(num_rows, 0, 1e9, 0);\n-      columns.push_back(std::make_shared<ChunkedArray>(values));\n-      fields.push_back(::arrow::field(\"val\", values->type()));\n-    }\n-\n+    FieldVector fields{\n+        field(\"timestamp\", int64(), /*nullable=*/true,\n+              key_value_metadata(\n+                  {{\"min\", \"0\"}, {\"max\", \"10000000000\"}, {\"null_probability\", \"0\"}})),\n+        ::arrow::field(\n\nReview comment:\n       ```suggestion\r\n           field(\r\n   ```\n\n##########\nFile path: cpp/src/arrow/testing/random.h\n##########\n@@ -358,6 +362,59 @@ class ARROW_TESTING_EXPORT RandomArrayGenerator {\n   std::default_random_engine seed_rng_;\n };\n \n+/// Generate a record batch with random data of the specified length.\n\nReview comment:\n       :+1: \n\n##########\nFile path: cpp/src/arrow/testing/random.h\n##########\n@@ -358,6 +362,59 @@ class ARROW_TESTING_EXPORT RandomArrayGenerator {\n   std::default_random_engine seed_rng_;\n };\n \n+/// Generate a record batch with random data of the specified length.\n+///\n+/// Generation options are read from key-value metadata for each field. Options\n+/// are applied recursively, e.g. for list(field(int8())), metadata of the child\n+/// field will be used when generating child values.\n\nReview comment:\n       ```suggestion\r\n   /// Generation options are read from key-value metadata for each field, and may be\r\n   /// specified at any nesting level. For example, generation options for the child values\r\n   /// of a list array can be specified by constructing the list type with\r\n   /// list(field(\"item\", int8(), options_metadata))\r\n   ```\n\n##########\nFile path: cpp/src/arrow/filesystem/s3fs_benchmark.cc\n##########\n@@ -146,32 +147,25 @@ class MinioFixture : public benchmark::Fixture {\n   /// Appends integer columns to the beginning (to act as indices).\n   Status MakeParquetObject(const std::string& path, int num_columns, int num_rows) {\n     std::vector<std::shared_ptr<ChunkedArray>> columns;\n-    std::vector<std::shared_ptr<Field>> fields;\n-\n-    {\n-      arrow::random::RandomArrayGenerator generator(0);\n-      std::shared_ptr<Array> values = generator.Int64(num_rows, 0, 1e10, 0);\n-      columns.push_back(std::make_shared<ChunkedArray>(values));\n-      fields.push_back(::arrow::field(\"timestamp\", values->type()));\n-    }\n-    {\n-      arrow::random::RandomArrayGenerator generator(1);\n-      std::shared_ptr<Array> values = generator.Int32(num_rows, 0, 1e9, 0);\n-      columns.push_back(std::make_shared<ChunkedArray>(values));\n-      fields.push_back(::arrow::field(\"val\", values->type()));\n-    }\n-\n+    FieldVector fields{\n+        field(\"timestamp\", int64(), /*nullable=*/true,\n+              key_value_metadata(\n+                  {{\"min\", \"0\"}, {\"max\", \"10000000000\"}, {\"null_probability\", \"0\"}})),\n+        ::arrow::field(\n+            \"val\", int32(), /*nullable=*/true,\n+            key_value_metadata(\n+                {{\"min\", \"0\"}, {\"max\", \"1000000000\"}, {\"null_probability\", \"0\"}}))};\n     for (int i = 0; i < num_columns; i++) {\n-      arrow::random::RandomArrayGenerator generator(i);\n-      std::shared_ptr<Array> values = generator.Float64(num_rows, -1.e10, 1e10, 0);\n       std::stringstream ss;\n       ss << \"col\" << i;\n-      columns.push_back(std::make_shared<ChunkedArray>(values));\n-      fields.push_back(::arrow::field(ss.str(), values->type()));\n+      fields.push_back(::arrow::field(\n\nReview comment:\n       ```suggestion\r\n         fields.push_back(field(\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-18T17:02:50.183+0000",
                    "updated": "2021-03-18T17:02:50.183+0000",
                    "started": "2021-03-18T17:02:50.183+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "568493",
                    "issueId": "13360364"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360364/worklog/568496",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #9715:\nURL: https://github.com/apache/arrow/pull/9715#discussion_r597074339\n\n\n\n##########\nFile path: cpp/src/arrow/testing/random.h\n##########\n@@ -358,6 +362,10 @@ class ARROW_TESTING_EXPORT RandomArrayGenerator {\n   std::default_random_engine seed_rng_;\n };\n \n+ARROW_TESTING_EXPORT\n+std::shared_ptr<arrow::RecordBatch> Generate(const FieldVector& fields, int64_t size,\n+                                             SeedType seed);\n\nReview comment:\n       SGTM. The explicit seed argument isn't the end of the world either; feel free to leave it\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-18T17:03:31.236+0000",
                    "updated": "2021-03-18T17:03:31.236+0000",
                    "started": "2021-03-18T17:03:31.236+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "568496",
                    "issueId": "13360364"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360364/worklog/568985",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz closed pull request #9715:\nURL: https://github.com/apache/arrow/pull/9715\n\n\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-19T15:53:09.025+0000",
                    "updated": "2021-03-19T15:53:09.025+0000",
                    "started": "2021-03-19T15:53:09.025+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "568985",
                    "issueId": "13360364"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360364/worklog/569303",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #9715:\nURL: https://github.com/apache/arrow/pull/9715#issuecomment-803497194\n\n\n   Any plans of applying this to parquet roundtrip tests?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-21T01:38:19.247+0000",
                    "updated": "2021-03-21T01:38:19.247+0000",
                    "started": "2021-03-21T01:38:19.247+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "569303",
                    "issueId": "13360364"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360364/worklog/569660",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #9715:\nURL: https://github.com/apache/arrow/pull/9715#issuecomment-804011421\n\n\n   @emkornfield could be done, did you want to file a JIRA for that? (Looks like the current tests all use hardcoded data?)\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-22T12:05:20.000+0000",
                    "updated": "2021-03-22T12:05:20.000+0000",
                    "started": "2021-03-22T12:05:20.000+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "569660",
                    "issueId": "13360364"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 7800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@78016c22[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@421aa602[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@683ce707[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@7f8176b4[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@31bc8c56[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@55367c45[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5abdad3b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@2e7d540e[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7b76b3ab[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@1d442cd4[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2aa78e32[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@6ebe724c[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 7800,
        "customfield_12312520": null,
        "customfield_12312521": "Fri Mar 19 15:53:03 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-03-19T15:53:03.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11745/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2021-02-23T15:46:55.000+0000",
        "updated": "2021-04-06T16:59:25.000+0000",
        "timeoriginalestimate": null,
        "description": "{{arrow::random::RandomArrayGenerator}} is useful for stress testing and benchmarking. Arrays of primitives can be generated with little boilerplate, however it is cumbersome to specify creation of nested arrays or record batches which are necessary for testing $n column operations such as group_by.\r\n\r\nMy ideal API for random generation takes only a FieldVector, a number of rows, and a seed as arguments. Other options (such as minimum, maximum, unique count, null probability, etc) are specified using field metadata so that they can be provided uniformly or granularly as necessary for a given test case:\r\n{code:c++}\r\nauto random_batch = Generate({\r\n  field(\"i32\", int32()), // i32 may take any value between INT_MAX and INT_MIN\r\n                         // and will be null with default probability 0.01\r\n  field(\"f32\", float32(), false), // f32 will be entirely valid\r\n  field(\"probability\", float64(), true, key_value_metadata({\r\n    // custom random generation properties:\r\n    {\"min\", \"0.0\"},\r\n    {\"max\", \"1.0\"},\r\n    {\"null_probability\", \"0.0001\"},\r\n  }),\r\n  field(\"list_i32\", list(\r\n    field(\"item\", int32(), true, key_value_metadata({\r\n      // custom random generation properties can also be specified for nested fields:\r\n      {\"min\", \"0\"},\r\n      {\"max\", \"1\"},\r\n    })\r\n  )),\r\n}, num_rows, 0xdeadbeef);\r\n{code}",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 7800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Improve configurability of random data generation",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360364/comment/17304985",
                    "id": "17304985",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 9715\n[https://github.com/apache/arrow/pull/9715]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-03-19T15:53:03.464+0000",
                    "updated": "2021-03-19T15:53:03.464+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0nz54:",
        "customfield_12314139": null
    }
}