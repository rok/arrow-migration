{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13205492",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13205492",
    "key": "ARROW-4084",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12343858",
                "id": "12343858",
                "description": "",
                "name": "0.12.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-01-20"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
            "name": "Minor",
            "id": "4"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=fsaintjacques",
            "name": "fsaintjacques",
            "key": "fsaintjacques",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=fsaintjacques&avatarId=37276",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=fsaintjacques&avatarId=37276",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=fsaintjacques&avatarId=37276",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=fsaintjacques&avatarId=37276"
            },
            "displayName": "Francois Saint-Jacques",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=fsaintjacques",
            "name": "fsaintjacques",
            "key": "fsaintjacques",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=fsaintjacques&avatarId=37276",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=fsaintjacques&avatarId=37276",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=fsaintjacques&avatarId=37276",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=fsaintjacques&avatarId=37276"
            },
            "displayName": "Francois Saint-Jacques",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=fsaintjacques",
            "name": "fsaintjacques",
            "key": "fsaintjacques",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=fsaintjacques&avatarId=37276",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=fsaintjacques&avatarId=37276",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=fsaintjacques&avatarId=37276",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=fsaintjacques&avatarId=37276"
            },
            "displayName": "Francois Saint-Jacques",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 7200,
            "total": 7200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 7200,
            "total": 7200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-4084/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 12,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13205492/worklog/177158",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques opened a new pull request #3228: ARROW-4084: Make Status static method support variadic arguments\nURL: https://github.com/apache/arrow/pull/3228\n \n \n   - Static constructors like `Status::Invalid` now supports variadic\r\n   arguments \u00e0 la `Status::Invalid(\"my\", variable, \"error message: \", i)`.\r\n   \r\n   - A new macro was added `ARROW_RETURN_IF(cond, status)` which replaces\r\n   the previous `ARROW_RETURN_IF_FALSE` but also adds branch prediction\r\n   hints. Note that only gandiva was refactored with this macro as\r\n   otherwise the code review would had exploded.\r\n   \r\n   - Fixed a bug in memory map implementations not checking the return\r\n   code of `mmap` and `mremap`.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-19T19:59:08.594+0000",
                    "updated": "2018-12-19T19:59:08.594+0000",
                    "started": "2018-12-19T19:59:08.594+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "177158",
                    "issueId": "13205492"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13205492/worklog/177180",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #3228: ARROW-4084: [C++] Make Status static method support variadic arguments\nURL: https://github.com/apache/arrow/pull/3228#discussion_r243074207\n \n \n\n ##########\n File path: cpp/src/arrow/util/string_builder.h\n ##########\n @@ -0,0 +1,50 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License. template <typename T>\n+\n+#ifndef ARROW_UTIL_STRING_BUILDER_H\n+#define ARROW_UTIL_STRING_BUILDER_H\n+\n+#include <sstream>\n+#include <string>\n+\n+namespace arrow {\n+namespace util {\n+\n+template <typename Head>\n+void StringBuilderRecursive(std::stringstream& stream, Head head) {\n+  stream << head;\n+}\n+\n+template <typename Head, typename... Tail>\n+void StringBuilderRecursive(std::stringstream& stream, Head head, Tail... tail) {\n \n Review comment:\n   The copies will probably be optimized out in this case, but idiomatically this should use perfect capture\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-19T21:03:01.646+0000",
                    "updated": "2018-12-19T21:03:01.646+0000",
                    "started": "2018-12-19T21:03:01.646+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "177180",
                    "issueId": "13205492"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13205492/worklog/177181",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #3228: ARROW-4084: [C++] Make Status static method support variadic arguments\nURL: https://github.com/apache/arrow/pull/3228#discussion_r243074520\n \n \n\n ##########\n File path: cpp/src/arrow/util/string_builder.h\n ##########\n @@ -0,0 +1,50 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License. template <typename T>\n+\n+#ifndef ARROW_UTIL_STRING_BUILDER_H\n+#define ARROW_UTIL_STRING_BUILDER_H\n+\n+#include <sstream>\n+#include <string>\n+\n+namespace arrow {\n+namespace util {\n+\n+template <typename Head>\n+void StringBuilderRecursive(std::stringstream& stream, Head head) {\n+  stream << head;\n+}\n+\n+template <typename Head, typename... Tail>\n+void StringBuilderRecursive(std::stringstream& stream, Head head, Tail... tail) {\n \n Review comment:\n   ```\r\n   template <typename Head, typename... Tail>\r\n   void StringBuilderRecursive(std::stringstream& stream, Head&& head, Tail&&... tail) {\r\n     StringBuilderRecursive(stream, std::forward<Head>(head));\r\n     StringBuilderRecursive(stream, std::forward<Tail>(tail)...);\r\n   }\r\n   ```\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-19T21:04:08.216+0000",
                    "updated": "2018-12-19T21:04:08.216+0000",
                    "started": "2018-12-19T21:04:08.216+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "177181",
                    "issueId": "13205492"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13205492/worklog/177255",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on a change in pull request #3228: ARROW-4084: [C++] Make Status static method support variadic arguments\nURL: https://github.com/apache/arrow/pull/3228#discussion_r243125557\n \n \n\n ##########\n File path: cpp/src/arrow/util/string_builder.h\n ##########\n @@ -0,0 +1,50 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License. template <typename T>\n+\n+#ifndef ARROW_UTIL_STRING_BUILDER_H\n+#define ARROW_UTIL_STRING_BUILDER_H\n+\n+#include <sstream>\n+#include <string>\n+\n+namespace arrow {\n+namespace util {\n+\n+template <typename Head>\n+void StringBuilderRecursive(std::stringstream& stream, Head head) {\n+  stream << head;\n+}\n+\n+template <typename Head, typename... Tail>\n+void StringBuilderRecursive(std::stringstream& stream, Head head, Tail... tail) {\n \n Review comment:\n   +1 for using perfect forwarding\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-20T00:45:57.797+0000",
                    "updated": "2018-12-20T00:45:57.797+0000",
                    "started": "2018-12-20T00:45:57.797+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "177255",
                    "issueId": "13205492"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13205492/worklog/177256",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #3228: ARROW-4084: [C++] Make Status static method support variadic arguments\nURL: https://github.com/apache/arrow/pull/3228#issuecomment-448814038\n \n \n   Impact on code size seems < 1% in a release build, libarrow increased by about 90K (total library size a little over 11MB for me with clang-6). Adding `inline` to the templates in string_builder.h made the code size a tiny bit smaller. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-20T00:57:39.670+0000",
                    "updated": "2018-12-20T00:57:39.670+0000",
                    "started": "2018-12-20T00:57:39.670+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "177256",
                    "issueId": "13205492"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13205492/worklog/177311",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on a change in pull request #3228: ARROW-4084: [C++] Make Status static method support variadic arguments\nURL: https://github.com/apache/arrow/pull/3228#discussion_r243146206\n \n \n\n ##########\n File path: cpp/src/arrow/util/string_builder.h\n ##########\n @@ -0,0 +1,50 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License. template <typename T>\n+\n+#ifndef ARROW_UTIL_STRING_BUILDER_H\n+#define ARROW_UTIL_STRING_BUILDER_H\n+\n+#include <sstream>\n+#include <string>\n+\n+namespace arrow {\n+namespace util {\n+\n+template <typename Head>\n+void StringBuilderRecursive(std::stringstream& stream, Head head) {\n+  stream << head;\n+}\n+\n+template <typename Head, typename... Tail>\n+void StringBuilderRecursive(std::stringstream& stream, Head head, Tail... tail) {\n \n Review comment:\n   Time to remove dust on my Effective modern C++ and read it!\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-20T03:19:42.438+0000",
                    "updated": "2018-12-20T03:19:42.438+0000",
                    "started": "2018-12-20T03:19:42.438+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "177311",
                    "issueId": "13205492"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13205492/worklog/177404",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #3228: ARROW-4084: [C++] Make Status static method support variadic arguments\nURL: https://github.com/apache/arrow/pull/3228#discussion_r243218406\n \n \n\n ##########\n File path: cpp/src/arrow/status.h\n ##########\n @@ -149,84 +145,106 @@ class ARROW_EXPORT Status {\n   static Status OK() { return Status(); }\n \n   /// Return a success status with a specific message\n-  static Status OK(const std::string& msg) { return Status(StatusCode::OK, msg); }\n+  template <typename... Args>\n+  static Status OK(Args... args) {\n+    return Status(StatusCode::OK, util::StringBuilder(args...));\n \n Review comment:\n   Do we need to use forwarding for `args...` here (and in the factories)?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-20T10:16:08.990+0000",
                    "updated": "2018-12-20T10:16:08.990+0000",
                    "started": "2018-12-20T10:16:08.990+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "177404",
                    "issueId": "13205492"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13205492/worklog/177405",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #3228: ARROW-4084: [C++] Make Status static method support variadic arguments\nURL: https://github.com/apache/arrow/pull/3228#discussion_r243218536\n \n \n\n ##########\n File path: cpp/src/arrow/util/string_builder.h\n ##########\n @@ -0,0 +1,50 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License. template <typename T>\n+\n+#ifndef ARROW_UTIL_STRING_BUILDER_H\n+#define ARROW_UTIL_STRING_BUILDER_H\n+\n+#include <sstream>\n+#include <string>\n+\n+namespace arrow {\n+namespace util {\n+\n+template <typename Head>\n+void StringBuilderRecursive(std::stringstream& stream, Head head) {\n+  stream << head;\n+}\n+\n+template <typename Head, typename... Tail>\n+void StringBuilderRecursive(std::stringstream& stream, Head head, Tail... tail) {\n+  StringBuilderRecursive(stream, head);\n+  StringBuilderRecursive(stream, tail...);\n+}\n+\n+template <typename... Args>\n+std::string StringBuilder(Args... args) {\n+  std::stringstream stream;\n+\n+  StringBuilderRecursive(stream, args...);\n \n Review comment:\n   Need to use forwarding here too?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-20T10:16:09.002+0000",
                    "updated": "2018-12-20T10:16:09.002+0000",
                    "started": "2018-12-20T10:16:09.001+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "177405",
                    "issueId": "13205492"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13205492/worklog/177527",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on issue #3228: ARROW-4084: [C++] Make Status static method support variadic arguments\nURL: https://github.com/apache/arrow/pull/3228#issuecomment-449020749\n \n \n   Error is conda failing to download.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-20T14:41:41.228+0000",
                    "updated": "2018-12-20T14:41:41.228+0000",
                    "started": "2018-12-20T14:41:41.228+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "177527",
                    "issueId": "13205492"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13205492/worklog/177529",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #3228: ARROW-4084: [C++] Make Status static method support variadic arguments\nURL: https://github.com/apache/arrow/pull/3228#issuecomment-449021456\n \n \n   It times out sometimes, just restarted\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-20T14:43:53.091+0000",
                    "updated": "2018-12-20T14:43:53.091+0000",
                    "started": "2018-12-20T14:43:53.090+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "177529",
                    "issueId": "13205492"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13205492/worklog/177531",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #3228: ARROW-4084: [C++] Make Status static method support variadic arguments\nURL: https://github.com/apache/arrow/pull/3228#issuecomment-449021865\n \n \n   +1\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-20T14:45:04.925+0000",
                    "updated": "2018-12-20T14:45:04.925+0000",
                    "started": "2018-12-20T14:45:04.924+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "177531",
                    "issueId": "13205492"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13205492/worklog/177536",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm closed pull request #3228: ARROW-4084: [C++] Make Status static method support variadic arguments\nURL: https://github.com/apache/arrow/pull/3228\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/cpp/src/arrow/adapters/orc/adapter.cc b/cpp/src/arrow/adapters/orc/adapter.cc\nindex de803d5ba6..01fc09afb0 100644\n--- a/cpp/src/arrow/adapters/orc/adapter.cc\n+++ b/cpp/src/arrow/adapters/orc/adapter.cc\n@@ -206,11 +206,7 @@ Status GetArrowType(const liborc::Type* type, std::shared_ptr<DataType>* out) {\n       *out = union_(fields, type_codes);\n       break;\n     }\n-    default: {\n-      std::stringstream ss;\n-      ss << \"Unknown Orc type kind: \" << kind;\n-      return Status::Invalid(ss.str());\n-    }\n+    default: { return Status::Invalid(\"Unknown Orc type kind: \", kind); }\n   }\n   return Status::OK();\n }\n@@ -346,11 +342,9 @@ class ORCFileReader::Impl {\n   }\n \n   Status SelectStripe(liborc::RowReaderOptions* opts, int64_t stripe) {\n-    if (stripe < 0 || stripe >= NumberOfStripes()) {\n-      std::stringstream ss;\n-      ss << \"Out of bounds stripe: \" << stripe;\n-      return Status::Invalid(ss.str());\n-    }\n+    ARROW_RETURN_IF(stripe < 0 || stripe >= NumberOfStripes(),\n+                    Status::Invalid(\"Out of bounds stripe: \", stripe));\n+\n     opts->range(stripes_[stripe].offset, stripes_[stripe].length);\n     return Status::OK();\n   }\n@@ -359,9 +353,7 @@ class ORCFileReader::Impl {\n                        const std::vector<int>& include_indices) {\n     std::list<uint64_t> include_indices_list;\n     for (auto it = include_indices.begin(); it != include_indices.end(); ++it) {\n-      if (*it < 0) {\n-        return Status::Invalid(\"Negative field index\");\n-      }\n+      ARROW_RETURN_IF(*it < 0, Status::Invalid(\"Negative field index\"));\n       include_indices_list.push_back(*it);\n     }\n     opts->includeTypes(include_indices_list);\n@@ -455,9 +447,7 @@ class ORCFileReader::Impl {\n       case liborc::DECIMAL:\n         return AppendDecimalBatch(type, batch, offset, length, builder);\n       default:\n-        std::stringstream ss;\n-        ss << \"Not implemented type kind: \" << kind;\n-        return Status::NotImplemented(ss.str());\n+        return Status::NotImplemented(\"Not implemented type kind: \", kind);\n     }\n   }\n \ndiff --git a/cpp/src/arrow/array.cc b/cpp/src/arrow/array.cc\nindex 7e45e90d9c..27b92aaf4e 100644\n--- a/cpp/src/arrow/array.cc\n+++ b/cpp/src/arrow/array.cc\n@@ -638,9 +638,8 @@ Status DictionaryArray::FromArrays(const std::shared_ptr<DataType>& type,\n       is_valid = ValidateDictionaryIndices<Int64Type>(indices, upper_bound);\n       break;\n     default:\n-      std::stringstream ss;\n-      ss << \"Categorical index type not supported: \" << indices->type()->ToString();\n-      return Status::NotImplemented(ss.str());\n+      return Status::NotImplemented(\"Categorical index type not supported: \",\n+                                    indices->type()->ToString());\n   }\n \n   if (!is_valid.ok()) {\n@@ -740,12 +739,11 @@ struct ValidateVisitor {\n   Status Visit(const NullArray&) { return Status::OK(); }\n \n   Status Visit(const PrimitiveArray& array) {\n-    if (array.data()->buffers.size() != 2) {\n-      return Status::Invalid(\"number of buffers was != 2\");\n-    }\n-    if (array.values() == nullptr) {\n-      return Status::Invalid(\"values was null\");\n-    }\n+    ARROW_RETURN_IF(array.data()->buffers.size() != 2,\n+                    Status::Invalid(\"number of buffers was != 2\"));\n+\n+    ARROW_RETURN_IF(array.values() == nullptr, Status::Invalid(\"values was null\"));\n+\n     return Status::OK();\n   }\n \n@@ -776,10 +774,8 @@ struct ValidateVisitor {\n       return Status::Invalid(\"value_offsets_ was null\");\n     }\n     if (value_offsets->size() / static_cast<int>(sizeof(int32_t)) < array.length()) {\n-      std::stringstream ss;\n-      ss << \"offset buffer size (bytes): \" << value_offsets->size()\n-         << \" isn't large enough for length: \" << array.length();\n-      return Status::Invalid(ss.str());\n+      return Status::Invalid(\"offset buffer size (bytes): \", value_offsets->size(),\n+                             \" isn't large enough for length: \", array.length());\n     }\n \n     if (!array.values()) {\n@@ -788,17 +784,13 @@ struct ValidateVisitor {\n \n     const int32_t last_offset = array.value_offset(array.length());\n     if (array.values()->length() != last_offset) {\n-      std::stringstream ss;\n-      ss << \"Final offset invariant not equal to values length: \" << last_offset\n-         << \"!=\" << array.values()->length();\n-      return Status::Invalid(ss.str());\n+      return Status::Invalid(\"Final offset invariant not equal to values length: \",\n+                             last_offset, \"!=\", array.values()->length());\n     }\n \n     const Status child_valid = ValidateArray(*array.values());\n     if (!child_valid.ok()) {\n-      std::stringstream ss;\n-      ss << \"Child array invalid: \" << child_valid.ToString();\n-      return Status::Invalid(ss.str());\n+      return Status::Invalid(\"Child array invalid: \", child_valid.ToString());\n     }\n \n     int32_t prev_offset = array.value_offset(0);\n@@ -808,18 +800,14 @@ struct ValidateVisitor {\n     for (int64_t i = 1; i <= array.length(); ++i) {\n       int32_t current_offset = array.value_offset(i);\n       if (array.IsNull(i - 1) && current_offset != prev_offset) {\n-        std::stringstream ss;\n-        ss << \"Offset invariant failure at: \" << i\n-           << \" inconsistent value_offsets for null slot\" << current_offset\n-           << \"!=\" << prev_offset;\n-        return Status::Invalid(ss.str());\n+        return Status::Invalid(\"Offset invariant failure at: \", i,\n+                               \" inconsistent value_offsets for null slot\",\n+                               current_offset, \"!=\", prev_offset);\n       }\n       if (current_offset < prev_offset) {\n-        std::stringstream ss;\n-        ss << \"Offset invariant failure: \" << i\n-           << \" inconsistent offset for non-null slot: \" << current_offset << \"<\"\n-           << prev_offset;\n-        return Status::Invalid(ss.str());\n+        return Status::Invalid(\"Offset invariant failure: \", i,\n+                               \" inconsistent offset for non-null slot: \", current_offset,\n+                               \"<\", prev_offset);\n       }\n       prev_offset = current_offset;\n     }\n@@ -842,18 +830,14 @@ struct ValidateVisitor {\n       for (int i = 0; i < array.num_fields(); ++i) {\n         auto it = array.field(i);\n         if (it->length() != array_length) {\n-          std::stringstream ss;\n-          ss << \"Length is not equal from field \" << it->type()->ToString()\n-             << \" at position {\" << idx << \"}\";\n-          return Status::Invalid(ss.str());\n+          return Status::Invalid(\"Length is not equal from field \",\n+                                 it->type()->ToString(), \" at position [\", idx, \"]\");\n         }\n \n         const Status child_valid = ValidateArray(*it);\n         if (!child_valid.ok()) {\n-          std::stringstream ss;\n-          ss << \"Child array invalid: \" << child_valid.ToString() << \" at position {\"\n-             << idx << \"}\";\n-          return Status::Invalid(ss.str());\n+          return Status::Invalid(\"Child array invalid: \", child_valid.ToString(),\n+                                 \" at position [\", idx, \"}\");\n         }\n         ++idx;\n       }\ndiff --git a/cpp/src/arrow/array/builder_binary.cc b/cpp/src/arrow/array/builder_binary.cc\nindex ad6ba11a48..8739859310 100644\n--- a/cpp/src/arrow/array/builder_binary.cc\n+++ b/cpp/src/arrow/array/builder_binary.cc\n@@ -59,21 +59,18 @@ Status BinaryBuilder::Resize(int64_t capacity) {\n }\n \n Status BinaryBuilder::ReserveData(int64_t elements) {\n-  if (value_data_length() + elements > value_data_capacity()) {\n-    if (value_data_length() + elements > kBinaryMemoryLimit) {\n-      return Status::CapacityError(\n-          \"Cannot reserve capacity larger than 2^31 - 1 for binary\");\n-    }\n-    RETURN_NOT_OK(value_data_builder_.Reserve(elements));\n-  }\n-  return Status::OK();\n+  const int64_t size = value_data_length() + elements;\n+  ARROW_RETURN_IF(\n+      size > kBinaryMemoryLimit,\n+      Status::CapacityError(\"Cannot reserve capacity larger than 2^31 - 1 for binary\"));\n+\n+  return (size > value_data_capacity()) ? value_data_builder_.Reserve(elements)\n+                                        : Status::OK();\n }\n \n Status BinaryBuilder::AppendOverflow(int64_t num_bytes) {\n-  std::stringstream ss;\n-  ss << \"BinaryArray cannot contain more than \" << kBinaryMemoryLimit << \" bytes, have \"\n-     << num_bytes;\n-  return Status::CapacityError(ss.str());\n+  return Status::CapacityError(\"BinaryArray cannot contain more than \",\n+                               kBinaryMemoryLimit, \" bytes, have \", num_bytes);\n }\n \n Status BinaryBuilder::FinishInternal(std::shared_ptr<ArrayData>* out) {\ndiff --git a/cpp/src/arrow/array/builder_nested.cc b/cpp/src/arrow/array/builder_nested.cc\nindex e73324323a..87c302a82c 100644\n--- a/cpp/src/arrow/array/builder_nested.cc\n+++ b/cpp/src/arrow/array/builder_nested.cc\n@@ -58,13 +58,11 @@ Status ListBuilder::AppendValues(const int32_t* offsets, int64_t length,\n }\n \n Status ListBuilder::AppendNextOffset() {\n-  int64_t num_values = value_builder_->length();\n-  if (ARROW_PREDICT_FALSE(num_values > kListMaximumElements)) {\n-    std::stringstream ss;\n-    ss << \"ListArray cannot contain more then INT32_MAX - 1 child elements,\"\n-       << \" have \" << num_values;\n-    return Status::CapacityError(ss.str());\n-  }\n+  const int64_t num_values = value_builder_->length();\n+  ARROW_RETURN_IF(\n+      num_values > kListMaximumElements,\n+      Status::CapacityError(\"ListArray cannot contain more then 2^31 - 1 child elements,\",\n+                            \" have \", num_values));\n   return offsets_builder_.Append(static_cast<int32_t>(num_values));\n }\n \ndiff --git a/cpp/src/arrow/builder.cc b/cpp/src/arrow/builder.cc\nindex ff2b453bb4..2072edc936 100644\n--- a/cpp/src/arrow/builder.cc\n+++ b/cpp/src/arrow/builder.cc\n@@ -93,9 +93,8 @@ Status MakeBuilder(MemoryPool* pool, const std::shared_ptr<DataType>& type,\n     }\n \n     default: {\n-      std::stringstream ss;\n-      ss << \"MakeBuilder: cannot construct builder for type \" << type->ToString();\n-      return Status::NotImplemented(ss.str());\n+      return Status::NotImplemented(\"MakeBuilder: cannot construct builder for type \",\n+                                    type->ToString());\n     }\n   }\n }\ndiff --git a/cpp/src/arrow/compute/kernels/cast.cc b/cpp/src/arrow/compute/kernels/cast.cc\nindex b148486bd2..2ce0702f20 100644\n--- a/cpp/src/arrow/compute/kernels/cast.cc\n+++ b/cpp/src/arrow/compute/kernels/cast.cc\n@@ -508,11 +508,9 @@ void ShiftTime(FunctionContext* ctx, const CastOptions& options, const bool is_m\n         out_data[i] = static_cast<out_type>(in_data[i] / factor);\n       }\n     } else {\n-#define RAISE_INVALID_CAST(VAL)                                                         \\\n-  std::stringstream ss;                                                                 \\\n-  ss << \"Casting from \" << input.type->ToString() << \" to \" << output->type->ToString() \\\n-     << \" would lose data: \" << VAL;                                                    \\\n-  ctx->SetStatus(Status::Invalid(ss.str()));\n+#define RAISE_INVALID_CAST(VAL)                                                   \\\n+  ctx->SetStatus(Status::Invalid(\"Casting from \", input.type->ToString(), \" to \", \\\n+                                 output->type->ToString(), \" would lose data: \", VAL));\n \n       if (input.null_count != 0) {\n         internal::BitmapReader bit_reader(input.buffers[0]->data(), input.offset,\n@@ -795,9 +793,8 @@ struct CastFunctor<\n         UnpackFixedSizeBinaryDictionary<Int64Type>(ctx, indices, dictionary, output);\n         break;\n       default:\n-        std::stringstream ss;\n-        ss << \"Invalid index type: \" << indices.type()->ToString();\n-        ctx->SetStatus(Status::Invalid(ss.str()));\n+        ctx->SetStatus(\n+            Status::Invalid(\"Invalid index type: \", indices.type()->ToString()));\n         return;\n     }\n   }\n@@ -874,9 +871,8 @@ struct CastFunctor<T, DictionaryType,\n             (UnpackBinaryDictionary<Int64Type>(ctx, indices, dictionary, output)));\n         break;\n       default:\n-        std::stringstream ss;\n-        ss << \"Invalid index type: \" << indices.type()->ToString();\n-        ctx->SetStatus(Status::Invalid(ss.str()));\n+        ctx->SetStatus(\n+            Status::Invalid(\"Invalid index type: \", indices.type()->ToString()));\n         return;\n     }\n   }\n@@ -932,9 +928,8 @@ struct CastFunctor<T, DictionaryType,\n         UnpackPrimitiveDictionary<Int64Type, c_type>(indices, dictionary, out);\n         break;\n       default:\n-        std::stringstream ss;\n-        ss << \"Invalid index type: \" << indices.type()->ToString();\n-        ctx->SetStatus(Status::Invalid(ss.str()));\n+        ctx->SetStatus(\n+            Status::Invalid(\"Invalid index type: \", indices.type()->ToString()));\n         return;\n     }\n   }\n@@ -960,9 +955,8 @@ struct CastFunctor<O, StringType, enable_if_number<O>> {\n \n       auto str = input_array.GetView(i);\n       if (!converter(str.data(), str.length(), out_data)) {\n-        std::stringstream ss;\n-        ss << \"Failed to cast String '\" << str << \"' into \" << output->type->ToString();\n-        ctx->SetStatus(Status(StatusCode::Invalid, ss.str()));\n+        ctx->SetStatus(Status::Invalid(\"Failed to cast String '\", str, \"' into \",\n+                                       output->type->ToString()));\n         return;\n       }\n     }\n@@ -991,10 +985,9 @@ struct CastFunctor<O, StringType,\n       bool value;\n       auto str = input_array.GetView(i);\n       if (!converter(str.data(), str.length(), &value)) {\n-        std::stringstream ss;\n-        ss << \"Failed to cast String '\" << input_array.GetString(i) << \"' into \"\n-           << output->type->ToString();\n-        ctx->SetStatus(Status(StatusCode::Invalid, ss.str()));\n+        ctx->SetStatus(Status::Invalid(\"Failed to cast String '\",\n+                                       input_array.GetString(i), \"' into \",\n+                                       output->type->ToString()));\n         return;\n       }\n \n@@ -1029,9 +1022,8 @@ struct CastFunctor<TimestampType, StringType> {\n \n       const auto str = input_array.GetView(i);\n       if (!converter(str.data(), str.length(), out_data)) {\n-        std::stringstream ss;\n-        ss << \"Failed to cast String '\" << str << \"' into \" << output->type->ToString();\n-        ctx->SetStatus(Status(StatusCode::Invalid, ss.str()));\n+        ctx->SetStatus(Status::Invalid(\"Failed to cast String '\", str, \"' into \",\n+                                       output->type->ToString()));\n         return;\n       }\n     }\n@@ -1123,9 +1115,8 @@ static Status AllocateIfNotPreallocated(FunctionContext* ctx, const ArrayData& i\n \n     if (!(is_primitive(type_id) || type_id == Type::FIXED_SIZE_BINARY ||\n           type_id == Type::DECIMAL)) {\n-      std::stringstream ss;\n-      ss << \"Cannot pre-allocate memory for type: \" << out->type->ToString();\n-      return Status::NotImplemented(ss.str());\n+      return Status::NotImplemented(\"Cannot pre-allocate memory for type: \",\n+                                    out->type->ToString());\n     }\n \n     if (type_id != Type::NA) {\n@@ -1400,10 +1391,8 @@ Status GetCastFunction(const DataType& in_type, const std::shared_ptr<DataType>&\n       break;\n   }\n   if (*kernel == nullptr) {\n-    std::stringstream ss;\n-    ss << \"No cast implemented from \" << in_type.ToString() << \" to \"\n-       << out_type->ToString();\n-    return Status::NotImplemented(ss.str());\n+    return Status::NotImplemented(\"No cast implemented from \", in_type.ToString(), \" to \",\n+                                  out_type->ToString());\n   }\n   return Status::OK();\n }\ndiff --git a/cpp/src/arrow/compute/kernels/hash.cc b/cpp/src/arrow/compute/kernels/hash.cc\nindex c057ea5736..0513fe1f6a 100644\n--- a/cpp/src/arrow/compute/kernels/hash.cc\n+++ b/cpp/src/arrow/compute/kernels/hash.cc\n@@ -56,11 +56,9 @@ namespace compute {\n \n namespace {\n \n-#define CHECK_IMPLEMENTED(KERNEL, FUNCNAME, TYPE)                  \\\n-  if (!KERNEL) {                                                   \\\n-    std::stringstream ss;                                          \\\n-    ss << FUNCNAME << \" not implemented for \" << type->ToString(); \\\n-    return Status::NotImplemented(ss.str());                       \\\n+#define CHECK_IMPLEMENTED(KERNEL, FUNCNAME, TYPE)                                       \\\n+  if (!KERNEL) {                                                                        \\\n+    return Status::NotImplemented(FUNCNAME, \" not implemented for \", type->ToString()); \\\n   }\n \n // ----------------------------------------------------------------------\ndiff --git a/cpp/src/arrow/csv/converter.cc b/cpp/src/arrow/csv/converter.cc\nindex 8a249a68c0..1018f85538 100644\n--- a/cpp/src/arrow/csv/converter.cc\n+++ b/cpp/src/arrow/csv/converter.cc\n@@ -40,10 +40,9 @@ namespace {\n \n Status GenericConversionError(const std::shared_ptr<DataType>& type, const uint8_t* data,\n                               uint32_t size) {\n-  std::stringstream ss;\n-  ss << \"CSV conversion error to \" << type->ToString() << \": invalid value '\"\n-     << std::string(reinterpret_cast<const char*>(data), size) << \"'\";\n-  return Status::Invalid(ss.str());\n+  return Status::Invalid(\"CSV conversion error to \", type->ToString(),\n+                         \": invalid value '\",\n+                         std::string(reinterpret_cast<const char*>(data), size), \"'\");\n }\n \n inline bool IsWhitespace(uint8_t c) {\n@@ -214,9 +213,8 @@ class VarSizeBinaryConverter : public ConcreteConverter {\n \n     auto visit = [&](const uint8_t* data, uint32_t size, bool quoted) -> Status {\n       if (CheckUTF8 && ARROW_PREDICT_FALSE(!util::ValidateUTF8(data, size))) {\n-        std::stringstream ss;\n-        ss << \"CSV conversion error to \" << type_->ToString() << \": invalid UTF8 data\";\n-        return Status::Invalid(ss.str());\n+        return Status::Invalid(\"CSV conversion error to \", type_->ToString(),\n+                               \": invalid UTF8 data\");\n       }\n       builder.UnsafeAppend(data, size);\n       return Status::OK();\n@@ -256,10 +254,8 @@ Status FixedSizeBinaryConverter::Convert(const BlockParser& parser, int32_t col_\n \n   auto visit = [&](const uint8_t* data, uint32_t size, bool quoted) -> Status {\n     if (ARROW_PREDICT_FALSE(size != byte_width)) {\n-      std::stringstream ss;\n-      ss << \"CSV conversion error to \" << type_->ToString() << \": got a \" << size\n-         << \"-byte long string\";\n-      return Status::Invalid(ss.str());\n+      return Status::Invalid(\"CSV conversion error to \", type_->ToString(), \": got a \",\n+                             size, \"-byte long string\");\n     }\n     return builder.Append(data);\n   };\n@@ -410,9 +406,8 @@ Status Converter::Make(const std::shared_ptr<DataType>& type,\n       break;\n \n     default: {\n-      std::stringstream ss;\n-      ss << \"CSV conversion to \" << type->ToString() << \" is not supported\";\n-      return Status::NotImplemented(ss.str());\n+      return Status::NotImplemented(\"CSV conversion to \", type->ToString(),\n+                                    \" is not supported\");\n     }\n \n #undef CONVERTER_CASE\ndiff --git a/cpp/src/arrow/csv/parser.cc b/cpp/src/arrow/csv/parser.cc\nindex fe7f841f58..b1d175adfb 100644\n--- a/cpp/src/arrow/csv/parser.cc\n+++ b/cpp/src/arrow/csv/parser.cc\n@@ -30,9 +30,7 @@ namespace arrow {\n namespace csv {\n \n static Status ParseError(const char* message) {\n-  std::stringstream ss;\n-  ss << \"CSV parse error: \" << message;\n-  return Status::Invalid(ss.str());\n+  return Status::Invalid(\"CSV parse error: \", message);\n }\n \n static Status MismatchingColumns(int32_t expected, int32_t actual) {\ndiff --git a/cpp/src/arrow/csv/reader.cc b/cpp/src/arrow/csv/reader.cc\nindex b2a6b7b430..efd61167b7 100644\n--- a/cpp/src/arrow/csv/reader.cc\n+++ b/cpp/src/arrow/csv/reader.cc\n@@ -355,10 +355,8 @@ class ThreadedTableReader : public BaseTableReader {\n                                       chunk_size, &parsed_size));\n           if (parsed_size != chunk_size) {\n             DCHECK_EQ(parsed_size, chunk_size);\n-            std::stringstream ss;\n-            ss << \"Chunker and parser disagree on block size: \" << chunk_size << \" vs \"\n-               << parsed_size;\n-            return Status::Invalid(ss.str());\n+            return Status::Invalid(\"Chunker and parser disagree on block size: \",\n+                                   chunk_size, \" vs \", parsed_size);\n           }\n           RETURN_NOT_OK(ProcessData(parser, chunk_index));\n           // Keep chunk buffer alive within closure and release it at the end\ndiff --git a/cpp/src/arrow/dbi/hiveserver2/hiveserver2-test.cc b/cpp/src/arrow/dbi/hiveserver2/hiveserver2-test.cc\nindex 7022ff017f..a7749161c4 100644\n--- a/cpp/src/arrow/dbi/hiveserver2/hiveserver2-test.cc\n+++ b/cpp/src/arrow/dbi/hiveserver2/hiveserver2-test.cc\n@@ -97,10 +97,8 @@ Status Wait(const std::unique_ptr<Operation>& op,\n   if (op_state == state) {\n     return Status::OK();\n   } else {\n-    std::stringstream ss;\n-    ss << \"Failed to reach state '\" << OperationStateToString(state) << \"' after \"\n-       << retries << \" retries.\";\n-    return Status::IOError(ss.str());\n+    return Status::IOError(\"Failed to reach state '\", OperationStateToString(state),\n+                           \"' after \", retries, \" retries\");\n   }\n }\n \ndiff --git a/cpp/src/arrow/dbi/hiveserver2/service.cc b/cpp/src/arrow/dbi/hiveserver2/service.cc\nindex e2d3f2a21b..502a8a284b 100644\n--- a/cpp/src/arrow/dbi/hiveserver2/service.cc\n+++ b/cpp/src/arrow/dbi/hiveserver2/service.cc\n@@ -92,9 +92,7 @@ Service::Service(const string& host, int port, int conn_timeout,\n \n Status Service::Open() {\n   if (impl_->protocol_version < hs2::TProtocolVersion::HIVE_CLI_SERVICE_PROTOCOL_V6) {\n-    std::stringstream ss;\n-    ss << \"Unsupported protocol: \" << impl_->protocol_version;\n-    return Status::NotImplemented(ss.str());\n+    return Status::NotImplemented(\"Unsupported protocol: \", impl_->protocol_version);\n   }\n \n   impl_->socket.reset(new TSocket(host_, port_));\ndiff --git a/cpp/src/arrow/dbi/hiveserver2/thrift-internal.cc b/cpp/src/arrow/dbi/hiveserver2/thrift-internal.cc\nindex d154e143ba..171eae3681 100644\n--- a/cpp/src/arrow/dbi/hiveserver2/thrift-internal.cc\n+++ b/cpp/src/arrow/dbi/hiveserver2/thrift-internal.cc\n@@ -204,11 +204,7 @@ Status TStatusToStatus(const hs2::TStatus& tstatus) {\n       return Status::IOError(tstatus.errorMessage);\n     case hs2::TStatusCode::INVALID_HANDLE_STATUS:\n       return Status::Invalid(\"Invalid handle\");\n-    default: {\n-      std::stringstream ss;\n-      ss << \"Unknown TStatusCode \" << tstatus.statusCode;\n-      return Status::UnknownError(ss.str());\n-    }\n+    default: { return Status::UnknownError(\"Unknown TStatusCode \", tstatus.statusCode); }\n   }\n }\n \ndiff --git a/cpp/src/arrow/flight/internal.cc b/cpp/src/arrow/flight/internal.cc\nindex 796e6095cd..b4c6b2addc 100644\n--- a/cpp/src/arrow/flight/internal.cc\n+++ b/cpp/src/arrow/flight/internal.cc\n@@ -37,16 +37,13 @@ Status FromGrpcStatus(const grpc::Status& grpc_status) {\n   if (grpc_status.ok()) {\n     return Status::OK();\n   }\n-  std::stringstream ss;\n \n   if (grpc_status.error_code() == grpc::StatusCode::UNIMPLEMENTED) {\n-    ss << \"gRPC returned unimplemented error, with message: \"\n-       << grpc_status.error_message();\n-    return Status::NotImplemented(ss.str());\n+    return Status::NotImplemented(\"gRPC returned unimplemented error, with message: \",\n+                                  grpc_status.error_message());\n   } else {\n-    ss << \"gRPC failed with error code \" << grpc_status.error_code()\n-       << \" and message: \" << grpc_status.error_message();\n-    return Status::IOError(ss.str());\n+    return Status::IOError(\"gRPC failed with error code \", grpc_status.error_code(),\n+                           \" and message: \", grpc_status.error_message());\n   }\n }\n \ndiff --git a/cpp/src/arrow/gpu/cuda_arrow_ipc.cc b/cpp/src/arrow/gpu/cuda_arrow_ipc.cc\nindex 03256a1f52..b4d8744cb0 100644\n--- a/cpp/src/arrow/gpu/cuda_arrow_ipc.cc\n+++ b/cpp/src/arrow/gpu/cuda_arrow_ipc.cc\n@@ -82,9 +82,8 @@ Status ReadMessage(CudaBufferReader* reader, MemoryPool* pool,\n   RETURN_NOT_OK(AllocateBuffer(pool, message_length, &metadata));\n   RETURN_NOT_OK(reader->Read(message_length, &bytes_read, metadata->mutable_data()));\n   if (bytes_read != message_length) {\n-    std::stringstream ss;\n-    ss << \"Expected \" << message_length << \" metadata bytes, but only got \" << bytes_read;\n-    return Status::IOError(ss.str());\n+    return Status::IOError(\"Expected \", message_length, \" metadata bytes, but only got \",\n+                           bytes_read);\n   }\n \n   return ipc::Message::ReadFrom(metadata, reader, out);\ndiff --git a/cpp/src/arrow/gpu/cuda_common.h b/cpp/src/arrow/gpu/cuda_common.h\nindex a53dd220ad..2b630c8114 100644\n--- a/cpp/src/arrow/gpu/cuda_common.h\n+++ b/cpp/src/arrow/gpu/cuda_common.h\n@@ -34,15 +34,13 @@ namespace cuda {\n     (void)ret;            \\\n   } while (0)\n \n-#define CU_RETURN_NOT_OK(STMT)                                                \\\n-  do {                                                                        \\\n-    CUresult ret = (STMT);                                                    \\\n-    if (ret != CUDA_SUCCESS) {                                                \\\n-      std::stringstream ss;                                                   \\\n-      ss << \"Cuda Driver API call in \" << __FILE__ << \" at line \" << __LINE__ \\\n-         << \" failed with code \" << ret << \": \" << #STMT;                     \\\n-      return Status::IOError(ss.str());                                       \\\n-    }                                                                         \\\n+#define CU_RETURN_NOT_OK(STMT)                                                  \\\n+  do {                                                                          \\\n+    CUresult ret = (STMT);                                                      \\\n+    if (ret != CUDA_SUCCESS) {                                                  \\\n+      return Status::IOError(\"Cuda Driver API call in \", __FILE__, \" at line \", \\\n+                             __LINE__, \" failed with code \", ret, \": \", #STMT); \\\n+    }                                                                           \\\n   } while (0)\n \n }  // namespace cuda\ndiff --git a/cpp/src/arrow/io/file-test.cc b/cpp/src/arrow/io/file-test.cc\nindex 4d710d3470..6d780c0940 100644\n--- a/cpp/src/arrow/io/file-test.cc\n+++ b/cpp/src/arrow/io/file-test.cc\n@@ -460,9 +460,7 @@ class MyMemoryPool : public MemoryPool {\n     *ptr = reinterpret_cast<uint8_t*>(std::realloc(*ptr, new_size));\n \n     if (*ptr == NULL) {\n-      std::stringstream ss;\n-      ss << \"realloc of size \" << new_size << \" failed\";\n-      return Status::OutOfMemory(ss.str());\n+      return Status::OutOfMemory(\"realloc of size \", new_size, \" failed\");\n     }\n \n     return Status::OK();\ndiff --git a/cpp/src/arrow/io/file.cc b/cpp/src/arrow/io/file.cc\nindex 869d8e3720..0398d5a1f9 100644\n--- a/cpp/src/arrow/io/file.cc\n+++ b/cpp/src/arrow/io/file.cc\n@@ -479,9 +479,7 @@ class MemoryMappedFile::MemoryMap : public MutableBuffer {\n     void* result = mmap(nullptr, static_cast<size_t>(initial_size), prot_flags_,\n                         map_mode_, file_->fd(), 0);\n     if (result == MAP_FAILED) {\n-      std::stringstream ss;\n-      ss << \"Memory mapping file failed: \" << std::strerror(errno);\n-      return Status::IOError(ss.str());\n+      return Status::IOError(\"Memory mapping file failed: \", std::strerror(errno));\n     }\n     size_ = capacity_ = initial_size;\n     data_ = mutable_data_ = static_cast<uint8_t*>(result);\ndiff --git a/cpp/src/arrow/io/hdfs-internal.cc b/cpp/src/arrow/io/hdfs-internal.cc\nindex c8be5164cf..c273ab45f6 100644\n--- a/cpp/src/arrow/io/hdfs-internal.cc\n+++ b/cpp/src/arrow/io/hdfs-internal.cc\n@@ -218,9 +218,7 @@ static arrow::Status try_dlopen(std::vector<fs::path> potential_paths, const cha\n   }\n \n   if (out_handle == NULL) {\n-    std::stringstream ss;\n-    ss << \"Unable to load \" << name;\n-    return arrow::Status::IOError(ss.str());\n+    return arrow::Status::IOError(\"Unable to load \", name);\n   }\n \n   return arrow::Status::OK();\n@@ -243,9 +241,7 @@ static arrow::Status try_dlopen(std::vector<fs::path> potential_paths, const cha\n   }\n \n   if (out_handle == NULL) {\n-    std::stringstream ss;\n-    ss << \"Unable to load \" << name;\n-    return arrow::Status::IOError(ss.str());\n+    return arrow::Status::IOError(\"Unable to load \", name);\n   }\n \n   return arrow::Status::OK();\ndiff --git a/cpp/src/arrow/io/hdfs.cc b/cpp/src/arrow/io/hdfs.cc\nindex 030b84853d..3e9b804ca2 100644\n--- a/cpp/src/arrow/io/hdfs.cc\n+++ b/cpp/src/arrow/io/hdfs.cc\n@@ -57,13 +57,11 @@ std::string TranslateErrno(int error_code) {\n \n }  // namespace\n \n-#define CHECK_FAILURE(RETURN_VALUE, WHAT)                                   \\\n-  do {                                                                      \\\n-    if (RETURN_VALUE == -1) {                                               \\\n-      std::stringstream ss;                                                 \\\n-      ss << \"HDFS \" << WHAT << \" failed, errno: \" << TranslateErrno(errno); \\\n-      return Status::IOError(ss.str());                                     \\\n-    }                                                                       \\\n+#define CHECK_FAILURE(RETURN_VALUE, WHAT)                                               \\\n+  do {                                                                                  \\\n+    if (RETURN_VALUE == -1) {                                                           \\\n+      return Status::IOError(\"HDFS \", WHAT, \" failed, errno: \", TranslateErrno(errno)); \\\n+    }                                                                                   \\\n   } while (0)\n \n static constexpr int kDefaultHdfsBufferSize = 1 << 16;\n@@ -466,10 +464,8 @@ class HadoopFileSystem::HadoopFileSystemImpl {\n       if ((errno == 0) || (errno == ENOENT && Exists(path))) {\n         num_entries = 0;\n       } else {\n-        std::stringstream ss;\n-        ss << \"HDFS list directory of \" << path\n-           << \" failed, errno: \" << TranslateErrno(errno);\n-        return Status::IOError(ss.str());\n+        return Status::IOError(\"HDFS list directory failed, errno: \",\n+                               TranslateErrno(errno));\n       }\n     }\n \n@@ -492,14 +488,9 @@ class HadoopFileSystem::HadoopFileSystemImpl {\n     hdfsFile handle = driver_->OpenFile(fs_, path.c_str(), O_RDONLY, buffer_size, 0, 0);\n \n     if (handle == nullptr) {\n-      std::stringstream ss;\n-      if (!Exists(path)) {\n-        ss << \"HDFS file does not exist: \" << path;\n-      } else {\n-        // TODO(wesm): determine other causes of failure\n-        ss << \"HDFS path exists, but opening file failed: \" << path;\n-      }\n-      return Status::IOError(ss.str());\n+      const char* msg = !Exists(path) ? \"HDFS file does not exist: \"\n+                                      : \"HDFS path exists, but opening file failed: \";\n+      return Status::IOError(msg, path);\n     }\n \n     // std::make_shared does not work with private ctors\n@@ -521,10 +512,7 @@ class HadoopFileSystem::HadoopFileSystemImpl {\n                           static_cast<tSize>(default_block_size));\n \n     if (handle == nullptr) {\n-      // TODO(wesm): determine cause of failure\n-      std::stringstream ss;\n-      ss << \"Unable to open file \" << path;\n-      return Status::IOError(ss.str());\n+      return Status::IOError(\"Unable to open file \", path);\n     }\n \n     // std::make_shared does not work with private ctors\ndiff --git a/cpp/src/arrow/ipc/dictionary.cc b/cpp/src/arrow/ipc/dictionary.cc\nindex 488bb75b9d..aa0d9085f5 100644\n--- a/cpp/src/arrow/ipc/dictionary.cc\n+++ b/cpp/src/arrow/ipc/dictionary.cc\n@@ -34,9 +34,7 @@ Status DictionaryMemo::GetDictionary(int64_t id,\n                                      std::shared_ptr<Array>* dictionary) const {\n   auto it = id_to_dictionary_.find(id);\n   if (it == id_to_dictionary_.end()) {\n-    std::stringstream ss;\n-    ss << \"Dictionary with id \" << id << \" not found\";\n-    return Status::KeyError(ss.str());\n+    return Status::KeyError(\"Dictionary with id \", id, \" not found\");\n   }\n   *dictionary = it->second;\n   return Status::OK();\n@@ -70,9 +68,7 @@ bool DictionaryMemo::HasDictionaryId(int64_t id) const {\n Status DictionaryMemo::AddDictionary(int64_t id,\n                                      const std::shared_ptr<Array>& dictionary) {\n   if (HasDictionaryId(id)) {\n-    std::stringstream ss;\n-    ss << \"Dictionary with id \" << id << \" already exists\";\n-    return Status::KeyError(ss.str());\n+    return Status::KeyError(\"Dictionary with id \", id, \" already exists\");\n   }\n   intptr_t address = reinterpret_cast<intptr_t>(dictionary.get());\n   id_to_dictionary_[id] = dictionary;\ndiff --git a/cpp/src/arrow/ipc/feather.cc b/cpp/src/arrow/ipc/feather.cc\nindex ebdb335fa5..b0ab62c678 100644\n--- a/cpp/src/arrow/ipc/feather.cc\n+++ b/cpp/src/arrow/ipc/feather.cc\n@@ -642,9 +642,7 @@ class TableWriter::TableWriterImpl : public ArrayVisitor {\n \n   Status LoadArrayMetadata(const Array& values, ArrayMetadata* meta) {\n     if (!(is_primitive(values.type_id()) || is_binary_like(values.type_id()))) {\n-      std::stringstream ss;\n-      ss << \"Array is not primitive type: \" << values.type()->ToString();\n-      return Status::Invalid(ss.str());\n+      return Status::Invalid(\"Array is not primitive type: \", values.type()->ToString());\n     }\n \n     meta->type = ToFlatbufferType(values.type_id());\ndiff --git a/cpp/src/arrow/ipc/json-integration-test.cc b/cpp/src/arrow/ipc/json-integration-test.cc\nindex 914cdb6659..fe69a53a94 100644\n--- a/cpp/src/arrow/ipc/json-integration-test.cc\n+++ b/cpp/src/arrow/ipc/json-integration-test.cc\n@@ -170,10 +170,8 @@ static Status ValidateArrowVsJson(const std::string& arrow_path,\n   const int arrow_nbatches = arrow_reader->num_record_batches();\n \n   if (json_nbatches != arrow_nbatches) {\n-    std::stringstream ss;\n-    ss << \"Different number of record batches: \" << json_nbatches << \" (JSON) vs \"\n-       << arrow_nbatches << \" (Arrow)\";\n-    return Status::Invalid(ss.str());\n+    return Status::Invalid(\"Different number of record batches: \", json_nbatches,\n+                           \" (JSON) vs \", arrow_nbatches, \" (Arrow)\");\n   }\n \n   std::shared_ptr<RecordBatch> arrow_batch;\n@@ -231,9 +229,7 @@ Status RunCommand(const std::string& json_path, const std::string& arrow_path,\n \n     return ValidateArrowVsJson(arrow_path, json_path);\n   } else {\n-    std::stringstream ss;\n-    ss << \"Unknown command: \" << command;\n-    return Status::Invalid(ss.str());\n+    return Status::Invalid(\"Unknown command: \", command);\n   }\n }\n \ndiff --git a/cpp/src/arrow/ipc/json-internal.cc b/cpp/src/arrow/ipc/json-internal.cc\nindex d5a5dd9f39..05e547506c 100644\n--- a/cpp/src/arrow/ipc/json-internal.cc\n+++ b/cpp/src/arrow/ipc/json-internal.cc\n@@ -633,9 +633,7 @@ static Status GetInteger(const rj::Value::ConstObject& json_type,\n       *type = is_signed ? int64() : uint64();\n       break;\n     default:\n-      std::stringstream ss;\n-      ss << \"Invalid bit width: \" << bit_width;\n-      return Status::Invalid(ss.str());\n+      return Status::Invalid(\"Invalid bit width: \", bit_width);\n   }\n   return Status::OK();\n }\n@@ -654,9 +652,7 @@ static Status GetFloatingPoint(const RjObject& json_type,\n   } else if (precision == \"HALF\") {\n     *type = float16();\n   } else {\n-    std::stringstream ss;\n-    ss << \"Invalid precision: \" << precision;\n-    return Status::Invalid(ss.str());\n+    return Status::Invalid(\"Invalid precision: \", precision);\n   }\n   return Status::OK();\n }\n@@ -693,9 +689,7 @@ static Status GetDate(const RjObject& json_type, std::shared_ptr<DataType>* type\n   } else if (unit_str == \"MILLISECOND\") {\n     *type = date64();\n   } else {\n-    std::stringstream ss;\n-    ss << \"Invalid date unit: \" << unit_str;\n-    return Status::Invalid(ss.str());\n+    return Status::Invalid(\"Invalid date unit: \", unit_str);\n   }\n   return Status::OK();\n }\n@@ -718,9 +712,7 @@ static Status GetTime(const RjObject& json_type, std::shared_ptr<DataType>* type\n   } else if (unit_str == \"NANOSECOND\") {\n     *type = time64(TimeUnit::NANO);\n   } else {\n-    std::stringstream ss;\n-    ss << \"Invalid time unit: \" << unit_str;\n-    return Status::Invalid(ss.str());\n+    return Status::Invalid(\"Invalid time unit: \", unit_str);\n   }\n \n   const auto& fw_type = checked_cast<const FixedWidthType&>(**type);\n@@ -749,9 +741,7 @@ static Status GetTimestamp(const RjObject& json_type, std::shared_ptr<DataType>*\n   } else if (unit_str == \"NANOSECOND\") {\n     unit = TimeUnit::NANO;\n   } else {\n-    std::stringstream ss;\n-    ss << \"Invalid time unit: \" << unit_str;\n-    return Status::Invalid(ss.str());\n+    return Status::Invalid(\"Invalid time unit: \", unit_str);\n   }\n \n   const auto& it_tz = json_type.FindMember(\"timezone\");\n@@ -778,9 +768,7 @@ static Status GetUnion(const RjObject& json_type,\n   } else if (mode_str == \"DENSE\") {\n     mode = UnionMode::DENSE;\n   } else {\n-    std::stringstream ss;\n-    ss << \"Invalid union mode: \" << mode_str;\n-    return Status::Invalid(ss.str());\n+    return Status::Invalid(\"Invalid union mode: \", mode_str);\n   }\n \n   const auto& it_type_codes = json_type.FindMember(\"typeIds\");\n@@ -838,9 +826,7 @@ static Status GetType(const RjObject& json_type,\n   } else if (type_name == \"union\") {\n     return GetUnion(json_type, children, type);\n   } else {\n-    std::stringstream ss;\n-    ss << \"Unrecognized type name: \" << type_name;\n-    return Status::Invalid(ss.str());\n+    return Status::Invalid(\"Unrecognized type name: \", type_name);\n   }\n   return Status::OK();\n }\n@@ -1235,10 +1221,8 @@ class ArrayReader {\n     const auto& json_children_arr = json_children->value.GetArray();\n \n     if (type.num_children() != static_cast<int>(json_children_arr.Size())) {\n-      std::stringstream ss;\n-      ss << \"Expected \" << type.num_children() << \" children, but got \"\n-         << json_children_arr.Size();\n-      return Status::Invalid(ss.str());\n+      return Status::Invalid(\"Expected \", type.num_children(), \" children, but got \",\n+                             json_children_arr.Size());\n     }\n \n     for (int i = 0; i < static_cast<int>(json_children_arr.Size()); ++i) {\n@@ -1342,9 +1326,7 @@ static Status ReadDictionary(const RjObject& obj, const DictionaryTypeMap& id_to\n \n   auto it = id_to_field.find(id);\n   if (it == id_to_field.end()) {\n-    std::stringstream ss;\n-    ss << \"No dictionary with id \" << id;\n-    return Status::Invalid(ss.str());\n+    return Status::Invalid(\"No dictionary with id \", id);\n   }\n   std::vector<std::shared_ptr<Field>> fields = {it->second};\n \n@@ -1489,9 +1471,7 @@ Status ReadArray(MemoryPool* pool, const rj::Value& json_array, const Schema& sc\n   }\n \n   if (result == nullptr) {\n-    std::stringstream ss;\n-    ss << \"Field named \" << name << \" not found in schema\";\n-    return Status::KeyError(ss.str());\n+    return Status::KeyError(\"Field named \", name, \" not found in schema\");\n   }\n \n   return ReadArray(pool, json_array, result->type(), array);\ndiff --git a/cpp/src/arrow/ipc/json-internal.h b/cpp/src/arrow/ipc/json-internal.h\nindex 5516e2dd72..c8c724968f 100644\n--- a/cpp/src/arrow/ipc/json-internal.h\n+++ b/cpp/src/arrow/ipc/json-internal.h\n@@ -49,56 +49,39 @@ using RjWriter = rj::Writer<rj::StringBuffer>;\n using RjArray = rj::Value::ConstArray;\n using RjObject = rj::Value::ConstObject;\n \n-#define RETURN_NOT_FOUND(TOK, NAME, PARENT) \\\n-  if (NAME == (PARENT).MemberEnd()) {       \\\n-    std::stringstream ss;                   \\\n-    ss << \"field \" << TOK << \" not found\";  \\\n-    return Status::Invalid(ss.str());       \\\n+#define RETURN_NOT_FOUND(TOK, NAME, PARENT)              \\\n+  if (NAME == (PARENT).MemberEnd()) {                    \\\n+    return Status::Invalid(\"field \", TOK, \" not found\"); \\\n   }\n \n-#define RETURN_NOT_STRING(TOK, NAME, PARENT) \\\n-  RETURN_NOT_FOUND(TOK, NAME, PARENT);       \\\n-  if (!NAME->value.IsString()) {             \\\n-    std::stringstream ss;                    \\\n-    ss << \"field was not a string\"           \\\n-       << \" line \" << __LINE__;              \\\n-    return Status::Invalid(ss.str());        \\\n+#define RETURN_NOT_STRING(TOK, NAME, PARENT)                          \\\n+  RETURN_NOT_FOUND(TOK, NAME, PARENT);                                \\\n+  if (!NAME->value.IsString()) {                                      \\\n+    return Status::Invalid(\"field was not a string line \", __LINE__); \\\n   }\n \n-#define RETURN_NOT_BOOL(TOK, NAME, PARENT) \\\n-  RETURN_NOT_FOUND(TOK, NAME, PARENT);     \\\n-  if (!NAME->value.IsBool()) {             \\\n-    std::stringstream ss;                  \\\n-    ss << \"field was not a boolean\"        \\\n-       << \" line \" << __LINE__;            \\\n-    return Status::Invalid(ss.str());      \\\n+#define RETURN_NOT_BOOL(TOK, NAME, PARENT)                             \\\n+  RETURN_NOT_FOUND(TOK, NAME, PARENT);                                 \\\n+  if (!NAME->value.IsBool()) {                                         \\\n+    return Status::Invalid(\"field was not a boolean line \", __LINE__); \\\n   }\n \n-#define RETURN_NOT_INT(TOK, NAME, PARENT) \\\n-  RETURN_NOT_FOUND(TOK, NAME, PARENT);    \\\n-  if (!NAME->value.IsInt()) {             \\\n-    std::stringstream ss;                 \\\n-    ss << \"field was not an int\"          \\\n-       << \" line \" << __LINE__;           \\\n-    return Status::Invalid(ss.str());     \\\n+#define RETURN_NOT_INT(TOK, NAME, PARENT)                           \\\n+  RETURN_NOT_FOUND(TOK, NAME, PARENT);                              \\\n+  if (!NAME->value.IsInt()) {                                       \\\n+    return Status::Invalid(\"field was not an int line \", __LINE__); \\\n   }\n \n-#define RETURN_NOT_ARRAY(TOK, NAME, PARENT) \\\n-  RETURN_NOT_FOUND(TOK, NAME, PARENT);      \\\n-  if (!NAME->value.IsArray()) {             \\\n-    std::stringstream ss;                   \\\n-    ss << \"field was not an array\"          \\\n-       << \" line \" << __LINE__;             \\\n-    return Status::Invalid(ss.str());       \\\n+#define RETURN_NOT_ARRAY(TOK, NAME, PARENT)                           \\\n+  RETURN_NOT_FOUND(TOK, NAME, PARENT);                                \\\n+  if (!NAME->value.IsArray()) {                                       \\\n+    return Status::Invalid(\"field was not an array line \", __LINE__); \\\n   }\n \n-#define RETURN_NOT_OBJECT(TOK, NAME, PARENT) \\\n-  RETURN_NOT_FOUND(TOK, NAME, PARENT);       \\\n-  if (!NAME->value.IsObject()) {             \\\n-    std::stringstream ss;                    \\\n-    ss << \"field was not an object\"          \\\n-       << \" line \" << __LINE__;              \\\n-    return Status::Invalid(ss.str());        \\\n+#define RETURN_NOT_OBJECT(TOK, NAME, PARENT)                           \\\n+  RETURN_NOT_FOUND(TOK, NAME, PARENT);                                 \\\n+  if (!NAME->value.IsObject()) {                                       \\\n+    return Status::Invalid(\"field was not an object line \", __LINE__); \\\n   }\n \n namespace arrow {\ndiff --git a/cpp/src/arrow/ipc/json-simple.cc b/cpp/src/arrow/ipc/json-simple.cc\nindex a8d120036e..d812f841d9 100644\n--- a/cpp/src/arrow/ipc/json-simple.cc\n+++ b/cpp/src/arrow/ipc/json-simple.cc\n@@ -41,9 +41,7 @@ using ::arrow::internal::checked_cast;\n static constexpr auto kParseFlags = rj::kParseFullPrecisionFlag | rj::kParseNanAndInfFlag;\n \n static Status JSONTypeError(const char* expected_type, rj::Type json_type) {\n-  std::stringstream ss;\n-  ss << \"Expected \" << expected_type << \" or null, got type \" << json_type;\n-  return Status::Invalid(ss.str());\n+  return Status::Invalid(\"Expected \", expected_type, \" or null, got type \", json_type);\n }\n \n class Converter {\n@@ -184,9 +182,8 @@ class IntegerConverter final : public ConcreteConverter<IntegerConverter<Type>>\n       if (v == v64) {\n         return builder_->Append(v);\n       } else {\n-        std::stringstream ss;\n-        ss << \"Value \" << v64 << \" out of bounds for \" << this->type_->ToString();\n-        return Status::Invalid(ss.str());\n+        return Status::Invalid(\"Value \", v64, \" out of bounds for \",\n+                               this->type_->ToString());\n       }\n     } else {\n       return JSONTypeError(\"signed int\", json_obj.GetType());\n@@ -203,9 +200,8 @@ class IntegerConverter final : public ConcreteConverter<IntegerConverter<Type>>\n       if (v == v64) {\n         return builder_->Append(v);\n       } else {\n-        std::stringstream ss;\n-        ss << \"Value \" << v64 << \" out of bounds for \" << this->type_->ToString();\n-        return Status::Invalid(ss.str());\n+        return Status::Invalid(\"Value \", v64, \" out of bounds for \",\n+                               this->type_->ToString());\n       }\n       return builder_->Append(v);\n     } else {\n@@ -272,10 +268,8 @@ class DecimalConverter final : public ConcreteConverter<DecimalConverter> {\n       auto view = util::string_view(json_obj.GetString(), json_obj.GetStringLength());\n       RETURN_NOT_OK(Decimal128::FromString(view, &d, &precision, &scale));\n       if (scale != decimal_type_->scale()) {\n-        std::stringstream ss;\n-        ss << \"Invalid scale for decimal: expected \" << decimal_type_->scale() << \", got \"\n-           << scale;\n-        return Status::Invalid(ss.str());\n+        return Status::Invalid(\"Invalid scale for decimal: expected \",\n+                               decimal_type_->scale(), \", got \", scale);\n       }\n       return builder_->Append(d);\n     }\n@@ -390,10 +384,8 @@ class StructConverter final : public ConcreteConverter<StructConverter> {\n       auto size = json_obj.Size();\n       auto expected_size = static_cast<uint32_t>(type_->num_children());\n       if (size != expected_size) {\n-        std::stringstream ss;\n-        ss << \"Expected array of size \" << expected_size << \", got array of size \"\n-           << size;\n-        return Status::Invalid(ss.str());\n+        return Status::Invalid(\"Expected array of size \", expected_size,\n+                               \", got array of size \", size);\n       }\n       for (uint32_t i = 0; i < size; ++i) {\n         RETURN_NOT_OK(child_converters_[i]->AppendValue(json_obj[i]));\n@@ -414,9 +406,8 @@ class StructConverter final : public ConcreteConverter<StructConverter> {\n         }\n       }\n       if (remaining > 0) {\n-        std::stringstream ss;\n-        ss << \"Unexpected members in JSON object for type \" << type_->ToString();\n-        return Status::Invalid(ss.str());\n+        return Status::Invalid(\"Unexpected members in JSON object for type \",\n+                               type_->ToString());\n       }\n       return builder_->Append();\n     }\n@@ -460,9 +451,8 @@ Status GetConverter(const std::shared_ptr<DataType>& type,\n     SIMPLE_CONVERTER_CASE(Type::STRING, StringConverter)\n     SIMPLE_CONVERTER_CASE(Type::DECIMAL, DecimalConverter)\n     default: {\n-      std::stringstream ss;\n-      ss << \"JSON conversion to \" << type->ToString() << \" not implemented\";\n-      return Status::NotImplemented(ss.str());\n+      return Status::NotImplemented(\"JSON conversion to \", type->ToString(),\n+                                    \" not implemented\");\n     }\n   }\n \n@@ -481,10 +471,8 @@ Status ArrayFromJSON(const std::shared_ptr<DataType>& type,\n   rj::Document json_doc;\n   json_doc.Parse<kParseFlags>(json_string.data(), json_string.length());\n   if (json_doc.HasParseError()) {\n-    std::stringstream ss;\n-    ss << \"JSON parse error at offset \" << json_doc.GetErrorOffset() << \": \"\n-       << GetParseError_En(json_doc.GetParseError());\n-    return Status::Invalid(ss.str());\n+    return Status::Invalid(\"JSON parse error at offset \", json_doc.GetErrorOffset(), \": \",\n+                           GetParseError_En(json_doc.GetParseError()));\n   }\n \n   // The JSON document should be an array, append it\ndiff --git a/cpp/src/arrow/ipc/message.cc b/cpp/src/arrow/ipc/message.cc\nindex 724e6255cb..8adf4a8b66 100644\n--- a/cpp/src/arrow/ipc/message.cc\n+++ b/cpp/src/arrow/ipc/message.cc\n@@ -153,10 +153,8 @@ Status Message::ReadFrom(const std::shared_ptr<Buffer>& metadata, io::InputStrea\n   std::shared_ptr<Buffer> body;\n   RETURN_NOT_OK(stream->Read(body_length, &body));\n   if (body->size() < body_length) {\n-    std::stringstream ss;\n-    ss << \"Expected to be able to read \" << body_length << \" bytes for message body, got \"\n-       << body->size();\n-    return Status::IOError(ss.str());\n+    return Status::IOError(\"Expected to be able to read \", body_length,\n+                           \" bytes for message body, got \", body->size());\n   }\n \n   return Message::Open(metadata, body, out);\n@@ -171,10 +169,8 @@ Status Message::ReadFrom(const int64_t offset, const std::shared_ptr<Buffer>& me\n   std::shared_ptr<Buffer> body;\n   RETURN_NOT_OK(file->ReadAt(offset, body_length, &body));\n   if (body->size() < body_length) {\n-    std::stringstream ss;\n-    ss << \"Expected to be able to read \" << body_length << \" bytes for message body, got \"\n-       << body->size();\n-    return Status::IOError(ss.str());\n+    return Status::IOError(\"Expected to be able to read \", body_length,\n+                           \" bytes for message body, got \", body->size());\n   }\n \n   return Message::Open(metadata, body, out);\n@@ -238,19 +234,16 @@ Status ReadMessage(int64_t offset, int32_t metadata_length, io::RandomAccessFile\n   RETURN_NOT_OK(file->ReadAt(offset, metadata_length, &buffer));\n \n   if (buffer->size() < metadata_length) {\n-    std::stringstream ss;\n-    ss << \"Expected to read \" << metadata_length << \" metadata bytes but got \"\n-       << buffer->size();\n-    return Status::Invalid(ss.str());\n+    return Status::Invalid(\"Expected to read \", metadata_length,\n+                           \" metadata bytes but got \", buffer->size());\n   }\n \n   int32_t flatbuffer_size = *reinterpret_cast<const int32_t*>(buffer->data());\n \n   if (flatbuffer_size + static_cast<int>(sizeof(int32_t)) > metadata_length) {\n-    std::stringstream ss;\n-    ss << \"flatbuffer size \" << metadata_length << \" invalid. File offset: \" << offset\n-       << \", metadata length: \" << metadata_length;\n-    return Status::Invalid(ss.str());\n+    return Status::Invalid(\"flatbuffer size \", metadata_length,\n+                           \" invalid. File offset: \", offset,\n+                           \", metadata length: \", metadata_length);\n   }\n \n   auto metadata = SliceBuffer(buffer, 4, buffer->size() - 4);\n@@ -303,10 +296,8 @@ Status ReadMessage(io::InputStream* file, std::unique_ptr<Message>* message) {\n   std::shared_ptr<Buffer> metadata;\n   RETURN_NOT_OK(file->Read(message_length, &metadata));\n   if (metadata->size() != message_length) {\n-    std::stringstream ss;\n-    ss << \"Expected to read \" << message_length << \" metadata bytes, but \"\n-       << \"only read \" << metadata->size();\n-    return Status::Invalid(ss.str());\n+    return Status::Invalid(\"Expected to read \", message_length, \" metadata bytes, but \",\n+                           \"only read \", metadata->size());\n   }\n \n   return Message::ReadFrom(metadata, file, message);\ndiff --git a/cpp/src/arrow/ipc/metadata-internal.cc b/cpp/src/arrow/ipc/metadata-internal.cc\nindex ef189c8ae6..1d4c80c294 100644\n--- a/cpp/src/arrow/ipc/metadata-internal.cc\n+++ b/cpp/src/arrow/ipc/metadata-internal.cc\n@@ -443,9 +443,7 @@ static Status TypeToFlatbuffer(FBB& fbb, const DataType& type,\n       return UnionToFlatBuffer(fbb, *value_type, children, dictionary_memo, offset);\n     default:\n       *out_type = flatbuf::Type_NONE;  // Make clang-tidy happy\n-      std::stringstream ss;\n-      ss << \"Unable to convert type: \" << type.ToString() << std::endl;\n-      return Status::NotImplemented(ss.str());\n+      return Status::NotImplemented(\"Unable to convert type: \", type.ToString());\n   }\n   return Status::OK();\n }\n@@ -483,9 +481,7 @@ static Status TensorTypeToFlatbuffer(FBB& fbb, const DataType& type,\n       break;\n     default:\n       *out_type = flatbuf::Type_NONE;  // Make clang-tidy happy\n-      std::stringstream ss;\n-      ss << \"Unable to convert type: \" << type.ToString() << std::endl;\n-      return Status::NotImplemented(ss.str());\n+      return Status::NotImplemented(\"Unable to convert type: \", type.ToString());\n   }\n   return Status::OK();\n }\ndiff --git a/cpp/src/arrow/ipc/reader.cc b/cpp/src/arrow/ipc/reader.cc\nindex 65f5d963e8..b2c26767be 100644\n--- a/cpp/src/arrow/ipc/reader.cc\n+++ b/cpp/src/arrow/ipc/reader.cc\n@@ -225,9 +225,7 @@ class ArrayLoader {\n \n     const int num_children = type.num_children();\n     if (num_children != 1) {\n-      std::stringstream ss;\n-      ss << \"Wrong number of children: \" << num_children;\n-      return Status::Invalid(ss.str());\n+      return Status::Invalid(\"Wrong number of children: \", num_children);\n     }\n \n     return LoadChildren(type.children());\n@@ -343,9 +341,7 @@ Status ReadDictionary(const Buffer& metadata, const DictionaryTypeMap& dictionar\n   int64_t id = *dictionary_id = dictionary_batch->id();\n   auto it = dictionary_types.find(id);\n   if (it == dictionary_types.end()) {\n-    std::stringstream ss;\n-    ss << \"Do not have type metadata for dictionary with id: \" << id;\n-    return Status::KeyError(ss.str());\n+    return Status::KeyError(\"Do not have type metadata for dictionary with id: \", id);\n   }\n \n   std::vector<std::shared_ptr<Field>> fields = {it->second};\n@@ -372,10 +368,8 @@ static Status ReadMessageAndValidate(MessageReader* reader, Message::Type expect\n   RETURN_NOT_OK(reader->ReadNextMessage(message));\n \n   if (!(*message) && !allow_null) {\n-    std::stringstream ss;\n-    ss << \"Expected \" << FormatMessageType(expected_type)\n-       << \" message in stream, was null or length 0\";\n-    return Status::Invalid(ss.str());\n+    return Status::Invalid(\"Expected \", FormatMessageType(expected_type),\n+                           \" message in stream, was null or length 0\");\n   }\n \n   if ((*message) == nullptr) {\n@@ -383,10 +377,9 @@ static Status ReadMessageAndValidate(MessageReader* reader, Message::Type expect\n   }\n \n   if ((*message)->type() != expected_type) {\n-    std::stringstream ss;\n-    ss << \"Message not expected type: \" << FormatMessageType(expected_type)\n-       << \", was: \" << (*message)->type();\n-    return Status::IOError(ss.str());\n+    return Status::IOError(\n+        \"Message not expected type: \", FormatMessageType(expected_type),\n+        \", was: \", (*message)->type());\n   }\n   return Status::OK();\n }\n@@ -512,9 +505,7 @@ class RecordBatchFileReader::RecordBatchFileReaderImpl {\n     int magic_size = static_cast<int>(strlen(kArrowMagicBytes));\n \n     if (footer_offset_ <= magic_size * 2 + 4) {\n-      std::stringstream ss;\n-      ss << \"File is too small: \" << footer_offset_;\n-      return Status::Invalid(ss.str());\n+      return Status::Invalid(\"File is too small: \", footer_offset_);\n     }\n \n     std::shared_ptr<Buffer> buffer;\n@@ -523,9 +514,7 @@ class RecordBatchFileReader::RecordBatchFileReaderImpl {\n \n     const int64_t expected_footer_size = magic_size + sizeof(int32_t);\n     if (buffer->size() < expected_footer_size) {\n-      std::stringstream ss;\n-      ss << \"Unable to read \" << expected_footer_size << \"from end of file\";\n-      return Status::Invalid(ss.str());\n+      return Status::Invalid(\"Unable to read \", expected_footer_size, \"from end of file\");\n     }\n \n     if (memcmp(buffer->data() + sizeof(int32_t), kArrowMagicBytes, magic_size)) {\ndiff --git a/cpp/src/arrow/memory_pool.cc b/cpp/src/arrow/memory_pool.cc\nindex d62db32b06..fb5beacf0f 100644\n--- a/cpp/src/arrow/memory_pool.cc\n+++ b/cpp/src/arrow/memory_pool.cc\n@@ -55,31 +55,23 @@ Status AllocateAligned(int64_t size, uint8_t** out) {\n   *out =\n       reinterpret_cast<uint8_t*>(_aligned_malloc(static_cast<size_t>(size), kAlignment));\n   if (!*out) {\n-    std::stringstream ss;\n-    ss << \"malloc of size \" << size << \" failed\";\n-    return Status::OutOfMemory(ss.str());\n+    return Status::OutOfMemory(\"malloc of size \", size, \" failed\");\n   }\n #elif defined(ARROW_JEMALLOC)\n   *out = reinterpret_cast<uint8_t*>(mallocx(\n       std::max(static_cast<size_t>(size), kAlignment), MALLOCX_ALIGN(kAlignment)));\n   if (*out == NULL) {\n-    std::stringstream ss;\n-    ss << \"malloc of size \" << size << \" failed\";\n-    return Status::OutOfMemory(ss.str());\n+    return Status::OutOfMemory(\"malloc of size \", size, \" failed\");\n   }\n #else\n   const int result = posix_memalign(reinterpret_cast<void**>(out), kAlignment,\n                                     static_cast<size_t>(size));\n   if (result == ENOMEM) {\n-    std::stringstream ss;\n-    ss << \"malloc of size \" << size << \" failed\";\n-    return Status::OutOfMemory(ss.str());\n+    return Status::OutOfMemory(\"malloc of size \", size, \" failed\");\n   }\n \n   if (result == EINVAL) {\n-    std::stringstream ss;\n-    ss << \"invalid alignment parameter: \" << kAlignment;\n-    return Status::Invalid(ss.str());\n+    return Status::Invalid(\"invalid alignment parameter: \", kAlignment);\n   }\n #endif\n   return Status::OK();\n@@ -118,10 +110,8 @@ class DefaultMemoryPool : public MemoryPool {\n     *ptr = reinterpret_cast<uint8_t*>(\n         rallocx(*ptr, static_cast<size_t>(new_size), MALLOCX_ALIGN(kAlignment)));\n     if (*ptr == NULL) {\n-      std::stringstream ss;\n-      ss << \"realloc of size \" << new_size << \" failed\";\n       *ptr = previous_ptr;\n-      return Status::OutOfMemory(ss.str());\n+      return Status::OutOfMemory(\"realloc of size \", new_size, \" failed\");\n     }\n #else\n     // Note: We cannot use realloc() here as it doesn't guarantee alignment.\ndiff --git a/cpp/src/arrow/python/arrow_to_pandas.cc b/cpp/src/arrow/python/arrow_to_pandas.cc\nindex 3e04f2727e..29d64355bd 100644\n--- a/cpp/src/arrow/python/arrow_to_pandas.cc\n+++ b/cpp/src/arrow/python/arrow_to_pandas.cc\n@@ -414,9 +414,7 @@ inline Status ConvertBinaryLike(PandasOptions options, const ChunkedArray& data,\n         *out_values = WrapBytes<ArrayType>::Wrap(view.data(), view.length());\n         if (*out_values == nullptr) {\n           PyErr_Clear();\n-          std::stringstream ss;\n-          ss << \"Wrapping \" << view << \" failed\";\n-          return Status::UnknownError(ss.str());\n+          return Status::UnknownError(\"Wrapping \", view, \" failed\");\n         }\n       }\n       ++out_values;\n@@ -773,18 +771,16 @@ class ObjectBlock : public PandasBlock {\n         CONVERTLISTSLIKE_CASE(ListType, LIST)\n         CONVERTLISTSLIKE_CASE(NullType, NA)\n         default: {\n-          std::stringstream ss;\n-          ss << \"Not implemented type for conversion from List to Pandas ObjectBlock: \"\n-             << list_type->value_type()->ToString();\n-          return Status::NotImplemented(ss.str());\n+          return Status::NotImplemented(\n+              \"Not implemented type for conversion from List to Pandas ObjectBlock: \",\n+              list_type->value_type()->ToString());\n         }\n       }\n     } else if (type == Type::STRUCT) {\n       RETURN_NOT_OK(ConvertStruct(options_, data, out_buffer));\n     } else {\n-      std::stringstream ss;\n-      ss << \"Unsupported type for object array output: \" << col->type()->ToString();\n-      return Status::NotImplemented(ss.str());\n+      return Status::NotImplemented(\"Unsupported type for object array output: \",\n+                                    col->type()->ToString());\n     }\n \n     placement_data_[rel_placement] = abs_placement;\n@@ -810,10 +806,9 @@ class IntBlock : public PandasBlock {\n     const ChunkedArray& data = *col->data().get();\n \n     if (type != ARROW_TYPE) {\n-      std::stringstream ss;\n-      ss << \"Cannot write Arrow data of type \" << col->type()->ToString();\n-      ss << \" to a Pandas int\" << sizeof(C_TYPE) << \" block.\";\n-      return Status::NotImplemented(ss.str());\n+      return Status::NotImplemented(\"Cannot write Arrow data of type \",\n+                                    col->type()->ToString(), \" to a Pandas int\",\n+                                    sizeof(C_TYPE), \" block\");\n     }\n \n     ConvertIntegerNoNullsSameType<C_TYPE>(options_, data, out_buffer);\n@@ -841,10 +836,9 @@ class Float16Block : public PandasBlock {\n     Type::type type = col->type()->id();\n \n     if (type != Type::HALF_FLOAT) {\n-      std::stringstream ss;\n-      ss << \"Cannot write Arrow data of type \" << col->type()->ToString();\n-      ss << \" to a Pandas float16 block.\";\n-      return Status::NotImplemented(ss.str());\n+      return Status::NotImplemented(\"Cannot write Arrow data of type \",\n+                                    col->type()->ToString(),\n+                                    \" to a Pandas float16 block\");\n     }\n \n     npy_half* out_buffer =\n@@ -866,10 +860,9 @@ class Float32Block : public PandasBlock {\n     Type::type type = col->type()->id();\n \n     if (type != Type::FLOAT) {\n-      std::stringstream ss;\n-      ss << \"Cannot write Arrow data of type \" << col->type()->ToString();\n-      ss << \" to a Pandas float32 block.\";\n-      return Status::NotImplemented(ss.str());\n+      return Status::NotImplemented(\"Cannot write Arrow data of type \",\n+                                    col->type()->ToString(),\n+                                    \" to a Pandas float32 block\");\n     }\n \n     float* out_buffer = reinterpret_cast<float*>(block_data_) + rel_placement * num_rows_;\n@@ -922,10 +915,9 @@ class Float64Block : public PandasBlock {\n         ConvertNumericNullable<double>(data, NAN, out_buffer);\n         break;\n       default:\n-        std::stringstream ss;\n-        ss << \"Cannot write Arrow data of type \" << col->type()->ToString();\n-        ss << \" to a Pandas float64 block.\";\n-        return Status::NotImplemented(ss.str());\n+        return Status::NotImplemented(\"Cannot write Arrow data of type \",\n+                                      col->type()->ToString(),\n+                                      \" to a Pandas float64 block\");\n     }\n \n #undef INTEGER_CASE\n@@ -945,10 +937,9 @@ class BoolBlock : public PandasBlock {\n     Type::type type = col->type()->id();\n \n     if (type != Type::BOOL) {\n-      std::stringstream ss;\n-      ss << \"Cannot write Arrow data of type \" << col->type()->ToString();\n-      ss << \" to a Pandas boolean block.\";\n-      return Status::NotImplemented(ss.str());\n+      return Status::NotImplemented(\"Cannot write Arrow data of type \",\n+                                    col->type()->ToString(),\n+                                    \" to a Pandas boolean block\");\n     }\n \n     uint8_t* out_buffer =\n@@ -1006,10 +997,9 @@ class DatetimeBlock : public PandasBlock {\n         return Status::NotImplemented(\"Unsupported time unit\");\n       }\n     } else {\n-      std::stringstream ss;\n-      ss << \"Cannot write Arrow data of type \" << col->type()->ToString();\n-      ss << \" to a Pandas datetime block.\";\n-      return Status::NotImplemented(ss.str());\n+      return Status::NotImplemented(\"Cannot write Arrow data of type \",\n+                                    col->type()->ToString(),\n+                                    \" to a Pandas datetime block.\");\n     }\n \n     placement_data_[rel_placement] = abs_placement;\n@@ -1075,9 +1065,8 @@ class CategoricalBlock : public PandasBlock {\n       const T* values = arr.raw_values();\n       for (int64_t i = 0; i < arr.length(); ++i) {\n         if (arr.IsValid(i) && (values[i] < 0 || values[i] >= dict_length)) {\n-          std::stringstream ss;\n-          ss << \"Out of bounds dictionary index: \" << static_cast<int64_t>(values[i]);\n-          return Status::Invalid(ss.str());\n+          return Status::Invalid(\"Out of bounds dictionary index: \",\n+                                 static_cast<int64_t>(values[i]));\n         }\n       }\n       return Status::OK();\n@@ -1088,16 +1077,15 @@ class CategoricalBlock : public PandasBlock {\n       RETURN_NOT_OK(AllocateNDArrayFromIndices<T>(npy_type, indices_first));\n     } else {\n       if (options_.zero_copy_only) {\n-        std::stringstream ss;\n         if (needs_copy_) {\n-          ss << \"Need to allocate categorical memory, \"\n-             << \"but only zero-copy conversions allowed.\";\n-        } else {\n-          ss << \"Needed to copy \" << data.num_chunks() << \" chunks with \"\n-             << indices_first->null_count()\n-             << \" indices nulls, but zero_copy_only was True\";\n+          return Status::Invalid(\"Need to allocate categorical memory, but \",\n+                                 \"only zero-copy conversions \"\n+                                 \"allowed\");\n         }\n-        return Status::Invalid(ss.str());\n+\n+        return Status::Invalid(\"Needed to copy \", data.num_chunks(), \" chunks with \",\n+                               indices_first->null_count(),\n+                               \" indices nulls, but zero_copy_only was True\");\n       }\n       RETURN_NOT_OK(AllocateNDArray(npy_type, 1));\n \n@@ -1155,10 +1143,8 @@ class CategoricalBlock : public PandasBlock {\n         RETURN_NOT_OK(WriteIndices<Int64Type>(converted_col));\n         break;\n       default: {\n-        std::stringstream ss;\n-        ss << \"Categorical index type not supported: \"\n-           << dict_type.index_type()->ToString();\n-        return Status::NotImplemented(ss.str());\n+        return Status::NotImplemented(\"Categorical index type not supported: \",\n+                                      dict_type.index_type()->ToString());\n       }\n     }\n \n@@ -1349,10 +1335,8 @@ static Status GetPandasBlockType(const Column& col, const PandasOptions& options\n     case Type::LIST: {\n       auto list_type = std::static_pointer_cast<ListType>(col.type());\n       if (!ListTypeSupported(*list_type->value_type())) {\n-        std::stringstream ss;\n-        ss << \"Not implemented type for list in DataFrameBlock: \"\n-           << list_type->value_type()->ToString();\n-        return Status::NotImplemented(ss.str());\n+        return Status::NotImplemented(\"Not implemented type for list in DataFrameBlock: \",\n+                                      list_type->value_type()->ToString());\n       }\n       *output_type = PandasBlock::OBJECT;\n     } break;\n@@ -1360,10 +1344,9 @@ static Status GetPandasBlockType(const Column& col, const PandasOptions& options\n       *output_type = PandasBlock::CATEGORICAL;\n       break;\n     default:\n-      std::stringstream ss;\n-      ss << \"No known equivalent Pandas block for Arrow data of type \";\n-      ss << col.type()->ToString() << \" is known.\";\n-      return Status::NotImplemented(ss.str());\n+      return Status::NotImplemented(\n+          \"No known equivalent Pandas block for Arrow data of type \",\n+          col.type()->ToString(), \" is known.\");\n   }\n   return Status::OK();\n }\n@@ -1657,10 +1640,8 @@ class ArrowDeserializer {\n     if (data_.num_chunks() == 1 && data_.null_count() == 0) {\n       return ConvertValuesZeroCopy<TYPE>(options_, npy_type, data_.chunk(0));\n     } else if (options_.zero_copy_only) {\n-      std::stringstream ss;\n-      ss << \"Needed to copy \" << data_.num_chunks() << \" chunks with \"\n-         << data_.null_count() << \" nulls, but zero_copy_only was True\";\n-      return Status::Invalid(ss.str());\n+      return Status::Invalid(\"Needed to copy \", data_.num_chunks(), \" chunks with \",\n+                             data_.null_count(), \" nulls, but zero_copy_only was True\");\n     }\n \n     RETURN_NOT_OK(AllocateOutput(npy_type));\n@@ -1751,10 +1732,8 @@ class ArrowDeserializer {\n     if (data_.num_chunks() == 1 && data_.null_count() == 0) {\n       return ConvertValuesZeroCopy<TYPE>(options_, traits::npy_type, data_.chunk(0));\n     } else if (options_.zero_copy_only) {\n-      std::stringstream ss;\n-      ss << \"Needed to copy \" << data_.num_chunks() << \" chunks with \"\n-         << data_.null_count() << \" nulls, but zero_copy_only was True\";\n-      return Status::Invalid(ss.str());\n+      return Status::Invalid(\"Needed to copy \", data_.num_chunks(), \" chunks with \",\n+                             data_.null_count(), \" nulls, but zero_copy_only was True\");\n     }\n \n     if (data_.null_count() > 0) {\n@@ -1854,9 +1833,8 @@ class ArrowDeserializer {\n       CONVERTVALUES_LISTSLIKE_CASE(Decimal128Type, DECIMAL)\n       CONVERTVALUES_LISTSLIKE_CASE(ListType, LIST)\n       default: {\n-        std::stringstream ss;\n-        ss << \"Not implemented type for lists: \" << list_type->value_type()->ToString();\n-        return Status::NotImplemented(ss.str());\n+        return Status::NotImplemented(\"Not implemented type for lists: \",\n+                                      list_type->value_type()->ToString());\n       }\n     }\n #undef CONVERTVALUES_LISTSLIKE_CASE\ndiff --git a/cpp/src/arrow/python/common.h b/cpp/src/arrow/python/common.h\nindex 6587bd328f..6e41beddd1 100644\n--- a/cpp/src/arrow/python/common.h\n+++ b/cpp/src/arrow/python/common.h\n@@ -215,10 +215,8 @@ struct PyBytesView {\n       this->ref.reset();\n       return Status::OK();\n     } else {\n-      std::stringstream ss;\n-      ss << \"Expected \" << expected_msg << \", got a '\" << Py_TYPE(obj)->tp_name\n-         << \"' object\";\n-      return Status::TypeError(ss.str());\n+      return Status::TypeError(\"Expected \", expected_msg, \", got a '\",\n+                               Py_TYPE(obj)->tp_name, \"' object\");\n     }\n   }\n \ndiff --git a/cpp/src/arrow/python/decimal.cc b/cpp/src/arrow/python/decimal.cc\nindex 051f31faac..8db7c01b9a 100644\n--- a/cpp/src/arrow/python/decimal.cc\n+++ b/cpp/src/arrow/python/decimal.cc\n@@ -125,11 +125,9 @@ Status DecimalFromPythonDecimal(PyObject* python_decimal, const DecimalType& arr\n   const int32_t scale = arrow_type.scale();\n \n   if (ARROW_PREDICT_FALSE(inferred_precision > precision)) {\n-    std::stringstream buf;\n-    buf << \"Decimal type with precision \" << inferred_precision\n-        << \" does not fit into precision inferred from first array element: \"\n-        << precision;\n-    return Status::Invalid(buf.str());\n+    return Status::Invalid(\n+        \"Decimal type with precision \", inferred_precision,\n+        \" does not fit into precision inferred from first array element: \", precision);\n   }\n \n   if (scale != inferred_scale) {\ndiff --git a/cpp/src/arrow/python/helpers.cc b/cpp/src/arrow/python/helpers.cc\nindex 2f43db6505..28ed1a6c36 100644\n--- a/cpp/src/arrow/python/helpers.cc\n+++ b/cpp/src/arrow/python/helpers.cc\n@@ -164,11 +164,10 @@ namespace {\n \n Status IntegerOverflowStatus(PyObject* obj, const std::string& overflow_message) {\n   if (overflow_message.empty()) {\n-    std::stringstream ss;\n     std::string obj_as_stdstring;\n     RETURN_NOT_OK(PyObject_StdStringStr(obj, &obj_as_stdstring));\n-    ss << \"Value \" << obj_as_stdstring << \" too large to fit in C integer type\";\n-    return Status::Invalid(ss.str());\n+    return Status::Invalid(\"Value \", obj_as_stdstring,\n+                           \" too large to fit in C integer type\");\n   } else {\n     return Status::Invalid(overflow_message);\n   }\n@@ -299,13 +298,10 @@ bool PandasObjectIsNull(PyObject* obj) {\n }\n \n Status InvalidValue(PyObject* obj, const std::string& why) {\n-  std::stringstream ss;\n-\n   std::string obj_as_str;\n   RETURN_NOT_OK(internal::PyObject_StdStringStr(obj, &obj_as_str));\n-  ss << \"Could not convert \" << obj_as_str << \" with type \" << Py_TYPE(obj)->tp_name\n-     << \": \" << why;\n-  return Status::Invalid(ss.str());\n+  return Status::Invalid(\"Could not convert \", obj_as_str, \" with type \",\n+                         Py_TYPE(obj)->tp_name, \": \", why);\n }\n \n Status UnboxIntegerAsInt64(PyObject* obj, int64_t* out) {\n@@ -355,10 +351,8 @@ Status IntegerScalarToDoubleSafe(PyObject* obj, double* out) {\n   constexpr int64_t kDoubleMin = -(1LL << 53);\n \n   if (value < kDoubleMin || value > kDoubleMax) {\n-    std::stringstream ss;\n-    ss << \"Integer value \" << value << \" is outside of the range exactly\"\n-       << \" representable by a IEEE 754 double precision value\";\n-    return Status::Invalid(ss.str());\n+    return Status::Invalid(\"Integer value \", value, \" is outside of the range exactly\",\n+                           \" representable by a IEEE 754 double precision value\");\n   }\n   *out = static_cast<double>(value);\n   return Status::OK();\n@@ -372,10 +366,8 @@ Status IntegerScalarToFloat32Safe(PyObject* obj, float* out) {\n   constexpr int64_t kFloatMin = -(1LL << 24);\n \n   if (value < kFloatMin || value > kFloatMax) {\n-    std::stringstream ss;\n-    ss << \"Integer value \" << value << \" is outside of the range exactly\"\n-       << \" representable by a IEEE 754 single precision value\";\n-    return Status::Invalid(ss.str());\n+    return Status::Invalid(\"Integer value \", value, \" is outside of the range exactly\",\n+                           \" representable by a IEEE 754 single precision value\");\n   }\n   *out = static_cast<float>(value);\n   return Status::OK();\ndiff --git a/cpp/src/arrow/python/inference.cc b/cpp/src/arrow/python/inference.cc\nindex 0f1d85ead2..c9db5f4f28 100644\n--- a/cpp/src/arrow/python/inference.cc\n+++ b/cpp/src/arrow/python/inference.cc\n@@ -58,10 +58,9 @@ class NumPyDtypeUnifier {\n   NumPyDtypeUnifier() : current_type_num_(-1), current_dtype_(NULLPTR) {}\n \n   Status InvalidMix(int new_dtype) {\n-    std::stringstream ss;\n-    ss << \"Cannot mix NumPy dtypes \" << GetNumPyTypeName(current_type_num_) << \" and \"\n-       << GetNumPyTypeName(new_dtype);\n-    return Status::Invalid(ss.str());\n+    return Status::Invalid(\"Cannot mix NumPy dtypes \",\n+                           GetNumPyTypeName(current_type_num_), \" and \",\n+                           GetNumPyTypeName(new_dtype));\n   }\n \n   int Observe_BOOL(PyArray_Descr* descr, int dtype) { return INVALID; }\n@@ -250,9 +249,7 @@ class NumPyDtypeUnifier {\n         action = Observe_DATETIME(descr);\n         break;\n       default:\n-        std::stringstream ss;\n-        ss << \"Unsupported numpy type \" << GetNumPyTypeName(dtype) << std::endl;\n-        return Status::NotImplemented(ss.str());\n+        return Status::NotImplemented(\"Unsupported numpy type \", GetNumPyTypeName(dtype));\n     }\n \n     if (action == INVALID) {\n@@ -480,10 +477,8 @@ class TypeInferrer {\n       } else if (PyBytes_Check(key_obj)) {\n         key = internal::PyBytes_AsStdString(key_obj);\n       } else {\n-        std::stringstream ss;\n-        ss << \"Expected dict key of type str or bytes, got '\" << Py_TYPE(key_obj)->tp_name\n-           << \"'\";\n-        return Status::TypeError(ss.str());\n+        return Status::TypeError(\"Expected dict key of type str or bytes, got '\",\n+                                 Py_TYPE(key_obj)->tp_name, \"'\");\n       }\n       // Get or create visitor for this key\n       auto it = struct_inferrers_.find(key);\ndiff --git a/cpp/src/arrow/python/numpy-internal.h b/cpp/src/arrow/python/numpy-internal.h\nindex 463795a210..6954e35c3e 100644\n--- a/cpp/src/arrow/python/numpy-internal.h\n+++ b/cpp/src/arrow/python/numpy-internal.h\n@@ -143,9 +143,8 @@ inline Status VisitNumpyArrayInline(PyArrayObject* arr, VISITOR* visitor) {\n     TYPE_VISIT_INLINE(DATETIME);\n     TYPE_VISIT_INLINE(OBJECT);\n   }\n-  std::stringstream ss;\n-  ss << \"NumPy type not implemented: \" << GetNumPyTypeName(PyArray_TYPE(arr));\n-  return Status::NotImplemented(ss.str());\n+  return Status::NotImplemented(\"NumPy type not implemented: \",\n+                                GetNumPyTypeName(PyArray_TYPE(arr)));\n }\n \n #undef TYPE_VISIT_INLINE\ndiff --git a/cpp/src/arrow/python/numpy_convert.cc b/cpp/src/arrow/python/numpy_convert.cc\nindex d95e337a48..c73e0bc15c 100644\n--- a/cpp/src/arrow/python/numpy_convert.cc\n+++ b/cpp/src/arrow/python/numpy_convert.cc\n@@ -92,9 +92,7 @@ Status GetTensorType(PyObject* dtype, std::shared_ptr<DataType>* out) {\n     TO_ARROW_TYPE_CASE(FLOAT32, float32);\n     TO_ARROW_TYPE_CASE(FLOAT64, float64);\n     default: {\n-      std::stringstream ss;\n-      ss << \"Unsupported numpy type \" << descr->type_num << std::endl;\n-      return Status::NotImplemented(ss.str());\n+      return Status::NotImplemented(\"Unsupported numpy type \", descr->type_num);\n     }\n   }\n   return Status::OK();\n@@ -119,9 +117,7 @@ Status GetNumPyType(const DataType& type, int* type_num) {\n     NUMPY_TYPE_CASE(FLOAT, FLOAT32);\n     NUMPY_TYPE_CASE(DOUBLE, FLOAT64);\n     default: {\n-      std::stringstream ss;\n-      ss << \"Unsupported tensor type: \" << type.ToString() << std::endl;\n-      return Status::NotImplemented(ss.str());\n+      return Status::NotImplemented(\"Unsupported tensor type: \", type.ToString());\n     }\n   }\n #undef NUMPY_TYPE_CASE\n@@ -181,9 +177,7 @@ Status NumPyDtypeToArrow(PyArray_Descr* descr, std::shared_ptr<DataType>* out) {\n       }\n     } break;\n     default: {\n-      std::stringstream ss;\n-      ss << \"Unsupported numpy type \" << descr->type_num << std::endl;\n-      return Status::NotImplemented(ss.str());\n+      return Status::NotImplemented(\"Unsupported numpy type \", descr->type_num);\n     }\n   }\n \ndiff --git a/cpp/src/arrow/python/numpy_to_arrow.cc b/cpp/src/arrow/python/numpy_to_arrow.cc\nindex da288d3c68..461a085722 100644\n--- a/cpp/src/arrow/python/numpy_to_arrow.cc\n+++ b/cpp/src/arrow/python/numpy_to_arrow.cc\n@@ -283,9 +283,8 @@ class NumPyConverter {\n   }\n \n   Status TypeNotImplemented(std::string type_name) {\n-    std::stringstream ss;\n-    ss << \"NumPyConverter doesn't implement <\" << type_name << \"> conversion. \";\n-    return Status::NotImplemented(ss.str());\n+    return Status::NotImplemented(\"NumPyConverter doesn't implement <\", type_name,\n+                                  \"> conversion. \");\n   }\n \n   MemoryPool* pool_;\n@@ -574,9 +573,8 @@ Status NumPyConverter::Visit(const FixedSizeBinaryType& type) {\n   auto byte_width = type.byte_width();\n \n   if (itemsize_ != byte_width) {\n-    std::stringstream ss;\n-    ss << \"Got bytestring of length \" << itemsize_ << \" (expected \" << byte_width << \")\";\n-    return Status::Invalid(ss.str());\n+    return Status::Invalid(\"Got bytestring of length \", itemsize_, \" (expected \",\n+                           byte_width, \")\");\n   }\n \n   FixedSizeBinaryBuilder builder(::arrow::fixed_size_binary(byte_width), pool_);\n@@ -651,9 +649,8 @@ Status NumPyConverter::Visit(const StringType& type) {\n       if (ARROW_PREDICT_TRUE(util::ValidateUTF8(data, itemsize_))) {\n         return builder.Append(data, itemsize_);\n       } else {\n-        std::stringstream ss;\n-        ss << \"Encountered non-UTF8 binary value: \" << HexEncode(data, itemsize_);\n-        return Status::Invalid(ss.str());\n+        return Status::Invalid(\"Encountered non-UTF8 binary value: \",\n+                               HexEncode(data, itemsize_));\n       }\n     } else {\n       return AppendUTF32(reinterpret_cast<const char*>(data), itemsize_, byteorder,\n@@ -697,9 +694,7 @@ Status NumPyConverter::Visit(const StructType& type) {\n     for (auto field : type.children()) {\n       PyObject* tup = PyDict_GetItemString(dtype_->fields, field->name().c_str());\n       if (tup == NULL) {\n-        std::stringstream ss;\n-        ss << \"Missing field '\" << field->name() << \"' in struct array\";\n-        return Status::TypeError(ss.str());\n+        return Status::TypeError(\"Missing field '\", field->name(), \"' in struct array\");\n       }\n       PyArray_Descr* sub_dtype =\n           reinterpret_cast<PyArray_Descr*>(PyTuple_GET_ITEM(tup, 0));\ndiff --git a/cpp/src/arrow/python/python_to_arrow.cc b/cpp/src/arrow/python/python_to_arrow.cc\nindex a77cebc7e7..f5e6a57760 100644\n--- a/cpp/src/arrow/python/python_to_arrow.cc\n+++ b/cpp/src/arrow/python/python_to_arrow.cc\n@@ -402,10 +402,7 @@ class TimestampConverter : public TypedConverter<TimestampType, TimestampConvert\n       std::shared_ptr<DataType> type;\n       RETURN_NOT_OK(NumPyDtypeToArrow(PyArray_DescrFromScalar(obj), &type));\n       if (type->id() != Type::TIMESTAMP) {\n-        std::ostringstream ss;\n-        ss << \"Expected np.datetime64 but got: \";\n-        ss << type->ToString();\n-        return Status::Invalid(ss.str());\n+        return Status::Invalid(\"Expected np.datetime64 but got: \", type->ToString());\n       }\n       const TimestampType& ttype = checked_cast<const TimestampType&>(*type);\n       if (unit_ != ttype.unit()) {\n@@ -705,10 +702,7 @@ Status ListConverter::AppendNdarrayItem(PyObject* obj) {\n       return value_converter_->AppendSingleVirtual(obj);\n     }\n     default: {\n-      std::stringstream ss;\n-      ss << \"Unknown list item type: \";\n-      ss << value_type_->ToString();\n-      return Status::TypeError(ss.str());\n+      return Status::TypeError(\"Unknown list item type: \", value_type_->ToString());\n     }\n   }\n }\n@@ -911,9 +905,8 @@ Status GetConverter(const std::shared_ptr<DataType>& type, bool from_pandas,\n           new StructConverter(from_pandas, strict_conversions));\n       break;\n     default:\n-      std::stringstream ss;\n-      ss << \"Sequence converter for type \" << type->ToString() << \" not implemented\";\n-      return Status::NotImplemented(ss.str());\n+      return Status::NotImplemented(\"Sequence converter for type \", type->ToString(),\n+                                    \" not implemented\");\n   }\n   return Status::OK();\n }\ndiff --git a/cpp/src/arrow/python/serialize.cc b/cpp/src/arrow/python/serialize.cc\nindex 7911557ee7..ca94369be5 100644\n--- a/cpp/src/arrow/python/serialize.cc\n+++ b/cpp/src/arrow/python/serialize.cc\n@@ -407,10 +407,9 @@ Status CallCustomCallback(PyObject* context, PyObject* method_name, PyObject* el\n                           PyObject** result) {\n   *result = NULL;\n   if (context == Py_None) {\n-    std::stringstream ss;\n-    ss << \"error while calling callback on \" << internal::PyObject_StdStringRepr(elem)\n-       << \": handler not registered\";\n-    return Status::SerializationError(ss.str());\n+    return Status::SerializationError(\"error while calling callback on \",\n+                                      internal::PyObject_StdStringRepr(elem),\n+                                      \": handler not registered\");\n   } else {\n     *result = PyObject_CallMethodObjArgs(context, method_name, elem, NULL);\n     return PassPyError();\ndiff --git a/cpp/src/arrow/python/util/datetime.h b/cpp/src/arrow/python/util/datetime.h\nindex 7350deadcc..dc462972c5 100644\n--- a/cpp/src/arrow/python/util/datetime.h\n+++ b/cpp/src/arrow/python/util/datetime.h\n@@ -199,9 +199,7 @@ static inline Status PyTime_convert_int(int64_t val, const TimeUnit::type unit,\n   switch (unit) {\n     case TimeUnit::NANO:\n       if (val % 1000 != 0) {\n-        std::stringstream ss;\n-        ss << \"Value \" << val << \" has non-zero nanoseconds\";\n-        return Status::Invalid(ss.str());\n+        return Status::Invalid(\"Value \", val, \" has non-zero nanoseconds\");\n       }\n       val /= 1000;\n     // fall through\ndiff --git a/cpp/src/arrow/record_batch.cc b/cpp/src/arrow/record_batch.cc\nindex 33287c19ff..baaf5cb175 100644\n--- a/cpp/src/arrow/record_batch.cc\n+++ b/cpp/src/arrow/record_batch.cc\n@@ -95,16 +95,13 @@ class SimpleRecordBatch : public RecordBatch {\n     DCHECK(column != nullptr);\n \n     if (!field->type()->Equals(column->type())) {\n-      std::stringstream ss;\n-      ss << \"Column data type \" << field->type()->name()\n-         << \" does not match field data type \" << column->type()->name();\n-      return Status::Invalid(ss.str());\n+      return Status::Invalid(\"Column data type \", field->type()->name(),\n+                             \" does not match field data type \", column->type()->name());\n     }\n     if (column->length() != num_rows_) {\n-      std::stringstream ss;\n-      ss << \"Added column's length must match record batch's length. Expected length \"\n-         << num_rows_ << \" but got length \" << column->length();\n-      return Status::Invalid(ss.str());\n+      return Status::Invalid(\n+          \"Added column's length must match record batch's length. Expected length \",\n+          num_rows_, \" but got length \", column->length());\n     }\n \n     std::shared_ptr<Schema> new_schema;\n@@ -229,17 +226,14 @@ Status RecordBatch::Validate() const {\n     auto arr_shared = this->column_data(i);\n     const ArrayData& arr = *arr_shared;\n     if (arr.length != num_rows_) {\n-      std::stringstream ss;\n-      ss << \"Number of rows in column \" << i << \" did not match batch: \" << arr.length\n-         << \" vs \" << num_rows_;\n-      return Status::Invalid(ss.str());\n+      return Status::Invalid(\"Number of rows in column \", i,\n+                             \" did not match batch: \", arr.length, \" vs \", num_rows_);\n     }\n     const auto& schema_type = *schema_->field(i)->type();\n     if (!arr.type->Equals(schema_type)) {\n-      std::stringstream ss;\n-      ss << \"Column \" << i << \" type not match schema: \" << arr.type->ToString() << \" vs \"\n-         << schema_type.ToString();\n-      return Status::Invalid(ss.str());\n+      return Status::Invalid(\"Column \", i,\n+                             \" type not match schema: \", arr.type->ToString(), \" vs \",\n+                             schema_type.ToString());\n     }\n   }\n   return Status::OK();\ndiff --git a/cpp/src/arrow/status.cc b/cpp/src/arrow/status.cc\nindex 8be8b36d13..db7f087149 100644\n--- a/cpp/src/arrow/status.cc\n+++ b/cpp/src/arrow/status.cc\n@@ -13,6 +13,7 @@\n #include \"arrow/status.h\"\n \n #include <assert.h>\n+#include <sstream>\n \n namespace arrow {\n \ndiff --git a/cpp/src/arrow/status.h b/cpp/src/arrow/status.h\nindex e3632a6d5f..12975afcc8 100644\n--- a/cpp/src/arrow/status.h\n+++ b/cpp/src/arrow/status.h\n@@ -25,34 +25,41 @@\n #endif\n \n #include \"arrow/util/macros.h\"\n+#include \"arrow/util/string_builder.h\"\n #include \"arrow/util/visibility.h\"\n \n #ifdef ARROW_EXTRA_ERROR_CONTEXT\n \n-/// \\brief Propagate any non-successful Status to the caller\n-#define ARROW_RETURN_NOT_OK(s)                                                      \\\n-  do {                                                                              \\\n-    ::arrow::Status _s = (s);                                                       \\\n-    if (ARROW_PREDICT_FALSE(!_s.ok())) {                                            \\\n-      std::stringstream ss;                                                         \\\n-      ss << __FILE__ << \":\" << __LINE__ << \" code: \" << #s << \"\\n\" << _s.message(); \\\n-      return ::arrow::Status(_s.code(), ss.str());                                  \\\n-    }                                                                               \\\n+/// \\brief Return with given status if condition is met.\n+#define ARROW_RETURN_IF(condition, status)                        \\\n+  do {                                                            \\\n+    if (ARROW_PREDICT_FALSE(condition)) {                         \\\n+      ::arrow::Status _s = (status);                              \\\n+      std::stringstream ss;                                       \\\n+      ss << __FILE__ << \":\" << __LINE__ << \" : \" << _s.message(); \\\n+      return ::arrow::Status(_s.code(), ss.str());                \\\n+    }                                                             \\\n   } while (0)\n \n #else\n \n-/// \\brief Propagate any non-successful Status to the caller\n-#define ARROW_RETURN_NOT_OK(s)           \\\n-  do {                                   \\\n-    ::arrow::Status _s = (s);            \\\n-    if (ARROW_PREDICT_FALSE(!_s.ok())) { \\\n-      return _s;                         \\\n-    }                                    \\\n-  } while (false)\n+#define ARROW_RETURN_IF(condition, status) \\\n+  do {                                     \\\n+    if (ARROW_PREDICT_FALSE(condition)) {  \\\n+      return (status);                     \\\n+    }                                      \\\n+  } while (0)\n \n #endif  // ARROW_EXTRA_ERROR_CONTEXT\n \n+/// \\brief Propagate any non-successful Status to the caller\n+#define ARROW_RETURN_NOT_OK(status)  \\\n+  do {                               \\\n+    ::arrow::Status __s = (status);  \\\n+    ARROW_RETURN_IF(!__s.ok(), __s); \\\n+                                     \\\n+  } while (false)\n+\n #define RETURN_NOT_OK_ELSE(s, else_) \\\n   do {                               \\\n     ::arrow::Status _s = (s);        \\\n@@ -62,17 +69,6 @@\n     }                                \\\n   } while (false)\n \n-#define ARROW_RETURN_FAILURE_IF_FALSE(condition, status)                                 \\\n-  do {                                                                                   \\\n-    if (!(condition)) {                                                                  \\\n-      Status _status = (status);                                                         \\\n-      std::stringstream ss;                                                              \\\n-      ss << __FILE__ << \":\" << __LINE__ << \" code: \" << _status.CodeAsString() << \" \\n \" \\\n-         << _status.message();                                                           \\\n-      return ::arrow::Status(_status.code(), ss.str());                                  \\\n-    }                                                                                    \\\n-  } while (0)\n-\n // This is an internal-use macro and should not be used in public headers.\n #ifndef RETURN_NOT_OK\n #define RETURN_NOT_OK(s) ARROW_RETURN_NOT_OK(s)\n@@ -149,84 +145,119 @@ class ARROW_EXPORT Status {\n   static Status OK() { return Status(); }\n \n   /// Return a success status with a specific message\n-  static Status OK(const std::string& msg) { return Status(StatusCode::OK, msg); }\n+  template <typename... Args>\n+  static Status OK(Args&&... args) {\n+    return Status(StatusCode::OK, util::StringBuilder(std::forward<Args>(args)...));\n+  }\n \n   /// Return an error status for out-of-memory conditions\n-  static Status OutOfMemory(const std::string& msg) {\n-    return Status(StatusCode::OutOfMemory, msg);\n+  template <typename... Args>\n+  static Status OutOfMemory(Args&&... args) {\n+    return Status(StatusCode::OutOfMemory,\n+                  util::StringBuilder(std::forward<Args>(args)...));\n   }\n \n   /// Return an error status for failed key lookups (e.g. column name in a table)\n-  static Status KeyError(const std::string& msg) {\n-    return Status(StatusCode::KeyError, msg);\n+  template <typename... Args>\n+  static Status KeyError(Args&&... args) {\n+    return Status(StatusCode::KeyError, util::StringBuilder(std::forward<Args>(args)...));\n   }\n \n   /// Return an error status for type errors (such as mismatching data types)\n-  static Status TypeError(const std::string& msg) {\n-    return Status(StatusCode::TypeError, msg);\n+  template <typename... Args>\n+  static Status TypeError(Args&&... args) {\n+    return Status(StatusCode::TypeError,\n+                  util::StringBuilder(std::forward<Args>(args)...));\n   }\n \n   /// Return an error status for unknown errors\n-  static Status UnknownError(const std::string& msg) {\n-    return Status(StatusCode::UnknownError, msg);\n+  template <typename... Args>\n+  static Status UnknownError(Args&&... args) {\n+    return Status(StatusCode::UnknownError,\n+                  util::StringBuilder(std::forward<Args>(args)...));\n   }\n \n   /// Return an error status when an operation or a combination of operation and\n   /// data types is unimplemented\n-  static Status NotImplemented(const std::string& msg) {\n-    return Status(StatusCode::NotImplemented, msg);\n+  template <typename... Args>\n+  static Status NotImplemented(Args&&... args) {\n+    return Status(StatusCode::NotImplemented,\n+                  util::StringBuilder(std::forward<Args>(args)...));\n   }\n \n   /// Return an error status for invalid data (for example a string that fails parsing)\n-  static Status Invalid(const std::string& msg) {\n-    return Status(StatusCode::Invalid, msg);\n+  template <typename... Args>\n+  static Status Invalid(Args&&... args) {\n+    return Status(StatusCode::Invalid, util::StringBuilder(std::forward<Args>(args)...));\n   }\n \n   /// Return an error status when a container's capacity would exceed its limits\n-  static Status CapacityError(const std::string& msg) {\n-    return Status(StatusCode::CapacityError, msg);\n+  template <typename... Args>\n+  static Status CapacityError(Args&&... args) {\n+    return Status(StatusCode::CapacityError,\n+                  util::StringBuilder(std::forward<Args>(args)...));\n   }\n \n   /// Return an error status when some IO-related operation failed\n-  static Status IOError(const std::string& msg) {\n-    return Status(StatusCode::IOError, msg);\n+  template <typename... Args>\n+  static Status IOError(Args&&... args) {\n+    return Status(StatusCode::IOError, util::StringBuilder(std::forward<Args>(args)...));\n   }\n \n   /// Return an error status when some (de)serialization operation failed\n-  static Status SerializationError(const std::string& msg) {\n-    return Status(StatusCode::SerializationError, msg);\n+  template <typename... Args>\n+  static Status SerializationError(Args&&... args) {\n+    return Status(StatusCode::SerializationError,\n+                  util::StringBuilder(std::forward<Args>(args)...));\n   }\n \n-  static Status RError(const std::string& msg) { return Status(StatusCode::RError, msg); }\n+  template <typename... Args>\n+  static Status RError(Args&&... args) {\n+    return Status(StatusCode::RError, util::StringBuilder(std::forward<Args>(args)...));\n+  }\n \n-  static Status PlasmaObjectExists(const std::string& msg) {\n-    return Status(StatusCode::PlasmaObjectExists, msg);\n+  template <typename... Args>\n+  static Status PlasmaObjectExists(Args&&... args) {\n+    return Status(StatusCode::PlasmaObjectExists,\n+                  util::StringBuilder(std::forward<Args>(args)...));\n   }\n \n-  static Status PlasmaObjectNonexistent(const std::string& msg) {\n-    return Status(StatusCode::PlasmaObjectNonexistent, msg);\n+  template <typename... Args>\n+  static Status PlasmaObjectNonexistent(Args&&... args) {\n+    return Status(StatusCode::PlasmaObjectNonexistent,\n+                  util::StringBuilder(std::forward<Args>(args)...));\n   }\n \n-  static Status PlasmaObjectAlreadySealed(const std::string& msg) {\n-    return Status(StatusCode::PlasmaObjectAlreadySealed, msg);\n+  template <typename... Args>\n+  static Status PlasmaObjectAlreadySealed(Args&&... args) {\n+    return Status(StatusCode::PlasmaObjectAlreadySealed,\n+                  util::StringBuilder(std::forward<Args>(args)...));\n   }\n \n-  static Status PlasmaStoreFull(const std::string& msg) {\n-    return Status(StatusCode::PlasmaStoreFull, msg);\n+  template <typename... Args>\n+  static Status PlasmaStoreFull(Args&&... args) {\n+    return Status(StatusCode::PlasmaStoreFull,\n+                  util::StringBuilder(std::forward<Args>(args)...));\n   }\n \n   static Status StillExecuting() { return Status(StatusCode::StillExecuting, \"\"); }\n \n-  static Status CodeGenError(const std::string& msg) {\n-    return Status(StatusCode::CodeGenError, msg);\n+  template <typename... Args>\n+  static Status CodeGenError(Args&&... args) {\n+    return Status(StatusCode::CodeGenError,\n+                  util::StringBuilder(std::forward<Args>(args)...));\n   }\n \n-  static Status ExpressionValidationError(const std::string& msg) {\n-    return Status(StatusCode::ExpressionValidationError, msg);\n+  template <typename... Args>\n+  static Status ExpressionValidationError(Args&&... args) {\n+    return Status(StatusCode::ExpressionValidationError,\n+                  util::StringBuilder(std::forward<Args>(args)...));\n   }\n \n-  static Status ExecutionError(const std::string& msg) {\n-    return Status(StatusCode::ExecutionError, msg);\n+  template <typename... Args>\n+  static Status ExecutionError(Args&&... args) {\n+    return Status(StatusCode::ExecutionError,\n+                  util::StringBuilder(std::forward<Args>(args)...));\n   }\n \n   /// Return true iff the status indicates success.\ndiff --git a/cpp/src/arrow/table.cc b/cpp/src/arrow/table.cc\nindex 1f3d927ddd..d232ac35e3 100644\n--- a/cpp/src/arrow/table.cc\n+++ b/cpp/src/arrow/table.cc\n@@ -234,10 +234,8 @@ Status Column::ValidateData() {\n   for (int i = 0; i < data_->num_chunks(); ++i) {\n     std::shared_ptr<DataType> type = data_->chunk(i)->type();\n     if (!this->type()->Equals(type)) {\n-      std::stringstream ss;\n-      ss << \"In chunk \" << i << \" expected type \" << this->type()->ToString()\n-         << \" but saw \" << type->ToString();\n-      return Status::Invalid(ss.str());\n+      return Status::Invalid(\"In chunk \", i, \" expected type \", this->type()->ToString(),\n+                             \" but saw \", type->ToString());\n     }\n   }\n   return Status::OK();\n@@ -301,10 +299,9 @@ class SimpleTable : public Table {\n     DCHECK(col != nullptr);\n \n     if (col->length() != num_rows_) {\n-      std::stringstream ss;\n-      ss << \"Added column's length must match table's length. Expected length \"\n-         << num_rows_ << \" but got length \" << col->length();\n-      return Status::Invalid(ss.str());\n+      return Status::Invalid(\n+          \"Added column's length must match table's length. Expected length \", num_rows_,\n+          \" but got length \", col->length());\n     }\n \n     std::shared_ptr<Schema> new_schema;\n@@ -319,10 +316,9 @@ class SimpleTable : public Table {\n     DCHECK(col != nullptr);\n \n     if (col->length() != num_rows_) {\n-      std::stringstream ss;\n-      ss << \"Added column's length must match table's length. Expected length \"\n-         << num_rows_ << \" but got length \" << col->length();\n-      return Status::Invalid(ss.str());\n+      return Status::Invalid(\n+          \"Added column's length must match table's length. Expected length \", num_rows_,\n+          \" but got length \", col->length());\n     }\n \n     std::shared_ptr<Schema> new_schema;\n@@ -363,15 +359,11 @@ class SimpleTable : public Table {\n     for (int i = 0; i < num_columns(); ++i) {\n       const Column* col = columns_[i].get();\n       if (col == nullptr) {\n-        std::stringstream ss;\n-        ss << \"Column \" << i << \" was null\";\n-        return Status::Invalid(ss.str());\n+        return Status::Invalid(\"Column \", i, \" was null\");\n       }\n       if (!col->field()->Equals(*schema_->field(i))) {\n-        std::stringstream ss;\n-        ss << \"Column field \" << i << \" named \" << col->name()\n-           << \" is inconsistent with schema\";\n-        return Status::Invalid(ss.str());\n+        return Status::Invalid(\"Column field \", i, \" named \", col->name(),\n+                               \" is inconsistent with schema\");\n       }\n     }\n \n@@ -379,10 +371,8 @@ class SimpleTable : public Table {\n     for (int i = 0; i < num_columns(); ++i) {\n       const Column* col = columns_[i].get();\n       if (col->length() != num_rows_) {\n-        std::stringstream ss;\n-        ss << \"Column \" << i << \" named \" << col->name() << \" expected length \"\n-           << num_rows_ << \" but got length \" << col->length();\n-        return Status::Invalid(ss.str());\n+        return Status::Invalid(\"Column \", i, \" named \", col->name(), \" expected length \",\n+                               num_rows_, \" but got length \", col->length());\n       }\n     }\n     return Status::OK();\n@@ -414,11 +404,9 @@ Status Table::FromRecordBatches(const std::shared_ptr<Schema>& schema,\n \n   for (int i = 0; i < nbatches; ++i) {\n     if (!batches[i]->schema()->Equals(*schema, false)) {\n-      std::stringstream ss;\n-      ss << \"Schema at index \" << static_cast<int>(i) << \" was different: \\n\"\n-         << schema->ToString() << \"\\nvs\\n\"\n-         << batches[i]->schema()->ToString();\n-      return Status::Invalid(ss.str());\n+      return Status::Invalid(\"Schema at index \", static_cast<int>(i),\n+                             \" was different: \\n\", schema->ToString(), \"\\nvs\\n\",\n+                             batches[i]->schema()->ToString());\n     }\n   }\n \n@@ -458,11 +446,9 @@ Status ConcatenateTables(const std::vector<std::shared_ptr<Table>>& tables,\n \n   for (int i = 1; i < ntables; ++i) {\n     if (!tables[i]->schema()->Equals(*schema, false)) {\n-      std::stringstream ss;\n-      ss << \"Schema at index \" << static_cast<int>(i) << \" was different: \\n\"\n-         << schema->ToString() << \"\\nvs\\n\"\n-         << tables[i]->schema()->ToString();\n-      return Status::Invalid(ss.str());\n+      return Status::Invalid(\"Schema at index \", static_cast<int>(i),\n+                             \" was different: \\n\", schema->ToString(), \"\\nvs\\n\",\n+                             tables[i]->schema()->ToString());\n     }\n   }\n \ndiff --git a/cpp/src/arrow/util/compression_brotli.cc b/cpp/src/arrow/util/compression_brotli.cc\nindex 89d099d6a6..3d75253e11 100644\n--- a/cpp/src/arrow/util/compression_brotli.cc\n+++ b/cpp/src/arrow/util/compression_brotli.cc\n@@ -81,9 +81,7 @@ class BrotliDecompressor : public Decompressor {\n   Status BrotliError(const char* msg) { return Status::IOError(msg); }\n \n   Status BrotliError(BrotliDecoderErrorCode code, const char* prefix_msg) {\n-    std::stringstream ss;\n-    ss << prefix_msg << BrotliDecoderErrorString(code);\n-    return Status::IOError(ss.str());\n+    return Status::IOError(prefix_msg, BrotliDecoderErrorString(code));\n   }\n \n   BrotliDecoderState* state_ = nullptr;\ndiff --git a/cpp/src/arrow/util/compression_lz4.cc b/cpp/src/arrow/util/compression_lz4.cc\nindex 97fd46ab6c..d157ba6176 100644\n--- a/cpp/src/arrow/util/compression_lz4.cc\n+++ b/cpp/src/arrow/util/compression_lz4.cc\n@@ -31,6 +31,10 @@\n namespace arrow {\n namespace util {\n \n+static Status LZ4Error(LZ4F_errorCode_t ret, const char* prefix_msg) {\n+  return Status::IOError(prefix_msg, LZ4F_getErrorName(ret));\n+}\n+\n // ----------------------------------------------------------------------\n // Lz4 decompressor implementation\n \n@@ -79,12 +83,6 @@ class LZ4Decompressor : public Decompressor {\n   bool IsFinished() override { return finished_; }\n \n  protected:\n-  Status LZ4Error(LZ4F_errorCode_t ret, const char* prefix_msg) {\n-    std::stringstream ss;\n-    ss << prefix_msg << LZ4F_getErrorName(ret);\n-    return Status::IOError(ss.str());\n-  }\n-\n   LZ4F_dctx* ctx_ = nullptr;\n   bool finished_;\n };\n@@ -125,12 +123,6 @@ class LZ4Compressor : public Compressor {\n              bool* should_retry) override;\n \n  protected:\n-  Status LZ4Error(LZ4F_errorCode_t ret, const char* prefix_msg) {\n-    std::stringstream ss;\n-    ss << prefix_msg << LZ4F_getErrorName(ret);\n-    return Status::IOError(ss.str());\n-  }\n-\n   LZ4F_cctx* ctx_ = nullptr;\n   LZ4F_preferences_t prefs_;\n   bool first_time_;\ndiff --git a/cpp/src/arrow/util/compression_snappy.cc b/cpp/src/arrow/util/compression_snappy.cc\nindex 1b483e5855..058593fe13 100644\n--- a/cpp/src/arrow/util/compression_snappy.cc\n+++ b/cpp/src/arrow/util/compression_snappy.cc\n@@ -57,10 +57,8 @@ Status SnappyCodec::Decompress(int64_t input_len, const uint8_t* input,\n     return Status::IOError(\"Corrupt snappy compressed data.\");\n   }\n   if (output_buffer_len < static_cast<int64_t>(decompressed_size)) {\n-    std::stringstream ss;\n-    ss << \"Output buffer size (\" << output_buffer_len << \") must be \" << decompressed_size\n-       << \" or larger.\";\n-    return Status::Invalid(ss.str());\n+    return Status::Invalid(\"Output buffer size (\", output_buffer_len, \") must be \",\n+                           decompressed_size, \" or larger.\");\n   }\n   if (output_len) {\n     *output_len = static_cast<int64_t>(decompressed_size);\ndiff --git a/cpp/src/arrow/util/compression_zlib.cc b/cpp/src/arrow/util/compression_zlib.cc\nindex 686dffa640..dfda317e3b 100644\n--- a/cpp/src/arrow/util/compression_zlib.cc\n+++ b/cpp/src/arrow/util/compression_zlib.cc\n@@ -76,6 +76,10 @@ static int DecompressionWindowBitsForFormat(GZipCodec::Format format) {\n   }\n }\n \n+static Status ZlibErrorPrefix(const char* prefix_msg, const char* msg) {\n+  return Status::IOError(prefix_msg, (msg) ? msg : \"(unknown error)\");\n+}\n+\n // ----------------------------------------------------------------------\n // gzip decompressor implementation\n \n@@ -142,14 +146,7 @@ class GZipDecompressor : public Decompressor {\n \n  protected:\n   Status ZlibError(const char* prefix_msg) {\n-    std::stringstream ss;\n-    ss << prefix_msg;\n-    if (stream_.msg && *stream_.msg) {\n-      ss << stream_.msg;\n-    } else {\n-      ss << \"(unknown error)\";\n-    }\n-    return Status::IOError(ss.str());\n+    return ZlibErrorPrefix(prefix_msg, stream_.msg);\n   }\n \n   z_stream stream_;\n@@ -197,14 +194,7 @@ class GZipCompressor : public Compressor {\n \n  protected:\n   Status ZlibError(const char* prefix_msg) {\n-    std::stringstream ss;\n-    ss << prefix_msg;\n-    if (stream_.msg && *stream_.msg) {\n-      ss << stream_.msg;\n-    } else {\n-      ss << \"(unknown error)\";\n-    }\n-    return Status::IOError(ss.str());\n+    return ZlibErrorPrefix(prefix_msg, stream_.msg);\n   }\n \n   z_stream stream_;\n@@ -344,9 +334,7 @@ class GZipCodec::GZipCodecImpl {\n     int window_bits = CompressionWindowBitsForFormat(format_);\n     if ((ret = deflateInit2(&stream_, Z_DEFAULT_COMPRESSION, Z_DEFLATED, window_bits,\n                             kGZipDefaultCompressionLevel, Z_DEFAULT_STRATEGY)) != Z_OK) {\n-      std::stringstream ss;\n-      ss << \"zlib deflateInit failed: \" << std::string(stream_.msg);\n-      return Status::IOError(ss.str());\n+      return ZlibErrorPrefix(\"zlib deflateInit failed: \", stream_.msg);\n     }\n     compressor_initialized_ = true;\n     return Status::OK();\n@@ -367,9 +355,7 @@ class GZipCodec::GZipCodecImpl {\n     // Initialize to run either deflate or zlib/gzip format\n     int window_bits = DecompressionWindowBitsForFormat(format_);\n     if ((ret = inflateInit2(&stream_, window_bits)) != Z_OK) {\n-      std::stringstream ss;\n-      ss << \"zlib inflateInit failed: \" << std::string(stream_.msg);\n-      return Status::IOError(ss.str());\n+      return ZlibErrorPrefix(\"zlib inflateInit failed: \", stream_.msg);\n     }\n     decompressor_initialized_ = true;\n     return Status::OK();\n@@ -401,9 +387,7 @@ class GZipCodec::GZipCodecImpl {\n \n     // Reset the stream for this block\n     if (inflateReset(&stream_) != Z_OK) {\n-      std::stringstream ss;\n-      ss << \"zlib inflateReset failed: \" << std::string(stream_.msg);\n-      return Status::IOError(ss.str());\n+      return ZlibErrorPrefix(\"zlib inflateReset failed: \", stream_.msg);\n     }\n \n     int ret = 0;\n@@ -425,18 +409,13 @@ class GZipCodec::GZipCodecImpl {\n       if (ret == Z_STREAM_END || ret != Z_OK) break;\n \n       // Failure, buffer was too small\n-      std::stringstream ss;\n-      ss << \"Too small a buffer passed to GZipCodec. InputLength=\" << input_length\n-         << \" OutputLength=\" << output_buffer_length;\n-      return Status::IOError(ss.str());\n+      return Status::IOError(\"Too small a buffer passed to GZipCodec. InputLength=\",\n+                             input_length, \" OutputLength=\", output_buffer_length);\n     }\n \n     // Failure for some other reason\n     if (ret != Z_STREAM_END) {\n-      std::stringstream ss;\n-      ss << \"GZipCodec failed: \";\n-      if (stream_.msg != NULL) ss << stream_.msg;\n-      return Status::IOError(ss.str());\n+      return ZlibErrorPrefix(\"GZipCodec failed: \", stream_.msg);\n     }\n \n     if (output_length) {\n@@ -475,15 +454,12 @@ class GZipCodec::GZipCodecImpl {\n         // small\n         return Status::IOError(\"zlib deflate failed, output buffer too small\");\n       }\n-      std::stringstream ss;\n-      ss << \"zlib deflate failed: \" << stream_.msg;\n-      return Status::IOError(ss.str());\n+\n+      return ZlibErrorPrefix(\"zlib deflate failed: \", stream_.msg);\n     }\n \n     if (deflateReset(&stream_) != Z_OK) {\n-      std::stringstream ss;\n-      ss << \"zlib deflateReset failed: \" << std::string(stream_.msg);\n-      return Status::IOError(ss.str());\n+      return ZlibErrorPrefix(\"zlib deflateReset failed: \", stream_.msg);\n     }\n \n     // Actual output length\ndiff --git a/cpp/src/arrow/util/compression_zstd.cc b/cpp/src/arrow/util/compression_zstd.cc\nindex 083cae99b9..de9df8fc94 100644\n--- a/cpp/src/arrow/util/compression_zstd.cc\n+++ b/cpp/src/arrow/util/compression_zstd.cc\n@@ -36,9 +36,7 @@ namespace util {\n constexpr int kZSTDDefaultCompressionLevel = 1;\n \n static Status ZSTDError(size_t ret, const char* prefix_msg) {\n-  std::stringstream ss;\n-  ss << prefix_msg << ZSTD_getErrorName(ret);\n-  return Status::IOError(ss.str());\n+  return Status::IOError(prefix_msg, ZSTD_getErrorName(ret));\n }\n \n // ----------------------------------------------------------------------\ndiff --git a/cpp/src/arrow/util/decimal.cc b/cpp/src/arrow/util/decimal.cc\nindex c47ac82e8c..f6e110561b 100644\n--- a/cpp/src/arrow/util/decimal.cc\n+++ b/cpp/src/arrow/util/decimal.cc\n@@ -345,9 +345,7 @@ Status Decimal128::FromString(const util::string_view& s, Decimal128* out,\n \n   DecimalComponents dec;\n   if (!ParseDecimalComponents(s.data(), s.size(), &dec)) {\n-    std::stringstream ss;\n-    ss << \"The string '\" << s << \"' is not a valid decimal number\";\n-    return Status::Invalid(ss.str());\n+    return Status::Invalid(\"The string '\", s, \"' is not a valid decimal number\");\n   }\n   std::string exponent_value = dec.exponent_sign + dec.exponent_digits;\n \n@@ -878,11 +876,9 @@ Status Decimal128::Rescale(int32_t original_scale, int32_t new_scale,\n \n   // Fail if we overflow or truncate\n   if (ARROW_PREDICT_FALSE(rescale_would_cause_data_loss)) {\n-    std::stringstream buf;\n-    buf << \"Rescaling decimal value \" << ToString(original_scale)\n-        << \" from original scale of \" << original_scale << \" to new scale of \"\n-        << new_scale << \" would cause data loss\";\n-    return Status::Invalid(buf.str());\n+    return Status::Invalid(\"Rescaling decimal value \", ToString(original_scale),\n+                           \" from original scale of \", original_scale,\n+                           \" to new scale of \", new_scale, \" would cause data loss\");\n   }\n \n   return Status::OK();\n@@ -909,11 +905,9 @@ Status Decimal128::FromBigEndian(const uint8_t* bytes, int32_t length, Decimal12\n   int64_t high, low;\n \n   if (length < kMinDecimalBytes || length > kMaxDecimalBytes) {\n-    std::ostringstream stream;\n-    stream << \"Length of byte array passed to Decimal128::FromBigEndian \";\n-    stream << \"was \" << length << \", but must be between \";\n-    stream << kMinDecimalBytes << \" and \" << kMaxDecimalBytes;\n-    return Status::Invalid(stream.str());\n+    return Status::Invalid(\"Length of byte array passed to Decimal128::FromBigEndian \",\n+                           \"was \", length, \", but must be between \", kMinDecimalBytes,\n+                           \" and \", kMaxDecimalBytes);\n   }\n \n   // Bytes are coming in big-endian, so the first byte is the MSB and therefore holds the\ndiff --git a/cpp/src/arrow/util/decimal.h b/cpp/src/arrow/util/decimal.h\nindex fe76d25eb4..f59a4a42ab 100644\n--- a/cpp/src/arrow/util/decimal.h\n+++ b/cpp/src/arrow/util/decimal.h\n@@ -149,9 +149,8 @@ class ARROW_EXPORT Decimal128 {\n     constexpr auto max_value = std::numeric_limits<T>::max();\n     const auto& self = *this;\n     if (self < min_value || self > max_value) {\n-      std::stringstream buf;\n-      buf << \"Invalid cast from Decimal128 to \" << sizeof(T) << \" byte integer\";\n-      return Status::Invalid(buf.str());\n+      return Status::Invalid(\"Invalid cast from Decimal128 to \", sizeof(T),\n+                             \" byte integer\");\n     }\n     *out = static_cast<T>(low_bits_);\n     return Status::OK();\ndiff --git a/cpp/src/arrow/util/io-util.cc b/cpp/src/arrow/util/io-util.cc\nindex 74ad80691d..5d67fe87fa 100644\n--- a/cpp/src/arrow/util/io-util.cc\n+++ b/cpp/src/arrow/util/io-util.cc\n@@ -113,10 +113,8 @@ static inline Status CheckFileOpResult(int ret, int errno_actual,\n                                        const PlatformFilename& file_name,\n                                        const char* opname) {\n   if (ret == -1) {\n-    std::stringstream ss;\n-    ss << \"Failed to \" << opname << \" file: \" << file_name.string();\n-    ss << \" , error: \" << std::strerror(errno_actual);\n-    return Status::IOError(ss.str());\n+    return Status::IOError(\"Failed to \", opname, \" file: \", file_name.string(),\n+                           \" , error: \", std::strerror(errno_actual));\n   }\n   return Status::OK();\n }\n@@ -232,12 +230,18 @@ Status CreatePipe(int fd[2]) {\n #endif\n \n   if (ret == -1) {\n-    return Status::IOError(std::string(\"Error creating pipe: \") +\n-                           std::string(strerror(errno)));\n+    return Status::IOError(\"Error creating pipe: \", std::strerror(errno));\n   }\n   return Status::OK();\n }\n \n+static Status StatusFromErrno(const char* prefix) {\n+#ifdef _WIN32\n+  errno = __map_mman_error(GetLastError(), EPERM);\n+#endif\n+  return Status::IOError(prefix, std::strerror(errno));\n+}\n+\n //\n // Compatible way to remap a memory map\n //\n@@ -251,18 +255,12 @@ Status MemoryMapRemap(void* addr, size_t old_size, size_t new_size, int fildes,\n   HANDLE fm, h;\n \n   if (!UnmapViewOfFile(addr)) {\n-    errno = __map_mman_error(GetLastError(), EPERM);\n-    std::stringstream ss;\n-    ss << \"UnmapViewOfFile failed: \" << std::strerror(errno);\n-    return Status::IOError(ss.str());\n+    return StatusFromErrno(\"UnmapViewOfFile failed: \");\n   }\n \n   h = reinterpret_cast<HANDLE>(_get_osfhandle(fildes));\n   if (h == INVALID_HANDLE_VALUE) {\n-    errno = __map_mman_error(GetLastError(), EPERM);\n-    std::stringstream ss;\n-    ss << \"cannot get file handle: \" << std::strerror(errno);\n-    return Status::IOError(ss.str());\n+    return StatusFromErrno(\"Cannot get file handle: \");\n   }\n \n   LONG new_size_low = static_cast<LONG>(new_size & 0xFFFFFFFFL);\n@@ -272,18 +270,12 @@ Status MemoryMapRemap(void* addr, size_t old_size, size_t new_size, int fildes,\n   SetEndOfFile(h);\n   fm = CreateFileMapping(h, NULL, PAGE_READWRITE, 0, 0, \"\");\n   if (fm == NULL) {\n-    errno = __map_mman_error(GetLastError(), EPERM);\n-    std::stringstream ss;\n-    ss << \"mremap failed: \" << std::strerror(errno);\n-    return Status::IOError(ss.str());\n+    return StatusFromErrno(\"CreateFileMapping failed: \");\n   }\n   *new_addr = MapViewOfFile(fm, FILE_MAP_WRITE, 0, 0, new_size);\n   CloseHandle(fm);\n   if (new_addr == NULL) {\n-    errno = __map_mman_error(GetLastError(), EPERM);\n-    std::stringstream ss;\n-    ss << \"mremap failed: \" << std::strerror(errno);\n-    return Status::IOError(ss.str());\n+    return StatusFromErrno(\"MapViewOfFile failed: \");\n   }\n   return Status::OK();\n #else\n@@ -291,26 +283,26 @@ Status MemoryMapRemap(void* addr, size_t old_size, size_t new_size, int fildes,\n   // we have to close the mmap first, truncate the file to the new size\n   // and recreate the mmap\n   if (munmap(addr, old_size) == -1) {\n-    std::stringstream ss;\n-    ss << \"munmap failed: \" << std::strerror(errno);\n-    return Status::IOError(ss.str());\n+    return StatusFromErrno(\"munmap failed: \");\n   }\n   if (ftruncate(fildes, new_size) == -1) {\n-    std::stringstream ss;\n-    ss << \"cannot truncate file: \" << std::strerror(errno);\n-    return Status::IOError(ss.str());\n+    return StatusFromErrno(\"ftruncate failed: \");\n   }\n   // we set READ / WRITE flags on the new map, since we could only have\n   // unlarged a RW map in the first place\n   *new_addr = mmap(NULL, new_size, PROT_READ | PROT_WRITE, MAP_SHARED, fildes, 0);\n+  if (*new_addr == MAP_FAILED) {\n+    return StatusFromErrno(\"mmap failed: \");\n+  }\n   return Status::OK();\n #else\n   if (ftruncate(fildes, new_size) == -1) {\n-    std::stringstream ss;\n-    ss << \"file truncate failed: \" << std::strerror(errno);\n-    return Status::IOError(ss.str());\n+    return StatusFromErrno(\"ftruncate failed: \");\n   }\n   *new_addr = mremap(addr, old_size, new_size, MREMAP_MAYMOVE);\n+  if (*new_addr == MAP_FAILED) {\n+    return StatusFromErrno(\"mremap failed: \");\n+  }\n   return Status::OK();\n #endif\n #endif\ndiff --git a/cpp/src/arrow/util/string_builder.h b/cpp/src/arrow/util/string_builder.h\nnew file mode 100644\nindex 0000000000..7b3e10742a\n--- /dev/null\n+++ b/cpp/src/arrow/util/string_builder.h\n@@ -0,0 +1,51 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License. template <typename T>\n+\n+#ifndef ARROW_UTIL_STRING_BUILDER_H\n+#define ARROW_UTIL_STRING_BUILDER_H\n+\n+#include <sstream>\n+#include <string>\n+#include <utility>\n+\n+namespace arrow {\n+namespace util {\n+\n+template <typename Head>\n+void StringBuilderRecursive(std::stringstream& stream, Head&& head) {\n+  stream << head;\n+}\n+\n+template <typename Head, typename... Tail>\n+void StringBuilderRecursive(std::stringstream& stream, Head&& head, Tail&&... tail) {\n+  StringBuilderRecursive(stream, std::forward<Head>(head));\n+  StringBuilderRecursive(stream, std::forward<Tail>(tail)...);\n+}\n+\n+template <typename... Args>\n+std::string StringBuilder(Args&&... args) {\n+  std::stringstream stream;\n+\n+  StringBuilderRecursive(stream, std::forward<Args>(args)...);\n+\n+  return stream.str();\n+}\n+\n+}  // namespace util\n+}  // namespace arrow\n+\n+#endif  // ARROW_UTIL_STRING_BUILDER_H\ndiff --git a/cpp/src/gandiva/date_utils.cc b/cpp/src/gandiva/date_utils.cc\nindex 2686b19350..8a7e1f03fb 100644\n--- a/cpp/src/gandiva/date_utils.cc\n+++ b/cpp/src/gandiva/date_utils.cc\n@@ -75,11 +75,8 @@ Status DateUtils::ToInternalFormat(const std::string& format,\n         buffer.str(\"\");\n         continue;\n       } else {\n-        if (buffer.str().length() > 0) {\n-          std::stringstream err_msg;\n-          err_msg << \"Invalid date format string '\" << format << \"' at position \" << i;\n-          return Status::Invalid(err_msg.str());\n-        }\n+        ARROW_RETURN_IF(buffer.str().length() > 0,\n+                        Status::Invalid(\"Invalid date format string '\", format, \"'\"));\n \n         is_in_quoted_text = true;\n         continue;\n@@ -156,10 +153,7 @@ Status DateUtils::ToInternalFormat(const std::string& format,\n         }\n       }\n     } else {\n-      // no potential matches found\n-      std::stringstream err_msg;\n-      err_msg << \"Invalid date format string '\" << format << \"' at position \" << i;\n-      return Status::Invalid(err_msg.str());\n+      return Status::Invalid(\"Invalid date format string '\", format, \"'\");\n     }\n   }\n \n@@ -170,11 +164,10 @@ Status DateUtils::ToInternalFormat(const std::string& format,\n     if (exactMatches.size() == 1 && exactMatches[0].length() == buffer.str().length()) {\n       builder << sql_date_format_to_boost_map_[exactMatches[0]];\n     } else {\n-      // we didn't successfully parse the entire string\n+      // Format partially parsed\n       int64_t pos = format.length() - buffer.str().length();\n-      std::stringstream err_msg;\n-      err_msg << \"Invalid date format string '\" << format << \"' at position \" << pos;\n-      return Status::Invalid(err_msg.str());\n+      return Status::Invalid(\"Invalid date format string '\", format, \"' at position \",\n+                             pos);\n     }\n   }\n   std::string final_pattern = builder.str();\ndiff --git a/cpp/src/gandiva/engine.cc b/cpp/src/gandiva/engine.cc\nindex 59884c5b4a..da7a6d886c 100644\n--- a/cpp/src/gandiva/engine.cc\n+++ b/cpp/src/gandiva/engine.cc\n@@ -103,12 +103,11 @@ Status Engine::LoadPreCompiledIRFiles(const std::string& byte_code_file_path) {\n   /// Read from file into memory buffer.\n   llvm::ErrorOr<std::unique_ptr<llvm::MemoryBuffer>> buffer_or_error =\n       llvm::MemoryBuffer::getFile(byte_code_file_path);\n-  if (!buffer_or_error) {\n-    std::stringstream ss;\n-    ss << \"Could not load module from IR \" << byte_code_file_path << \": \"\n-       << buffer_or_error.getError().message();\n-    return Status::CodeGenError(ss.str());\n-  }\n+  ARROW_RETURN_IF(\n+      !buffer_or_error,\n+      Status::CodeGenError(\"Could not load module from IR \", byte_code_file_path, \": \",\n+                           buffer_or_error.getError().message()));\n+\n   std::unique_ptr<llvm::MemoryBuffer> buffer = move(buffer_or_error.get());\n \n   /// Parse the IR module.\n@@ -123,15 +122,11 @@ Status Engine::LoadPreCompiledIRFiles(const std::string& byte_code_file_path) {\n   }\n   std::unique_ptr<llvm::Module> ir_module = move(module_or_error.get());\n \n-  /// Verify the IR module\n-  if (llvm::verifyModule(*ir_module, &llvm::errs())) {\n-    return Status::CodeGenError(\"verify of IR Module failed\");\n-  }\n+  ARROW_RETURN_IF(llvm::verifyModule(*ir_module, &llvm::errs()),\n+                  Status::CodeGenError(\"verify of IR Module failed\"));\n+  ARROW_RETURN_IF(llvm::Linker::linkModules(*module_, move(ir_module)),\n+                  Status::CodeGenError(\"failed to link IR Modules\"));\n \n-  // Link this to the primary module.\n-  if (llvm::Linker::linkModules(*module_, move(ir_module))) {\n-    return Status::CodeGenError(\"failed to link IR Modules\");\n-  }\n   return Status::OK();\n }\n \n@@ -197,13 +192,13 @@ Status Engine::FinalizeModule(bool optimise_ir, bool dump_ir) {\n     }\n   }\n \n-  if (llvm::verifyModule(*module_, &llvm::errs())) {\n-    return Status::CodeGenError(\"verify of module failed after optimisation passes\");\n-  }\n+  ARROW_RETURN_IF(llvm::verifyModule(*module_, &llvm::errs()),\n+                  Status::CodeGenError(\"Module verification failed after optimizer\"));\n \n   // do the compilation\n   execution_engine_->finalizeObject();\n   module_finalized_ = true;\n+\n   return Status::OK();\n }\n \ndiff --git a/cpp/src/gandiva/expr_validator.cc b/cpp/src/gandiva/expr_validator.cc\nindex 3f5d63745f..43de9d7a05 100644\n--- a/cpp/src/gandiva/expr_validator.cc\n+++ b/cpp/src/gandiva/expr_validator.cc\n@@ -24,133 +24,114 @@\n namespace gandiva {\n \n Status ExprValidator::Validate(const ExpressionPtr& expr) {\n-  if (expr == nullptr) {\n-    return Status::ExpressionValidationError(\"Expression cannot be null.\");\n-  }\n+  ARROW_RETURN_IF(expr == nullptr,\n+                  Status::ExpressionValidationError(\"Expression cannot be null\"));\n+\n   Node& root = *expr->root();\n-  Status status = root.Accept(*this);\n-  if (!status.ok()) {\n-    return status;\n-  }\n-  // validate return type matches\n-  // no need to check if type is supported\n-  // since root type has been validated.\n-  if (!root.return_type()->Equals(*expr->result()->type())) {\n-    std::stringstream ss;\n-    ss << \"Return type of root node \" << root.return_type()->name()\n-       << \" does not match that of expression \" << *expr->result()->type();\n-    return Status::ExpressionValidationError(ss.str());\n-  }\n+  ARROW_RETURN_NOT_OK(root.Accept(*this));\n+\n+  // Ensure root's return type match the expression return type. Type\n+  // support validation is not required because root type is already supported.\n+  ARROW_RETURN_IF(!root.return_type()->Equals(*expr->result()->type()),\n+                  Status::ExpressionValidationError(\"Return type of root node \",\n+                                                    root.return_type()->name(),\n+                                                    \" does not match that of expression \",\n+                                                    expr->result()->type()->name()));\n+\n   return Status::OK();\n }\n \n Status ExprValidator::Visit(const FieldNode& node) {\n   auto llvm_type = types_->IRType(node.return_type()->id());\n-  if (llvm_type == nullptr) {\n-    std::stringstream ss;\n-    ss << \"Field \" << node.field()->name() << \" has unsupported data type \"\n-       << node.return_type()->name();\n-    return Status::ExpressionValidationError(ss.str());\n-  }\n+  ARROW_RETURN_IF(llvm_type == nullptr,\n+                  Status::ExpressionValidationError(\"Field \", node.field()->name(),\n+                                                    \" has unsupported data type \",\n+                                                    node.return_type()->name()));\n \n+  // Ensure that field is found in schema\n   auto field_in_schema_entry = field_map_.find(node.field()->name());\n+  ARROW_RETURN_IF(field_in_schema_entry == field_map_.end(),\n+                  Status::ExpressionValidationError(\"Field \", node.field()->name(),\n+                                                    \" not in schema.\"));\n \n-  // validate that field is in schema.\n-  if (field_in_schema_entry == field_map_.end()) {\n-    std::stringstream ss;\n-    ss << \"Field \" << node.field()->name() << \" not in schema.\";\n-    return Status::ExpressionValidationError(ss.str());\n-  }\n-\n+  // Ensure that that the found field match.\n   FieldPtr field_in_schema = field_in_schema_entry->second;\n-  // validate that field matches the definition in schema.\n-  if (!field_in_schema->Equals(node.field())) {\n-    std::stringstream ss;\n-    ss << \"Field definition in schema \" << field_in_schema->ToString()\n-       << \" different from field in expression \" << node.field()->ToString();\n-    return Status::ExpressionValidationError(ss.str());\n-  }\n+  ARROW_RETURN_IF(!field_in_schema->Equals(node.field()),\n+                  Status::ExpressionValidationError(\n+                      \"Field definition in schema \", field_in_schema->ToString(),\n+                      \" different from field in expression \", node.field()->ToString()));\n+\n   return Status::OK();\n }\n \n Status ExprValidator::Visit(const FunctionNode& node) {\n   auto desc = node.descriptor();\n   FunctionSignature signature(desc->name(), desc->params(), desc->return_type());\n+\n   const NativeFunction* native_function = registry_.LookupSignature(signature);\n-  if (native_function == nullptr) {\n-    std::stringstream ss;\n-    ss << \"Function \" << signature.ToString() << \" not supported yet. \";\n-    return Status::ExpressionValidationError(ss.str());\n-  }\n+  ARROW_RETURN_IF(native_function == nullptr,\n+                  Status::ExpressionValidationError(\"Function \", signature.ToString(),\n+                                                    \" not supported yet. \"));\n \n   for (auto& child : node.children()) {\n-    Status status = child->Accept(*this);\n-    ARROW_RETURN_NOT_OK(status);\n+    ARROW_RETURN_NOT_OK(child->Accept(*this));\n   }\n+\n   return Status::OK();\n }\n \n Status ExprValidator::Visit(const IfNode& node) {\n-  Status status = node.condition()->Accept(*this);\n-  ARROW_RETURN_NOT_OK(status);\n-  status = node.then_node()->Accept(*this);\n-  ARROW_RETURN_NOT_OK(status);\n-  status = node.else_node()->Accept(*this);\n-  ARROW_RETURN_NOT_OK(status);\n+  ARROW_RETURN_NOT_OK(node.condition()->Accept(*this));\n+  ARROW_RETURN_NOT_OK(node.then_node()->Accept(*this));\n+  ARROW_RETURN_NOT_OK(node.else_node()->Accept(*this));\n \n   auto if_node_ret_type = node.return_type();\n   auto then_node_ret_type = node.then_node()->return_type();\n   auto else_node_ret_type = node.else_node()->return_type();\n \n-  if (!if_node_ret_type->Equals(*then_node_ret_type)) {\n-    std::stringstream ss;\n-    ss << \"Return type of if \" << *if_node_ret_type << \" and then \" << *then_node_ret_type\n-       << \" not matching.\";\n-    return Status::ExpressionValidationError(ss.str());\n-  }\n+  // Then-branch return type must match.\n+  ARROW_RETURN_IF(!if_node_ret_type->Equals(*then_node_ret_type),\n+                  Status::ExpressionValidationError(\n+                      \"Return type of if \", if_node_ret_type->ToString(), \" and then \",\n+                      then_node_ret_type->ToString(), \" not matching.\"));\n \n-  if (!if_node_ret_type->Equals(*else_node_ret_type)) {\n-    std::stringstream ss;\n-    ss << \"Return type of if \" << *if_node_ret_type << \" and else \" << *else_node_ret_type\n-       << \" not matching.\";\n-    return Status::ExpressionValidationError(ss.str());\n-  }\n+  // Else-branch return type must match.\n+  ARROW_RETURN_IF(!if_node_ret_type->Equals(*else_node_ret_type),\n+                  Status::ExpressionValidationError(\n+                      \"Return type of if \", if_node_ret_type->ToString(), \" and else \",\n+                      else_node_ret_type->ToString(), \" not matching.\"));\n \n   return Status::OK();\n }\n \n Status ExprValidator::Visit(const LiteralNode& node) {\n   auto llvm_type = types_->IRType(node.return_type()->id());\n-  if (llvm_type == nullptr) {\n-    std::stringstream ss;\n-    ss << \"Value \" << node.holder() << \" has unsupported data type \"\n-       << node.return_type()->name();\n-    return Status::ExpressionValidationError(ss.str());\n-  }\n+  ARROW_RETURN_IF(llvm_type == nullptr,\n+                  Status::ExpressionValidationError(\"Value \", node.holder(),\n+                                                    \" has unsupported data type \",\n+                                                    node.return_type()->name()));\n+\n   return Status::OK();\n }\n \n Status ExprValidator::Visit(const BooleanNode& node) {\n-  Status status;\n-\n-  if (node.children().size() < 2) {\n-    std::stringstream ss;\n-    ss << \"Boolean expression has \" << node.children().size()\n-       << \" children, expected atleast two\";\n-    return Status::ExpressionValidationError(ss.str());\n-  }\n+  ARROW_RETURN_IF(\n+      node.children().size() < 2,\n+      Status::ExpressionValidationError(\"Boolean expression has \", node.children().size(),\n+                                        \" children, expected atleast two\"));\n \n   for (auto& child : node.children()) {\n-    if (!child->return_type()->Equals(arrow::boolean())) {\n-      std::stringstream ss;\n-      ss << \"Boolean expression has a child with return type \"\n-         << child->return_type()->name() << \", expected return type boolean\";\n-      return Status::ExpressionValidationError(ss.str());\n-    }\n-\n-    status = child->Accept(*this);\n-    ARROW_RETURN_NOT_OK(status);\n+    const auto bool_type = arrow::boolean();\n+    const auto ret_type = child->return_type();\n+\n+    ARROW_RETURN_IF(!ret_type->Equals(bool_type),\n+                    Status::ExpressionValidationError(\n+                        \"Boolean expression has a child with return type \",\n+                        ret_type->ToString(), \", expected return type boolean\"));\n+\n+    ARROW_RETURN_NOT_OK(child->Accept(*this));\n   }\n+\n   return Status::OK();\n }\n \n@@ -178,18 +159,13 @@ Status ExprValidator::Visit(const InExpressionNode<std::string>& node) {\n Status ExprValidator::ValidateInExpression(size_t number_of_values,\n                                            DataTypePtr in_expr_return_type,\n                                            DataTypePtr type_of_values) {\n-  if (static_cast<int32_t>(number_of_values) == 0) {\n-    std::stringstream ss;\n-    ss << \"IN Expression needs a non-empty constant list to match.\";\n-    return Status::ExpressionValidationError(ss.str());\n-  }\n-\n-  if (!in_expr_return_type->Equals(type_of_values)) {\n-    std::stringstream ss;\n-    ss << \"Evaluation expression for IN clause returns \" << in_expr_return_type\n-       << \" values are of type\" << type_of_values;\n-    return Status::ExpressionValidationError(ss.str());\n-  }\n+  ARROW_RETURN_IF(number_of_values == 0,\n+                  Status::ExpressionValidationError(\n+                      \"IN Expression needs a non-empty constant list to match.\"));\n+  ARROW_RETURN_IF(!in_expr_return_type->Equals(type_of_values),\n+                  Status::ExpressionValidationError(\n+                      \"Evaluation expression for IN clause returns \", in_expr_return_type,\n+                      \" values are of type\", type_of_values));\n \n   return Status::OK();\n }\ndiff --git a/cpp/src/gandiva/filter.cc b/cpp/src/gandiva/filter.cc\nindex 7a24d9554e..6075e25745 100644\n--- a/cpp/src/gandiva/filter.cc\n+++ b/cpp/src/gandiva/filter.cc\n@@ -40,32 +40,28 @@ Filter::Filter(std::unique_ptr<LLVMGenerator> llvm_generator, SchemaPtr schema,\n Status Filter::Make(SchemaPtr schema, ConditionPtr condition,\n                     std::shared_ptr<Configuration> configuration,\n                     std::shared_ptr<Filter>* filter) {\n-  ARROW_RETURN_FAILURE_IF_FALSE(schema != nullptr,\n-                                Status::Invalid(\"schema cannot be null\"));\n-  ARROW_RETURN_FAILURE_IF_FALSE(condition != nullptr,\n-                                Status::Invalid(\"condition cannot be null\"));\n-  ARROW_RETURN_FAILURE_IF_FALSE(configuration != nullptr,\n-                                Status::Invalid(\"configuration cannot be null\"));\n+  ARROW_RETURN_IF(schema == nullptr, Status::Invalid(\"Schema cannot be null\"));\n+  ARROW_RETURN_IF(condition == nullptr, Status::Invalid(\"Condition cannot be null\"));\n+  ARROW_RETURN_IF(configuration == nullptr,\n+                  Status::Invalid(\"Configuration cannot be null\"));\n+\n   static Cache<FilterCacheKey, std::shared_ptr<Filter>> cache;\n   FilterCacheKey cache_key(schema, configuration, *(condition.get()));\n-  std::shared_ptr<Filter> cachedFilter = cache.GetModule(cache_key);\n+  auto cachedFilter = cache.GetModule(cache_key);\n   if (cachedFilter != nullptr) {\n     *filter = cachedFilter;\n     return Status::OK();\n   }\n+\n   // Build LLVM generator, and generate code for the specified expression\n   std::unique_ptr<LLVMGenerator> llvm_gen;\n-  Status status = LLVMGenerator::Make(configuration, &llvm_gen);\n-  ARROW_RETURN_NOT_OK(status);\n+  ARROW_RETURN_NOT_OK(LLVMGenerator::Make(configuration, &llvm_gen));\n \n   // Run the validation on the expression.\n   // Return if the expression is invalid since we will not be able to process further.\n   ExprValidator expr_validator(llvm_gen->types(), schema);\n-  status = expr_validator.Validate(condition);\n-  ARROW_RETURN_NOT_OK(status);\n-\n-  status = llvm_gen->Build({condition});\n-  ARROW_RETURN_NOT_OK(status);\n+  ARROW_RETURN_NOT_OK(expr_validator.Validate(condition));\n+  ARROW_RETURN_NOT_OK(llvm_gen->Build({condition}));\n \n   // Instantiate the filter with the completely built llvm generator\n   *filter = std::make_shared<Filter>(std::move(llvm_gen), schema, configuration);\n@@ -76,42 +72,33 @@ Status Filter::Make(SchemaPtr schema, ConditionPtr condition,\n \n Status Filter::Evaluate(const arrow::RecordBatch& batch,\n                         std::shared_ptr<SelectionVector> out_selection) {\n-  if (!batch.schema()->Equals(*schema_)) {\n-    return Status::Invalid(\"Schema in RecordBatch must match the schema in Make()\");\n-  }\n-  if (batch.num_rows() == 0) {\n-    return Status::Invalid(\"RecordBatch must be non-empty.\");\n-  }\n-  if (out_selection == nullptr) {\n-    return Status::Invalid(\"out_selection must be non-null.\");\n-  }\n-  if (out_selection->GetMaxSlots() < batch.num_rows()) {\n-    std::stringstream ss;\n-    ss << \"out_selection has \" << out_selection->GetMaxSlots()\n-       << \" slots, which is less than the batch size \" << batch.num_rows();\n-    return Status::Invalid(ss.str());\n-  }\n+  const auto num_rows = batch.num_rows();\n+  ARROW_RETURN_IF(!batch.schema()->Equals(*schema_),\n+                  Status::Invalid(\"RecordBatch schema must expected filter schema\"));\n+  ARROW_RETURN_IF(num_rows == 0, Status::Invalid(\"RecordBatch must be non-empty.\"));\n+  ARROW_RETURN_IF(out_selection == nullptr,\n+                  Status::Invalid(\"out_selection must be non-null.\"));\n+  ARROW_RETURN_IF(out_selection->GetMaxSlots() < num_rows,\n+                  Status::Invalid(\"Output selection vector capacity too small\"));\n \n   // Allocate three local_bitmaps (one for output, one for validity, one to compute the\n   // intersection).\n-  LocalBitMapsHolder bitmaps(batch.num_rows(), 3 /*local_bitmaps*/);\n+  LocalBitMapsHolder bitmaps(num_rows, 3 /*local_bitmaps*/);\n   int64_t bitmap_size = bitmaps.GetLocalBitMapSize();\n \n   auto validity = std::make_shared<arrow::Buffer>(bitmaps.GetLocalBitMap(0), bitmap_size);\n   auto value = std::make_shared<arrow::Buffer>(bitmaps.GetLocalBitMap(1), bitmap_size);\n-  auto array_data =\n-      arrow::ArrayData::Make(arrow::boolean(), batch.num_rows(), {validity, value});\n+  auto array_data = arrow::ArrayData::Make(arrow::boolean(), num_rows, {validity, value});\n \n   // Execute the expression(s).\n-  auto status = llvm_generator_->Execute(batch, {array_data});\n-  ARROW_RETURN_NOT_OK(status);\n+  ARROW_RETURN_NOT_OK(llvm_generator_->Execute(batch, {array_data}));\n \n   // Compute the intersection of the value and validity.\n   auto result = bitmaps.GetLocalBitMap(2);\n   BitMapAccumulator::IntersectBitMaps(\n-      result, {bitmaps.GetLocalBitMap(0), bitmaps.GetLocalBitMap((1))}, batch.num_rows());\n+      result, {bitmaps.GetLocalBitMap(0), bitmaps.GetLocalBitMap((1))}, num_rows);\n \n-  return out_selection->PopulateFromBitMap(result, bitmap_size, batch.num_rows() - 1);\n+  return out_selection->PopulateFromBitMap(result, bitmap_size, num_rows - 1);\n }\n \n }  // namespace gandiva\ndiff --git a/cpp/src/gandiva/like_holder.cc b/cpp/src/gandiva/like_holder.cc\nindex d659b22c46..051b75b7dc 100644\n--- a/cpp/src/gandiva/like_holder.cc\n+++ b/cpp/src/gandiva/like_holder.cc\n@@ -50,39 +50,40 @@ const FunctionNode LikeHolder::TryOptimize(const FunctionNode& node) {\n     }\n   }\n \n-  // didn't hit any of the optimisation paths. return original.\n+  // Could not optimize, return original node.\n   return node;\n }\n \n+static bool IsArrowStringLiteral(arrow::Type::type type) {\n+  return type == arrow::Type::STRING || type == arrow::Type::BINARY;\n+}\n+\n Status LikeHolder::Make(const FunctionNode& node, std::shared_ptr<LikeHolder>* holder) {\n-  if (node.children().size() != 2) {\n-    return Status::Invalid(\"'like' function requires two parameters\");\n-  }\n+  ARROW_RETURN_IF(node.children().size() != 2,\n+                  Status::Invalid(\"'like' function requires two parameters\"));\n \n   auto literal = dynamic_cast<LiteralNode*>(node.children().at(1).get());\n-  if (literal == nullptr) {\n-    return Status::Invalid(\"'like' function requires a literal as the second parameter\");\n-  }\n+  ARROW_RETURN_IF(\n+      literal == nullptr,\n+      Status::Invalid(\"'like' function requires a literal as the second parameter\"));\n \n   auto literal_type = literal->return_type()->id();\n-  if (literal_type != arrow::Type::STRING && literal_type != arrow::Type::BINARY) {\n-    return Status::Invalid(\n-        \"'like' function requires a string literal as the second parameter\");\n-  }\n-  auto pattern = boost::get<std::string>(literal->holder());\n-  return Make(pattern, holder);\n+  ARROW_RETURN_IF(\n+      !IsArrowStringLiteral(literal_type),\n+      Status::Invalid(\n+          \"'like' function requires a string literal as the second parameter\"));\n+\n+  return Make(boost::get<std::string>(literal->holder()), holder);\n }\n \n Status LikeHolder::Make(const std::string& sql_pattern,\n                         std::shared_ptr<LikeHolder>* holder) {\n   std::string pcre_pattern;\n-  auto status = RegexUtil::SqlLikePatternToPcre(sql_pattern, pcre_pattern);\n-  ARROW_RETURN_NOT_OK(status);\n+  ARROW_RETURN_NOT_OK(RegexUtil::SqlLikePatternToPcre(sql_pattern, pcre_pattern));\n \n   auto lholder = std::shared_ptr<LikeHolder>(new LikeHolder(pcre_pattern));\n-  if (!lholder->regex_.ok()) {\n-    return Status::Invalid(\"building re2 regex failed for pattern \" + pcre_pattern);\n-  }\n+  ARROW_RETURN_IF(!lholder->regex_.ok(),\n+                  Status::Invalid(\"Building RE2 pattern '\", pcre_pattern, \"' failed\"));\n \n   *holder = lholder;\n   return Status::OK();\ndiff --git a/cpp/src/gandiva/llvm_generator.cc b/cpp/src/gandiva/llvm_generator.cc\nindex 82d0386cfb..50f147b2fc 100644\n--- a/cpp/src/gandiva/llvm_generator.cc\n+++ b/cpp/src/gandiva/llvm_generator.cc\n@@ -44,10 +44,10 @@ LLVMGenerator::LLVMGenerator()\n Status LLVMGenerator::Make(std::shared_ptr<Configuration> config,\n                            std::unique_ptr<LLVMGenerator>* llvm_generator) {\n   std::unique_ptr<LLVMGenerator> llvmgen_obj(new LLVMGenerator());\n-  Status status = Engine::Make(config, &(llvmgen_obj->engine_));\n-  ARROW_RETURN_NOT_OK(status);\n \n+  ARROW_RETURN_NOT_OK(Engine::Make(config, &(llvmgen_obj->engine_)));\n   *llvm_generator = std::move(llvmgen_obj);\n+\n   return Status::OK();\n }\n \n@@ -57,33 +57,29 @@ Status LLVMGenerator::Add(const ExpressionPtr expr, const FieldDescriptorPtr out\n   // decompose the expression to separate out value and validities.\n   ExprDecomposer decomposer(function_registry_, annotator_);\n   ValueValidityPairPtr value_validity;\n-  auto status = decomposer.Decompose(*expr->root(), &value_validity);\n-  ARROW_RETURN_NOT_OK(status);\n+  ARROW_RETURN_NOT_OK(decomposer.Decompose(*expr->root(), &value_validity));\n \n   // Generate the IR function for the decomposed expression.\n   llvm::Function* ir_function = nullptr;\n-  status = CodeGenExprValue(value_validity->value_expr(), output, idx, &ir_function);\n-  ARROW_RETURN_NOT_OK(status);\n+  ARROW_RETURN_NOT_OK(\n+      CodeGenExprValue(value_validity->value_expr(), output, idx, &ir_function));\n \n   std::unique_ptr<CompiledExpr> compiled_expr(\n       new CompiledExpr(value_validity, output, ir_function));\n   compiled_exprs_.push_back(std::move(compiled_expr));\n+\n   return Status::OK();\n }\n \n /// Build and optimise module for projection expression.\n Status LLVMGenerator::Build(const ExpressionVector& exprs) {\n-  Status status;\n-\n   for (auto& expr : exprs) {\n     auto output = annotator_.AddOutputFieldDescriptor(expr->result());\n-    status = Add(expr, output);\n-    ARROW_RETURN_NOT_OK(status);\n+    ARROW_RETURN_NOT_OK(Add(expr, output));\n   }\n \n-  // optimise, compile and finalize the module\n-  status = engine_->FinalizeModule(optimise_ir_, dump_ir_);\n-  ARROW_RETURN_NOT_OK(status);\n+  // Optimize, compile and finalize the module\n+  ARROW_RETURN_NOT_OK(engine_->FinalizeModule(optimise_ir_, dump_ir_));\n \n   // setup the jit functions for each expression.\n   for (auto& compiled_expr : compiled_exprs_) {\n@@ -91,6 +87,7 @@ Status LLVMGenerator::Build(const ExpressionVector& exprs) {\n     EvalFunc fn = reinterpret_cast<EvalFunc>(engine_->CompiledFunction(ir_func));\n     compiled_expr->set_jit_function(fn);\n   }\n+\n   return Status::OK();\n }\n \n@@ -107,13 +104,15 @@ Status LLVMGenerator::Execute(const arrow::RecordBatch& record_batch,\n     EvalFunc jit_function = compiled_expr->jit_function();\n     jit_function(eval_batch->GetBufferArray(), eval_batch->GetLocalBitMapArray(),\n                  (int64_t)eval_batch->GetExecutionContext(), record_batch.num_rows());\n-    // check for execution errors\n-    if (eval_batch->GetExecutionContext()->has_error()) {\n-      return Status::ExecutionError(eval_batch->GetExecutionContext()->get_error());\n-    }\n+\n+    ARROW_RETURN_IF(\n+        eval_batch->GetExecutionContext()->has_error(),\n+        Status::ExecutionError(eval_batch->GetExecutionContext()->get_error()));\n+\n     // generate validity vectors.\n     ComputeBitMapsForExpr(*compiled_expr, *eval_batch);\n   }\n+\n   return Status::OK();\n }\n \n@@ -233,8 +232,8 @@ Status LLVMGenerator::CodeGenExprValue(DexPtr value_expr, FieldDescriptorPtr out\n   engine_->AddFunctionToCompile(func_name);\n   *fn = llvm::Function::Create(prototype, llvm::GlobalValue::ExternalLinkage, func_name,\n                                module());\n-  ARROW_RETURN_FAILURE_IF_FALSE((*fn != nullptr),\n-                                Status::CodeGenError(\"Error creating function.\"));\n+  ARROW_RETURN_IF((*fn == nullptr), Status::CodeGenError(\"Error creating function.\"));\n+\n   // Name the arguments\n   llvm::Function::arg_iterator args = (*fn)->arg_begin();\n   llvm::Value* arg_addrs = &*args;\n@@ -396,6 +395,7 @@ llvm::Value* LLVMGenerator::AddFunctionCall(const std::string& full_name,\n     value = ir_builder()->CreateCall(fn, args, full_name);\n     DCHECK(value->getType() == ret_type);\n   }\n+\n   return value;\n }\n \ndiff --git a/cpp/src/gandiva/projector.cc b/cpp/src/gandiva/projector.cc\nindex 40fdc20113..d5902fc72f 100644\n--- a/cpp/src/gandiva/projector.cc\n+++ b/cpp/src/gandiva/projector.cc\n@@ -45,12 +45,10 @@ Status Projector::Make(SchemaPtr schema, const ExpressionVector& exprs,\n Status Projector::Make(SchemaPtr schema, const ExpressionVector& exprs,\n                        std::shared_ptr<Configuration> configuration,\n                        std::shared_ptr<Projector>* projector) {\n-  ARROW_RETURN_FAILURE_IF_FALSE(schema != nullptr,\n-                                Status::Invalid(\"schema cannot be null\"));\n-  ARROW_RETURN_FAILURE_IF_FALSE(!exprs.empty(),\n-                                Status::Invalid(\"expressions need to be non-empty\"));\n-  ARROW_RETURN_FAILURE_IF_FALSE(configuration != nullptr,\n-                                Status::Invalid(\"configuration cannot be null\"));\n+  ARROW_RETURN_IF(schema == nullptr, Status::Invalid(\"Schema cannot be null\"));\n+  ARROW_RETURN_IF(exprs.empty(), Status::Invalid(\"Expressions cannot be empty\"));\n+  ARROW_RETURN_IF(configuration == nullptr,\n+                  Status::Invalid(\"Configuration cannot be null\"));\n \n   // see if equivalent projector was already built\n   static Cache<ProjectorCacheKey, std::shared_ptr<Projector>> cache;\n@@ -63,23 +61,21 @@ Status Projector::Make(SchemaPtr schema, const ExpressionVector& exprs,\n \n   // Build LLVM generator, and generate code for the specified expressions\n   std::unique_ptr<LLVMGenerator> llvm_gen;\n-  Status status = LLVMGenerator::Make(configuration, &llvm_gen);\n-  ARROW_RETURN_NOT_OK(status);\n+  ARROW_RETURN_NOT_OK(LLVMGenerator::Make(configuration, &llvm_gen));\n \n   // Run the validation on the expressions.\n   // Return if any of the expression is invalid since\n   // we will not be able to process further.\n   ExprValidator expr_validator(llvm_gen->types(), schema);\n   for (auto& expr : exprs) {\n-    status = expr_validator.Validate(expr);\n-    ARROW_RETURN_NOT_OK(status);\n+    ARROW_RETURN_NOT_OK(expr_validator.Validate(expr));\n   }\n \n-  status = llvm_gen->Build(exprs);\n-  ARROW_RETURN_NOT_OK(status);\n+  ARROW_RETURN_NOT_OK(llvm_gen->Build(exprs));\n \n   // save the output field types. Used for validation at Evaluate() time.\n   std::vector<FieldPtr> output_fields;\n+  output_fields.reserve(exprs.size());\n   for (auto& expr : exprs) {\n     output_fields.push_back(expr->result());\n   }\n@@ -94,86 +90,70 @@ Status Projector::Make(SchemaPtr schema, const ExpressionVector& exprs,\n \n Status Projector::Evaluate(const arrow::RecordBatch& batch,\n                            const ArrayDataVector& output_data_vecs) {\n-  Status status = ValidateEvaluateArgsCommon(batch);\n-  ARROW_RETURN_NOT_OK(status);\n-\n-  if (output_data_vecs.size() != output_fields_.size()) {\n-    std::stringstream ss;\n-    ss << \"number of buffers for output_data_vecs is \" << output_data_vecs.size()\n-       << \", expected \" << output_fields_.size();\n-    return Status::Invalid(ss.str());\n-  }\n+  ARROW_RETURN_NOT_OK(ValidateEvaluateArgsCommon(batch));\n+  ARROW_RETURN_IF(\n+      output_data_vecs.size() != output_fields_.size(),\n+      Status::Invalid(\"Number of output buffers must match number of fields\"));\n \n   int idx = 0;\n   for (auto& array_data : output_data_vecs) {\n+    const auto output_field = output_fields_[idx];\n     if (array_data == nullptr) {\n-      std::stringstream ss;\n-      ss << \"array for output field \" << output_fields_[idx]->name() << \"is null.\";\n-      return Status::Invalid(ss.str());\n+      return Status::Invalid(\"Output array for field \", output_field->name(),\n+                             \" should not be null\");\n     }\n \n-    Status status =\n-        ValidateArrayDataCapacity(*array_data, *(output_fields_[idx]), batch.num_rows());\n-    ARROW_RETURN_NOT_OK(status);\n+    ARROW_RETURN_NOT_OK(\n+        ValidateArrayDataCapacity(*array_data, *output_field, batch.num_rows()));\n     ++idx;\n   }\n+\n   return llvm_generator_->Execute(batch, output_data_vecs);\n }\n \n Status Projector::Evaluate(const arrow::RecordBatch& batch, arrow::MemoryPool* pool,\n                            arrow::ArrayVector* output) {\n-  Status status = ValidateEvaluateArgsCommon(batch);\n-  ARROW_RETURN_NOT_OK(status);\n-\n-  if (output == nullptr) {\n-    return Status::Invalid(\"output must be non-null.\");\n-  }\n-\n-  if (pool == nullptr) {\n-    return Status::Invalid(\"memory pool must be non-null.\");\n-  }\n+  ARROW_RETURN_NOT_OK(ValidateEvaluateArgsCommon(batch));\n+  ARROW_RETURN_IF(output == nullptr, Status::Invalid(\"Output must be non-null.\"));\n+  ARROW_RETURN_IF(pool == nullptr, Status::Invalid(\"Memory pool must be non-null.\"));\n \n   // Allocate the output data vecs.\n   ArrayDataVector output_data_vecs;\n+  output_data_vecs.reserve(output_fields_.size());\n   for (auto& field : output_fields_) {\n     ArrayDataPtr output_data;\n \n-    status = AllocArrayData(field->type(), batch.num_rows(), pool, &output_data);\n-    ARROW_RETURN_NOT_OK(status);\n-\n+    ARROW_RETURN_NOT_OK(\n+        AllocArrayData(field->type(), batch.num_rows(), pool, &output_data));\n     output_data_vecs.push_back(output_data);\n   }\n \n   // Execute the expression(s).\n-  status = llvm_generator_->Execute(batch, output_data_vecs);\n-  ARROW_RETURN_NOT_OK(status);\n+  ARROW_RETURN_NOT_OK(llvm_generator_->Execute(batch, output_data_vecs));\n \n   // Create and return array arrays.\n   output->clear();\n   for (auto& array_data : output_data_vecs) {\n     output->push_back(arrow::MakeArray(array_data));\n   }\n+\n   return Status::OK();\n }\n \n // TODO : handle variable-len vectors\n Status Projector::AllocArrayData(const DataTypePtr& type, int64_t num_records,\n                                  arrow::MemoryPool* pool, ArrayDataPtr* array_data) {\n-  if (!arrow::is_primitive(type->id())) {\n-    return Status::Invalid(\"Unsupported output data type \" + type->ToString());\n-  }\n+  ARROW_RETURN_IF(!arrow::is_primitive(type->id()),\n+                  Status::Invalid(\"Unsupported output data type \", type));\n \n-  arrow::Status astatus;\n   std::shared_ptr<arrow::Buffer> null_bitmap;\n-  int64_t size = arrow::BitUtil::BytesForBits(num_records);\n-  astatus = arrow::AllocateBuffer(pool, size, &null_bitmap);\n-  ARROW_RETURN_NOT_OK(astatus);\n+  int64_t bitmap_bytes = arrow::BitUtil::BytesForBits(num_records);\n+  ARROW_RETURN_NOT_OK(arrow::AllocateBuffer(pool, bitmap_bytes, &null_bitmap));\n \n   std::shared_ptr<arrow::Buffer> data;\n   const auto& fw_type = dynamic_cast<const arrow::FixedWidthType&>(*type);\n   int64_t data_len = arrow::BitUtil::BytesForBits(num_records * fw_type.bit_width());\n-  astatus = arrow::AllocateBuffer(pool, data_len, &data);\n-  ARROW_RETURN_NOT_OK(astatus);\n+  ARROW_RETURN_NOT_OK(arrow::AllocateBuffer(pool, data_len, &data));\n \n   // Valgrind detects unitialized memory at byte level. Boolean types use bits\n   // and can leave buffer memory uninitialized in the last byte.\n@@ -186,47 +166,33 @@ Status Projector::AllocArrayData(const DataTypePtr& type, int64_t num_records,\n }\n \n Status Projector::ValidateEvaluateArgsCommon(const arrow::RecordBatch& batch) {\n-  if (!batch.schema()->Equals(*schema_)) {\n-    return Status::Invalid(\"Schema in RecordBatch must match the schema in Make()\");\n-  }\n-  if (batch.num_rows() == 0) {\n-    return Status::Invalid(\"RecordBatch must be non-empty.\");\n-  }\n+  ARROW_RETURN_IF(!batch.schema()->Equals(*schema_),\n+                  Status::Invalid(\"Schema in RecordBatch must match schema in Make()\"));\n+  ARROW_RETURN_IF(batch.num_rows() == 0,\n+                  Status::Invalid(\"RecordBatch must be non-empty.\"));\n+\n   return Status::OK();\n }\n \n Status Projector::ValidateArrayDataCapacity(const arrow::ArrayData& array_data,\n                                             const arrow::Field& field,\n                                             int64_t num_records) {\n-  // verify that there are atleast two buffers (validity and data).\n-  if (array_data.buffers.size() < 2) {\n-    std::stringstream ss;\n-    ss << \"number of buffers for output field \" << field.name() << \"is \"\n-       << array_data.buffers.size() << \", must have minimum 2.\";\n-    return Status::Invalid(ss.str());\n-  }\n+  ARROW_RETURN_IF(array_data.buffers.size() < 2,\n+                  Status::Invalid(\"ArrayData must have at least 2 buffers\"));\n \n-  // verify size of bitmap buffer.\n   int64_t min_bitmap_len = arrow::BitUtil::BytesForBits(num_records);\n   int64_t bitmap_len = array_data.buffers[0]->capacity();\n-  if (bitmap_len < min_bitmap_len) {\n-    std::stringstream ss;\n-    ss << \"bitmap buffer for output field \" << field.name() << \"has size \" << bitmap_len\n-       << \", must have minimum size \" << min_bitmap_len;\n-    return Status::Invalid(ss.str());\n-  }\n+  ARROW_RETURN_IF(bitmap_len < min_bitmap_len,\n+                  Status::Invalid(\"Bitmap buffer too small for \", field.name()));\n \n   // verify size of data buffer.\n   // TODO : handle variable-len vectors\n   const auto& fw_type = dynamic_cast<const arrow::FixedWidthType&>(*field.type());\n   int64_t min_data_len = arrow::BitUtil::BytesForBits(num_records * fw_type.bit_width());\n   int64_t data_len = array_data.buffers[1]->capacity();\n-  if (data_len < min_data_len) {\n-    std::stringstream ss;\n-    ss << \"data buffer for output field \" << field.name() << \" has size \" << data_len\n-       << \", must have minimum size \" << min_data_len;\n-    return Status::Invalid(ss.str());\n-  }\n+  ARROW_RETURN_IF(data_len < min_data_len,\n+                  Status::Invalid(\"Data buffer too small for \", field.name()));\n+\n   return Status::OK();\n }\n \ndiff --git a/cpp/src/gandiva/regex_util.cc b/cpp/src/gandiva/regex_util.cc\nindex 893af095a3..1d3860615d 100644\n--- a/cpp/src/gandiva/regex_util.cc\n+++ b/cpp/src/gandiva/regex_util.cc\n@@ -38,20 +38,16 @@ Status RegexUtil::SqlLikePatternToPcre(const std::string& sql_pattern, char esca\n     if (cur == escape_char) {\n       // escape char must be followed by '_', '%' or the escape char itself.\n       ++idx;\n-      if (idx == sql_pattern.size()) {\n-        std::stringstream msg;\n-        msg << \"unexpected escape char at the end of pattern \" << sql_pattern;\n-        return Status::Invalid(msg.str());\n-      }\n+      ARROW_RETURN_IF(\n+          idx == sql_pattern.size(),\n+          Status::Invalid(\"Unexpected escape char at the end of pattern \", sql_pattern));\n \n       cur = sql_pattern.at(idx);\n       if (cur == '_' || cur == '%' || cur == escape_char) {\n         pcre_pattern += cur;\n       } else {\n-        std::stringstream msg;\n-        msg << \"invalid escape sequence in pattern \" << sql_pattern << \" at offset \"\n-            << idx;\n-        return Status::Invalid(msg.str());\n+        return Status::Invalid(\"Invalid escape sequence in pattern \", sql_pattern,\n+                               \" at offset \", idx);\n       }\n     } else if (cur == '_') {\n       pcre_pattern += '.';\ndiff --git a/cpp/src/gandiva/selection_vector.cc b/cpp/src/gandiva/selection_vector.cc\nindex 9266ca7fe1..f89b80c2b5 100644\n--- a/cpp/src/gandiva/selection_vector.cc\n+++ b/cpp/src/gandiva/selection_vector.cc\n@@ -28,22 +28,15 @@ namespace gandiva {\n \n Status SelectionVector::PopulateFromBitMap(const uint8_t* bitmap, int64_t bitmap_size,\n                                            int64_t max_bitmap_index) {\n-  if (bitmap_size % 8 != 0) {\n-    std::stringstream ss;\n-    ss << \"bitmap size \" << bitmap_size << \" must be padded to 64-bit size\";\n-    return Status::Invalid(ss.str());\n-  }\n-  if (max_bitmap_index < 0) {\n-    std::stringstream ss;\n-    ss << \"max bitmap index \" << max_bitmap_index << \" must be positive\";\n-    return Status::Invalid(ss.str());\n-  }\n-  if (static_cast<uint64_t>(max_bitmap_index) > GetMaxSupportedValue()) {\n-    std::stringstream ss;\n-    ss << \"max_bitmap_index \" << max_bitmap_index << \" must be <= maxSupportedValue \"\n-       << GetMaxSupportedValue() << \" in selection vector\";\n-    return Status::Invalid(ss.str());\n-  }\n+  const uint64_t max_idx = static_cast<uint64_t>(max_bitmap_index);\n+  ARROW_RETURN_IF(bitmap_size % 8, Status::Invalid(\"Bitmap size \", bitmap_size,\n+                                                   \" must be aligned to 64-bit size\"));\n+  ARROW_RETURN_IF(max_bitmap_index < 0,\n+                  Status::Invalid(\"Max bitmap index must be positive\"));\n+  ARROW_RETURN_IF(\n+      max_idx > GetMaxSupportedValue(),\n+      Status::Invalid(\"max_bitmap_index \", max_idx, \" must be <= maxSupportedValue \",\n+                      GetMaxSupportedValue(), \" in selection vector\"));\n \n   int64_t max_slots = GetMaxSlots();\n \n@@ -64,9 +57,9 @@ Status SelectionVector::PopulateFromBitMap(const uint8_t* bitmap, int64_t bitmap\n         break;\n       }\n \n-      if (selection_idx >= max_slots) {\n-        return Status::Invalid(\"selection vector has no remaining slots\");\n-      }\n+      ARROW_RETURN_IF(selection_idx >= max_slots,\n+                      Status::Invalid(\"selection vector has no remaining slots\"));\n+\n       SetIndex(selection_idx, pos_in_bitmap);\n       ++selection_idx;\n \n@@ -81,60 +74,54 @@ Status SelectionVector::PopulateFromBitMap(const uint8_t* bitmap, int64_t bitmap\n Status SelectionVector::MakeInt16(int64_t max_slots,\n                                   std::shared_ptr<arrow::Buffer> buffer,\n                                   std::shared_ptr<SelectionVector>* selection_vector) {\n-  auto status = SelectionVectorInt16::ValidateBuffer(max_slots, buffer);\n-  ARROW_RETURN_NOT_OK(status);\n-\n+  ARROW_RETURN_NOT_OK(SelectionVectorInt16::ValidateBuffer(max_slots, buffer));\n   *selection_vector = std::make_shared<SelectionVectorInt16>(max_slots, buffer);\n+\n   return Status::OK();\n }\n \n Status SelectionVector::MakeInt16(int64_t max_slots, arrow::MemoryPool* pool,\n                                   std::shared_ptr<SelectionVector>* selection_vector) {\n   std::shared_ptr<arrow::Buffer> buffer;\n-  auto status = SelectionVectorInt16::AllocateBuffer(max_slots, pool, &buffer);\n-  ARROW_RETURN_NOT_OK(status);\n-\n+  ARROW_RETURN_NOT_OK(SelectionVectorInt16::AllocateBuffer(max_slots, pool, &buffer));\n   *selection_vector = std::make_shared<SelectionVectorInt16>(max_slots, buffer);\n+\n   return Status::OK();\n }\n \n Status SelectionVector::MakeInt32(int64_t max_slots,\n                                   std::shared_ptr<arrow::Buffer> buffer,\n                                   std::shared_ptr<SelectionVector>* selection_vector) {\n-  auto status = SelectionVectorInt32::ValidateBuffer(max_slots, buffer);\n-  ARROW_RETURN_NOT_OK(status);\n-\n+  ARROW_RETURN_NOT_OK(SelectionVectorInt32::ValidateBuffer(max_slots, buffer));\n   *selection_vector = std::make_shared<SelectionVectorInt32>(max_slots, buffer);\n+\n   return Status::OK();\n }\n \n Status SelectionVector::MakeInt32(int64_t max_slots, arrow::MemoryPool* pool,\n                                   std::shared_ptr<SelectionVector>* selection_vector) {\n   std::shared_ptr<arrow::Buffer> buffer;\n-  auto status = SelectionVectorInt32::AllocateBuffer(max_slots, pool, &buffer);\n-  ARROW_RETURN_NOT_OK(status);\n-\n+  ARROW_RETURN_NOT_OK(SelectionVectorInt32::AllocateBuffer(max_slots, pool, &buffer));\n   *selection_vector = std::make_shared<SelectionVectorInt32>(max_slots, buffer);\n+\n   return Status::OK();\n }\n \n Status SelectionVector::MakeInt64(int64_t max_slots,\n                                   std::shared_ptr<arrow::Buffer> buffer,\n                                   std::shared_ptr<SelectionVector>* selection_vector) {\n-  auto status = SelectionVectorInt64::ValidateBuffer(max_slots, buffer);\n-  ARROW_RETURN_NOT_OK(status);\n-\n+  ARROW_RETURN_NOT_OK(SelectionVectorInt64::ValidateBuffer(max_slots, buffer));\n   *selection_vector = std::make_shared<SelectionVectorInt64>(max_slots, buffer);\n+\n   return Status::OK();\n }\n \n Status SelectionVector::MakeInt64(int64_t max_slots, arrow::MemoryPool* pool,\n                                   std::shared_ptr<SelectionVector>* selection_vector) {\n   std::shared_ptr<arrow::Buffer> buffer;\n-  auto status = SelectionVectorInt64::AllocateBuffer(max_slots, pool, &buffer);\n-  ARROW_RETURN_NOT_OK(status);\n-\n+  ARROW_RETURN_NOT_OK(SelectionVectorInt64::AllocateBuffer(max_slots, pool, &buffer));\n   *selection_vector = std::make_shared<SelectionVectorInt64>(max_slots, buffer);\n+\n   return Status::OK();\n }\n \n@@ -142,8 +129,7 @@ template <typename C_TYPE, typename A_TYPE>\n Status SelectionVectorImpl<C_TYPE, A_TYPE>::AllocateBuffer(\n     int64_t max_slots, arrow::MemoryPool* pool, std::shared_ptr<arrow::Buffer>* buffer) {\n   auto buffer_len = max_slots * sizeof(C_TYPE);\n-  auto astatus = arrow::AllocateBuffer(pool, buffer_len, buffer);\n-  ARROW_RETURN_NOT_OK(astatus);\n+  ARROW_RETURN_NOT_OK(arrow::AllocateBuffer(pool, buffer_len, buffer));\n \n   return Status::OK();\n }\n@@ -151,19 +137,13 @@ Status SelectionVectorImpl<C_TYPE, A_TYPE>::AllocateBuffer(\n template <typename C_TYPE, typename A_TYPE>\n Status SelectionVectorImpl<C_TYPE, A_TYPE>::ValidateBuffer(\n     int64_t max_slots, std::shared_ptr<arrow::Buffer> buffer) {\n-  // verify buffer is mutable\n-  if (!buffer->is_mutable()) {\n-    return Status::Invalid(\"buffer for selection vector must be mutable\");\n-  }\n+  ARROW_RETURN_IF(!buffer->is_mutable(),\n+                  Status::Invalid(\"buffer for selection vector must be mutable\"));\n+\n+  const int64_t min_len = max_slots * sizeof(C_TYPE);\n+  ARROW_RETURN_IF(buffer->size() < min_len,\n+                  Status::Invalid(\"Buffer for selection vector is too small\"));\n \n-  // verify size of buffer.\n-  int64_t min_len = max_slots * sizeof(C_TYPE);\n-  if (buffer->size() < min_len) {\n-    std::stringstream ss;\n-    ss << \"buffer for selection_data has size \" << buffer->size()\n-       << \", must have minimum size \" << min_len;\n-    return Status::Invalid(ss.str());\n-  }\n   return Status::OK();\n }\n \ndiff --git a/cpp/src/gandiva/tests/projector_build_validation_test.cc b/cpp/src/gandiva/tests/projector_build_validation_test.cc\nindex ddcb729b3b..18f02957fd 100644\n--- a/cpp/src/gandiva/tests/projector_build_validation_test.cc\n+++ b/cpp/src/gandiva/tests/projector_build_validation_test.cc\n@@ -191,8 +191,6 @@ TEST_F(TestProjector, TestIfNotMatchingReturnType) {\n   std::shared_ptr<Projector> projector;\n   Status status = Projector::Make(schema, {expr}, &projector);\n   EXPECT_TRUE(status.IsExpressionValidationError());\n-  std::string expected_error = \"Return type of if bool and then int32 not matching.\";\n-  EXPECT_TRUE(status.message().find(expected_error) != std::string::npos);\n }\n \n TEST_F(TestProjector, TestElseNotMatchingReturnType) {\n@@ -218,8 +216,6 @@ TEST_F(TestProjector, TestElseNotMatchingReturnType) {\n   std::shared_ptr<Projector> projector;\n   Status status = Projector::Make(schema, {expr}, &projector);\n   EXPECT_TRUE(status.IsExpressionValidationError());\n-  std::string expected_error = \"Return type of if int32 and else bool not matching.\";\n-  EXPECT_TRUE(status.message().find(expected_error) != std::string::npos);\n }\n \n TEST_F(TestProjector, TestElseNotSupportedType) {\n@@ -245,8 +241,7 @@ TEST_F(TestProjector, TestElseNotSupportedType) {\n   std::shared_ptr<Projector> projector;\n   Status status = Projector::Make(schema, {expr}, &projector);\n   EXPECT_TRUE(status.IsExpressionValidationError());\n-  std::string expected_error = \"Field c has unsupported data type list\";\n-  EXPECT_TRUE(status.message().find(expected_error) != std::string::npos);\n+  EXPECT_EQ(status.code(), StatusCode::ExpressionValidationError);\n }\n \n TEST_F(TestProjector, TestAndMinChildren) {\n@@ -266,8 +261,6 @@ TEST_F(TestProjector, TestAndMinChildren) {\n   std::shared_ptr<Projector> projector;\n   Status status = Projector::Make(schema, {expr}, &projector);\n   EXPECT_TRUE(status.IsExpressionValidationError());\n-  std::string expected_error = \"Boolean expression has 1 children, expected atleast two\";\n-  EXPECT_TRUE(status.message().find(expected_error) != std::string::npos);\n }\n \n TEST_F(TestProjector, TestAndBooleanArgType) {\n@@ -289,10 +282,6 @@ TEST_F(TestProjector, TestAndBooleanArgType) {\n   std::shared_ptr<Projector> projector;\n   Status status = Projector::Make(schema, {expr}, &projector);\n   EXPECT_TRUE(status.IsExpressionValidationError());\n-  std::string expected_error =\n-      \"Boolean expression has a child with return type int32, expected return type \"\n-      \"boolean\";\n-  EXPECT_TRUE(status.message().find(expected_error) != std::string::npos);\n }\n \n }  // namespace gandiva\ndiff --git a/cpp/src/parquet/arrow/reader.cc b/cpp/src/parquet/arrow/reader.cc\nindex 7830b6abc7..b5905fddff 100644\n--- a/cpp/src/parquet/arrow/reader.cc\n+++ b/cpp/src/parquet/arrow/reader.cc\n@@ -690,10 +690,8 @@ Status FileReader::GetRecordBatchReader(const std::vector<int>& row_group_indice\n   int max_num = num_row_groups();\n   for (auto row_group_index : row_group_indices) {\n     if (row_group_index < 0 || row_group_index >= max_num) {\n-      std::ostringstream ss;\n-      ss << \"Some index in row_group_indices is \" << row_group_index\n-         << \", which is either < 0 or >= num_row_groups(\" << max_num << \")\";\n-      return Status::Invalid(ss.str());\n+      return Status::Invalid(\"Some index in row_group_indices is \", row_group_index,\n+                             \", which is either < 0 or >= num_row_groups(\", max_num, \")\");\n     }\n   }\n \n@@ -1495,9 +1493,8 @@ Status PrimitiveImpl::NextBatch(int64_t records_to_read,\n       TRANSFER_CASE(TIME32, ::arrow::Time32Type, Int32Type)\n       TRANSFER_CASE(TIME64, ::arrow::Time64Type, Int64Type)\n     default:\n-      std::stringstream ss;\n-      ss << \"No support for reading columns of type \" << field_->type()->ToString();\n-      return Status::NotImplemented(ss.str());\n+      return Status::NotImplemented(\"No support for reading columns of type \",\n+                                    field_->type()->ToString());\n   }\n \n   DCHECK_NE(result.kind(), Datum::NONE);\ndiff --git a/cpp/src/parquet/arrow/schema.cc b/cpp/src/parquet/arrow/schema.cc\nindex af9fbc91a5..fed0e59dfa 100644\n--- a/cpp/src/parquet/arrow/schema.cc\n+++ b/cpp/src/parquet/arrow/schema.cc\n@@ -80,10 +80,9 @@ static Status FromFLBA(const PrimitiveNode& node, std::shared_ptr<ArrowType>* ou\n       *out = MakeDecimal128Type(node);\n       break;\n     default:\n-      std::stringstream ss;\n-      ss << \"Unhandled logical type \" << LogicalTypeToString(node.logical_type())\n-         << \" for fixed-length binary array\";\n-      return Status::NotImplemented(ss.str());\n+      return Status::NotImplemented(\"Unhandled logical type \",\n+                                    LogicalTypeToString(node.logical_type()),\n+                                    \" for fixed-length binary array\");\n   }\n \n   return Status::OK();\n@@ -122,10 +121,9 @@ static Status FromInt32(const PrimitiveNode& node, std::shared_ptr<ArrowType>* o\n       *out = MakeDecimal128Type(node);\n       break;\n     default:\n-      std::stringstream ss;\n-      ss << \"Unhandled logical type \" << LogicalTypeToString(node.logical_type())\n-         << \" for INT32\";\n-      return Status::NotImplemented(ss.str());\n+      return Status::NotImplemented(\"Unhandled logical type \",\n+                                    LogicalTypeToString(node.logical_type()),\n+                                    \" for INT32\");\n   }\n   return Status::OK();\n }\n@@ -154,10 +152,9 @@ static Status FromInt64(const PrimitiveNode& node, std::shared_ptr<ArrowType>* o\n       *out = ::arrow::time64(::arrow::TimeUnit::MICRO);\n       break;\n     default:\n-      std::stringstream ss;\n-      ss << \"Unhandled logical type \" << LogicalTypeToString(node.logical_type())\n-         << \" for INT64\";\n-      return Status::NotImplemented(ss.str());\n+      return Status::NotImplemented(\"Unhandled logical type \",\n+                                    LogicalTypeToString(node.logical_type()),\n+                                    \" for INT64\");\n   }\n   return Status::OK();\n }\n@@ -613,10 +610,9 @@ Status FieldToNode(const std::shared_ptr<Field>& field,\n     }\n     default: {\n       // TODO: DENSE_UNION, SPARE_UNION, JSON_SCALAR, DECIMAL_TEXT, VARCHAR\n-      std::stringstream ss;\n-      ss << \"Unhandled type for Arrow to Parquet schema conversion: \";\n-      ss << field->type()->ToString();\n-      return Status::NotImplemented(ss.str());\n+      return Status::NotImplemented(\n+          \"Unhandled type for Arrow to Parquet schema conversion: \",\n+          field->type()->ToString());\n     }\n   }\n   PARQUET_CATCH_NOT_OK(*out =\ndiff --git a/cpp/src/parquet/arrow/writer.cc b/cpp/src/parquet/arrow/writer.cc\nindex bce9f37026..a8153cac1e 100644\n--- a/cpp/src/parquet/arrow/writer.cc\n+++ b/cpp/src/parquet/arrow/writer.cc\n@@ -676,10 +676,8 @@ Status ArrowColumnWriter::WriteTimestampsCoerce(const bool truncated_timestamps_\n   auto DivideBy = [&](const int64_t factor) {\n     for (int64_t i = 0; i < array.length(); i++) {\n       if (!truncated_timestamps_allowed && !data.IsNull(i) && (values[i] % factor != 0)) {\n-        std::stringstream ss;\n-        ss << \"Casting from \" << type.ToString() << \" to \" << target_type->ToString()\n-           << \" would lose data: \" << values[i];\n-        return Status::Invalid(ss.str());\n+        return Status::Invalid(\"Casting from \", type.ToString(), \" to \",\n+                               target_type->ToString(), \" would lose data: \", values[i]);\n       }\n       buffer[i] = values[i] / factor;\n     }\n@@ -950,9 +948,8 @@ Status ArrowColumnWriter::Write(const Array& data) {\n     default:\n       break;\n   }\n-  std::stringstream ss;\n-  ss << \"Data type not supported as list value: \" << values_array->type()->ToString();\n-  return Status::NotImplemented(ss.str());\n+  return Status::NotImplemented(\"Data type not supported as list value: \",\n+                                values_array->type()->ToString());\n }\n \n }  // namespace\ndiff --git a/cpp/src/plasma/io.cc b/cpp/src/plasma/io.cc\nindex d63ceb6da2..d2794e89d3 100644\n--- a/cpp/src/plasma/io.cc\n+++ b/cpp/src/plasma/io.cc\n@@ -49,7 +49,7 @@ Status WriteBytes(int fd, uint8_t* cursor, size_t length) {\n       if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR) {\n         continue;\n       }\n-      return Status::IOError(std::string(strerror(errno)));\n+      return Status::IOError(strerror(errno));\n     } else if (nbytes == 0) {\n       return Status::IOError(\"Encountered unexpected EOF\");\n     }\n@@ -80,7 +80,7 @@ Status ReadBytes(int fd, uint8_t* cursor, size_t length) {\n       if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR) {\n         continue;\n       }\n-      return Status::IOError(std::string(strerror(errno)));\n+      return Status::IOError(strerror(errno));\n     } else if (0 == nbytes) {\n       return Status::IOError(\"Encountered unexpected EOF\");\n     }\n@@ -171,12 +171,12 @@ Status ConnectIpcSocketRetry(const std::string& pathname, int num_retries,\n     *fd = ConnectIpcSock(pathname);\n     --num_retries;\n   }\n+\n   // If we could not connect to the socket, exit.\n   if (*fd == -1) {\n-    std::stringstream ss;\n-    ss << \"Could not connect to socket \" << pathname;\n-    return Status::IOError(ss.str());\n+    return Status::IOError(\"Could not connect to socket \", pathname);\n   }\n+\n   return Status::OK();\n }\n \n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-20T14:51:48.932+0000",
                    "updated": "2018-12-20T14:51:48.932+0000",
                    "started": "2018-12-20T14:51:48.931+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "177536",
                    "issueId": "13205492"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 7200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@3a393413[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@48ae34d8[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7a87c937[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@43b62a4b[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@38355009[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@5ed3826f[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1ad936f3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@684fb391[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7ae80389[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@38ea2641[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6bd7e101[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@7e9104d1[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 7200,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Dec 20 14:51:37 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-12-20T14:51:37.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-4084/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2018-12-19T19:47:14.000+0000",
        "updated": "2018-12-20T14:51:48.000+0000",
        "timeoriginalestimate": null,
        "description": "There's a lot of stringstream repetition when creating a Status.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 7200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Simplify Status and stringstream boilerplate",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13205492/comment/16725914",
                    "id": "16725914",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 3228\n[https://github.com/apache/arrow/pull/3228]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-12-20T14:51:37.436+0000",
                    "updated": "2018-12-20T14:51:37.436+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|u005go:",
        "customfield_12314139": null
    }
}