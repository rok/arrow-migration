{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13183717",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717",
    "key": "ARROW-3191",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12344925",
                "id": "12344925",
                "description": "",
                "name": "0.14.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-07-04"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12553784",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12553784",
                "type": {
                    "id": "10032",
                    "name": "Blocker",
                    "inward": "is blocked by",
                    "outward": "blocks",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10032"
                },
                "outwardIssue": {
                    "id": "13214915",
                    "key": "ARROW-4526",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13214915",
                    "fields": {
                        "summary": "[Java] Remove Netty references from ArrowBuf and move Allocator out of vector package",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/2",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/critical.svg",
                            "name": "Critical",
                            "id": "2"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=siddteotia",
            "name": "siddteotia",
            "key": "siddteotia",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=siddteotia&avatarId=32343",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=siddteotia&avatarId=32343",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=siddteotia&avatarId=32343",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=siddteotia&avatarId=32343"
            },
            "displayName": "Siddharth Teotia",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328933",
                "id": "12328933",
                "name": "Java"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
            "name": "jnadeau",
            "key": "jnadeau",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Jacques Nadeau",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
            "name": "jnadeau",
            "key": "jnadeau",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Jacques Nadeau",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 34800,
            "total": 34800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 34800,
            "total": 34800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3191/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 61,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/worklog/227217",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "siddharthteotia commented on pull request #4151: ARROW-3191:[JAVA] WIP for pointing ArrowBuf to arbitrary memory\nURL: https://github.com/apache/arrow/pull/4151\n \n \n   This patch has the following goals:\r\n   \r\n   (1) Make ArrowBuf work with any arbitrary memory. \r\n   (2) Decouple the usage of data get/set in ArrowBuf and memory accounting, reference management, ownership etc.\r\n   \r\n   Changes\r\n   \r\n   (1) A ReferenceManager interface that can be provided to ArrowBuf. This allows the users to provide their own custom implementation of reference management or it can be a NO-OP.\r\n   (2) All the accounting, ownership, reference related APIs have been moved to the default implementation of ReferenceManager -- BufferLedger, AllocationManager\r\n   (3) ArrowBuf is now literally an abstraction over some user provided underlying memory chunk. All it needs is starting virtual address and length of data to access along with a user provided implementation of ReferenceManager.\r\n   (4) ArrowBuf no longer extends or implements any of Netty's buffer interfaces. Thus all of the extra and unused APIs have been removed and it just provides simple get/set.\r\n   \r\n   There is quite a bit of cleanup that needs to be done since some APIs have been moved out of ArrowBuf. So the caller code needs to change. They are likely going to be boilerplate changes but I would like to do them once we have consensus on the major set of changes here and the decoupling between ArrowBuf usage and reference management.\r\n   \r\n   So the code doesn't compile yet because of the above mentioned reason. Secondly, there are a few things that I have removed assuming they are not being used  -- like BufferManager in ArrowBuf. I am still evaluating its usage. So there a few TODOs in code for these reasons.\r\n   \r\n   Raising PR before the code is complete to get feedback on the important set of changes.\r\n   \r\n   \r\n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-13T18:22:03.889+0000",
                    "updated": "2019-04-13T18:22:03.889+0000",
                    "started": "2019-04-13T18:22:03.889+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "227217",
                    "issueId": "13183717"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/worklog/227308",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pearu commented on issue #4151: ARROW-3191:[JAVA] WIP for pointing ArrowBuf to arbitrary memory\nURL: https://github.com/apache/arrow/pull/4151#issuecomment-482938597\n \n \n   > Make ArrowBuf work with any arbitrary memory.\r\n   \r\n   What does \"arbitrary memory\" mean? Would this include also device memory?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-14T09:42:17.530+0000",
                    "updated": "2019-04-14T09:42:17.530+0000",
                    "started": "2019-04-14T09:42:17.530+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "227308",
                    "issueId": "13183717"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/worklog/227345",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #4151: ARROW-3191:[JAVA] WIP for pointing ArrowBuf to arbitrary memory\nURL: https://github.com/apache/arrow/pull/4151#discussion_r275162290\n \n \n\n ##########\n File path: java/memory/src/main/java/io/netty/buffer/ArrowBuf.java\n ##########\n @@ -499,461 +225,212 @@ public boolean equals(Object obj) {\n     return this == obj;\n   }\n \n-  @Override\n-  public ArrowBuf retain(int increment) {\n-    Preconditions.checkArgument(increment > 0, \"retain(%d) argument is not positive\", increment);\n-\n-    if (isEmpty) {\n-      return this;\n-    }\n-\n-    if (BaseAllocator.DEBUG) {\n-      historicalLog.recordEvent(\"retain(%d)\", increment);\n-    }\n-\n-    final int originalReferenceCount = refCnt.getAndAdd(increment);\n-    Preconditions.checkArgument(originalReferenceCount > 0);\n-    return this;\n-  }\n-\n-  @Override\n-  public ArrowBuf retain() {\n-    return retain(1);\n-  }\n-\n-  @Override\n-  public ByteBuf touch() {\n-    return this;\n+  /**\n+   * IMPORTANT NOTE\n+   * The data getters and setters work with a caller provided\n+   * index. This index is 0 based and since ArrowBuf has access\n+   * to a portion of underlying chunk of memory starting at\n+   * some address, we convert the given relative index into\n+   * absolute index as memory address + index.\n+   *\n+   * Example:\n+   *\n+   * Let's say we have an underlying chunk of memory of length 64 bytes\n+   * Now let's say we have an ArrowBuf that has access to the chunk\n+   * from offset 4 for length of 16 bytes.\n+   *\n+   * If the starting virtual address of chunk is MAR, then memory\n+   * address of this ArrowBuf is MAR + offset -- this is what is stored\n+   * in variable addr. See the BufferLedger and AllocationManager code\n+   * for the implementation of ReferenceManager that manages a\n+   * chunk of memory and creates ArrowBuf with access to a range of\n+   * bytes within the chunk (or the entire chunk)\n+   *\n+   * So now to get/set data, we will do => addr + index\n+   * This logic is put in method addr(index) and is frequently\n+   * used in get/set data methods to compute the absolute\n+   * byte address for get/set operation in the underlying chunk\n+   *\n+   * @param index the index at which we the user wants to read/write\n+   * @return the absolute address within the memro\n+   */\n+  private long addr(int index) {\n \n Review comment:\n   what do you think about changing the API to take LONGs here instead?  Or do you think this should be a separate PR?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-14T15:37:36.467+0000",
                    "updated": "2019-04-14T15:37:36.467+0000",
                    "started": "2019-04-14T15:37:36.466+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "227345",
                    "issueId": "13183717"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/worklog/227347",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #4151: ARROW-3191:[JAVA] WIP for pointing ArrowBuf to arbitrary memory\nURL: https://github.com/apache/arrow/pull/4151#discussion_r275162656\n \n \n\n ##########\n File path: java/memory/src/main/java/io/netty/buffer/ArrowBuf.java\n ##########\n @@ -499,461 +225,212 @@ public boolean equals(Object obj) {\n     return this == obj;\n   }\n \n-  @Override\n-  public ArrowBuf retain(int increment) {\n-    Preconditions.checkArgument(increment > 0, \"retain(%d) argument is not positive\", increment);\n-\n-    if (isEmpty) {\n-      return this;\n-    }\n-\n-    if (BaseAllocator.DEBUG) {\n-      historicalLog.recordEvent(\"retain(%d)\", increment);\n-    }\n-\n-    final int originalReferenceCount = refCnt.getAndAdd(increment);\n-    Preconditions.checkArgument(originalReferenceCount > 0);\n-    return this;\n-  }\n-\n-  @Override\n-  public ArrowBuf retain() {\n-    return retain(1);\n-  }\n-\n-  @Override\n-  public ByteBuf touch() {\n-    return this;\n+  /**\n+   * IMPORTANT NOTE\n+   * The data getters and setters work with a caller provided\n+   * index. This index is 0 based and since ArrowBuf has access\n+   * to a portion of underlying chunk of memory starting at\n+   * some address, we convert the given relative index into\n+   * absolute index as memory address + index.\n+   *\n+   * Example:\n+   *\n+   * Let's say we have an underlying chunk of memory of length 64 bytes\n+   * Now let's say we have an ArrowBuf that has access to the chunk\n+   * from offset 4 for length of 16 bytes.\n+   *\n+   * If the starting virtual address of chunk is MAR, then memory\n+   * address of this ArrowBuf is MAR + offset -- this is what is stored\n+   * in variable addr. See the BufferLedger and AllocationManager code\n+   * for the implementation of ReferenceManager that manages a\n+   * chunk of memory and creates ArrowBuf with access to a range of\n+   * bytes within the chunk (or the entire chunk)\n+   *\n+   * So now to get/set data, we will do => addr + index\n+   * This logic is put in method addr(index) and is frequently\n+   * used in get/set data methods to compute the absolute\n+   * byte address for get/set operation in the underlying chunk\n+   *\n+   * @param index the index at which we the user wants to read/write\n+   * @return the absolute address within the memro\n+   */\n+  private long addr(int index) {\n+    return addr + index;\n   }\n \n-  @Override\n-  public ByteBuf touch(Object hint) {\n-    return this;\n+  public long getLong(int index) {\n+    chk(index, 8);\n+    return PlatformDependent.getLong(addr(index));\n   }\n \n-  @Override\n-  public long getLong(int index) {\n+  public ArrowBuf setLong(int index, long value) {\n     chk(index, 8);\n-    final long v = PlatformDependent.getLong(addr(index));\n-    return v;\n+    PlatformDependent.putLong(addr(index), value);\n+    return this;\n   }\n \n-  @Override\n   public float getFloat(int index) {\n     return Float.intBitsToFloat(getInt(index));\n   }\n \n-  /**\n-   * Gets a 64-bit long integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public long getLongLE(int index) {\n-    chk(index, 8);\n-    final long v = PlatformDependent.getLong(addr(index));\n-    return Long.reverseBytes(v);\n+  public ArrowBuf setFloat(int index, float value) {\n+    chk(index, 4);\n+    PlatformDependent.putInt(addr(index), Float.floatToRawIntBits(value));\n+    return this;\n   }\n \n-  @Override\n   public double getDouble(int index) {\n     return Double.longBitsToDouble(getLong(index));\n   }\n \n-  @Override\n-  public char getChar(int index) {\n-    return (char) getShort(index);\n-  }\n-\n-  @Override\n-  public long getUnsignedInt(int index) {\n-    return getInt(index) & 0xFFFFFFFFL;\n-  }\n-\n-  @Override\n-  public int getInt(int index) {\n-    chk(index, 4);\n-    final int v = PlatformDependent.getInt(addr(index));\n-    return v;\n-  }\n-\n-  /**\n-   * Gets a 32-bit integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public int getIntLE(int index) {\n-    chk(index, 4);\n-    final int v = PlatformDependent.getInt(addr(index));\n-    return Integer.reverseBytes(v);\n-  }\n-\n-  @Override\n-  public int getUnsignedShort(int index) {\n-    return getShort(index) & 0xFFFF;\n-  }\n-\n-  @Override\n-  public short getShort(int index) {\n-    chk(index, 2);\n-    final short v = PlatformDependent.getShort(addr(index));\n-    return v;\n-  }\n-\n-  /**\n-   * Gets a 16-bit short integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public short getShortLE(int index) {\n-    final short v = PlatformDependent.getShort(addr(index));\n-    return Short.reverseBytes(v);\n-  }\n-\n-  /**\n-   * Gets an unsigned 24-bit medium integer at the specified absolute\n-   * {@code index} in this buffer.\n-   */\n-  @Override\n-  public int getUnsignedMedium(int index) {\n-    chk(index, 3);\n-    final long addr = addr(index);\n-    return (PlatformDependent.getByte(addr) & 0xff) << 16 |\n-        (PlatformDependent.getShort(addr + 1) & 0xffff);\n+  public ArrowBuf setDouble(int index, double value) {\n+    chk(index, 8);\n+    PlatformDependent.putLong(addr(index), Double.doubleToRawLongBits(value));\n+    return this;\n   }\n \n-  /**\n-   * Gets an unsigned 24-bit medium integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public int getUnsignedMediumLE(int index) {\n-    chk(index, 3);\n-    final long addr = addr(index);\n-    return (PlatformDependent.getByte(addr) & 0xff) |\n-        (Short.reverseBytes(PlatformDependent.getShort(addr + 1)) & 0xffff) << 8;\n+  public char getChar(int index) {\n+    return (char) getShort(index);\n   }\n \n-  @Override\n-  public ArrowBuf setShort(int index, int value) {\n+  public ArrowBuf setChar(int index, int value) {\n \n Review comment:\n   can we change this to either take a char, or replicate documentation saying which bits are ignored.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-14T15:46:59.895+0000",
                    "updated": "2019-04-14T15:46:59.895+0000",
                    "started": "2019-04-14T15:46:59.894+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "227347",
                    "issueId": "13183717"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/worklog/227348",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #4151: ARROW-3191:[JAVA] WIP for pointing ArrowBuf to arbitrary memory\nURL: https://github.com/apache/arrow/pull/4151#discussion_r275162712\n \n \n\n ##########\n File path: java/memory/src/main/java/io/netty/buffer/ArrowBuf.java\n ##########\n @@ -499,461 +225,212 @@ public boolean equals(Object obj) {\n     return this == obj;\n   }\n \n-  @Override\n-  public ArrowBuf retain(int increment) {\n-    Preconditions.checkArgument(increment > 0, \"retain(%d) argument is not positive\", increment);\n-\n-    if (isEmpty) {\n-      return this;\n-    }\n-\n-    if (BaseAllocator.DEBUG) {\n-      historicalLog.recordEvent(\"retain(%d)\", increment);\n-    }\n-\n-    final int originalReferenceCount = refCnt.getAndAdd(increment);\n-    Preconditions.checkArgument(originalReferenceCount > 0);\n-    return this;\n-  }\n-\n-  @Override\n-  public ArrowBuf retain() {\n-    return retain(1);\n-  }\n-\n-  @Override\n-  public ByteBuf touch() {\n-    return this;\n+  /**\n+   * IMPORTANT NOTE\n+   * The data getters and setters work with a caller provided\n+   * index. This index is 0 based and since ArrowBuf has access\n+   * to a portion of underlying chunk of memory starting at\n+   * some address, we convert the given relative index into\n+   * absolute index as memory address + index.\n+   *\n+   * Example:\n+   *\n+   * Let's say we have an underlying chunk of memory of length 64 bytes\n+   * Now let's say we have an ArrowBuf that has access to the chunk\n+   * from offset 4 for length of 16 bytes.\n+   *\n+   * If the starting virtual address of chunk is MAR, then memory\n+   * address of this ArrowBuf is MAR + offset -- this is what is stored\n+   * in variable addr. See the BufferLedger and AllocationManager code\n+   * for the implementation of ReferenceManager that manages a\n+   * chunk of memory and creates ArrowBuf with access to a range of\n+   * bytes within the chunk (or the entire chunk)\n+   *\n+   * So now to get/set data, we will do => addr + index\n+   * This logic is put in method addr(index) and is frequently\n+   * used in get/set data methods to compute the absolute\n+   * byte address for get/set operation in the underlying chunk\n+   *\n+   * @param index the index at which we the user wants to read/write\n+   * @return the absolute address within the memro\n+   */\n+  private long addr(int index) {\n+    return addr + index;\n   }\n \n-  @Override\n-  public ByteBuf touch(Object hint) {\n-    return this;\n+  public long getLong(int index) {\n+    chk(index, 8);\n+    return PlatformDependent.getLong(addr(index));\n   }\n \n-  @Override\n-  public long getLong(int index) {\n+  public ArrowBuf setLong(int index, long value) {\n     chk(index, 8);\n-    final long v = PlatformDependent.getLong(addr(index));\n-    return v;\n+    PlatformDependent.putLong(addr(index), value);\n+    return this;\n   }\n \n-  @Override\n   public float getFloat(int index) {\n     return Float.intBitsToFloat(getInt(index));\n   }\n \n-  /**\n-   * Gets a 64-bit long integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public long getLongLE(int index) {\n-    chk(index, 8);\n-    final long v = PlatformDependent.getLong(addr(index));\n-    return Long.reverseBytes(v);\n+  public ArrowBuf setFloat(int index, float value) {\n+    chk(index, 4);\n+    PlatformDependent.putInt(addr(index), Float.floatToRawIntBits(value));\n+    return this;\n   }\n \n-  @Override\n   public double getDouble(int index) {\n     return Double.longBitsToDouble(getLong(index));\n   }\n \n-  @Override\n-  public char getChar(int index) {\n-    return (char) getShort(index);\n-  }\n-\n-  @Override\n-  public long getUnsignedInt(int index) {\n-    return getInt(index) & 0xFFFFFFFFL;\n-  }\n-\n-  @Override\n-  public int getInt(int index) {\n-    chk(index, 4);\n-    final int v = PlatformDependent.getInt(addr(index));\n-    return v;\n-  }\n-\n-  /**\n-   * Gets a 32-bit integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public int getIntLE(int index) {\n-    chk(index, 4);\n-    final int v = PlatformDependent.getInt(addr(index));\n-    return Integer.reverseBytes(v);\n-  }\n-\n-  @Override\n-  public int getUnsignedShort(int index) {\n-    return getShort(index) & 0xFFFF;\n-  }\n-\n-  @Override\n-  public short getShort(int index) {\n-    chk(index, 2);\n-    final short v = PlatformDependent.getShort(addr(index));\n-    return v;\n-  }\n-\n-  /**\n-   * Gets a 16-bit short integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public short getShortLE(int index) {\n-    final short v = PlatformDependent.getShort(addr(index));\n-    return Short.reverseBytes(v);\n-  }\n-\n-  /**\n-   * Gets an unsigned 24-bit medium integer at the specified absolute\n-   * {@code index} in this buffer.\n-   */\n-  @Override\n-  public int getUnsignedMedium(int index) {\n-    chk(index, 3);\n-    final long addr = addr(index);\n-    return (PlatformDependent.getByte(addr) & 0xff) << 16 |\n-        (PlatformDependent.getShort(addr + 1) & 0xffff);\n+  public ArrowBuf setDouble(int index, double value) {\n+    chk(index, 8);\n+    PlatformDependent.putLong(addr(index), Double.doubleToRawLongBits(value));\n+    return this;\n   }\n \n-  /**\n-   * Gets an unsigned 24-bit medium integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public int getUnsignedMediumLE(int index) {\n-    chk(index, 3);\n-    final long addr = addr(index);\n-    return (PlatformDependent.getByte(addr) & 0xff) |\n-        (Short.reverseBytes(PlatformDependent.getShort(addr + 1)) & 0xffff) << 8;\n+  public char getChar(int index) {\n+    return (char) getShort(index);\n   }\n \n-  @Override\n-  public ArrowBuf setShort(int index, int value) {\n+  public ArrowBuf setChar(int index, int value) {\n     chk(index, 2);\n     PlatformDependent.putShort(addr(index), (short) value);\n     return this;\n   }\n \n-  /**\n-   * Sets the specified 16-bit short integer at the specified absolute {@code index}\n-   * in this buffer with Big Endian byte order.\n-   */\n-  @Override\n-  public ByteBuf setShortLE(int index, int value) {\n-    chk(index, 2);\n-    PlatformDependent.putShort(addr(index), Short.reverseBytes((short) value));\n-    return this;\n-  }\n-\n-  /**\n-   * Sets the specified 24-bit medium integer at the specified absolute\n-   * {@code index} in this buffer.\n-   */\n-  @Override\n-  public ByteBuf setMedium(int index, int value) {\n-    chk(index, 3);\n-    final long addr = addr(index);\n-    PlatformDependent.putByte(addr, (byte) (value >>> 16));\n-    PlatformDependent.putShort(addr + 1, (short) value);\n-    return this;\n-  }\n-\n-\n-  /**\n-   * Sets the specified 24-bit medium integer at the specified absolute {@code index}\n-   * in this buffer with Big Endian byte order.\n-   */\n-  @Override\n-  public ByteBuf setMediumLE(int index, int value) {\n-    chk(index, 3);\n-    final long addr = addr(index);\n-    PlatformDependent.putByte(addr, (byte) value);\n-    PlatformDependent.putShort(addr + 1, Short.reverseBytes((short) (value >>> 8)));\n-    return this;\n+  public int getInt(int index) {\n+    chk(index, 4);\n+    return PlatformDependent.getInt(addr(index));\n   }\n \n-  @Override\n   public ArrowBuf setInt(int index, int value) {\n     chk(index, 4);\n     PlatformDependent.putInt(addr(index), value);\n     return this;\n   }\n \n-  /**\n-   * Sets the specified 32-bit integer at the specified absolute {@code index}\n-   * in this buffer with Big Endian byte order.\n-   */\n-  @Override\n-  public ByteBuf setIntLE(int index, int value) {\n-    chk(index, 4);\n-    PlatformDependent.putInt(addr(index), Integer.reverseBytes(value));\n-    return this;\n-  }\n-\n-  @Override\n-  public ArrowBuf setLong(int index, long value) {\n-    chk(index, 8);\n-    PlatformDependent.putLong(addr(index), value);\n-    return this;\n-  }\n-\n-  /**\n-   * Sets the specified 64-bit long integer at the specified absolute {@code index}\n-   * in this buffer with Big Endian byte order.\n-   */\n-  @Override\n-  public ByteBuf setLongLE(int index, long value) {\n-    chk(index, 8);\n-    PlatformDependent.putLong(addr(index), Long.reverseBytes(value));\n-    return this;\n+  public short getShort(int index) {\n+    chk(index, 2);\n+    return PlatformDependent.getShort(addr(index));\n   }\n \n-  @Override\n-  public ArrowBuf setChar(int index, int value) {\n+  public ArrowBuf setShort(int index, int value) {\n     chk(index, 2);\n     PlatformDependent.putShort(addr(index), (short) value);\n     return this;\n   }\n \n-  @Override\n-  public ArrowBuf setFloat(int index, float value) {\n-    chk(index, 4);\n-    PlatformDependent.putInt(addr(index), Float.floatToRawIntBits(value));\n-    return this;\n-  }\n-\n-  @Override\n-  public ArrowBuf setDouble(int index, double value) {\n-    chk(index, 8);\n-    PlatformDependent.putLong(addr(index), Double.doubleToRawLongBits(value));\n-    return this;\n-  }\n-\n-  @Override\n   public ArrowBuf writeShort(int value) {\n     ensure(2);\n     PlatformDependent.putShort(addr(writerIndex), (short) value);\n     writerIndex += 2;\n     return this;\n   }\n \n-  @Override\n   public ArrowBuf writeInt(int value) {\n     ensure(4);\n     PlatformDependent.putInt(addr(writerIndex), value);\n     writerIndex += 4;\n     return this;\n   }\n \n-  @Override\n   public ArrowBuf writeLong(long value) {\n     ensure(8);\n     PlatformDependent.putLong(addr(writerIndex), value);\n     writerIndex += 8;\n     return this;\n   }\n \n-  @Override\n-  public ArrowBuf writeChar(int value) {\n-    ensure(2);\n-    PlatformDependent.putShort(addr(writerIndex), (short) value);\n-    writerIndex += 2;\n-    return this;\n-  }\n-\n-  @Override\n   public ArrowBuf writeFloat(float value) {\n     ensure(4);\n     PlatformDependent.putInt(addr(writerIndex), Float.floatToRawIntBits(value));\n     writerIndex += 4;\n     return this;\n   }\n \n-  @Override\n   public ArrowBuf writeDouble(double value) {\n     ensure(8);\n     PlatformDependent.putLong(addr(writerIndex), Double.doubleToRawLongBits(value));\n     writerIndex += 8;\n     return this;\n   }\n \n-  @Override\n-  public ArrowBuf getBytes(int index, byte[] dst, int dstIndex, int length) {\n-    udle.getBytes(index + offset, dst, dstIndex, length);\n-    return this;\n-  }\n-\n-  @Override\n-  public ArrowBuf getBytes(int index, ByteBuffer dst) {\n-    udle.getBytes(index + offset, dst);\n-    return this;\n-  }\n-\n-  @Override\n   public ArrowBuf setByte(int index, int value) {\n \n Review comment:\n   eliminate or document.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-14T15:48:10.243+0000",
                    "updated": "2019-04-14T15:48:10.243+0000",
                    "started": "2019-04-14T15:48:10.243+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "227348",
                    "issueId": "13183717"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/worklog/227349",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #4151: ARROW-3191:[JAVA] WIP for pointing ArrowBuf to arbitrary memory\nURL: https://github.com/apache/arrow/pull/4151#discussion_r275162721\n \n \n\n ##########\n File path: java/memory/src/main/java/io/netty/buffer/ArrowBuf.java\n ##########\n @@ -499,461 +225,212 @@ public boolean equals(Object obj) {\n     return this == obj;\n   }\n \n-  @Override\n-  public ArrowBuf retain(int increment) {\n-    Preconditions.checkArgument(increment > 0, \"retain(%d) argument is not positive\", increment);\n-\n-    if (isEmpty) {\n-      return this;\n-    }\n-\n-    if (BaseAllocator.DEBUG) {\n-      historicalLog.recordEvent(\"retain(%d)\", increment);\n-    }\n-\n-    final int originalReferenceCount = refCnt.getAndAdd(increment);\n-    Preconditions.checkArgument(originalReferenceCount > 0);\n-    return this;\n-  }\n-\n-  @Override\n-  public ArrowBuf retain() {\n-    return retain(1);\n-  }\n-\n-  @Override\n-  public ByteBuf touch() {\n-    return this;\n+  /**\n+   * IMPORTANT NOTE\n+   * The data getters and setters work with a caller provided\n+   * index. This index is 0 based and since ArrowBuf has access\n+   * to a portion of underlying chunk of memory starting at\n+   * some address, we convert the given relative index into\n+   * absolute index as memory address + index.\n+   *\n+   * Example:\n+   *\n+   * Let's say we have an underlying chunk of memory of length 64 bytes\n+   * Now let's say we have an ArrowBuf that has access to the chunk\n+   * from offset 4 for length of 16 bytes.\n+   *\n+   * If the starting virtual address of chunk is MAR, then memory\n+   * address of this ArrowBuf is MAR + offset -- this is what is stored\n+   * in variable addr. See the BufferLedger and AllocationManager code\n+   * for the implementation of ReferenceManager that manages a\n+   * chunk of memory and creates ArrowBuf with access to a range of\n+   * bytes within the chunk (or the entire chunk)\n+   *\n+   * So now to get/set data, we will do => addr + index\n+   * This logic is put in method addr(index) and is frequently\n+   * used in get/set data methods to compute the absolute\n+   * byte address for get/set operation in the underlying chunk\n+   *\n+   * @param index the index at which we the user wants to read/write\n+   * @return the absolute address within the memro\n+   */\n+  private long addr(int index) {\n+    return addr + index;\n   }\n \n-  @Override\n-  public ByteBuf touch(Object hint) {\n-    return this;\n+  public long getLong(int index) {\n+    chk(index, 8);\n+    return PlatformDependent.getLong(addr(index));\n   }\n \n-  @Override\n-  public long getLong(int index) {\n+  public ArrowBuf setLong(int index, long value) {\n     chk(index, 8);\n-    final long v = PlatformDependent.getLong(addr(index));\n-    return v;\n+    PlatformDependent.putLong(addr(index), value);\n+    return this;\n   }\n \n-  @Override\n   public float getFloat(int index) {\n     return Float.intBitsToFloat(getInt(index));\n   }\n \n-  /**\n-   * Gets a 64-bit long integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public long getLongLE(int index) {\n-    chk(index, 8);\n-    final long v = PlatformDependent.getLong(addr(index));\n-    return Long.reverseBytes(v);\n+  public ArrowBuf setFloat(int index, float value) {\n+    chk(index, 4);\n+    PlatformDependent.putInt(addr(index), Float.floatToRawIntBits(value));\n+    return this;\n   }\n \n-  @Override\n   public double getDouble(int index) {\n     return Double.longBitsToDouble(getLong(index));\n   }\n \n-  @Override\n-  public char getChar(int index) {\n-    return (char) getShort(index);\n-  }\n-\n-  @Override\n-  public long getUnsignedInt(int index) {\n-    return getInt(index) & 0xFFFFFFFFL;\n-  }\n-\n-  @Override\n-  public int getInt(int index) {\n-    chk(index, 4);\n-    final int v = PlatformDependent.getInt(addr(index));\n-    return v;\n-  }\n-\n-  /**\n-   * Gets a 32-bit integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public int getIntLE(int index) {\n-    chk(index, 4);\n-    final int v = PlatformDependent.getInt(addr(index));\n-    return Integer.reverseBytes(v);\n-  }\n-\n-  @Override\n-  public int getUnsignedShort(int index) {\n-    return getShort(index) & 0xFFFF;\n-  }\n-\n-  @Override\n-  public short getShort(int index) {\n-    chk(index, 2);\n-    final short v = PlatformDependent.getShort(addr(index));\n-    return v;\n-  }\n-\n-  /**\n-   * Gets a 16-bit short integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public short getShortLE(int index) {\n-    final short v = PlatformDependent.getShort(addr(index));\n-    return Short.reverseBytes(v);\n-  }\n-\n-  /**\n-   * Gets an unsigned 24-bit medium integer at the specified absolute\n-   * {@code index} in this buffer.\n-   */\n-  @Override\n-  public int getUnsignedMedium(int index) {\n-    chk(index, 3);\n-    final long addr = addr(index);\n-    return (PlatformDependent.getByte(addr) & 0xff) << 16 |\n-        (PlatformDependent.getShort(addr + 1) & 0xffff);\n+  public ArrowBuf setDouble(int index, double value) {\n+    chk(index, 8);\n+    PlatformDependent.putLong(addr(index), Double.doubleToRawLongBits(value));\n+    return this;\n   }\n \n-  /**\n-   * Gets an unsigned 24-bit medium integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public int getUnsignedMediumLE(int index) {\n-    chk(index, 3);\n-    final long addr = addr(index);\n-    return (PlatformDependent.getByte(addr) & 0xff) |\n-        (Short.reverseBytes(PlatformDependent.getShort(addr + 1)) & 0xffff) << 8;\n+  public char getChar(int index) {\n+    return (char) getShort(index);\n   }\n \n-  @Override\n-  public ArrowBuf setShort(int index, int value) {\n+  public ArrowBuf setChar(int index, int value) {\n     chk(index, 2);\n     PlatformDependent.putShort(addr(index), (short) value);\n     return this;\n   }\n \n-  /**\n-   * Sets the specified 16-bit short integer at the specified absolute {@code index}\n-   * in this buffer with Big Endian byte order.\n-   */\n-  @Override\n-  public ByteBuf setShortLE(int index, int value) {\n-    chk(index, 2);\n-    PlatformDependent.putShort(addr(index), Short.reverseBytes((short) value));\n-    return this;\n-  }\n-\n-  /**\n-   * Sets the specified 24-bit medium integer at the specified absolute\n-   * {@code index} in this buffer.\n-   */\n-  @Override\n-  public ByteBuf setMedium(int index, int value) {\n-    chk(index, 3);\n-    final long addr = addr(index);\n-    PlatformDependent.putByte(addr, (byte) (value >>> 16));\n-    PlatformDependent.putShort(addr + 1, (short) value);\n-    return this;\n-  }\n-\n-\n-  /**\n-   * Sets the specified 24-bit medium integer at the specified absolute {@code index}\n-   * in this buffer with Big Endian byte order.\n-   */\n-  @Override\n-  public ByteBuf setMediumLE(int index, int value) {\n-    chk(index, 3);\n-    final long addr = addr(index);\n-    PlatformDependent.putByte(addr, (byte) value);\n-    PlatformDependent.putShort(addr + 1, Short.reverseBytes((short) (value >>> 8)));\n-    return this;\n+  public int getInt(int index) {\n+    chk(index, 4);\n+    return PlatformDependent.getInt(addr(index));\n   }\n \n-  @Override\n   public ArrowBuf setInt(int index, int value) {\n     chk(index, 4);\n     PlatformDependent.putInt(addr(index), value);\n     return this;\n   }\n \n-  /**\n-   * Sets the specified 32-bit integer at the specified absolute {@code index}\n-   * in this buffer with Big Endian byte order.\n-   */\n-  @Override\n-  public ByteBuf setIntLE(int index, int value) {\n-    chk(index, 4);\n-    PlatformDependent.putInt(addr(index), Integer.reverseBytes(value));\n-    return this;\n-  }\n-\n-  @Override\n-  public ArrowBuf setLong(int index, long value) {\n-    chk(index, 8);\n-    PlatformDependent.putLong(addr(index), value);\n-    return this;\n-  }\n-\n-  /**\n-   * Sets the specified 64-bit long integer at the specified absolute {@code index}\n-   * in this buffer with Big Endian byte order.\n-   */\n-  @Override\n-  public ByteBuf setLongLE(int index, long value) {\n-    chk(index, 8);\n-    PlatformDependent.putLong(addr(index), Long.reverseBytes(value));\n-    return this;\n+  public short getShort(int index) {\n+    chk(index, 2);\n+    return PlatformDependent.getShort(addr(index));\n   }\n \n-  @Override\n-  public ArrowBuf setChar(int index, int value) {\n+  public ArrowBuf setShort(int index, int value) {\n     chk(index, 2);\n     PlatformDependent.putShort(addr(index), (short) value);\n     return this;\n   }\n \n-  @Override\n-  public ArrowBuf setFloat(int index, float value) {\n-    chk(index, 4);\n-    PlatformDependent.putInt(addr(index), Float.floatToRawIntBits(value));\n-    return this;\n-  }\n-\n-  @Override\n-  public ArrowBuf setDouble(int index, double value) {\n-    chk(index, 8);\n-    PlatformDependent.putLong(addr(index), Double.doubleToRawLongBits(value));\n-    return this;\n-  }\n-\n-  @Override\n   public ArrowBuf writeShort(int value) {\n     ensure(2);\n     PlatformDependent.putShort(addr(writerIndex), (short) value);\n     writerIndex += 2;\n     return this;\n   }\n \n-  @Override\n   public ArrowBuf writeInt(int value) {\n     ensure(4);\n     PlatformDependent.putInt(addr(writerIndex), value);\n     writerIndex += 4;\n     return this;\n   }\n \n-  @Override\n   public ArrowBuf writeLong(long value) {\n     ensure(8);\n     PlatformDependent.putLong(addr(writerIndex), value);\n     writerIndex += 8;\n     return this;\n   }\n \n-  @Override\n-  public ArrowBuf writeChar(int value) {\n-    ensure(2);\n-    PlatformDependent.putShort(addr(writerIndex), (short) value);\n-    writerIndex += 2;\n-    return this;\n-  }\n-\n-  @Override\n   public ArrowBuf writeFloat(float value) {\n     ensure(4);\n     PlatformDependent.putInt(addr(writerIndex), Float.floatToRawIntBits(value));\n     writerIndex += 4;\n     return this;\n   }\n \n-  @Override\n   public ArrowBuf writeDouble(double value) {\n     ensure(8);\n     PlatformDependent.putLong(addr(writerIndex), Double.doubleToRawLongBits(value));\n     writerIndex += 8;\n     return this;\n   }\n \n-  @Override\n-  public ArrowBuf getBytes(int index, byte[] dst, int dstIndex, int length) {\n-    udle.getBytes(index + offset, dst, dstIndex, length);\n-    return this;\n-  }\n-\n-  @Override\n-  public ArrowBuf getBytes(int index, ByteBuffer dst) {\n-    udle.getBytes(index + offset, dst);\n-    return this;\n-  }\n-\n-  @Override\n   public ArrowBuf setByte(int index, int value) {\n     chk(index, 1);\n     PlatformDependent.putByte(addr(index), (byte) value);\n     return this;\n   }\n \n \n Review comment:\n   Please try to add javadoc to each method\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-14T15:48:25.220+0000",
                    "updated": "2019-04-14T15:48:25.220+0000",
                    "started": "2019-04-14T15:48:25.220+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "227349",
                    "issueId": "13183717"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/worklog/227350",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #4151: ARROW-3191:[JAVA] WIP for pointing ArrowBuf to arbitrary memory\nURL: https://github.com/apache/arrow/pull/4151#discussion_r275162773\n \n \n\n ##########\n File path: java/memory/src/main/java/io/netty/buffer/ArrowBuf.java\n ##########\n @@ -403,89 +190,28 @@ public ArrowBuf slice(int index, int length) {\n      * .html#wiki-h3-5, which\n      * explains that derived buffers share their reference count with their parent\n      */\n-    final ArrowBuf newBuf = ledger.newArrowBuf(offset + index, length);\n+    final ArrowBuf newBuf = referenceManager.deriveBuffer(this, index, length);\n     newBuf.writerIndex(length);\n     return newBuf;\n   }\n \n-  @Override\n-  public ArrowBuf duplicate() {\n-    return slice(0, length);\n-  }\n-\n-  @Override\n-  public int nioBufferCount() {\n-    return 1;\n-  }\n-\n-  @Override\n   public ByteBuffer nioBuffer() {\n \n Review comment:\n   consider returning a collection here (if it isn't too big a change, even even we want to change to support 64 bit size memory in a separate PR).\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-14T15:49:48.426+0000",
                    "updated": "2019-04-14T15:49:48.426+0000",
                    "started": "2019-04-14T15:49:48.426+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "227350",
                    "issueId": "13183717"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/worklog/227351",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #4151: ARROW-3191:[JAVA] WIP for pointing ArrowBuf to arbitrary memory\nURL: https://github.com/apache/arrow/pull/4151#discussion_r275163197\n \n \n\n ##########\n File path: java/memory/src/main/java/io/netty/buffer/ArrowBuf.java\n ##########\n @@ -499,461 +225,212 @@ public boolean equals(Object obj) {\n     return this == obj;\n   }\n \n-  @Override\n-  public ArrowBuf retain(int increment) {\n-    Preconditions.checkArgument(increment > 0, \"retain(%d) argument is not positive\", increment);\n-\n-    if (isEmpty) {\n-      return this;\n-    }\n-\n-    if (BaseAllocator.DEBUG) {\n-      historicalLog.recordEvent(\"retain(%d)\", increment);\n-    }\n-\n-    final int originalReferenceCount = refCnt.getAndAdd(increment);\n-    Preconditions.checkArgument(originalReferenceCount > 0);\n-    return this;\n-  }\n-\n-  @Override\n-  public ArrowBuf retain() {\n-    return retain(1);\n-  }\n-\n-  @Override\n-  public ByteBuf touch() {\n-    return this;\n+  /**\n+   * IMPORTANT NOTE\n+   * The data getters and setters work with a caller provided\n+   * index. This index is 0 based and since ArrowBuf has access\n+   * to a portion of underlying chunk of memory starting at\n+   * some address, we convert the given relative index into\n+   * absolute index as memory address + index.\n+   *\n+   * Example:\n+   *\n+   * Let's say we have an underlying chunk of memory of length 64 bytes\n+   * Now let's say we have an ArrowBuf that has access to the chunk\n+   * from offset 4 for length of 16 bytes.\n+   *\n+   * If the starting virtual address of chunk is MAR, then memory\n+   * address of this ArrowBuf is MAR + offset -- this is what is stored\n+   * in variable addr. See the BufferLedger and AllocationManager code\n+   * for the implementation of ReferenceManager that manages a\n+   * chunk of memory and creates ArrowBuf with access to a range of\n+   * bytes within the chunk (or the entire chunk)\n+   *\n+   * So now to get/set data, we will do => addr + index\n+   * This logic is put in method addr(index) and is frequently\n+   * used in get/set data methods to compute the absolute\n+   * byte address for get/set operation in the underlying chunk\n+   *\n+   * @param index the index at which we the user wants to read/write\n+   * @return the absolute address within the memro\n+   */\n+  private long addr(int index) {\n+    return addr + index;\n   }\n \n-  @Override\n-  public ByteBuf touch(Object hint) {\n-    return this;\n+  public long getLong(int index) {\n+    chk(index, 8);\n+    return PlatformDependent.getLong(addr(index));\n   }\n \n-  @Override\n-  public long getLong(int index) {\n+  public ArrowBuf setLong(int index, long value) {\n     chk(index, 8);\n-    final long v = PlatformDependent.getLong(addr(index));\n-    return v;\n+    PlatformDependent.putLong(addr(index), value);\n+    return this;\n   }\n \n-  @Override\n   public float getFloat(int index) {\n     return Float.intBitsToFloat(getInt(index));\n   }\n \n-  /**\n-   * Gets a 64-bit long integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public long getLongLE(int index) {\n-    chk(index, 8);\n-    final long v = PlatformDependent.getLong(addr(index));\n-    return Long.reverseBytes(v);\n+  public ArrowBuf setFloat(int index, float value) {\n+    chk(index, 4);\n+    PlatformDependent.putInt(addr(index), Float.floatToRawIntBits(value));\n+    return this;\n   }\n \n-  @Override\n   public double getDouble(int index) {\n     return Double.longBitsToDouble(getLong(index));\n   }\n \n-  @Override\n-  public char getChar(int index) {\n-    return (char) getShort(index);\n-  }\n-\n-  @Override\n-  public long getUnsignedInt(int index) {\n-    return getInt(index) & 0xFFFFFFFFL;\n-  }\n-\n-  @Override\n-  public int getInt(int index) {\n-    chk(index, 4);\n-    final int v = PlatformDependent.getInt(addr(index));\n-    return v;\n-  }\n-\n-  /**\n-   * Gets a 32-bit integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public int getIntLE(int index) {\n-    chk(index, 4);\n-    final int v = PlatformDependent.getInt(addr(index));\n-    return Integer.reverseBytes(v);\n-  }\n-\n-  @Override\n-  public int getUnsignedShort(int index) {\n-    return getShort(index) & 0xFFFF;\n-  }\n-\n-  @Override\n-  public short getShort(int index) {\n-    chk(index, 2);\n-    final short v = PlatformDependent.getShort(addr(index));\n-    return v;\n-  }\n-\n-  /**\n-   * Gets a 16-bit short integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public short getShortLE(int index) {\n-    final short v = PlatformDependent.getShort(addr(index));\n-    return Short.reverseBytes(v);\n-  }\n-\n-  /**\n-   * Gets an unsigned 24-bit medium integer at the specified absolute\n-   * {@code index} in this buffer.\n-   */\n-  @Override\n-  public int getUnsignedMedium(int index) {\n-    chk(index, 3);\n-    final long addr = addr(index);\n-    return (PlatformDependent.getByte(addr) & 0xff) << 16 |\n-        (PlatformDependent.getShort(addr + 1) & 0xffff);\n+  public ArrowBuf setDouble(int index, double value) {\n+    chk(index, 8);\n+    PlatformDependent.putLong(addr(index), Double.doubleToRawLongBits(value));\n+    return this;\n   }\n \n-  /**\n-   * Gets an unsigned 24-bit medium integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public int getUnsignedMediumLE(int index) {\n-    chk(index, 3);\n-    final long addr = addr(index);\n-    return (PlatformDependent.getByte(addr) & 0xff) |\n-        (Short.reverseBytes(PlatformDependent.getShort(addr + 1)) & 0xffff) << 8;\n+  public char getChar(int index) {\n+    return (char) getShort(index);\n   }\n \n-  @Override\n-  public ArrowBuf setShort(int index, int value) {\n+  public ArrowBuf setChar(int index, int value) {\n \n Review comment:\n   Actually, is there a use-case to store 2-byte characters in Arrow (I'm not thinking of one off the top of my head).\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-14T15:59:56.707+0000",
                    "updated": "2019-04-14T15:59:56.707+0000",
                    "started": "2019-04-14T15:59:56.706+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "227351",
                    "issueId": "13183717"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/worklog/227352",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #4151: ARROW-3191:[JAVA] WIP for pointing ArrowBuf to arbitrary memory\nURL: https://github.com/apache/arrow/pull/4151#discussion_r275163272\n \n \n\n ##########\n File path: java/memory/src/main/java/io/netty/buffer/ArrowBuf.java\n ##########\n @@ -499,461 +225,212 @@ public boolean equals(Object obj) {\n     return this == obj;\n   }\n \n-  @Override\n-  public ArrowBuf retain(int increment) {\n-    Preconditions.checkArgument(increment > 0, \"retain(%d) argument is not positive\", increment);\n-\n-    if (isEmpty) {\n-      return this;\n-    }\n-\n-    if (BaseAllocator.DEBUG) {\n-      historicalLog.recordEvent(\"retain(%d)\", increment);\n-    }\n-\n-    final int originalReferenceCount = refCnt.getAndAdd(increment);\n-    Preconditions.checkArgument(originalReferenceCount > 0);\n-    return this;\n-  }\n-\n-  @Override\n-  public ArrowBuf retain() {\n-    return retain(1);\n-  }\n-\n-  @Override\n-  public ByteBuf touch() {\n-    return this;\n+  /**\n+   * IMPORTANT NOTE\n+   * The data getters and setters work with a caller provided\n+   * index. This index is 0 based and since ArrowBuf has access\n+   * to a portion of underlying chunk of memory starting at\n+   * some address, we convert the given relative index into\n+   * absolute index as memory address + index.\n+   *\n+   * Example:\n+   *\n+   * Let's say we have an underlying chunk of memory of length 64 bytes\n+   * Now let's say we have an ArrowBuf that has access to the chunk\n+   * from offset 4 for length of 16 bytes.\n+   *\n+   * If the starting virtual address of chunk is MAR, then memory\n+   * address of this ArrowBuf is MAR + offset -- this is what is stored\n+   * in variable addr. See the BufferLedger and AllocationManager code\n+   * for the implementation of ReferenceManager that manages a\n+   * chunk of memory and creates ArrowBuf with access to a range of\n+   * bytes within the chunk (or the entire chunk)\n+   *\n+   * So now to get/set data, we will do => addr + index\n+   * This logic is put in method addr(index) and is frequently\n+   * used in get/set data methods to compute the absolute\n+   * byte address for get/set operation in the underlying chunk\n+   *\n+   * @param index the index at which we the user wants to read/write\n+   * @return the absolute address within the memro\n+   */\n+  private long addr(int index) {\n+    return addr + index;\n   }\n \n-  @Override\n-  public ByteBuf touch(Object hint) {\n-    return this;\n+  public long getLong(int index) {\n+    chk(index, 8);\n+    return PlatformDependent.getLong(addr(index));\n   }\n \n-  @Override\n-  public long getLong(int index) {\n+  public ArrowBuf setLong(int index, long value) {\n     chk(index, 8);\n-    final long v = PlatformDependent.getLong(addr(index));\n-    return v;\n+    PlatformDependent.putLong(addr(index), value);\n+    return this;\n   }\n \n-  @Override\n   public float getFloat(int index) {\n \n Review comment:\n   generally same question about changing the API to use Longs instead of Ints for all getters/settings\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-14T16:02:13.265+0000",
                    "updated": "2019-04-14T16:02:13.265+0000",
                    "started": "2019-04-14T16:02:13.264+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "227352",
                    "issueId": "13183717"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/worklog/227359",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #4151: ARROW-3191:[JAVA] WIP for pointing ArrowBuf to arbitrary memory\nURL: https://github.com/apache/arrow/pull/4151#discussion_r275163963\n \n \n\n ##########\n File path: java/memory/src/main/java/io/netty/buffer/ArrowBuf.java\n ##########\n @@ -17,144 +17,84 @@\n \n package io.netty.buffer;\n \n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n import java.nio.ByteBuffer;\n import java.nio.ByteOrder;\n-import java.nio.channels.FileChannel;\n-import java.nio.channels.GatheringByteChannel;\n-import java.nio.channels.ScatteringByteChannel;\n-import java.nio.charset.Charset;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n \n-import org.apache.arrow.memory.AllocationManager.BufferLedger;\n-import org.apache.arrow.memory.ArrowByteBufAllocator;\n-import org.apache.arrow.memory.BaseAllocator;\n+import io.netty.util.IllegalReferenceCountException;\n+import io.netty.util.internal.MathUtil;\n+import org.apache.arrow.memory.*;\n import org.apache.arrow.memory.BaseAllocator.Verbosity;\n-import org.apache.arrow.memory.BoundsChecking;\n-import org.apache.arrow.memory.BufferAllocator;\n-import org.apache.arrow.memory.BufferManager;\n import org.apache.arrow.memory.util.HistoricalLog;\n import org.apache.arrow.util.Preconditions;\n \n import io.netty.util.internal.PlatformDependent;\n \n /**\n- * ArrowBuf is the abstraction around raw byte arrays that\n- * comprise arrow data structures.\n+ * ArrowBuf serves as a facade over underlying memory by providing\n+ * several access APIs to read/write data into a chunk of direct\n+ * memory. All the accounting, ownership and reference management\n+ * is done by {@link ReferenceManager} and ArrowBuf can work\n+ * with a custom user provided implementation of ReferenceManager\n  *\n+ * Two important instance variables of an ArrowBuf:\n  *\n- * <p>Specifically, it serves as a facade over\n- * {@linkplain UnsafeDirectLittleEndian} memory objects that hides the details\n- * of raw memory addresses.\n+ * (1) address - starting virtual address in the underlying memory\n+ * chunk that this ArrowBuf has access to\n  *\n- * <p>ArrowBuf supports reference counting and ledgering to closely track where\n- * memory is being used.\n+ * (2) length - length (in bytes) in the underlying memory chunk\n \n Review comment:\n   should this be tied to memory?  What if we want a file backed implementation?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-14T16:21:18.878+0000",
                    "updated": "2019-04-14T16:21:18.878+0000",
                    "started": "2019-04-14T16:21:18.877+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "227359",
                    "issueId": "13183717"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/worklog/227431",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jacques-n commented on pull request #4151: ARROW-3191:[JAVA] WIP for pointing ArrowBuf to arbitrary memory\nURL: https://github.com/apache/arrow/pull/4151#discussion_r275205662\n \n \n\n ##########\n File path: java/memory/src/main/java/io/netty/buffer/ArrowBuf.java\n ##########\n @@ -499,461 +225,212 @@ public boolean equals(Object obj) {\n     return this == obj;\n   }\n \n-  @Override\n-  public ArrowBuf retain(int increment) {\n-    Preconditions.checkArgument(increment > 0, \"retain(%d) argument is not positive\", increment);\n-\n-    if (isEmpty) {\n-      return this;\n-    }\n-\n-    if (BaseAllocator.DEBUG) {\n-      historicalLog.recordEvent(\"retain(%d)\", increment);\n-    }\n-\n-    final int originalReferenceCount = refCnt.getAndAdd(increment);\n-    Preconditions.checkArgument(originalReferenceCount > 0);\n-    return this;\n-  }\n-\n-  @Override\n-  public ArrowBuf retain() {\n-    return retain(1);\n-  }\n-\n-  @Override\n-  public ByteBuf touch() {\n-    return this;\n+  /**\n+   * IMPORTANT NOTE\n+   * The data getters and setters work with a caller provided\n+   * index. This index is 0 based and since ArrowBuf has access\n+   * to a portion of underlying chunk of memory starting at\n+   * some address, we convert the given relative index into\n+   * absolute index as memory address + index.\n+   *\n+   * Example:\n+   *\n+   * Let's say we have an underlying chunk of memory of length 64 bytes\n+   * Now let's say we have an ArrowBuf that has access to the chunk\n+   * from offset 4 for length of 16 bytes.\n+   *\n+   * If the starting virtual address of chunk is MAR, then memory\n+   * address of this ArrowBuf is MAR + offset -- this is what is stored\n+   * in variable addr. See the BufferLedger and AllocationManager code\n+   * for the implementation of ReferenceManager that manages a\n+   * chunk of memory and creates ArrowBuf with access to a range of\n+   * bytes within the chunk (or the entire chunk)\n+   *\n+   * So now to get/set data, we will do => addr + index\n+   * This logic is put in method addr(index) and is frequently\n+   * used in get/set data methods to compute the absolute\n+   * byte address for get/set operation in the underlying chunk\n+   *\n+   * @param index the index at which we the user wants to read/write\n+   * @return the absolute address within the memro\n+   */\n+  private long addr(int index) {\n \n Review comment:\n   I don't think we should encumber this patch with that change.\r\n   \r\n   Let's also have a discussion about that change on the mailing list before we make it. What use case is there where this is important?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-15T04:49:04.774+0000",
                    "updated": "2019-04-15T04:49:04.774+0000",
                    "started": "2019-04-15T04:49:04.773+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "227431",
                    "issueId": "13183717"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/worklog/227433",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jacques-n commented on pull request #4151: ARROW-3191:[JAVA] WIP for pointing ArrowBuf to arbitrary memory\nURL: https://github.com/apache/arrow/pull/4151#discussion_r275205782\n \n \n\n ##########\n File path: java/memory/src/main/java/io/netty/buffer/ArrowBuf.java\n ##########\n @@ -17,144 +17,84 @@\n \n package io.netty.buffer;\n \n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n import java.nio.ByteBuffer;\n import java.nio.ByteOrder;\n-import java.nio.channels.FileChannel;\n-import java.nio.channels.GatheringByteChannel;\n-import java.nio.channels.ScatteringByteChannel;\n-import java.nio.charset.Charset;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n \n-import org.apache.arrow.memory.AllocationManager.BufferLedger;\n-import org.apache.arrow.memory.ArrowByteBufAllocator;\n-import org.apache.arrow.memory.BaseAllocator;\n+import io.netty.util.IllegalReferenceCountException;\n+import io.netty.util.internal.MathUtil;\n+import org.apache.arrow.memory.*;\n import org.apache.arrow.memory.BaseAllocator.Verbosity;\n-import org.apache.arrow.memory.BoundsChecking;\n-import org.apache.arrow.memory.BufferAllocator;\n-import org.apache.arrow.memory.BufferManager;\n import org.apache.arrow.memory.util.HistoricalLog;\n import org.apache.arrow.util.Preconditions;\n \n import io.netty.util.internal.PlatformDependent;\n \n /**\n- * ArrowBuf is the abstraction around raw byte arrays that\n- * comprise arrow data structures.\n+ * ArrowBuf serves as a facade over underlying memory by providing\n+ * several access APIs to read/write data into a chunk of direct\n+ * memory. All the accounting, ownership and reference management\n+ * is done by {@link ReferenceManager} and ArrowBuf can work\n+ * with a custom user provided implementation of ReferenceManager\n  *\n+ * Two important instance variables of an ArrowBuf:\n  *\n- * <p>Specifically, it serves as a facade over\n- * {@linkplain UnsafeDirectLittleEndian} memory objects that hides the details\n- * of raw memory addresses.\n+ * (1) address - starting virtual address in the underlying memory\n+ * chunk that this ArrowBuf has access to\n  *\n- * <p>ArrowBuf supports reference counting and ledgering to closely track where\n- * memory is being used.\n+ * (2) length - length (in bytes) in the underlying memory chunk\n \n Review comment:\n   It definitely should be tied to a memory address. Whether that is backed by a memory mapped file will be up to the consumer with this change.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-15T04:50:13.605+0000",
                    "updated": "2019-04-15T04:50:13.605+0000",
                    "started": "2019-04-15T04:50:13.605+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "227433",
                    "issueId": "13183717"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/worklog/227435",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jacques-n commented on issue #4151: ARROW-3191:[JAVA] WIP for pointing ArrowBuf to arbitrary memory\nURL: https://github.com/apache/arrow/pull/4151#issuecomment-483107177\n \n \n   > > Make ArrowBuf work with any arbitrary memory.\r\n   > \r\n   > What does \"arbitrary memory\" mean? Would this include also device memory?\r\n   \r\n   It just means any memory address, not just those attached to a Netty allocator. Right now, ArrowBuf must be allocated by the Netty allocator which means that if a user allocated memory some other way, he is unable to connect it to Arrow. For example, the Java Plasma client has that problem right now.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-15T04:55:04.471+0000",
                    "updated": "2019-04-15T04:55:04.471+0000",
                    "started": "2019-04-15T04:55:04.471+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "227435",
                    "issueId": "13183717"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/worklog/227436",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jacques-n commented on pull request #4151: ARROW-3191:[JAVA] WIP for pointing ArrowBuf to arbitrary memory\nURL: https://github.com/apache/arrow/pull/4151#discussion_r275206384\n \n \n\n ##########\n File path: java/memory/src/main/java/io/netty/buffer/ArrowBuf.java\n ##########\n @@ -499,461 +225,212 @@ public boolean equals(Object obj) {\n     return this == obj;\n   }\n \n-  @Override\n-  public ArrowBuf retain(int increment) {\n-    Preconditions.checkArgument(increment > 0, \"retain(%d) argument is not positive\", increment);\n-\n-    if (isEmpty) {\n-      return this;\n-    }\n-\n-    if (BaseAllocator.DEBUG) {\n-      historicalLog.recordEvent(\"retain(%d)\", increment);\n-    }\n-\n-    final int originalReferenceCount = refCnt.getAndAdd(increment);\n-    Preconditions.checkArgument(originalReferenceCount > 0);\n-    return this;\n-  }\n-\n-  @Override\n-  public ArrowBuf retain() {\n-    return retain(1);\n-  }\n-\n-  @Override\n-  public ByteBuf touch() {\n-    return this;\n+  /**\n+   * IMPORTANT NOTE\n+   * The data getters and setters work with a caller provided\n+   * index. This index is 0 based and since ArrowBuf has access\n+   * to a portion of underlying chunk of memory starting at\n+   * some address, we convert the given relative index into\n+   * absolute index as memory address + index.\n+   *\n+   * Example:\n+   *\n+   * Let's say we have an underlying chunk of memory of length 64 bytes\n+   * Now let's say we have an ArrowBuf that has access to the chunk\n+   * from offset 4 for length of 16 bytes.\n+   *\n+   * If the starting virtual address of chunk is MAR, then memory\n+   * address of this ArrowBuf is MAR + offset -- this is what is stored\n+   * in variable addr. See the BufferLedger and AllocationManager code\n+   * for the implementation of ReferenceManager that manages a\n+   * chunk of memory and creates ArrowBuf with access to a range of\n+   * bytes within the chunk (or the entire chunk)\n+   *\n+   * So now to get/set data, we will do => addr + index\n+   * This logic is put in method addr(index) and is frequently\n+   * used in get/set data methods to compute the absolute\n+   * byte address for get/set operation in the underlying chunk\n+   *\n+   * @param index the index at which we the user wants to read/write\n+   * @return the absolute address within the memro\n+   */\n+  private long addr(int index) {\n+    return addr + index;\n   }\n \n-  @Override\n-  public ByteBuf touch(Object hint) {\n-    return this;\n+  public long getLong(int index) {\n+    chk(index, 8);\n+    return PlatformDependent.getLong(addr(index));\n   }\n \n-  @Override\n-  public long getLong(int index) {\n+  public ArrowBuf setLong(int index, long value) {\n     chk(index, 8);\n-    final long v = PlatformDependent.getLong(addr(index));\n-    return v;\n+    PlatformDependent.putLong(addr(index), value);\n+    return this;\n   }\n \n-  @Override\n   public float getFloat(int index) {\n     return Float.intBitsToFloat(getInt(index));\n   }\n \n-  /**\n-   * Gets a 64-bit long integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public long getLongLE(int index) {\n-    chk(index, 8);\n-    final long v = PlatformDependent.getLong(addr(index));\n-    return Long.reverseBytes(v);\n+  public ArrowBuf setFloat(int index, float value) {\n+    chk(index, 4);\n+    PlatformDependent.putInt(addr(index), Float.floatToRawIntBits(value));\n+    return this;\n   }\n \n-  @Override\n   public double getDouble(int index) {\n     return Double.longBitsToDouble(getLong(index));\n   }\n \n-  @Override\n-  public char getChar(int index) {\n-    return (char) getShort(index);\n-  }\n-\n-  @Override\n-  public long getUnsignedInt(int index) {\n-    return getInt(index) & 0xFFFFFFFFL;\n-  }\n-\n-  @Override\n-  public int getInt(int index) {\n-    chk(index, 4);\n-    final int v = PlatformDependent.getInt(addr(index));\n-    return v;\n-  }\n-\n-  /**\n-   * Gets a 32-bit integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public int getIntLE(int index) {\n-    chk(index, 4);\n-    final int v = PlatformDependent.getInt(addr(index));\n-    return Integer.reverseBytes(v);\n-  }\n-\n-  @Override\n-  public int getUnsignedShort(int index) {\n-    return getShort(index) & 0xFFFF;\n-  }\n-\n-  @Override\n-  public short getShort(int index) {\n-    chk(index, 2);\n-    final short v = PlatformDependent.getShort(addr(index));\n-    return v;\n-  }\n-\n-  /**\n-   * Gets a 16-bit short integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public short getShortLE(int index) {\n-    final short v = PlatformDependent.getShort(addr(index));\n-    return Short.reverseBytes(v);\n-  }\n-\n-  /**\n-   * Gets an unsigned 24-bit medium integer at the specified absolute\n-   * {@code index} in this buffer.\n-   */\n-  @Override\n-  public int getUnsignedMedium(int index) {\n-    chk(index, 3);\n-    final long addr = addr(index);\n-    return (PlatformDependent.getByte(addr) & 0xff) << 16 |\n-        (PlatformDependent.getShort(addr + 1) & 0xffff);\n+  public ArrowBuf setDouble(int index, double value) {\n+    chk(index, 8);\n+    PlatformDependent.putLong(addr(index), Double.doubleToRawLongBits(value));\n+    return this;\n   }\n \n-  /**\n-   * Gets an unsigned 24-bit medium integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public int getUnsignedMediumLE(int index) {\n-    chk(index, 3);\n-    final long addr = addr(index);\n-    return (PlatformDependent.getByte(addr) & 0xff) |\n-        (Short.reverseBytes(PlatformDependent.getShort(addr + 1)) & 0xffff) << 8;\n+  public char getChar(int index) {\n+    return (char) getShort(index);\n   }\n \n-  @Override\n-  public ArrowBuf setShort(int index, int value) {\n+  public ArrowBuf setChar(int index, int value) {\n     chk(index, 2);\n     PlatformDependent.putShort(addr(index), (short) value);\n     return this;\n   }\n \n-  /**\n-   * Sets the specified 16-bit short integer at the specified absolute {@code index}\n-   * in this buffer with Big Endian byte order.\n-   */\n-  @Override\n-  public ByteBuf setShortLE(int index, int value) {\n-    chk(index, 2);\n-    PlatformDependent.putShort(addr(index), Short.reverseBytes((short) value));\n-    return this;\n-  }\n-\n-  /**\n-   * Sets the specified 24-bit medium integer at the specified absolute\n-   * {@code index} in this buffer.\n-   */\n-  @Override\n-  public ByteBuf setMedium(int index, int value) {\n-    chk(index, 3);\n-    final long addr = addr(index);\n-    PlatformDependent.putByte(addr, (byte) (value >>> 16));\n-    PlatformDependent.putShort(addr + 1, (short) value);\n-    return this;\n-  }\n-\n-\n-  /**\n-   * Sets the specified 24-bit medium integer at the specified absolute {@code index}\n-   * in this buffer with Big Endian byte order.\n-   */\n-  @Override\n-  public ByteBuf setMediumLE(int index, int value) {\n-    chk(index, 3);\n-    final long addr = addr(index);\n-    PlatformDependent.putByte(addr, (byte) value);\n-    PlatformDependent.putShort(addr + 1, Short.reverseBytes((short) (value >>> 8)));\n-    return this;\n+  public int getInt(int index) {\n+    chk(index, 4);\n+    return PlatformDependent.getInt(addr(index));\n   }\n \n-  @Override\n   public ArrowBuf setInt(int index, int value) {\n     chk(index, 4);\n     PlatformDependent.putInt(addr(index), value);\n     return this;\n   }\n \n-  /**\n-   * Sets the specified 32-bit integer at the specified absolute {@code index}\n-   * in this buffer with Big Endian byte order.\n-   */\n-  @Override\n-  public ByteBuf setIntLE(int index, int value) {\n-    chk(index, 4);\n-    PlatformDependent.putInt(addr(index), Integer.reverseBytes(value));\n-    return this;\n-  }\n-\n-  @Override\n-  public ArrowBuf setLong(int index, long value) {\n-    chk(index, 8);\n-    PlatformDependent.putLong(addr(index), value);\n-    return this;\n-  }\n-\n-  /**\n-   * Sets the specified 64-bit long integer at the specified absolute {@code index}\n-   * in this buffer with Big Endian byte order.\n-   */\n-  @Override\n-  public ByteBuf setLongLE(int index, long value) {\n-    chk(index, 8);\n-    PlatformDependent.putLong(addr(index), Long.reverseBytes(value));\n-    return this;\n+  public short getShort(int index) {\n+    chk(index, 2);\n+    return PlatformDependent.getShort(addr(index));\n   }\n \n-  @Override\n-  public ArrowBuf setChar(int index, int value) {\n+  public ArrowBuf setShort(int index, int value) {\n     chk(index, 2);\n     PlatformDependent.putShort(addr(index), (short) value);\n     return this;\n   }\n \n-  @Override\n-  public ArrowBuf setFloat(int index, float value) {\n-    chk(index, 4);\n-    PlatformDependent.putInt(addr(index), Float.floatToRawIntBits(value));\n-    return this;\n-  }\n-\n-  @Override\n-  public ArrowBuf setDouble(int index, double value) {\n-    chk(index, 8);\n-    PlatformDependent.putLong(addr(index), Double.doubleToRawLongBits(value));\n-    return this;\n-  }\n-\n-  @Override\n   public ArrowBuf writeShort(int value) {\n     ensure(2);\n     PlatformDependent.putShort(addr(writerIndex), (short) value);\n     writerIndex += 2;\n     return this;\n   }\n \n-  @Override\n   public ArrowBuf writeInt(int value) {\n     ensure(4);\n     PlatformDependent.putInt(addr(writerIndex), value);\n     writerIndex += 4;\n     return this;\n   }\n \n-  @Override\n   public ArrowBuf writeLong(long value) {\n     ensure(8);\n     PlatformDependent.putLong(addr(writerIndex), value);\n     writerIndex += 8;\n     return this;\n   }\n \n-  @Override\n-  public ArrowBuf writeChar(int value) {\n-    ensure(2);\n-    PlatformDependent.putShort(addr(writerIndex), (short) value);\n-    writerIndex += 2;\n-    return this;\n-  }\n-\n-  @Override\n   public ArrowBuf writeFloat(float value) {\n     ensure(4);\n     PlatformDependent.putInt(addr(writerIndex), Float.floatToRawIntBits(value));\n     writerIndex += 4;\n     return this;\n   }\n \n-  @Override\n   public ArrowBuf writeDouble(double value) {\n     ensure(8);\n     PlatformDependent.putLong(addr(writerIndex), Double.doubleToRawLongBits(value));\n     writerIndex += 8;\n     return this;\n   }\n \n-  @Override\n-  public ArrowBuf getBytes(int index, byte[] dst, int dstIndex, int length) {\n-    udle.getBytes(index + offset, dst, dstIndex, length);\n-    return this;\n-  }\n-\n-  @Override\n-  public ArrowBuf getBytes(int index, ByteBuffer dst) {\n-    udle.getBytes(index + offset, dst);\n-    return this;\n-  }\n-\n-  @Override\n   public ArrowBuf setByte(int index, int value) {\n     chk(index, 1);\n     PlatformDependent.putByte(addr(index), (byte) value);\n     return this;\n   }\n \n \n Review comment:\n   Let's make sure people are happy with overall shape/approach of patch before we spend time on this type of changes.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-15T04:55:49.233+0000",
                    "updated": "2019-04-15T04:55:49.233+0000",
                    "started": "2019-04-15T04:55:49.233+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "227436",
                    "issueId": "13183717"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/worklog/227437",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #4151: ARROW-3191:[JAVA] WIP for pointing ArrowBuf to arbitrary memory\nURL: https://github.com/apache/arrow/pull/4151#discussion_r275207194\n \n \n\n ##########\n File path: java/memory/src/main/java/io/netty/buffer/ArrowBuf.java\n ##########\n @@ -499,461 +225,212 @@ public boolean equals(Object obj) {\n     return this == obj;\n   }\n \n-  @Override\n-  public ArrowBuf retain(int increment) {\n-    Preconditions.checkArgument(increment > 0, \"retain(%d) argument is not positive\", increment);\n-\n-    if (isEmpty) {\n-      return this;\n-    }\n-\n-    if (BaseAllocator.DEBUG) {\n-      historicalLog.recordEvent(\"retain(%d)\", increment);\n-    }\n-\n-    final int originalReferenceCount = refCnt.getAndAdd(increment);\n-    Preconditions.checkArgument(originalReferenceCount > 0);\n-    return this;\n-  }\n-\n-  @Override\n-  public ArrowBuf retain() {\n-    return retain(1);\n-  }\n-\n-  @Override\n-  public ByteBuf touch() {\n-    return this;\n+  /**\n+   * IMPORTANT NOTE\n+   * The data getters and setters work with a caller provided\n+   * index. This index is 0 based and since ArrowBuf has access\n+   * to a portion of underlying chunk of memory starting at\n+   * some address, we convert the given relative index into\n+   * absolute index as memory address + index.\n+   *\n+   * Example:\n+   *\n+   * Let's say we have an underlying chunk of memory of length 64 bytes\n+   * Now let's say we have an ArrowBuf that has access to the chunk\n+   * from offset 4 for length of 16 bytes.\n+   *\n+   * If the starting virtual address of chunk is MAR, then memory\n+   * address of this ArrowBuf is MAR + offset -- this is what is stored\n+   * in variable addr. See the BufferLedger and AllocationManager code\n+   * for the implementation of ReferenceManager that manages a\n+   * chunk of memory and creates ArrowBuf with access to a range of\n+   * bytes within the chunk (or the entire chunk)\n+   *\n+   * So now to get/set data, we will do => addr + index\n+   * This logic is put in method addr(index) and is frequently\n+   * used in get/set data methods to compute the absolute\n+   * byte address for get/set operation in the underlying chunk\n+   *\n+   * @param index the index at which we the user wants to read/write\n+   * @return the absolute address within the memro\n+   */\n+  private long addr(int index) {\n \n Review comment:\n   I can bring this up for discussion on the mailing list but the suggestion is to bring this in line with the C++ side of things so large message batches can be read in java if desired see (https://issues.apache.org/jira/browse/ARROW-679)\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-15T05:03:51.337+0000",
                    "updated": "2019-04-15T05:03:51.337+0000",
                    "started": "2019-04-15T05:03:51.337+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "227437",
                    "issueId": "13183717"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/worklog/227442",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #4151: ARROW-3191:[JAVA] WIP for pointing ArrowBuf to arbitrary memory\nURL: https://github.com/apache/arrow/pull/4151#discussion_r275210646\n \n \n\n ##########\n File path: java/memory/src/main/java/org/apache/arrow/memory/ReferenceManager.java\n ##########\n @@ -0,0 +1,101 @@\n+package org.apache.arrow.memory;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+/**\n+ * Reference Manager manages one or more ArrowBufs that share the\n+ * reference count for the underlying memory chunk.\n+ */\n+public interface ReferenceManager {\n+\n+  /**\n+   * Return the reference count\n+   * @return reference count\n+   */\n+  int getRefCount();\n+\n+  /**\n+   * Decrement this reference manager's reference count for the associated underlying\n+   * memory. If the reference count drops to 0, it implies that ArrowBufs managed by this\n+   * reference manager no longer need access to the underlying memory\n+   * @return the new reference count\n+   */\n+  boolean release();\n+\n+  /**\n+   * Decrement this reference manager's reference count for the associated underlying\n+   * memory. If the reference count drops to 0, it implies that ArrowBufs managed by this\n+   * reference manager no longer need access to the underlying memory\n+   * @param increment the count to increase the reference count by\n+   * @return the new reference count\n+   */\n+  boolean release(int increment);\n+\n+  /**\n+   * Increment this reference manager's reference count by 1 for the associated underlying\n+   * memory.\n+   */\n+  void retain();\n+\n+  /**\n+   * Increment this reference manager's reference count by a given amount for the\n+   * associated underlying memory\n+   * @param increment the count to increase the reference count by\n+   */\n+  void retain(int increment);\n+\n+  /**\n+   * Create a new ArrowBuf that is associated with an alternative allocator for the purposes of\n+   * memory ownership and accounting. This has no impact on the reference counting for the current\n+   * ArrowBuf except in the situation where the passed in Allocator is the same as the current buffer.\n+   *\n+   * This operation has no impact on the reference count of this ArrowBuf. The newly created\n+   * ArrowBuf with either have a reference count of 1 (in the case that this is the first time this\n+   * memory is being associated with the target allocator or in other words allocation manager currently\n+   * doesn't hold a mapping for the target allocator) or the current value of the reference count for\n+   * the target allocator-reference manager combination + 1 in the case that the provided allocator\n+   * already had an association to this underlying memory.\n+   *\n+   * @param srcBuffer source ArrowBuf\n+   * @param targetAllocator The target allocator to create an association with.\n+   * @return A new ArrowBuf which shares the same underlying memory as this ArrowBuf.\n+   */\n+  ArrowBuf retain (ArrowBuf srcBuffer, BufferAllocator targetAllocator);\n \n Review comment:\n   this name doesn't seem to match up well with the documentation if an actual arrowbuf is being allocated.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-15T05:30:29.816+0000",
                    "updated": "2019-04-15T05:30:29.816+0000",
                    "started": "2019-04-15T05:30:29.815+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "227442",
                    "issueId": "13183717"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/worklog/229217",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "BryanCutler commented on pull request #4151: ARROW-3191:[JAVA] WIP for pointing ArrowBuf to arbitrary memory\nURL: https://github.com/apache/arrow/pull/4151#discussion_r276323478\n \n \n\n ##########\n File path: java/memory/src/main/java/io/netty/buffer/ArrowBuf.java\n ##########\n @@ -499,461 +225,212 @@ public boolean equals(Object obj) {\n     return this == obj;\n   }\n \n-  @Override\n-  public ArrowBuf retain(int increment) {\n-    Preconditions.checkArgument(increment > 0, \"retain(%d) argument is not positive\", increment);\n-\n-    if (isEmpty) {\n-      return this;\n-    }\n-\n-    if (BaseAllocator.DEBUG) {\n-      historicalLog.recordEvent(\"retain(%d)\", increment);\n-    }\n-\n-    final int originalReferenceCount = refCnt.getAndAdd(increment);\n-    Preconditions.checkArgument(originalReferenceCount > 0);\n-    return this;\n-  }\n-\n-  @Override\n-  public ArrowBuf retain() {\n-    return retain(1);\n-  }\n-\n-  @Override\n-  public ByteBuf touch() {\n-    return this;\n+  /**\n+   * IMPORTANT NOTE\n+   * The data getters and setters work with a caller provided\n+   * index. This index is 0 based and since ArrowBuf has access\n+   * to a portion of underlying chunk of memory starting at\n+   * some address, we convert the given relative index into\n+   * absolute index as memory address + index.\n+   *\n+   * Example:\n+   *\n+   * Let's say we have an underlying chunk of memory of length 64 bytes\n+   * Now let's say we have an ArrowBuf that has access to the chunk\n+   * from offset 4 for length of 16 bytes.\n+   *\n+   * If the starting virtual address of chunk is MAR, then memory\n+   * address of this ArrowBuf is MAR + offset -- this is what is stored\n+   * in variable addr. See the BufferLedger and AllocationManager code\n+   * for the implementation of ReferenceManager that manages a\n+   * chunk of memory and creates ArrowBuf with access to a range of\n+   * bytes within the chunk (or the entire chunk)\n+   *\n+   * So now to get/set data, we will do => addr + index\n+   * This logic is put in method addr(index) and is frequently\n+   * used in get/set data methods to compute the absolute\n+   * byte address for get/set operation in the underlying chunk\n+   *\n+   * @param index the index at which we the user wants to read/write\n+   * @return the absolute address within the memro\n+   */\n+  private long addr(int index) {\n+    return addr + index;\n   }\n \n-  @Override\n-  public ByteBuf touch(Object hint) {\n-    return this;\n+  public long getLong(int index) {\n+    chk(index, 8);\n+    return PlatformDependent.getLong(addr(index));\n   }\n \n-  @Override\n-  public long getLong(int index) {\n+  public ArrowBuf setLong(int index, long value) {\n     chk(index, 8);\n-    final long v = PlatformDependent.getLong(addr(index));\n-    return v;\n+    PlatformDependent.putLong(addr(index), value);\n+    return this;\n   }\n \n-  @Override\n   public float getFloat(int index) {\n     return Float.intBitsToFloat(getInt(index));\n   }\n \n-  /**\n-   * Gets a 64-bit long integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public long getLongLE(int index) {\n-    chk(index, 8);\n-    final long v = PlatformDependent.getLong(addr(index));\n-    return Long.reverseBytes(v);\n+  public ArrowBuf setFloat(int index, float value) {\n+    chk(index, 4);\n+    PlatformDependent.putInt(addr(index), Float.floatToRawIntBits(value));\n+    return this;\n   }\n \n-  @Override\n   public double getDouble(int index) {\n     return Double.longBitsToDouble(getLong(index));\n   }\n \n-  @Override\n-  public char getChar(int index) {\n-    return (char) getShort(index);\n-  }\n-\n-  @Override\n-  public long getUnsignedInt(int index) {\n-    return getInt(index) & 0xFFFFFFFFL;\n-  }\n-\n-  @Override\n-  public int getInt(int index) {\n-    chk(index, 4);\n-    final int v = PlatformDependent.getInt(addr(index));\n-    return v;\n-  }\n-\n-  /**\n-   * Gets a 32-bit integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public int getIntLE(int index) {\n-    chk(index, 4);\n-    final int v = PlatformDependent.getInt(addr(index));\n-    return Integer.reverseBytes(v);\n-  }\n-\n-  @Override\n-  public int getUnsignedShort(int index) {\n-    return getShort(index) & 0xFFFF;\n-  }\n-\n-  @Override\n-  public short getShort(int index) {\n-    chk(index, 2);\n-    final short v = PlatformDependent.getShort(addr(index));\n-    return v;\n-  }\n-\n-  /**\n-   * Gets a 16-bit short integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public short getShortLE(int index) {\n-    final short v = PlatformDependent.getShort(addr(index));\n-    return Short.reverseBytes(v);\n-  }\n-\n-  /**\n-   * Gets an unsigned 24-bit medium integer at the specified absolute\n-   * {@code index} in this buffer.\n-   */\n-  @Override\n-  public int getUnsignedMedium(int index) {\n-    chk(index, 3);\n-    final long addr = addr(index);\n-    return (PlatformDependent.getByte(addr) & 0xff) << 16 |\n-        (PlatformDependent.getShort(addr + 1) & 0xffff);\n+  public ArrowBuf setDouble(int index, double value) {\n+    chk(index, 8);\n+    PlatformDependent.putLong(addr(index), Double.doubleToRawLongBits(value));\n+    return this;\n   }\n \n-  /**\n-   * Gets an unsigned 24-bit medium integer at the specified absolute {@code index} in\n-   * this buffer in Big Endian Byte Order.\n-   */\n-  @Override\n-  public int getUnsignedMediumLE(int index) {\n-    chk(index, 3);\n-    final long addr = addr(index);\n-    return (PlatformDependent.getByte(addr) & 0xff) |\n-        (Short.reverseBytes(PlatformDependent.getShort(addr + 1)) & 0xffff) << 8;\n+  public char getChar(int index) {\n+    return (char) getShort(index);\n   }\n \n-  @Override\n-  public ArrowBuf setShort(int index, int value) {\n+  public ArrowBuf setChar(int index, int value) {\n     chk(index, 2);\n     PlatformDependent.putShort(addr(index), (short) value);\n     return this;\n   }\n \n-  /**\n-   * Sets the specified 16-bit short integer at the specified absolute {@code index}\n-   * in this buffer with Big Endian byte order.\n-   */\n-  @Override\n-  public ByteBuf setShortLE(int index, int value) {\n-    chk(index, 2);\n-    PlatformDependent.putShort(addr(index), Short.reverseBytes((short) value));\n-    return this;\n-  }\n-\n-  /**\n-   * Sets the specified 24-bit medium integer at the specified absolute\n-   * {@code index} in this buffer.\n-   */\n-  @Override\n-  public ByteBuf setMedium(int index, int value) {\n-    chk(index, 3);\n-    final long addr = addr(index);\n-    PlatformDependent.putByte(addr, (byte) (value >>> 16));\n-    PlatformDependent.putShort(addr + 1, (short) value);\n-    return this;\n-  }\n-\n-\n-  /**\n-   * Sets the specified 24-bit medium integer at the specified absolute {@code index}\n-   * in this buffer with Big Endian byte order.\n-   */\n-  @Override\n-  public ByteBuf setMediumLE(int index, int value) {\n-    chk(index, 3);\n-    final long addr = addr(index);\n-    PlatformDependent.putByte(addr, (byte) value);\n-    PlatformDependent.putShort(addr + 1, Short.reverseBytes((short) (value >>> 8)));\n-    return this;\n+  public int getInt(int index) {\n+    chk(index, 4);\n+    return PlatformDependent.getInt(addr(index));\n   }\n \n-  @Override\n   public ArrowBuf setInt(int index, int value) {\n     chk(index, 4);\n     PlatformDependent.putInt(addr(index), value);\n     return this;\n   }\n \n-  /**\n-   * Sets the specified 32-bit integer at the specified absolute {@code index}\n-   * in this buffer with Big Endian byte order.\n-   */\n-  @Override\n-  public ByteBuf setIntLE(int index, int value) {\n-    chk(index, 4);\n-    PlatformDependent.putInt(addr(index), Integer.reverseBytes(value));\n-    return this;\n-  }\n-\n-  @Override\n-  public ArrowBuf setLong(int index, long value) {\n-    chk(index, 8);\n-    PlatformDependent.putLong(addr(index), value);\n-    return this;\n-  }\n-\n-  /**\n-   * Sets the specified 64-bit long integer at the specified absolute {@code index}\n-   * in this buffer with Big Endian byte order.\n-   */\n-  @Override\n-  public ByteBuf setLongLE(int index, long value) {\n-    chk(index, 8);\n-    PlatformDependent.putLong(addr(index), Long.reverseBytes(value));\n-    return this;\n+  public short getShort(int index) {\n+    chk(index, 2);\n+    return PlatformDependent.getShort(addr(index));\n   }\n \n-  @Override\n-  public ArrowBuf setChar(int index, int value) {\n+  public ArrowBuf setShort(int index, int value) {\n     chk(index, 2);\n     PlatformDependent.putShort(addr(index), (short) value);\n     return this;\n   }\n \n-  @Override\n-  public ArrowBuf setFloat(int index, float value) {\n-    chk(index, 4);\n-    PlatformDependent.putInt(addr(index), Float.floatToRawIntBits(value));\n-    return this;\n-  }\n-\n-  @Override\n-  public ArrowBuf setDouble(int index, double value) {\n-    chk(index, 8);\n-    PlatformDependent.putLong(addr(index), Double.doubleToRawLongBits(value));\n-    return this;\n-  }\n-\n-  @Override\n   public ArrowBuf writeShort(int value) {\n     ensure(2);\n     PlatformDependent.putShort(addr(writerIndex), (short) value);\n     writerIndex += 2;\n     return this;\n   }\n \n-  @Override\n   public ArrowBuf writeInt(int value) {\n     ensure(4);\n     PlatformDependent.putInt(addr(writerIndex), value);\n     writerIndex += 4;\n     return this;\n   }\n \n-  @Override\n   public ArrowBuf writeLong(long value) {\n     ensure(8);\n     PlatformDependent.putLong(addr(writerIndex), value);\n     writerIndex += 8;\n     return this;\n   }\n \n-  @Override\n-  public ArrowBuf writeChar(int value) {\n-    ensure(2);\n-    PlatformDependent.putShort(addr(writerIndex), (short) value);\n-    writerIndex += 2;\n-    return this;\n-  }\n-\n-  @Override\n   public ArrowBuf writeFloat(float value) {\n     ensure(4);\n     PlatformDependent.putInt(addr(writerIndex), Float.floatToRawIntBits(value));\n     writerIndex += 4;\n     return this;\n   }\n \n-  @Override\n   public ArrowBuf writeDouble(double value) {\n     ensure(8);\n     PlatformDependent.putLong(addr(writerIndex), Double.doubleToRawLongBits(value));\n     writerIndex += 8;\n     return this;\n   }\n \n-  @Override\n-  public ArrowBuf getBytes(int index, byte[] dst, int dstIndex, int length) {\n-    udle.getBytes(index + offset, dst, dstIndex, length);\n-    return this;\n-  }\n-\n-  @Override\n-  public ArrowBuf getBytes(int index, ByteBuffer dst) {\n-    udle.getBytes(index + offset, dst);\n-    return this;\n-  }\n-\n-  @Override\n   public ArrowBuf setByte(int index, int value) {\n     chk(index, 1);\n     PlatformDependent.putByte(addr(index), (byte) value);\n     return this;\n   }\n \n-  public void setByte(int index, byte b) {\n+  public ArrowBuf setByte(int index, byte b) {\n     chk(index, 1);\n     PlatformDependent.putByte(addr(index), b);\n+    return this;\n   }\n \n-  public void writeByteUnsafe(byte b) {\n-    PlatformDependent.putByte(addr(readerIndex), b);\n-    readerIndex++;\n-  }\n-\n-  @Override\n-  protected byte _getByte(int index) {\n-    return getByte(index);\n-  }\n-\n-  @Override\n-  protected short _getShort(int index) {\n-    return getShort(index);\n-  }\n-\n-  /**\n-   * @see ArrowBuf#getShortLE(int).\n-   */\n-  @Override\n-  protected short _getShortLE(int index) {\n-    return getShortLE(index);\n-  }\n-\n-  @Override\n-  protected int _getInt(int index) {\n-    return getInt(index);\n-  }\n-\n-  /**\n-   * @see ArrowBuf#getIntLE(int).\n-   */\n-  @Override\n-  protected int _getIntLE(int index) {\n-    return getIntLE(index);\n-  }\n-\n-  /**\n-   * @see ArrowBuf#getUnsignedMedium(int).\n-   */\n-  @Override\n-  protected int _getUnsignedMedium(int index) {\n-    return getUnsignedMedium(index);\n-  }\n-\n-  /**\n-   * @see ArrowBuf#getUnsignedMediumLE(int).\n-   */\n-  @Override\n-  protected int _getUnsignedMediumLE(int index) {\n-    return getUnsignedMediumLE(index);\n-  }\n-\n-  @Override\n-  protected long _getLong(int index) {\n-    return getLong(index);\n-  }\n-\n-  /**\n-   * @see ArrowBuf#getLongLE(int).\n-   */\n-  @Override\n-  protected long _getLongLE(int index) {\n-    return getLongLE(index);\n-  }\n-\n-  @Override\n-  protected void _setByte(int index, int value) {\n-    setByte(index, value);\n-  }\n-\n-  @Override\n-  protected void _setShort(int index, int value) {\n-    setShort(index, value);\n-  }\n-\n-  /**\n-   * @see ArrowBuf#setShortLE(int, int).\n-   */\n-  @Override\n-  protected void _setShortLE(int index, int value) {\n-    setShortLE(index, value);\n-  }\n-\n-  @Override\n-  protected void _setMedium(int index, int value) {\n-    setMedium(index, value);\n-  }\n-\n-  /**\n-   * @see ArrowBuf#setMediumLE(int, int).\n-   */\n-  @Override\n-  protected void _setMediumLE(int index, int value) {\n-    setMediumLE(index, value);\n-  }\n-\n-  @Override\n-  protected void _setInt(int index, int value) {\n-    setInt(index, value);\n-  }\n-\n-  /**\n-   * @see ArrowBuf#setIntLE(int, int).\n-   */\n-  @Override\n-  protected void _setIntLE(int index, int value) {\n-    setIntLE(index, value);\n-  }\n-\n-  @Override\n-  protected void _setLong(int index, long value) {\n-    setLong(index, value);\n+  public byte getByte(int index) {\n+    chk(index, 1);\n+    return PlatformDependent.getByte(addr(index));\n   }\n \n-  /**\n-   * @see ArrowBuf#setLongLE(int, long).\n-   */\n-  @Override\n-  public void _setLongLE(int index, long value) {\n-    setLongLE(index, value);\n-  }\n+  // TODO: do bound checking properly for the following APIs\n \n-  @Override\n-  public ArrowBuf getBytes(int index, ByteBuf dst, int dstIndex, int length) {\n-    udle.getBytes(index + offset, dst, dstIndex, length);\n+  public ArrowBuf getBytes(int index, byte[] dst, int dstIndex, int length) {\n+    final int end = dstIndex + length - 1;\n+    for (int i = dstIndex; i <= end; i++) {\n+      dst[i] = PlatformDependent.getByte(addr(index));\n+    }\n     return this;\n   }\n \n-  @Override\n-  public ArrowBuf getBytes(int index, OutputStream out, int length) throws IOException {\n-    udle.getBytes(index + offset, out, length);\n+  public ArrowBuf getBytes(int index, ByteBuffer dst) {\n+    int toRead = length;\n+    long address = addr(index);\n+    // word by word memcpy\n+    while (toRead >= 8) {\n+      dst.putLong(PlatformDependent.getLong(address));\n+      address += 8;\n+      toRead -= 8;\n+    }\n+    while (toRead > 0) {\n+      dst.put(PlatformDependent.getByte(address));\n+      --toRead;\n \n Review comment:\n   do you need a `++address` here?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-17T16:57:26.030+0000",
                    "updated": "2019-04-17T16:57:26.030+0000",
                    "started": "2019-04-17T16:57:26.029+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "229217",
                    "issueId": "13183717"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/worklog/229218",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "BryanCutler commented on pull request #4151: ARROW-3191:[JAVA] WIP for pointing ArrowBuf to arbitrary memory\nURL: https://github.com/apache/arrow/pull/4151#discussion_r276331217\n \n \n\n ##########\n File path: java/memory/src/main/java/org/apache/arrow/memory/BufferLedger.java\n ##########\n @@ -0,0 +1,515 @@\n+package org.apache.arrow.memory;\n+\n+import io.netty.buffer.ArrowBuf;\n+import io.netty.buffer.UnsafeDirectLittleEndian;\n+import org.apache.arrow.memory.util.HistoricalLog;\n+import org.apache.arrow.util.Preconditions;\n+\n+import java.util.IdentityHashMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import static org.apache.arrow.memory.BaseAllocator.indent;\n+\n+/**\n+ * The reference manager that binds an {@link AllocationManager} to\n+ * {@link BufferAllocator} and a set of {@link ArrowBuf}. The set of\n+ * ArrowBufs managed by this reference manager share a common\n+ * fate (same reference count)\n+ *\n+ * As with AllocationManager, the only reason this is public is due to ArrowBuf\n+ * being in io.netty.buffer package.\n+ */\n+public class BufferLedger implements ValueWithKeyIncluded<BaseAllocator>, ReferenceManager  {\n+\n+  private final IdentityHashMap<ArrowBuf, Integer> buffers = BaseAllocator.DEBUG ? new IdentityHashMap<>() : null;\n+  private static final AtomicLong LEDGER_ID_GENERATOR = new AtomicLong(0);\n+  // unique ID assigned to each ledger\n+  private final long ledgerId = LEDGER_ID_GENERATOR.incrementAndGet();\n+  private final AtomicInteger bufRefCnt = new AtomicInteger(0); // start at zero so we can\n+  // manage request for retain\n+  // correctly\n+  private final long lCreationTime = System.nanoTime();\n+  private final BaseAllocator allocator;\n+  private final AllocationManager allocationManager;\n+  private final HistoricalLog historicalLog =\n+    BaseAllocator.DEBUG ? new HistoricalLog(BaseAllocator.DEBUG_LOG_LENGTH, \"BufferLedger[%d]\", 1) : null;\n+  private volatile long lDestructionTime = 0;\n+\n+  BufferLedger(final BaseAllocator allocator, final AllocationManager allocationManager) {\n+    this.allocator = allocator;\n+    this.allocationManager = allocationManager;\n+  }\n+\n+  boolean isOwningLedger() {\n+    return this == allocationManager.getOwningLedger();\n+  }\n+\n+  public BaseAllocator getKey() {\n+    return allocator;\n+  }\n+\n+  /**\n+   * Get the buffer allocator associated with this reference manager\n+   * @return buffer allocator\n+   */\n+  @Override\n+  public BufferAllocator getAllocator() {\n+    return allocator;\n+  }\n+\n+  /**\n+   * Get this ledger's reference count\n+   * @return reference count\n+   */\n+  @Override\n+  public int getRefCount() {\n+    return bufRefCnt.get();\n+  }\n+\n+  /**\n+   * Increment the ledger's reference count for the associated\n+   * underlying memory chunk. All ArrowBufs managed by this ledger\n+   * will share the ref count.\n+   */\n+  void increment() {\n+    bufRefCnt.incrementAndGet();\n \n Review comment:\n   could it be helpful to return the new count?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-17T16:57:26.096+0000",
                    "updated": "2019-04-17T16:57:26.096+0000",
                    "started": "2019-04-17T16:57:26.096+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "229218",
                    "issueId": "13183717"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/worklog/229219",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "BryanCutler commented on pull request #4151: ARROW-3191:[JAVA] WIP for pointing ArrowBuf to arbitrary memory\nURL: https://github.com/apache/arrow/pull/4151#discussion_r276328448\n \n \n\n ##########\n File path: java/memory/src/main/java/org/apache/arrow/memory/ReferenceManager.java\n ##########\n @@ -0,0 +1,101 @@\n+package org.apache.arrow.memory;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+/**\n+ * Reference Manager manages one or more ArrowBufs that share the\n+ * reference count for the underlying memory chunk.\n+ */\n+public interface ReferenceManager {\n+\n+  /**\n+   * Return the reference count\n+   * @return reference count\n+   */\n+  int getRefCount();\n+\n+  /**\n+   * Decrement this reference manager's reference count for the associated underlying\n+   * memory. If the reference count drops to 0, it implies that ArrowBufs managed by this\n+   * reference manager no longer need access to the underlying memory\n+   * @return the new reference count\n \n Review comment:\n   it returns a boolean though?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-17T16:57:26.193+0000",
                    "updated": "2019-04-17T16:57:26.193+0000",
                    "started": "2019-04-17T16:57:26.192+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "229219",
                    "issueId": "13183717"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/worklog/229220",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "BryanCutler commented on pull request #4151: ARROW-3191:[JAVA] WIP for pointing ArrowBuf to arbitrary memory\nURL: https://github.com/apache/arrow/pull/4151#discussion_r276328542\n \n \n\n ##########\n File path: java/memory/src/main/java/org/apache/arrow/memory/ReferenceManager.java\n ##########\n @@ -0,0 +1,101 @@\n+package org.apache.arrow.memory;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+/**\n+ * Reference Manager manages one or more ArrowBufs that share the\n+ * reference count for the underlying memory chunk.\n+ */\n+public interface ReferenceManager {\n+\n+  /**\n+   * Return the reference count\n+   * @return reference count\n+   */\n+  int getRefCount();\n+\n+  /**\n+   * Decrement this reference manager's reference count for the associated underlying\n+   * memory. If the reference count drops to 0, it implies that ArrowBufs managed by this\n+   * reference manager no longer need access to the underlying memory\n+   * @return the new reference count\n+   */\n+  boolean release();\n+\n+  /**\n+   * Decrement this reference manager's reference count for the associated underlying\n+   * memory. If the reference count drops to 0, it implies that ArrowBufs managed by this\n+   * reference manager no longer need access to the underlying memory\n+   * @param increment the count to increase the reference count by\n+   * @return the new reference count\n \n Review comment:\n   same here\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-17T16:57:26.194+0000",
                    "updated": "2019-04-17T16:57:26.194+0000",
                    "started": "2019-04-17T16:57:26.194+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "229220",
                    "issueId": "13183717"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 34800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@50b56a7a[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2b19b6e3[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@42f6777f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@243e7f6c[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1af8b00f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@7a1790fe[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@bab4d4c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@5cb9964a[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@31e3d1a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@45c8cde7[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1458293f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@443e638[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 34800,
        "customfield_12312520": null,
        "customfield_12312521": "Tue May 07 23:30:19 UTC 2019",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2019-05-07T23:30:19.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3191/watchers",
            "watchCount": 10,
            "isWatching": false
        },
        "created": "2018-09-07T19:26:54.000+0000",
        "updated": "2019-05-29T06:16:34.000+0000",
        "timeoriginalestimate": null,
        "description": "Right now ArrowBuf can only point to memory managed by an Arrow Allocator. This is because in many cases we want to be able to support hierarchical accounting of\u00a0memory and the ability to transfer memory ownership between separate allocators within the same hierarchy.\r\n\r\nAt the same time,\u00a0there are definitely times where someone might want to map some amount of arbitrary off-heap memory. In these situations they should still be able to use ArrowBuf.\r\n\r\nI propose we have a new ArrowBuf constructor that\u00a0takes an input that subclasses an interface similar to:\r\n\r\n{code}\r\npublic abstract class Memory\u00a0 {\r\n  protected final int length;\r\n  protected final long address;\r\n  protected abstract void release();\r\n}\r\n{code}\r\n\r\nWe then make it so all the memory transfer semantics and accounting behavior are noops for this type of memory. The target of this work will be to make sure that all the fast paths continue to be efficient but some of the other paths like transfer can include a conditional (either directly or through alternative implementations of things like ledger).",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "9h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 34800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Java] Add support for ArrowBuf to point to arbitrary memory.",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/comment/16608040",
                    "id": "16608040",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "body": "As far as I can see, this is also a necessary integration to access Arrow buffers that were created in e.g. C++ or Python so that they can be consumed without a copy in Java.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "created": "2018-09-08T12:53:22.703+0000",
                    "updated": "2018-09-08T12:53:22.703+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/comment/16761808",
                    "id": "16761808",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Would anyone like to take a look at this? [~pravindra]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2019-02-06T15:00:16.142+0000",
                    "updated": "2019-02-06T15:00:16.142+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/comment/16771221",
                    "id": "16771221",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
                        "name": "jnadeau",
                        "key": "jnadeau",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Jacques Nadeau",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Hey [~siddteotia], any progress on this? It would be great to\u00a0be able to start using the Memory abstraction for several things. For example, being able to put an ArrowBuf in an ArrowBuf while\u00a0overloading the release() semantics becomes possible.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
                        "name": "jnadeau",
                        "key": "jnadeau",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Jacques Nadeau",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2019-02-18T16:52:12.520+0000",
                    "updated": "2019-02-18T16:52:12.520+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/comment/16790156",
                    "id": "16790156",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Any thoughts here? A chance this could get into 0.13?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2019-03-12T02:49:59.623+0000",
                    "updated": "2019-03-12T02:49:59.623+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/comment/16790205",
                    "id": "16790205",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=siddteotia",
                        "name": "siddteotia",
                        "key": "siddteotia",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=siddteotia&avatarId=32343",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=siddteotia&avatarId=32343",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=siddteotia&avatarId=32343",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=siddteotia&avatarId=32343"
                        },
                        "displayName": "Siddharth Teotia",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Sorry [~wesmckinn] and [~jnadeau], I\u00a0have not been able to start working on this one.\u00a0I will add it to my next sprint (next week) and will try if I can get started this week itself",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=siddteotia",
                        "name": "siddteotia",
                        "key": "siddteotia",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=siddteotia&avatarId=32343",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=siddteotia&avatarId=32343",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=siddteotia&avatarId=32343",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=siddteotia&avatarId=32343"
                        },
                        "displayName": "Siddharth Teotia",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2019-03-12T04:05:27.703+0000",
                    "updated": "2019-03-12T04:05:27.703+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/comment/16791002",
                    "id": "16791002",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "I'm moving this to 0.14. This feature will need some time to harden, but the sooner it's implemented the better so we can get feedback from folks",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2019-03-12T21:00:45.739+0000",
                    "updated": "2019-03-12T21:00:45.739+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13183717/comment/16835194",
                    "id": "16835194",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
                        "name": "bryanc",
                        "key": "bryanc",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
                        },
                        "displayName": "Bryan Cutler",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Issue resolved by pull request 4151\n[https://github.com/apache/arrow/pull/4151]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
                        "name": "bryanc",
                        "key": "bryanc",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
                        },
                        "displayName": "Bryan Cutler",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2019-05-07T23:30:19.432+0000",
                    "updated": "2019-05-07T23:30:19.432+0000"
                }
            ],
            "maxResults": 7,
            "total": 7,
            "startAt": 0
        },
        "customfield_12311820": "0|i3xuvr:",
        "customfield_12314139": null
    }
}