{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13286025",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286025",
    "key": "ARROW-7878",
    "fields": {
        "fixVersions": [],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/2",
            "id": "2",
            "description": "The problem described is an issue which will never be fixed.",
            "name": "Won't Fix"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12346687",
                "id": "12346687",
                "description": "",
                "name": "0.17.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-04-20"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12582969",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12582969",
                "type": {
                    "id": "10032",
                    "name": "Blocker",
                    "inward": "is blocked by",
                    "outward": "blocks",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10032"
                },
                "outwardIssue": {
                    "id": "13290879",
                    "key": "ARROW-8060",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13290879",
                    "fields": {
                        "summary": "[Python] Make dataset Expression objects serializable",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12624370",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12624370",
                "type": {
                    "id": "12310051",
                    "name": "Supercedes",
                    "inward": "is superceded by",
                    "outward": "supercedes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310051"
                },
                "inwardIssue": {
                    "id": "13363665",
                    "key": "ARROW-11928",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13363665",
                    "fields": {
                        "summary": "[C++][Compute] Add ExecNode hierarchy",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": null,
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
            "name": "Closed",
            "id": "6",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=fsaintjacques",
            "name": "fsaintjacques",
            "key": "fsaintjacques",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=fsaintjacques&avatarId=37276",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=fsaintjacques&avatarId=37276",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=fsaintjacques&avatarId=37276",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=fsaintjacques&avatarId=37276"
            },
            "displayName": "Francois Saint-Jacques",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=fsaintjacques",
            "name": "fsaintjacques",
            "key": "fsaintjacques",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=fsaintjacques&avatarId=37276",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=fsaintjacques&avatarId=37276",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=fsaintjacques&avatarId=37276",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=fsaintjacques&avatarId=37276"
            },
            "displayName": "Francois Saint-Jacques",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 67200,
            "total": 67200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 67200,
            "total": 67200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-7878/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 138,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286025/worklog/395293",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on pull request #6506: ARROW-7878: [C++][Compute] Draft LogicalPlan classes\nURL: https://github.com/apache/arrow/pull/6506\n \n \n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-02-28T21:45:39.327+0000",
                    "updated": "2020-02-28T21:45:39.327+0000",
                    "started": "2020-02-28T21:45:39.327+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "395293",
                    "issueId": "13286025"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286025/worklog/395296",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on issue #6506: ARROW-7878: [C++][Compute] Draft LogicalPlan classes\nURL: https://github.com/apache/arrow/pull/6506#issuecomment-592744951\n \n \n   https://issues.apache.org/jira/browse/ARROW-7878\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-02-28T21:49:57.042+0000",
                    "updated": "2020-02-28T21:49:57.042+0000",
                    "started": "2020-02-28T21:49:57.041+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "395296",
                    "issueId": "13286025"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286025/worklog/395598",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on pull request #6506: ARROW-7878: [C++][Compute] Draft LogicalPlan classes\nURL: https://github.com/apache/arrow/pull/6506#discussion_r386106517\n \n \n\n ##########\n File path: cpp/src/arrow/engine/expression.h\n ##########\n @@ -0,0 +1,490 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+\n+#include \"arrow/engine/catalog.h\"\n+#include \"arrow/engine/type_fwd.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/compare.h\"\n+#include \"arrow/util/variant.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+/// ExprType is a class representing the type of an Expression. The type is\n+/// composed of a shape and a DataType or a Schema depending on the shape.\n+///\n+/// ExprType is mainly used to validate arguments for operator expressions, e.g.\n+/// relational operator expressions expect inputs of Table shape.\n+///\n+/// The sum-type representation would be:\n+///\n+/// enum ExprType {\n+///   ScalarType(DataType),\n+///   ArrayType(DataType),\n+///   TableType(Schema),\n+/// }\n+class ARROW_EXPORT ExprType : public util::EqualityComparable<ExprType> {\n+ public:\n+  enum Shape : uint8_t {\n+    // The expression yields a Scalar, e.g. \"1\".\n+    SCALAR,\n+    // The expression yields an Array, e.g. \"[1, 2, 3]\".\n+    ARRAY,\n+    // The expression yields a Table, e.g. \"{'a': [1, 2], 'b': [true, false]}\"\n+    TABLE,\n+  };\n+\n+  /// Construct a Scalar type.\n+  static ExprType Scalar(std::shared_ptr<DataType> type);\n+  /// Construct an Array type.\n+  static ExprType Array(std::shared_ptr<DataType> type);\n+  /// Construct a Table type.\n+  static ExprType Table(std::shared_ptr<Schema> schema);\n+\n+  /// \\brief Shape of the expression.\n+  Shape shape() const { return shape_; }\n+\n+  /// \\brief DataType of the expression if a scalar or an array.\n+  /// WARNING: You must ensure the proper shape before calling this accessor.\n+  const std::shared_ptr<DataType>& data_type() const { return data_type_; }\n+  /// \\brief Schema of the expression if of table shape.\n+  /// WARNING: You must ensure the proper shape before calling this accessor.\n+  const std::shared_ptr<Schema>& schema() const { return schema_; }\n+\n+  /// \\brief Indicate if the type is a Scalar.\n+  bool IsScalar() const { return shape_ == SCALAR; }\n+  /// \\brief Indicate if the type is an Array.\n+  bool IsArray() const { return shape_ == ARRAY; }\n+  /// \\brief Indicate if the type is a Table.\n+  bool IsTable() const { return shape_ == TABLE; }\n+\n+  template <Type::type TYPE_ID>\n+  bool IsTypedLike() const {\n+    return (IsScalar() || IsArray()) && data_type_->id() == TYPE_ID;\n+  }\n+\n+  /// \\brief Indicate if the type is a predicate, i.e. a boolean scalar.\n+  bool IsPredicate() const { return IsTypedLike<Type::BOOL>(); }\n+\n+  /// \\brief Cast to DataType/Schema if the shape allows it.\n+  Result<ExprType> CastTo(const std::shared_ptr<DataType>& data_type) const;\n+  Result<ExprType> CastTo(const std::shared_ptr<Schema>& schema) const;\n+\n+  /// \\brief Broadcasting align two types to the largest shape.\n+  ///\n+  /// \\param[in] lhs, first type to broadcast\n+  /// \\param[in] rhs, second type to broadcast\n+  /// \\return broadcasted type or an error why it can't be broadcasted.\n+  ///\n+  /// Broadcasting promotes the shape of the smallest type to the bigger one if\n+  /// they share the same DataType. In functional pattern matching it would look\n+  /// like:\n+  ///\n+  /// ```\n+  /// Broadcast(rhs, lhs) = match(lhs, rhs) {\n+  ///   case: ScalarType(t1), ScalarType(t2) if t1 == t2 => ScalarType(t)\n+  ///   case: ScalarType(t1), ArrayType(t2)  if t1 == t2 => ArrayType(t)\n+  ///   case: ArrayType(t1),  ScalarType(t2) if t1 == t2 => ArrayType(t)\n+  ///   case: ArrayType(t1),  ArrayType(t2)  if t1 == t2 => ArrayType(t)\n+  ///   case: _ => Error(\"Types not compatible for broadcasting\")\n+  /// }\n+  /// ```\n+  static Result<ExprType> Broadcast(const ExprType& lhs, const ExprType& rhs);\n+\n+  bool Equals(const ExprType& type) const;\n+\n+  std::string ToString() const;\n+\n+  ExprType(const ExprType& copy);\n+  ExprType(ExprType&& copy);\n+  ~ExprType();\n+\n+ private:\n+  /// Table constructor\n+  ExprType(std::shared_ptr<Schema> schema, Shape shape);\n+  /// Scalar or Array constructor\n+  ExprType(std::shared_ptr<DataType> type, Shape shape);\n+\n+  union {\n+    // Zero initialize the pointer or Copy/Assign constructors will fail.\n+    std::shared_ptr<DataType> data_type_{};\n+    std::shared_ptr<Schema> schema_;\n+  };\n+  Shape shape_;\n+};\n+\n+/// Represents an expression tree\n+class ARROW_EXPORT Expr : public util::EqualityComparable<Expr> {\n+ public:\n+  // Tag identifier for the expression type.\n+  enum Kind : uint8_t {\n+    // A Scalar literal, i.e. a constant.\n+    SCALAR_LITERAL,\n+    // A Field reference in a schema.\n+    FIELD_REFERENCE,\n+\n+    // Equal compare operator\n+    EQ_CMP_OP,\n+    // Not-Equal compare operator\n+    NE_CMP_OP,\n+    // Greater-Than compare operator\n+    GT_CMP_OP,\n+    // Greater-Equal-Than compare operator\n+    GE_CMP_OP,\n+    // Less-Than compare operator\n+    LT_CMP_OP,\n+    // Less-Equal-Than compare operator\n+    LE_CMP_OP,\n+\n+    // Empty relation with a known schema.\n+    EMPTY_REL,\n+    // Scan relational operator\n+    SCAN_REL,\n+    // Projection relational operator\n+    PROJECTION_REL,\n+    // Filter relational operator\n+    FILTER_REL,\n+  };\n+\n+  /// \\brief Return the kind of the expression.\n+  Kind kind() const { return kind_; }\n+  /// \\brief Return a string representation of the kind.\n+  std::string kind_name() const;\n+\n+  /// \\brief Return the type and shape of the resulting expression.\n+  const ExprType& type() const { return type_; }\n+\n+  /// \\brief Indicate if the expressions\n+  bool Equals(const Expr& other) const;\n+  using util::EqualityComparable<Expr>::Equals;\n+\n+  /// \\brief Return a string representing the expression\n+  std::string ToString() const;\n+\n+  virtual ~Expr() = default;\n+\n+ protected:\n+  explicit Expr(Kind kind, ExprType type) : type_(std::move(type)), kind_(kind) {}\n+\n+  ExprType type_;\n+  Kind kind_;\n+};\n+\n+// The following traits are used to break cycle between CRTP base classes and\n+// their derived counterparts to extract the Expr::Kind and other static\n+// properties from the forward declared class.\n+template <typename T>\n+struct expr_traits;\n+\n+template <>\n+struct expr_traits<ScalarExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::SCALAR_LITERAL;\n+};\n+\n+template <>\n+struct expr_traits<FieldRefExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::FIELD_REFERENCE;\n+};\n+\n+template <>\n+struct expr_traits<EqualCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::EQ_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<NotEqualCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::NE_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<GreaterThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::GT_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<GreaterEqualThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::GE_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<LessThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::LT_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<LessEqualThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::LE_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<EmptyRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::EMPTY_REL;\n+};\n+\n+template <>\n+struct expr_traits<ScanRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::SCAN_REL;\n+};\n+\n+template <>\n+struct expr_traits<ProjectionRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::PROJECTION_REL;\n+};\n+\n+template <>\n+struct expr_traits<FilterRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::FILTER_REL;\n+};\n+\n+//\n+// Value Expressions\n+//\n+\n+// An unnamed scalar literal expression.\n+class ARROW_EXPORT ScalarExpr : public Expr {\n+ public:\n+  static Result<std::shared_ptr<ScalarExpr>> Make(std::shared_ptr<Scalar> scalar);\n+\n+  const std::shared_ptr<Scalar>& scalar() const { return scalar_; }\n+\n+ private:\n+  explicit ScalarExpr(std::shared_ptr<Scalar> scalar);\n+\n+  std::shared_ptr<Scalar> scalar_;\n+};\n+\n+// References a column in a table/dataset\n+class ARROW_EXPORT FieldRefExpr : public Expr {\n+ public:\n+  static Result<std::shared_ptr<FieldRefExpr>> Make(std::shared_ptr<Field> field);\n+\n+  const std::shared_ptr<Field>& field() const { return field_; }\n+\n+ private:\n+  explicit FieldRefExpr(std::shared_ptr<Field> field);\n+\n+  std::shared_ptr<Field> field_;\n \n Review comment:\n   This will be replaced with the class in ARROW-7421.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-01T13:03:48.379+0000",
                    "updated": "2020-03-01T13:03:48.379+0000",
                    "started": "2020-03-01T13:03:48.379+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "395598",
                    "issueId": "13286025"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286025/worklog/395651",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on pull request #6506: ARROW-7878: [C++][Compute] Draft LogicalPlan classes\nURL: https://github.com/apache/arrow/pull/6506#discussion_r386127728\n \n \n\n ##########\n File path: cpp/src/arrow/engine/logical_plan_test.cc\n ##########\n @@ -0,0 +1,125 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <gmock/gmock.h>\n+\n+#include \"arrow/engine/catalog.h\"\n+#include \"arrow/engine/expression.h\"\n+#include \"arrow/engine/logical_plan.h\"\n+#include \"arrow/testing/gtest_common.h\"\n+\n+using testing::HasSubstr;\n+\n+namespace arrow {\n+namespace engine {\n+\n+using ResultExpr = LogicalPlanBuilder::ResultExpr;\n+\n+class LogicalPlanBuilderTest : public testing::Test {\n+ protected:\n+  void SetUp() override {\n+    CatalogBuilder catalog_builder;\n+    ASSERT_OK(catalog_builder.Add(table_1, MockTable(schema_1)));\n+    ASSERT_OK_AND_ASSIGN(options.catalog, catalog_builder.Finish());\n+    builder = LogicalPlanBuilder{options};\n+  }\n+\n+  ResultExpr scalar_expr() {\n+    auto forthy_two = MakeScalar(42);\n+    return builder.Scalar(forthy_two);\n+  }\n+\n+  ResultExpr scan_expr() { return builder.Scan(table_1); }\n+\n+  template <typename T>\n+  ResultExpr field_expr(T key, std::shared_ptr<Expr> input = nullptr) {\n+    if (input == nullptr) {\n+      ARROW_ASSIGN_OR_RAISE(input, scan_expr());\n+    }\n+    return builder.Field(input, key);\n+  }\n+\n+  ResultExpr predicate_expr() { return nullptr; }\n+\n+  std::string table_1 = \"table_1\";\n+  std::shared_ptr<Schema> schema_1 = schema({\n+      field(\"bool\", boolean()),\n+      field(\"i32\", int32()),\n+      field(\"u64\", uint64()),\n+      field(\"f32\", uint32()),\n \n Review comment:\n   This looks like a mismatch for the `f32` type?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-01T18:03:14.149+0000",
                    "updated": "2020-03-01T18:03:14.149+0000",
                    "started": "2020-03-01T18:03:14.148+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "395651",
                    "issueId": "13286025"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286025/worklog/395652",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on issue #6506: ARROW-7878: [C++][Compute] Draft LogicalPlan classes\nURL: https://github.com/apache/arrow/pull/6506#issuecomment-593126217\n \n \n   This is exciting! This may be the final motivation I need to start coding in C++ again.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-01T18:05:24.476+0000",
                    "updated": "2020-03-01T18:05:24.476+0000",
                    "started": "2020-03-01T18:05:24.475+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "395652",
                    "issueId": "13286025"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286025/worklog/396160",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on pull request #6506: ARROW-7878: [C++][Compute] Draft LogicalPlan classes\nURL: https://github.com/apache/arrow/pull/6506#discussion_r386462999\n \n \n\n ##########\n File path: cpp/src/arrow/engine/catalog.h\n ##########\n @@ -0,0 +1,94 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/variant.h\"\n+\n+namespace arrow {\n+\n+namespace dataset {\n+class Dataset;\n+}\n+\n+namespace engine {\n+\n+/// Catalog is made of named Table/Dataset to be referenced in LogicalPlans.\n+class Catalog {\n+ public:\n+  class Entry;\n+\n+  static Result<std::shared_ptr<Catalog>> Make(const std::vector<Entry>& tables);\n+\n+  Result<Entry> Get(const std::string& name) const;\n+  Result<std::shared_ptr<Schema>> GetSchema(const std::string& name) const;\n+\n+  class Entry {\n+   public:\n+    enum Kind {\n \n Review comment:\n   I think it would be enough to have a single kind of entry, only datasets.\r\n   In case of a table it would be an InMemoryDataset.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-02T15:30:45.080+0000",
                    "updated": "2020-03-02T15:30:45.080+0000",
                    "started": "2020-03-02T15:30:45.080+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "396160",
                    "issueId": "13286025"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286025/worklog/396191",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #6506: ARROW-7878: [C++][Compute] Draft LogicalPlan classes\nURL: https://github.com/apache/arrow/pull/6506#discussion_r386462777\n \n \n\n ##########\n File path: cpp/src/arrow/engine/expression.h\n ##########\n @@ -0,0 +1,490 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+\n+#include \"arrow/engine/catalog.h\"\n+#include \"arrow/engine/type_fwd.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/compare.h\"\n+#include \"arrow/util/variant.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+/// ExprType is a class representing the type of an Expression. The type is\n+/// composed of a shape and a DataType or a Schema depending on the shape.\n+///\n+/// ExprType is mainly used to validate arguments for operator expressions, e.g.\n+/// relational operator expressions expect inputs of Table shape.\n+///\n+/// The sum-type representation would be:\n+///\n+/// enum ExprType {\n+///   ScalarType(DataType),\n+///   ArrayType(DataType),\n+///   TableType(Schema),\n+/// }\n+class ARROW_EXPORT ExprType : public util::EqualityComparable<ExprType> {\n+ public:\n+  enum Shape : uint8_t {\n+    // The expression yields a Scalar, e.g. \"1\".\n+    SCALAR,\n+    // The expression yields an Array, e.g. \"[1, 2, 3]\".\n+    ARRAY,\n+    // The expression yields a Table, e.g. \"{'a': [1, 2], 'b': [true, false]}\"\n+    TABLE,\n+  };\n+\n+  /// Construct a Scalar type.\n+  static ExprType Scalar(std::shared_ptr<DataType> type);\n+  /// Construct an Array type.\n+  static ExprType Array(std::shared_ptr<DataType> type);\n+  /// Construct a Table type.\n+  static ExprType Table(std::shared_ptr<Schema> schema);\n+\n+  /// \\brief Shape of the expression.\n+  Shape shape() const { return shape_; }\n+\n+  /// \\brief DataType of the expression if a scalar or an array.\n+  /// WARNING: You must ensure the proper shape before calling this accessor.\n+  const std::shared_ptr<DataType>& data_type() const { return data_type_; }\n+  /// \\brief Schema of the expression if of table shape.\n+  /// WARNING: You must ensure the proper shape before calling this accessor.\n+  const std::shared_ptr<Schema>& schema() const { return schema_; }\n+\n+  /// \\brief Indicate if the type is a Scalar.\n+  bool IsScalar() const { return shape_ == SCALAR; }\n+  /// \\brief Indicate if the type is an Array.\n+  bool IsArray() const { return shape_ == ARRAY; }\n+  /// \\brief Indicate if the type is a Table.\n+  bool IsTable() const { return shape_ == TABLE; }\n+\n+  template <Type::type TYPE_ID>\n+  bool IsTypedLike() const {\n \n Review comment:\n   Why not pass the type_id as a runtime function argument?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-02T16:34:13.054+0000",
                    "updated": "2020-03-02T16:34:13.054+0000",
                    "started": "2020-03-02T16:34:13.053+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "396191",
                    "issueId": "13286025"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286025/worklog/396192",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #6506: ARROW-7878: [C++][Compute] Draft LogicalPlan classes\nURL: https://github.com/apache/arrow/pull/6506#discussion_r386464608\n \n \n\n ##########\n File path: cpp/src/arrow/engine/expression.h\n ##########\n @@ -0,0 +1,490 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+\n+#include \"arrow/engine/catalog.h\"\n+#include \"arrow/engine/type_fwd.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/compare.h\"\n+#include \"arrow/util/variant.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+/// ExprType is a class representing the type of an Expression. The type is\n+/// composed of a shape and a DataType or a Schema depending on the shape.\n+///\n+/// ExprType is mainly used to validate arguments for operator expressions, e.g.\n+/// relational operator expressions expect inputs of Table shape.\n+///\n+/// The sum-type representation would be:\n+///\n+/// enum ExprType {\n+///   ScalarType(DataType),\n+///   ArrayType(DataType),\n+///   TableType(Schema),\n+/// }\n+class ARROW_EXPORT ExprType : public util::EqualityComparable<ExprType> {\n+ public:\n+  enum Shape : uint8_t {\n+    // The expression yields a Scalar, e.g. \"1\".\n+    SCALAR,\n+    // The expression yields an Array, e.g. \"[1, 2, 3]\".\n+    ARRAY,\n+    // The expression yields a Table, e.g. \"{'a': [1, 2], 'b': [true, false]}\"\n+    TABLE,\n+  };\n+\n+  /// Construct a Scalar type.\n+  static ExprType Scalar(std::shared_ptr<DataType> type);\n+  /// Construct an Array type.\n+  static ExprType Array(std::shared_ptr<DataType> type);\n+  /// Construct a Table type.\n+  static ExprType Table(std::shared_ptr<Schema> schema);\n+\n+  /// \\brief Shape of the expression.\n+  Shape shape() const { return shape_; }\n+\n+  /// \\brief DataType of the expression if a scalar or an array.\n+  /// WARNING: You must ensure the proper shape before calling this accessor.\n+  const std::shared_ptr<DataType>& data_type() const { return data_type_; }\n+  /// \\brief Schema of the expression if of table shape.\n+  /// WARNING: You must ensure the proper shape before calling this accessor.\n+  const std::shared_ptr<Schema>& schema() const { return schema_; }\n+\n+  /// \\brief Indicate if the type is a Scalar.\n+  bool IsScalar() const { return shape_ == SCALAR; }\n+  /// \\brief Indicate if the type is an Array.\n+  bool IsArray() const { return shape_ == ARRAY; }\n+  /// \\brief Indicate if the type is a Table.\n+  bool IsTable() const { return shape_ == TABLE; }\n+\n+  template <Type::type TYPE_ID>\n+  bool IsTypedLike() const {\n+    return (IsScalar() || IsArray()) && data_type_->id() == TYPE_ID;\n+  }\n+\n+  /// \\brief Indicate if the type is a predicate, i.e. a boolean scalar.\n+  bool IsPredicate() const { return IsTypedLike<Type::BOOL>(); }\n+\n+  /// \\brief Cast to DataType/Schema if the shape allows it.\n+  Result<ExprType> CastTo(const std::shared_ptr<DataType>& data_type) const;\n+  Result<ExprType> CastTo(const std::shared_ptr<Schema>& schema) const;\n+\n+  /// \\brief Broadcasting align two types to the largest shape.\n+  ///\n+  /// \\param[in] lhs, first type to broadcast\n+  /// \\param[in] rhs, second type to broadcast\n+  /// \\return broadcasted type or an error why it can't be broadcasted.\n+  ///\n+  /// Broadcasting promotes the shape of the smallest type to the bigger one if\n+  /// they share the same DataType. In functional pattern matching it would look\n+  /// like:\n+  ///\n+  /// ```\n+  /// Broadcast(rhs, lhs) = match(lhs, rhs) {\n+  ///   case: ScalarType(t1), ScalarType(t2) if t1 == t2 => ScalarType(t)\n+  ///   case: ScalarType(t1), ArrayType(t2)  if t1 == t2 => ArrayType(t)\n+  ///   case: ArrayType(t1),  ScalarType(t2) if t1 == t2 => ArrayType(t)\n+  ///   case: ArrayType(t1),  ArrayType(t2)  if t1 == t2 => ArrayType(t)\n+  ///   case: _ => Error(\"Types not compatible for broadcasting\")\n+  /// }\n+  /// ```\n+  static Result<ExprType> Broadcast(const ExprType& lhs, const ExprType& rhs);\n+\n+  bool Equals(const ExprType& type) const;\n+\n+  std::string ToString() const;\n+\n+  ExprType(const ExprType& copy);\n+  ExprType(ExprType&& copy);\n+  ~ExprType();\n+\n+ private:\n+  /// Table constructor\n+  ExprType(std::shared_ptr<Schema> schema, Shape shape);\n+  /// Scalar or Array constructor\n+  ExprType(std::shared_ptr<DataType> type, Shape shape);\n+\n+  union {\n+    // Zero initialize the pointer or Copy/Assign constructors will fail.\n \n Review comment:\n   Hmm, doesn't `shared_ptr` zero-initialize by default? Or is that a `union` quirk?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-02T16:34:13.059+0000",
                    "updated": "2020-03-02T16:34:13.059+0000",
                    "started": "2020-03-02T16:34:13.059+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "396192",
                    "issueId": "13286025"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286025/worklog/396193",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #6506: ARROW-7878: [C++][Compute] Draft LogicalPlan classes\nURL: https://github.com/apache/arrow/pull/6506#discussion_r386467969\n \n \n\n ##########\n File path: cpp/src/arrow/engine/expression.h\n ##########\n @@ -0,0 +1,490 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+\n+#include \"arrow/engine/catalog.h\"\n+#include \"arrow/engine/type_fwd.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/compare.h\"\n+#include \"arrow/util/variant.h\"\n \n Review comment:\n   Unused?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-02T16:34:13.218+0000",
                    "updated": "2020-03-02T16:34:13.218+0000",
                    "started": "2020-03-02T16:34:13.218+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "396193",
                    "issueId": "13286025"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286025/worklog/396194",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #6506: ARROW-7878: [C++][Compute] Draft LogicalPlan classes\nURL: https://github.com/apache/arrow/pull/6506#discussion_r386467195\n \n \n\n ##########\n File path: cpp/src/arrow/engine/expression.h\n ##########\n @@ -0,0 +1,490 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+\n+#include \"arrow/engine/catalog.h\"\n+#include \"arrow/engine/type_fwd.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/compare.h\"\n+#include \"arrow/util/variant.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+/// ExprType is a class representing the type of an Expression. The type is\n+/// composed of a shape and a DataType or a Schema depending on the shape.\n+///\n+/// ExprType is mainly used to validate arguments for operator expressions, e.g.\n+/// relational operator expressions expect inputs of Table shape.\n+///\n+/// The sum-type representation would be:\n+///\n+/// enum ExprType {\n+///   ScalarType(DataType),\n+///   ArrayType(DataType),\n+///   TableType(Schema),\n+/// }\n+class ARROW_EXPORT ExprType : public util::EqualityComparable<ExprType> {\n+ public:\n+  enum Shape : uint8_t {\n+    // The expression yields a Scalar, e.g. \"1\".\n+    SCALAR,\n+    // The expression yields an Array, e.g. \"[1, 2, 3]\".\n+    ARRAY,\n+    // The expression yields a Table, e.g. \"{'a': [1, 2], 'b': [true, false]}\"\n+    TABLE,\n+  };\n+\n+  /// Construct a Scalar type.\n+  static ExprType Scalar(std::shared_ptr<DataType> type);\n+  /// Construct an Array type.\n+  static ExprType Array(std::shared_ptr<DataType> type);\n+  /// Construct a Table type.\n+  static ExprType Table(std::shared_ptr<Schema> schema);\n+\n+  /// \\brief Shape of the expression.\n+  Shape shape() const { return shape_; }\n+\n+  /// \\brief DataType of the expression if a scalar or an array.\n+  /// WARNING: You must ensure the proper shape before calling this accessor.\n+  const std::shared_ptr<DataType>& data_type() const { return data_type_; }\n+  /// \\brief Schema of the expression if of table shape.\n+  /// WARNING: You must ensure the proper shape before calling this accessor.\n+  const std::shared_ptr<Schema>& schema() const { return schema_; }\n+\n+  /// \\brief Indicate if the type is a Scalar.\n+  bool IsScalar() const { return shape_ == SCALAR; }\n+  /// \\brief Indicate if the type is an Array.\n+  bool IsArray() const { return shape_ == ARRAY; }\n+  /// \\brief Indicate if the type is a Table.\n+  bool IsTable() const { return shape_ == TABLE; }\n+\n+  template <Type::type TYPE_ID>\n+  bool IsTypedLike() const {\n+    return (IsScalar() || IsArray()) && data_type_->id() == TYPE_ID;\n+  }\n+\n+  /// \\brief Indicate if the type is a predicate, i.e. a boolean scalar.\n+  bool IsPredicate() const { return IsTypedLike<Type::BOOL>(); }\n+\n+  /// \\brief Cast to DataType/Schema if the shape allows it.\n+  Result<ExprType> CastTo(const std::shared_ptr<DataType>& data_type) const;\n+  Result<ExprType> CastTo(const std::shared_ptr<Schema>& schema) const;\n+\n+  /// \\brief Broadcasting align two types to the largest shape.\n+  ///\n+  /// \\param[in] lhs, first type to broadcast\n+  /// \\param[in] rhs, second type to broadcast\n+  /// \\return broadcasted type or an error why it can't be broadcasted.\n+  ///\n+  /// Broadcasting promotes the shape of the smallest type to the bigger one if\n+  /// they share the same DataType. In functional pattern matching it would look\n+  /// like:\n+  ///\n+  /// ```\n+  /// Broadcast(rhs, lhs) = match(lhs, rhs) {\n+  ///   case: ScalarType(t1), ScalarType(t2) if t1 == t2 => ScalarType(t)\n+  ///   case: ScalarType(t1), ArrayType(t2)  if t1 == t2 => ArrayType(t)\n+  ///   case: ArrayType(t1),  ScalarType(t2) if t1 == t2 => ArrayType(t)\n+  ///   case: ArrayType(t1),  ArrayType(t2)  if t1 == t2 => ArrayType(t)\n+  ///   case: _ => Error(\"Types not compatible for broadcasting\")\n+  /// }\n+  /// ```\n+  static Result<ExprType> Broadcast(const ExprType& lhs, const ExprType& rhs);\n+\n+  bool Equals(const ExprType& type) const;\n+\n+  std::string ToString() const;\n+\n+  ExprType(const ExprType& copy);\n+  ExprType(ExprType&& copy);\n+  ~ExprType();\n+\n+ private:\n+  /// Table constructor\n+  ExprType(std::shared_ptr<Schema> schema, Shape shape);\n+  /// Scalar or Array constructor\n+  ExprType(std::shared_ptr<DataType> type, Shape shape);\n+\n+  union {\n+    // Zero initialize the pointer or Copy/Assign constructors will fail.\n+    std::shared_ptr<DataType> data_type_{};\n+    std::shared_ptr<Schema> schema_;\n+  };\n+  Shape shape_;\n+};\n+\n+/// Represents an expression tree\n+class ARROW_EXPORT Expr : public util::EqualityComparable<Expr> {\n+ public:\n+  // Tag identifier for the expression type.\n+  enum Kind : uint8_t {\n+    // A Scalar literal, i.e. a constant.\n+    SCALAR_LITERAL,\n+    // A Field reference in a schema.\n+    FIELD_REFERENCE,\n+\n+    // Equal compare operator\n+    EQ_CMP_OP,\n+    // Not-Equal compare operator\n+    NE_CMP_OP,\n+    // Greater-Than compare operator\n+    GT_CMP_OP,\n+    // Greater-Equal-Than compare operator\n+    GE_CMP_OP,\n+    // Less-Than compare operator\n+    LT_CMP_OP,\n+    // Less-Equal-Than compare operator\n+    LE_CMP_OP,\n+\n+    // Empty relation with a known schema.\n+    EMPTY_REL,\n+    // Scan relational operator\n+    SCAN_REL,\n+    // Projection relational operator\n+    PROJECTION_REL,\n+    // Filter relational operator\n+    FILTER_REL,\n+  };\n+\n+  /// \\brief Return the kind of the expression.\n+  Kind kind() const { return kind_; }\n+  /// \\brief Return a string representation of the kind.\n+  std::string kind_name() const;\n+\n+  /// \\brief Return the type and shape of the resulting expression.\n+  const ExprType& type() const { return type_; }\n+\n+  /// \\brief Indicate if the expressions\n \n Review comment:\n   The end of the sentence seems to be missing.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-02T16:34:13.402+0000",
                    "updated": "2020-03-02T16:34:13.402+0000",
                    "started": "2020-03-02T16:34:13.402+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "396194",
                    "issueId": "13286025"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286025/worklog/396195",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #6506: ARROW-7878: [C++][Compute] Draft LogicalPlan classes\nURL: https://github.com/apache/arrow/pull/6506#discussion_r386465572\n \n \n\n ##########\n File path: cpp/src/arrow/engine/expression.h\n ##########\n @@ -0,0 +1,490 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+\n+#include \"arrow/engine/catalog.h\"\n+#include \"arrow/engine/type_fwd.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/compare.h\"\n+#include \"arrow/util/variant.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+/// ExprType is a class representing the type of an Expression. The type is\n+/// composed of a shape and a DataType or a Schema depending on the shape.\n+///\n+/// ExprType is mainly used to validate arguments for operator expressions, e.g.\n+/// relational operator expressions expect inputs of Table shape.\n+///\n+/// The sum-type representation would be:\n+///\n+/// enum ExprType {\n+///   ScalarType(DataType),\n+///   ArrayType(DataType),\n+///   TableType(Schema),\n+/// }\n+class ARROW_EXPORT ExprType : public util::EqualityComparable<ExprType> {\n+ public:\n+  enum Shape : uint8_t {\n+    // The expression yields a Scalar, e.g. \"1\".\n+    SCALAR,\n+    // The expression yields an Array, e.g. \"[1, 2, 3]\".\n+    ARRAY,\n+    // The expression yields a Table, e.g. \"{'a': [1, 2], 'b': [true, false]}\"\n+    TABLE,\n+  };\n+\n+  /// Construct a Scalar type.\n+  static ExprType Scalar(std::shared_ptr<DataType> type);\n+  /// Construct an Array type.\n+  static ExprType Array(std::shared_ptr<DataType> type);\n+  /// Construct a Table type.\n+  static ExprType Table(std::shared_ptr<Schema> schema);\n+\n+  /// \\brief Shape of the expression.\n+  Shape shape() const { return shape_; }\n+\n+  /// \\brief DataType of the expression if a scalar or an array.\n+  /// WARNING: You must ensure the proper shape before calling this accessor.\n+  const std::shared_ptr<DataType>& data_type() const { return data_type_; }\n+  /// \\brief Schema of the expression if of table shape.\n+  /// WARNING: You must ensure the proper shape before calling this accessor.\n+  const std::shared_ptr<Schema>& schema() const { return schema_; }\n+\n+  /// \\brief Indicate if the type is a Scalar.\n+  bool IsScalar() const { return shape_ == SCALAR; }\n+  /// \\brief Indicate if the type is an Array.\n+  bool IsArray() const { return shape_ == ARRAY; }\n+  /// \\brief Indicate if the type is a Table.\n+  bool IsTable() const { return shape_ == TABLE; }\n+\n+  template <Type::type TYPE_ID>\n+  bool IsTypedLike() const {\n+    return (IsScalar() || IsArray()) && data_type_->id() == TYPE_ID;\n+  }\n+\n+  /// \\brief Indicate if the type is a predicate, i.e. a boolean scalar.\n+  bool IsPredicate() const { return IsTypedLike<Type::BOOL>(); }\n+\n+  /// \\brief Cast to DataType/Schema if the shape allows it.\n+  Result<ExprType> CastTo(const std::shared_ptr<DataType>& data_type) const;\n+  Result<ExprType> CastTo(const std::shared_ptr<Schema>& schema) const;\n+\n+  /// \\brief Broadcasting align two types to the largest shape.\n+  ///\n+  /// \\param[in] lhs, first type to broadcast\n+  /// \\param[in] rhs, second type to broadcast\n+  /// \\return broadcasted type or an error why it can't be broadcasted.\n+  ///\n+  /// Broadcasting promotes the shape of the smallest type to the bigger one if\n+  /// they share the same DataType. In functional pattern matching it would look\n+  /// like:\n+  ///\n+  /// ```\n+  /// Broadcast(rhs, lhs) = match(lhs, rhs) {\n+  ///   case: ScalarType(t1), ScalarType(t2) if t1 == t2 => ScalarType(t)\n+  ///   case: ScalarType(t1), ArrayType(t2)  if t1 == t2 => ArrayType(t)\n+  ///   case: ArrayType(t1),  ScalarType(t2) if t1 == t2 => ArrayType(t)\n+  ///   case: ArrayType(t1),  ArrayType(t2)  if t1 == t2 => ArrayType(t)\n+  ///   case: _ => Error(\"Types not compatible for broadcasting\")\n+  /// }\n+  /// ```\n+  static Result<ExprType> Broadcast(const ExprType& lhs, const ExprType& rhs);\n+\n+  bool Equals(const ExprType& type) const;\n+\n+  std::string ToString() const;\n+\n+  ExprType(const ExprType& copy);\n+  ExprType(ExprType&& copy);\n+  ~ExprType();\n+\n+ private:\n+  /// Table constructor\n+  ExprType(std::shared_ptr<Schema> schema, Shape shape);\n+  /// Scalar or Array constructor\n+  ExprType(std::shared_ptr<DataType> type, Shape shape);\n+\n+  union {\n+    // Zero initialize the pointer or Copy/Assign constructors will fail.\n+    std::shared_ptr<DataType> data_type_{};\n+    std::shared_ptr<Schema> schema_;\n+  };\n+  Shape shape_;\n+};\n+\n+/// Represents an expression tree\n+class ARROW_EXPORT Expr : public util::EqualityComparable<Expr> {\n+ public:\n+  // Tag identifier for the expression type.\n+  enum Kind : uint8_t {\n+    // A Scalar literal, i.e. a constant.\n+    SCALAR_LITERAL,\n+    // A Field reference in a schema.\n+    FIELD_REFERENCE,\n+\n+    // Equal compare operator\n+    EQ_CMP_OP,\n+    // Not-Equal compare operator\n+    NE_CMP_OP,\n+    // Greater-Than compare operator\n+    GT_CMP_OP,\n+    // Greater-Equal-Than compare operator\n+    GE_CMP_OP,\n+    // Less-Than compare operator\n+    LT_CMP_OP,\n+    // Less-Equal-Than compare operator\n+    LE_CMP_OP,\n \n Review comment:\n   There could be many comparison operators, it is worth enumerating them all there or having a single catch-call `COMPARE_OP` item?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-02T16:34:13.730+0000",
                    "updated": "2020-03-02T16:34:13.730+0000",
                    "started": "2020-03-02T16:34:13.730+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "396195",
                    "issueId": "13286025"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286025/worklog/396196",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #6506: ARROW-7878: [C++][Compute] Draft LogicalPlan classes\nURL: https://github.com/apache/arrow/pull/6506#discussion_r386469224\n \n \n\n ##########\n File path: cpp/src/arrow/engine/expression.h\n ##########\n @@ -0,0 +1,490 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+\n+#include \"arrow/engine/catalog.h\"\n+#include \"arrow/engine/type_fwd.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/compare.h\"\n+#include \"arrow/util/variant.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+/// ExprType is a class representing the type of an Expression. The type is\n+/// composed of a shape and a DataType or a Schema depending on the shape.\n+///\n+/// ExprType is mainly used to validate arguments for operator expressions, e.g.\n+/// relational operator expressions expect inputs of Table shape.\n+///\n+/// The sum-type representation would be:\n+///\n+/// enum ExprType {\n+///   ScalarType(DataType),\n+///   ArrayType(DataType),\n+///   TableType(Schema),\n+/// }\n+class ARROW_EXPORT ExprType : public util::EqualityComparable<ExprType> {\n+ public:\n+  enum Shape : uint8_t {\n+    // The expression yields a Scalar, e.g. \"1\".\n+    SCALAR,\n+    // The expression yields an Array, e.g. \"[1, 2, 3]\".\n+    ARRAY,\n+    // The expression yields a Table, e.g. \"{'a': [1, 2], 'b': [true, false]}\"\n+    TABLE,\n+  };\n+\n+  /// Construct a Scalar type.\n+  static ExprType Scalar(std::shared_ptr<DataType> type);\n+  /// Construct an Array type.\n+  static ExprType Array(std::shared_ptr<DataType> type);\n+  /// Construct a Table type.\n+  static ExprType Table(std::shared_ptr<Schema> schema);\n+\n+  /// \\brief Shape of the expression.\n+  Shape shape() const { return shape_; }\n+\n+  /// \\brief DataType of the expression if a scalar or an array.\n+  /// WARNING: You must ensure the proper shape before calling this accessor.\n+  const std::shared_ptr<DataType>& data_type() const { return data_type_; }\n+  /// \\brief Schema of the expression if of table shape.\n+  /// WARNING: You must ensure the proper shape before calling this accessor.\n+  const std::shared_ptr<Schema>& schema() const { return schema_; }\n+\n+  /// \\brief Indicate if the type is a Scalar.\n+  bool IsScalar() const { return shape_ == SCALAR; }\n+  /// \\brief Indicate if the type is an Array.\n+  bool IsArray() const { return shape_ == ARRAY; }\n+  /// \\brief Indicate if the type is a Table.\n+  bool IsTable() const { return shape_ == TABLE; }\n+\n+  template <Type::type TYPE_ID>\n+  bool IsTypedLike() const {\n+    return (IsScalar() || IsArray()) && data_type_->id() == TYPE_ID;\n+  }\n+\n+  /// \\brief Indicate if the type is a predicate, i.e. a boolean scalar.\n+  bool IsPredicate() const { return IsTypedLike<Type::BOOL>(); }\n+\n+  /// \\brief Cast to DataType/Schema if the shape allows it.\n+  Result<ExprType> CastTo(const std::shared_ptr<DataType>& data_type) const;\n+  Result<ExprType> CastTo(const std::shared_ptr<Schema>& schema) const;\n+\n+  /// \\brief Broadcasting align two types to the largest shape.\n+  ///\n+  /// \\param[in] lhs, first type to broadcast\n+  /// \\param[in] rhs, second type to broadcast\n+  /// \\return broadcasted type or an error why it can't be broadcasted.\n+  ///\n+  /// Broadcasting promotes the shape of the smallest type to the bigger one if\n+  /// they share the same DataType. In functional pattern matching it would look\n+  /// like:\n+  ///\n+  /// ```\n+  /// Broadcast(rhs, lhs) = match(lhs, rhs) {\n+  ///   case: ScalarType(t1), ScalarType(t2) if t1 == t2 => ScalarType(t)\n+  ///   case: ScalarType(t1), ArrayType(t2)  if t1 == t2 => ArrayType(t)\n+  ///   case: ArrayType(t1),  ScalarType(t2) if t1 == t2 => ArrayType(t)\n+  ///   case: ArrayType(t1),  ArrayType(t2)  if t1 == t2 => ArrayType(t)\n+  ///   case: _ => Error(\"Types not compatible for broadcasting\")\n+  /// }\n+  /// ```\n+  static Result<ExprType> Broadcast(const ExprType& lhs, const ExprType& rhs);\n+\n+  bool Equals(const ExprType& type) const;\n+\n+  std::string ToString() const;\n+\n+  ExprType(const ExprType& copy);\n+  ExprType(ExprType&& copy);\n+  ~ExprType();\n+\n+ private:\n+  /// Table constructor\n+  ExprType(std::shared_ptr<Schema> schema, Shape shape);\n+  /// Scalar or Array constructor\n+  ExprType(std::shared_ptr<DataType> type, Shape shape);\n+\n+  union {\n+    // Zero initialize the pointer or Copy/Assign constructors will fail.\n+    std::shared_ptr<DataType> data_type_{};\n+    std::shared_ptr<Schema> schema_;\n+  };\n+  Shape shape_;\n+};\n+\n+/// Represents an expression tree\n+class ARROW_EXPORT Expr : public util::EqualityComparable<Expr> {\n+ public:\n+  // Tag identifier for the expression type.\n+  enum Kind : uint8_t {\n+    // A Scalar literal, i.e. a constant.\n+    SCALAR_LITERAL,\n+    // A Field reference in a schema.\n+    FIELD_REFERENCE,\n+\n+    // Equal compare operator\n+    EQ_CMP_OP,\n+    // Not-Equal compare operator\n+    NE_CMP_OP,\n+    // Greater-Than compare operator\n+    GT_CMP_OP,\n+    // Greater-Equal-Than compare operator\n+    GE_CMP_OP,\n+    // Less-Than compare operator\n+    LT_CMP_OP,\n+    // Less-Equal-Than compare operator\n+    LE_CMP_OP,\n+\n+    // Empty relation with a known schema.\n+    EMPTY_REL,\n+    // Scan relational operator\n+    SCAN_REL,\n+    // Projection relational operator\n+    PROJECTION_REL,\n+    // Filter relational operator\n+    FILTER_REL,\n+  };\n+\n+  /// \\brief Return the kind of the expression.\n+  Kind kind() const { return kind_; }\n+  /// \\brief Return a string representation of the kind.\n+  std::string kind_name() const;\n+\n+  /// \\brief Return the type and shape of the resulting expression.\n+  const ExprType& type() const { return type_; }\n+\n+  /// \\brief Indicate if the expressions\n+  bool Equals(const Expr& other) const;\n+  using util::EqualityComparable<Expr>::Equals;\n+\n+  /// \\brief Return a string representing the expression\n+  std::string ToString() const;\n+\n+  virtual ~Expr() = default;\n+\n+ protected:\n+  explicit Expr(Kind kind, ExprType type) : type_(std::move(type)), kind_(kind) {}\n+\n+  ExprType type_;\n+  Kind kind_;\n+};\n+\n+// The following traits are used to break cycle between CRTP base classes and\n+// their derived counterparts to extract the Expr::Kind and other static\n+// properties from the forward declared class.\n+template <typename T>\n+struct expr_traits;\n+\n+template <>\n+struct expr_traits<ScalarExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::SCALAR_LITERAL;\n+};\n+\n+template <>\n+struct expr_traits<FieldRefExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::FIELD_REFERENCE;\n+};\n+\n+template <>\n+struct expr_traits<EqualCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::EQ_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<NotEqualCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::NE_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<GreaterThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::GT_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<GreaterEqualThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::GE_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<LessThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::LT_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<LessEqualThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::LE_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<EmptyRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::EMPTY_REL;\n+};\n+\n+template <>\n+struct expr_traits<ScanRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::SCAN_REL;\n+};\n+\n+template <>\n+struct expr_traits<ProjectionRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::PROJECTION_REL;\n+};\n+\n+template <>\n+struct expr_traits<FilterRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::FILTER_REL;\n+};\n+\n+//\n+// Value Expressions\n+//\n+\n+// An unnamed scalar literal expression.\n+class ARROW_EXPORT ScalarExpr : public Expr {\n+ public:\n+  static Result<std::shared_ptr<ScalarExpr>> Make(std::shared_ptr<Scalar> scalar);\n+\n+  const std::shared_ptr<Scalar>& scalar() const { return scalar_; }\n+\n+ private:\n+  explicit ScalarExpr(std::shared_ptr<Scalar> scalar);\n+\n+  std::shared_ptr<Scalar> scalar_;\n+};\n+\n+// References a column in a table/dataset\n+class ARROW_EXPORT FieldRefExpr : public Expr {\n+ public:\n+  static Result<std::shared_ptr<FieldRefExpr>> Make(std::shared_ptr<Field> field);\n+\n+  const std::shared_ptr<Field>& field() const { return field_; }\n+\n+ private:\n+  explicit FieldRefExpr(std::shared_ptr<Field> field);\n+\n+  std::shared_ptr<Field> field_;\n+};\n+\n+//\n+// Operator expressions\n+//\n+\n+class ARROW_EXPORT UnaryOpExpr {\n \n Review comment:\n   \"UnaryOpExprMixin\", if it doesn't derive from Expr?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-02T16:34:13.785+0000",
                    "updated": "2020-03-02T16:34:13.785+0000",
                    "started": "2020-03-02T16:34:13.785+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "396196",
                    "issueId": "13286025"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286025/worklog/396197",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #6506: ARROW-7878: [C++][Compute] Draft LogicalPlan classes\nURL: https://github.com/apache/arrow/pull/6506#discussion_r386463302\n \n \n\n ##########\n File path: cpp/src/arrow/engine/expression.h\n ##########\n @@ -0,0 +1,490 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+\n+#include \"arrow/engine/catalog.h\"\n+#include \"arrow/engine/type_fwd.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/compare.h\"\n+#include \"arrow/util/variant.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+/// ExprType is a class representing the type of an Expression. The type is\n+/// composed of a shape and a DataType or a Schema depending on the shape.\n+///\n+/// ExprType is mainly used to validate arguments for operator expressions, e.g.\n+/// relational operator expressions expect inputs of Table shape.\n+///\n+/// The sum-type representation would be:\n+///\n+/// enum ExprType {\n+///   ScalarType(DataType),\n+///   ArrayType(DataType),\n+///   TableType(Schema),\n+/// }\n+class ARROW_EXPORT ExprType : public util::EqualityComparable<ExprType> {\n+ public:\n+  enum Shape : uint8_t {\n+    // The expression yields a Scalar, e.g. \"1\".\n+    SCALAR,\n+    // The expression yields an Array, e.g. \"[1, 2, 3]\".\n+    ARRAY,\n+    // The expression yields a Table, e.g. \"{'a': [1, 2], 'b': [true, false]}\"\n+    TABLE,\n+  };\n+\n+  /// Construct a Scalar type.\n+  static ExprType Scalar(std::shared_ptr<DataType> type);\n+  /// Construct an Array type.\n+  static ExprType Array(std::shared_ptr<DataType> type);\n+  /// Construct a Table type.\n+  static ExprType Table(std::shared_ptr<Schema> schema);\n+\n+  /// \\brief Shape of the expression.\n+  Shape shape() const { return shape_; }\n+\n+  /// \\brief DataType of the expression if a scalar or an array.\n+  /// WARNING: You must ensure the proper shape before calling this accessor.\n+  const std::shared_ptr<DataType>& data_type() const { return data_type_; }\n+  /// \\brief Schema of the expression if of table shape.\n+  /// WARNING: You must ensure the proper shape before calling this accessor.\n+  const std::shared_ptr<Schema>& schema() const { return schema_; }\n+\n+  /// \\brief Indicate if the type is a Scalar.\n+  bool IsScalar() const { return shape_ == SCALAR; }\n+  /// \\brief Indicate if the type is an Array.\n+  bool IsArray() const { return shape_ == ARRAY; }\n+  /// \\brief Indicate if the type is a Table.\n+  bool IsTable() const { return shape_ == TABLE; }\n+\n+  template <Type::type TYPE_ID>\n+  bool IsTypedLike() const {\n+    return (IsScalar() || IsArray()) && data_type_->id() == TYPE_ID;\n+  }\n+\n+  /// \\brief Indicate if the type is a predicate, i.e. a boolean scalar.\n+  bool IsPredicate() const { return IsTypedLike<Type::BOOL>(); }\n+\n+  /// \\brief Cast to DataType/Schema if the shape allows it.\n+  Result<ExprType> CastTo(const std::shared_ptr<DataType>& data_type) const;\n+  Result<ExprType> CastTo(const std::shared_ptr<Schema>& schema) const;\n+\n+  /// \\brief Broadcasting align two types to the largest shape.\n \n Review comment:\n   \"Broadcasting align\"?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-02T16:34:14.107+0000",
                    "updated": "2020-03-02T16:34:14.107+0000",
                    "started": "2020-03-02T16:34:14.107+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "396197",
                    "issueId": "13286025"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286025/worklog/396198",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #6506: ARROW-7878: [C++][Compute] Draft LogicalPlan classes\nURL: https://github.com/apache/arrow/pull/6506#discussion_r386469583\n \n \n\n ##########\n File path: cpp/src/arrow/engine/expression.h\n ##########\n @@ -0,0 +1,490 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+\n+#include \"arrow/engine/catalog.h\"\n+#include \"arrow/engine/type_fwd.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/compare.h\"\n+#include \"arrow/util/variant.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+/// ExprType is a class representing the type of an Expression. The type is\n+/// composed of a shape and a DataType or a Schema depending on the shape.\n+///\n+/// ExprType is mainly used to validate arguments for operator expressions, e.g.\n+/// relational operator expressions expect inputs of Table shape.\n+///\n+/// The sum-type representation would be:\n+///\n+/// enum ExprType {\n+///   ScalarType(DataType),\n+///   ArrayType(DataType),\n+///   TableType(Schema),\n+/// }\n+class ARROW_EXPORT ExprType : public util::EqualityComparable<ExprType> {\n+ public:\n+  enum Shape : uint8_t {\n+    // The expression yields a Scalar, e.g. \"1\".\n+    SCALAR,\n+    // The expression yields an Array, e.g. \"[1, 2, 3]\".\n+    ARRAY,\n+    // The expression yields a Table, e.g. \"{'a': [1, 2], 'b': [true, false]}\"\n+    TABLE,\n+  };\n+\n+  /// Construct a Scalar type.\n+  static ExprType Scalar(std::shared_ptr<DataType> type);\n+  /// Construct an Array type.\n+  static ExprType Array(std::shared_ptr<DataType> type);\n+  /// Construct a Table type.\n+  static ExprType Table(std::shared_ptr<Schema> schema);\n+\n+  /// \\brief Shape of the expression.\n+  Shape shape() const { return shape_; }\n+\n+  /// \\brief DataType of the expression if a scalar or an array.\n+  /// WARNING: You must ensure the proper shape before calling this accessor.\n+  const std::shared_ptr<DataType>& data_type() const { return data_type_; }\n+  /// \\brief Schema of the expression if of table shape.\n+  /// WARNING: You must ensure the proper shape before calling this accessor.\n+  const std::shared_ptr<Schema>& schema() const { return schema_; }\n+\n+  /// \\brief Indicate if the type is a Scalar.\n+  bool IsScalar() const { return shape_ == SCALAR; }\n+  /// \\brief Indicate if the type is an Array.\n+  bool IsArray() const { return shape_ == ARRAY; }\n+  /// \\brief Indicate if the type is a Table.\n+  bool IsTable() const { return shape_ == TABLE; }\n+\n+  template <Type::type TYPE_ID>\n+  bool IsTypedLike() const {\n+    return (IsScalar() || IsArray()) && data_type_->id() == TYPE_ID;\n+  }\n+\n+  /// \\brief Indicate if the type is a predicate, i.e. a boolean scalar.\n+  bool IsPredicate() const { return IsTypedLike<Type::BOOL>(); }\n+\n+  /// \\brief Cast to DataType/Schema if the shape allows it.\n+  Result<ExprType> CastTo(const std::shared_ptr<DataType>& data_type) const;\n+  Result<ExprType> CastTo(const std::shared_ptr<Schema>& schema) const;\n+\n+  /// \\brief Broadcasting align two types to the largest shape.\n+  ///\n+  /// \\param[in] lhs, first type to broadcast\n+  /// \\param[in] rhs, second type to broadcast\n+  /// \\return broadcasted type or an error why it can't be broadcasted.\n+  ///\n+  /// Broadcasting promotes the shape of the smallest type to the bigger one if\n+  /// they share the same DataType. In functional pattern matching it would look\n+  /// like:\n+  ///\n+  /// ```\n+  /// Broadcast(rhs, lhs) = match(lhs, rhs) {\n+  ///   case: ScalarType(t1), ScalarType(t2) if t1 == t2 => ScalarType(t)\n+  ///   case: ScalarType(t1), ArrayType(t2)  if t1 == t2 => ArrayType(t)\n+  ///   case: ArrayType(t1),  ScalarType(t2) if t1 == t2 => ArrayType(t)\n+  ///   case: ArrayType(t1),  ArrayType(t2)  if t1 == t2 => ArrayType(t)\n+  ///   case: _ => Error(\"Types not compatible for broadcasting\")\n+  /// }\n+  /// ```\n+  static Result<ExprType> Broadcast(const ExprType& lhs, const ExprType& rhs);\n+\n+  bool Equals(const ExprType& type) const;\n+\n+  std::string ToString() const;\n+\n+  ExprType(const ExprType& copy);\n+  ExprType(ExprType&& copy);\n+  ~ExprType();\n+\n+ private:\n+  /// Table constructor\n+  ExprType(std::shared_ptr<Schema> schema, Shape shape);\n+  /// Scalar or Array constructor\n+  ExprType(std::shared_ptr<DataType> type, Shape shape);\n+\n+  union {\n+    // Zero initialize the pointer or Copy/Assign constructors will fail.\n+    std::shared_ptr<DataType> data_type_{};\n+    std::shared_ptr<Schema> schema_;\n+  };\n+  Shape shape_;\n+};\n+\n+/// Represents an expression tree\n+class ARROW_EXPORT Expr : public util::EqualityComparable<Expr> {\n+ public:\n+  // Tag identifier for the expression type.\n+  enum Kind : uint8_t {\n+    // A Scalar literal, i.e. a constant.\n+    SCALAR_LITERAL,\n+    // A Field reference in a schema.\n+    FIELD_REFERENCE,\n+\n+    // Equal compare operator\n+    EQ_CMP_OP,\n+    // Not-Equal compare operator\n+    NE_CMP_OP,\n+    // Greater-Than compare operator\n+    GT_CMP_OP,\n+    // Greater-Equal-Than compare operator\n+    GE_CMP_OP,\n+    // Less-Than compare operator\n+    LT_CMP_OP,\n+    // Less-Equal-Than compare operator\n+    LE_CMP_OP,\n+\n+    // Empty relation with a known schema.\n+    EMPTY_REL,\n+    // Scan relational operator\n+    SCAN_REL,\n+    // Projection relational operator\n+    PROJECTION_REL,\n+    // Filter relational operator\n+    FILTER_REL,\n+  };\n+\n+  /// \\brief Return the kind of the expression.\n+  Kind kind() const { return kind_; }\n+  /// \\brief Return a string representation of the kind.\n+  std::string kind_name() const;\n+\n+  /// \\brief Return the type and shape of the resulting expression.\n+  const ExprType& type() const { return type_; }\n+\n+  /// \\brief Indicate if the expressions\n+  bool Equals(const Expr& other) const;\n+  using util::EqualityComparable<Expr>::Equals;\n+\n+  /// \\brief Return a string representing the expression\n+  std::string ToString() const;\n+\n+  virtual ~Expr() = default;\n+\n+ protected:\n+  explicit Expr(Kind kind, ExprType type) : type_(std::move(type)), kind_(kind) {}\n+\n+  ExprType type_;\n+  Kind kind_;\n+};\n+\n+// The following traits are used to break cycle between CRTP base classes and\n+// their derived counterparts to extract the Expr::Kind and other static\n+// properties from the forward declared class.\n+template <typename T>\n+struct expr_traits;\n+\n+template <>\n+struct expr_traits<ScalarExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::SCALAR_LITERAL;\n+};\n+\n+template <>\n+struct expr_traits<FieldRefExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::FIELD_REFERENCE;\n+};\n+\n+template <>\n+struct expr_traits<EqualCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::EQ_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<NotEqualCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::NE_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<GreaterThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::GT_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<GreaterEqualThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::GE_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<LessThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::LT_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<LessEqualThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::LE_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<EmptyRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::EMPTY_REL;\n+};\n+\n+template <>\n+struct expr_traits<ScanRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::SCAN_REL;\n+};\n+\n+template <>\n+struct expr_traits<ProjectionRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::PROJECTION_REL;\n+};\n+\n+template <>\n+struct expr_traits<FilterRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::FILTER_REL;\n+};\n+\n+//\n+// Value Expressions\n+//\n+\n+// An unnamed scalar literal expression.\n+class ARROW_EXPORT ScalarExpr : public Expr {\n+ public:\n+  static Result<std::shared_ptr<ScalarExpr>> Make(std::shared_ptr<Scalar> scalar);\n+\n+  const std::shared_ptr<Scalar>& scalar() const { return scalar_; }\n+\n+ private:\n+  explicit ScalarExpr(std::shared_ptr<Scalar> scalar);\n+\n+  std::shared_ptr<Scalar> scalar_;\n+};\n+\n+// References a column in a table/dataset\n+class ARROW_EXPORT FieldRefExpr : public Expr {\n+ public:\n+  static Result<std::shared_ptr<FieldRefExpr>> Make(std::shared_ptr<Field> field);\n+\n+  const std::shared_ptr<Field>& field() const { return field_; }\n+\n+ private:\n+  explicit FieldRefExpr(std::shared_ptr<Field> field);\n+\n+  std::shared_ptr<Field> field_;\n+};\n+\n+//\n+// Operator expressions\n+//\n+\n+class ARROW_EXPORT UnaryOpExpr {\n+ public:\n+  const std::shared_ptr<Expr>& operand() const { return operand_; }\n+\n+ protected:\n+  explicit UnaryOpExpr(std::shared_ptr<Expr> operand) : operand_(std::move(operand)) {}\n+\n+  std::shared_ptr<Expr> operand_;\n+};\n+\n+class ARROW_EXPORT BinaryOpExpr {\n+ public:\n+  const std::shared_ptr<Expr>& left_operand() const { return left_operand_; }\n+  const std::shared_ptr<Expr>& right_operand() const { return right_operand_; }\n+\n+ protected:\n+  BinaryOpExpr(std::shared_ptr<Expr> left, std::shared_ptr<Expr> right)\n+      : left_operand_(std::move(left)), right_operand_(std::move(right)) {}\n+\n+  std::shared_ptr<Expr> left_operand_;\n+  std::shared_ptr<Expr> right_operand_;\n+};\n+\n+class ARROW_EXPORT MultiAryOpExpr {\n+ public:\n+  const std::vector<std::shared_ptr<Expr>>& operands() const { return operands_; }\n+\n+ protected:\n+  explicit MultiAryOpExpr(std::vector<std::shared_ptr<Expr>> operands)\n+      : operands_(std::move(operands)) {}\n+\n+  std::vector<std::shared_ptr<Expr>> operands_;\n+};\n+\n+//\n+// Comparison expressions\n+//\n+\n+template <typename Self>\n \n Review comment:\n   \"typename Derived\"? \"Self\" is a bit confusing...\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-02T16:34:14.416+0000",
                    "updated": "2020-03-02T16:34:14.416+0000",
                    "started": "2020-03-02T16:34:14.416+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "396198",
                    "issueId": "13286025"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286025/worklog/396199",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #6506: ARROW-7878: [C++][Compute] Draft LogicalPlan classes\nURL: https://github.com/apache/arrow/pull/6506#discussion_r386473579\n \n \n\n ##########\n File path: cpp/src/arrow/engine/expression.h\n ##########\n @@ -0,0 +1,490 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+\n+#include \"arrow/engine/catalog.h\"\n+#include \"arrow/engine/type_fwd.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/compare.h\"\n+#include \"arrow/util/variant.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+/// ExprType is a class representing the type of an Expression. The type is\n+/// composed of a shape and a DataType or a Schema depending on the shape.\n+///\n+/// ExprType is mainly used to validate arguments for operator expressions, e.g.\n+/// relational operator expressions expect inputs of Table shape.\n+///\n+/// The sum-type representation would be:\n+///\n+/// enum ExprType {\n+///   ScalarType(DataType),\n+///   ArrayType(DataType),\n+///   TableType(Schema),\n+/// }\n+class ARROW_EXPORT ExprType : public util::EqualityComparable<ExprType> {\n+ public:\n+  enum Shape : uint8_t {\n+    // The expression yields a Scalar, e.g. \"1\".\n+    SCALAR,\n+    // The expression yields an Array, e.g. \"[1, 2, 3]\".\n+    ARRAY,\n+    // The expression yields a Table, e.g. \"{'a': [1, 2], 'b': [true, false]}\"\n+    TABLE,\n+  };\n+\n+  /// Construct a Scalar type.\n+  static ExprType Scalar(std::shared_ptr<DataType> type);\n+  /// Construct an Array type.\n+  static ExprType Array(std::shared_ptr<DataType> type);\n+  /// Construct a Table type.\n+  static ExprType Table(std::shared_ptr<Schema> schema);\n+\n+  /// \\brief Shape of the expression.\n+  Shape shape() const { return shape_; }\n+\n+  /// \\brief DataType of the expression if a scalar or an array.\n+  /// WARNING: You must ensure the proper shape before calling this accessor.\n+  const std::shared_ptr<DataType>& data_type() const { return data_type_; }\n+  /// \\brief Schema of the expression if of table shape.\n+  /// WARNING: You must ensure the proper shape before calling this accessor.\n+  const std::shared_ptr<Schema>& schema() const { return schema_; }\n+\n+  /// \\brief Indicate if the type is a Scalar.\n+  bool IsScalar() const { return shape_ == SCALAR; }\n+  /// \\brief Indicate if the type is an Array.\n+  bool IsArray() const { return shape_ == ARRAY; }\n+  /// \\brief Indicate if the type is a Table.\n+  bool IsTable() const { return shape_ == TABLE; }\n+\n+  template <Type::type TYPE_ID>\n+  bool IsTypedLike() const {\n+    return (IsScalar() || IsArray()) && data_type_->id() == TYPE_ID;\n+  }\n+\n+  /// \\brief Indicate if the type is a predicate, i.e. a boolean scalar.\n+  bool IsPredicate() const { return IsTypedLike<Type::BOOL>(); }\n+\n+  /// \\brief Cast to DataType/Schema if the shape allows it.\n+  Result<ExprType> CastTo(const std::shared_ptr<DataType>& data_type) const;\n+  Result<ExprType> CastTo(const std::shared_ptr<Schema>& schema) const;\n+\n+  /// \\brief Broadcasting align two types to the largest shape.\n+  ///\n+  /// \\param[in] lhs, first type to broadcast\n+  /// \\param[in] rhs, second type to broadcast\n+  /// \\return broadcasted type or an error why it can't be broadcasted.\n+  ///\n+  /// Broadcasting promotes the shape of the smallest type to the bigger one if\n+  /// they share the same DataType. In functional pattern matching it would look\n+  /// like:\n+  ///\n+  /// ```\n+  /// Broadcast(rhs, lhs) = match(lhs, rhs) {\n+  ///   case: ScalarType(t1), ScalarType(t2) if t1 == t2 => ScalarType(t)\n+  ///   case: ScalarType(t1), ArrayType(t2)  if t1 == t2 => ArrayType(t)\n+  ///   case: ArrayType(t1),  ScalarType(t2) if t1 == t2 => ArrayType(t)\n+  ///   case: ArrayType(t1),  ArrayType(t2)  if t1 == t2 => ArrayType(t)\n+  ///   case: _ => Error(\"Types not compatible for broadcasting\")\n+  /// }\n+  /// ```\n+  static Result<ExprType> Broadcast(const ExprType& lhs, const ExprType& rhs);\n+\n+  bool Equals(const ExprType& type) const;\n+\n+  std::string ToString() const;\n+\n+  ExprType(const ExprType& copy);\n+  ExprType(ExprType&& copy);\n+  ~ExprType();\n+\n+ private:\n+  /// Table constructor\n+  ExprType(std::shared_ptr<Schema> schema, Shape shape);\n+  /// Scalar or Array constructor\n+  ExprType(std::shared_ptr<DataType> type, Shape shape);\n+\n+  union {\n+    // Zero initialize the pointer or Copy/Assign constructors will fail.\n+    std::shared_ptr<DataType> data_type_{};\n+    std::shared_ptr<Schema> schema_;\n+  };\n+  Shape shape_;\n+};\n+\n+/// Represents an expression tree\n+class ARROW_EXPORT Expr : public util::EqualityComparable<Expr> {\n+ public:\n+  // Tag identifier for the expression type.\n+  enum Kind : uint8_t {\n+    // A Scalar literal, i.e. a constant.\n+    SCALAR_LITERAL,\n+    // A Field reference in a schema.\n+    FIELD_REFERENCE,\n+\n+    // Equal compare operator\n+    EQ_CMP_OP,\n+    // Not-Equal compare operator\n+    NE_CMP_OP,\n+    // Greater-Than compare operator\n+    GT_CMP_OP,\n+    // Greater-Equal-Than compare operator\n+    GE_CMP_OP,\n+    // Less-Than compare operator\n+    LT_CMP_OP,\n+    // Less-Equal-Than compare operator\n+    LE_CMP_OP,\n+\n+    // Empty relation with a known schema.\n+    EMPTY_REL,\n+    // Scan relational operator\n+    SCAN_REL,\n+    // Projection relational operator\n+    PROJECTION_REL,\n+    // Filter relational operator\n+    FILTER_REL,\n+  };\n+\n+  /// \\brief Return the kind of the expression.\n+  Kind kind() const { return kind_; }\n+  /// \\brief Return a string representation of the kind.\n+  std::string kind_name() const;\n+\n+  /// \\brief Return the type and shape of the resulting expression.\n+  const ExprType& type() const { return type_; }\n+\n+  /// \\brief Indicate if the expressions\n+  bool Equals(const Expr& other) const;\n+  using util::EqualityComparable<Expr>::Equals;\n+\n+  /// \\brief Return a string representing the expression\n+  std::string ToString() const;\n+\n+  virtual ~Expr() = default;\n+\n+ protected:\n+  explicit Expr(Kind kind, ExprType type) : type_(std::move(type)), kind_(kind) {}\n+\n+  ExprType type_;\n+  Kind kind_;\n+};\n+\n+// The following traits are used to break cycle between CRTP base classes and\n+// their derived counterparts to extract the Expr::Kind and other static\n+// properties from the forward declared class.\n+template <typename T>\n+struct expr_traits;\n+\n+template <>\n+struct expr_traits<ScalarExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::SCALAR_LITERAL;\n+};\n+\n+template <>\n+struct expr_traits<FieldRefExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::FIELD_REFERENCE;\n+};\n+\n+template <>\n+struct expr_traits<EqualCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::EQ_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<NotEqualCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::NE_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<GreaterThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::GT_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<GreaterEqualThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::GE_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<LessThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::LT_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<LessEqualThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::LE_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<EmptyRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::EMPTY_REL;\n+};\n+\n+template <>\n+struct expr_traits<ScanRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::SCAN_REL;\n+};\n+\n+template <>\n+struct expr_traits<ProjectionRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::PROJECTION_REL;\n+};\n+\n+template <>\n+struct expr_traits<FilterRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::FILTER_REL;\n+};\n+\n+//\n+// Value Expressions\n+//\n+\n+// An unnamed scalar literal expression.\n+class ARROW_EXPORT ScalarExpr : public Expr {\n+ public:\n+  static Result<std::shared_ptr<ScalarExpr>> Make(std::shared_ptr<Scalar> scalar);\n+\n+  const std::shared_ptr<Scalar>& scalar() const { return scalar_; }\n+\n+ private:\n+  explicit ScalarExpr(std::shared_ptr<Scalar> scalar);\n+\n+  std::shared_ptr<Scalar> scalar_;\n+};\n+\n+// References a column in a table/dataset\n+class ARROW_EXPORT FieldRefExpr : public Expr {\n+ public:\n+  static Result<std::shared_ptr<FieldRefExpr>> Make(std::shared_ptr<Field> field);\n+\n+  const std::shared_ptr<Field>& field() const { return field_; }\n+\n+ private:\n+  explicit FieldRefExpr(std::shared_ptr<Field> field);\n+\n+  std::shared_ptr<Field> field_;\n+};\n+\n+//\n+// Operator expressions\n+//\n+\n+class ARROW_EXPORT UnaryOpExpr {\n+ public:\n+  const std::shared_ptr<Expr>& operand() const { return operand_; }\n+\n+ protected:\n+  explicit UnaryOpExpr(std::shared_ptr<Expr> operand) : operand_(std::move(operand)) {}\n+\n+  std::shared_ptr<Expr> operand_;\n+};\n+\n+class ARROW_EXPORT BinaryOpExpr {\n+ public:\n+  const std::shared_ptr<Expr>& left_operand() const { return left_operand_; }\n+  const std::shared_ptr<Expr>& right_operand() const { return right_operand_; }\n+\n+ protected:\n+  BinaryOpExpr(std::shared_ptr<Expr> left, std::shared_ptr<Expr> right)\n+      : left_operand_(std::move(left)), right_operand_(std::move(right)) {}\n+\n+  std::shared_ptr<Expr> left_operand_;\n+  std::shared_ptr<Expr> right_operand_;\n+};\n+\n+class ARROW_EXPORT MultiAryOpExpr {\n+ public:\n+  const std::vector<std::shared_ptr<Expr>>& operands() const { return operands_; }\n+\n+ protected:\n+  explicit MultiAryOpExpr(std::vector<std::shared_ptr<Expr>> operands)\n+      : operands_(std::move(operands)) {}\n+\n+  std::vector<std::shared_ptr<Expr>> operands_;\n+};\n+\n+//\n+// Comparison expressions\n+//\n+\n+template <typename Self>\n+class ARROW_EXPORT CmpOpExpr : public BinaryOpExpr, public Expr {\n+ public:\n+  static Result<std::shared_ptr<Self>> Make(std::shared_ptr<Expr> left,\n+                                            std::shared_ptr<Expr> right) {\n+    if (left == NULLPTR || right == NULLPTR) {\n+      return Status::Invalid(\"Compare operands must be non-nulls\");\n+    }\n+\n+    // Broadcast ensures that types are compatible in shape and type.\n+    auto broadcast = ExprType::Broadcast(left->type(), right->type());\n+    // The type of comparison is always a boolean predicate.\n+    auto cast = [](const ExprType& t) { return t.CastTo(boolean()); };\n+    ARROW_ASSIGN_OR_RAISE(auto type, broadcast.Map(cast));\n+\n+    return std::shared_ptr<Self>(\n+        new Self(std::move(type), std::move(left), std::move(right)));\n+  }\n+\n+ protected:\n+  CmpOpExpr(ExprType type, std::shared_ptr<Expr> left, std::shared_ptr<Expr> right)\n+      : BinaryOpExpr(std::move(left), std::move(right)),\n+        Expr(expr_traits<Self>::kind_id, std::move(type)) {}\n+};\n+\n+class ARROW_EXPORT EqualCmpExpr : public CmpOpExpr<EqualCmpExpr> {\n+ protected:\n+  using CmpOpExpr<EqualCmpExpr>::CmpOpExpr;\n+};\n+\n+class ARROW_EXPORT NotEqualCmpExpr : public CmpOpExpr<NotEqualCmpExpr> {\n+ protected:\n+  using CmpOpExpr<NotEqualCmpExpr>::CmpOpExpr;\n+};\n+\n+class ARROW_EXPORT GreaterThanCmpExpr : public CmpOpExpr<GreaterThanCmpExpr> {\n+ protected:\n+  using CmpOpExpr<GreaterThanCmpExpr>::CmpOpExpr;\n+};\n+\n+class ARROW_EXPORT GreaterEqualThanCmpExpr : public CmpOpExpr<GreaterEqualThanCmpExpr> {\n+ protected:\n+  using CmpOpExpr<GreaterEqualThanCmpExpr>::CmpOpExpr;\n+};\n+\n+class ARROW_EXPORT LessThanCmpExpr : public CmpOpExpr<LessThanCmpExpr> {\n+ protected:\n+  using CmpOpExpr<LessThanCmpExpr>::CmpOpExpr;\n+};\n+\n+class ARROW_EXPORT LessEqualThanCmpExpr : public CmpOpExpr<LessEqualThanCmpExpr> {\n+ protected:\n+  using CmpOpExpr<LessEqualThanCmpExpr>::CmpOpExpr;\n+};\n+\n+//\n+// Relational Expressions\n+//\n+\n+template <typename Self>\n+class ARROW_EXPORT RelExpr : public Expr {\n+ public:\n+  const std::shared_ptr<Schema>& schema() const { return schema_; }\n+\n+ protected:\n+  explicit RelExpr(std::shared_ptr<Schema> schema)\n+      : Expr(expr_traits<Self>::kind_id, ExprType::Table(schema)),\n+        schema_(std::move(schema)) {}\n+\n+  std::shared_ptr<Schema> schema_;\n+};\n+\n+class ARROW_EXPORT EmptyRelExpr : public RelExpr<EmptyRelExpr> {\n \n Review comment:\n   Should add a docstring somewhere explaining what an empty relation is, and what its output type is.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-02T16:34:14.419+0000",
                    "updated": "2020-03-02T16:34:14.419+0000",
                    "started": "2020-03-02T16:34:14.419+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "396199",
                    "issueId": "13286025"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286025/worklog/396200",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #6506: ARROW-7878: [C++][Compute] Draft LogicalPlan classes\nURL: https://github.com/apache/arrow/pull/6506#discussion_r386471970\n \n \n\n ##########\n File path: cpp/src/arrow/engine/expression.h\n ##########\n @@ -0,0 +1,490 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+\n+#include \"arrow/engine/catalog.h\"\n+#include \"arrow/engine/type_fwd.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/compare.h\"\n+#include \"arrow/util/variant.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+/// ExprType is a class representing the type of an Expression. The type is\n+/// composed of a shape and a DataType or a Schema depending on the shape.\n+///\n+/// ExprType is mainly used to validate arguments for operator expressions, e.g.\n+/// relational operator expressions expect inputs of Table shape.\n+///\n+/// The sum-type representation would be:\n+///\n+/// enum ExprType {\n+///   ScalarType(DataType),\n+///   ArrayType(DataType),\n+///   TableType(Schema),\n+/// }\n+class ARROW_EXPORT ExprType : public util::EqualityComparable<ExprType> {\n+ public:\n+  enum Shape : uint8_t {\n+    // The expression yields a Scalar, e.g. \"1\".\n+    SCALAR,\n+    // The expression yields an Array, e.g. \"[1, 2, 3]\".\n+    ARRAY,\n+    // The expression yields a Table, e.g. \"{'a': [1, 2], 'b': [true, false]}\"\n+    TABLE,\n+  };\n+\n+  /// Construct a Scalar type.\n+  static ExprType Scalar(std::shared_ptr<DataType> type);\n+  /// Construct an Array type.\n+  static ExprType Array(std::shared_ptr<DataType> type);\n+  /// Construct a Table type.\n+  static ExprType Table(std::shared_ptr<Schema> schema);\n+\n+  /// \\brief Shape of the expression.\n+  Shape shape() const { return shape_; }\n+\n+  /// \\brief DataType of the expression if a scalar or an array.\n+  /// WARNING: You must ensure the proper shape before calling this accessor.\n+  const std::shared_ptr<DataType>& data_type() const { return data_type_; }\n+  /// \\brief Schema of the expression if of table shape.\n+  /// WARNING: You must ensure the proper shape before calling this accessor.\n+  const std::shared_ptr<Schema>& schema() const { return schema_; }\n+\n+  /// \\brief Indicate if the type is a Scalar.\n+  bool IsScalar() const { return shape_ == SCALAR; }\n+  /// \\brief Indicate if the type is an Array.\n+  bool IsArray() const { return shape_ == ARRAY; }\n+  /// \\brief Indicate if the type is a Table.\n+  bool IsTable() const { return shape_ == TABLE; }\n+\n+  template <Type::type TYPE_ID>\n+  bool IsTypedLike() const {\n+    return (IsScalar() || IsArray()) && data_type_->id() == TYPE_ID;\n+  }\n+\n+  /// \\brief Indicate if the type is a predicate, i.e. a boolean scalar.\n+  bool IsPredicate() const { return IsTypedLike<Type::BOOL>(); }\n+\n+  /// \\brief Cast to DataType/Schema if the shape allows it.\n+  Result<ExprType> CastTo(const std::shared_ptr<DataType>& data_type) const;\n+  Result<ExprType> CastTo(const std::shared_ptr<Schema>& schema) const;\n+\n+  /// \\brief Broadcasting align two types to the largest shape.\n+  ///\n+  /// \\param[in] lhs, first type to broadcast\n+  /// \\param[in] rhs, second type to broadcast\n+  /// \\return broadcasted type or an error why it can't be broadcasted.\n+  ///\n+  /// Broadcasting promotes the shape of the smallest type to the bigger one if\n+  /// they share the same DataType. In functional pattern matching it would look\n+  /// like:\n+  ///\n+  /// ```\n+  /// Broadcast(rhs, lhs) = match(lhs, rhs) {\n+  ///   case: ScalarType(t1), ScalarType(t2) if t1 == t2 => ScalarType(t)\n+  ///   case: ScalarType(t1), ArrayType(t2)  if t1 == t2 => ArrayType(t)\n+  ///   case: ArrayType(t1),  ScalarType(t2) if t1 == t2 => ArrayType(t)\n+  ///   case: ArrayType(t1),  ArrayType(t2)  if t1 == t2 => ArrayType(t)\n+  ///   case: _ => Error(\"Types not compatible for broadcasting\")\n+  /// }\n+  /// ```\n+  static Result<ExprType> Broadcast(const ExprType& lhs, const ExprType& rhs);\n+\n+  bool Equals(const ExprType& type) const;\n+\n+  std::string ToString() const;\n+\n+  ExprType(const ExprType& copy);\n+  ExprType(ExprType&& copy);\n+  ~ExprType();\n+\n+ private:\n+  /// Table constructor\n+  ExprType(std::shared_ptr<Schema> schema, Shape shape);\n+  /// Scalar or Array constructor\n+  ExprType(std::shared_ptr<DataType> type, Shape shape);\n+\n+  union {\n+    // Zero initialize the pointer or Copy/Assign constructors will fail.\n+    std::shared_ptr<DataType> data_type_{};\n+    std::shared_ptr<Schema> schema_;\n+  };\n+  Shape shape_;\n+};\n+\n+/// Represents an expression tree\n+class ARROW_EXPORT Expr : public util::EqualityComparable<Expr> {\n+ public:\n+  // Tag identifier for the expression type.\n+  enum Kind : uint8_t {\n+    // A Scalar literal, i.e. a constant.\n+    SCALAR_LITERAL,\n+    // A Field reference in a schema.\n+    FIELD_REFERENCE,\n+\n+    // Equal compare operator\n+    EQ_CMP_OP,\n+    // Not-Equal compare operator\n+    NE_CMP_OP,\n+    // Greater-Than compare operator\n+    GT_CMP_OP,\n+    // Greater-Equal-Than compare operator\n+    GE_CMP_OP,\n+    // Less-Than compare operator\n+    LT_CMP_OP,\n+    // Less-Equal-Than compare operator\n+    LE_CMP_OP,\n+\n+    // Empty relation with a known schema.\n+    EMPTY_REL,\n+    // Scan relational operator\n+    SCAN_REL,\n+    // Projection relational operator\n+    PROJECTION_REL,\n+    // Filter relational operator\n+    FILTER_REL,\n+  };\n+\n+  /// \\brief Return the kind of the expression.\n+  Kind kind() const { return kind_; }\n+  /// \\brief Return a string representation of the kind.\n+  std::string kind_name() const;\n+\n+  /// \\brief Return the type and shape of the resulting expression.\n+  const ExprType& type() const { return type_; }\n+\n+  /// \\brief Indicate if the expressions\n+  bool Equals(const Expr& other) const;\n+  using util::EqualityComparable<Expr>::Equals;\n+\n+  /// \\brief Return a string representing the expression\n+  std::string ToString() const;\n+\n+  virtual ~Expr() = default;\n+\n+ protected:\n+  explicit Expr(Kind kind, ExprType type) : type_(std::move(type)), kind_(kind) {}\n+\n+  ExprType type_;\n+  Kind kind_;\n+};\n+\n+// The following traits are used to break cycle between CRTP base classes and\n+// their derived counterparts to extract the Expr::Kind and other static\n+// properties from the forward declared class.\n+template <typename T>\n+struct expr_traits;\n+\n+template <>\n+struct expr_traits<ScalarExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::SCALAR_LITERAL;\n+};\n+\n+template <>\n+struct expr_traits<FieldRefExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::FIELD_REFERENCE;\n+};\n+\n+template <>\n+struct expr_traits<EqualCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::EQ_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<NotEqualCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::NE_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<GreaterThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::GT_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<GreaterEqualThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::GE_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<LessThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::LT_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<LessEqualThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::LE_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<EmptyRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::EMPTY_REL;\n+};\n+\n+template <>\n+struct expr_traits<ScanRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::SCAN_REL;\n+};\n+\n+template <>\n+struct expr_traits<ProjectionRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::PROJECTION_REL;\n+};\n+\n+template <>\n+struct expr_traits<FilterRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::FILTER_REL;\n+};\n+\n+//\n+// Value Expressions\n+//\n+\n+// An unnamed scalar literal expression.\n+class ARROW_EXPORT ScalarExpr : public Expr {\n+ public:\n+  static Result<std::shared_ptr<ScalarExpr>> Make(std::shared_ptr<Scalar> scalar);\n+\n+  const std::shared_ptr<Scalar>& scalar() const { return scalar_; }\n+\n+ private:\n+  explicit ScalarExpr(std::shared_ptr<Scalar> scalar);\n+\n+  std::shared_ptr<Scalar> scalar_;\n+};\n+\n+// References a column in a table/dataset\n+class ARROW_EXPORT FieldRefExpr : public Expr {\n+ public:\n+  static Result<std::shared_ptr<FieldRefExpr>> Make(std::shared_ptr<Field> field);\n+\n+  const std::shared_ptr<Field>& field() const { return field_; }\n+\n+ private:\n+  explicit FieldRefExpr(std::shared_ptr<Field> field);\n+\n+  std::shared_ptr<Field> field_;\n+};\n+\n+//\n+// Operator expressions\n+//\n+\n+class ARROW_EXPORT UnaryOpExpr {\n+ public:\n+  const std::shared_ptr<Expr>& operand() const { return operand_; }\n+\n+ protected:\n+  explicit UnaryOpExpr(std::shared_ptr<Expr> operand) : operand_(std::move(operand)) {}\n+\n+  std::shared_ptr<Expr> operand_;\n+};\n+\n+class ARROW_EXPORT BinaryOpExpr {\n+ public:\n+  const std::shared_ptr<Expr>& left_operand() const { return left_operand_; }\n+  const std::shared_ptr<Expr>& right_operand() const { return right_operand_; }\n+\n+ protected:\n+  BinaryOpExpr(std::shared_ptr<Expr> left, std::shared_ptr<Expr> right)\n+      : left_operand_(std::move(left)), right_operand_(std::move(right)) {}\n+\n+  std::shared_ptr<Expr> left_operand_;\n+  std::shared_ptr<Expr> right_operand_;\n+};\n+\n+class ARROW_EXPORT MultiAryOpExpr {\n+ public:\n+  const std::vector<std::shared_ptr<Expr>>& operands() const { return operands_; }\n+\n+ protected:\n+  explicit MultiAryOpExpr(std::vector<std::shared_ptr<Expr>> operands)\n+      : operands_(std::move(operands)) {}\n+\n+  std::vector<std::shared_ptr<Expr>> operands_;\n+};\n+\n+//\n+// Comparison expressions\n+//\n+\n+template <typename Self>\n+class ARROW_EXPORT CmpOpExpr : public BinaryOpExpr, public Expr {\n+ public:\n+  static Result<std::shared_ptr<Self>> Make(std::shared_ptr<Expr> left,\n+                                            std::shared_ptr<Expr> right) {\n+    if (left == NULLPTR || right == NULLPTR) {\n+      return Status::Invalid(\"Compare operands must be non-nulls\");\n+    }\n+\n+    // Broadcast ensures that types are compatible in shape and type.\n+    auto broadcast = ExprType::Broadcast(left->type(), right->type());\n+    // The type of comparison is always a boolean predicate.\n+    auto cast = [](const ExprType& t) { return t.CastTo(boolean()); };\n+    ARROW_ASSIGN_OR_RAISE(auto type, broadcast.Map(cast));\n \n Review comment:\n   I don't understand what this does. The operator should return a boolean. Why do you need to cast the inputs to boolean?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-02T16:34:14.440+0000",
                    "updated": "2020-03-02T16:34:14.440+0000",
                    "started": "2020-03-02T16:34:14.440+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "396200",
                    "issueId": "13286025"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286025/worklog/396201",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #6506: ARROW-7878: [C++][Compute] Draft LogicalPlan classes\nURL: https://github.com/apache/arrow/pull/6506#discussion_r386486488\n \n \n\n ##########\n File path: cpp/src/arrow/engine/expression_test.cc\n ##########\n @@ -0,0 +1,250 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/engine/expression.h\"\n+#include \"arrow/scalar.h\"\n+#include \"arrow/testing/gmock.h\"\n+#include \"arrow/testing/gtest_common.h\"\n+#include \"arrow/type.h\"\n+\n+using testing::HasSubstr;\n+using testing::Not;\n+using testing::Pointee;\n+\n+namespace arrow {\n+namespace engine {\n+\n+class ExprTypeTest : public testing::Test {};\n+\n+TEST_F(ExprTypeTest, Basic) {\n+  auto i32 = int32();\n+  auto s = schema({field(\"i32\", i32)});\n+\n+  auto scalar = ExprType::Scalar(i32);\n+  EXPECT_EQ(scalar.shape(), ExprType::Shape::SCALAR);\n+  EXPECT_TRUE(scalar.data_type()->Equals(i32));\n+  EXPECT_TRUE(scalar.IsScalar());\n+  EXPECT_FALSE(scalar.IsArray());\n+  EXPECT_FALSE(scalar.IsTable());\n+\n+  auto array = ExprType::Array(i32);\n+  EXPECT_EQ(array.shape(), ExprType::Shape::ARRAY);\n+  EXPECT_TRUE(array.data_type()->Equals(i32));\n+  EXPECT_FALSE(array.IsScalar());\n+  EXPECT_TRUE(array.IsArray());\n+  EXPECT_FALSE(array.IsTable());\n+\n+  auto table = ExprType::Table(s);\n+  EXPECT_EQ(table.shape(), ExprType::Shape::TABLE);\n+  EXPECT_TRUE(table.schema()->Equals(s));\n+  EXPECT_FALSE(table.IsScalar());\n+  EXPECT_FALSE(table.IsArray());\n+  EXPECT_TRUE(table.IsTable());\n+}\n+\n+TEST_F(ExprTypeTest, IsPredicate) {\n+  auto bool_scalar = ExprType::Scalar(boolean());\n+  EXPECT_TRUE(bool_scalar.IsPredicate());\n+\n+  auto bool_array = ExprType::Array(boolean());\n+  EXPECT_TRUE(bool_array.IsPredicate());\n+\n+  auto bool_table = ExprType::Table(schema({field(\"b\", boolean())}));\n+  EXPECT_FALSE(bool_table.IsPredicate());\n+\n+  auto i32_scalar = ExprType::Scalar(int32());\n+  EXPECT_FALSE(i32_scalar.IsPredicate());\n+}\n+\n+TEST_F(ExprTypeTest, Broadcast) {\n+  auto bool_scalar = ExprType::Scalar(boolean());\n+  auto bool_array = ExprType::Array(boolean());\n+  auto bool_table = ExprType::Table(schema({field(\"b\", boolean())}));\n+  auto i32_scalar = ExprType::Scalar(int32());\n+\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(Invalid, HasSubstr(\"operands must be of same type\"),\n+                                  ExprType::Broadcast(bool_scalar, i32_scalar));\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(Invalid, HasSubstr(\"operands must not be tables\"),\n+                                  ExprType::Broadcast(bool_scalar, bool_table));\n+\n+  EXPECT_THAT(ExprType::Broadcast(bool_scalar, bool_scalar), OkAndEq(bool_scalar));\n+  EXPECT_THAT(ExprType::Broadcast(bool_scalar, bool_array), OkAndEq(bool_array));\n+  EXPECT_THAT(ExprType::Broadcast(bool_array, bool_scalar), OkAndEq(bool_array));\n+  EXPECT_THAT(ExprType::Broadcast(bool_array, bool_array), OkAndEq(bool_array));\n+}\n+\n+TEST_F(ExprTypeTest, CastTo) {\n+  auto bool_scalar = ExprType::Scalar(boolean());\n+  auto bool_array = ExprType::Array(boolean());\n+  auto bool_table = ExprType::Table(schema({field(\"b\", boolean())}));\n+\n+  auto i32 = int32();\n+  auto other = schema({field(\"a\", i32)});\n+\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(Invalid, HasSubstr(\"Cannot cast a ScalarType with\"),\n+                                  bool_scalar.CastTo(other));\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(Invalid, HasSubstr(\"Cannot cast an ArrayType with\"),\n+                                  bool_array.CastTo(other));\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(Invalid, HasSubstr(\"Cannot cast a TableType with\"),\n+                                  bool_table.CastTo(i32));\n+\n+  EXPECT_EQ(bool_scalar.CastTo(i32), ExprType::Scalar(i32));\n+  EXPECT_EQ(bool_array.CastTo(i32), ExprType::Array(i32));\n+  EXPECT_EQ(bool_table.CastTo(other), ExprType::Table(other));\n+}\n+\n+class ExprTest : public testing::Test {};\n+\n+TEST_F(ExprTest, ScalarExpr) {\n+  ASSERT_RAISES(Invalid, ScalarExpr::Make(nullptr));\n+\n+  auto i32 = int32();\n+  ASSERT_OK_AND_ASSIGN(auto value, MakeScalar(i32, 10));\n+  ASSERT_OK_AND_ASSIGN(auto expr, ScalarExpr::Make(value));\n+  EXPECT_EQ(expr->kind(), Expr::SCALAR_LITERAL);\n+  EXPECT_EQ(expr->type(), ExprType::Scalar(i32));\n+  EXPECT_EQ(*expr->scalar(), *value);\n+}\n+\n+TEST_F(ExprTest, FieldRefExpr) {\n+  ASSERT_RAISES(Invalid, FieldRefExpr::Make(nullptr));\n+\n+  auto i32 = int32();\n+  auto f_i32 = field(\"i32\", i32);\n+\n+  ASSERT_OK_AND_ASSIGN(auto expr, FieldRefExpr::Make(f_i32));\n+  EXPECT_EQ(expr->kind(), Expr::FIELD_REFERENCE);\n+  EXPECT_EQ(expr->type(), ExprType::Array(i32));\n+  EXPECT_THAT(expr->field(), PtrEquals(f_i32));\n+}\n+\n+template <typename CmpClass>\n+class CmpExprTest : public ExprTest {\n+ public:\n+  Expr::Kind kind() { return expr_traits<CmpClass>::kind_id; }\n+\n+  Result<std::shared_ptr<CmpClass>> Make(std::shared_ptr<Expr> left,\n+                                         std::shared_ptr<Expr> right) {\n+    return CmpClass::Make(std::move(left), std::move(right));\n+  }\n+};\n+\n+using CompareExprs = ::testing::Types<EqualCmpExpr, NotEqualCmpExpr>;\n+\n+TYPED_TEST_CASE(CmpExprTest, CompareExprs);\n+TYPED_TEST(CmpExprTest, BasicCompareExpr) {\n+  auto i32 = int32();\n+\n+  auto f_i32 = field(\"i32\", i32);\n+  ASSERT_OK_AND_ASSIGN(auto f_expr, FieldRefExpr::Make(f_i32));\n+\n+  ASSERT_OK_AND_ASSIGN(auto s_i32, MakeScalar(i32, 42));\n+  ASSERT_OK_AND_ASSIGN(auto s_expr, ScalarExpr::Make(s_i32));\n+\n+  // Required fields\n+  ASSERT_RAISES(Invalid, this->Make(nullptr, nullptr));\n+  ASSERT_RAISES(Invalid, this->Make(s_expr, nullptr));\n+  ASSERT_RAISES(Invalid, this->Make(nullptr, f_expr));\n+\n+  // Not type compatible\n+  ASSERT_OK_AND_ASSIGN(auto s_i64, MakeScalar(int64(), 42L));\n+  ASSERT_OK_AND_ASSIGN(auto s_expr_i64, ScalarExpr::Make(s_i64));\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(Invalid, HasSubstr(\"operands must be of same type\"),\n+                                  this->Make(s_expr_i64, f_expr));\n+\n+  ASSERT_OK_AND_ASSIGN(auto expr, this->Make(f_expr, s_expr));\n+  EXPECT_EQ(expr->kind(), this->kind());\n+  // Ensure type is broadcasted\n+  EXPECT_EQ(expr->type(), ExprType::Array(boolean()));\n+  EXPECT_TRUE(expr->type().IsPredicate());\n+  EXPECT_THAT(expr, PtrEquals(expr));\n+  EXPECT_THAT(expr->left_operand(), PtrEquals(f_expr));\n+  EXPECT_THAT(expr->right_operand(), PtrEquals(s_expr));\n+\n+  ASSERT_OK_AND_ASSIGN(auto other, this->Make(f_expr, s_expr));\n+  EXPECT_THAT(expr, PtrEquals(other));\n+  // Compare operators supports commutativity\n+  // TODO(fsaintjacques): what about floating point types?\n \n Review comment:\n   Well, why do we need to handle commutativity in `Expr::Equals`? Is there any point in that?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-02T16:34:14.549+0000",
                    "updated": "2020-03-02T16:34:14.549+0000",
                    "started": "2020-03-02T16:34:14.548+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "396201",
                    "issueId": "13286025"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286025/worklog/396202",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #6506: ARROW-7878: [C++][Compute] Draft LogicalPlan classes\nURL: https://github.com/apache/arrow/pull/6506#discussion_r386496130\n \n \n\n ##########\n File path: cpp/src/arrow/engine/logical_plan.h\n ##########\n @@ -0,0 +1,136 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/compare.h\"\n+#include \"arrow/util/variant.h\"\n \n Review comment:\n   Unused?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-02T16:34:14.655+0000",
                    "updated": "2020-03-02T16:34:14.655+0000",
                    "started": "2020-03-02T16:34:14.655+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "396202",
                    "issueId": "13286025"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286025/worklog/396203",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #6506: ARROW-7878: [C++][Compute] Draft LogicalPlan classes\nURL: https://github.com/apache/arrow/pull/6506#discussion_r386492723\n \n \n\n ##########\n File path: cpp/src/arrow/engine/logical_plan.h\n ##########\n @@ -0,0 +1,136 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/compare.h\"\n+#include \"arrow/util/variant.h\"\n+\n+namespace arrow {\n+\n+namespace dataset {\n+class Dataset;\n+}\n+\n+namespace engine {\n+\n+class Catalog;\n+class Expr;\n+class ExprType;\n+\n+class LogicalPlan : public util::EqualityComparable<LogicalPlan> {\n+ public:\n+  explicit LogicalPlan(std::shared_ptr<Expr> root);\n+\n+  const std::shared_ptr<Expr>& root() const { return root_; }\n+  const ExprType& type() const;\n+\n+  bool Equals(const LogicalPlan& other) const;\n+  std::string ToString() const;\n+\n+ private:\n+  std::shared_ptr<Expr> root_;\n+};\n+\n+struct LogicalPlanBuilderOptions {\n+  /// Catalog containing named tables.\n+  std::shared_ptr<Catalog> catalog;\n+};\n+\n+class LogicalPlanBuilder {\n+ public:\n+  using ResultExpr = Result<std::shared_ptr<Expr>>;\n+\n+  explicit LogicalPlanBuilder(LogicalPlanBuilderOptions options = {});\n+\n+  /// \\defgroup leaf-nodes Leaf nodes in the logical plan\n+  /// @{\n+\n+  /// \\brief Construct a Scalar literal.\n+  ResultExpr Scalar(const std::shared_ptr<Scalar>& scalar);\n+\n+  /// \\brief References a field by name.\n+  ResultExpr Field(const std::shared_ptr<Expr>& input, const std::string& field_name);\n+  /// \\brief References a field by index.\n+  ResultExpr Field(const std::shared_ptr<Expr>& input, int field_index);\n+\n+  /// \\brief Scan a Table/Dataset from the Catalog.\n+  ResultExpr Scan(const std::string& table_name);\n+\n+  /// @}\n+\n+  /// \\defgroup comparator-nodes Comparison operators\n+  /// @{\n+\n+  /*\n+  TODO(fsaintjacques): This.\n+  ResultExpr Equal(const std::shared_ptr<Expr>& lhs, const std::shared_ptr<Expr>& rhs);\n+  ResultExpr NotEqual(const std::shared_ptr<Expr>& lhs, const std::shared_ptr<Expr>& rhs);\n+  ResultExpr GreaterThan(const std::shared_ptr<Expr>& lhs,\n+                         const std::shared_ptr<Expr>& rhs);\n+  ResultExpr GreaterEqualThan(const std::shared_ptr<Expr>& lhs,\n+                              const std::shared_ptr<Expr>& rhs);\n+  ResultExpr LessThan(const std::shared_ptr<Expr>& lhs, const std::shared_ptr<Expr>& rhs);\n+  ResultExpr LessEqualThan(const std::shared_ptr<Expr>& lhs,\n+                           const std::shared_ptr<Expr>& rhs);\n+  */\n+\n+  /// @}\n+\n+  /// \\defgroup rel-nodes Relational operator nodes in the logical plan\n+\n+  /// \\brief Filter rows of a relation with the given predicate.\n+  ResultExpr Filter(const std::shared_ptr<Expr>& input,\n+                    const std::shared_ptr<Expr>& predicate);\n+\n+  /// \\brief Project (mutate) columns with given expressions.\n+  ResultExpr Project(const std::shared_ptr<Expr>& input,\n+                     const std::vector<std::shared_ptr<Expr>>& expressions);\n+  ResultExpr Mutate(const std::shared_ptr<Expr>& input,\n+                    const std::vector<std::shared_ptr<Expr>>& expressions);\n+\n+  /// \\brief Project (select) columns by names.\n \n Review comment:\n   What is the difference between project and select?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-02T16:34:14.693+0000",
                    "updated": "2020-03-02T16:34:14.693+0000",
                    "started": "2020-03-02T16:34:14.693+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "396203",
                    "issueId": "13286025"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286025/worklog/396204",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #6506: ARROW-7878: [C++][Compute] Draft LogicalPlan classes\nURL: https://github.com/apache/arrow/pull/6506#discussion_r386473657\n \n \n\n ##########\n File path: cpp/src/arrow/engine/expression.h\n ##########\n @@ -0,0 +1,490 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+\n+#include \"arrow/engine/catalog.h\"\n+#include \"arrow/engine/type_fwd.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/compare.h\"\n+#include \"arrow/util/variant.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+/// ExprType is a class representing the type of an Expression. The type is\n+/// composed of a shape and a DataType or a Schema depending on the shape.\n+///\n+/// ExprType is mainly used to validate arguments for operator expressions, e.g.\n+/// relational operator expressions expect inputs of Table shape.\n+///\n+/// The sum-type representation would be:\n+///\n+/// enum ExprType {\n+///   ScalarType(DataType),\n+///   ArrayType(DataType),\n+///   TableType(Schema),\n+/// }\n+class ARROW_EXPORT ExprType : public util::EqualityComparable<ExprType> {\n+ public:\n+  enum Shape : uint8_t {\n+    // The expression yields a Scalar, e.g. \"1\".\n+    SCALAR,\n+    // The expression yields an Array, e.g. \"[1, 2, 3]\".\n+    ARRAY,\n+    // The expression yields a Table, e.g. \"{'a': [1, 2], 'b': [true, false]}\"\n+    TABLE,\n+  };\n+\n+  /// Construct a Scalar type.\n+  static ExprType Scalar(std::shared_ptr<DataType> type);\n+  /// Construct an Array type.\n+  static ExprType Array(std::shared_ptr<DataType> type);\n+  /// Construct a Table type.\n+  static ExprType Table(std::shared_ptr<Schema> schema);\n+\n+  /// \\brief Shape of the expression.\n+  Shape shape() const { return shape_; }\n+\n+  /// \\brief DataType of the expression if a scalar or an array.\n+  /// WARNING: You must ensure the proper shape before calling this accessor.\n+  const std::shared_ptr<DataType>& data_type() const { return data_type_; }\n+  /// \\brief Schema of the expression if of table shape.\n+  /// WARNING: You must ensure the proper shape before calling this accessor.\n+  const std::shared_ptr<Schema>& schema() const { return schema_; }\n+\n+  /// \\brief Indicate if the type is a Scalar.\n+  bool IsScalar() const { return shape_ == SCALAR; }\n+  /// \\brief Indicate if the type is an Array.\n+  bool IsArray() const { return shape_ == ARRAY; }\n+  /// \\brief Indicate if the type is a Table.\n+  bool IsTable() const { return shape_ == TABLE; }\n+\n+  template <Type::type TYPE_ID>\n+  bool IsTypedLike() const {\n+    return (IsScalar() || IsArray()) && data_type_->id() == TYPE_ID;\n+  }\n+\n+  /// \\brief Indicate if the type is a predicate, i.e. a boolean scalar.\n+  bool IsPredicate() const { return IsTypedLike<Type::BOOL>(); }\n+\n+  /// \\brief Cast to DataType/Schema if the shape allows it.\n+  Result<ExprType> CastTo(const std::shared_ptr<DataType>& data_type) const;\n+  Result<ExprType> CastTo(const std::shared_ptr<Schema>& schema) const;\n+\n+  /// \\brief Broadcasting align two types to the largest shape.\n+  ///\n+  /// \\param[in] lhs, first type to broadcast\n+  /// \\param[in] rhs, second type to broadcast\n+  /// \\return broadcasted type or an error why it can't be broadcasted.\n+  ///\n+  /// Broadcasting promotes the shape of the smallest type to the bigger one if\n+  /// they share the same DataType. In functional pattern matching it would look\n+  /// like:\n+  ///\n+  /// ```\n+  /// Broadcast(rhs, lhs) = match(lhs, rhs) {\n+  ///   case: ScalarType(t1), ScalarType(t2) if t1 == t2 => ScalarType(t)\n+  ///   case: ScalarType(t1), ArrayType(t2)  if t1 == t2 => ArrayType(t)\n+  ///   case: ArrayType(t1),  ScalarType(t2) if t1 == t2 => ArrayType(t)\n+  ///   case: ArrayType(t1),  ArrayType(t2)  if t1 == t2 => ArrayType(t)\n+  ///   case: _ => Error(\"Types not compatible for broadcasting\")\n+  /// }\n+  /// ```\n+  static Result<ExprType> Broadcast(const ExprType& lhs, const ExprType& rhs);\n+\n+  bool Equals(const ExprType& type) const;\n+\n+  std::string ToString() const;\n+\n+  ExprType(const ExprType& copy);\n+  ExprType(ExprType&& copy);\n+  ~ExprType();\n+\n+ private:\n+  /// Table constructor\n+  ExprType(std::shared_ptr<Schema> schema, Shape shape);\n+  /// Scalar or Array constructor\n+  ExprType(std::shared_ptr<DataType> type, Shape shape);\n+\n+  union {\n+    // Zero initialize the pointer or Copy/Assign constructors will fail.\n+    std::shared_ptr<DataType> data_type_{};\n+    std::shared_ptr<Schema> schema_;\n+  };\n+  Shape shape_;\n+};\n+\n+/// Represents an expression tree\n+class ARROW_EXPORT Expr : public util::EqualityComparable<Expr> {\n+ public:\n+  // Tag identifier for the expression type.\n+  enum Kind : uint8_t {\n+    // A Scalar literal, i.e. a constant.\n+    SCALAR_LITERAL,\n+    // A Field reference in a schema.\n+    FIELD_REFERENCE,\n+\n+    // Equal compare operator\n+    EQ_CMP_OP,\n+    // Not-Equal compare operator\n+    NE_CMP_OP,\n+    // Greater-Than compare operator\n+    GT_CMP_OP,\n+    // Greater-Equal-Than compare operator\n+    GE_CMP_OP,\n+    // Less-Than compare operator\n+    LT_CMP_OP,\n+    // Less-Equal-Than compare operator\n+    LE_CMP_OP,\n+\n+    // Empty relation with a known schema.\n+    EMPTY_REL,\n+    // Scan relational operator\n+    SCAN_REL,\n+    // Projection relational operator\n+    PROJECTION_REL,\n+    // Filter relational operator\n+    FILTER_REL,\n+  };\n+\n+  /// \\brief Return the kind of the expression.\n+  Kind kind() const { return kind_; }\n+  /// \\brief Return a string representation of the kind.\n+  std::string kind_name() const;\n+\n+  /// \\brief Return the type and shape of the resulting expression.\n+  const ExprType& type() const { return type_; }\n+\n+  /// \\brief Indicate if the expressions\n+  bool Equals(const Expr& other) const;\n+  using util::EqualityComparable<Expr>::Equals;\n+\n+  /// \\brief Return a string representing the expression\n+  std::string ToString() const;\n+\n+  virtual ~Expr() = default;\n+\n+ protected:\n+  explicit Expr(Kind kind, ExprType type) : type_(std::move(type)), kind_(kind) {}\n+\n+  ExprType type_;\n+  Kind kind_;\n+};\n+\n+// The following traits are used to break cycle between CRTP base classes and\n+// their derived counterparts to extract the Expr::Kind and other static\n+// properties from the forward declared class.\n+template <typename T>\n+struct expr_traits;\n+\n+template <>\n+struct expr_traits<ScalarExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::SCALAR_LITERAL;\n+};\n+\n+template <>\n+struct expr_traits<FieldRefExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::FIELD_REFERENCE;\n+};\n+\n+template <>\n+struct expr_traits<EqualCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::EQ_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<NotEqualCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::NE_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<GreaterThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::GT_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<GreaterEqualThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::GE_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<LessThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::LT_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<LessEqualThanCmpExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::LE_CMP_OP;\n+};\n+\n+template <>\n+struct expr_traits<EmptyRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::EMPTY_REL;\n+};\n+\n+template <>\n+struct expr_traits<ScanRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::SCAN_REL;\n+};\n+\n+template <>\n+struct expr_traits<ProjectionRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::PROJECTION_REL;\n+};\n+\n+template <>\n+struct expr_traits<FilterRelExpr> {\n+  static constexpr Expr::Kind kind_id = Expr::FILTER_REL;\n+};\n+\n+//\n+// Value Expressions\n+//\n+\n+// An unnamed scalar literal expression.\n+class ARROW_EXPORT ScalarExpr : public Expr {\n+ public:\n+  static Result<std::shared_ptr<ScalarExpr>> Make(std::shared_ptr<Scalar> scalar);\n+\n+  const std::shared_ptr<Scalar>& scalar() const { return scalar_; }\n+\n+ private:\n+  explicit ScalarExpr(std::shared_ptr<Scalar> scalar);\n+\n+  std::shared_ptr<Scalar> scalar_;\n+};\n+\n+// References a column in a table/dataset\n+class ARROW_EXPORT FieldRefExpr : public Expr {\n+ public:\n+  static Result<std::shared_ptr<FieldRefExpr>> Make(std::shared_ptr<Field> field);\n+\n+  const std::shared_ptr<Field>& field() const { return field_; }\n+\n+ private:\n+  explicit FieldRefExpr(std::shared_ptr<Field> field);\n+\n+  std::shared_ptr<Field> field_;\n+};\n+\n+//\n+// Operator expressions\n+//\n+\n+class ARROW_EXPORT UnaryOpExpr {\n+ public:\n+  const std::shared_ptr<Expr>& operand() const { return operand_; }\n+\n+ protected:\n+  explicit UnaryOpExpr(std::shared_ptr<Expr> operand) : operand_(std::move(operand)) {}\n+\n+  std::shared_ptr<Expr> operand_;\n+};\n+\n+class ARROW_EXPORT BinaryOpExpr {\n+ public:\n+  const std::shared_ptr<Expr>& left_operand() const { return left_operand_; }\n+  const std::shared_ptr<Expr>& right_operand() const { return right_operand_; }\n+\n+ protected:\n+  BinaryOpExpr(std::shared_ptr<Expr> left, std::shared_ptr<Expr> right)\n+      : left_operand_(std::move(left)), right_operand_(std::move(right)) {}\n+\n+  std::shared_ptr<Expr> left_operand_;\n+  std::shared_ptr<Expr> right_operand_;\n+};\n+\n+class ARROW_EXPORT MultiAryOpExpr {\n+ public:\n+  const std::vector<std::shared_ptr<Expr>>& operands() const { return operands_; }\n+\n+ protected:\n+  explicit MultiAryOpExpr(std::vector<std::shared_ptr<Expr>> operands)\n+      : operands_(std::move(operands)) {}\n+\n+  std::vector<std::shared_ptr<Expr>> operands_;\n+};\n+\n+//\n+// Comparison expressions\n+//\n+\n+template <typename Self>\n+class ARROW_EXPORT CmpOpExpr : public BinaryOpExpr, public Expr {\n+ public:\n+  static Result<std::shared_ptr<Self>> Make(std::shared_ptr<Expr> left,\n+                                            std::shared_ptr<Expr> right) {\n+    if (left == NULLPTR || right == NULLPTR) {\n+      return Status::Invalid(\"Compare operands must be non-nulls\");\n+    }\n+\n+    // Broadcast ensures that types are compatible in shape and type.\n+    auto broadcast = ExprType::Broadcast(left->type(), right->type());\n+    // The type of comparison is always a boolean predicate.\n+    auto cast = [](const ExprType& t) { return t.CastTo(boolean()); };\n+    ARROW_ASSIGN_OR_RAISE(auto type, broadcast.Map(cast));\n+\n+    return std::shared_ptr<Self>(\n+        new Self(std::move(type), std::move(left), std::move(right)));\n+  }\n+\n+ protected:\n+  CmpOpExpr(ExprType type, std::shared_ptr<Expr> left, std::shared_ptr<Expr> right)\n+      : BinaryOpExpr(std::move(left), std::move(right)),\n+        Expr(expr_traits<Self>::kind_id, std::move(type)) {}\n+};\n+\n+class ARROW_EXPORT EqualCmpExpr : public CmpOpExpr<EqualCmpExpr> {\n+ protected:\n+  using CmpOpExpr<EqualCmpExpr>::CmpOpExpr;\n+};\n+\n+class ARROW_EXPORT NotEqualCmpExpr : public CmpOpExpr<NotEqualCmpExpr> {\n+ protected:\n+  using CmpOpExpr<NotEqualCmpExpr>::CmpOpExpr;\n+};\n+\n+class ARROW_EXPORT GreaterThanCmpExpr : public CmpOpExpr<GreaterThanCmpExpr> {\n+ protected:\n+  using CmpOpExpr<GreaterThanCmpExpr>::CmpOpExpr;\n+};\n+\n+class ARROW_EXPORT GreaterEqualThanCmpExpr : public CmpOpExpr<GreaterEqualThanCmpExpr> {\n+ protected:\n+  using CmpOpExpr<GreaterEqualThanCmpExpr>::CmpOpExpr;\n+};\n+\n+class ARROW_EXPORT LessThanCmpExpr : public CmpOpExpr<LessThanCmpExpr> {\n+ protected:\n+  using CmpOpExpr<LessThanCmpExpr>::CmpOpExpr;\n+};\n+\n+class ARROW_EXPORT LessEqualThanCmpExpr : public CmpOpExpr<LessEqualThanCmpExpr> {\n+ protected:\n+  using CmpOpExpr<LessEqualThanCmpExpr>::CmpOpExpr;\n+};\n+\n+//\n+// Relational Expressions\n+//\n+\n+template <typename Self>\n+class ARROW_EXPORT RelExpr : public Expr {\n+ public:\n+  const std::shared_ptr<Schema>& schema() const { return schema_; }\n+\n+ protected:\n+  explicit RelExpr(std::shared_ptr<Schema> schema)\n+      : Expr(expr_traits<Self>::kind_id, ExprType::Table(schema)),\n+        schema_(std::move(schema)) {}\n+\n+  std::shared_ptr<Schema> schema_;\n+};\n+\n+class ARROW_EXPORT EmptyRelExpr : public RelExpr<EmptyRelExpr> {\n+ public:\n+  static Result<std::shared_ptr<EmptyRelExpr>> Make(std::shared_ptr<Schema> schema);\n+\n+ protected:\n+  using RelExpr<EmptyRelExpr>::RelExpr;\n+};\n+\n+class ARROW_EXPORT ScanRelExpr : public RelExpr<ScanRelExpr> {\n \n Review comment:\n   Ditto here.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-02T16:34:14.750+0000",
                    "updated": "2020-03-02T16:34:14.750+0000",
                    "started": "2020-03-02T16:34:14.750+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "396204",
                    "issueId": "13286025"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 67200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@4199a595[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@396555e9[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4b7d25b4[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@58a4eb2f[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@17a68c8d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@742fd108[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@565d0abc[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@295f6ecb[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@abe5d89[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@137a47[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3ea58813[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@6cde903a[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 67200,
        "customfield_12312520": null,
        "customfield_12312521": "2020-02-18 16:22:09.0",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-10-08T19:38:08.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-7878/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2020-02-18T16:22:09.000+0000",
        "updated": "2021-10-08T19:38:08.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "18h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 67200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Implement LogicalPlan and LogicalPlanBuilder",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [],
            "maxResults": 0,
            "total": 0,
            "startAt": 0
        },
        "customfield_12311820": "0|z0bmc0:",
        "customfield_12314139": null
    }
}