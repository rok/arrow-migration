{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13384190",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384190",
    "key": "ARROW-13095",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349983",
                "id": "12349983",
                "description": "",
                "name": "5.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-07-28"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "beginner",
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12617552",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12617552",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "inwardIssue": {
                    "id": "13377986",
                    "key": "ARROW-12748",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377986",
                    "fields": {
                        "summary": "[C++] Arithmetic kernels for numeric arrays",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 16200,
            "total": 16200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 16200,
            "total": 16200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13095/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 27,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384190/worklog/611886",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10544:\nURL: https://github.com/apache/arrow/pull/10544#issuecomment-863502391\n\n\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-18T20:53:16.725+0000",
                    "updated": "2021-06-18T20:53:16.725+0000",
                    "started": "2021-06-18T20:53:16.724+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "611886",
                    "issueId": "13384190"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384190/worklog/611994",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "edponce commented on pull request #10544:\nURL: https://github.com/apache/arrow/pull/10544#issuecomment-863490564\n\n\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-18T21:06:58.021+0000",
                    "updated": "2021-06-18T21:06:58.021+0000",
                    "started": "2021-06-18T21:06:58.021+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "611994",
                    "issueId": "13384190"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384190/worklog/612042",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "edponce commented on a change in pull request #10544:\nURL: https://github.com/apache/arrow/pull/10544#discussion_r653780349\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -397,6 +397,136 @@ struct PowerChecked {\n   }\n };\n \n+// Stamp out a trig function for which +/-inf are domain errors\n+#define TRIG_NO_INF(name, func)                                                        \\\n+  struct Trig##name {                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) { \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };                                                                                   \\\n+  struct Trig##name##Checked {                                                         \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val,            \\\n+                                                  Status* st) {                        \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      if (ARROW_PREDICT_FALSE(std::isinf(val))) {                                      \\\n+        *st = Status::Invalid(\"domain error\");                                         \\\n+        return val;                                                                    \\\n+      }                                                                                \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };\n+\n+TRIG_NO_INF(Sin, std::sin);\n+TRIG_NO_INF(Cos, std::cos);\n+TRIG_NO_INF(Tan, std::tan);\n+\n+struct TrigAsin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAsinChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAcos {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAcosChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAtan {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::atan(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::atan(val);\n+  }\n+};\n+\n+struct TrigAtan2 {\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+};\n\nReview comment:\n       I have always thought of the `check_overflow` option to be applicable for both *underflow* and *overflow*. I do not see a benefit of having two distinct options. Regarding if you should include `ArithmeticOptions` just for the sakes of consistency, I would argue that should not be done. Why would we want to include an unused value? Also, it might confuse the client code if it thinks that the function options provide some functionality.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -397,6 +397,136 @@ struct PowerChecked {\n   }\n };\n \n+// Stamp out a trig function for which +/-inf are domain errors\n+#define TRIG_NO_INF(name, func)                                                        \\\n+  struct Trig##name {                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) { \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };                                                                                   \\\n+  struct Trig##name##Checked {                                                         \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val,            \\\n+                                                  Status* st) {                        \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      if (ARROW_PREDICT_FALSE(std::isinf(val))) {                                      \\\n+        *st = Status::Invalid(\"domain error\");                                         \\\n+        return val;                                                                    \\\n+      }                                                                                \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };\n+\n+TRIG_NO_INF(Sin, std::sin);\n+TRIG_NO_INF(Cos, std::cos);\n+TRIG_NO_INF(Tan, std::tan);\n+\n+struct TrigAsin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAsinChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAcos {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAcosChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAtan {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::atan(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::atan(val);\n+  }\n+};\n+\n+struct TrigAtan2 {\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+};\n\nReview comment:\n       C++ defines [atan2(0, 0)](https://www.cplusplus.com/reference/cmath/atan2/) as a domain error, the returned value is implementation-specific, so even if it returns 0 in our tests we should trigger a domain error as it maps to 0/0 expression.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -397,6 +397,136 @@ struct PowerChecked {\n   }\n };\n \n+// Stamp out a trig function for which +/-inf are domain errors\n+#define TRIG_NO_INF(name, func)                                                        \\\n+  struct Trig##name {                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) { \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };                                                                                   \\\n+  struct Trig##name##Checked {                                                         \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val,            \\\n+                                                  Status* st) {                        \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      if (ARROW_PREDICT_FALSE(std::isinf(val))) {                                      \\\n+        *st = Status::Invalid(\"domain error\");                                         \\\n+        return val;                                                                    \\\n+      }                                                                                \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };\n+\n+TRIG_NO_INF(Sin, std::sin);\n+TRIG_NO_INF(Cos, std::cos);\n+TRIG_NO_INF(Tan, std::tan);\n+\n+struct TrigAsin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAsinChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAcos {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAcosChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAtan {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::atan(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::atan(val);\n+  }\n+};\n+\n+struct TrigAtan2 {\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+};\n\nReview comment:\n       Thanks for the `atan2` link. Maybe a safer way to go (to prevent domain error for `atan2(0, 0)`) is to explicitly return 0 for this case. This way if IEEE 754 is not being conformed to, result is consistent and domain error is circumvented.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -397,6 +397,136 @@ struct PowerChecked {\n   }\n };\n \n+// Stamp out a trig function for which +/-inf are domain errors\n+#define TRIG_NO_INF(name, func)                                                        \\\n+  struct Trig##name {                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) { \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };                                                                                   \\\n+  struct Trig##name##Checked {                                                         \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val,            \\\n+                                                  Status* st) {                        \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      if (ARROW_PREDICT_FALSE(std::isinf(val))) {                                      \\\n+        *st = Status::Invalid(\"domain error\");                                         \\\n+        return val;                                                                    \\\n+      }                                                                                \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };\n+\n+TRIG_NO_INF(Sin, std::sin);\n+TRIG_NO_INF(Cos, std::cos);\n+TRIG_NO_INF(Tan, std::tan);\n+\n+struct TrigAsin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAsinChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAcos {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAcosChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAtan {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::atan(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::atan(val);\n+  }\n+};\n+\n+struct TrigAtan2 {\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+};\n\nReview comment:\n       Thanks for the `atan2` link. Maybe a safer way to go (to prevent domain error for `atan2(0, 0)`) is to explicitly return 0 for this case. This way if IEEE 754 is not being conformed to, result is consistent and domain error is circumvented. But what would be the performance effect of this comparison?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -602,6 +787,80 @@ const FunctionDoc pow_checked_doc{\n     (\"An error is returned when integer to negative integer power is encountered,\\n\"\n      \"or integer overflow is encountered.\"),\n     {\"base\", \"exponent\"}};\n+\n+const FunctionDoc sin_doc{\"Computes the sine of the elements argument-wise\",\n+                          (\"Integer arguments return double values. \"\n+                           \"This function returns NaN on values outside its domain. \"\n+                           \"To raise an error instead, see sin_checked.\"),\n+                          {\"x\"}};\n\nReview comment:\n       Based on all the other function docs, when a function is referenced in the text it is enclosed in double quotes. For example, change *sin_checked* to *\\\\\"sin_checked\\\\\"*.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -602,6 +787,80 @@ const FunctionDoc pow_checked_doc{\n     (\"An error is returned when integer to negative integer power is encountered,\\n\"\n      \"or integer overflow is encountered.\"),\n     {\"base\", \"exponent\"}};\n+\n+const FunctionDoc sin_doc{\"Computes the sine of the elements argument-wise\",\n+                          (\"Integer arguments return double values. \"\n+                           \"This function returns NaN on values outside its domain. \"\n+                           \"To raise an error instead, see sin_checked.\"),\n+                          {\"x\"}};\n\nReview comment:\n       Based on all the other function docs, when a function is referenced in the text it is enclosed in double quotes. For example, change *sin_checked* to *\\\\\"sin_checked\\\\\"*. Similarly, for all the other cases.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -397,6 +397,136 @@ struct PowerChecked {\n   }\n };\n \n+// Stamp out a trig function for which +/-inf are domain errors\n+#define TRIG_NO_INF(name, func)                                                        \\\n+  struct Trig##name {                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) { \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };                                                                                   \\\n+  struct Trig##name##Checked {                                                         \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val,            \\\n+                                                  Status* st) {                        \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      if (ARROW_PREDICT_FALSE(std::isinf(val))) {                                      \\\n+        *st = Status::Invalid(\"domain error\");                                         \\\n+        return val;                                                                    \\\n+      }                                                                                \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };\n+\n+TRIG_NO_INF(Sin, std::sin);\n+TRIG_NO_INF(Cos, std::cos);\n+TRIG_NO_INF(Tan, std::tan);\n+\n+struct TrigAsin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAsinChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAcos {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAcosChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAtan {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::atan(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::atan(val);\n+  }\n+};\n+\n+struct TrigAtan2 {\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+};\n\nReview comment:\n       Well, probably there is no need to check for underflow, because it seems that for all trigonometric functions, C++ applies rounding to the underflow cases and returns a correct value.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -397,6 +397,136 @@ struct PowerChecked {\n   }\n };\n \n+// Stamp out a trig function for which +/-inf are domain errors\n+#define TRIG_NO_INF(name, func)                                                        \\\n+  struct Trig##name {                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) { \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };                                                                                   \\\n+  struct Trig##name##Checked {                                                         \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val,            \\\n+                                                  Status* st) {                        \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      if (ARROW_PREDICT_FALSE(std::isinf(val))) {                                      \\\n+        *st = Status::Invalid(\"domain error\");                                         \\\n+        return val;                                                                    \\\n+      }                                                                                \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };\n+\n+TRIG_NO_INF(Sin, std::sin);\n+TRIG_NO_INF(Cos, std::cos);\n+TRIG_NO_INF(Tan, std::tan);\n+\n+struct TrigAsin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAsinChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAcos {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAcosChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAtan {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::atan(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::atan(val);\n+  }\n+};\n+\n+struct TrigAtan2 {\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+};\n\nReview comment:\n       One last fix, `copy_sign` should also be applied to 0.0 value, `return std::copysign(static_cast<T>(0.0), y)`.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -397,6 +397,136 @@ struct PowerChecked {\n   }\n };\n \n+// Stamp out a trig function for which +/-inf are domain errors\n+#define TRIG_NO_INF(name, func)                                                        \\\n+  struct Trig##name {                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) { \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };                                                                                   \\\n+  struct Trig##name##Checked {                                                         \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val,            \\\n+                                                  Status* st) {                        \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      if (ARROW_PREDICT_FALSE(std::isinf(val))) {                                      \\\n+        *st = Status::Invalid(\"domain error\");                                         \\\n+        return val;                                                                    \\\n+      }                                                                                \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };\n+\n+TRIG_NO_INF(Sin, std::sin);\n+TRIG_NO_INF(Cos, std::cos);\n+TRIG_NO_INF(Tan, std::tan);\n+\n+struct TrigAsin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAsinChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAcos {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAcosChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAtan {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::atan(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::atan(val);\n+  }\n+};\n+\n+struct TrigAtan2 {\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+};\n\nReview comment:\n       One last fix, `std::copysign` should also be applied to 0.0 value, `return std::copysign(static_cast<T>(0.0), y)`.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/util_internal.h\n##########\n@@ -30,6 +30,24 @@ namespace arrow {\n namespace compute {\n namespace internal {\n \n+// Used in some kernels and testing - not provided by default in MSVC\n+// and _USE_MATH_DEFINES is not reliable with unity builds\n+#ifndef M_E\n+#define M_E 2.71828182845904523536\n+#define M_LOG2E 1.44269504088896340736\n+#define M_LOG10E 0.434294481903251827651\n+#define M_LN2 0.693147180559945309417\n+#define M_LN10 2.30258509299404568402\n+#define M_PI 3.14159265358979323846\n+#define M_PI_2 1.57079632679489661923\n+#define M_PI_4 0.785398163397448309616\n+#define M_1_PI 0.318309886183790671538\n+#define M_2_PI 0.636619772367581343076\n+#define M_2_SQRTPI 1.12837916709551257390\n+#define M_SQRT2 1.41421356237309504880\n+#define M_SQRT1_2 0.707106781186547524401\n+#endif\n+\n\nReview comment:\n       I do not understand the issue with `_USE_MATH_DEFINES` and unity builds. These defines should be guarded with\r\n   ```\r\n   #if defined(_USE_MATH_DEFINES) && !defined(_MATH_DEFINES_DEFINED)\r\n   #define _MATH_DEFINES_DEFINED\r\n   ...\r\n   #endif\r\n   ```\r\n   to prevent multiple definitions.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/util_internal.h\n##########\n@@ -30,6 +30,24 @@ namespace arrow {\n namespace compute {\n namespace internal {\n \n+// Used in some kernels and testing - not provided by default in MSVC\n+// and _USE_MATH_DEFINES is not reliable with unity builds\n+#ifndef M_E\n+#define M_E 2.71828182845904523536\n+#define M_LOG2E 1.44269504088896340736\n+#define M_LOG10E 0.434294481903251827651\n+#define M_LN2 0.693147180559945309417\n+#define M_LN10 2.30258509299404568402\n+#define M_PI 3.14159265358979323846\n+#define M_PI_2 1.57079632679489661923\n+#define M_PI_4 0.785398163397448309616\n+#define M_1_PI 0.318309886183790671538\n+#define M_2_PI 0.636619772367581343076\n+#define M_2_SQRTPI 1.12837916709551257390\n+#define M_SQRT2 1.41421356237309504880\n+#define M_SQRT1_2 0.707106781186547524401\n+#endif\n+\n\nReview comment:\n       Ok, I see. You are guarding all the defines based on the existence of `M_E`. I think it would be \"safer\" to guard each macro independently. Safer in the sense that if at some point `M_E` is defined explicitly in another translation unit, then the remaining macros will be undefined.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/util_internal.h\n##########\n@@ -30,6 +30,24 @@ namespace arrow {\n namespace compute {\n namespace internal {\n \n+// Used in some kernels and testing - not provided by default in MSVC\n+// and _USE_MATH_DEFINES is not reliable with unity builds\n+#ifndef M_E\n+#define M_E 2.71828182845904523536\n+#define M_LOG2E 1.44269504088896340736\n+#define M_LOG10E 0.434294481903251827651\n+#define M_LN2 0.693147180559945309417\n+#define M_LN10 2.30258509299404568402\n+#define M_PI 3.14159265358979323846\n+#define M_PI_2 1.57079632679489661923\n+#define M_PI_4 0.785398163397448309616\n+#define M_1_PI 0.318309886183790671538\n+#define M_2_PI 0.636619772367581343076\n+#define M_2_SQRTPI 1.12837916709551257390\n+#define M_SQRT2 1.41421356237309504880\n+#define M_SQRT1_2 0.707106781186547524401\n+#endif\n+\n\nReview comment:\n       Ok, I see. You are guarding all the defines based on the existence of `M_E`. I think it would be \"safer\" to guard each macro independently. Safer in the sense that if at some point only `M_E` is defined explicitly in another translation unit, then the remaining macros will be undefined. Alternatively, we can use `_USE_ARROW_MATH_DEFINES` and require it before including `util_internal.h`, but this seems overkill.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-18T21:13:34.055+0000",
                    "updated": "2021-06-18T21:13:34.055+0000",
                    "started": "2021-06-18T21:13:34.055+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "612042",
                    "issueId": "13384190"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384190/worklog/612085",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10544:\nURL: https://github.com/apache/arrow/pull/10544#discussion_r653778253\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -397,6 +397,136 @@ struct PowerChecked {\n   }\n };\n \n+// Stamp out a trig function for which +/-inf are domain errors\n+#define TRIG_NO_INF(name, func)                                                        \\\n+  struct Trig##name {                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) { \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };                                                                                   \\\n+  struct Trig##name##Checked {                                                         \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val,            \\\n+                                                  Status* st) {                        \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      if (ARROW_PREDICT_FALSE(std::isinf(val))) {                                      \\\n+        *st = Status::Invalid(\"domain error\");                                         \\\n+        return val;                                                                    \\\n+      }                                                                                \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };\n+\n+TRIG_NO_INF(Sin, std::sin);\n+TRIG_NO_INF(Cos, std::cos);\n+TRIG_NO_INF(Tan, std::tan);\n+\n+struct TrigAsin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAsinChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAcos {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAcosChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAtan {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::atan(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::atan(val);\n+  }\n+};\n+\n+struct TrigAtan2 {\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+};\n\nReview comment:\n       What I see is that an implementation using IEEE floating point arithmetic specifically does not consider it a domain error: https://en.cppreference.com/w/cpp/numeric/math/atan2\r\n   \r\n   Though we could be more conservative.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -397,6 +397,136 @@ struct PowerChecked {\n   }\n };\n \n+// Stamp out a trig function for which +/-inf are domain errors\n+#define TRIG_NO_INF(name, func)                                                        \\\n+  struct Trig##name {                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) { \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };                                                                                   \\\n+  struct Trig##name##Checked {                                                         \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val,            \\\n+                                                  Status* st) {                        \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      if (ARROW_PREDICT_FALSE(std::isinf(val))) {                                      \\\n+        *st = Status::Invalid(\"domain error\");                                         \\\n+        return val;                                                                    \\\n+      }                                                                                \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };\n+\n+TRIG_NO_INF(Sin, std::sin);\n+TRIG_NO_INF(Cos, std::cos);\n+TRIG_NO_INF(Tan, std::tan);\n+\n+struct TrigAsin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAsinChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAcos {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAcosChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAtan {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::atan(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::atan(val);\n+  }\n+};\n+\n+struct TrigAtan2 {\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+};\n\nReview comment:\n       Regarding underflow: I will adjust the kernels to check for this and see if I can find some values to test with.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -397,6 +397,136 @@ struct PowerChecked {\n   }\n };\n \n+// Stamp out a trig function for which +/-inf are domain errors\n+#define TRIG_NO_INF(name, func)                                                        \\\n+  struct Trig##name {                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) { \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };                                                                                   \\\n+  struct Trig##name##Checked {                                                         \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val,            \\\n+                                                  Status* st) {                        \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      if (ARROW_PREDICT_FALSE(std::isinf(val))) {                                      \\\n+        *st = Status::Invalid(\"domain error\");                                         \\\n+        return val;                                                                    \\\n+      }                                                                                \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };\n+\n+TRIG_NO_INF(Sin, std::sin);\n+TRIG_NO_INF(Cos, std::cos);\n+TRIG_NO_INF(Tan, std::tan);\n+\n+struct TrigAsin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAsinChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAcos {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAcosChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAtan {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::atan(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::atan(val);\n+  }\n+};\n+\n+struct TrigAtan2 {\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+};\n\nReview comment:\n       Ah, ok. I do see that it'll set a floating-point exception that you can test for, but that may indeed be overkill.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -397,6 +397,136 @@ struct PowerChecked {\n   }\n };\n \n+// Stamp out a trig function for which +/-inf are domain errors\n+#define TRIG_NO_INF(name, func)                                                        \\\n+  struct Trig##name {                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) { \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };                                                                                   \\\n+  struct Trig##name##Checked {                                                         \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val,            \\\n+                                                  Status* st) {                        \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      if (ARROW_PREDICT_FALSE(std::isinf(val))) {                                      \\\n+        *st = Status::Invalid(\"domain error\");                                         \\\n+        return val;                                                                    \\\n+      }                                                                                \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };\n+\n+TRIG_NO_INF(Sin, std::sin);\n+TRIG_NO_INF(Cos, std::cos);\n+TRIG_NO_INF(Tan, std::tan);\n+\n+struct TrigAsin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAsinChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAcos {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAcosChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAtan {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::atan(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::atan(val);\n+  }\n+};\n+\n+struct TrigAtan2 {\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+};\n\nReview comment:\n       I've fixed the docs and updated atan2 to explicitly check for the 0, 0 case (including signed zeroes which are specified).\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -397,6 +397,136 @@ struct PowerChecked {\n   }\n };\n \n+// Stamp out a trig function for which +/-inf are domain errors\n+#define TRIG_NO_INF(name, func)                                                        \\\n+  struct Trig##name {                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) { \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };                                                                                   \\\n+  struct Trig##name##Checked {                                                         \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {        \\\n+      static_assert(std::is_same<T, double>::value, \"\");                               \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+    template <typename T, typename Arg0>                                               \\\n+    static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val,            \\\n+                                                  Status* st) {                        \\\n+      static_assert(std::is_same<T, Arg0>::value, \"\");                                 \\\n+      if (ARROW_PREDICT_FALSE(std::isinf(val))) {                                      \\\n+        *st = Status::Invalid(\"domain error\");                                         \\\n+        return val;                                                                    \\\n+      }                                                                                \\\n+      return func(val);                                                                \\\n+    }                                                                                  \\\n+  };\n+\n+TRIG_NO_INF(Sin, std::sin);\n+TRIG_NO_INF(Cos, std::cos);\n+TRIG_NO_INF(Tan, std::tan);\n+\n+struct TrigAsin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAsinChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::asin(val);\n+  }\n+};\n+\n+struct TrigAcos {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAcosChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE((val < -1.0 || val > 1.0) && !std::isnan(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::acos(val);\n+  }\n+};\n+\n+struct TrigAtan {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::atan(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::atan(val);\n+  }\n+};\n+\n+struct TrigAtan2 {\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::atan2(y, x);\n+  }\n+};\n\nReview comment:\n       Whoops, good catch - thanks!\n\n##########\nFile path: cpp/src/arrow/compute/kernels/util_internal.h\n##########\n@@ -30,6 +30,24 @@ namespace arrow {\n namespace compute {\n namespace internal {\n \n+// Used in some kernels and testing - not provided by default in MSVC\n+// and _USE_MATH_DEFINES is not reliable with unity builds\n+#ifndef M_E\n+#define M_E 2.71828182845904523536\n+#define M_LOG2E 1.44269504088896340736\n+#define M_LOG10E 0.434294481903251827651\n+#define M_LN2 0.693147180559945309417\n+#define M_LN10 2.30258509299404568402\n+#define M_PI 3.14159265358979323846\n+#define M_PI_2 1.57079632679489661923\n+#define M_PI_4 0.785398163397448309616\n+#define M_1_PI 0.318309886183790671538\n+#define M_2_PI 0.636619772367581343076\n+#define M_2_SQRTPI 1.12837916709551257390\n+#define M_SQRT2 1.41421356237309504880\n+#define M_SQRT1_2 0.707106781186547524401\n+#endif\n+\n\nReview comment:\n       It's the opposite: if any translation unit forgets to add that define before including cmath, even if you don't forget, you'll get a build error, since cmath will already have been included.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-18T21:18:39.165+0000",
                    "updated": "2021-06-18T21:18:39.165+0000",
                    "started": "2021-06-18T21:18:39.164+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "612085",
                    "issueId": "13384190"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384190/worklog/613439",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on a change in pull request #10544:\nURL: https://github.com/apache/arrow/pull/10544#discussion_r656142729\n\n\n\n##########\nFile path: docs/source/cpp/compute.rst\n##########\n@@ -266,10 +266,20 @@ an ``Invalid`` :class:`Status` when overflow is detected.\n +--------------------------+------------+--------------------+---------------------+\n | abs_checked              | Unary      | Numeric            | Numeric             |\n +--------------------------+------------+--------------------+---------------------+\n+| acos                     | Unary      | Numeric            | Numeric             |\n++--------------------------+------------+--------------------+---------------------+\n | add                      | Binary     | Numeric            | Numeric (1)         |\n +--------------------------+------------+--------------------+---------------------+\n | add_checked              | Binary     | Numeric            | Numeric (1)         |\n +--------------------------+------------+--------------------+---------------------+\n+| asin                     | Unary      | Numeric            | Numeric             |\n\nReview comment:\n       I would put then in a separate table with the trigonometric kernels grouped (IMO that will be easier to keep somewhat the overview on this page)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-22T11:50:25.310+0000",
                    "updated": "2021-06-22T11:50:25.310+0000",
                    "started": "2021-06-22T11:50:25.310+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "613439",
                    "issueId": "13384190"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384190/worklog/614301",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #10544:\nURL: https://github.com/apache/arrow/pull/10544#discussion_r657566805\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -224,19 +228,19 @@ struct Multiply {\n   static_assert(std::is_same<decltype(int64_t() * int64_t()), int64_t>::value, \"\");\n   static_assert(std::is_same<decltype(uint64_t() * uint64_t()), uint64_t>::value, \"\");\n \n-  template <typename T>\n+  template <typename T, typename Arg0, typename Arg1>\n   static constexpr enable_if_floating_point<T> Call(KernelContext*, T left, T right,\n                                                     Status*) {\n     return left * right;\n   }\n \n-  template <typename T>\n+  template <typename T, typename Arg0, typename Arg1>\n   static constexpr enable_if_unsigned_integer<T> Call(KernelContext*, T left, T right,\n                                                       Status*) {\n     return left * right;\n   }\n \n-  template <typename T>\n+  template <typename T, typename Arg0, typename Arg1>\n   static constexpr enable_if_signed_integer<T> Call(KernelContext*, T left, T right,\n                                                     Status*) {\n     return to_unsigned(left) * to_unsigned(right);\n\nReview comment:\n       Need to fix UB error\r\n   https://github.com/apache/arrow/pull/10544/checks?check_run_id=2885532059#step:8:2285\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-24T01:45:19.241+0000",
                    "updated": "2021-06-24T01:45:19.241+0000",
                    "started": "2021-06-24T01:45:19.241+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "614301",
                    "issueId": "13384190"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384190/worklog/614302",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #10544:\nURL: https://github.com/apache/arrow/pull/10544#discussion_r657572298\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -224,19 +228,19 @@ struct Multiply {\n   static_assert(std::is_same<decltype(int64_t() * int64_t()), int64_t>::value, \"\");\n   static_assert(std::is_same<decltype(uint64_t() * uint64_t()), uint64_t>::value, \"\");\n \n-  template <typename T>\n+  template <typename T, typename Arg0, typename Arg1>\n   static constexpr enable_if_floating_point<T> Call(KernelContext*, T left, T right,\n                                                     Status*) {\n     return left * right;\n   }\n \n-  template <typename T>\n+  template <typename T, typename Arg0, typename Arg1>\n   static constexpr enable_if_unsigned_integer<T> Call(KernelContext*, T left, T right,\n                                                       Status*) {\n     return left * right;\n   }\n \n-  template <typename T>\n+  template <typename T, typename Arg0, typename Arg1>\n   static constexpr enable_if_signed_integer<T> Call(KernelContext*, T left, T right,\n                                                     Status*) {\n     return to_unsigned(left) * to_unsigned(right);\n\nReview comment:\n       Looks not related to this patch?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-24T02:03:03.589+0000",
                    "updated": "2021-06-24T02:03:03.589+0000",
                    "started": "2021-06-24T02:03:03.589+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "614302",
                    "issueId": "13384190"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384190/worklog/614307",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #10544:\nURL: https://github.com/apache/arrow/pull/10544#discussion_r657575451\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -224,19 +228,19 @@ struct Multiply {\n   static_assert(std::is_same<decltype(int64_t() * int64_t()), int64_t>::value, \"\");\n   static_assert(std::is_same<decltype(uint64_t() * uint64_t()), uint64_t>::value, \"\");\n \n-  template <typename T>\n+  template <typename T, typename Arg0, typename Arg1>\n   static constexpr enable_if_floating_point<T> Call(KernelContext*, T left, T right,\n                                                     Status*) {\n     return left * right;\n   }\n \n-  template <typename T>\n+  template <typename T, typename Arg0, typename Arg1>\n   static constexpr enable_if_unsigned_integer<T> Call(KernelContext*, T left, T right,\n                                                       Status*) {\n     return left * right;\n   }\n \n-  template <typename T>\n+  template <typename T, typename Arg0, typename Arg1>\n   static constexpr enable_if_signed_integer<T> Call(KernelContext*, T left, T right,\n                                                     Status*) {\n     return to_unsigned(left) * to_unsigned(right);\n\nReview comment:\n       I think it's because the template parameters are changed. The specialized int16 code path (defined after this function) is not called due to this change.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-24T02:13:24.589+0000",
                    "updated": "2021-06-24T02:13:24.589+0000",
                    "started": "2021-06-24T02:13:24.589+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "614307",
                    "issueId": "13384190"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384190/worklog/614308",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #10544:\nURL: https://github.com/apache/arrow/pull/10544#discussion_r657572298\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -224,19 +228,19 @@ struct Multiply {\n   static_assert(std::is_same<decltype(int64_t() * int64_t()), int64_t>::value, \"\");\n   static_assert(std::is_same<decltype(uint64_t() * uint64_t()), uint64_t>::value, \"\");\n \n-  template <typename T>\n+  template <typename T, typename Arg0, typename Arg1>\n   static constexpr enable_if_floating_point<T> Call(KernelContext*, T left, T right,\n                                                     Status*) {\n     return left * right;\n   }\n \n-  template <typename T>\n+  template <typename T, typename Arg0, typename Arg1>\n   static constexpr enable_if_unsigned_integer<T> Call(KernelContext*, T left, T right,\n                                                       Status*) {\n     return left * right;\n   }\n \n-  template <typename T>\n+  template <typename T, typename Arg0, typename Arg1>\n   static constexpr enable_if_signed_integer<T> Call(KernelContext*, T left, T right,\n                                                     Status*) {\n     return to_unsigned(left) * to_unsigned(right);\n\nReview comment:\n       Looks not related to this patch?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-24T02:13:47.707+0000",
                    "updated": "2021-06-24T02:13:47.707+0000",
                    "started": "2021-06-24T02:13:47.707+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "614308",
                    "issueId": "13384190"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384190/worklog/614488",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10544:\nURL: https://github.com/apache/arrow/pull/10544#discussion_r657924667\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -224,19 +228,19 @@ struct Multiply {\n   static_assert(std::is_same<decltype(int64_t() * int64_t()), int64_t>::value, \"\");\n   static_assert(std::is_same<decltype(uint64_t() * uint64_t()), uint64_t>::value, \"\");\n \n-  template <typename T>\n+  template <typename T, typename Arg0, typename Arg1>\n   static constexpr enable_if_floating_point<T> Call(KernelContext*, T left, T right,\n                                                     Status*) {\n     return left * right;\n   }\n \n-  template <typename T>\n+  template <typename T, typename Arg0, typename Arg1>\n   static constexpr enable_if_unsigned_integer<T> Call(KernelContext*, T left, T right,\n                                                       Status*) {\n     return left * right;\n   }\n \n-  template <typename T>\n+  template <typename T, typename Arg0, typename Arg1>\n   static constexpr enable_if_signed_integer<T> Call(KernelContext*, T left, T right,\n                                                     Status*) {\n     return to_unsigned(left) * to_unsigned(right);\n\nReview comment:\n       Thanks for digging into this. I updated the templates here so that the specialization is called again.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-24T13:00:21.873+0000",
                    "updated": "2021-06-24T13:00:21.873+0000",
                    "started": "2021-06-24T13:00:21.873+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "614488",
                    "issueId": "13384190"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384190/worklog/614820",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on pull request #10544:\nURL: https://github.com/apache/arrow/pull/10544#issuecomment-868170085\n\n\n   @edponce @jorisvandenbossche do you have other comments?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-25T03:10:47.599+0000",
                    "updated": "2021-06-25T03:10:47.599+0000",
                    "started": "2021-06-25T03:10:47.598+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "614820",
                    "issueId": "13384190"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384190/worklog/614823",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "edponce commented on a change in pull request #10544:\nURL: https://github.com/apache/arrow/pull/10544#discussion_r658451649\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -454,6 +462,200 @@ struct PowerChecked {\n   }\n };\n \n+struct Sin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return sin(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return sin(val);\n\nReview comment:\n       Use *std::sin* and friends to be consistent and be clear that this is not an Arrow function (or is it?).\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-25T03:38:26.429+0000",
                    "updated": "2021-06-25T03:38:26.429+0000",
                    "started": "2021-06-25T03:38:26.429+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "614823",
                    "issueId": "13384190"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384190/worklog/614824",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "edponce commented on a change in pull request #10544:\nURL: https://github.com/apache/arrow/pull/10544#discussion_r658451649\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -454,6 +462,200 @@ struct PowerChecked {\n   }\n };\n \n+struct Sin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return sin(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return sin(val);\n\nReview comment:\n       Use `std::sin` and friends to be consistent and be clear that this is not an Arrow function (or is it?).\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-25T03:38:41.003+0000",
                    "updated": "2021-06-25T03:38:41.003+0000",
                    "started": "2021-06-25T03:38:41.002+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "614824",
                    "issueId": "13384190"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384190/worklog/614825",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "edponce commented on a change in pull request #10544:\nURL: https://github.com/apache/arrow/pull/10544#discussion_r658457205\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -454,6 +462,200 @@ struct PowerChecked {\n   }\n };\n \n+struct Sin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return sin(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return sin(val);\n+  }\n+};\n+\n+struct SinChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return sin(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE(std::isinf(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return sin(val);\n+  }\n+};\n+\n+struct Cos {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return cos(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return cos(val);\n+  }\n+};\n+\n+struct CosChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return cos(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE(std::isinf(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return cos(val);\n+  }\n+};\n+\n+struct Tan {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return tan(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return tan(val);\n+  }\n+};\n+\n+struct TanChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return tan(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE(std::isinf(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    // Cannot raise range errors (overflow) since PI/2 is not exactly representable\n+    return tan(val);\n+  }\n+};\n+\n+struct Asin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::asin(val);\n+  }\n+};\n+\n+struct AsinChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE(!std::isnan(val) && (val < -1.0 || val > 1.0))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::asin(val);\n+  }\n+};\n+\n+struct Acos {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::acos(val);\n+  }\n+};\n+\n+struct AcosChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE(!std::isnan(val) && (val < -1.0 || val > 1.0))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::acos(val);\n+  }\n+};\n+\n+struct Atan {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::atan(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::atan(val);\n+  }\n+};\n+\n+struct Atan2 {\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    // Explicitly mimic what IEEE754 does (atan(0, 0) == 0) if needed\n+    if (!std::numeric_limits<T>::is_iec559 && y == 0 && x == 0) return 0;\n\nReview comment:\n       After more thorough thinking, I consider it is safe to remove the \"zero check\" condition because 99% of CPUs adhere to 99% of IEEE 754, so based on the C++ standard the resulting value from `atan2(0,0)` will be correct. If you feel that we should keep it, I am fine with that too. Apologies for the back and forth on this detail. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-25T03:58:38.821+0000",
                    "updated": "2021-06-25T03:58:38.821+0000",
                    "started": "2021-06-25T03:58:38.821+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "614825",
                    "issueId": "13384190"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384190/worklog/614910",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "edponce commented on a change in pull request #10544:\nURL: https://github.com/apache/arrow/pull/10544#discussion_r658603719\n\n\n\n##########\nFile path: docs/source/cpp/compute.rst\n##########\n@@ -312,6 +312,40 @@ precision of `divide` is at least the sum of precisions of both operands with\n enough scale kept. Error is returned if the result precision is beyond the\n decimal value range.\n \n+Trigonometric functions are also supported, and also offer ``_checked``\n+variants that check for domain errors if needed.\n\nReview comment:\n       Should we add a `Trigonometric functions` subsection? Even though they are arithmetic functions, this will add a link in docs for quick access.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-25T08:53:15.045+0000",
                    "updated": "2021-06-25T08:53:15.045+0000",
                    "started": "2021-06-25T08:53:15.045+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "614910",
                    "issueId": "13384190"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384190/worklog/614974",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10544:\nURL: https://github.com/apache/arrow/pull/10544#discussion_r658739906\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -454,6 +462,200 @@ struct PowerChecked {\n   }\n };\n \n+struct Sin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return sin(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return sin(val);\n\nReview comment:\n       Whoops, not sure why it even lets me call that without std::. Fixed.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-25T12:52:44.937+0000",
                    "updated": "2021-06-25T12:52:44.937+0000",
                    "started": "2021-06-25T12:52:44.937+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "614974",
                    "issueId": "13384190"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384190/worklog/614976",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10544:\nURL: https://github.com/apache/arrow/pull/10544#discussion_r658740109\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -454,6 +462,200 @@ struct PowerChecked {\n   }\n };\n \n+struct Sin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return sin(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return sin(val);\n+  }\n+};\n+\n+struct SinChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return sin(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE(std::isinf(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return sin(val);\n+  }\n+};\n+\n+struct Cos {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return cos(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return cos(val);\n+  }\n+};\n+\n+struct CosChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return cos(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE(std::isinf(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return cos(val);\n+  }\n+};\n+\n+struct Tan {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return tan(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return tan(val);\n+  }\n+};\n+\n+struct TanChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return tan(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE(std::isinf(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    // Cannot raise range errors (overflow) since PI/2 is not exactly representable\n+    return tan(val);\n+  }\n+};\n+\n+struct Asin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::asin(val);\n+  }\n+};\n+\n+struct AsinChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE(!std::isnan(val) && (val < -1.0 || val > 1.0))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::asin(val);\n+  }\n+};\n+\n+struct Acos {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::acos(val);\n+  }\n+};\n+\n+struct AcosChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::acos(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE(!std::isnan(val) && (val < -1.0 || val > 1.0))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::acos(val);\n+  }\n+};\n+\n+struct Atan {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::atan(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::atan(val);\n+  }\n+};\n+\n+struct Atan2 {\n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 y, Arg1 x, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    static_assert(std::is_same<Arg0, Arg1>::value, \"\");\n+    // Explicitly mimic what IEEE754 does (atan(0, 0) == 0) if needed\n+    if (!std::numeric_limits<T>::is_iec559 && y == 0 && x == 0) return 0;\n\nReview comment:\n       I've decided to remove it then. The tests will catch if a platform doesn't support that.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-25T12:53:01.361+0000",
                    "updated": "2021-06-25T12:53:01.361+0000",
                    "started": "2021-06-25T12:53:01.361+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "614976",
                    "issueId": "13384190"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384190/worklog/614977",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10544:\nURL: https://github.com/apache/arrow/pull/10544#discussion_r658740181\n\n\n\n##########\nFile path: docs/source/cpp/compute.rst\n##########\n@@ -312,6 +312,40 @@ precision of `divide` is at least the sum of precisions of both operands with\n enough scale kept. Error is returned if the result precision is beyond the\n decimal value range.\n \n+Trigonometric functions are also supported, and also offer ``_checked``\n+variants that check for domain errors if needed.\n\nReview comment:\n       I went ahead and added a subsection.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-25T12:53:15.685+0000",
                    "updated": "2021-06-25T12:53:15.685+0000",
                    "started": "2021-06-25T12:53:15.684+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "614977",
                    "issueId": "13384190"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384190/worklog/615635",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #10544:\nURL: https://github.com/apache/arrow/pull/10544#discussion_r659837706\n\n\n\n##########\nFile path: cpp/src/arrow/compute/api_scalar.h\n##########\n@@ -298,6 +298,68 @@ Result<Datum> Power(const Datum& left, const Datum& right,\n                     ArithmeticOptions options = ArithmeticOptions(),\n                     ExecContext* ctx = NULLPTR);\n \n+/// \\brief Compute the sine of the array values.\n+/// \\param[in] arg The values to compute the sine for.\n+/// \\param[in] options arithmetic options (enable/disable overflow checking), optional\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the elementwise sine of the values\n+ARROW_EXPORT\n+Result<Datum> Sin(const Datum& arg, ArithmeticOptions options = ArithmeticOptions(),\n+                  ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Compute the cosine of the array values.\n+/// \\param[in] arg The values to compute the cosine for.\n+/// \\param[in] options arithmetic options (enable/disable overflow checking), optional\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the elementwise cosine of the values\n+ARROW_EXPORT\n+Result<Datum> Cos(const Datum& arg, ArithmeticOptions options = ArithmeticOptions(),\n+                  ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Compute the inverse sine (arcsine) of the array values.\n+/// \\param[in] arg The values to compute the inverse sine for.\n+/// \\param[in] options arithmetic options (enable/disable overflow checking), optional\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the elementwise inverse sine of the values\n+ARROW_EXPORT\n+Result<Datum> Asin(const Datum& arg, ArithmeticOptions options = ArithmeticOptions(),\n+                   ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Compute the inverse cosine (arccosine) of the array values.\n+/// \\param[in] arg The values to compute the inverse cosine for.\n+/// \\param[in] options arithmetic options (enable/disable overflow checking), optional\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the elementwise inverse cosine of the values\n+ARROW_EXPORT\n+Result<Datum> Acos(const Datum& arg, ArithmeticOptions options = ArithmeticOptions(),\n+                   ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Compute the tangent of the array values.\n+/// \\param[in] arg The values to compute the tangent for.\n+/// \\param[in] options arithmetic options (enable/disable overflow checking), optional\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the elementwise tangent of the values\n+ARROW_EXPORT\n+Result<Datum> Tan(const Datum& arg, ArithmeticOptions options = ArithmeticOptions(),\n+                  ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Compute the inverse tangent (arctangent) of the array values.\n+/// \\param[in] arg The values to compute the inverse tangent for.\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the elementwise inverse tangent of the values\n+ARROW_EXPORT\n+Result<Datum> Atan(const Datum& arg, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Compute the inverse tangent (arctangent) of the array\n+/// values, using the argument signs to determine the correct\n+/// quadrant.\n\nReview comment:\n       This docstring should be more explicit about what `y` and `x` are for.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic_test.cc\n##########\n@@ -1511,5 +1530,117 @@ TEST(TestBinaryArithmeticDecimal, Divide) {\n   }\n }\n \n+TYPED_TEST(TestUnaryArithmeticFloating, TrigSin) {\n+  this->SetNansEqual(true);\n+  for (auto check_overflow : {false, true}) {\n+    this->SetOverflowCheck(check_overflow);\n+    this->AssertUnaryOp(Sin, \"[]\", \"[]\");\n+    this->AssertUnaryOp(Sin, \"[null, NaN]\", \"[null, NaN]\");\n+    this->AssertUnaryOp(Sin, MakeArray(0, M_PI_2, M_PI), \"[0, 1, 0]\");\n+  }\n+  this->AssertUnaryOpRaises(Sin, \"[Inf, -Inf]\", \"domain error\");\n+}\n+\n+TYPED_TEST(TestUnaryArithmeticFloating, TrigCos) {\n+  this->SetNansEqual(true);\n+  for (auto check_overflow : {false, true}) {\n+    this->SetOverflowCheck(check_overflow);\n+    this->AssertUnaryOp(Cos, \"[]\", \"[]\");\n+    this->AssertUnaryOp(Cos, \"[null, NaN]\", \"[null, NaN]\");\n+    this->AssertUnaryOp(Cos, MakeArray(0, M_PI_2, M_PI), \"[1, 0, -1]\");\n+  }\n+  this->AssertUnaryOpRaises(Cos, \"[Inf, -Inf]\", \"domain error\");\n+}\n+\n+TYPED_TEST(TestUnaryArithmeticFloating, TrigTan) {\n+  this->SetNansEqual(true);\n+  for (auto check_overflow : {false, true}) {\n+    this->SetOverflowCheck(check_overflow);\n+    this->AssertUnaryOp(Tan, \"[]\", \"[]\");\n+    this->AssertUnaryOp(Tan, \"[null, NaN]\", \"[null, NaN]\");\n+    // N.B. pi/2 isn't representable exactly -> there are no poles\n+    // (i.e. tan(pi/2) is merely a large value and not +Inf)\n+    this->AssertUnaryOp(Tan, MakeArray(0, M_PI), \"[0, 0]\");\n+  }\n+  this->AssertUnaryOpRaises(Tan, \"[Inf, -Inf]\", \"domain error\");\n+}\n+\n+TYPED_TEST(TestUnaryArithmeticFloating, TrigAsin) {\n+  this->SetNansEqual(true);\n+  for (auto check_overflow : {false, true}) {\n+    this->SetOverflowCheck(check_overflow);\n+    this->AssertUnaryOp(Asin, \"[]\", \"[]\");\n+    this->AssertUnaryOp(Asin, \"[null, NaN]\", \"[null, NaN]\");\n+    this->AssertUnaryOp(Asin, \"[0, 1, -1]\", MakeArray(0, M_PI_2, -M_PI_2));\n+  }\n+  this->AssertUnaryOpRaises(Asin, \"[Inf, -Inf, -2, 2]\", \"domain error\");\n+}\n+\n+TYPED_TEST(TestUnaryArithmeticFloating, TrigAcos) {\n+  this->SetNansEqual(true);\n+  for (auto check_overflow : {false, true}) {\n+    this->SetOverflowCheck(check_overflow);\n+    this->AssertUnaryOp(Acos, \"[]\", \"[]\");\n+    this->AssertUnaryOp(Acos, \"[null, NaN]\", \"[null, NaN]\");\n+    this->AssertUnaryOp(Acos, \"[0, 1, -1]\", MakeArray(M_PI_2, 0, M_PI));\n+  }\n+  this->AssertUnaryOpRaises(Acos, \"[Inf, -Inf, -2, 2]\", \"domain error\");\n+}\n+\n+TYPED_TEST(TestUnaryArithmeticFloating, TrigAtan) {\n+  this->SetNansEqual(true);\n+  auto atan = [](const Datum& arg, ArithmeticOptions, ExecContext* ctx) {\n+    return Atan(arg, ctx);\n+  };\n+  this->AssertUnaryOp(atan, \"[]\", \"[]\");\n+  this->AssertUnaryOp(atan, \"[null, NaN]\", \"[null, NaN]\");\n+  this->AssertUnaryOp(atan, \"[0, 1, -1, Inf, -Inf]\",\n+                      MakeArray(0, M_PI_4, -M_PI_4, M_PI_2, -M_PI_2));\n+}\n+\n+TYPED_TEST(TestBinaryArithmeticFloating, TrigAtan2) {\n+  this->SetNansEqual(true);\n+  auto atan2 = [](const Datum& y, const Datum& x, ArithmeticOptions, ExecContext* ctx) {\n+    return Atan2(y, x, ctx);\n+  };\n+  this->AssertBinop(atan2, \"[]\", \"[]\", \"[]\");\n+  this->AssertBinop(atan2, \"[0, 0, null, NaN]\", \"[null, NaN, 0, 0]\",\n+                    \"[null, NaN, null, NaN]\");\n+  this->AssertBinop(atan2, \"[0, 0, -0.0, 0, -0.0, 0, 1, 0, -1, Inf, -Inf, 0, 0]\",\n+                    \"[0, 0, 0, -0.0, -0.0, 1, 0, -1, 0, 0, 0, Inf, -Inf]\",\n+                    MakeArray(0, 0, -0.0, M_PI, -M_PI, 0, M_PI_2, M_PI, -M_PI_2, M_PI_2,\n+                              -M_PI_2, 0, M_PI));\n+}\n+\n+TYPED_TEST(TestUnaryArithmeticIntegral, Trig) {\n\nReview comment:\n       Is this testing an implicitly cast version of the kernel? It doesn't seem very useful to compute trigonometric functions on integers.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -454,6 +462,191 @@ struct PowerChecked {\n   }\n };\n \n+struct Sin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n\nReview comment:\n       As mentioned elsewhere, I don't think it's useful to expose integer-accepting versions of these kernels.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -820,6 +1081,80 @@ const FunctionDoc pow_checked_doc{\n     (\"An error is returned when integer to negative integer power is encountered,\\n\"\n      \"or integer overflow is encountered.\"),\n     {\"base\", \"exponent\"}};\n+\n+const FunctionDoc sin_doc{\"Computes the sine of the elements argument-wise\",\n\nReview comment:\n       Other docstrings use infinitive / imperative instead of present, such as \"Compute the sine of the arguments element-wise\".\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic_test.cc\n##########\n@@ -1511,5 +1530,117 @@ TEST(TestBinaryArithmeticDecimal, Divide) {\n   }\n }\n \n+TYPED_TEST(TestUnaryArithmeticFloating, TrigSin) {\n+  this->SetNansEqual(true);\n+  for (auto check_overflow : {false, true}) {\n+    this->SetOverflowCheck(check_overflow);\n+    this->AssertUnaryOp(Sin, \"[]\", \"[]\");\n+    this->AssertUnaryOp(Sin, \"[null, NaN]\", \"[null, NaN]\");\n+    this->AssertUnaryOp(Sin, MakeArray(0, M_PI_2, M_PI), \"[0, 1, 0]\");\n+  }\n+  this->AssertUnaryOpRaises(Sin, \"[Inf, -Inf]\", \"domain error\");\n\nReview comment:\n       This is for the checked variant, but what happens for the non-checked variant? Return `NaN`?\n\n##########\nFile path: docs/source/python/api/compute.rst\n##########\n@@ -59,6 +59,28 @@ throws an ``ArrowInvalid`` exception when overflow is detected.\n    power\n    power_checked\n \n+Trigonometric Functions\n+-----------------------\n+\n+Trigonometric functions are also supported, and also offer ``_checked``\n+variants which detect domain and range errors where appropriate.\n\nReview comment:\n       Are range errors actually detected?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -454,6 +462,191 @@ struct PowerChecked {\n   }\n };\n \n+struct Sin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::sin(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::sin(val);\n+  }\n+};\n+\n+struct SinChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::sin(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE(std::isinf(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::sin(val);\n+  }\n+};\n+\n+struct Cos {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::cos(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::cos(val);\n+  }\n+};\n+\n+struct CosChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::cos(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE(std::isinf(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::cos(val);\n+  }\n+};\n+\n+struct Tan {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::tan(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::tan(val);\n+  }\n+};\n+\n+struct TanChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::tan(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE(std::isinf(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    // Cannot raise range errors (overflow) since PI/2 is not exactly representable\n+    return std::tan(val);\n+  }\n+};\n+\n+struct Asin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::asin(val);\n+  }\n+};\n+\n+struct AsinChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE(!std::isnan(val) && (val < -1.0 || val > 1.0))) {\n\nReview comment:\n       Is the NaN check necessary? NaNs should typically fail those comparisons, AFAIU.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -454,6 +462,191 @@ struct PowerChecked {\n   }\n };\n \n+struct Sin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::sin(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::sin(val);\n+  }\n+};\n+\n+struct SinChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::sin(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE(std::isinf(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::sin(val);\n+  }\n+};\n+\n+struct Cos {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::cos(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::cos(val);\n+  }\n+};\n+\n+struct CosChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::cos(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE(std::isinf(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::cos(val);\n+  }\n+};\n+\n+struct Tan {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::tan(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::tan(val);\n+  }\n+};\n+\n+struct TanChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::tan(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE(std::isinf(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    // Cannot raise range errors (overflow) since PI/2 is not exactly representable\n\nReview comment:\n       Well, you could call `std::isinf` on the result?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-28T14:43:33.607+0000",
                    "updated": "2021-06-28T14:43:33.607+0000",
                    "started": "2021-06-28T14:43:33.606+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "615635",
                    "issueId": "13384190"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384190/worklog/615694",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10544:\nURL: https://github.com/apache/arrow/pull/10544#discussion_r659975493\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_arithmetic.cc\n##########\n@@ -454,6 +462,191 @@ struct PowerChecked {\n   }\n };\n \n+struct Sin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::sin(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::sin(val);\n+  }\n+};\n+\n+struct SinChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::sin(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE(std::isinf(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::sin(val);\n+  }\n+};\n+\n+struct Cos {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::cos(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::cos(val);\n+  }\n+};\n+\n+struct CosChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::cos(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE(std::isinf(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    return std::cos(val);\n+  }\n+};\n+\n+struct Tan {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::tan(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::tan(val);\n+  }\n+};\n+\n+struct TanChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::tan(val);\n+  }\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE(std::isinf(val))) {\n+      *st = Status::Invalid(\"domain error\");\n+      return val;\n+    }\n+    // Cannot raise range errors (overflow) since PI/2 is not exactly representable\n+    return std::tan(val);\n+  }\n+};\n+\n+struct Asin {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    return std::asin(val);\n+  }\n+};\n+\n+struct AsinChecked {\n+  template <typename T, typename Arg0>\n+  static enable_if_integer<Arg0, T> Call(KernelContext*, Arg0 val, Status*) {\n+    static_assert(std::is_same<T, double>::value, \"\");\n+    return std::asin(val);\n+  }\n+\n+  template <typename T, typename Arg0>\n+  static enable_if_floating_point<Arg0, T> Call(KernelContext*, Arg0 val, Status* st) {\n+    static_assert(std::is_same<T, Arg0>::value, \"\");\n+    if (ARROW_PREDICT_FALSE(!std::isnan(val) && (val < -1.0 || val > 1.0))) {\n\nReview comment:\n       As Eduardo points out above, C++ doesn't guarantee any particular behavior. But we're essentially already assuming IEE754 conformance here in which case the check is redundant.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-28T17:21:30.067+0000",
                    "updated": "2021-06-28T17:21:30.067+0000",
                    "started": "2021-06-28T17:21:30.066+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "615694",
                    "issueId": "13384190"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 16200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@7b06c353[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3b194871[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6f6a47c6[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@1e41d09a[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@39242221[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@43c176c0[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7ea84d09[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@6e7d9746[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@76509582[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@3eef8afe[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@293482f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@56389c[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 16200,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Jun 30 16:30:47 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-06-30T16:30:47.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13095/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2021-06-16T15:50:12.000+0000",
        "updated": "2021-06-30T16:31:02.000+0000",
        "timeoriginalestimate": null,
        "description": "sin, cos, asin, acos, tan, atan, cotan, atan2",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "4.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 16200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Implement trigonometric compute functions",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384190/comment/17372107",
                    "id": "17372107",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 10544\n[https://github.com/apache/arrow/pull/10544]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-06-30T16:30:47.618+0000",
                    "updated": "2021-06-30T16:30:47.618+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0s0j4:",
        "customfield_12314139": null
    }
}