{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13201194",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194",
    "key": "ARROW-3897",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12344925",
                "id": "12344925",
                "description": "",
                "name": "0.14.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-07-04"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": 172800,
        "timeestimate": 138000,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=kgurney",
            "name": "kgurney",
            "key": "kgurney",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Kevin Gurney",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12334213",
                "id": "12334213",
                "name": "MATLAB"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 138000,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=rdmello",
            "name": "rdmello",
            "key": "rdmello",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=rdmello&avatarId=37707",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=rdmello&avatarId=37707",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=rdmello&avatarId=37707",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=rdmello&avatarId=37707"
            },
            "displayName": "Rylan Dmello",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=rdmello",
            "name": "rdmello",
            "key": "rdmello",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=rdmello&avatarId=37707",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=rdmello&avatarId=37707",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=rdmello&avatarId=37707",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=rdmello&avatarId=37707"
            },
            "displayName": "Rylan Dmello",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 34800,
            "total": 172800,
            "percent": 20
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 34800,
            "total": 172800,
            "percent": 20
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3897/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 62,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194/worklog/243571",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kevingurney commented on pull request #4328: ARROW-3897: [MATLAB] Add MATLAB support for writing numeric datatypes to a Feather file\nURL: https://github.com/apache/arrow/pull/4328\n \n \n   **Writing Feather Files**\r\n   - Currently the MATLAB interface to Feather supports reading numeric datatypes (`double`, `single`, `uint*` and `int*`) from Feather files using the `featherread` function.\r\n   - This pull request adds a `featherwrite` function to serialize a MATLAB `table` containing numeric datatypes to a Feather file.\r\n   \r\n   **Testing**\r\n   - Removed binary Feather files used for testing and replaced them with temporary files generated during test execution by `featherwrite`.\r\n   - Added additional test cases to improve code coverage.\r\n   \r\n   **Notes**\r\n   - A preliminary code review was performed in https://github.com/mathworks/arrow/pull/6. I saw the discussion on https://github.com/apache/arrow/pull/4321 about conducting code reviews directly in apache/arrow following https://apache.org/theapacheway/. I'll be sure to  do code reviews directly in apache/arrow moving forward.\r\n   - This pull request contains a lot of changes. My apologies for this. Our intent was to refactor the reading and writing code and improve code coverage, but we should have isolated these changes into separate patches/JIRA issues. We'll be more thoughtful about breaking our submissions into small, single purpose patches in the future.\r\n   - This pull request includes contributions from @rdmello and @sihuiliu. Thanks!\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-16T18:49:52.857+0000",
                    "updated": "2019-05-16T18:49:52.857+0000",
                    "started": "2019-05-16T18:49:52.857+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "243571",
                    "issueId": "13201194"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194/worklog/244311",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4328: ARROW-3897: [MATLAB] Add MATLAB support for writing numeric datatypes to a Feather file\nURL: https://github.com/apache/arrow/pull/4328#discussion_r285279464\n \n \n\n ##########\n File path: matlab/src/feather_reader.cc\n ##########\n @@ -102,34 +111,93 @@ mxArray* ReadVariableData(const std::shared_ptr<arrow::Column>& column) {\n   return nullptr;\n }\n \n-// Read the nulls of variable i from the Feather file as a mxArray*.\n-mxArray* ReadVariableNulls(const std::shared_ptr<arrow::Column>& column) {\n-  // TODO: Implement proper null value support. For the time being,\n-  // we will simply return a zero initialized logical array to MATLAB.\n-  return mxCreateLogicalMatrix(column->length(), 1);\n+// arrow::Buffers are bit-packed, while mxLogical arrays aren't. This utility\n+// uses arrow::BitUtil::GetBit to copy each bit of an arrow::Buffer into\n+// each byte of an mxLogical array.\n+void BitUnpackBuffer(const std::shared_ptr<arrow::Buffer>& source, const int64_t length,\n+                     bool* destination) {\n \n Review comment:\n   Is `int8_t*` or `uint8_t*` more appropriate here?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-17T21:29:44.957+0000",
                    "updated": "2019-05-17T21:29:44.957+0000",
                    "started": "2019-05-17T21:29:44.957+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "244311",
                    "issueId": "13201194"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194/worklog/244312",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4328: ARROW-3897: [MATLAB] Add MATLAB support for writing numeric datatypes to a Feather file\nURL: https://github.com/apache/arrow/pull/4328#discussion_r285281003\n \n \n\n ##########\n File path: matlab/src/feather_reader.cc\n ##########\n @@ -102,34 +111,93 @@ mxArray* ReadVariableData(const std::shared_ptr<arrow::Column>& column) {\n   return nullptr;\n }\n \n-// Read the nulls of variable i from the Feather file as a mxArray*.\n-mxArray* ReadVariableNulls(const std::shared_ptr<arrow::Column>& column) {\n-  // TODO: Implement proper null value support. For the time being,\n-  // we will simply return a zero initialized logical array to MATLAB.\n-  return mxCreateLogicalMatrix(column->length(), 1);\n+// arrow::Buffers are bit-packed, while mxLogical arrays aren't. This utility\n+// uses arrow::BitUtil::GetBit to copy each bit of an arrow::Buffer into\n+// each byte of an mxLogical array.\n+void BitUnpackBuffer(const std::shared_ptr<arrow::Buffer>& source, const int64_t length,\n+                     bool* destination) {\n+\n+  // If the arrow::Buffer's null_bitmap pointer is nullptr, then fill\n+  // the destination with values to signify valid elements.\n+  if (!source) {\n+    std::fill(destination, destination + length, true);\n+    return;\n+  }\n+\n+  const uint8_t* source_data = source->data();\n+\n+  // Unpack the bit-packed validity (null) bitmap.\n+  for (int64_t i = 0; i < length; ++i) {\n+    // Here arrow::BitUtil::GetBit will return an expanded 8-bit bool representation \n+    // of a single bit in the validity bitmap.\n+    destination[i] = arrow::BitUtil::GetBit(source_data, i);\n \n Review comment:\n   I would suggest a loop-unrolled bit unpack for much better performance. You can do this as follow up work of course (please open a JIRA issue if so). So basically going one byte at a time and writing code like\r\n   \r\n   ```\r\n   destination[iter] = byte & 1\r\n   destination[iter + 1] = byte & 2\r\n   destination[iter + 2] = byte & 4\r\n   destination[iter + 3] = byte & 8\r\n   destination[iter + 4] = byte & 16\r\n   destination[iter + 5] = byte & 32\r\n   destination[iter + 6] = byte & 64\r\n   destination[iter + 7] = byte & 128\r\n   ```\r\n   \r\n   We might have some stuff like this already. I note that we aren't even following my own advice in \r\n   \r\n   https://github.com/apache/arrow/blob/master/cpp/src/arrow/python/arrow_to_pandas.cc#L369\r\n   \r\n   What do you think about moving this utility code to someplace in the main Arrow C++ codebase? There's probably some other places we can use it.\r\n   \r\n   cc @pitrou \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-17T21:29:45.173+0000",
                    "updated": "2019-05-17T21:29:45.173+0000",
                    "started": "2019-05-17T21:29:45.168+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "244312",
                    "issueId": "13201194"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194/worklog/244313",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4328: ARROW-3897: [MATLAB] Add MATLAB support for writing numeric datatypes to a Feather file\nURL: https://github.com/apache/arrow/pull/4328#discussion_r285281820\n \n \n\n ##########\n File path: matlab/src/feather_reader.cc\n ##########\n @@ -102,34 +111,93 @@ mxArray* ReadVariableData(const std::shared_ptr<arrow::Column>& column) {\n   return nullptr;\n }\n \n-// Read the nulls of variable i from the Feather file as a mxArray*.\n-mxArray* ReadVariableNulls(const std::shared_ptr<arrow::Column>& column) {\n-  // TODO: Implement proper null value support. For the time being,\n-  // we will simply return a zero initialized logical array to MATLAB.\n-  return mxCreateLogicalMatrix(column->length(), 1);\n+// arrow::Buffers are bit-packed, while mxLogical arrays aren't. This utility\n+// uses arrow::BitUtil::GetBit to copy each bit of an arrow::Buffer into\n+// each byte of an mxLogical array.\n+void BitUnpackBuffer(const std::shared_ptr<arrow::Buffer>& source, const int64_t length,\n+                     bool* destination) {\n+\n+  // If the arrow::Buffer's null_bitmap pointer is nullptr, then fill\n+  // the destination with values to signify valid elements.\n+  if (!source) {\n+    std::fill(destination, destination + length, true);\n+    return;\n+  }\n+\n+  const uint8_t* source_data = source->data();\n+\n+  // Unpack the bit-packed validity (null) bitmap.\n+  for (int64_t i = 0; i < length; ++i) {\n+    // Here arrow::BitUtil::GetBit will return an expanded 8-bit bool representation \n+    // of a single bit in the validity bitmap.\n+    destination[i] = arrow::BitUtil::GetBit(source_data, i);\n+  }\n+}\n+\n+// Read the validity (null) bitmap of variable i from the Feather\n+// file as an mxArray*.\n+mxArray* ReadVariableValidityBitmap(const std::shared_ptr<arrow::Column>& column) {\n+  // Allocate an mxLogical array to store the validity (null) bitmap values.\n+  // Note: All Arrow arrays can have an associated validity (null) bitmap.\n+  // The Apache Arrow specification defines 0 (false) to represent an\n+  // invalid (null) array entry and 1 (true) to represent a valid\n+  // (non-null) array entry.\n+  mxArray* validity_bitmap = mxCreateLogicalMatrix(column->length(), 1);\n+  bool* validity_bitmap_unpacked = static_cast<bool*>(mxGetLogicals(validity_bitmap));\n+\n+  // The Apache Arrow specification allows validity (null) bitmaps\n+  // to be unallocated if there are no null values. In this case,\n+  // we simply return a logical array filled with the value true.\n+  if (column->null_count() == 0) {\n+    std::fill(validity_bitmap_unpacked, validity_bitmap_unpacked + column->length(),\n+              true);\n+    return validity_bitmap;\n+  }\n+\n+  std::shared_ptr<arrow::ChunkedArray> chunked_array = column->data();\n+  const int32_t num_chunks = chunked_array->num_chunks();\n+\n+  int64_t mx_array_offset = 0;\n+  // Iterate over each arrow::Array in the arrow::ChunkedArray.\n+  for (int32_t chunk_index = 0; chunk_index < num_chunks; ++chunk_index) {\n+\n+    std::shared_ptr<arrow::Array> array = chunked_array->chunk(chunk_index);\n+    const int64_t array_length = array->length();\n+\n+    internal::BitUnpackBuffer(array->null_bitmap(), array_length,\n+                              validity_bitmap_unpacked + mx_array_offset);\n+\n+    mx_array_offset += array_length;\n+  }\n+\n+  return validity_bitmap;\n }\n \n-// Read the type of variable i from the Feather file as a mxArray*.\n+// Read the type name of an Arrow column as an mxChar array.\n mxArray* ReadVariableType(const std::shared_ptr<arrow::Column>& column) {\n-  return mxCreateString(column->type()->name().c_str());\n+  return mlarrow::util::ConvertUTF8StringToUTF16CharMatrix(column->type()->name());\n }\n \n-// MATLAB arrays cannot be larger than 2^48.\n+// MATLAB arrays cannot be larger than 2^48 elements.\n static constexpr uint64_t MAX_MATLAB_SIZE = static_cast<uint64_t>(0x01) << 48;\n \n }  // namespace internal\n \n arrow::Status FeatherReader::Open(const std::string& filename,\n                                   std::shared_ptr<FeatherReader>* feather_reader) {\n   *feather_reader = std::shared_ptr<FeatherReader>(new FeatherReader());\n+ \n   // Open file with given filename as a ReadableFile.\n   std::shared_ptr<arrow::io::ReadableFile> readable_file(nullptr);\n-  auto status = arrow::io::ReadableFile::Open(filename, &readable_file);\n+  \n+  arrow::Status status = arrow::io::ReadableFile::Open(filename, &readable_file);\n   if (!status.ok()) {\n     return status;\n   }\n \n Review comment:\n   hm, why not `RETURN_NOT_OK(...)`?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-17T21:29:45.341+0000",
                    "updated": "2019-05-17T21:29:45.341+0000",
                    "started": "2019-05-17T21:29:45.340+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "244313",
                    "issueId": "13201194"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194/worklog/244314",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4328: ARROW-3897: [MATLAB] Add MATLAB support for writing numeric datatypes to a Feather file\nURL: https://github.com/apache/arrow/pull/4328#discussion_r285282320\n \n \n\n ##########\n File path: matlab/src/feather_writer.cc\n ##########\n @@ -0,0 +1,365 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+#include <functional> /* for std::multiplies */\n+#include <numeric>    /* for std::accumulate */\n+\n+#include <arrow/array.h>\n+#include <arrow/buffer.h>\n+#include <arrow/io/file.h>\n+#include <arrow/ipc/feather.h>\n+#include <arrow/status.h>\n+#include <arrow/table.h>\n+#include <arrow/type.h>\n+#include <arrow/util/bit-util.h>\n+\n+#include <mex.h>\n+\n+#include \"feather_writer.h\"\n+#include \"matlab_traits.h\"\n+#include \"util/handle_status.h\"\n+\n+namespace mlarrow {\n+\n+namespace internal {\n+\n+// Utility that helps verify the input mxArray struct field name and type.\n+// Returns void since any errors will throw and terminate MEX execution.\n+void ValidateMxStructField(const mxArray* struct_array, const char* fieldname,\n+                           const mxClassID expected_class_id, const bool can_be_empty) {\n+  // Check that the input mxArray is a struct array.\n+  if (!mxIsStruct(struct_array)) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectDimensionsOrType\",\n+                      \"Input needs to be a struct array\");\n+  }\n+\n+  // Return early if an empty table is provided as input.\n+  if (mxIsEmpty(struct_array)) {\n+    return;\n+  }\n+\n+  mxArray* field = mxGetField(struct_array, 0, fieldname);\n+\n+  if (!field) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:MissingStructField\",\n+                      \"Missing field '%s' in input struct array\", fieldname);\n+  }\n+\n+  mxClassID actual_class_id = mxGetClassID(field);\n+\n+  // Avoid type check if an mxUNKNOWN_CLASS is provided since the UNKNOWN type is used to\n+  // signify genericity in the input type.\n+  if (expected_class_id != mxUNKNOWN_CLASS) {\n+    if (expected_class_id != actual_class_id) {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:MissingStructField\",\n+                        \"Incorrect type '%s' for struct array field '%s'\",\n+                        mxGetClassName(field), fieldname);\n+    }\n+  }\n+\n+  // Some struct fields (like the table description) can be empty, while others \n+  // (like NumRows) should never be empty. This conditional helps account for both cases.\n+  if (!can_be_empty) {\n+    // Ensure that individual mxStructArray fields are non-empty.\n+    // We can call mxGetData after this without needing another null check.\n+    if (mxIsEmpty(field)) {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:EmptyStructField\",\n+                        \"Struct array field '%s' cannot be empty\", fieldname);\n+    }\n+  }\n+}\n+\n+// Utility function to convert mxChar mxArray* to std::string while preserving\n+// Unicode code points.\n+std::string MxArrayToString(const mxArray* array) {\n+  // Return empty std::string if a mxChar array is not passed in.\n+  if (!mxIsChar(array)) {\n+    return std::string();\n+  }\n+\n+  // Convert mxArray first to a C-style char array, then copy into a std::string.\n+  char* utf8_array = mxArrayToUTF8String(array);\n+  std::string output(utf8_array);\n+\n+  // Free the allocated char* from the MEX runtime.\n+  mxFree(utf8_array);\n+\n+  return output;\n+}\n+\n+// Compare number of columns and exit out to the MATLAB layer if incorrect.\n+void ValidateNumColumns(int64_t actual, int64_t expected) {\n+  if (actual != expected) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectNumberOfColumns\",\n+                      \"Received only '%d' columns but expected '%d' columns\", actual,\n+                      expected);\n+  }\n+}\n+\n+// Compare number of rows and exit out to the MATLAB layer if incorrect.\n+void ValidateNumRows(int64_t actual, int64_t expected) {\n+  if (actual != expected) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectNumberOfRows\",\n+                      \"Received only '%d' rows but expected '%d' rows\", actual, expected);\n+  }\n+}\n+\n+// Calculate the number of bytes required in the bit-packed validity buffer.\n+constexpr int64_t BitPackedLength(int64_t num_elements) {\n+  // Since mxLogicalArray encodes [0, 1] in a full byte, we can compress that byte\n+  // down to a bit...therefore dividing the mxLogicalArray length by 8 here.\n+  return static_cast<int64_t>(std::ceil(num_elements / 8.0));\n+}\n+\n+// Construct a bit-packed buffer on the heap for validity information.\n+std::shared_ptr<uint8_t> MakePackedValidityBuffer(int64_t num_elements) {\n+  return std::shared_ptr<uint8_t>(new uint8_t[BitPackedLength(num_elements)]);\n+}\n+\n+// Calculate the total number of elements in an mxArray\n+// We have to do this separately since mxGetNumberOfElements only works in numeric arrays\n+size_t GetNumberOfElements(const mxArray* array) {\n+  // Get the dimensions and the total number of dimensions from the mxArray*.\n+  const size_t num_dimensions = mxGetNumberOfDimensions(array);\n+  const size_t* dimensions = mxGetDimensions(array);\n+\n+  // Iterate over the dimensions array and accumulate the total number of elements.\n+  return std::accumulate(dimensions, dimensions + num_dimensions, 1,\n+                         std::multiplies<size_t>());\n+}\n+\n+// Write an mxLogicalArray* into a bit-packed arrow::MutableBuffer\n+void BitPackBuffer(const mxArray* logical_array,\n+                           std::shared_ptr<arrow::MutableBuffer> packed_buffer) {\n+  // Error out if the incorrect type is passed in.\n+  if (!mxIsLogical(logical_array)) {\n+    mexErrMsgIdAndTxt(\n+        \"MATLAB:arrow:IncorrectType\",\n+        \"Expected mxLogical array as input but received mxArray of class '%s'\",\n+        mxGetClassName(logical_array));\n+  }\n+\n+  // Validate that the input arrow::Buffer has sufficent size to store a full bit-packed\n+  // representation of the input mxLogicalArray\n+  int64_t unpacked_buffer_length = GetNumberOfElements(logical_array);\n+  if (BitPackedLength(unpacked_buffer_length) > packed_buffer->capacity()) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:BufferSizeExceeded\",\n+                      \"Buffer of size %d bytes cannot store %d bytes of data\",\n+                      packed_buffer->capacity(), BitPackedLength(unpacked_buffer_length));\n+  }\n+\n+  // Get pointers to the internal uint8_t arrays behind arrow::Buffer and mxArray\n+  uint8_t* packed_buffer_ptr = packed_buffer->mutable_data();\n+  const uint8_t* unpacked_buffer_ptr =\n+      reinterpret_cast<const uint8_t*>(mxGetLogicals(logical_array));\n+\n+  // Iterate over the mxLogical array and write bit-packed bools to the arrow::Buffer.\n+  for (int64_t i = 0; i < unpacked_buffer_length; ++i) {\n+    // If the mxLogical value is true, set the corresponding bit in the bit-packed\n+    // buffer. Otherwise, clear that bit.\n+    if (unpacked_buffer_ptr[i]) {\n+      arrow::BitUtil::SetBit(packed_buffer_ptr, i);\n+    } else {\n+      arrow::BitUtil::ClearBit(packed_buffer_ptr, i);\n+    }\n \n Review comment:\n   Consider using `GenerateBitsUnrolled` for much better performance\r\n   \r\n   https://github.com/apache/arrow/blob/master/cpp/src/arrow/util/bit-util.h#L642\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-17T21:29:45.384+0000",
                    "updated": "2019-05-17T21:29:45.384+0000",
                    "started": "2019-05-17T21:29:45.384+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "244314",
                    "issueId": "13201194"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194/worklog/244315",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4328: ARROW-3897: [MATLAB] Add MATLAB support for writing numeric datatypes to a Feather file\nURL: https://github.com/apache/arrow/pull/4328#discussion_r285282039\n \n \n\n ##########\n File path: matlab/src/feather_writer.cc\n ##########\n @@ -0,0 +1,365 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+#include <functional> /* for std::multiplies */\n+#include <numeric>    /* for std::accumulate */\n+\n+#include <arrow/array.h>\n+#include <arrow/buffer.h>\n+#include <arrow/io/file.h>\n+#include <arrow/ipc/feather.h>\n+#include <arrow/status.h>\n+#include <arrow/table.h>\n+#include <arrow/type.h>\n+#include <arrow/util/bit-util.h>\n+\n+#include <mex.h>\n+\n+#include \"feather_writer.h\"\n+#include \"matlab_traits.h\"\n+#include \"util/handle_status.h\"\n+\n+namespace mlarrow {\n+\n+namespace internal {\n+\n+// Utility that helps verify the input mxArray struct field name and type.\n+// Returns void since any errors will throw and terminate MEX execution.\n+void ValidateMxStructField(const mxArray* struct_array, const char* fieldname,\n+                           const mxClassID expected_class_id, const bool can_be_empty) {\n \n Review comment:\n   NB we generally don't use `const` with non-struct/C++ class types in this codebase\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-17T21:29:45.604+0000",
                    "updated": "2019-05-17T21:29:45.604+0000",
                    "started": "2019-05-17T21:29:45.603+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "244315",
                    "issueId": "13201194"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194/worklog/244316",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4328: ARROW-3897: [MATLAB] Add MATLAB support for writing numeric datatypes to a Feather file\nURL: https://github.com/apache/arrow/pull/4328#discussion_r285283853\n \n \n\n ##########\n File path: matlab/src/feather_writer.cc\n ##########\n @@ -0,0 +1,365 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+#include <functional> /* for std::multiplies */\n+#include <numeric>    /* for std::accumulate */\n+\n+#include <arrow/array.h>\n+#include <arrow/buffer.h>\n+#include <arrow/io/file.h>\n+#include <arrow/ipc/feather.h>\n+#include <arrow/status.h>\n+#include <arrow/table.h>\n+#include <arrow/type.h>\n+#include <arrow/util/bit-util.h>\n+\n+#include <mex.h>\n+\n+#include \"feather_writer.h\"\n+#include \"matlab_traits.h\"\n+#include \"util/handle_status.h\"\n+\n+namespace mlarrow {\n+\n+namespace internal {\n+\n+// Utility that helps verify the input mxArray struct field name and type.\n+// Returns void since any errors will throw and terminate MEX execution.\n+void ValidateMxStructField(const mxArray* struct_array, const char* fieldname,\n+                           const mxClassID expected_class_id, const bool can_be_empty) {\n+  // Check that the input mxArray is a struct array.\n+  if (!mxIsStruct(struct_array)) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectDimensionsOrType\",\n+                      \"Input needs to be a struct array\");\n+  }\n+\n+  // Return early if an empty table is provided as input.\n+  if (mxIsEmpty(struct_array)) {\n+    return;\n+  }\n+\n+  mxArray* field = mxGetField(struct_array, 0, fieldname);\n+\n+  if (!field) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:MissingStructField\",\n+                      \"Missing field '%s' in input struct array\", fieldname);\n+  }\n+\n+  mxClassID actual_class_id = mxGetClassID(field);\n+\n+  // Avoid type check if an mxUNKNOWN_CLASS is provided since the UNKNOWN type is used to\n+  // signify genericity in the input type.\n+  if (expected_class_id != mxUNKNOWN_CLASS) {\n+    if (expected_class_id != actual_class_id) {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:MissingStructField\",\n+                        \"Incorrect type '%s' for struct array field '%s'\",\n+                        mxGetClassName(field), fieldname);\n+    }\n+  }\n+\n+  // Some struct fields (like the table description) can be empty, while others \n+  // (like NumRows) should never be empty. This conditional helps account for both cases.\n+  if (!can_be_empty) {\n+    // Ensure that individual mxStructArray fields are non-empty.\n+    // We can call mxGetData after this without needing another null check.\n+    if (mxIsEmpty(field)) {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:EmptyStructField\",\n+                        \"Struct array field '%s' cannot be empty\", fieldname);\n+    }\n+  }\n+}\n+\n+// Utility function to convert mxChar mxArray* to std::string while preserving\n+// Unicode code points.\n+std::string MxArrayToString(const mxArray* array) {\n+  // Return empty std::string if a mxChar array is not passed in.\n+  if (!mxIsChar(array)) {\n+    return std::string();\n+  }\n+\n+  // Convert mxArray first to a C-style char array, then copy into a std::string.\n+  char* utf8_array = mxArrayToUTF8String(array);\n+  std::string output(utf8_array);\n+\n+  // Free the allocated char* from the MEX runtime.\n+  mxFree(utf8_array);\n+\n+  return output;\n+}\n+\n+// Compare number of columns and exit out to the MATLAB layer if incorrect.\n+void ValidateNumColumns(int64_t actual, int64_t expected) {\n+  if (actual != expected) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectNumberOfColumns\",\n+                      \"Received only '%d' columns but expected '%d' columns\", actual,\n+                      expected);\n+  }\n+}\n+\n+// Compare number of rows and exit out to the MATLAB layer if incorrect.\n+void ValidateNumRows(int64_t actual, int64_t expected) {\n+  if (actual != expected) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectNumberOfRows\",\n+                      \"Received only '%d' rows but expected '%d' rows\", actual, expected);\n+  }\n+}\n+\n+// Calculate the number of bytes required in the bit-packed validity buffer.\n+constexpr int64_t BitPackedLength(int64_t num_elements) {\n+  // Since mxLogicalArray encodes [0, 1] in a full byte, we can compress that byte\n+  // down to a bit...therefore dividing the mxLogicalArray length by 8 here.\n+  return static_cast<int64_t>(std::ceil(num_elements / 8.0));\n+}\n+\n+// Construct a bit-packed buffer on the heap for validity information.\n+std::shared_ptr<uint8_t> MakePackedValidityBuffer(int64_t num_elements) {\n+  return std::shared_ptr<uint8_t>(new uint8_t[BitPackedLength(num_elements)]);\n+}\n+\n+// Calculate the total number of elements in an mxArray\n+// We have to do this separately since mxGetNumberOfElements only works in numeric arrays\n+size_t GetNumberOfElements(const mxArray* array) {\n+  // Get the dimensions and the total number of dimensions from the mxArray*.\n+  const size_t num_dimensions = mxGetNumberOfDimensions(array);\n+  const size_t* dimensions = mxGetDimensions(array);\n+\n+  // Iterate over the dimensions array and accumulate the total number of elements.\n+  return std::accumulate(dimensions, dimensions + num_dimensions, 1,\n+                         std::multiplies<size_t>());\n+}\n+\n+// Write an mxLogicalArray* into a bit-packed arrow::MutableBuffer\n+void BitPackBuffer(const mxArray* logical_array,\n+                           std::shared_ptr<arrow::MutableBuffer> packed_buffer) {\n+  // Error out if the incorrect type is passed in.\n+  if (!mxIsLogical(logical_array)) {\n+    mexErrMsgIdAndTxt(\n+        \"MATLAB:arrow:IncorrectType\",\n+        \"Expected mxLogical array as input but received mxArray of class '%s'\",\n+        mxGetClassName(logical_array));\n+  }\n+\n+  // Validate that the input arrow::Buffer has sufficent size to store a full bit-packed\n+  // representation of the input mxLogicalArray\n+  int64_t unpacked_buffer_length = GetNumberOfElements(logical_array);\n+  if (BitPackedLength(unpacked_buffer_length) > packed_buffer->capacity()) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:BufferSizeExceeded\",\n+                      \"Buffer of size %d bytes cannot store %d bytes of data\",\n+                      packed_buffer->capacity(), BitPackedLength(unpacked_buffer_length));\n+  }\n+\n+  // Get pointers to the internal uint8_t arrays behind arrow::Buffer and mxArray\n+  uint8_t* packed_buffer_ptr = packed_buffer->mutable_data();\n+  const uint8_t* unpacked_buffer_ptr =\n+      reinterpret_cast<const uint8_t*>(mxGetLogicals(logical_array));\n+\n+  // Iterate over the mxLogical array and write bit-packed bools to the arrow::Buffer.\n+  for (int64_t i = 0; i < unpacked_buffer_length; ++i) {\n+    // If the mxLogical value is true, set the corresponding bit in the bit-packed\n+    // buffer. Otherwise, clear that bit.\n+    if (unpacked_buffer_ptr[i]) {\n+      arrow::BitUtil::SetBit(packed_buffer_ptr, i);\n+    } else {\n+      arrow::BitUtil::ClearBit(packed_buffer_ptr, i);\n+    }\n+  }\n+}\n+\n+// Write numeric datatypes to the Feather file.\n+template <typename ArrowDataType>\n+std::unique_ptr<arrow::Array> WriteNumericData(\n+    const mxArray* data, const std::shared_ptr<arrow::Buffer> validity_bitmap) {\n+  // Alias the type name for the underlying MATLAB type.\n+  using MatlabType = typename MatlabTraits<ArrowDataType>::MatlabType;\n+\n+  // Get a pointer to the underlying mxArray data.\n+  // We need to (temporarily) cast away const here since the mxGet* functions do not\n+  // accept a const input parameter for compatibility reasons.\n+  const MatlabType* dt = MatlabTraits<ArrowDataType>::GetData(const_cast<mxArray*>(data));\n+\n+  // Construct an arrow::Buffer that points to the underlying mxArray without copying.\n+  // - The lifetime of the mxArray buffer exceeds that of the arrow::Buffer here since\n+  //   MATLAB should only free this region on garbage-collection after the MEX function\n+  //   is executed. Therefore it is safe for arrow::Buffer to point to this location.\n+  // - However arrow::Buffer must not free this region by itself, since that could cause\n+  //   segfaults if the input array is used later in MATLAB.\n+  //   - The Doxygen doc for arrow::Buffer's constructor implies that it is not an RAII\n+  //     type, so this should be safe from possible double-free here.\n+  std::shared_ptr<arrow::Buffer> buffer(\n \n Review comment:\n   Use `std::make_shared`\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-17T21:29:45.605+0000",
                    "updated": "2019-05-17T21:29:45.605+0000",
                    "started": "2019-05-17T21:29:45.605+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "244316",
                    "issueId": "13201194"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194/worklog/244317",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4328: ARROW-3897: [MATLAB] Add MATLAB support for writing numeric datatypes to a Feather file\nURL: https://github.com/apache/arrow/pull/4328#discussion_r285292428\n \n \n\n ##########\n File path: matlab/src/feather_writer.cc\n ##########\n @@ -0,0 +1,365 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+#include <functional> /* for std::multiplies */\n+#include <numeric>    /* for std::accumulate */\n+\n+#include <arrow/array.h>\n+#include <arrow/buffer.h>\n+#include <arrow/io/file.h>\n+#include <arrow/ipc/feather.h>\n+#include <arrow/status.h>\n+#include <arrow/table.h>\n+#include <arrow/type.h>\n+#include <arrow/util/bit-util.h>\n+\n+#include <mex.h>\n+\n+#include \"feather_writer.h\"\n+#include \"matlab_traits.h\"\n+#include \"util/handle_status.h\"\n+\n+namespace mlarrow {\n+\n+namespace internal {\n+\n+// Utility that helps verify the input mxArray struct field name and type.\n+// Returns void since any errors will throw and terminate MEX execution.\n+void ValidateMxStructField(const mxArray* struct_array, const char* fieldname,\n+                           const mxClassID expected_class_id, const bool can_be_empty) {\n+  // Check that the input mxArray is a struct array.\n+  if (!mxIsStruct(struct_array)) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectDimensionsOrType\",\n+                      \"Input needs to be a struct array\");\n+  }\n+\n+  // Return early if an empty table is provided as input.\n+  if (mxIsEmpty(struct_array)) {\n+    return;\n+  }\n+\n+  mxArray* field = mxGetField(struct_array, 0, fieldname);\n+\n+  if (!field) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:MissingStructField\",\n+                      \"Missing field '%s' in input struct array\", fieldname);\n+  }\n+\n+  mxClassID actual_class_id = mxGetClassID(field);\n+\n+  // Avoid type check if an mxUNKNOWN_CLASS is provided since the UNKNOWN type is used to\n+  // signify genericity in the input type.\n+  if (expected_class_id != mxUNKNOWN_CLASS) {\n+    if (expected_class_id != actual_class_id) {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:MissingStructField\",\n+                        \"Incorrect type '%s' for struct array field '%s'\",\n+                        mxGetClassName(field), fieldname);\n+    }\n+  }\n+\n+  // Some struct fields (like the table description) can be empty, while others \n+  // (like NumRows) should never be empty. This conditional helps account for both cases.\n+  if (!can_be_empty) {\n+    // Ensure that individual mxStructArray fields are non-empty.\n+    // We can call mxGetData after this without needing another null check.\n+    if (mxIsEmpty(field)) {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:EmptyStructField\",\n+                        \"Struct array field '%s' cannot be empty\", fieldname);\n+    }\n+  }\n+}\n+\n+// Utility function to convert mxChar mxArray* to std::string while preserving\n+// Unicode code points.\n+std::string MxArrayToString(const mxArray* array) {\n+  // Return empty std::string if a mxChar array is not passed in.\n+  if (!mxIsChar(array)) {\n+    return std::string();\n+  }\n+\n+  // Convert mxArray first to a C-style char array, then copy into a std::string.\n+  char* utf8_array = mxArrayToUTF8String(array);\n+  std::string output(utf8_array);\n+\n+  // Free the allocated char* from the MEX runtime.\n+  mxFree(utf8_array);\n+\n+  return output;\n+}\n+\n+// Compare number of columns and exit out to the MATLAB layer if incorrect.\n+void ValidateNumColumns(int64_t actual, int64_t expected) {\n+  if (actual != expected) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectNumberOfColumns\",\n+                      \"Received only '%d' columns but expected '%d' columns\", actual,\n+                      expected);\n+  }\n+}\n+\n+// Compare number of rows and exit out to the MATLAB layer if incorrect.\n+void ValidateNumRows(int64_t actual, int64_t expected) {\n+  if (actual != expected) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectNumberOfRows\",\n+                      \"Received only '%d' rows but expected '%d' rows\", actual, expected);\n+  }\n+}\n+\n+// Calculate the number of bytes required in the bit-packed validity buffer.\n+constexpr int64_t BitPackedLength(int64_t num_elements) {\n+  // Since mxLogicalArray encodes [0, 1] in a full byte, we can compress that byte\n+  // down to a bit...therefore dividing the mxLogicalArray length by 8 here.\n+  return static_cast<int64_t>(std::ceil(num_elements / 8.0));\n+}\n+\n+// Construct a bit-packed buffer on the heap for validity information.\n+std::shared_ptr<uint8_t> MakePackedValidityBuffer(int64_t num_elements) {\n+  return std::shared_ptr<uint8_t>(new uint8_t[BitPackedLength(num_elements)]);\n+}\n+\n+// Calculate the total number of elements in an mxArray\n+// We have to do this separately since mxGetNumberOfElements only works in numeric arrays\n+size_t GetNumberOfElements(const mxArray* array) {\n+  // Get the dimensions and the total number of dimensions from the mxArray*.\n+  const size_t num_dimensions = mxGetNumberOfDimensions(array);\n+  const size_t* dimensions = mxGetDimensions(array);\n+\n+  // Iterate over the dimensions array and accumulate the total number of elements.\n+  return std::accumulate(dimensions, dimensions + num_dimensions, 1,\n+                         std::multiplies<size_t>());\n+}\n+\n+// Write an mxLogicalArray* into a bit-packed arrow::MutableBuffer\n+void BitPackBuffer(const mxArray* logical_array,\n+                           std::shared_ptr<arrow::MutableBuffer> packed_buffer) {\n+  // Error out if the incorrect type is passed in.\n+  if (!mxIsLogical(logical_array)) {\n+    mexErrMsgIdAndTxt(\n+        \"MATLAB:arrow:IncorrectType\",\n+        \"Expected mxLogical array as input but received mxArray of class '%s'\",\n+        mxGetClassName(logical_array));\n+  }\n+\n+  // Validate that the input arrow::Buffer has sufficent size to store a full bit-packed\n+  // representation of the input mxLogicalArray\n+  int64_t unpacked_buffer_length = GetNumberOfElements(logical_array);\n+  if (BitPackedLength(unpacked_buffer_length) > packed_buffer->capacity()) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:BufferSizeExceeded\",\n+                      \"Buffer of size %d bytes cannot store %d bytes of data\",\n+                      packed_buffer->capacity(), BitPackedLength(unpacked_buffer_length));\n+  }\n+\n+  // Get pointers to the internal uint8_t arrays behind arrow::Buffer and mxArray\n+  uint8_t* packed_buffer_ptr = packed_buffer->mutable_data();\n+  const uint8_t* unpacked_buffer_ptr =\n+      reinterpret_cast<const uint8_t*>(mxGetLogicals(logical_array));\n+\n+  // Iterate over the mxLogical array and write bit-packed bools to the arrow::Buffer.\n+  for (int64_t i = 0; i < unpacked_buffer_length; ++i) {\n+    // If the mxLogical value is true, set the corresponding bit in the bit-packed\n+    // buffer. Otherwise, clear that bit.\n+    if (unpacked_buffer_ptr[i]) {\n+      arrow::BitUtil::SetBit(packed_buffer_ptr, i);\n+    } else {\n+      arrow::BitUtil::ClearBit(packed_buffer_ptr, i);\n+    }\n+  }\n+}\n+\n+// Write numeric datatypes to the Feather file.\n+template <typename ArrowDataType>\n+std::unique_ptr<arrow::Array> WriteNumericData(\n+    const mxArray* data, const std::shared_ptr<arrow::Buffer> validity_bitmap) {\n+  // Alias the type name for the underlying MATLAB type.\n+  using MatlabType = typename MatlabTraits<ArrowDataType>::MatlabType;\n+\n+  // Get a pointer to the underlying mxArray data.\n+  // We need to (temporarily) cast away const here since the mxGet* functions do not\n+  // accept a const input parameter for compatibility reasons.\n+  const MatlabType* dt = MatlabTraits<ArrowDataType>::GetData(const_cast<mxArray*>(data));\n+\n+  // Construct an arrow::Buffer that points to the underlying mxArray without copying.\n+  // - The lifetime of the mxArray buffer exceeds that of the arrow::Buffer here since\n+  //   MATLAB should only free this region on garbage-collection after the MEX function\n+  //   is executed. Therefore it is safe for arrow::Buffer to point to this location.\n+  // - However arrow::Buffer must not free this region by itself, since that could cause\n+  //   segfaults if the input array is used later in MATLAB.\n+  //   - The Doxygen doc for arrow::Buffer's constructor implies that it is not an RAII\n+  //     type, so this should be safe from possible double-free here.\n+  std::shared_ptr<arrow::Buffer> buffer(\n+      new arrow::Buffer(reinterpret_cast<const uint8_t*>(dt),\n+                        mxGetElementSize(data) * mxGetNumberOfElements(data)));\n+\n+  // Construct arrow::NumericArray specialization using arrow::Buffer.\n+  // Pass in nulls information...we could compute and provide the number of nulls here too,\n+  // but passing -1 for now so that Arrow recomputes it if necessary.\n+  std::unique_ptr<arrow::Array> array_wrapper(new arrow::NumericArray<ArrowDataType>(\n+      mxGetNumberOfElements(data), buffer, validity_bitmap, -1));\n+\n+  return array_wrapper;\n+}\n+\n+// Dispatch MATLAB column data to the correct arrow::Array converter.\n+std::unique_ptr<arrow::Array> WriteVariableData(\n+    const mxArray* data, const std::string& type,\n+    const std::shared_ptr<arrow::Buffer> validity_bitmap) {\n+  // Get the underlying type of the mxArray data.\n+  const mxClassID mxclass = mxGetClassID(data);\n+\n+  switch (mxclass) {\n+    case mxSINGLE_CLASS:\n+      return WriteNumericData<arrow::FloatType>(data, validity_bitmap);\n+    case mxDOUBLE_CLASS:\n+      return WriteNumericData<arrow::DoubleType>(data, validity_bitmap);\n+    case mxUINT8_CLASS:\n+      return WriteNumericData<arrow::UInt8Type>(data, validity_bitmap);\n+    case mxUINT16_CLASS:\n+      return WriteNumericData<arrow::UInt16Type>(data, validity_bitmap);\n+    case mxUINT32_CLASS:\n+      return WriteNumericData<arrow::UInt32Type>(data, validity_bitmap);\n+    case mxUINT64_CLASS:\n+      return WriteNumericData<arrow::UInt64Type>(data, validity_bitmap);\n+    case mxINT8_CLASS:\n+      return WriteNumericData<arrow::Int8Type>(data, validity_bitmap);\n+    case mxINT16_CLASS:\n+      return WriteNumericData<arrow::Int16Type>(data, validity_bitmap);\n+    case mxINT32_CLASS:\n+      return WriteNumericData<arrow::Int32Type>(data, validity_bitmap);\n+    case mxINT64_CLASS:\n+      return WriteNumericData<arrow::Int64Type>(data, validity_bitmap);\n+\n+    default: {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:UnsupportedArrowType\",\n+                        \"Unsupported arrow::Type '%s' for variable '%s'\",\n+                        mxGetClassName(data), type.c_str());\n+    }\n+  }\n+\n+  // We shouldn't ever reach this branch, but if we do, return a null unique_ptr.\n+  return std::unique_ptr<arrow::Array>();\n \n Review comment:\n   I think you can just `return nullptr;`\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-17T21:29:45.828+0000",
                    "updated": "2019-05-17T21:29:45.828+0000",
                    "started": "2019-05-17T21:29:45.827+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "244317",
                    "issueId": "13201194"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194/worklog/244318",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4328: ARROW-3897: [MATLAB] Add MATLAB support for writing numeric datatypes to a Feather file\nURL: https://github.com/apache/arrow/pull/4328#discussion_r285292513\n \n \n\n ##########\n File path: matlab/src/feather_writer.cc\n ##########\n @@ -0,0 +1,365 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+#include <functional> /* for std::multiplies */\n+#include <numeric>    /* for std::accumulate */\n+\n+#include <arrow/array.h>\n+#include <arrow/buffer.h>\n+#include <arrow/io/file.h>\n+#include <arrow/ipc/feather.h>\n+#include <arrow/status.h>\n+#include <arrow/table.h>\n+#include <arrow/type.h>\n+#include <arrow/util/bit-util.h>\n+\n+#include <mex.h>\n+\n+#include \"feather_writer.h\"\n+#include \"matlab_traits.h\"\n+#include \"util/handle_status.h\"\n+\n+namespace mlarrow {\n+\n+namespace internal {\n+\n+// Utility that helps verify the input mxArray struct field name and type.\n+// Returns void since any errors will throw and terminate MEX execution.\n+void ValidateMxStructField(const mxArray* struct_array, const char* fieldname,\n+                           const mxClassID expected_class_id, const bool can_be_empty) {\n+  // Check that the input mxArray is a struct array.\n+  if (!mxIsStruct(struct_array)) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectDimensionsOrType\",\n+                      \"Input needs to be a struct array\");\n+  }\n+\n+  // Return early if an empty table is provided as input.\n+  if (mxIsEmpty(struct_array)) {\n+    return;\n+  }\n+\n+  mxArray* field = mxGetField(struct_array, 0, fieldname);\n+\n+  if (!field) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:MissingStructField\",\n+                      \"Missing field '%s' in input struct array\", fieldname);\n+  }\n+\n+  mxClassID actual_class_id = mxGetClassID(field);\n+\n+  // Avoid type check if an mxUNKNOWN_CLASS is provided since the UNKNOWN type is used to\n+  // signify genericity in the input type.\n+  if (expected_class_id != mxUNKNOWN_CLASS) {\n+    if (expected_class_id != actual_class_id) {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:MissingStructField\",\n+                        \"Incorrect type '%s' for struct array field '%s'\",\n+                        mxGetClassName(field), fieldname);\n+    }\n+  }\n+\n+  // Some struct fields (like the table description) can be empty, while others \n+  // (like NumRows) should never be empty. This conditional helps account for both cases.\n+  if (!can_be_empty) {\n+    // Ensure that individual mxStructArray fields are non-empty.\n+    // We can call mxGetData after this without needing another null check.\n+    if (mxIsEmpty(field)) {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:EmptyStructField\",\n+                        \"Struct array field '%s' cannot be empty\", fieldname);\n+    }\n+  }\n+}\n+\n+// Utility function to convert mxChar mxArray* to std::string while preserving\n+// Unicode code points.\n+std::string MxArrayToString(const mxArray* array) {\n+  // Return empty std::string if a mxChar array is not passed in.\n+  if (!mxIsChar(array)) {\n+    return std::string();\n+  }\n+\n+  // Convert mxArray first to a C-style char array, then copy into a std::string.\n+  char* utf8_array = mxArrayToUTF8String(array);\n+  std::string output(utf8_array);\n+\n+  // Free the allocated char* from the MEX runtime.\n+  mxFree(utf8_array);\n+\n+  return output;\n+}\n+\n+// Compare number of columns and exit out to the MATLAB layer if incorrect.\n+void ValidateNumColumns(int64_t actual, int64_t expected) {\n+  if (actual != expected) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectNumberOfColumns\",\n+                      \"Received only '%d' columns but expected '%d' columns\", actual,\n+                      expected);\n+  }\n+}\n+\n+// Compare number of rows and exit out to the MATLAB layer if incorrect.\n+void ValidateNumRows(int64_t actual, int64_t expected) {\n+  if (actual != expected) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectNumberOfRows\",\n+                      \"Received only '%d' rows but expected '%d' rows\", actual, expected);\n+  }\n+}\n+\n+// Calculate the number of bytes required in the bit-packed validity buffer.\n+constexpr int64_t BitPackedLength(int64_t num_elements) {\n+  // Since mxLogicalArray encodes [0, 1] in a full byte, we can compress that byte\n+  // down to a bit...therefore dividing the mxLogicalArray length by 8 here.\n+  return static_cast<int64_t>(std::ceil(num_elements / 8.0));\n+}\n+\n+// Construct a bit-packed buffer on the heap for validity information.\n+std::shared_ptr<uint8_t> MakePackedValidityBuffer(int64_t num_elements) {\n+  return std::shared_ptr<uint8_t>(new uint8_t[BitPackedLength(num_elements)]);\n+}\n+\n+// Calculate the total number of elements in an mxArray\n+// We have to do this separately since mxGetNumberOfElements only works in numeric arrays\n+size_t GetNumberOfElements(const mxArray* array) {\n+  // Get the dimensions and the total number of dimensions from the mxArray*.\n+  const size_t num_dimensions = mxGetNumberOfDimensions(array);\n+  const size_t* dimensions = mxGetDimensions(array);\n+\n+  // Iterate over the dimensions array and accumulate the total number of elements.\n+  return std::accumulate(dimensions, dimensions + num_dimensions, 1,\n+                         std::multiplies<size_t>());\n+}\n+\n+// Write an mxLogicalArray* into a bit-packed arrow::MutableBuffer\n+void BitPackBuffer(const mxArray* logical_array,\n+                           std::shared_ptr<arrow::MutableBuffer> packed_buffer) {\n+  // Error out if the incorrect type is passed in.\n+  if (!mxIsLogical(logical_array)) {\n+    mexErrMsgIdAndTxt(\n+        \"MATLAB:arrow:IncorrectType\",\n+        \"Expected mxLogical array as input but received mxArray of class '%s'\",\n+        mxGetClassName(logical_array));\n+  }\n+\n+  // Validate that the input arrow::Buffer has sufficent size to store a full bit-packed\n+  // representation of the input mxLogicalArray\n+  int64_t unpacked_buffer_length = GetNumberOfElements(logical_array);\n+  if (BitPackedLength(unpacked_buffer_length) > packed_buffer->capacity()) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:BufferSizeExceeded\",\n+                      \"Buffer of size %d bytes cannot store %d bytes of data\",\n+                      packed_buffer->capacity(), BitPackedLength(unpacked_buffer_length));\n+  }\n+\n+  // Get pointers to the internal uint8_t arrays behind arrow::Buffer and mxArray\n+  uint8_t* packed_buffer_ptr = packed_buffer->mutable_data();\n+  const uint8_t* unpacked_buffer_ptr =\n+      reinterpret_cast<const uint8_t*>(mxGetLogicals(logical_array));\n+\n+  // Iterate over the mxLogical array and write bit-packed bools to the arrow::Buffer.\n+  for (int64_t i = 0; i < unpacked_buffer_length; ++i) {\n+    // If the mxLogical value is true, set the corresponding bit in the bit-packed\n+    // buffer. Otherwise, clear that bit.\n+    if (unpacked_buffer_ptr[i]) {\n+      arrow::BitUtil::SetBit(packed_buffer_ptr, i);\n+    } else {\n+      arrow::BitUtil::ClearBit(packed_buffer_ptr, i);\n+    }\n+  }\n+}\n+\n+// Write numeric datatypes to the Feather file.\n+template <typename ArrowDataType>\n+std::unique_ptr<arrow::Array> WriteNumericData(\n+    const mxArray* data, const std::shared_ptr<arrow::Buffer> validity_bitmap) {\n+  // Alias the type name for the underlying MATLAB type.\n+  using MatlabType = typename MatlabTraits<ArrowDataType>::MatlabType;\n+\n+  // Get a pointer to the underlying mxArray data.\n+  // We need to (temporarily) cast away const here since the mxGet* functions do not\n+  // accept a const input parameter for compatibility reasons.\n+  const MatlabType* dt = MatlabTraits<ArrowDataType>::GetData(const_cast<mxArray*>(data));\n+\n+  // Construct an arrow::Buffer that points to the underlying mxArray without copying.\n+  // - The lifetime of the mxArray buffer exceeds that of the arrow::Buffer here since\n+  //   MATLAB should only free this region on garbage-collection after the MEX function\n+  //   is executed. Therefore it is safe for arrow::Buffer to point to this location.\n+  // - However arrow::Buffer must not free this region by itself, since that could cause\n+  //   segfaults if the input array is used later in MATLAB.\n+  //   - The Doxygen doc for arrow::Buffer's constructor implies that it is not an RAII\n+  //     type, so this should be safe from possible double-free here.\n+  std::shared_ptr<arrow::Buffer> buffer(\n+      new arrow::Buffer(reinterpret_cast<const uint8_t*>(dt),\n+                        mxGetElementSize(data) * mxGetNumberOfElements(data)));\n+\n+  // Construct arrow::NumericArray specialization using arrow::Buffer.\n+  // Pass in nulls information...we could compute and provide the number of nulls here too,\n+  // but passing -1 for now so that Arrow recomputes it if necessary.\n+  std::unique_ptr<arrow::Array> array_wrapper(new arrow::NumericArray<ArrowDataType>(\n+      mxGetNumberOfElements(data), buffer, validity_bitmap, -1));\n+\n+  return array_wrapper;\n+}\n+\n+// Dispatch MATLAB column data to the correct arrow::Array converter.\n+std::unique_ptr<arrow::Array> WriteVariableData(\n+    const mxArray* data, const std::string& type,\n+    const std::shared_ptr<arrow::Buffer> validity_bitmap) {\n+  // Get the underlying type of the mxArray data.\n+  const mxClassID mxclass = mxGetClassID(data);\n+\n+  switch (mxclass) {\n+    case mxSINGLE_CLASS:\n+      return WriteNumericData<arrow::FloatType>(data, validity_bitmap);\n+    case mxDOUBLE_CLASS:\n+      return WriteNumericData<arrow::DoubleType>(data, validity_bitmap);\n+    case mxUINT8_CLASS:\n+      return WriteNumericData<arrow::UInt8Type>(data, validity_bitmap);\n+    case mxUINT16_CLASS:\n+      return WriteNumericData<arrow::UInt16Type>(data, validity_bitmap);\n+    case mxUINT32_CLASS:\n+      return WriteNumericData<arrow::UInt32Type>(data, validity_bitmap);\n+    case mxUINT64_CLASS:\n+      return WriteNumericData<arrow::UInt64Type>(data, validity_bitmap);\n+    case mxINT8_CLASS:\n+      return WriteNumericData<arrow::Int8Type>(data, validity_bitmap);\n+    case mxINT16_CLASS:\n+      return WriteNumericData<arrow::Int16Type>(data, validity_bitmap);\n+    case mxINT32_CLASS:\n+      return WriteNumericData<arrow::Int32Type>(data, validity_bitmap);\n+    case mxINT64_CLASS:\n+      return WriteNumericData<arrow::Int64Type>(data, validity_bitmap);\n+\n+    default: {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:UnsupportedArrowType\",\n+                        \"Unsupported arrow::Type '%s' for variable '%s'\",\n+                        mxGetClassName(data), type.c_str());\n+    }\n+  }\n+\n+  // We shouldn't ever reach this branch, but if we do, return a null unique_ptr.\n+  return std::unique_ptr<arrow::Array>();\n+}\n+\n+}  // namespace internal\n+\n+arrow::Status FeatherWriter::Open(const std::string& filename,\n+                                  std::shared_ptr<FeatherWriter>* feather_writer) {\n+  // Allocate shared_ptr out parameter.\n+  *feather_writer = std::shared_ptr<FeatherWriter>(new FeatherWriter());\n \n Review comment:\n   `make_shared<...>(...)`?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-17T21:29:45.864+0000",
                    "updated": "2019-05-17T21:29:45.864+0000",
                    "started": "2019-05-17T21:29:45.863+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "244318",
                    "issueId": "13201194"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194/worklog/244319",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4328: ARROW-3897: [MATLAB] Add MATLAB support for writing numeric datatypes to a Feather file\nURL: https://github.com/apache/arrow/pull/4328#discussion_r285292560\n \n \n\n ##########\n File path: matlab/src/feather_writer.cc\n ##########\n @@ -0,0 +1,365 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+#include <functional> /* for std::multiplies */\n+#include <numeric>    /* for std::accumulate */\n+\n+#include <arrow/array.h>\n+#include <arrow/buffer.h>\n+#include <arrow/io/file.h>\n+#include <arrow/ipc/feather.h>\n+#include <arrow/status.h>\n+#include <arrow/table.h>\n+#include <arrow/type.h>\n+#include <arrow/util/bit-util.h>\n+\n+#include <mex.h>\n+\n+#include \"feather_writer.h\"\n+#include \"matlab_traits.h\"\n+#include \"util/handle_status.h\"\n+\n+namespace mlarrow {\n+\n+namespace internal {\n+\n+// Utility that helps verify the input mxArray struct field name and type.\n+// Returns void since any errors will throw and terminate MEX execution.\n+void ValidateMxStructField(const mxArray* struct_array, const char* fieldname,\n+                           const mxClassID expected_class_id, const bool can_be_empty) {\n+  // Check that the input mxArray is a struct array.\n+  if (!mxIsStruct(struct_array)) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectDimensionsOrType\",\n+                      \"Input needs to be a struct array\");\n+  }\n+\n+  // Return early if an empty table is provided as input.\n+  if (mxIsEmpty(struct_array)) {\n+    return;\n+  }\n+\n+  mxArray* field = mxGetField(struct_array, 0, fieldname);\n+\n+  if (!field) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:MissingStructField\",\n+                      \"Missing field '%s' in input struct array\", fieldname);\n+  }\n+\n+  mxClassID actual_class_id = mxGetClassID(field);\n+\n+  // Avoid type check if an mxUNKNOWN_CLASS is provided since the UNKNOWN type is used to\n+  // signify genericity in the input type.\n+  if (expected_class_id != mxUNKNOWN_CLASS) {\n+    if (expected_class_id != actual_class_id) {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:MissingStructField\",\n+                        \"Incorrect type '%s' for struct array field '%s'\",\n+                        mxGetClassName(field), fieldname);\n+    }\n+  }\n+\n+  // Some struct fields (like the table description) can be empty, while others \n+  // (like NumRows) should never be empty. This conditional helps account for both cases.\n+  if (!can_be_empty) {\n+    // Ensure that individual mxStructArray fields are non-empty.\n+    // We can call mxGetData after this without needing another null check.\n+    if (mxIsEmpty(field)) {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:EmptyStructField\",\n+                        \"Struct array field '%s' cannot be empty\", fieldname);\n+    }\n+  }\n+}\n+\n+// Utility function to convert mxChar mxArray* to std::string while preserving\n+// Unicode code points.\n+std::string MxArrayToString(const mxArray* array) {\n+  // Return empty std::string if a mxChar array is not passed in.\n+  if (!mxIsChar(array)) {\n+    return std::string();\n+  }\n+\n+  // Convert mxArray first to a C-style char array, then copy into a std::string.\n+  char* utf8_array = mxArrayToUTF8String(array);\n+  std::string output(utf8_array);\n+\n+  // Free the allocated char* from the MEX runtime.\n+  mxFree(utf8_array);\n+\n+  return output;\n+}\n+\n+// Compare number of columns and exit out to the MATLAB layer if incorrect.\n+void ValidateNumColumns(int64_t actual, int64_t expected) {\n+  if (actual != expected) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectNumberOfColumns\",\n+                      \"Received only '%d' columns but expected '%d' columns\", actual,\n+                      expected);\n+  }\n+}\n+\n+// Compare number of rows and exit out to the MATLAB layer if incorrect.\n+void ValidateNumRows(int64_t actual, int64_t expected) {\n+  if (actual != expected) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectNumberOfRows\",\n+                      \"Received only '%d' rows but expected '%d' rows\", actual, expected);\n+  }\n+}\n+\n+// Calculate the number of bytes required in the bit-packed validity buffer.\n+constexpr int64_t BitPackedLength(int64_t num_elements) {\n+  // Since mxLogicalArray encodes [0, 1] in a full byte, we can compress that byte\n+  // down to a bit...therefore dividing the mxLogicalArray length by 8 here.\n+  return static_cast<int64_t>(std::ceil(num_elements / 8.0));\n+}\n+\n+// Construct a bit-packed buffer on the heap for validity information.\n+std::shared_ptr<uint8_t> MakePackedValidityBuffer(int64_t num_elements) {\n+  return std::shared_ptr<uint8_t>(new uint8_t[BitPackedLength(num_elements)]);\n+}\n+\n+// Calculate the total number of elements in an mxArray\n+// We have to do this separately since mxGetNumberOfElements only works in numeric arrays\n+size_t GetNumberOfElements(const mxArray* array) {\n+  // Get the dimensions and the total number of dimensions from the mxArray*.\n+  const size_t num_dimensions = mxGetNumberOfDimensions(array);\n+  const size_t* dimensions = mxGetDimensions(array);\n+\n+  // Iterate over the dimensions array and accumulate the total number of elements.\n+  return std::accumulate(dimensions, dimensions + num_dimensions, 1,\n+                         std::multiplies<size_t>());\n+}\n+\n+// Write an mxLogicalArray* into a bit-packed arrow::MutableBuffer\n+void BitPackBuffer(const mxArray* logical_array,\n+                           std::shared_ptr<arrow::MutableBuffer> packed_buffer) {\n+  // Error out if the incorrect type is passed in.\n+  if (!mxIsLogical(logical_array)) {\n+    mexErrMsgIdAndTxt(\n+        \"MATLAB:arrow:IncorrectType\",\n+        \"Expected mxLogical array as input but received mxArray of class '%s'\",\n+        mxGetClassName(logical_array));\n+  }\n+\n+  // Validate that the input arrow::Buffer has sufficent size to store a full bit-packed\n+  // representation of the input mxLogicalArray\n+  int64_t unpacked_buffer_length = GetNumberOfElements(logical_array);\n+  if (BitPackedLength(unpacked_buffer_length) > packed_buffer->capacity()) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:BufferSizeExceeded\",\n+                      \"Buffer of size %d bytes cannot store %d bytes of data\",\n+                      packed_buffer->capacity(), BitPackedLength(unpacked_buffer_length));\n+  }\n+\n+  // Get pointers to the internal uint8_t arrays behind arrow::Buffer and mxArray\n+  uint8_t* packed_buffer_ptr = packed_buffer->mutable_data();\n+  const uint8_t* unpacked_buffer_ptr =\n+      reinterpret_cast<const uint8_t*>(mxGetLogicals(logical_array));\n+\n+  // Iterate over the mxLogical array and write bit-packed bools to the arrow::Buffer.\n+  for (int64_t i = 0; i < unpacked_buffer_length; ++i) {\n+    // If the mxLogical value is true, set the corresponding bit in the bit-packed\n+    // buffer. Otherwise, clear that bit.\n+    if (unpacked_buffer_ptr[i]) {\n+      arrow::BitUtil::SetBit(packed_buffer_ptr, i);\n+    } else {\n+      arrow::BitUtil::ClearBit(packed_buffer_ptr, i);\n+    }\n+  }\n+}\n+\n+// Write numeric datatypes to the Feather file.\n+template <typename ArrowDataType>\n+std::unique_ptr<arrow::Array> WriteNumericData(\n+    const mxArray* data, const std::shared_ptr<arrow::Buffer> validity_bitmap) {\n+  // Alias the type name for the underlying MATLAB type.\n+  using MatlabType = typename MatlabTraits<ArrowDataType>::MatlabType;\n+\n+  // Get a pointer to the underlying mxArray data.\n+  // We need to (temporarily) cast away const here since the mxGet* functions do not\n+  // accept a const input parameter for compatibility reasons.\n+  const MatlabType* dt = MatlabTraits<ArrowDataType>::GetData(const_cast<mxArray*>(data));\n+\n+  // Construct an arrow::Buffer that points to the underlying mxArray without copying.\n+  // - The lifetime of the mxArray buffer exceeds that of the arrow::Buffer here since\n+  //   MATLAB should only free this region on garbage-collection after the MEX function\n+  //   is executed. Therefore it is safe for arrow::Buffer to point to this location.\n+  // - However arrow::Buffer must not free this region by itself, since that could cause\n+  //   segfaults if the input array is used later in MATLAB.\n+  //   - The Doxygen doc for arrow::Buffer's constructor implies that it is not an RAII\n+  //     type, so this should be safe from possible double-free here.\n+  std::shared_ptr<arrow::Buffer> buffer(\n+      new arrow::Buffer(reinterpret_cast<const uint8_t*>(dt),\n+                        mxGetElementSize(data) * mxGetNumberOfElements(data)));\n+\n+  // Construct arrow::NumericArray specialization using arrow::Buffer.\n+  // Pass in nulls information...we could compute and provide the number of nulls here too,\n+  // but passing -1 for now so that Arrow recomputes it if necessary.\n+  std::unique_ptr<arrow::Array> array_wrapper(new arrow::NumericArray<ArrowDataType>(\n+      mxGetNumberOfElements(data), buffer, validity_bitmap, -1));\n+\n+  return array_wrapper;\n+}\n+\n+// Dispatch MATLAB column data to the correct arrow::Array converter.\n+std::unique_ptr<arrow::Array> WriteVariableData(\n+    const mxArray* data, const std::string& type,\n+    const std::shared_ptr<arrow::Buffer> validity_bitmap) {\n+  // Get the underlying type of the mxArray data.\n+  const mxClassID mxclass = mxGetClassID(data);\n+\n+  switch (mxclass) {\n+    case mxSINGLE_CLASS:\n+      return WriteNumericData<arrow::FloatType>(data, validity_bitmap);\n+    case mxDOUBLE_CLASS:\n+      return WriteNumericData<arrow::DoubleType>(data, validity_bitmap);\n+    case mxUINT8_CLASS:\n+      return WriteNumericData<arrow::UInt8Type>(data, validity_bitmap);\n+    case mxUINT16_CLASS:\n+      return WriteNumericData<arrow::UInt16Type>(data, validity_bitmap);\n+    case mxUINT32_CLASS:\n+      return WriteNumericData<arrow::UInt32Type>(data, validity_bitmap);\n+    case mxUINT64_CLASS:\n+      return WriteNumericData<arrow::UInt64Type>(data, validity_bitmap);\n+    case mxINT8_CLASS:\n+      return WriteNumericData<arrow::Int8Type>(data, validity_bitmap);\n+    case mxINT16_CLASS:\n+      return WriteNumericData<arrow::Int16Type>(data, validity_bitmap);\n+    case mxINT32_CLASS:\n+      return WriteNumericData<arrow::Int32Type>(data, validity_bitmap);\n+    case mxINT64_CLASS:\n+      return WriteNumericData<arrow::Int64Type>(data, validity_bitmap);\n+\n+    default: {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:UnsupportedArrowType\",\n+                        \"Unsupported arrow::Type '%s' for variable '%s'\",\n+                        mxGetClassName(data), type.c_str());\n+    }\n+  }\n+\n+  // We shouldn't ever reach this branch, but if we do, return a null unique_ptr.\n+  return std::unique_ptr<arrow::Array>();\n+}\n+\n+}  // namespace internal\n+\n+arrow::Status FeatherWriter::Open(const std::string& filename,\n+                                  std::shared_ptr<FeatherWriter>* feather_writer) {\n+  // Allocate shared_ptr out parameter.\n+  *feather_writer = std::shared_ptr<FeatherWriter>(new FeatherWriter());\n+\n+  // Open a FileOutputStream corresponding to the provided filename.\n+  std::shared_ptr<arrow::io::OutputStream> writable_file(nullptr);\n+  ARROW_RETURN_NOT_OK(arrow::io::FileOutputStream::Open(filename, &writable_file));\n+\n+  // TableWriter::Open expects a shared_ptr to an OutputStream.\n+  // Open the Feather file for writing with a TableWriter.\n+  ARROW_RETURN_NOT_OK(arrow::ipc::feather::TableWriter::Open(\n+      writable_file, &(*feather_writer)->table_writer_));\n \n Review comment:\n   You can just return this Status\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-17T21:29:45.872+0000",
                    "updated": "2019-05-17T21:29:45.872+0000",
                    "started": "2019-05-17T21:29:45.872+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "244319",
                    "issueId": "13201194"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194/worklog/244320",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4328: ARROW-3897: [MATLAB] Add MATLAB support for writing numeric datatypes to a Feather file\nURL: https://github.com/apache/arrow/pull/4328#discussion_r285284007\n \n \n\n ##########\n File path: matlab/src/feather_writer.cc\n ##########\n @@ -0,0 +1,365 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+#include <functional> /* for std::multiplies */\n+#include <numeric>    /* for std::accumulate */\n+\n+#include <arrow/array.h>\n+#include <arrow/buffer.h>\n+#include <arrow/io/file.h>\n+#include <arrow/ipc/feather.h>\n+#include <arrow/status.h>\n+#include <arrow/table.h>\n+#include <arrow/type.h>\n+#include <arrow/util/bit-util.h>\n+\n+#include <mex.h>\n+\n+#include \"feather_writer.h\"\n+#include \"matlab_traits.h\"\n+#include \"util/handle_status.h\"\n+\n+namespace mlarrow {\n+\n+namespace internal {\n+\n+// Utility that helps verify the input mxArray struct field name and type.\n+// Returns void since any errors will throw and terminate MEX execution.\n+void ValidateMxStructField(const mxArray* struct_array, const char* fieldname,\n+                           const mxClassID expected_class_id, const bool can_be_empty) {\n+  // Check that the input mxArray is a struct array.\n+  if (!mxIsStruct(struct_array)) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectDimensionsOrType\",\n+                      \"Input needs to be a struct array\");\n+  }\n+\n+  // Return early if an empty table is provided as input.\n+  if (mxIsEmpty(struct_array)) {\n+    return;\n+  }\n+\n+  mxArray* field = mxGetField(struct_array, 0, fieldname);\n+\n+  if (!field) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:MissingStructField\",\n+                      \"Missing field '%s' in input struct array\", fieldname);\n+  }\n+\n+  mxClassID actual_class_id = mxGetClassID(field);\n+\n+  // Avoid type check if an mxUNKNOWN_CLASS is provided since the UNKNOWN type is used to\n+  // signify genericity in the input type.\n+  if (expected_class_id != mxUNKNOWN_CLASS) {\n+    if (expected_class_id != actual_class_id) {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:MissingStructField\",\n+                        \"Incorrect type '%s' for struct array field '%s'\",\n+                        mxGetClassName(field), fieldname);\n+    }\n+  }\n+\n+  // Some struct fields (like the table description) can be empty, while others \n+  // (like NumRows) should never be empty. This conditional helps account for both cases.\n+  if (!can_be_empty) {\n+    // Ensure that individual mxStructArray fields are non-empty.\n+    // We can call mxGetData after this without needing another null check.\n+    if (mxIsEmpty(field)) {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:EmptyStructField\",\n+                        \"Struct array field '%s' cannot be empty\", fieldname);\n+    }\n+  }\n+}\n+\n+// Utility function to convert mxChar mxArray* to std::string while preserving\n+// Unicode code points.\n+std::string MxArrayToString(const mxArray* array) {\n+  // Return empty std::string if a mxChar array is not passed in.\n+  if (!mxIsChar(array)) {\n+    return std::string();\n+  }\n+\n+  // Convert mxArray first to a C-style char array, then copy into a std::string.\n+  char* utf8_array = mxArrayToUTF8String(array);\n+  std::string output(utf8_array);\n+\n+  // Free the allocated char* from the MEX runtime.\n+  mxFree(utf8_array);\n+\n+  return output;\n+}\n+\n+// Compare number of columns and exit out to the MATLAB layer if incorrect.\n+void ValidateNumColumns(int64_t actual, int64_t expected) {\n+  if (actual != expected) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectNumberOfColumns\",\n+                      \"Received only '%d' columns but expected '%d' columns\", actual,\n+                      expected);\n+  }\n+}\n+\n+// Compare number of rows and exit out to the MATLAB layer if incorrect.\n+void ValidateNumRows(int64_t actual, int64_t expected) {\n+  if (actual != expected) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectNumberOfRows\",\n+                      \"Received only '%d' rows but expected '%d' rows\", actual, expected);\n+  }\n+}\n+\n+// Calculate the number of bytes required in the bit-packed validity buffer.\n+constexpr int64_t BitPackedLength(int64_t num_elements) {\n+  // Since mxLogicalArray encodes [0, 1] in a full byte, we can compress that byte\n+  // down to a bit...therefore dividing the mxLogicalArray length by 8 here.\n+  return static_cast<int64_t>(std::ceil(num_elements / 8.0));\n+}\n+\n+// Construct a bit-packed buffer on the heap for validity information.\n+std::shared_ptr<uint8_t> MakePackedValidityBuffer(int64_t num_elements) {\n+  return std::shared_ptr<uint8_t>(new uint8_t[BitPackedLength(num_elements)]);\n+}\n+\n+// Calculate the total number of elements in an mxArray\n+// We have to do this separately since mxGetNumberOfElements only works in numeric arrays\n+size_t GetNumberOfElements(const mxArray* array) {\n+  // Get the dimensions and the total number of dimensions from the mxArray*.\n+  const size_t num_dimensions = mxGetNumberOfDimensions(array);\n+  const size_t* dimensions = mxGetDimensions(array);\n+\n+  // Iterate over the dimensions array and accumulate the total number of elements.\n+  return std::accumulate(dimensions, dimensions + num_dimensions, 1,\n+                         std::multiplies<size_t>());\n+}\n+\n+// Write an mxLogicalArray* into a bit-packed arrow::MutableBuffer\n+void BitPackBuffer(const mxArray* logical_array,\n+                           std::shared_ptr<arrow::MutableBuffer> packed_buffer) {\n+  // Error out if the incorrect type is passed in.\n+  if (!mxIsLogical(logical_array)) {\n+    mexErrMsgIdAndTxt(\n+        \"MATLAB:arrow:IncorrectType\",\n+        \"Expected mxLogical array as input but received mxArray of class '%s'\",\n+        mxGetClassName(logical_array));\n+  }\n+\n+  // Validate that the input arrow::Buffer has sufficent size to store a full bit-packed\n+  // representation of the input mxLogicalArray\n+  int64_t unpacked_buffer_length = GetNumberOfElements(logical_array);\n+  if (BitPackedLength(unpacked_buffer_length) > packed_buffer->capacity()) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:BufferSizeExceeded\",\n+                      \"Buffer of size %d bytes cannot store %d bytes of data\",\n+                      packed_buffer->capacity(), BitPackedLength(unpacked_buffer_length));\n+  }\n+\n+  // Get pointers to the internal uint8_t arrays behind arrow::Buffer and mxArray\n+  uint8_t* packed_buffer_ptr = packed_buffer->mutable_data();\n+  const uint8_t* unpacked_buffer_ptr =\n+      reinterpret_cast<const uint8_t*>(mxGetLogicals(logical_array));\n+\n+  // Iterate over the mxLogical array and write bit-packed bools to the arrow::Buffer.\n+  for (int64_t i = 0; i < unpacked_buffer_length; ++i) {\n+    // If the mxLogical value is true, set the corresponding bit in the bit-packed\n+    // buffer. Otherwise, clear that bit.\n+    if (unpacked_buffer_ptr[i]) {\n+      arrow::BitUtil::SetBit(packed_buffer_ptr, i);\n+    } else {\n+      arrow::BitUtil::ClearBit(packed_buffer_ptr, i);\n+    }\n+  }\n+}\n+\n+// Write numeric datatypes to the Feather file.\n+template <typename ArrowDataType>\n+std::unique_ptr<arrow::Array> WriteNumericData(\n+    const mxArray* data, const std::shared_ptr<arrow::Buffer> validity_bitmap) {\n+  // Alias the type name for the underlying MATLAB type.\n+  using MatlabType = typename MatlabTraits<ArrowDataType>::MatlabType;\n+\n+  // Get a pointer to the underlying mxArray data.\n+  // We need to (temporarily) cast away const here since the mxGet* functions do not\n+  // accept a const input parameter for compatibility reasons.\n+  const MatlabType* dt = MatlabTraits<ArrowDataType>::GetData(const_cast<mxArray*>(data));\n+\n+  // Construct an arrow::Buffer that points to the underlying mxArray without copying.\n+  // - The lifetime of the mxArray buffer exceeds that of the arrow::Buffer here since\n+  //   MATLAB should only free this region on garbage-collection after the MEX function\n+  //   is executed. Therefore it is safe for arrow::Buffer to point to this location.\n+  // - However arrow::Buffer must not free this region by itself, since that could cause\n+  //   segfaults if the input array is used later in MATLAB.\n+  //   - The Doxygen doc for arrow::Buffer's constructor implies that it is not an RAII\n+  //     type, so this should be safe from possible double-free here.\n+  std::shared_ptr<arrow::Buffer> buffer(\n+      new arrow::Buffer(reinterpret_cast<const uint8_t*>(dt),\n+                        mxGetElementSize(data) * mxGetNumberOfElements(data)));\n+\n+  // Construct arrow::NumericArray specialization using arrow::Buffer.\n+  // Pass in nulls information...we could compute and provide the number of nulls here too,\n+  // but passing -1 for now so that Arrow recomputes it if necessary.\n+  std::unique_ptr<arrow::Array> array_wrapper(new arrow::NumericArray<ArrowDataType>(\n \n Review comment:\n   just return here without lvalue?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-17T21:29:45.924+0000",
                    "updated": "2019-05-17T21:29:45.924+0000",
                    "started": "2019-05-17T21:29:45.923+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "244320",
                    "issueId": "13201194"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194/worklog/244321",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4328: ARROW-3897: [MATLAB] Add MATLAB support for writing numeric datatypes to a Feather file\nURL: https://github.com/apache/arrow/pull/4328#discussion_r285293395\n \n \n\n ##########\n File path: matlab/src/feather_writer.h\n ##########\n @@ -0,0 +1,76 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef MLARROW_FEATHER_WRITER_H\n+#define MLARROW_FEATHER_WRITER_H\n+\n+#include <memory>\n+#include <string>\n+\n+#include <arrow/ipc/feather.h>\n+#include <arrow/status.h>\n+#include <arrow/type.h>\n+\n+#include <matrix.h>\n+\n+namespace mlarrow {\n \n Review comment:\n   You could spare yourself a lot of typing in this codebase by nesting the matlab symbols in a namespace inside `arrow`, e.g. `namespace arrow { namespace matlab {` (or whatever NS name you need to use to avoid any symbol conflicts)\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-17T21:29:46.048+0000",
                    "updated": "2019-05-17T21:29:46.048+0000",
                    "started": "2019-05-17T21:29:46.047+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "244321",
                    "issueId": "13201194"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194/worklog/244322",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4328: ARROW-3897: [MATLAB] Add MATLAB support for writing numeric datatypes to a Feather file\nURL: https://github.com/apache/arrow/pull/4328#discussion_r285293097\n \n \n\n ##########\n File path: matlab/src/feather_writer.cc\n ##########\n @@ -0,0 +1,365 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+#include <functional> /* for std::multiplies */\n+#include <numeric>    /* for std::accumulate */\n+\n+#include <arrow/array.h>\n+#include <arrow/buffer.h>\n+#include <arrow/io/file.h>\n+#include <arrow/ipc/feather.h>\n+#include <arrow/status.h>\n+#include <arrow/table.h>\n+#include <arrow/type.h>\n+#include <arrow/util/bit-util.h>\n+\n+#include <mex.h>\n+\n+#include \"feather_writer.h\"\n+#include \"matlab_traits.h\"\n+#include \"util/handle_status.h\"\n+\n+namespace mlarrow {\n+\n+namespace internal {\n+\n+// Utility that helps verify the input mxArray struct field name and type.\n+// Returns void since any errors will throw and terminate MEX execution.\n+void ValidateMxStructField(const mxArray* struct_array, const char* fieldname,\n+                           const mxClassID expected_class_id, const bool can_be_empty) {\n+  // Check that the input mxArray is a struct array.\n+  if (!mxIsStruct(struct_array)) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectDimensionsOrType\",\n+                      \"Input needs to be a struct array\");\n+  }\n+\n+  // Return early if an empty table is provided as input.\n+  if (mxIsEmpty(struct_array)) {\n+    return;\n+  }\n+\n+  mxArray* field = mxGetField(struct_array, 0, fieldname);\n+\n+  if (!field) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:MissingStructField\",\n+                      \"Missing field '%s' in input struct array\", fieldname);\n+  }\n+\n+  mxClassID actual_class_id = mxGetClassID(field);\n+\n+  // Avoid type check if an mxUNKNOWN_CLASS is provided since the UNKNOWN type is used to\n+  // signify genericity in the input type.\n+  if (expected_class_id != mxUNKNOWN_CLASS) {\n+    if (expected_class_id != actual_class_id) {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:MissingStructField\",\n+                        \"Incorrect type '%s' for struct array field '%s'\",\n+                        mxGetClassName(field), fieldname);\n+    }\n+  }\n+\n+  // Some struct fields (like the table description) can be empty, while others \n+  // (like NumRows) should never be empty. This conditional helps account for both cases.\n+  if (!can_be_empty) {\n+    // Ensure that individual mxStructArray fields are non-empty.\n+    // We can call mxGetData after this without needing another null check.\n+    if (mxIsEmpty(field)) {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:EmptyStructField\",\n+                        \"Struct array field '%s' cannot be empty\", fieldname);\n+    }\n+  }\n+}\n+\n+// Utility function to convert mxChar mxArray* to std::string while preserving\n+// Unicode code points.\n+std::string MxArrayToString(const mxArray* array) {\n+  // Return empty std::string if a mxChar array is not passed in.\n+  if (!mxIsChar(array)) {\n+    return std::string();\n+  }\n+\n+  // Convert mxArray first to a C-style char array, then copy into a std::string.\n+  char* utf8_array = mxArrayToUTF8String(array);\n+  std::string output(utf8_array);\n+\n+  // Free the allocated char* from the MEX runtime.\n+  mxFree(utf8_array);\n+\n+  return output;\n+}\n+\n+// Compare number of columns and exit out to the MATLAB layer if incorrect.\n+void ValidateNumColumns(int64_t actual, int64_t expected) {\n+  if (actual != expected) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectNumberOfColumns\",\n+                      \"Received only '%d' columns but expected '%d' columns\", actual,\n+                      expected);\n+  }\n+}\n+\n+// Compare number of rows and exit out to the MATLAB layer if incorrect.\n+void ValidateNumRows(int64_t actual, int64_t expected) {\n+  if (actual != expected) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectNumberOfRows\",\n+                      \"Received only '%d' rows but expected '%d' rows\", actual, expected);\n+  }\n+}\n+\n+// Calculate the number of bytes required in the bit-packed validity buffer.\n+constexpr int64_t BitPackedLength(int64_t num_elements) {\n+  // Since mxLogicalArray encodes [0, 1] in a full byte, we can compress that byte\n+  // down to a bit...therefore dividing the mxLogicalArray length by 8 here.\n+  return static_cast<int64_t>(std::ceil(num_elements / 8.0));\n+}\n+\n+// Construct a bit-packed buffer on the heap for validity information.\n+std::shared_ptr<uint8_t> MakePackedValidityBuffer(int64_t num_elements) {\n+  return std::shared_ptr<uint8_t>(new uint8_t[BitPackedLength(num_elements)]);\n+}\n+\n+// Calculate the total number of elements in an mxArray\n+// We have to do this separately since mxGetNumberOfElements only works in numeric arrays\n+size_t GetNumberOfElements(const mxArray* array) {\n+  // Get the dimensions and the total number of dimensions from the mxArray*.\n+  const size_t num_dimensions = mxGetNumberOfDimensions(array);\n+  const size_t* dimensions = mxGetDimensions(array);\n+\n+  // Iterate over the dimensions array and accumulate the total number of elements.\n+  return std::accumulate(dimensions, dimensions + num_dimensions, 1,\n+                         std::multiplies<size_t>());\n+}\n+\n+// Write an mxLogicalArray* into a bit-packed arrow::MutableBuffer\n+void BitPackBuffer(const mxArray* logical_array,\n+                           std::shared_ptr<arrow::MutableBuffer> packed_buffer) {\n+  // Error out if the incorrect type is passed in.\n+  if (!mxIsLogical(logical_array)) {\n+    mexErrMsgIdAndTxt(\n+        \"MATLAB:arrow:IncorrectType\",\n+        \"Expected mxLogical array as input but received mxArray of class '%s'\",\n+        mxGetClassName(logical_array));\n+  }\n+\n+  // Validate that the input arrow::Buffer has sufficent size to store a full bit-packed\n+  // representation of the input mxLogicalArray\n+  int64_t unpacked_buffer_length = GetNumberOfElements(logical_array);\n+  if (BitPackedLength(unpacked_buffer_length) > packed_buffer->capacity()) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:BufferSizeExceeded\",\n+                      \"Buffer of size %d bytes cannot store %d bytes of data\",\n+                      packed_buffer->capacity(), BitPackedLength(unpacked_buffer_length));\n+  }\n+\n+  // Get pointers to the internal uint8_t arrays behind arrow::Buffer and mxArray\n+  uint8_t* packed_buffer_ptr = packed_buffer->mutable_data();\n+  const uint8_t* unpacked_buffer_ptr =\n+      reinterpret_cast<const uint8_t*>(mxGetLogicals(logical_array));\n+\n+  // Iterate over the mxLogical array and write bit-packed bools to the arrow::Buffer.\n+  for (int64_t i = 0; i < unpacked_buffer_length; ++i) {\n+    // If the mxLogical value is true, set the corresponding bit in the bit-packed\n+    // buffer. Otherwise, clear that bit.\n+    if (unpacked_buffer_ptr[i]) {\n+      arrow::BitUtil::SetBit(packed_buffer_ptr, i);\n+    } else {\n+      arrow::BitUtil::ClearBit(packed_buffer_ptr, i);\n+    }\n+  }\n+}\n+\n+// Write numeric datatypes to the Feather file.\n+template <typename ArrowDataType>\n+std::unique_ptr<arrow::Array> WriteNumericData(\n+    const mxArray* data, const std::shared_ptr<arrow::Buffer> validity_bitmap) {\n+  // Alias the type name for the underlying MATLAB type.\n+  using MatlabType = typename MatlabTraits<ArrowDataType>::MatlabType;\n+\n+  // Get a pointer to the underlying mxArray data.\n+  // We need to (temporarily) cast away const here since the mxGet* functions do not\n+  // accept a const input parameter for compatibility reasons.\n+  const MatlabType* dt = MatlabTraits<ArrowDataType>::GetData(const_cast<mxArray*>(data));\n+\n+  // Construct an arrow::Buffer that points to the underlying mxArray without copying.\n+  // - The lifetime of the mxArray buffer exceeds that of the arrow::Buffer here since\n+  //   MATLAB should only free this region on garbage-collection after the MEX function\n+  //   is executed. Therefore it is safe for arrow::Buffer to point to this location.\n+  // - However arrow::Buffer must not free this region by itself, since that could cause\n+  //   segfaults if the input array is used later in MATLAB.\n+  //   - The Doxygen doc for arrow::Buffer's constructor implies that it is not an RAII\n+  //     type, so this should be safe from possible double-free here.\n+  std::shared_ptr<arrow::Buffer> buffer(\n+      new arrow::Buffer(reinterpret_cast<const uint8_t*>(dt),\n+                        mxGetElementSize(data) * mxGetNumberOfElements(data)));\n+\n+  // Construct arrow::NumericArray specialization using arrow::Buffer.\n+  // Pass in nulls information...we could compute and provide the number of nulls here too,\n+  // but passing -1 for now so that Arrow recomputes it if necessary.\n+  std::unique_ptr<arrow::Array> array_wrapper(new arrow::NumericArray<ArrowDataType>(\n+      mxGetNumberOfElements(data), buffer, validity_bitmap, -1));\n+\n+  return array_wrapper;\n+}\n+\n+// Dispatch MATLAB column data to the correct arrow::Array converter.\n+std::unique_ptr<arrow::Array> WriteVariableData(\n+    const mxArray* data, const std::string& type,\n+    const std::shared_ptr<arrow::Buffer> validity_bitmap) {\n+  // Get the underlying type of the mxArray data.\n+  const mxClassID mxclass = mxGetClassID(data);\n+\n+  switch (mxclass) {\n+    case mxSINGLE_CLASS:\n+      return WriteNumericData<arrow::FloatType>(data, validity_bitmap);\n+    case mxDOUBLE_CLASS:\n+      return WriteNumericData<arrow::DoubleType>(data, validity_bitmap);\n+    case mxUINT8_CLASS:\n+      return WriteNumericData<arrow::UInt8Type>(data, validity_bitmap);\n+    case mxUINT16_CLASS:\n+      return WriteNumericData<arrow::UInt16Type>(data, validity_bitmap);\n+    case mxUINT32_CLASS:\n+      return WriteNumericData<arrow::UInt32Type>(data, validity_bitmap);\n+    case mxUINT64_CLASS:\n+      return WriteNumericData<arrow::UInt64Type>(data, validity_bitmap);\n+    case mxINT8_CLASS:\n+      return WriteNumericData<arrow::Int8Type>(data, validity_bitmap);\n+    case mxINT16_CLASS:\n+      return WriteNumericData<arrow::Int16Type>(data, validity_bitmap);\n+    case mxINT32_CLASS:\n+      return WriteNumericData<arrow::Int32Type>(data, validity_bitmap);\n+    case mxINT64_CLASS:\n+      return WriteNumericData<arrow::Int64Type>(data, validity_bitmap);\n+\n+    default: {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:UnsupportedArrowType\",\n+                        \"Unsupported arrow::Type '%s' for variable '%s'\",\n+                        mxGetClassName(data), type.c_str());\n+    }\n+  }\n+\n+  // We shouldn't ever reach this branch, but if we do, return a null unique_ptr.\n+  return std::unique_ptr<arrow::Array>();\n+}\n+\n+}  // namespace internal\n+\n+arrow::Status FeatherWriter::Open(const std::string& filename,\n+                                  std::shared_ptr<FeatherWriter>* feather_writer) {\n+  // Allocate shared_ptr out parameter.\n+  *feather_writer = std::shared_ptr<FeatherWriter>(new FeatherWriter());\n+\n+  // Open a FileOutputStream corresponding to the provided filename.\n+  std::shared_ptr<arrow::io::OutputStream> writable_file(nullptr);\n+  ARROW_RETURN_NOT_OK(arrow::io::FileOutputStream::Open(filename, &writable_file));\n+\n+  // TableWriter::Open expects a shared_ptr to an OutputStream.\n+  // Open the Feather file for writing with a TableWriter.\n+  ARROW_RETURN_NOT_OK(arrow::ipc::feather::TableWriter::Open(\n+      writable_file, &(*feather_writer)->table_writer_));\n+\n+  return arrow::Status::OK();\n+}\n+\n+// Write table metadata to the Feather file from a mxArray*.\n+arrow::Status FeatherWriter::WriteMetadata(const mxArray* metadata) {\n+  // Verify that all required fieldnames are provided.\n+  internal::ValidateMxStructField(metadata, \"Description\", mxCHAR_CLASS, true);\n+  internal::ValidateMxStructField(metadata, \"Version\", mxDOUBLE_CLASS, false);\n+  internal::ValidateMxStructField(metadata, \"NumRows\", mxDOUBLE_CLASS, false);\n+  internal::ValidateMxStructField(metadata, \"NumVariables\", mxDOUBLE_CLASS, false);\n+\n+  // Convert Description to a std::string and set on FeatherWriter and TableWriter.\n+  std::string description =\n+      internal::MxArrayToString(mxGetField(metadata, 0, \"Description\"));\n+  this->description_ = description;\n+  this->table_writer_->SetDescription(description);\n+\n+  // Get the NumRows field in the struct array and set on TableWriter.\n+  this->num_rows_ = static_cast<int64_t>(mxGetScalar(mxGetField(metadata, 0, \"NumRows\")));\n+  this->table_writer_->SetNumRows(this->num_rows_);\n+\n+  // Get the total number of variables. This is checked later for consistency with\n+  // the provided number of columns before finishing the file write.\n+  this->num_variables_ =\n+      static_cast<int64_t>(mxGetScalar(mxGetField(metadata, 0, \"NumVariables\")));\n+\n+  // Store the version information so we could handle possible future API changes.\n+  this->version_ = static_cast<int32_t>(mxGetScalar(mxGetField(metadata, 0, \"Version\")));\n+\n+  return arrow::Status::OK();\n+}\n+\n+// Write mxArrays from MATLAB into a Feather file.\n+arrow::Status FeatherWriter::WriteVariables(const mxArray* variables) {\n+  // Verify that all required fieldnames are provided.\n+  internal::ValidateMxStructField(variables, \"Name\", mxCHAR_CLASS, true);\n+  internal::ValidateMxStructField(variables, \"Type\", mxCHAR_CLASS, false);\n+  internal::ValidateMxStructField(variables, \"Data\", mxUNKNOWN_CLASS, true);\n+  internal::ValidateMxStructField(variables, \"Valid\", mxLOGICAL_CLASS, true);\n+\n+  // Get the number of columns in the struct array.\n+  size_t num_columns = internal::GetNumberOfElements(variables);\n+\n+  // Verify that we have all the columns required for writing\n+  // Currently we need all columns to be passed in together in the WriteVariables method.\n+  internal::ValidateNumColumns(static_cast<int64_t>(num_columns), this->num_variables_);\n+\n+  // Set up packed validity buffer for later arrow::Buffers to reference and populate.\n+  // Since this is defined in the enclosing scope around any arrow::Buffer usage, this\n+  // should outlive any arrow::Buffers created on this range, thus avoiding dangling\n+  // references.\n+  std::shared_ptr<uint8_t> packed_validity_buffer =\n+      internal::MakePackedValidityBuffer(this->num_rows_);\n+\n+  // Iterate over the input columns and generate arrow arrays.\n+  for (int idx = 0; idx < num_columns; ++idx) {\n+    // Unwrap constituent mxArray*s from the mxStructArray*. This is safe since we\n+    // already checked for existence and non-nullness of these types.\n+    const mxArray* name = mxGetField(variables, idx, \"Name\");\n+    const mxArray* data = mxGetField(variables, idx, \"Data\");\n+    const mxArray* type = mxGetField(variables, idx, \"Type\");\n+    const mxArray* valid = mxGetField(variables, idx, \"Valid\");\n+\n+    // Convert column and type name to a std::string from mxArray*.\n+    std::string name_str = internal::MxArrayToString(name);\n+    std::string type_str = internal::MxArrayToString(type);\n+\n+    // Set up an arrow::Buffer which can be populated by the validity bitmap information\n+    // for the current column.\n+    int64_t packed_validity_buffer_len = internal::BitPackedLength(this->num_rows_);\n+    std::shared_ptr<arrow::MutableBuffer> validity_bitmap(new arrow::MutableBuffer(\n+        packed_validity_buffer.get(), packed_validity_buffer_len));\n+\n+    // Populate bit-packed arrow::Buffer using validity data in the mxArray*.\n+    internal::BitPackBuffer(valid, validity_bitmap);\n+\n+    // Wrap mxArray data in an arrow::Array of the equivalent type.\n+    std::unique_ptr<arrow::Array> array =\n+        internal::WriteVariableData(data, type_str, validity_bitmap);\n+\n+    // Verify that the arrow::Array has the right number of elements.\n+    internal::ValidateNumRows(array->length(), this->num_rows_);\n+\n+    // Write another column to the Feather file.\n+    ARROW_RETURN_NOT_OK(this->table_writer_->Append(name_str, *array));\n+  }\n+\n+  // Write the Feather file metadata to the end of the file.\n+  arrow::Status status = this->table_writer_->Finalize();\n \n Review comment:\n   Just return this Status\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-17T21:29:46.076+0000",
                    "updated": "2019-05-17T21:29:46.076+0000",
                    "started": "2019-05-17T21:29:46.075+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "244322",
                    "issueId": "13201194"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194/worklog/244323",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4328: ARROW-3897: [MATLAB] Add MATLAB support for writing numeric datatypes to a Feather file\nURL: https://github.com/apache/arrow/pull/4328#discussion_r285292921\n \n \n\n ##########\n File path: matlab/src/feather_writer.cc\n ##########\n @@ -0,0 +1,365 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+#include <functional> /* for std::multiplies */\n+#include <numeric>    /* for std::accumulate */\n+\n+#include <arrow/array.h>\n+#include <arrow/buffer.h>\n+#include <arrow/io/file.h>\n+#include <arrow/ipc/feather.h>\n+#include <arrow/status.h>\n+#include <arrow/table.h>\n+#include <arrow/type.h>\n+#include <arrow/util/bit-util.h>\n+\n+#include <mex.h>\n+\n+#include \"feather_writer.h\"\n+#include \"matlab_traits.h\"\n+#include \"util/handle_status.h\"\n+\n+namespace mlarrow {\n+\n+namespace internal {\n+\n+// Utility that helps verify the input mxArray struct field name and type.\n+// Returns void since any errors will throw and terminate MEX execution.\n+void ValidateMxStructField(const mxArray* struct_array, const char* fieldname,\n+                           const mxClassID expected_class_id, const bool can_be_empty) {\n+  // Check that the input mxArray is a struct array.\n+  if (!mxIsStruct(struct_array)) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectDimensionsOrType\",\n+                      \"Input needs to be a struct array\");\n+  }\n+\n+  // Return early if an empty table is provided as input.\n+  if (mxIsEmpty(struct_array)) {\n+    return;\n+  }\n+\n+  mxArray* field = mxGetField(struct_array, 0, fieldname);\n+\n+  if (!field) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:MissingStructField\",\n+                      \"Missing field '%s' in input struct array\", fieldname);\n+  }\n+\n+  mxClassID actual_class_id = mxGetClassID(field);\n+\n+  // Avoid type check if an mxUNKNOWN_CLASS is provided since the UNKNOWN type is used to\n+  // signify genericity in the input type.\n+  if (expected_class_id != mxUNKNOWN_CLASS) {\n+    if (expected_class_id != actual_class_id) {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:MissingStructField\",\n+                        \"Incorrect type '%s' for struct array field '%s'\",\n+                        mxGetClassName(field), fieldname);\n+    }\n+  }\n+\n+  // Some struct fields (like the table description) can be empty, while others \n+  // (like NumRows) should never be empty. This conditional helps account for both cases.\n+  if (!can_be_empty) {\n+    // Ensure that individual mxStructArray fields are non-empty.\n+    // We can call mxGetData after this without needing another null check.\n+    if (mxIsEmpty(field)) {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:EmptyStructField\",\n+                        \"Struct array field '%s' cannot be empty\", fieldname);\n+    }\n+  }\n+}\n+\n+// Utility function to convert mxChar mxArray* to std::string while preserving\n+// Unicode code points.\n+std::string MxArrayToString(const mxArray* array) {\n+  // Return empty std::string if a mxChar array is not passed in.\n+  if (!mxIsChar(array)) {\n+    return std::string();\n+  }\n+\n+  // Convert mxArray first to a C-style char array, then copy into a std::string.\n+  char* utf8_array = mxArrayToUTF8String(array);\n+  std::string output(utf8_array);\n+\n+  // Free the allocated char* from the MEX runtime.\n+  mxFree(utf8_array);\n+\n+  return output;\n+}\n+\n+// Compare number of columns and exit out to the MATLAB layer if incorrect.\n+void ValidateNumColumns(int64_t actual, int64_t expected) {\n+  if (actual != expected) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectNumberOfColumns\",\n+                      \"Received only '%d' columns but expected '%d' columns\", actual,\n+                      expected);\n+  }\n+}\n+\n+// Compare number of rows and exit out to the MATLAB layer if incorrect.\n+void ValidateNumRows(int64_t actual, int64_t expected) {\n+  if (actual != expected) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectNumberOfRows\",\n+                      \"Received only '%d' rows but expected '%d' rows\", actual, expected);\n+  }\n+}\n+\n+// Calculate the number of bytes required in the bit-packed validity buffer.\n+constexpr int64_t BitPackedLength(int64_t num_elements) {\n+  // Since mxLogicalArray encodes [0, 1] in a full byte, we can compress that byte\n+  // down to a bit...therefore dividing the mxLogicalArray length by 8 here.\n+  return static_cast<int64_t>(std::ceil(num_elements / 8.0));\n+}\n+\n+// Construct a bit-packed buffer on the heap for validity information.\n+std::shared_ptr<uint8_t> MakePackedValidityBuffer(int64_t num_elements) {\n+  return std::shared_ptr<uint8_t>(new uint8_t[BitPackedLength(num_elements)]);\n \n Review comment:\n   Maybe you want to use the built-in allocation utilities and use `arrow::MemoryPool`? https://github.com/apache/arrow/blob/b496913e5ddb7d8bbef65a59be5a54ac14bf6740/cpp/src/arrow/buffer.h#L402\r\n   \r\n   This has the side benefit of properly capturing allocation errors (which would occur as `std::bad_alloc` here I think)\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-17T21:29:46.122+0000",
                    "updated": "2019-05-17T21:29:46.122+0000",
                    "started": "2019-05-17T21:29:46.121+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "244323",
                    "issueId": "13201194"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194/worklog/244324",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4328: ARROW-3897: [MATLAB] Add MATLAB support for writing numeric datatypes to a Feather file\nURL: https://github.com/apache/arrow/pull/4328#discussion_r285292679\n \n \n\n ##########\n File path: matlab/src/feather_writer.cc\n ##########\n @@ -0,0 +1,365 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+#include <functional> /* for std::multiplies */\n+#include <numeric>    /* for std::accumulate */\n+\n+#include <arrow/array.h>\n+#include <arrow/buffer.h>\n+#include <arrow/io/file.h>\n+#include <arrow/ipc/feather.h>\n+#include <arrow/status.h>\n+#include <arrow/table.h>\n+#include <arrow/type.h>\n+#include <arrow/util/bit-util.h>\n+\n+#include <mex.h>\n+\n+#include \"feather_writer.h\"\n+#include \"matlab_traits.h\"\n+#include \"util/handle_status.h\"\n+\n+namespace mlarrow {\n+\n+namespace internal {\n+\n+// Utility that helps verify the input mxArray struct field name and type.\n+// Returns void since any errors will throw and terminate MEX execution.\n+void ValidateMxStructField(const mxArray* struct_array, const char* fieldname,\n+                           const mxClassID expected_class_id, const bool can_be_empty) {\n+  // Check that the input mxArray is a struct array.\n+  if (!mxIsStruct(struct_array)) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectDimensionsOrType\",\n+                      \"Input needs to be a struct array\");\n+  }\n+\n+  // Return early if an empty table is provided as input.\n+  if (mxIsEmpty(struct_array)) {\n+    return;\n+  }\n+\n+  mxArray* field = mxGetField(struct_array, 0, fieldname);\n+\n+  if (!field) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:MissingStructField\",\n+                      \"Missing field '%s' in input struct array\", fieldname);\n+  }\n+\n+  mxClassID actual_class_id = mxGetClassID(field);\n+\n+  // Avoid type check if an mxUNKNOWN_CLASS is provided since the UNKNOWN type is used to\n+  // signify genericity in the input type.\n+  if (expected_class_id != mxUNKNOWN_CLASS) {\n+    if (expected_class_id != actual_class_id) {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:MissingStructField\",\n+                        \"Incorrect type '%s' for struct array field '%s'\",\n+                        mxGetClassName(field), fieldname);\n+    }\n+  }\n+\n+  // Some struct fields (like the table description) can be empty, while others \n+  // (like NumRows) should never be empty. This conditional helps account for both cases.\n+  if (!can_be_empty) {\n+    // Ensure that individual mxStructArray fields are non-empty.\n+    // We can call mxGetData after this without needing another null check.\n+    if (mxIsEmpty(field)) {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:EmptyStructField\",\n+                        \"Struct array field '%s' cannot be empty\", fieldname);\n+    }\n+  }\n+}\n+\n+// Utility function to convert mxChar mxArray* to std::string while preserving\n+// Unicode code points.\n+std::string MxArrayToString(const mxArray* array) {\n+  // Return empty std::string if a mxChar array is not passed in.\n+  if (!mxIsChar(array)) {\n+    return std::string();\n+  }\n+\n+  // Convert mxArray first to a C-style char array, then copy into a std::string.\n+  char* utf8_array = mxArrayToUTF8String(array);\n+  std::string output(utf8_array);\n+\n+  // Free the allocated char* from the MEX runtime.\n+  mxFree(utf8_array);\n+\n+  return output;\n+}\n+\n+// Compare number of columns and exit out to the MATLAB layer if incorrect.\n+void ValidateNumColumns(int64_t actual, int64_t expected) {\n+  if (actual != expected) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectNumberOfColumns\",\n+                      \"Received only '%d' columns but expected '%d' columns\", actual,\n+                      expected);\n+  }\n+}\n+\n+// Compare number of rows and exit out to the MATLAB layer if incorrect.\n+void ValidateNumRows(int64_t actual, int64_t expected) {\n+  if (actual != expected) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectNumberOfRows\",\n+                      \"Received only '%d' rows but expected '%d' rows\", actual, expected);\n+  }\n+}\n+\n+// Calculate the number of bytes required in the bit-packed validity buffer.\n+constexpr int64_t BitPackedLength(int64_t num_elements) {\n+  // Since mxLogicalArray encodes [0, 1] in a full byte, we can compress that byte\n+  // down to a bit...therefore dividing the mxLogicalArray length by 8 here.\n+  return static_cast<int64_t>(std::ceil(num_elements / 8.0));\n+}\n+\n+// Construct a bit-packed buffer on the heap for validity information.\n+std::shared_ptr<uint8_t> MakePackedValidityBuffer(int64_t num_elements) {\n+  return std::shared_ptr<uint8_t>(new uint8_t[BitPackedLength(num_elements)]);\n+}\n+\n+// Calculate the total number of elements in an mxArray\n+// We have to do this separately since mxGetNumberOfElements only works in numeric arrays\n+size_t GetNumberOfElements(const mxArray* array) {\n+  // Get the dimensions and the total number of dimensions from the mxArray*.\n+  const size_t num_dimensions = mxGetNumberOfDimensions(array);\n+  const size_t* dimensions = mxGetDimensions(array);\n+\n+  // Iterate over the dimensions array and accumulate the total number of elements.\n+  return std::accumulate(dimensions, dimensions + num_dimensions, 1,\n+                         std::multiplies<size_t>());\n+}\n+\n+// Write an mxLogicalArray* into a bit-packed arrow::MutableBuffer\n+void BitPackBuffer(const mxArray* logical_array,\n+                           std::shared_ptr<arrow::MutableBuffer> packed_buffer) {\n+  // Error out if the incorrect type is passed in.\n+  if (!mxIsLogical(logical_array)) {\n+    mexErrMsgIdAndTxt(\n+        \"MATLAB:arrow:IncorrectType\",\n+        \"Expected mxLogical array as input but received mxArray of class '%s'\",\n+        mxGetClassName(logical_array));\n+  }\n+\n+  // Validate that the input arrow::Buffer has sufficent size to store a full bit-packed\n+  // representation of the input mxLogicalArray\n+  int64_t unpacked_buffer_length = GetNumberOfElements(logical_array);\n+  if (BitPackedLength(unpacked_buffer_length) > packed_buffer->capacity()) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:BufferSizeExceeded\",\n+                      \"Buffer of size %d bytes cannot store %d bytes of data\",\n+                      packed_buffer->capacity(), BitPackedLength(unpacked_buffer_length));\n+  }\n+\n+  // Get pointers to the internal uint8_t arrays behind arrow::Buffer and mxArray\n+  uint8_t* packed_buffer_ptr = packed_buffer->mutable_data();\n+  const uint8_t* unpacked_buffer_ptr =\n+      reinterpret_cast<const uint8_t*>(mxGetLogicals(logical_array));\n+\n+  // Iterate over the mxLogical array and write bit-packed bools to the arrow::Buffer.\n+  for (int64_t i = 0; i < unpacked_buffer_length; ++i) {\n+    // If the mxLogical value is true, set the corresponding bit in the bit-packed\n+    // buffer. Otherwise, clear that bit.\n+    if (unpacked_buffer_ptr[i]) {\n+      arrow::BitUtil::SetBit(packed_buffer_ptr, i);\n+    } else {\n+      arrow::BitUtil::ClearBit(packed_buffer_ptr, i);\n+    }\n+  }\n+}\n+\n+// Write numeric datatypes to the Feather file.\n+template <typename ArrowDataType>\n+std::unique_ptr<arrow::Array> WriteNumericData(\n+    const mxArray* data, const std::shared_ptr<arrow::Buffer> validity_bitmap) {\n+  // Alias the type name for the underlying MATLAB type.\n+  using MatlabType = typename MatlabTraits<ArrowDataType>::MatlabType;\n+\n+  // Get a pointer to the underlying mxArray data.\n+  // We need to (temporarily) cast away const here since the mxGet* functions do not\n+  // accept a const input parameter for compatibility reasons.\n+  const MatlabType* dt = MatlabTraits<ArrowDataType>::GetData(const_cast<mxArray*>(data));\n+\n+  // Construct an arrow::Buffer that points to the underlying mxArray without copying.\n+  // - The lifetime of the mxArray buffer exceeds that of the arrow::Buffer here since\n+  //   MATLAB should only free this region on garbage-collection after the MEX function\n+  //   is executed. Therefore it is safe for arrow::Buffer to point to this location.\n+  // - However arrow::Buffer must not free this region by itself, since that could cause\n+  //   segfaults if the input array is used later in MATLAB.\n+  //   - The Doxygen doc for arrow::Buffer's constructor implies that it is not an RAII\n+  //     type, so this should be safe from possible double-free here.\n+  std::shared_ptr<arrow::Buffer> buffer(\n+      new arrow::Buffer(reinterpret_cast<const uint8_t*>(dt),\n+                        mxGetElementSize(data) * mxGetNumberOfElements(data)));\n+\n+  // Construct arrow::NumericArray specialization using arrow::Buffer.\n+  // Pass in nulls information...we could compute and provide the number of nulls here too,\n+  // but passing -1 for now so that Arrow recomputes it if necessary.\n+  std::unique_ptr<arrow::Array> array_wrapper(new arrow::NumericArray<ArrowDataType>(\n+      mxGetNumberOfElements(data), buffer, validity_bitmap, -1));\n+\n+  return array_wrapper;\n+}\n+\n+// Dispatch MATLAB column data to the correct arrow::Array converter.\n+std::unique_ptr<arrow::Array> WriteVariableData(\n+    const mxArray* data, const std::string& type,\n+    const std::shared_ptr<arrow::Buffer> validity_bitmap) {\n+  // Get the underlying type of the mxArray data.\n+  const mxClassID mxclass = mxGetClassID(data);\n+\n+  switch (mxclass) {\n+    case mxSINGLE_CLASS:\n+      return WriteNumericData<arrow::FloatType>(data, validity_bitmap);\n+    case mxDOUBLE_CLASS:\n+      return WriteNumericData<arrow::DoubleType>(data, validity_bitmap);\n+    case mxUINT8_CLASS:\n+      return WriteNumericData<arrow::UInt8Type>(data, validity_bitmap);\n+    case mxUINT16_CLASS:\n+      return WriteNumericData<arrow::UInt16Type>(data, validity_bitmap);\n+    case mxUINT32_CLASS:\n+      return WriteNumericData<arrow::UInt32Type>(data, validity_bitmap);\n+    case mxUINT64_CLASS:\n+      return WriteNumericData<arrow::UInt64Type>(data, validity_bitmap);\n+    case mxINT8_CLASS:\n+      return WriteNumericData<arrow::Int8Type>(data, validity_bitmap);\n+    case mxINT16_CLASS:\n+      return WriteNumericData<arrow::Int16Type>(data, validity_bitmap);\n+    case mxINT32_CLASS:\n+      return WriteNumericData<arrow::Int32Type>(data, validity_bitmap);\n+    case mxINT64_CLASS:\n+      return WriteNumericData<arrow::Int64Type>(data, validity_bitmap);\n+\n+    default: {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:UnsupportedArrowType\",\n+                        \"Unsupported arrow::Type '%s' for variable '%s'\",\n+                        mxGetClassName(data), type.c_str());\n+    }\n+  }\n+\n+  // We shouldn't ever reach this branch, but if we do, return a null unique_ptr.\n+  return std::unique_ptr<arrow::Array>();\n+}\n+\n+}  // namespace internal\n+\n+arrow::Status FeatherWriter::Open(const std::string& filename,\n+                                  std::shared_ptr<FeatherWriter>* feather_writer) {\n+  // Allocate shared_ptr out parameter.\n+  *feather_writer = std::shared_ptr<FeatherWriter>(new FeatherWriter());\n+\n+  // Open a FileOutputStream corresponding to the provided filename.\n+  std::shared_ptr<arrow::io::OutputStream> writable_file(nullptr);\n+  ARROW_RETURN_NOT_OK(arrow::io::FileOutputStream::Open(filename, &writable_file));\n+\n+  // TableWriter::Open expects a shared_ptr to an OutputStream.\n+  // Open the Feather file for writing with a TableWriter.\n+  ARROW_RETURN_NOT_OK(arrow::ipc::feather::TableWriter::Open(\n+      writable_file, &(*feather_writer)->table_writer_));\n+\n+  return arrow::Status::OK();\n+}\n+\n+// Write table metadata to the Feather file from a mxArray*.\n+arrow::Status FeatherWriter::WriteMetadata(const mxArray* metadata) {\n+  // Verify that all required fieldnames are provided.\n+  internal::ValidateMxStructField(metadata, \"Description\", mxCHAR_CLASS, true);\n+  internal::ValidateMxStructField(metadata, \"Version\", mxDOUBLE_CLASS, false);\n+  internal::ValidateMxStructField(metadata, \"NumRows\", mxDOUBLE_CLASS, false);\n+  internal::ValidateMxStructField(metadata, \"NumVariables\", mxDOUBLE_CLASS, false);\n+\n+  // Convert Description to a std::string and set on FeatherWriter and TableWriter.\n+  std::string description =\n+      internal::MxArrayToString(mxGetField(metadata, 0, \"Description\"));\n+  this->description_ = description;\n+  this->table_writer_->SetDescription(description);\n+\n+  // Get the NumRows field in the struct array and set on TableWriter.\n+  this->num_rows_ = static_cast<int64_t>(mxGetScalar(mxGetField(metadata, 0, \"NumRows\")));\n+  this->table_writer_->SetNumRows(this->num_rows_);\n+\n+  // Get the total number of variables. This is checked later for consistency with\n+  // the provided number of columns before finishing the file write.\n+  this->num_variables_ =\n+      static_cast<int64_t>(mxGetScalar(mxGetField(metadata, 0, \"NumVariables\")));\n+\n+  // Store the version information so we could handle possible future API changes.\n+  this->version_ = static_cast<int32_t>(mxGetScalar(mxGetField(metadata, 0, \"Version\")));\n+\n+  return arrow::Status::OK();\n \n Review comment:\n   It doesn't seem like this function is capable of returning an error Status\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-17T21:29:46.125+0000",
                    "updated": "2019-05-17T21:29:46.125+0000",
                    "started": "2019-05-17T21:29:46.124+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "244324",
                    "issueId": "13201194"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194/worklog/244325",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4328: ARROW-3897: [MATLAB] Add MATLAB support for writing numeric datatypes to a Feather file\nURL: https://github.com/apache/arrow/pull/4328#discussion_r285293812\n \n \n\n ##########\n File path: matlab/src/+mlarrow/+util/table2mlarrow.m\n ##########\n @@ -0,0 +1,87 @@\n+function [variables, metadata] = table2mlarrow(t)\n+%TABLE2MLARROW Converts a MATLAB table into a form\n+%   suitable for passing to the mlarrow C++ MEX layer.\n+%\n+%   [VARIABLES, METADATA] = TABLE2MLARROW(T)\n+%   Takes a MATLAB table T and returns struct array equivalents\n+%   which are suitable for passing to the mlarrow C++ MEX layer.\n+%\n+%   VARIABLES is an 1xN struct array representing the the table variables.\n+%\n+%   VARIABLES contains the following fields:\n+%\n+%   Field Name     Class        Description\n+%   ------------   -------      ----------------------------------------------\n+%   Name           char         Variable's name\n+%   Type           char         Variable's MATLAB datatype\n+%   Data           numeric      Variable's data\n+%   Valid          logical      0 = invalid (null), 1 = valid (non-null) value\n+%\n+%   METADATA is a 1x1 struct array with the following fields:\n+%\n+%   METADATA contains the following fields:\n+%\n+%   Field Name    Class         Description\n+%   ------------  -------       ----------------------------------------------\n+%   Description   char          Table description (T.Properties.Description)\n+%   NumRows       double        Number of table rows (height(T))\n+%   NumVariables  double        Number of table variables (width(T))\n+%   Version       double        Feather file version to write\n+%\n+%   See also FEATHERREAD, FEATHERWRITE.\n+\n+% Licensed to the Apache Software Foundation (ASF) under one or more\n+% contributor license agreements.  See the NOTICE file distributed with\n+% this work for additional information regarding copyright ownership.\n+% The ASF licenses this file to you under the Apache License, Version\n+% 2.0 (the \"License\"); you may not use this file except in compliance\n+% with the License.  You may obtain a copy of the License at\n+%\n+%   http://www.apache.org/licenses/LICENSE-2.0\n+%\n+% Unless required by applicable law or agreed to in writing, software\n+% distributed under the License is distributed on an \"AS IS\" BASIS,\n+% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+% implied.  See the License for the specific language governing\n+% permissions and limitations under the License.\n+\n+import mlarrow.util.*;\n+\n+% Currently, featherwrite only supports Version 2 Feather files.\n+featherVersion = 2;\n \n Review comment:\n   I'm curious why this detail needs to be here at all\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-17T21:29:46.145+0000",
                    "updated": "2019-05-17T21:29:46.145+0000",
                    "started": "2019-05-17T21:29:46.144+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "244325",
                    "issueId": "13201194"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194/worklog/244327",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4328: ARROW-3897: [MATLAB] Add MATLAB support for writing numeric datatypes to a Feather file\nURL: https://github.com/apache/arrow/pull/4328#discussion_r285295810\n \n \n\n ##########\n File path: matlab/src/feather_reader.cc\n ##########\n @@ -102,34 +111,93 @@ mxArray* ReadVariableData(const std::shared_ptr<arrow::Column>& column) {\n   return nullptr;\n }\n \n-// Read the nulls of variable i from the Feather file as a mxArray*.\n-mxArray* ReadVariableNulls(const std::shared_ptr<arrow::Column>& column) {\n-  // TODO: Implement proper null value support. For the time being,\n-  // we will simply return a zero initialized logical array to MATLAB.\n-  return mxCreateLogicalMatrix(column->length(), 1);\n+// arrow::Buffers are bit-packed, while mxLogical arrays aren't. This utility\n+// uses arrow::BitUtil::GetBit to copy each bit of an arrow::Buffer into\n+// each byte of an mxLogical array.\n+void BitUnpackBuffer(const std::shared_ptr<arrow::Buffer>& source, const int64_t length,\n+                     bool* destination) {\n+\n+  // If the arrow::Buffer's null_bitmap pointer is nullptr, then fill\n+  // the destination with values to signify valid elements.\n+  if (!source) {\n+    std::fill(destination, destination + length, true);\n+    return;\n+  }\n+\n+  const uint8_t* source_data = source->data();\n+\n+  // Unpack the bit-packed validity (null) bitmap.\n+  for (int64_t i = 0; i < length; ++i) {\n+    // Here arrow::BitUtil::GetBit will return an expanded 8-bit bool representation \n+    // of a single bit in the validity bitmap.\n+    destination[i] = arrow::BitUtil::GetBit(source_data, i);\n \n Review comment:\n   We already have facilities named GenerateBits() and GenerateBitsUnrolled() to store bits sequentially in a bitmap.\r\n   \r\n   So symmetrically we could have e.g. VisitBits() and VisitBitsUnrolled() to read bits sequentially from a bitmap.\r\n   \r\n   Note that BitmapReader should already be faster than a na\u00efve loop that calls GetBit().\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-17T21:35:04.824+0000",
                    "updated": "2019-05-17T21:35:04.824+0000",
                    "started": "2019-05-17T21:35:04.823+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "244327",
                    "issueId": "13201194"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194/worklog/244328",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4328: ARROW-3897: [MATLAB] Add MATLAB support for writing numeric datatypes to a Feather file\nURL: https://github.com/apache/arrow/pull/4328#discussion_r285296416\n \n \n\n ##########\n File path: matlab/src/feather_writer.cc\n ##########\n @@ -0,0 +1,365 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+#include <functional> /* for std::multiplies */\n+#include <numeric>    /* for std::accumulate */\n+\n+#include <arrow/array.h>\n+#include <arrow/buffer.h>\n+#include <arrow/io/file.h>\n+#include <arrow/ipc/feather.h>\n+#include <arrow/status.h>\n+#include <arrow/table.h>\n+#include <arrow/type.h>\n+#include <arrow/util/bit-util.h>\n+\n+#include <mex.h>\n+\n+#include \"feather_writer.h\"\n+#include \"matlab_traits.h\"\n+#include \"util/handle_status.h\"\n+\n+namespace mlarrow {\n+\n+namespace internal {\n+\n+// Utility that helps verify the input mxArray struct field name and type.\n+// Returns void since any errors will throw and terminate MEX execution.\n+void ValidateMxStructField(const mxArray* struct_array, const char* fieldname,\n+                           const mxClassID expected_class_id, const bool can_be_empty) {\n+  // Check that the input mxArray is a struct array.\n+  if (!mxIsStruct(struct_array)) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectDimensionsOrType\",\n+                      \"Input needs to be a struct array\");\n+  }\n+\n+  // Return early if an empty table is provided as input.\n+  if (mxIsEmpty(struct_array)) {\n+    return;\n+  }\n+\n+  mxArray* field = mxGetField(struct_array, 0, fieldname);\n+\n+  if (!field) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:MissingStructField\",\n+                      \"Missing field '%s' in input struct array\", fieldname);\n+  }\n+\n+  mxClassID actual_class_id = mxGetClassID(field);\n+\n+  // Avoid type check if an mxUNKNOWN_CLASS is provided since the UNKNOWN type is used to\n+  // signify genericity in the input type.\n+  if (expected_class_id != mxUNKNOWN_CLASS) {\n+    if (expected_class_id != actual_class_id) {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:MissingStructField\",\n+                        \"Incorrect type '%s' for struct array field '%s'\",\n+                        mxGetClassName(field), fieldname);\n+    }\n+  }\n+\n+  // Some struct fields (like the table description) can be empty, while others \n+  // (like NumRows) should never be empty. This conditional helps account for both cases.\n+  if (!can_be_empty) {\n+    // Ensure that individual mxStructArray fields are non-empty.\n+    // We can call mxGetData after this without needing another null check.\n+    if (mxIsEmpty(field)) {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:EmptyStructField\",\n+                        \"Struct array field '%s' cannot be empty\", fieldname);\n+    }\n+  }\n+}\n+\n+// Utility function to convert mxChar mxArray* to std::string while preserving\n+// Unicode code points.\n+std::string MxArrayToString(const mxArray* array) {\n+  // Return empty std::string if a mxChar array is not passed in.\n+  if (!mxIsChar(array)) {\n+    return std::string();\n+  }\n+\n+  // Convert mxArray first to a C-style char array, then copy into a std::string.\n+  char* utf8_array = mxArrayToUTF8String(array);\n+  std::string output(utf8_array);\n+\n+  // Free the allocated char* from the MEX runtime.\n+  mxFree(utf8_array);\n+\n+  return output;\n+}\n+\n+// Compare number of columns and exit out to the MATLAB layer if incorrect.\n+void ValidateNumColumns(int64_t actual, int64_t expected) {\n+  if (actual != expected) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectNumberOfColumns\",\n+                      \"Received only '%d' columns but expected '%d' columns\", actual,\n+                      expected);\n+  }\n+}\n+\n+// Compare number of rows and exit out to the MATLAB layer if incorrect.\n+void ValidateNumRows(int64_t actual, int64_t expected) {\n+  if (actual != expected) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectNumberOfRows\",\n+                      \"Received only '%d' rows but expected '%d' rows\", actual, expected);\n+  }\n+}\n+\n+// Calculate the number of bytes required in the bit-packed validity buffer.\n+constexpr int64_t BitPackedLength(int64_t num_elements) {\n+  // Since mxLogicalArray encodes [0, 1] in a full byte, we can compress that byte\n+  // down to a bit...therefore dividing the mxLogicalArray length by 8 here.\n+  return static_cast<int64_t>(std::ceil(num_elements / 8.0));\n+}\n+\n+// Construct a bit-packed buffer on the heap for validity information.\n+std::shared_ptr<uint8_t> MakePackedValidityBuffer(int64_t num_elements) {\n+  return std::shared_ptr<uint8_t>(new uint8_t[BitPackedLength(num_elements)]);\n \n Review comment:\n   Right, also I'm not sure it's ok to use `shared_ptr` around array allocations.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-17T21:37:30.467+0000",
                    "updated": "2019-05-17T21:37:30.467+0000",
                    "started": "2019-05-17T21:37:30.466+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "244328",
                    "issueId": "13201194"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194/worklog/246751",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kevingurney commented on pull request #4328: ARROW-3897: [MATLAB] Add MATLAB support for writing numeric datatypes to a Feather file\nURL: https://github.com/apache/arrow/pull/4328#discussion_r286521605\n \n \n\n ##########\n File path: matlab/src/feather_reader.cc\n ##########\n @@ -102,34 +111,93 @@ mxArray* ReadVariableData(const std::shared_ptr<arrow::Column>& column) {\n   return nullptr;\n }\n \n-// Read the nulls of variable i from the Feather file as a mxArray*.\n-mxArray* ReadVariableNulls(const std::shared_ptr<arrow::Column>& column) {\n-  // TODO: Implement proper null value support. For the time being,\n-  // we will simply return a zero initialized logical array to MATLAB.\n-  return mxCreateLogicalMatrix(column->length(), 1);\n+// arrow::Buffers are bit-packed, while mxLogical arrays aren't. This utility\n+// uses arrow::BitUtil::GetBit to copy each bit of an arrow::Buffer into\n+// each byte of an mxLogical array.\n+void BitUnpackBuffer(const std::shared_ptr<arrow::Buffer>& source, const int64_t length,\n+                     bool* destination) {\n+\n+  // If the arrow::Buffer's null_bitmap pointer is nullptr, then fill\n+  // the destination with values to signify valid elements.\n+  if (!source) {\n+    std::fill(destination, destination + length, true);\n+    return;\n+  }\n+\n+  const uint8_t* source_data = source->data();\n+\n+  // Unpack the bit-packed validity (null) bitmap.\n+  for (int64_t i = 0; i < length; ++i) {\n+    // Here arrow::BitUtil::GetBit will return an expanded 8-bit bool representation \n+    // of a single bit in the validity bitmap.\n+    destination[i] = arrow::BitUtil::GetBit(source_data, i);\n+  }\n+}\n+\n+// Read the validity (null) bitmap of variable i from the Feather\n+// file as an mxArray*.\n+mxArray* ReadVariableValidityBitmap(const std::shared_ptr<arrow::Column>& column) {\n+  // Allocate an mxLogical array to store the validity (null) bitmap values.\n+  // Note: All Arrow arrays can have an associated validity (null) bitmap.\n+  // The Apache Arrow specification defines 0 (false) to represent an\n+  // invalid (null) array entry and 1 (true) to represent a valid\n+  // (non-null) array entry.\n+  mxArray* validity_bitmap = mxCreateLogicalMatrix(column->length(), 1);\n+  bool* validity_bitmap_unpacked = static_cast<bool*>(mxGetLogicals(validity_bitmap));\n+\n+  // The Apache Arrow specification allows validity (null) bitmaps\n+  // to be unallocated if there are no null values. In this case,\n+  // we simply return a logical array filled with the value true.\n+  if (column->null_count() == 0) {\n+    std::fill(validity_bitmap_unpacked, validity_bitmap_unpacked + column->length(),\n+              true);\n+    return validity_bitmap;\n+  }\n+\n+  std::shared_ptr<arrow::ChunkedArray> chunked_array = column->data();\n+  const int32_t num_chunks = chunked_array->num_chunks();\n+\n+  int64_t mx_array_offset = 0;\n+  // Iterate over each arrow::Array in the arrow::ChunkedArray.\n+  for (int32_t chunk_index = 0; chunk_index < num_chunks; ++chunk_index) {\n+\n+    std::shared_ptr<arrow::Array> array = chunked_array->chunk(chunk_index);\n+    const int64_t array_length = array->length();\n+\n+    internal::BitUnpackBuffer(array->null_bitmap(), array_length,\n+                              validity_bitmap_unpacked + mx_array_offset);\n+\n+    mx_array_offset += array_length;\n+  }\n+\n+  return validity_bitmap;\n }\n \n-// Read the type of variable i from the Feather file as a mxArray*.\n+// Read the type name of an Arrow column as an mxChar array.\n mxArray* ReadVariableType(const std::shared_ptr<arrow::Column>& column) {\n-  return mxCreateString(column->type()->name().c_str());\n+  return mlarrow::util::ConvertUTF8StringToUTF16CharMatrix(column->type()->name());\n }\n \n-// MATLAB arrays cannot be larger than 2^48.\n+// MATLAB arrays cannot be larger than 2^48 elements.\n static constexpr uint64_t MAX_MATLAB_SIZE = static_cast<uint64_t>(0x01) << 48;\n \n }  // namespace internal\n \n arrow::Status FeatherReader::Open(const std::string& filename,\n                                   std::shared_ptr<FeatherReader>* feather_reader) {\n   *feather_reader = std::shared_ptr<FeatherReader>(new FeatherReader());\n+ \n   // Open file with given filename as a ReadableFile.\n   std::shared_ptr<arrow::io::ReadableFile> readable_file(nullptr);\n-  auto status = arrow::io::ReadableFile::Open(filename, &readable_file);\n+  \n+  arrow::Status status = arrow::io::ReadableFile::Open(filename, &readable_file);\n   if (!status.ok()) {\n     return status;\n   }\n \n Review comment:\n   Fixed.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-22T14:31:06.042+0000",
                    "updated": "2019-05-22T14:31:06.042+0000",
                    "started": "2019-05-22T14:31:06.035+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "246751",
                    "issueId": "13201194"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194/worklog/246793",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kevingurney commented on pull request #4328: ARROW-3897: [MATLAB] Add MATLAB support for writing numeric datatypes to a Feather file\nURL: https://github.com/apache/arrow/pull/4328#discussion_r286536275\n \n \n\n ##########\n File path: matlab/src/feather_writer.cc\n ##########\n @@ -0,0 +1,365 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+#include <functional> /* for std::multiplies */\n+#include <numeric>    /* for std::accumulate */\n+\n+#include <arrow/array.h>\n+#include <arrow/buffer.h>\n+#include <arrow/io/file.h>\n+#include <arrow/ipc/feather.h>\n+#include <arrow/status.h>\n+#include <arrow/table.h>\n+#include <arrow/type.h>\n+#include <arrow/util/bit-util.h>\n+\n+#include <mex.h>\n+\n+#include \"feather_writer.h\"\n+#include \"matlab_traits.h\"\n+#include \"util/handle_status.h\"\n+\n+namespace mlarrow {\n+\n+namespace internal {\n+\n+// Utility that helps verify the input mxArray struct field name and type.\n+// Returns void since any errors will throw and terminate MEX execution.\n+void ValidateMxStructField(const mxArray* struct_array, const char* fieldname,\n+                           const mxClassID expected_class_id, const bool can_be_empty) {\n+  // Check that the input mxArray is a struct array.\n+  if (!mxIsStruct(struct_array)) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectDimensionsOrType\",\n+                      \"Input needs to be a struct array\");\n+  }\n+\n+  // Return early if an empty table is provided as input.\n+  if (mxIsEmpty(struct_array)) {\n+    return;\n+  }\n+\n+  mxArray* field = mxGetField(struct_array, 0, fieldname);\n+\n+  if (!field) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:MissingStructField\",\n+                      \"Missing field '%s' in input struct array\", fieldname);\n+  }\n+\n+  mxClassID actual_class_id = mxGetClassID(field);\n+\n+  // Avoid type check if an mxUNKNOWN_CLASS is provided since the UNKNOWN type is used to\n+  // signify genericity in the input type.\n+  if (expected_class_id != mxUNKNOWN_CLASS) {\n+    if (expected_class_id != actual_class_id) {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:MissingStructField\",\n+                        \"Incorrect type '%s' for struct array field '%s'\",\n+                        mxGetClassName(field), fieldname);\n+    }\n+  }\n+\n+  // Some struct fields (like the table description) can be empty, while others \n+  // (like NumRows) should never be empty. This conditional helps account for both cases.\n+  if (!can_be_empty) {\n+    // Ensure that individual mxStructArray fields are non-empty.\n+    // We can call mxGetData after this without needing another null check.\n+    if (mxIsEmpty(field)) {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:EmptyStructField\",\n+                        \"Struct array field '%s' cannot be empty\", fieldname);\n+    }\n+  }\n+}\n+\n+// Utility function to convert mxChar mxArray* to std::string while preserving\n+// Unicode code points.\n+std::string MxArrayToString(const mxArray* array) {\n+  // Return empty std::string if a mxChar array is not passed in.\n+  if (!mxIsChar(array)) {\n+    return std::string();\n+  }\n+\n+  // Convert mxArray first to a C-style char array, then copy into a std::string.\n+  char* utf8_array = mxArrayToUTF8String(array);\n+  std::string output(utf8_array);\n+\n+  // Free the allocated char* from the MEX runtime.\n+  mxFree(utf8_array);\n+\n+  return output;\n+}\n+\n+// Compare number of columns and exit out to the MATLAB layer if incorrect.\n+void ValidateNumColumns(int64_t actual, int64_t expected) {\n+  if (actual != expected) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectNumberOfColumns\",\n+                      \"Received only '%d' columns but expected '%d' columns\", actual,\n+                      expected);\n+  }\n+}\n+\n+// Compare number of rows and exit out to the MATLAB layer if incorrect.\n+void ValidateNumRows(int64_t actual, int64_t expected) {\n+  if (actual != expected) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:IncorrectNumberOfRows\",\n+                      \"Received only '%d' rows but expected '%d' rows\", actual, expected);\n+  }\n+}\n+\n+// Calculate the number of bytes required in the bit-packed validity buffer.\n+constexpr int64_t BitPackedLength(int64_t num_elements) {\n+  // Since mxLogicalArray encodes [0, 1] in a full byte, we can compress that byte\n+  // down to a bit...therefore dividing the mxLogicalArray length by 8 here.\n+  return static_cast<int64_t>(std::ceil(num_elements / 8.0));\n+}\n+\n+// Construct a bit-packed buffer on the heap for validity information.\n+std::shared_ptr<uint8_t> MakePackedValidityBuffer(int64_t num_elements) {\n+  return std::shared_ptr<uint8_t>(new uint8_t[BitPackedLength(num_elements)]);\n+}\n+\n+// Calculate the total number of elements in an mxArray\n+// We have to do this separately since mxGetNumberOfElements only works in numeric arrays\n+size_t GetNumberOfElements(const mxArray* array) {\n+  // Get the dimensions and the total number of dimensions from the mxArray*.\n+  const size_t num_dimensions = mxGetNumberOfDimensions(array);\n+  const size_t* dimensions = mxGetDimensions(array);\n+\n+  // Iterate over the dimensions array and accumulate the total number of elements.\n+  return std::accumulate(dimensions, dimensions + num_dimensions, 1,\n+                         std::multiplies<size_t>());\n+}\n+\n+// Write an mxLogicalArray* into a bit-packed arrow::MutableBuffer\n+void BitPackBuffer(const mxArray* logical_array,\n+                           std::shared_ptr<arrow::MutableBuffer> packed_buffer) {\n+  // Error out if the incorrect type is passed in.\n+  if (!mxIsLogical(logical_array)) {\n+    mexErrMsgIdAndTxt(\n+        \"MATLAB:arrow:IncorrectType\",\n+        \"Expected mxLogical array as input but received mxArray of class '%s'\",\n+        mxGetClassName(logical_array));\n+  }\n+\n+  // Validate that the input arrow::Buffer has sufficent size to store a full bit-packed\n+  // representation of the input mxLogicalArray\n+  int64_t unpacked_buffer_length = GetNumberOfElements(logical_array);\n+  if (BitPackedLength(unpacked_buffer_length) > packed_buffer->capacity()) {\n+    mexErrMsgIdAndTxt(\"MATLAB:arrow:BufferSizeExceeded\",\n+                      \"Buffer of size %d bytes cannot store %d bytes of data\",\n+                      packed_buffer->capacity(), BitPackedLength(unpacked_buffer_length));\n+  }\n+\n+  // Get pointers to the internal uint8_t arrays behind arrow::Buffer and mxArray\n+  uint8_t* packed_buffer_ptr = packed_buffer->mutable_data();\n+  const uint8_t* unpacked_buffer_ptr =\n+      reinterpret_cast<const uint8_t*>(mxGetLogicals(logical_array));\n+\n+  // Iterate over the mxLogical array and write bit-packed bools to the arrow::Buffer.\n+  for (int64_t i = 0; i < unpacked_buffer_length; ++i) {\n+    // If the mxLogical value is true, set the corresponding bit in the bit-packed\n+    // buffer. Otherwise, clear that bit.\n+    if (unpacked_buffer_ptr[i]) {\n+      arrow::BitUtil::SetBit(packed_buffer_ptr, i);\n+    } else {\n+      arrow::BitUtil::ClearBit(packed_buffer_ptr, i);\n+    }\n+  }\n+}\n+\n+// Write numeric datatypes to the Feather file.\n+template <typename ArrowDataType>\n+std::unique_ptr<arrow::Array> WriteNumericData(\n+    const mxArray* data, const std::shared_ptr<arrow::Buffer> validity_bitmap) {\n+  // Alias the type name for the underlying MATLAB type.\n+  using MatlabType = typename MatlabTraits<ArrowDataType>::MatlabType;\n+\n+  // Get a pointer to the underlying mxArray data.\n+  // We need to (temporarily) cast away const here since the mxGet* functions do not\n+  // accept a const input parameter for compatibility reasons.\n+  const MatlabType* dt = MatlabTraits<ArrowDataType>::GetData(const_cast<mxArray*>(data));\n+\n+  // Construct an arrow::Buffer that points to the underlying mxArray without copying.\n+  // - The lifetime of the mxArray buffer exceeds that of the arrow::Buffer here since\n+  //   MATLAB should only free this region on garbage-collection after the MEX function\n+  //   is executed. Therefore it is safe for arrow::Buffer to point to this location.\n+  // - However arrow::Buffer must not free this region by itself, since that could cause\n+  //   segfaults if the input array is used later in MATLAB.\n+  //   - The Doxygen doc for arrow::Buffer's constructor implies that it is not an RAII\n+  //     type, so this should be safe from possible double-free here.\n+  std::shared_ptr<arrow::Buffer> buffer(\n+      new arrow::Buffer(reinterpret_cast<const uint8_t*>(dt),\n+                        mxGetElementSize(data) * mxGetNumberOfElements(data)));\n+\n+  // Construct arrow::NumericArray specialization using arrow::Buffer.\n+  // Pass in nulls information...we could compute and provide the number of nulls here too,\n+  // but passing -1 for now so that Arrow recomputes it if necessary.\n+  std::unique_ptr<arrow::Array> array_wrapper(new arrow::NumericArray<ArrowDataType>(\n+      mxGetNumberOfElements(data), buffer, validity_bitmap, -1));\n+\n+  return array_wrapper;\n+}\n+\n+// Dispatch MATLAB column data to the correct arrow::Array converter.\n+std::unique_ptr<arrow::Array> WriteVariableData(\n+    const mxArray* data, const std::string& type,\n+    const std::shared_ptr<arrow::Buffer> validity_bitmap) {\n+  // Get the underlying type of the mxArray data.\n+  const mxClassID mxclass = mxGetClassID(data);\n+\n+  switch (mxclass) {\n+    case mxSINGLE_CLASS:\n+      return WriteNumericData<arrow::FloatType>(data, validity_bitmap);\n+    case mxDOUBLE_CLASS:\n+      return WriteNumericData<arrow::DoubleType>(data, validity_bitmap);\n+    case mxUINT8_CLASS:\n+      return WriteNumericData<arrow::UInt8Type>(data, validity_bitmap);\n+    case mxUINT16_CLASS:\n+      return WriteNumericData<arrow::UInt16Type>(data, validity_bitmap);\n+    case mxUINT32_CLASS:\n+      return WriteNumericData<arrow::UInt32Type>(data, validity_bitmap);\n+    case mxUINT64_CLASS:\n+      return WriteNumericData<arrow::UInt64Type>(data, validity_bitmap);\n+    case mxINT8_CLASS:\n+      return WriteNumericData<arrow::Int8Type>(data, validity_bitmap);\n+    case mxINT16_CLASS:\n+      return WriteNumericData<arrow::Int16Type>(data, validity_bitmap);\n+    case mxINT32_CLASS:\n+      return WriteNumericData<arrow::Int32Type>(data, validity_bitmap);\n+    case mxINT64_CLASS:\n+      return WriteNumericData<arrow::Int64Type>(data, validity_bitmap);\n+\n+    default: {\n+      mexErrMsgIdAndTxt(\"MATLAB:arrow:UnsupportedArrowType\",\n+                        \"Unsupported arrow::Type '%s' for variable '%s'\",\n+                        mxGetClassName(data), type.c_str());\n+    }\n+  }\n+\n+  // We shouldn't ever reach this branch, but if we do, return a null unique_ptr.\n+  return std::unique_ptr<arrow::Array>();\n+}\n+\n+}  // namespace internal\n+\n+arrow::Status FeatherWriter::Open(const std::string& filename,\n+                                  std::shared_ptr<FeatherWriter>* feather_writer) {\n+  // Allocate shared_ptr out parameter.\n+  *feather_writer = std::shared_ptr<FeatherWriter>(new FeatherWriter());\n+\n+  // Open a FileOutputStream corresponding to the provided filename.\n+  std::shared_ptr<arrow::io::OutputStream> writable_file(nullptr);\n+  ARROW_RETURN_NOT_OK(arrow::io::FileOutputStream::Open(filename, &writable_file));\n+\n+  // TableWriter::Open expects a shared_ptr to an OutputStream.\n+  // Open the Feather file for writing with a TableWriter.\n+  ARROW_RETURN_NOT_OK(arrow::ipc::feather::TableWriter::Open(\n+      writable_file, &(*feather_writer)->table_writer_));\n+\n+  return arrow::Status::OK();\n+}\n+\n+// Write table metadata to the Feather file from a mxArray*.\n+arrow::Status FeatherWriter::WriteMetadata(const mxArray* metadata) {\n+  // Verify that all required fieldnames are provided.\n+  internal::ValidateMxStructField(metadata, \"Description\", mxCHAR_CLASS, true);\n+  internal::ValidateMxStructField(metadata, \"Version\", mxDOUBLE_CLASS, false);\n+  internal::ValidateMxStructField(metadata, \"NumRows\", mxDOUBLE_CLASS, false);\n+  internal::ValidateMxStructField(metadata, \"NumVariables\", mxDOUBLE_CLASS, false);\n+\n+  // Convert Description to a std::string and set on FeatherWriter and TableWriter.\n+  std::string description =\n+      internal::MxArrayToString(mxGetField(metadata, 0, \"Description\"));\n+  this->description_ = description;\n+  this->table_writer_->SetDescription(description);\n+\n+  // Get the NumRows field in the struct array and set on TableWriter.\n+  this->num_rows_ = static_cast<int64_t>(mxGetScalar(mxGetField(metadata, 0, \"NumRows\")));\n+  this->table_writer_->SetNumRows(this->num_rows_);\n+\n+  // Get the total number of variables. This is checked later for consistency with\n+  // the provided number of columns before finishing the file write.\n+  this->num_variables_ =\n+      static_cast<int64_t>(mxGetScalar(mxGetField(metadata, 0, \"NumVariables\")));\n+\n+  // Store the version information so we could handle possible future API changes.\n+  this->version_ = static_cast<int32_t>(mxGetScalar(mxGetField(metadata, 0, \"Version\")));\n+\n+  return arrow::Status::OK();\n \n Review comment:\n   Good catch! I'll change this to a `void` return type.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-22T14:57:48.941+0000",
                    "updated": "2019-05-22T14:57:48.941+0000",
                    "started": "2019-05-22T14:57:48.940+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "246793",
                    "issueId": "13201194"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 34800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@3b9a9f65[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4449b5de[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4271b3ab[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@4b1f097e[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@38711a44[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@6ede245c[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@217d2ec7[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@129a876f[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@22890c42[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@3dea308b[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@75293ae7[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@33ce6ad2[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 34800,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Jun 11 17:55:48 UTC 2019",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2019-06-11T17:55:48.000+0000",
        "workratio": 20,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3897/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2018-11-28T21:27:36.000+0000",
        "updated": "2019-06-11T18:42:29.000+0000",
        "timeoriginalestimate": 172800,
        "description": "Currently the MATLAB - Feather interface supports reading numeric datatypes (double, single, uint* and int*) from a Feather file. We should also add support for writing these numeric datatypes to a Feather file.",
        "customfield_10010": null,
        "timetracking": {
            "originalEstimate": "48h",
            "remainingEstimate": "38h 20m",
            "timeSpent": "9h 40m",
            "originalEstimateSeconds": 172800,
            "remainingEstimateSeconds": 138000,
            "timeSpentSeconds": 34800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[MATLAB] Add MATLAB support for writing numeric datatypes to a Feather file",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194/comment/16702399",
                    "id": "16702399",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "To future-proof your code, you should interact as little as possible with the Feather APIs. Instead, focus on converting to and from {{arrow::RecordBatch}} and {{arrow::Table}}. ",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-11-28T21:29:27.926+0000",
                    "updated": "2018-11-28T21:29:27.926+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194/comment/16702427",
                    "id": "16702427",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kgurney",
                        "name": "kgurney",
                        "key": "kgurney",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Kevin Gurney",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Thanks for the\u00a0feedback - this is what we\u00a0are hoping to do with the\u00a0refactoring for\u00a0ARROW-3896. Assigning this task to myself, since I currently have changes in flight for numeric datatype writing.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kgurney",
                        "name": "kgurney",
                        "key": "kgurney",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Kevin Gurney",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-11-28T22:08:53.849+0000",
                    "updated": "2018-11-28T22:08:53.849+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201194/comment/16861270",
                    "id": "16861270",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 4328\n[https://github.com/apache/arrow/pull/4328]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2019-06-11T17:55:48.124+0000",
                    "updated": "2019-06-11T17:55:48.124+0000"
                }
            ],
            "maxResults": 3,
            "total": 3,
            "startAt": 0
        },
        "customfield_12311820": "0|s00ywg:",
        "customfield_12314139": null
    }
}