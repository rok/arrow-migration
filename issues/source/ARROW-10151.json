{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13330418",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418",
    "key": "ARROW-10151",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12345977",
                "id": "12345977",
                "description": "",
                "name": "2.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-10-19"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12599750",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12599750",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "outwardIssue": {
                    "id": "13323760",
                    "key": "ARROW-9812",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13323760",
                    "fields": {
                        "summary": "[Python] Map data types doesn't work from Arrow to Parquet",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
                            "id": "1",
                            "description": "A problem which impairs or prevents the functions of the product.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
                            "name": "Bug",
                            "subtask": false,
                            "avatarId": 21133
                        }
                    }
                }
            },
            {
                "id": "12601065",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12601065",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "outwardIssue": {
                    "id": "13334743",
                    "key": "ARROW-10260",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13334743",
                    "fields": {
                        "summary": "[Python] Missing MapType to Pandas dtype",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12599749",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12599749",
                "type": {
                    "id": "10001",
                    "name": "dependent",
                    "inward": "is depended upon by",
                    "outward": "depends upon",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10001"
                },
                "inwardIssue": {
                    "id": "13165945",
                    "key": "SPARK-24554",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13165945",
                    "fields": {
                        "summary": "Add MapType Support for Arrow in PySpark",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                            "id": "7",
                            "description": "The sub-task of the issue",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                            "name": "Sub-task",
                            "subtask": true,
                            "avatarId": 21146
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
            "name": "bryanc",
            "key": "bryanc",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
            },
            "displayName": "Bryan Cutler",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328936",
                "id": "12328936",
                "name": "Python"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
            "name": "bryanc",
            "key": "bryanc",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
            },
            "displayName": "Bryan Cutler",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
            "name": "bryanc",
            "key": "bryanc",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
            },
            "displayName": "Bryan Cutler",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 14400,
            "total": 14400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 14400,
            "total": 14400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10151/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 24,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/worklog/495185",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "BryanCutler opened a new pull request #8337:\nURL: https://github.com/apache/arrow/pull/8337\n\n\n   This change adds conversion for a `pyarrow.MapArray` to Pandas as a column of lists of tuples, where each tuple is a key/item pair. Unit tests were added for python to verify conversion for Pandas round-trip, chunked arrays and `MapArray` with NULL map and NULL items.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-05T07:08:14.309+0000",
                    "updated": "2020-10-05T07:08:14.309+0000",
                    "started": "2020-10-05T07:08:14.309+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "495185",
                    "issueId": "13330418"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/worklog/495187",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "BryanCutler commented on a change in pull request #8337:\nURL: https://github.com/apache/arrow/pull/8337#discussion_r499383052\n\n\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,114 @@ Status ConvertListsLike(const PandasOptions& options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+inline Status ConvertMap(const PandasOptions& options, const ChunkedArray& data,\n+                         PyObject** out_values) {\n+  // Get columns of underlying key/item arrays\n+  std::vector<std::shared_ptr<Array>> key_arrays;\n+  std::vector<std::shared_ptr<Array>> item_arrays;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& map_arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    key_arrays.emplace_back(map_arr.keys());\n+    item_arrays.emplace_back(map_arr.items());\n+  }\n+\n+  const auto& map_type = checked_cast<const MapType&>(*data.type());\n+  const auto& key_type = map_type.key_type();\n+  const auto& item_type = map_type.item_type();\n+\n+  // TODO: Is this needed for key/item?\n+  /*\n+  if (value_type->id() == Type::DICTIONARY) {\n\nReview comment:\n       This was taken from the ListConversoin, but not totally sure it applies here to the key/item arrays..\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-05T07:09:32.971+0000",
                    "updated": "2020-10-05T07:09:32.971+0000",
                    "started": "2020-10-05T07:09:32.971+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "495187",
                    "issueId": "13330418"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/worklog/495193",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8337:\nURL: https://github.com/apache/arrow/pull/8337#issuecomment-703452358\n\n\n   https://issues.apache.org/jira/browse/ARROW-10151\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-05T07:25:12.709+0000",
                    "updated": "2020-10-05T07:25:12.709+0000",
                    "started": "2020-10-05T07:25:12.709+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "495193",
                    "issueId": "13330418"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/worklog/495474",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "BryanCutler commented on a change in pull request #8337:\nURL: https://github.com/apache/arrow/pull/8337#discussion_r499767269\n\n\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,114 @@ Status ConvertListsLike(const PandasOptions& options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+inline Status ConvertMap(const PandasOptions& options, const ChunkedArray& data,\n+                         PyObject** out_values) {\n+  // Get columns of underlying key/item arrays\n+  std::vector<std::shared_ptr<Array>> key_arrays;\n+  std::vector<std::shared_ptr<Array>> item_arrays;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& map_arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    key_arrays.emplace_back(map_arr.keys());\n+    item_arrays.emplace_back(map_arr.items());\n+  }\n+\n+  const auto& map_type = checked_cast<const MapType&>(*data.type());\n+  const auto& key_type = map_type.key_type();\n+  const auto& item_type = map_type.item_type();\n+\n+  // TODO: Is this needed for key/item?\n+  /*\n+  if (value_type->id() == Type::DICTIONARY) {\n\nReview comment:\n       Yes, same applies. Fixed and added tests.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-05T17:44:56.704+0000",
                    "updated": "2020-10-05T17:44:56.704+0000",
                    "started": "2020-10-05T17:44:56.703+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "495474",
                    "issueId": "13330418"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/worklog/495483",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "BryanCutler commented on pull request #8337:\nURL: https://github.com/apache/arrow/pull/8337#issuecomment-703797500\n\n\n   Ping @pitrou @jorisvandenbossche to please take a look, thanks!\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-05T18:07:48.069+0000",
                    "updated": "2020-10-05T18:07:48.069+0000",
                    "started": "2020-10-05T18:07:48.069+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "495483",
                    "issueId": "13330418"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/worklog/495809",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8337:\nURL: https://github.com/apache/arrow/pull/8337#discussion_r500077813\n\n\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,117 @@ Status ConvertListsLike(const PandasOptions& options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+inline Status ConvertMap(const PandasOptions& options, const ChunkedArray& data,\n+                         PyObject** out_values) {\n+  // Get columns of underlying key/item arrays\n+  std::vector<std::shared_ptr<Array>> key_arrays;\n+  std::vector<std::shared_ptr<Array>> item_arrays;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& map_arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    key_arrays.emplace_back(map_arr.keys());\n+    item_arrays.emplace_back(map_arr.items());\n+  }\n+\n+  const auto& map_type = checked_cast<const MapType&>(*data.type());\n+  auto key_type = map_type.key_type();\n+  auto item_type = map_type.item_type();\n+\n+  // ARROW-6899: Convert dictionary-encoded children to dense instead of\n+  // failing below. A more efficient conversion than this could be done later\n+  if (key_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*key_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &key_arrays));\n+    key_type = dense_type;\n+  }\n+  if (item_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*item_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &item_arrays));\n+    item_type = dense_type;\n+  }\n+\n+  // TODO(ARROW-489): Currently we don't have a Python reference for single columns.\n+  //    Storing a reference to the whole Array would be too expensive.\n+\n+  // ARROW-3789(wesm): During refactoring I found that unit tests assumed that\n+  // timestamp units would be preserved on list<timestamp UNIT> conversions in\n+  // Table.to_pandas. So we set the option here to not coerce things to\n+  // nanoseconds. Bit of a hack but this seemed the simplest thing to satisfy\n+  // the existing unit tests\n+  PandasOptions modified_options = options;\n+  modified_options.coerce_temporal_nanoseconds = false;\n+\n+  auto flat_keys = std::make_shared<ChunkedArray>(key_arrays, key_type);\n+  auto flat_items = std::make_shared<ChunkedArray>(item_arrays, item_type);\n+  OwnedRef list_item;\n+  OwnedRef key_value;\n+  OwnedRef item_value;\n+  OwnedRefNoGIL owned_numpy_keys;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_keys, nullptr,\n+                                            owned_numpy_keys.ref()));\n+  OwnedRefNoGIL owned_numpy_items;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_items, nullptr,\n+                                            owned_numpy_items.ref()));\n+  PyArrayObject* py_keys = reinterpret_cast<PyArrayObject*>(owned_numpy_keys.obj());\n+  PyArrayObject* py_items = reinterpret_cast<PyArrayObject*>(owned_numpy_items.obj());\n+\n+  int64_t chunk_offset = 0;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    auto arr = std::static_pointer_cast<MapArray>(data.chunk(c));\n\nReview comment:\n       Use `checked_cast`\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,117 @@ Status ConvertListsLike(const PandasOptions& options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+inline Status ConvertMap(const PandasOptions& options, const ChunkedArray& data,\n+                         PyObject** out_values) {\n+  // Get columns of underlying key/item arrays\n+  std::vector<std::shared_ptr<Array>> key_arrays;\n+  std::vector<std::shared_ptr<Array>> item_arrays;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& map_arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    key_arrays.emplace_back(map_arr.keys());\n+    item_arrays.emplace_back(map_arr.items());\n+  }\n+\n+  const auto& map_type = checked_cast<const MapType&>(*data.type());\n+  auto key_type = map_type.key_type();\n+  auto item_type = map_type.item_type();\n+\n+  // ARROW-6899: Convert dictionary-encoded children to dense instead of\n+  // failing below. A more efficient conversion than this could be done later\n+  if (key_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*key_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &key_arrays));\n+    key_type = dense_type;\n+  }\n+  if (item_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*item_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &item_arrays));\n+    item_type = dense_type;\n+  }\n+\n+  // TODO(ARROW-489): Currently we don't have a Python reference for single columns.\n+  //    Storing a reference to the whole Array would be too expensive.\n+\n+  // ARROW-3789(wesm): During refactoring I found that unit tests assumed that\n+  // timestamp units would be preserved on list<timestamp UNIT> conversions in\n+  // Table.to_pandas. So we set the option here to not coerce things to\n+  // nanoseconds. Bit of a hack but this seemed the simplest thing to satisfy\n+  // the existing unit tests\n+  PandasOptions modified_options = options;\n+  modified_options.coerce_temporal_nanoseconds = false;\n+\n+  auto flat_keys = std::make_shared<ChunkedArray>(key_arrays, key_type);\n+  auto flat_items = std::make_shared<ChunkedArray>(item_arrays, item_type);\n+  OwnedRef list_item;\n+  OwnedRef key_value;\n+  OwnedRef item_value;\n+  OwnedRefNoGIL owned_numpy_keys;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_keys, nullptr,\n+                                            owned_numpy_keys.ref()));\n+  OwnedRefNoGIL owned_numpy_items;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_items, nullptr,\n+                                            owned_numpy_items.ref()));\n+  PyArrayObject* py_keys = reinterpret_cast<PyArrayObject*>(owned_numpy_keys.obj());\n+  PyArrayObject* py_items = reinterpret_cast<PyArrayObject*>(owned_numpy_items.obj());\n+\n+  int64_t chunk_offset = 0;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    auto arr = std::static_pointer_cast<MapArray>(data.chunk(c));\n+    const bool has_nulls = data.null_count() > 0;\n+\n+    // Make a list of key/item pairs for each row in array\n+    for (int64_t i = 0; i < arr->length(); ++i) {\n+      if (has_nulls && arr->IsNull(i)) {\n+        Py_INCREF(Py_None);\n+        *out_values = Py_None;\n+      } else {\n+        int64_t entry_offset = arr->value_offset(i);\n+        int64_t num_maps = arr->value_offset(i + 1) - entry_offset;\n+\n+        // Build the new list object for the row of maps\n+        list_item.reset(PyList_New(0));\n+        RETURN_IF_PYERROR();\n+\n+        // Add each key/item pair in the row\n+        for (int64_t j = 0; j < num_maps; ++j) {\n+          // Get key value, key is non-nullable for a valid row\n+          auto ptr_key = reinterpret_cast<const char*>(\n+              PyArray_GETPTR1(py_keys, chunk_offset + entry_offset + j));\n+          key_value.reset(PyArray_GETITEM(py_keys, ptr_key));\n+          RETURN_IF_PYERROR();\n+\n+          if (item_arrays[c]->IsNull(entry_offset + j)) {\n+            // Translate the Null to a None\n+            Py_INCREF(Py_None);\n+            item_value.reset(Py_None);\n+          } else {\n+            // Get valid value from item array\n+            auto ptr_item = reinterpret_cast<const char*>(\n+                PyArray_GETPTR1(py_items, chunk_offset + entry_offset + j));\n+            item_value.reset(PyArray_GETITEM(py_items, ptr_item));\n+            RETURN_IF_PYERROR();\n+          }\n+\n+          // Add the key/item pair to the list for the row\n+          PyList_Append(list_item.obj(),\n\nReview comment:\n       With a presized list, use `PyList_SET_ITEM` instead. Be careful with reference counts.\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,117 @@ Status ConvertListsLike(const PandasOptions& options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+inline Status ConvertMap(const PandasOptions& options, const ChunkedArray& data,\n\nReview comment:\n       No need to make this `inline`.\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,117 @@ Status ConvertListsLike(const PandasOptions& options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+inline Status ConvertMap(const PandasOptions& options, const ChunkedArray& data,\n+                         PyObject** out_values) {\n+  // Get columns of underlying key/item arrays\n+  std::vector<std::shared_ptr<Array>> key_arrays;\n+  std::vector<std::shared_ptr<Array>> item_arrays;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& map_arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    key_arrays.emplace_back(map_arr.keys());\n+    item_arrays.emplace_back(map_arr.items());\n+  }\n+\n+  const auto& map_type = checked_cast<const MapType&>(*data.type());\n+  auto key_type = map_type.key_type();\n+  auto item_type = map_type.item_type();\n+\n+  // ARROW-6899: Convert dictionary-encoded children to dense instead of\n+  // failing below. A more efficient conversion than this could be done later\n+  if (key_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*key_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &key_arrays));\n+    key_type = dense_type;\n+  }\n+  if (item_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*item_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &item_arrays));\n+    item_type = dense_type;\n+  }\n+\n+  // TODO(ARROW-489): Currently we don't have a Python reference for single columns.\n+  //    Storing a reference to the whole Array would be too expensive.\n\nReview comment:\n       I don't know what that means. Can you reformulate?\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,117 @@ Status ConvertListsLike(const PandasOptions& options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+inline Status ConvertMap(const PandasOptions& options, const ChunkedArray& data,\n+                         PyObject** out_values) {\n+  // Get columns of underlying key/item arrays\n+  std::vector<std::shared_ptr<Array>> key_arrays;\n+  std::vector<std::shared_ptr<Array>> item_arrays;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& map_arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    key_arrays.emplace_back(map_arr.keys());\n+    item_arrays.emplace_back(map_arr.items());\n+  }\n+\n+  const auto& map_type = checked_cast<const MapType&>(*data.type());\n+  auto key_type = map_type.key_type();\n+  auto item_type = map_type.item_type();\n+\n+  // ARROW-6899: Convert dictionary-encoded children to dense instead of\n+  // failing below. A more efficient conversion than this could be done later\n+  if (key_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*key_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &key_arrays));\n+    key_type = dense_type;\n+  }\n+  if (item_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*item_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &item_arrays));\n+    item_type = dense_type;\n+  }\n+\n+  // TODO(ARROW-489): Currently we don't have a Python reference for single columns.\n+  //    Storing a reference to the whole Array would be too expensive.\n+\n+  // ARROW-3789(wesm): During refactoring I found that unit tests assumed that\n+  // timestamp units would be preserved on list<timestamp UNIT> conversions in\n+  // Table.to_pandas. So we set the option here to not coerce things to\n+  // nanoseconds. Bit of a hack but this seemed the simplest thing to satisfy\n+  // the existing unit tests\n+  PandasOptions modified_options = options;\n+  modified_options.coerce_temporal_nanoseconds = false;\n+\n+  auto flat_keys = std::make_shared<ChunkedArray>(key_arrays, key_type);\n+  auto flat_items = std::make_shared<ChunkedArray>(item_arrays, item_type);\n+  OwnedRef list_item;\n+  OwnedRef key_value;\n+  OwnedRef item_value;\n+  OwnedRefNoGIL owned_numpy_keys;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_keys, nullptr,\n+                                            owned_numpy_keys.ref()));\n+  OwnedRefNoGIL owned_numpy_items;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_items, nullptr,\n+                                            owned_numpy_items.ref()));\n+  PyArrayObject* py_keys = reinterpret_cast<PyArrayObject*>(owned_numpy_keys.obj());\n+  PyArrayObject* py_items = reinterpret_cast<PyArrayObject*>(owned_numpy_items.obj());\n+\n+  int64_t chunk_offset = 0;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    auto arr = std::static_pointer_cast<MapArray>(data.chunk(c));\n+    const bool has_nulls = data.null_count() > 0;\n+\n+    // Make a list of key/item pairs for each row in array\n+    for (int64_t i = 0; i < arr->length(); ++i) {\n+      if (has_nulls && arr->IsNull(i)) {\n+        Py_INCREF(Py_None);\n+        *out_values = Py_None;\n+      } else {\n+        int64_t entry_offset = arr->value_offset(i);\n+        int64_t num_maps = arr->value_offset(i + 1) - entry_offset;\n+\n+        // Build the new list object for the row of maps\n+        list_item.reset(PyList_New(0));\n+        RETURN_IF_PYERROR();\n+\n+        // Add each key/item pair in the row\n+        for (int64_t j = 0; j < num_maps; ++j) {\n+          // Get key value, key is non-nullable for a valid row\n+          auto ptr_key = reinterpret_cast<const char*>(\n+              PyArray_GETPTR1(py_keys, chunk_offset + entry_offset + j));\n+          key_value.reset(PyArray_GETITEM(py_keys, ptr_key));\n+          RETURN_IF_PYERROR();\n+\n+          if (item_arrays[c]->IsNull(entry_offset + j)) {\n+            // Translate the Null to a None\n+            Py_INCREF(Py_None);\n\nReview comment:\n       Why incref here?\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,117 @@ Status ConvertListsLike(const PandasOptions& options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+inline Status ConvertMap(const PandasOptions& options, const ChunkedArray& data,\n+                         PyObject** out_values) {\n+  // Get columns of underlying key/item arrays\n+  std::vector<std::shared_ptr<Array>> key_arrays;\n+  std::vector<std::shared_ptr<Array>> item_arrays;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& map_arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    key_arrays.emplace_back(map_arr.keys());\n+    item_arrays.emplace_back(map_arr.items());\n+  }\n+\n+  const auto& map_type = checked_cast<const MapType&>(*data.type());\n+  auto key_type = map_type.key_type();\n+  auto item_type = map_type.item_type();\n+\n+  // ARROW-6899: Convert dictionary-encoded children to dense instead of\n+  // failing below. A more efficient conversion than this could be done later\n+  if (key_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*key_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &key_arrays));\n+    key_type = dense_type;\n+  }\n+  if (item_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*item_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &item_arrays));\n+    item_type = dense_type;\n+  }\n+\n+  // TODO(ARROW-489): Currently we don't have a Python reference for single columns.\n+  //    Storing a reference to the whole Array would be too expensive.\n+\n+  // ARROW-3789(wesm): During refactoring I found that unit tests assumed that\n\nReview comment:\n       Is this still relevant? Blindly copying old comments like this doesn't give me good feelings.\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,117 @@ Status ConvertListsLike(const PandasOptions& options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+inline Status ConvertMap(const PandasOptions& options, const ChunkedArray& data,\n+                         PyObject** out_values) {\n+  // Get columns of underlying key/item arrays\n+  std::vector<std::shared_ptr<Array>> key_arrays;\n+  std::vector<std::shared_ptr<Array>> item_arrays;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& map_arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    key_arrays.emplace_back(map_arr.keys());\n+    item_arrays.emplace_back(map_arr.items());\n+  }\n+\n+  const auto& map_type = checked_cast<const MapType&>(*data.type());\n+  auto key_type = map_type.key_type();\n+  auto item_type = map_type.item_type();\n+\n+  // ARROW-6899: Convert dictionary-encoded children to dense instead of\n+  // failing below. A more efficient conversion than this could be done later\n+  if (key_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*key_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &key_arrays));\n+    key_type = dense_type;\n+  }\n+  if (item_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*item_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &item_arrays));\n+    item_type = dense_type;\n+  }\n+\n+  // TODO(ARROW-489): Currently we don't have a Python reference for single columns.\n+  //    Storing a reference to the whole Array would be too expensive.\n+\n+  // ARROW-3789(wesm): During refactoring I found that unit tests assumed that\n+  // timestamp units would be preserved on list<timestamp UNIT> conversions in\n+  // Table.to_pandas. So we set the option here to not coerce things to\n+  // nanoseconds. Bit of a hack but this seemed the simplest thing to satisfy\n+  // the existing unit tests\n+  PandasOptions modified_options = options;\n+  modified_options.coerce_temporal_nanoseconds = false;\n+\n+  auto flat_keys = std::make_shared<ChunkedArray>(key_arrays, key_type);\n+  auto flat_items = std::make_shared<ChunkedArray>(item_arrays, item_type);\n+  OwnedRef list_item;\n+  OwnedRef key_value;\n+  OwnedRef item_value;\n+  OwnedRefNoGIL owned_numpy_keys;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_keys, nullptr,\n+                                            owned_numpy_keys.ref()));\n+  OwnedRefNoGIL owned_numpy_items;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_items, nullptr,\n+                                            owned_numpy_items.ref()));\n+  PyArrayObject* py_keys = reinterpret_cast<PyArrayObject*>(owned_numpy_keys.obj());\n+  PyArrayObject* py_items = reinterpret_cast<PyArrayObject*>(owned_numpy_items.obj());\n+\n+  int64_t chunk_offset = 0;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    auto arr = std::static_pointer_cast<MapArray>(data.chunk(c));\n+    const bool has_nulls = data.null_count() > 0;\n+\n+    // Make a list of key/item pairs for each row in array\n+    for (int64_t i = 0; i < arr->length(); ++i) {\n+      if (has_nulls && arr->IsNull(i)) {\n+        Py_INCREF(Py_None);\n+        *out_values = Py_None;\n+      } else {\n+        int64_t entry_offset = arr->value_offset(i);\n+        int64_t num_maps = arr->value_offset(i + 1) - entry_offset;\n+\n+        // Build the new list object for the row of maps\n+        list_item.reset(PyList_New(0));\n+        RETURN_IF_PYERROR();\n+\n+        // Add each key/item pair in the row\n+        for (int64_t j = 0; j < num_maps; ++j) {\n+          // Get key value, key is non-nullable for a valid row\n+          auto ptr_key = reinterpret_cast<const char*>(\n+              PyArray_GETPTR1(py_keys, chunk_offset + entry_offset + j));\n+          key_value.reset(PyArray_GETITEM(py_keys, ptr_key));\n+          RETURN_IF_PYERROR();\n+\n+          if (item_arrays[c]->IsNull(entry_offset + j)) {\n+            // Translate the Null to a None\n+            Py_INCREF(Py_None);\n+            item_value.reset(Py_None);\n+          } else {\n+            // Get valid value from item array\n+            auto ptr_item = reinterpret_cast<const char*>(\n+                PyArray_GETPTR1(py_items, chunk_offset + entry_offset + j));\n+            item_value.reset(PyArray_GETITEM(py_items, ptr_item));\n+            RETURN_IF_PYERROR();\n\nReview comment:\n       Is this required? I would expect the above to be always successful?\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,117 @@ Status ConvertListsLike(const PandasOptions& options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+inline Status ConvertMap(const PandasOptions& options, const ChunkedArray& data,\n+                         PyObject** out_values) {\n+  // Get columns of underlying key/item arrays\n+  std::vector<std::shared_ptr<Array>> key_arrays;\n+  std::vector<std::shared_ptr<Array>> item_arrays;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& map_arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    key_arrays.emplace_back(map_arr.keys());\n+    item_arrays.emplace_back(map_arr.items());\n+  }\n+\n+  const auto& map_type = checked_cast<const MapType&>(*data.type());\n+  auto key_type = map_type.key_type();\n+  auto item_type = map_type.item_type();\n+\n+  // ARROW-6899: Convert dictionary-encoded children to dense instead of\n+  // failing below. A more efficient conversion than this could be done later\n+  if (key_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*key_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &key_arrays));\n+    key_type = dense_type;\n+  }\n+  if (item_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*item_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &item_arrays));\n+    item_type = dense_type;\n+  }\n+\n+  // TODO(ARROW-489): Currently we don't have a Python reference for single columns.\n+  //    Storing a reference to the whole Array would be too expensive.\n+\n+  // ARROW-3789(wesm): During refactoring I found that unit tests assumed that\n+  // timestamp units would be preserved on list<timestamp UNIT> conversions in\n+  // Table.to_pandas. So we set the option here to not coerce things to\n+  // nanoseconds. Bit of a hack but this seemed the simplest thing to satisfy\n+  // the existing unit tests\n+  PandasOptions modified_options = options;\n+  modified_options.coerce_temporal_nanoseconds = false;\n+\n+  auto flat_keys = std::make_shared<ChunkedArray>(key_arrays, key_type);\n+  auto flat_items = std::make_shared<ChunkedArray>(item_arrays, item_type);\n+  OwnedRef list_item;\n+  OwnedRef key_value;\n+  OwnedRef item_value;\n+  OwnedRefNoGIL owned_numpy_keys;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_keys, nullptr,\n+                                            owned_numpy_keys.ref()));\n+  OwnedRefNoGIL owned_numpy_items;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_items, nullptr,\n+                                            owned_numpy_items.ref()));\n+  PyArrayObject* py_keys = reinterpret_cast<PyArrayObject*>(owned_numpy_keys.obj());\n+  PyArrayObject* py_items = reinterpret_cast<PyArrayObject*>(owned_numpy_items.obj());\n+\n+  int64_t chunk_offset = 0;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    auto arr = std::static_pointer_cast<MapArray>(data.chunk(c));\n+    const bool has_nulls = data.null_count() > 0;\n+\n+    // Make a list of key/item pairs for each row in array\n+    for (int64_t i = 0; i < arr->length(); ++i) {\n+      if (has_nulls && arr->IsNull(i)) {\n+        Py_INCREF(Py_None);\n+        *out_values = Py_None;\n+      } else {\n+        int64_t entry_offset = arr->value_offset(i);\n+        int64_t num_maps = arr->value_offset(i + 1) - entry_offset;\n+\n+        // Build the new list object for the row of maps\n+        list_item.reset(PyList_New(0));\n+        RETURN_IF_PYERROR();\n+\n+        // Add each key/item pair in the row\n+        for (int64_t j = 0; j < num_maps; ++j) {\n+          // Get key value, key is non-nullable for a valid row\n+          auto ptr_key = reinterpret_cast<const char*>(\n+              PyArray_GETPTR1(py_keys, chunk_offset + entry_offset + j));\n+          key_value.reset(PyArray_GETITEM(py_keys, ptr_key));\n+          RETURN_IF_PYERROR();\n+\n+          if (item_arrays[c]->IsNull(entry_offset + j)) {\n+            // Translate the Null to a None\n+            Py_INCREF(Py_None);\n+            item_value.reset(Py_None);\n+          } else {\n+            // Get valid value from item array\n+            auto ptr_item = reinterpret_cast<const char*>(\n+                PyArray_GETPTR1(py_items, chunk_offset + entry_offset + j));\n+            item_value.reset(PyArray_GETITEM(py_items, ptr_item));\n+            RETURN_IF_PYERROR();\n+          }\n+\n+          // Add the key/item pair to the list for the row\n+          PyList_Append(list_item.obj(),\n+                        PyTuple_Pack(2, key_value.obj(), item_value.obj()));\n+          RETURN_IF_PYERROR();\n+        }\n+\n+        *out_values = list_item.obj();\n+        // Grant ownership to the resulting array\n+        Py_INCREF(*out_values);\n\nReview comment:\n       Use `OwnedRef.detach` instead of issueing duplicate incref/decrefs.\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,117 @@ Status ConvertListsLike(const PandasOptions& options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+inline Status ConvertMap(const PandasOptions& options, const ChunkedArray& data,\n+                         PyObject** out_values) {\n+  // Get columns of underlying key/item arrays\n+  std::vector<std::shared_ptr<Array>> key_arrays;\n+  std::vector<std::shared_ptr<Array>> item_arrays;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& map_arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    key_arrays.emplace_back(map_arr.keys());\n+    item_arrays.emplace_back(map_arr.items());\n+  }\n+\n+  const auto& map_type = checked_cast<const MapType&>(*data.type());\n+  auto key_type = map_type.key_type();\n+  auto item_type = map_type.item_type();\n+\n+  // ARROW-6899: Convert dictionary-encoded children to dense instead of\n+  // failing below. A more efficient conversion than this could be done later\n+  if (key_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*key_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &key_arrays));\n+    key_type = dense_type;\n+  }\n+  if (item_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*item_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &item_arrays));\n+    item_type = dense_type;\n+  }\n+\n+  // TODO(ARROW-489): Currently we don't have a Python reference for single columns.\n+  //    Storing a reference to the whole Array would be too expensive.\n+\n+  // ARROW-3789(wesm): During refactoring I found that unit tests assumed that\n+  // timestamp units would be preserved on list<timestamp UNIT> conversions in\n+  // Table.to_pandas. So we set the option here to not coerce things to\n+  // nanoseconds. Bit of a hack but this seemed the simplest thing to satisfy\n+  // the existing unit tests\n+  PandasOptions modified_options = options;\n+  modified_options.coerce_temporal_nanoseconds = false;\n+\n+  auto flat_keys = std::make_shared<ChunkedArray>(key_arrays, key_type);\n+  auto flat_items = std::make_shared<ChunkedArray>(item_arrays, item_type);\n+  OwnedRef list_item;\n+  OwnedRef key_value;\n+  OwnedRef item_value;\n+  OwnedRefNoGIL owned_numpy_keys;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_keys, nullptr,\n+                                            owned_numpy_keys.ref()));\n+  OwnedRefNoGIL owned_numpy_items;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_items, nullptr,\n+                                            owned_numpy_items.ref()));\n+  PyArrayObject* py_keys = reinterpret_cast<PyArrayObject*>(owned_numpy_keys.obj());\n+  PyArrayObject* py_items = reinterpret_cast<PyArrayObject*>(owned_numpy_items.obj());\n+\n+  int64_t chunk_offset = 0;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    auto arr = std::static_pointer_cast<MapArray>(data.chunk(c));\n+    const bool has_nulls = data.null_count() > 0;\n+\n+    // Make a list of key/item pairs for each row in array\n+    for (int64_t i = 0; i < arr->length(); ++i) {\n+      if (has_nulls && arr->IsNull(i)) {\n+        Py_INCREF(Py_None);\n+        *out_values = Py_None;\n+      } else {\n+        int64_t entry_offset = arr->value_offset(i);\n+        int64_t num_maps = arr->value_offset(i + 1) - entry_offset;\n+\n+        // Build the new list object for the row of maps\n+        list_item.reset(PyList_New(0));\n\nReview comment:\n       You should presize to `num_maps`.\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,117 @@ Status ConvertListsLike(const PandasOptions& options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+inline Status ConvertMap(const PandasOptions& options, const ChunkedArray& data,\n+                         PyObject** out_values) {\n+  // Get columns of underlying key/item arrays\n+  std::vector<std::shared_ptr<Array>> key_arrays;\n+  std::vector<std::shared_ptr<Array>> item_arrays;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& map_arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    key_arrays.emplace_back(map_arr.keys());\n+    item_arrays.emplace_back(map_arr.items());\n+  }\n+\n+  const auto& map_type = checked_cast<const MapType&>(*data.type());\n+  auto key_type = map_type.key_type();\n+  auto item_type = map_type.item_type();\n+\n+  // ARROW-6899: Convert dictionary-encoded children to dense instead of\n+  // failing below. A more efficient conversion than this could be done later\n+  if (key_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*key_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &key_arrays));\n+    key_type = dense_type;\n+  }\n+  if (item_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*item_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &item_arrays));\n+    item_type = dense_type;\n+  }\n+\n+  // TODO(ARROW-489): Currently we don't have a Python reference for single columns.\n+  //    Storing a reference to the whole Array would be too expensive.\n+\n+  // ARROW-3789(wesm): During refactoring I found that unit tests assumed that\n+  // timestamp units would be preserved on list<timestamp UNIT> conversions in\n+  // Table.to_pandas. So we set the option here to not coerce things to\n+  // nanoseconds. Bit of a hack but this seemed the simplest thing to satisfy\n+  // the existing unit tests\n+  PandasOptions modified_options = options;\n+  modified_options.coerce_temporal_nanoseconds = false;\n+\n+  auto flat_keys = std::make_shared<ChunkedArray>(key_arrays, key_type);\n+  auto flat_items = std::make_shared<ChunkedArray>(item_arrays, item_type);\n+  OwnedRef list_item;\n+  OwnedRef key_value;\n+  OwnedRef item_value;\n+  OwnedRefNoGIL owned_numpy_keys;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_keys, nullptr,\n+                                            owned_numpy_keys.ref()));\n+  OwnedRefNoGIL owned_numpy_items;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_items, nullptr,\n+                                            owned_numpy_items.ref()));\n+  PyArrayObject* py_keys = reinterpret_cast<PyArrayObject*>(owned_numpy_keys.obj());\n+  PyArrayObject* py_items = reinterpret_cast<PyArrayObject*>(owned_numpy_items.obj());\n+\n+  int64_t chunk_offset = 0;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    auto arr = std::static_pointer_cast<MapArray>(data.chunk(c));\n+    const bool has_nulls = data.null_count() > 0;\n+\n+    // Make a list of key/item pairs for each row in array\n+    for (int64_t i = 0; i < arr->length(); ++i) {\n+      if (has_nulls && arr->IsNull(i)) {\n+        Py_INCREF(Py_None);\n+        *out_values = Py_None;\n+      } else {\n+        int64_t entry_offset = arr->value_offset(i);\n+        int64_t num_maps = arr->value_offset(i + 1) - entry_offset;\n+\n+        // Build the new list object for the row of maps\n+        list_item.reset(PyList_New(0));\n+        RETURN_IF_PYERROR();\n+\n+        // Add each key/item pair in the row\n+        for (int64_t j = 0; j < num_maps; ++j) {\n+          // Get key value, key is non-nullable for a valid row\n+          auto ptr_key = reinterpret_cast<const char*>(\n+              PyArray_GETPTR1(py_keys, chunk_offset + entry_offset + j));\n+          key_value.reset(PyArray_GETITEM(py_keys, ptr_key));\n+          RETURN_IF_PYERROR();\n+\n+          if (item_arrays[c]->IsNull(entry_offset + j)) {\n\nReview comment:\n       Why do you need this? I would expect `py_items` to contain a `None` entry already...?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-06T09:33:06.718+0000",
                    "updated": "2020-10-06T09:33:06.718+0000",
                    "started": "2020-10-06T09:33:06.718+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "495809",
                    "issueId": "13330418"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/worklog/496163",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #8337:\nURL: https://github.com/apache/arrow/pull/8337#issuecomment-704537948\n\n\n   Also, you'll want to rebase.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-06T20:35:55.814+0000",
                    "updated": "2020-10-06T20:35:55.814+0000",
                    "started": "2020-10-06T20:35:55.814+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "496163",
                    "issueId": "13330418"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/worklog/496229",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "BryanCutler commented on a change in pull request #8337:\nURL: https://github.com/apache/arrow/pull/8337#discussion_r500646932\n\n\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,117 @@ Status ConvertListsLike(const PandasOptions& options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+inline Status ConvertMap(const PandasOptions& options, const ChunkedArray& data,\n+                         PyObject** out_values) {\n+  // Get columns of underlying key/item arrays\n+  std::vector<std::shared_ptr<Array>> key_arrays;\n+  std::vector<std::shared_ptr<Array>> item_arrays;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& map_arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    key_arrays.emplace_back(map_arr.keys());\n+    item_arrays.emplace_back(map_arr.items());\n+  }\n+\n+  const auto& map_type = checked_cast<const MapType&>(*data.type());\n+  auto key_type = map_type.key_type();\n+  auto item_type = map_type.item_type();\n+\n+  // ARROW-6899: Convert dictionary-encoded children to dense instead of\n+  // failing below. A more efficient conversion than this could be done later\n+  if (key_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*key_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &key_arrays));\n+    key_type = dense_type;\n+  }\n+  if (item_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*item_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &item_arrays));\n+    item_type = dense_type;\n+  }\n+\n+  // TODO(ARROW-489): Currently we don't have a Python reference for single columns.\n+  //    Storing a reference to the whole Array would be too expensive.\n\nReview comment:\n       JIRA is closed now as Not a Problem, will remove here also\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-06T23:12:56.374+0000",
                    "updated": "2020-10-06T23:12:56.374+0000",
                    "started": "2020-10-06T23:12:56.374+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "496229",
                    "issueId": "13330418"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/worklog/496230",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "BryanCutler commented on a change in pull request #8337:\nURL: https://github.com/apache/arrow/pull/8337#discussion_r500647083\n\n\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,117 @@ Status ConvertListsLike(const PandasOptions& options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+inline Status ConvertMap(const PandasOptions& options, const ChunkedArray& data,\n+                         PyObject** out_values) {\n+  // Get columns of underlying key/item arrays\n+  std::vector<std::shared_ptr<Array>> key_arrays;\n+  std::vector<std::shared_ptr<Array>> item_arrays;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& map_arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    key_arrays.emplace_back(map_arr.keys());\n+    item_arrays.emplace_back(map_arr.items());\n+  }\n+\n+  const auto& map_type = checked_cast<const MapType&>(*data.type());\n+  auto key_type = map_type.key_type();\n+  auto item_type = map_type.item_type();\n+\n+  // ARROW-6899: Convert dictionary-encoded children to dense instead of\n+  // failing below. A more efficient conversion than this could be done later\n+  if (key_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*key_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &key_arrays));\n+    key_type = dense_type;\n+  }\n+  if (item_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*item_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &item_arrays));\n+    item_type = dense_type;\n+  }\n+\n+  // TODO(ARROW-489): Currently we don't have a Python reference for single columns.\n+  //    Storing a reference to the whole Array would be too expensive.\n+\n+  // ARROW-3789(wesm): During refactoring I found that unit tests assumed that\n\nReview comment:\n       I saw you updated the related code, will do the same here\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-06T23:13:19.549+0000",
                    "updated": "2020-10-06T23:13:19.549+0000",
                    "started": "2020-10-06T23:13:19.549+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "496230",
                    "issueId": "13330418"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/worklog/496325",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "BryanCutler commented on a change in pull request #8337:\nURL: https://github.com/apache/arrow/pull/8337#discussion_r500762391\n\n\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,117 @@ Status ConvertListsLike(const PandasOptions& options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+inline Status ConvertMap(const PandasOptions& options, const ChunkedArray& data,\n+                         PyObject** out_values) {\n+  // Get columns of underlying key/item arrays\n+  std::vector<std::shared_ptr<Array>> key_arrays;\n+  std::vector<std::shared_ptr<Array>> item_arrays;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& map_arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    key_arrays.emplace_back(map_arr.keys());\n+    item_arrays.emplace_back(map_arr.items());\n+  }\n+\n+  const auto& map_type = checked_cast<const MapType&>(*data.type());\n+  auto key_type = map_type.key_type();\n+  auto item_type = map_type.item_type();\n+\n+  // ARROW-6899: Convert dictionary-encoded children to dense instead of\n+  // failing below. A more efficient conversion than this could be done later\n+  if (key_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*key_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &key_arrays));\n+    key_type = dense_type;\n+  }\n+  if (item_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*item_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &item_arrays));\n+    item_type = dense_type;\n+  }\n+\n+  // TODO(ARROW-489): Currently we don't have a Python reference for single columns.\n+  //    Storing a reference to the whole Array would be too expensive.\n+\n+  // ARROW-3789(wesm): During refactoring I found that unit tests assumed that\n+  // timestamp units would be preserved on list<timestamp UNIT> conversions in\n+  // Table.to_pandas. So we set the option here to not coerce things to\n+  // nanoseconds. Bit of a hack but this seemed the simplest thing to satisfy\n+  // the existing unit tests\n+  PandasOptions modified_options = options;\n+  modified_options.coerce_temporal_nanoseconds = false;\n+\n+  auto flat_keys = std::make_shared<ChunkedArray>(key_arrays, key_type);\n+  auto flat_items = std::make_shared<ChunkedArray>(item_arrays, item_type);\n+  OwnedRef list_item;\n+  OwnedRef key_value;\n+  OwnedRef item_value;\n+  OwnedRefNoGIL owned_numpy_keys;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_keys, nullptr,\n+                                            owned_numpy_keys.ref()));\n+  OwnedRefNoGIL owned_numpy_items;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_items, nullptr,\n+                                            owned_numpy_items.ref()));\n+  PyArrayObject* py_keys = reinterpret_cast<PyArrayObject*>(owned_numpy_keys.obj());\n+  PyArrayObject* py_items = reinterpret_cast<PyArrayObject*>(owned_numpy_items.obj());\n+\n+  int64_t chunk_offset = 0;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    auto arr = std::static_pointer_cast<MapArray>(data.chunk(c));\n+    const bool has_nulls = data.null_count() > 0;\n+\n+    // Make a list of key/item pairs for each row in array\n+    for (int64_t i = 0; i < arr->length(); ++i) {\n+      if (has_nulls && arr->IsNull(i)) {\n+        Py_INCREF(Py_None);\n+        *out_values = Py_None;\n+      } else {\n+        int64_t entry_offset = arr->value_offset(i);\n+        int64_t num_maps = arr->value_offset(i + 1) - entry_offset;\n+\n+        // Build the new list object for the row of maps\n+        list_item.reset(PyList_New(0));\n\nReview comment:\n       I tried that at first but had trouble with the ref counts. I didn't use the `PyList_SET_ITEM` macro though, so I'll try again\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-07T06:20:10.283+0000",
                    "updated": "2020-10-07T06:20:10.283+0000",
                    "started": "2020-10-07T06:20:10.283+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "496325",
                    "issueId": "13330418"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/worklog/496326",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "BryanCutler commented on a change in pull request #8337:\nURL: https://github.com/apache/arrow/pull/8337#discussion_r500762610\n\n\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,117 @@ Status ConvertListsLike(const PandasOptions& options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+inline Status ConvertMap(const PandasOptions& options, const ChunkedArray& data,\n+                         PyObject** out_values) {\n+  // Get columns of underlying key/item arrays\n+  std::vector<std::shared_ptr<Array>> key_arrays;\n+  std::vector<std::shared_ptr<Array>> item_arrays;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& map_arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    key_arrays.emplace_back(map_arr.keys());\n+    item_arrays.emplace_back(map_arr.items());\n+  }\n+\n+  const auto& map_type = checked_cast<const MapType&>(*data.type());\n+  auto key_type = map_type.key_type();\n+  auto item_type = map_type.item_type();\n+\n+  // ARROW-6899: Convert dictionary-encoded children to dense instead of\n+  // failing below. A more efficient conversion than this could be done later\n+  if (key_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*key_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &key_arrays));\n+    key_type = dense_type;\n+  }\n+  if (item_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*item_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &item_arrays));\n+    item_type = dense_type;\n+  }\n+\n+  // TODO(ARROW-489): Currently we don't have a Python reference for single columns.\n+  //    Storing a reference to the whole Array would be too expensive.\n+\n+  // ARROW-3789(wesm): During refactoring I found that unit tests assumed that\n+  // timestamp units would be preserved on list<timestamp UNIT> conversions in\n+  // Table.to_pandas. So we set the option here to not coerce things to\n+  // nanoseconds. Bit of a hack but this seemed the simplest thing to satisfy\n+  // the existing unit tests\n+  PandasOptions modified_options = options;\n+  modified_options.coerce_temporal_nanoseconds = false;\n+\n+  auto flat_keys = std::make_shared<ChunkedArray>(key_arrays, key_type);\n+  auto flat_items = std::make_shared<ChunkedArray>(item_arrays, item_type);\n+  OwnedRef list_item;\n+  OwnedRef key_value;\n+  OwnedRef item_value;\n+  OwnedRefNoGIL owned_numpy_keys;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_keys, nullptr,\n+                                            owned_numpy_keys.ref()));\n+  OwnedRefNoGIL owned_numpy_items;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_items, nullptr,\n+                                            owned_numpy_items.ref()));\n+  PyArrayObject* py_keys = reinterpret_cast<PyArrayObject*>(owned_numpy_keys.obj());\n+  PyArrayObject* py_items = reinterpret_cast<PyArrayObject*>(owned_numpy_items.obj());\n+\n+  int64_t chunk_offset = 0;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    auto arr = std::static_pointer_cast<MapArray>(data.chunk(c));\n+    const bool has_nulls = data.null_count() > 0;\n+\n+    // Make a list of key/item pairs for each row in array\n+    for (int64_t i = 0; i < arr->length(); ++i) {\n+      if (has_nulls && arr->IsNull(i)) {\n+        Py_INCREF(Py_None);\n+        *out_values = Py_None;\n+      } else {\n+        int64_t entry_offset = arr->value_offset(i);\n+        int64_t num_maps = arr->value_offset(i + 1) - entry_offset;\n+\n+        // Build the new list object for the row of maps\n+        list_item.reset(PyList_New(0));\n+        RETURN_IF_PYERROR();\n+\n+        // Add each key/item pair in the row\n+        for (int64_t j = 0; j < num_maps; ++j) {\n+          // Get key value, key is non-nullable for a valid row\n+          auto ptr_key = reinterpret_cast<const char*>(\n+              PyArray_GETPTR1(py_keys, chunk_offset + entry_offset + j));\n+          key_value.reset(PyArray_GETITEM(py_keys, ptr_key));\n+          RETURN_IF_PYERROR();\n+\n+          if (item_arrays[c]->IsNull(entry_offset + j)) {\n\nReview comment:\n       Good point, let me try that\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-07T06:20:33.330+0000",
                    "updated": "2020-10-07T06:20:33.330+0000",
                    "started": "2020-10-07T06:20:33.330+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "496326",
                    "issueId": "13330418"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/worklog/496336",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "BryanCutler commented on a change in pull request #8337:\nURL: https://github.com/apache/arrow/pull/8337#discussion_r500770931\n\n\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,117 @@ Status ConvertListsLike(const PandasOptions& options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+inline Status ConvertMap(const PandasOptions& options, const ChunkedArray& data,\n+                         PyObject** out_values) {\n+  // Get columns of underlying key/item arrays\n+  std::vector<std::shared_ptr<Array>> key_arrays;\n+  std::vector<std::shared_ptr<Array>> item_arrays;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& map_arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    key_arrays.emplace_back(map_arr.keys());\n+    item_arrays.emplace_back(map_arr.items());\n+  }\n+\n+  const auto& map_type = checked_cast<const MapType&>(*data.type());\n+  auto key_type = map_type.key_type();\n+  auto item_type = map_type.item_type();\n+\n+  // ARROW-6899: Convert dictionary-encoded children to dense instead of\n+  // failing below. A more efficient conversion than this could be done later\n+  if (key_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*key_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &key_arrays));\n+    key_type = dense_type;\n+  }\n+  if (item_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*item_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &item_arrays));\n+    item_type = dense_type;\n+  }\n+\n+  // TODO(ARROW-489): Currently we don't have a Python reference for single columns.\n+  //    Storing a reference to the whole Array would be too expensive.\n+\n+  // ARROW-3789(wesm): During refactoring I found that unit tests assumed that\n+  // timestamp units would be preserved on list<timestamp UNIT> conversions in\n+  // Table.to_pandas. So we set the option here to not coerce things to\n+  // nanoseconds. Bit of a hack but this seemed the simplest thing to satisfy\n+  // the existing unit tests\n+  PandasOptions modified_options = options;\n+  modified_options.coerce_temporal_nanoseconds = false;\n+\n+  auto flat_keys = std::make_shared<ChunkedArray>(key_arrays, key_type);\n+  auto flat_items = std::make_shared<ChunkedArray>(item_arrays, item_type);\n+  OwnedRef list_item;\n+  OwnedRef key_value;\n+  OwnedRef item_value;\n+  OwnedRefNoGIL owned_numpy_keys;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_keys, nullptr,\n+                                            owned_numpy_keys.ref()));\n+  OwnedRefNoGIL owned_numpy_items;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_items, nullptr,\n+                                            owned_numpy_items.ref()));\n+  PyArrayObject* py_keys = reinterpret_cast<PyArrayObject*>(owned_numpy_keys.obj());\n+  PyArrayObject* py_items = reinterpret_cast<PyArrayObject*>(owned_numpy_items.obj());\n+\n+  int64_t chunk_offset = 0;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    auto arr = std::static_pointer_cast<MapArray>(data.chunk(c));\n+    const bool has_nulls = data.null_count() > 0;\n+\n+    // Make a list of key/item pairs for each row in array\n+    for (int64_t i = 0; i < arr->length(); ++i) {\n+      if (has_nulls && arr->IsNull(i)) {\n+        Py_INCREF(Py_None);\n+        *out_values = Py_None;\n+      } else {\n+        int64_t entry_offset = arr->value_offset(i);\n+        int64_t num_maps = arr->value_offset(i + 1) - entry_offset;\n+\n+        // Build the new list object for the row of maps\n+        list_item.reset(PyList_New(0));\n+        RETURN_IF_PYERROR();\n+\n+        // Add each key/item pair in the row\n+        for (int64_t j = 0; j < num_maps; ++j) {\n+          // Get key value, key is non-nullable for a valid row\n+          auto ptr_key = reinterpret_cast<const char*>(\n+              PyArray_GETPTR1(py_keys, chunk_offset + entry_offset + j));\n+          key_value.reset(PyArray_GETITEM(py_keys, ptr_key));\n+          RETURN_IF_PYERROR();\n+\n+          if (item_arrays[c]->IsNull(entry_offset + j)) {\n+            // Translate the Null to a None\n+            Py_INCREF(Py_None);\n+            item_value.reset(Py_None);\n+          } else {\n+            // Get valid value from item array\n+            auto ptr_item = reinterpret_cast<const char*>(\n+                PyArray_GETPTR1(py_items, chunk_offset + entry_offset + j));\n+            item_value.reset(PyArray_GETITEM(py_items, ptr_item));\n+            RETURN_IF_PYERROR();\n\nReview comment:\n       Hmm, I'm not an expert on the python/numpy c-apis, so I was following `ConvertStruct` here. I thought that `PyArray_GETITEM` might set an error, but looks like it would return null on failure. Is it possible the reset of the `item_value` PyObject could cause an error?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-07T06:41:16.297+0000",
                    "updated": "2020-10-07T06:41:16.297+0000",
                    "started": "2020-10-07T06:41:16.297+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "496336",
                    "issueId": "13330418"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/worklog/496340",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "BryanCutler commented on a change in pull request #8337:\nURL: https://github.com/apache/arrow/pull/8337#discussion_r500778364\n\n\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,117 @@ Status ConvertListsLike(const PandasOptions& options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+inline Status ConvertMap(const PandasOptions& options, const ChunkedArray& data,\n+                         PyObject** out_values) {\n+  // Get columns of underlying key/item arrays\n+  std::vector<std::shared_ptr<Array>> key_arrays;\n+  std::vector<std::shared_ptr<Array>> item_arrays;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& map_arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    key_arrays.emplace_back(map_arr.keys());\n+    item_arrays.emplace_back(map_arr.items());\n+  }\n+\n+  const auto& map_type = checked_cast<const MapType&>(*data.type());\n+  auto key_type = map_type.key_type();\n+  auto item_type = map_type.item_type();\n+\n+  // ARROW-6899: Convert dictionary-encoded children to dense instead of\n+  // failing below. A more efficient conversion than this could be done later\n+  if (key_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*key_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &key_arrays));\n+    key_type = dense_type;\n+  }\n+  if (item_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*item_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &item_arrays));\n+    item_type = dense_type;\n+  }\n+\n+  // TODO(ARROW-489): Currently we don't have a Python reference for single columns.\n+  //    Storing a reference to the whole Array would be too expensive.\n+\n+  // ARROW-3789(wesm): During refactoring I found that unit tests assumed that\n+  // timestamp units would be preserved on list<timestamp UNIT> conversions in\n+  // Table.to_pandas. So we set the option here to not coerce things to\n+  // nanoseconds. Bit of a hack but this seemed the simplest thing to satisfy\n+  // the existing unit tests\n+  PandasOptions modified_options = options;\n+  modified_options.coerce_temporal_nanoseconds = false;\n+\n+  auto flat_keys = std::make_shared<ChunkedArray>(key_arrays, key_type);\n+  auto flat_items = std::make_shared<ChunkedArray>(item_arrays, item_type);\n+  OwnedRef list_item;\n+  OwnedRef key_value;\n+  OwnedRef item_value;\n+  OwnedRefNoGIL owned_numpy_keys;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_keys, nullptr,\n+                                            owned_numpy_keys.ref()));\n+  OwnedRefNoGIL owned_numpy_items;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_items, nullptr,\n+                                            owned_numpy_items.ref()));\n+  PyArrayObject* py_keys = reinterpret_cast<PyArrayObject*>(owned_numpy_keys.obj());\n+  PyArrayObject* py_items = reinterpret_cast<PyArrayObject*>(owned_numpy_items.obj());\n+\n+  int64_t chunk_offset = 0;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    auto arr = std::static_pointer_cast<MapArray>(data.chunk(c));\n+    const bool has_nulls = data.null_count() > 0;\n+\n+    // Make a list of key/item pairs for each row in array\n+    for (int64_t i = 0; i < arr->length(); ++i) {\n+      if (has_nulls && arr->IsNull(i)) {\n+        Py_INCREF(Py_None);\n+        *out_values = Py_None;\n+      } else {\n+        int64_t entry_offset = arr->value_offset(i);\n+        int64_t num_maps = arr->value_offset(i + 1) - entry_offset;\n+\n+        // Build the new list object for the row of maps\n+        list_item.reset(PyList_New(0));\n+        RETURN_IF_PYERROR();\n+\n+        // Add each key/item pair in the row\n+        for (int64_t j = 0; j < num_maps; ++j) {\n+          // Get key value, key is non-nullable for a valid row\n+          auto ptr_key = reinterpret_cast<const char*>(\n+              PyArray_GETPTR1(py_keys, chunk_offset + entry_offset + j));\n+          key_value.reset(PyArray_GETITEM(py_keys, ptr_key));\n+          RETURN_IF_PYERROR();\n+\n+          if (item_arrays[c]->IsNull(entry_offset + j)) {\n\nReview comment:\n       Actually, this doesn't seem to quite work. The backing array is numpy so if the dtype is an object, it will return `None`, but if numeric, it will be `nan`. I think we want the conversion to have `None` for all null values right?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-07T06:57:08.546+0000",
                    "updated": "2020-10-07T06:57:08.546+0000",
                    "started": "2020-10-07T06:57:08.546+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "496340",
                    "issueId": "13330418"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/worklog/496341",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "BryanCutler commented on a change in pull request #8337:\nURL: https://github.com/apache/arrow/pull/8337#discussion_r500779323\n\n\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,117 @@ Status ConvertListsLike(const PandasOptions& options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+inline Status ConvertMap(const PandasOptions& options, const ChunkedArray& data,\n+                         PyObject** out_values) {\n+  // Get columns of underlying key/item arrays\n+  std::vector<std::shared_ptr<Array>> key_arrays;\n+  std::vector<std::shared_ptr<Array>> item_arrays;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& map_arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    key_arrays.emplace_back(map_arr.keys());\n+    item_arrays.emplace_back(map_arr.items());\n+  }\n+\n+  const auto& map_type = checked_cast<const MapType&>(*data.type());\n+  auto key_type = map_type.key_type();\n+  auto item_type = map_type.item_type();\n+\n+  // ARROW-6899: Convert dictionary-encoded children to dense instead of\n+  // failing below. A more efficient conversion than this could be done later\n+  if (key_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*key_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &key_arrays));\n+    key_type = dense_type;\n+  }\n+  if (item_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*item_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &item_arrays));\n+    item_type = dense_type;\n+  }\n+\n+  // TODO(ARROW-489): Currently we don't have a Python reference for single columns.\n+  //    Storing a reference to the whole Array would be too expensive.\n+\n+  // ARROW-3789(wesm): During refactoring I found that unit tests assumed that\n+  // timestamp units would be preserved on list<timestamp UNIT> conversions in\n+  // Table.to_pandas. So we set the option here to not coerce things to\n+  // nanoseconds. Bit of a hack but this seemed the simplest thing to satisfy\n+  // the existing unit tests\n+  PandasOptions modified_options = options;\n+  modified_options.coerce_temporal_nanoseconds = false;\n+\n+  auto flat_keys = std::make_shared<ChunkedArray>(key_arrays, key_type);\n+  auto flat_items = std::make_shared<ChunkedArray>(item_arrays, item_type);\n+  OwnedRef list_item;\n+  OwnedRef key_value;\n+  OwnedRef item_value;\n+  OwnedRefNoGIL owned_numpy_keys;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_keys, nullptr,\n+                                            owned_numpy_keys.ref()));\n+  OwnedRefNoGIL owned_numpy_items;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_items, nullptr,\n+                                            owned_numpy_items.ref()));\n+  PyArrayObject* py_keys = reinterpret_cast<PyArrayObject*>(owned_numpy_keys.obj());\n+  PyArrayObject* py_items = reinterpret_cast<PyArrayObject*>(owned_numpy_items.obj());\n+\n+  int64_t chunk_offset = 0;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    auto arr = std::static_pointer_cast<MapArray>(data.chunk(c));\n+    const bool has_nulls = data.null_count() > 0;\n+\n+    // Make a list of key/item pairs for each row in array\n+    for (int64_t i = 0; i < arr->length(); ++i) {\n+      if (has_nulls && arr->IsNull(i)) {\n+        Py_INCREF(Py_None);\n+        *out_values = Py_None;\n+      } else {\n+        int64_t entry_offset = arr->value_offset(i);\n+        int64_t num_maps = arr->value_offset(i + 1) - entry_offset;\n+\n+        // Build the new list object for the row of maps\n+        list_item.reset(PyList_New(0));\n+        RETURN_IF_PYERROR();\n+\n+        // Add each key/item pair in the row\n+        for (int64_t j = 0; j < num_maps; ++j) {\n+          // Get key value, key is non-nullable for a valid row\n+          auto ptr_key = reinterpret_cast<const char*>(\n+              PyArray_GETPTR1(py_keys, chunk_offset + entry_offset + j));\n+          key_value.reset(PyArray_GETITEM(py_keys, ptr_key));\n+          RETURN_IF_PYERROR();\n+\n+          if (item_arrays[c]->IsNull(entry_offset + j)) {\n+            // Translate the Null to a None\n+            Py_INCREF(Py_None);\n\nReview comment:\n       Isn't the line below adding another reference to that object?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-07T06:59:14.909+0000",
                    "updated": "2020-10-07T06:59:14.909+0000",
                    "started": "2020-10-07T06:59:14.909+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "496341",
                    "issueId": "13330418"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/worklog/496343",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "BryanCutler commented on a change in pull request #8337:\nURL: https://github.com/apache/arrow/pull/8337#discussion_r500780264\n\n\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,117 @@ Status ConvertListsLike(const PandasOptions& options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+inline Status ConvertMap(const PandasOptions& options, const ChunkedArray& data,\n+                         PyObject** out_values) {\n+  // Get columns of underlying key/item arrays\n+  std::vector<std::shared_ptr<Array>> key_arrays;\n+  std::vector<std::shared_ptr<Array>> item_arrays;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& map_arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    key_arrays.emplace_back(map_arr.keys());\n+    item_arrays.emplace_back(map_arr.items());\n+  }\n+\n+  const auto& map_type = checked_cast<const MapType&>(*data.type());\n+  auto key_type = map_type.key_type();\n+  auto item_type = map_type.item_type();\n+\n+  // ARROW-6899: Convert dictionary-encoded children to dense instead of\n+  // failing below. A more efficient conversion than this could be done later\n+  if (key_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*key_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &key_arrays));\n+    key_type = dense_type;\n+  }\n+  if (item_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*item_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &item_arrays));\n+    item_type = dense_type;\n+  }\n+\n+  // TODO(ARROW-489): Currently we don't have a Python reference for single columns.\n+  //    Storing a reference to the whole Array would be too expensive.\n+\n+  // ARROW-3789(wesm): During refactoring I found that unit tests assumed that\n+  // timestamp units would be preserved on list<timestamp UNIT> conversions in\n+  // Table.to_pandas. So we set the option here to not coerce things to\n+  // nanoseconds. Bit of a hack but this seemed the simplest thing to satisfy\n+  // the existing unit tests\n+  PandasOptions modified_options = options;\n+  modified_options.coerce_temporal_nanoseconds = false;\n+\n+  auto flat_keys = std::make_shared<ChunkedArray>(key_arrays, key_type);\n+  auto flat_items = std::make_shared<ChunkedArray>(item_arrays, item_type);\n+  OwnedRef list_item;\n+  OwnedRef key_value;\n+  OwnedRef item_value;\n+  OwnedRefNoGIL owned_numpy_keys;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_keys, nullptr,\n+                                            owned_numpy_keys.ref()));\n+  OwnedRefNoGIL owned_numpy_items;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_items, nullptr,\n+                                            owned_numpy_items.ref()));\n+  PyArrayObject* py_keys = reinterpret_cast<PyArrayObject*>(owned_numpy_keys.obj());\n+  PyArrayObject* py_items = reinterpret_cast<PyArrayObject*>(owned_numpy_items.obj());\n+\n+  int64_t chunk_offset = 0;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    auto arr = std::static_pointer_cast<MapArray>(data.chunk(c));\n+    const bool has_nulls = data.null_count() > 0;\n+\n+    // Make a list of key/item pairs for each row in array\n+    for (int64_t i = 0; i < arr->length(); ++i) {\n+      if (has_nulls && arr->IsNull(i)) {\n+        Py_INCREF(Py_None);\n+        *out_values = Py_None;\n+      } else {\n+        int64_t entry_offset = arr->value_offset(i);\n+        int64_t num_maps = arr->value_offset(i + 1) - entry_offset;\n+\n+        // Build the new list object for the row of maps\n+        list_item.reset(PyList_New(0));\n+        RETURN_IF_PYERROR();\n+\n+        // Add each key/item pair in the row\n+        for (int64_t j = 0; j < num_maps; ++j) {\n+          // Get key value, key is non-nullable for a valid row\n+          auto ptr_key = reinterpret_cast<const char*>(\n+              PyArray_GETPTR1(py_keys, chunk_offset + entry_offset + j));\n+          key_value.reset(PyArray_GETITEM(py_keys, ptr_key));\n+          RETURN_IF_PYERROR();\n+\n+          if (item_arrays[c]->IsNull(entry_offset + j)) {\n+            // Translate the Null to a None\n+            Py_INCREF(Py_None);\n+            item_value.reset(Py_None);\n+          } else {\n+            // Get valid value from item array\n+            auto ptr_item = reinterpret_cast<const char*>(\n+                PyArray_GETPTR1(py_items, chunk_offset + entry_offset + j));\n+            item_value.reset(PyArray_GETITEM(py_items, ptr_item));\n+            RETURN_IF_PYERROR();\n+          }\n+\n+          // Add the key/item pair to the list for the row\n+          PyList_Append(list_item.obj(),\n+                        PyTuple_Pack(2, key_value.obj(), item_value.obj()));\n+          RETURN_IF_PYERROR();\n+        }\n+\n+        *out_values = list_item.obj();\n+        // Grant ownership to the resulting array\n+        Py_INCREF(*out_values);\n\nReview comment:\n       Again, I was following `ConvertStruct()` but I can change it if you prefer\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-07T07:01:03.456+0000",
                    "updated": "2020-10-07T07:01:03.456+0000",
                    "started": "2020-10-07T07:01:03.456+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "496343",
                    "issueId": "13330418"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/worklog/496347",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "BryanCutler commented on pull request #8337:\nURL: https://github.com/apache/arrow/pull/8337#issuecomment-704745055\n\n\n   Thanks for reviewing @pitrou , I updated but still had a couple questions and I'm not totally sure I got the reference counting right. I'll have to take a closer look tomorrow.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-07T07:16:06.232+0000",
                    "updated": "2020-10-07T07:16:06.232+0000",
                    "started": "2020-10-07T07:16:06.232+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "496347",
                    "issueId": "13330418"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/worklog/496409",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8337:\nURL: https://github.com/apache/arrow/pull/8337#discussion_r500866571\n\n\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,117 @@ Status ConvertListsLike(const PandasOptions& options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+inline Status ConvertMap(const PandasOptions& options, const ChunkedArray& data,\n+                         PyObject** out_values) {\n+  // Get columns of underlying key/item arrays\n+  std::vector<std::shared_ptr<Array>> key_arrays;\n+  std::vector<std::shared_ptr<Array>> item_arrays;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& map_arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    key_arrays.emplace_back(map_arr.keys());\n+    item_arrays.emplace_back(map_arr.items());\n+  }\n+\n+  const auto& map_type = checked_cast<const MapType&>(*data.type());\n+  auto key_type = map_type.key_type();\n+  auto item_type = map_type.item_type();\n+\n+  // ARROW-6899: Convert dictionary-encoded children to dense instead of\n+  // failing below. A more efficient conversion than this could be done later\n+  if (key_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*key_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &key_arrays));\n+    key_type = dense_type;\n+  }\n+  if (item_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*item_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &item_arrays));\n+    item_type = dense_type;\n+  }\n+\n+  // TODO(ARROW-489): Currently we don't have a Python reference for single columns.\n+  //    Storing a reference to the whole Array would be too expensive.\n+\n+  // ARROW-3789(wesm): During refactoring I found that unit tests assumed that\n+  // timestamp units would be preserved on list<timestamp UNIT> conversions in\n+  // Table.to_pandas. So we set the option here to not coerce things to\n+  // nanoseconds. Bit of a hack but this seemed the simplest thing to satisfy\n+  // the existing unit tests\n+  PandasOptions modified_options = options;\n+  modified_options.coerce_temporal_nanoseconds = false;\n+\n+  auto flat_keys = std::make_shared<ChunkedArray>(key_arrays, key_type);\n+  auto flat_items = std::make_shared<ChunkedArray>(item_arrays, item_type);\n+  OwnedRef list_item;\n+  OwnedRef key_value;\n+  OwnedRef item_value;\n+  OwnedRefNoGIL owned_numpy_keys;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_keys, nullptr,\n+                                            owned_numpy_keys.ref()));\n+  OwnedRefNoGIL owned_numpy_items;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_items, nullptr,\n+                                            owned_numpy_items.ref()));\n+  PyArrayObject* py_keys = reinterpret_cast<PyArrayObject*>(owned_numpy_keys.obj());\n+  PyArrayObject* py_items = reinterpret_cast<PyArrayObject*>(owned_numpy_items.obj());\n+\n+  int64_t chunk_offset = 0;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    auto arr = std::static_pointer_cast<MapArray>(data.chunk(c));\n+    const bool has_nulls = data.null_count() > 0;\n+\n+    // Make a list of key/item pairs for each row in array\n+    for (int64_t i = 0; i < arr->length(); ++i) {\n+      if (has_nulls && arr->IsNull(i)) {\n+        Py_INCREF(Py_None);\n+        *out_values = Py_None;\n+      } else {\n+        int64_t entry_offset = arr->value_offset(i);\n+        int64_t num_maps = arr->value_offset(i + 1) - entry_offset;\n+\n+        // Build the new list object for the row of maps\n+        list_item.reset(PyList_New(0));\n+        RETURN_IF_PYERROR();\n+\n+        // Add each key/item pair in the row\n+        for (int64_t j = 0; j < num_maps; ++j) {\n+          // Get key value, key is non-nullable for a valid row\n+          auto ptr_key = reinterpret_cast<const char*>(\n+              PyArray_GETPTR1(py_keys, chunk_offset + entry_offset + j));\n+          key_value.reset(PyArray_GETITEM(py_keys, ptr_key));\n+          RETURN_IF_PYERROR();\n+\n+          if (item_arrays[c]->IsNull(entry_offset + j)) {\n\nReview comment:\n       Ah, ok, thank you.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-07T09:24:37.248+0000",
                    "updated": "2020-10-07T09:24:37.248+0000",
                    "started": "2020-10-07T09:24:37.248+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "496409",
                    "issueId": "13330418"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/worklog/496411",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8337:\nURL: https://github.com/apache/arrow/pull/8337#discussion_r500867795\n\n\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,117 @@ Status ConvertListsLike(const PandasOptions& options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+inline Status ConvertMap(const PandasOptions& options, const ChunkedArray& data,\n+                         PyObject** out_values) {\n+  // Get columns of underlying key/item arrays\n+  std::vector<std::shared_ptr<Array>> key_arrays;\n+  std::vector<std::shared_ptr<Array>> item_arrays;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& map_arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    key_arrays.emplace_back(map_arr.keys());\n+    item_arrays.emplace_back(map_arr.items());\n+  }\n+\n+  const auto& map_type = checked_cast<const MapType&>(*data.type());\n+  auto key_type = map_type.key_type();\n+  auto item_type = map_type.item_type();\n+\n+  // ARROW-6899: Convert dictionary-encoded children to dense instead of\n+  // failing below. A more efficient conversion than this could be done later\n+  if (key_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*key_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &key_arrays));\n+    key_type = dense_type;\n+  }\n+  if (item_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*item_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &item_arrays));\n+    item_type = dense_type;\n+  }\n+\n+  // TODO(ARROW-489): Currently we don't have a Python reference for single columns.\n+  //    Storing a reference to the whole Array would be too expensive.\n+\n+  // ARROW-3789(wesm): During refactoring I found that unit tests assumed that\n+  // timestamp units would be preserved on list<timestamp UNIT> conversions in\n+  // Table.to_pandas. So we set the option here to not coerce things to\n+  // nanoseconds. Bit of a hack but this seemed the simplest thing to satisfy\n+  // the existing unit tests\n+  PandasOptions modified_options = options;\n+  modified_options.coerce_temporal_nanoseconds = false;\n+\n+  auto flat_keys = std::make_shared<ChunkedArray>(key_arrays, key_type);\n+  auto flat_items = std::make_shared<ChunkedArray>(item_arrays, item_type);\n+  OwnedRef list_item;\n+  OwnedRef key_value;\n+  OwnedRef item_value;\n+  OwnedRefNoGIL owned_numpy_keys;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_keys, nullptr,\n+                                            owned_numpy_keys.ref()));\n+  OwnedRefNoGIL owned_numpy_items;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_items, nullptr,\n+                                            owned_numpy_items.ref()));\n+  PyArrayObject* py_keys = reinterpret_cast<PyArrayObject*>(owned_numpy_keys.obj());\n+  PyArrayObject* py_items = reinterpret_cast<PyArrayObject*>(owned_numpy_items.obj());\n+\n+  int64_t chunk_offset = 0;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    auto arr = std::static_pointer_cast<MapArray>(data.chunk(c));\n+    const bool has_nulls = data.null_count() > 0;\n+\n+    // Make a list of key/item pairs for each row in array\n+    for (int64_t i = 0; i < arr->length(); ++i) {\n+      if (has_nulls && arr->IsNull(i)) {\n+        Py_INCREF(Py_None);\n+        *out_values = Py_None;\n+      } else {\n+        int64_t entry_offset = arr->value_offset(i);\n+        int64_t num_maps = arr->value_offset(i + 1) - entry_offset;\n+\n+        // Build the new list object for the row of maps\n+        list_item.reset(PyList_New(0));\n+        RETURN_IF_PYERROR();\n+\n+        // Add each key/item pair in the row\n+        for (int64_t j = 0; j < num_maps; ++j) {\n+          // Get key value, key is non-nullable for a valid row\n+          auto ptr_key = reinterpret_cast<const char*>(\n+              PyArray_GETPTR1(py_keys, chunk_offset + entry_offset + j));\n+          key_value.reset(PyArray_GETITEM(py_keys, ptr_key));\n+          RETURN_IF_PYERROR();\n+\n+          if (item_arrays[c]->IsNull(entry_offset + j)) {\n+            // Translate the Null to a None\n+            Py_INCREF(Py_None);\n\nReview comment:\n       Hmm, right, it should be ok.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-07T09:26:35.889+0000",
                    "updated": "2020-10-07T09:26:35.889+0000",
                    "started": "2020-10-07T09:26:35.889+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "496411",
                    "issueId": "13330418"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/worklog/496413",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8337:\nURL: https://github.com/apache/arrow/pull/8337#discussion_r500868159\n\n\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,117 @@ Status ConvertListsLike(const PandasOptions& options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+inline Status ConvertMap(const PandasOptions& options, const ChunkedArray& data,\n+                         PyObject** out_values) {\n+  // Get columns of underlying key/item arrays\n+  std::vector<std::shared_ptr<Array>> key_arrays;\n+  std::vector<std::shared_ptr<Array>> item_arrays;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& map_arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    key_arrays.emplace_back(map_arr.keys());\n+    item_arrays.emplace_back(map_arr.items());\n+  }\n+\n+  const auto& map_type = checked_cast<const MapType&>(*data.type());\n+  auto key_type = map_type.key_type();\n+  auto item_type = map_type.item_type();\n+\n+  // ARROW-6899: Convert dictionary-encoded children to dense instead of\n+  // failing below. A more efficient conversion than this could be done later\n+  if (key_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*key_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &key_arrays));\n+    key_type = dense_type;\n+  }\n+  if (item_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*item_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &item_arrays));\n+    item_type = dense_type;\n+  }\n+\n+  // TODO(ARROW-489): Currently we don't have a Python reference for single columns.\n+  //    Storing a reference to the whole Array would be too expensive.\n+\n+  // ARROW-3789(wesm): During refactoring I found that unit tests assumed that\n+  // timestamp units would be preserved on list<timestamp UNIT> conversions in\n+  // Table.to_pandas. So we set the option here to not coerce things to\n+  // nanoseconds. Bit of a hack but this seemed the simplest thing to satisfy\n+  // the existing unit tests\n+  PandasOptions modified_options = options;\n+  modified_options.coerce_temporal_nanoseconds = false;\n+\n+  auto flat_keys = std::make_shared<ChunkedArray>(key_arrays, key_type);\n+  auto flat_items = std::make_shared<ChunkedArray>(item_arrays, item_type);\n+  OwnedRef list_item;\n+  OwnedRef key_value;\n+  OwnedRef item_value;\n+  OwnedRefNoGIL owned_numpy_keys;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_keys, nullptr,\n+                                            owned_numpy_keys.ref()));\n+  OwnedRefNoGIL owned_numpy_items;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(modified_options, flat_items, nullptr,\n+                                            owned_numpy_items.ref()));\n+  PyArrayObject* py_keys = reinterpret_cast<PyArrayObject*>(owned_numpy_keys.obj());\n+  PyArrayObject* py_items = reinterpret_cast<PyArrayObject*>(owned_numpy_items.obj());\n+\n+  int64_t chunk_offset = 0;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    auto arr = std::static_pointer_cast<MapArray>(data.chunk(c));\n+    const bool has_nulls = data.null_count() > 0;\n+\n+    // Make a list of key/item pairs for each row in array\n+    for (int64_t i = 0; i < arr->length(); ++i) {\n+      if (has_nulls && arr->IsNull(i)) {\n+        Py_INCREF(Py_None);\n+        *out_values = Py_None;\n+      } else {\n+        int64_t entry_offset = arr->value_offset(i);\n+        int64_t num_maps = arr->value_offset(i + 1) - entry_offset;\n+\n+        // Build the new list object for the row of maps\n+        list_item.reset(PyList_New(0));\n+        RETURN_IF_PYERROR();\n+\n+        // Add each key/item pair in the row\n+        for (int64_t j = 0; j < num_maps; ++j) {\n+          // Get key value, key is non-nullable for a valid row\n+          auto ptr_key = reinterpret_cast<const char*>(\n+              PyArray_GETPTR1(py_keys, chunk_offset + entry_offset + j));\n+          key_value.reset(PyArray_GETITEM(py_keys, ptr_key));\n+          RETURN_IF_PYERROR();\n+\n+          if (item_arrays[c]->IsNull(entry_offset + j)) {\n+            // Translate the Null to a None\n+            Py_INCREF(Py_None);\n+            item_value.reset(Py_None);\n+          } else {\n+            // Get valid value from item array\n+            auto ptr_item = reinterpret_cast<const char*>(\n+                PyArray_GETPTR1(py_items, chunk_offset + entry_offset + j));\n+            item_value.reset(PyArray_GETITEM(py_items, ptr_item));\n+            RETURN_IF_PYERROR();\n\nReview comment:\n       Ah, I though `PyArray_GETITEM` was a simple macro but it seems more involved. So it can return an error indeed.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-07T09:27:11.989+0000",
                    "updated": "2020-10-07T09:27:11.989+0000",
                    "started": "2020-10-07T09:27:11.989+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "496413",
                    "issueId": "13330418"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/worklog/496414",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8337:\nURL: https://github.com/apache/arrow/pull/8337#discussion_r500868740\n\n\n\n##########\nFile path: cpp/src/arrow/python/arrow_to_pandas.cc\n##########\n@@ -791,6 +791,111 @@ Status ConvertListsLike(PandasOptions options, const ChunkedArray& data,\n   return Status::OK();\n }\n \n+Status ConvertMap(PandasOptions options, const ChunkedArray& data,\n+                  PyObject** out_values) {\n+  // Get columns of underlying key/item arrays\n+  std::vector<std::shared_ptr<Array>> key_arrays;\n+  std::vector<std::shared_ptr<Array>> item_arrays;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& map_arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    key_arrays.emplace_back(map_arr.keys());\n+    item_arrays.emplace_back(map_arr.items());\n+  }\n+\n+  const auto& map_type = checked_cast<const MapType&>(*data.type());\n+  auto key_type = map_type.key_type();\n+  auto item_type = map_type.item_type();\n+\n+  // ARROW-6899: Convert dictionary-encoded children to dense instead of\n+  // failing below. A more efficient conversion than this could be done later\n+  if (key_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*key_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &key_arrays));\n+    key_type = dense_type;\n+  }\n+  if (item_type->id() == Type::DICTIONARY) {\n+    auto dense_type = checked_cast<const DictionaryType&>(*item_type).value_type();\n+    RETURN_NOT_OK(DecodeDictionaries(options.pool, dense_type, &item_arrays));\n+    item_type = dense_type;\n+  }\n+\n+  // See notes in MakeInnerOptions.\n+  options = MakeInnerOptions(std::move(options));\n+  // Don't blindly convert because timestamps in lists are handled differently.\n+  options.timestamp_as_object = true;\n+\n+  auto flat_keys = std::make_shared<ChunkedArray>(key_arrays, key_type);\n+  auto flat_items = std::make_shared<ChunkedArray>(item_arrays, item_type);\n+  OwnedRef list_item;\n+  OwnedRef key_value;\n+  OwnedRef item_value;\n+  OwnedRefNoGIL owned_numpy_keys;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(options, flat_keys, nullptr,\n+                                            owned_numpy_keys.ref()));\n+  OwnedRefNoGIL owned_numpy_items;\n+  RETURN_NOT_OK(ConvertChunkedArrayToPandas(options, flat_items, nullptr,\n+                                            owned_numpy_items.ref()));\n+  PyArrayObject* py_keys = reinterpret_cast<PyArrayObject*>(owned_numpy_keys.obj());\n+  PyArrayObject* py_items = reinterpret_cast<PyArrayObject*>(owned_numpy_items.obj());\n+\n+  int64_t chunk_offset = 0;\n+  for (int c = 0; c < data.num_chunks(); ++c) {\n+    const auto& arr = checked_cast<const MapArray&>(*data.chunk(c));\n+    const bool has_nulls = data.null_count() > 0;\n+\n+    // Make a list of key/item pairs for each row in array\n+    for (int64_t i = 0; i < arr.length(); ++i) {\n+      if (has_nulls && arr.IsNull(i)) {\n+        Py_INCREF(Py_None);\n+        *out_values = Py_None;\n+      } else {\n+        int64_t entry_offset = arr.value_offset(i);\n+        int64_t num_maps = arr.value_offset(i + 1) - entry_offset;\n+\n+        // Build the new list object for the row of maps\n+        list_item.reset(PyList_New(num_maps));\n+        RETURN_IF_PYERROR();\n+\n+        // Add each key/item pair in the row\n+        for (int64_t j = 0; j < num_maps; ++j) {\n+          // Get key value, key is non-nullable for a valid row\n+          auto ptr_key = reinterpret_cast<const char*>(\n+              PyArray_GETPTR1(py_keys, chunk_offset + entry_offset + j));\n+          key_value.reset(PyArray_GETITEM(py_keys, ptr_key));\n+          RETURN_IF_PYERROR();\n+\n+          if (item_arrays[c]->IsNull(entry_offset + j)) {\n+            // Translate the Null to a None\n+            Py_INCREF(Py_None);\n+            item_value.reset(Py_None);\n+          } else {\n+            // Get valid value from item array\n+            auto ptr_item = reinterpret_cast<const char*>(\n+                PyArray_GETPTR1(py_items, chunk_offset + entry_offset + j));\n+            item_value.reset(PyArray_GETITEM(py_items, ptr_item));\n+            RETURN_IF_PYERROR();\n+          }\n+\n+          // Add the key/item pair to the list for the row\n+          PyList_SET_ITEM(list_item.obj(), j,\n+                          PyTuple_Pack(2, key_value.obj(), item_value.obj()));\n+          RETURN_IF_PYERROR();\n+        }\n+\n+        *out_values = list_item.obj();\n\nReview comment:\n       `*out_values = list_item.detach()`, simply.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-07T09:28:05.533+0000",
                    "updated": "2020-10-07T09:28:05.533+0000",
                    "started": "2020-10-07T09:28:05.532+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "496414",
                    "issueId": "13330418"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 14400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@6892cc9f[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6b099418[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6ea7bd59[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@49294dc1[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@65e8a2b1[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@ec32bbe[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5ddd124a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@5e991b75[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7ec4c73d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@694d9d80[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5cb78da1[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@4a6377f1[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 14400,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Oct 07 11:09:08 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-10-07T11:09:07.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10151/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2020-10-01T17:54:19.000+0000",
        "updated": "2020-10-09T23:54:00.000+0000",
        "timeoriginalestimate": null,
        "description": "MapArray does not currently support to_pandas conversion and raises a {{Status::NotImplemented(\"No known equivalent Pandas block for Arrow data of type \")}}\r\n\r\nConversion from Pandas seems to work, but should verify there are tests in place.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "4h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 14400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Python] Add support MapArray to_pandas conversion",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/comment/17205715",
                    "id": "17205715",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
                        "name": "bryanc",
                        "key": "bryanc",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
                        },
                        "displayName": "Bryan Cutler",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "I started working on this, I think I can have it ready for the 2.0.0 release.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
                        "name": "bryanc",
                        "key": "bryanc",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
                        },
                        "displayName": "Bryan Cutler",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2020-10-01T17:54:45.087+0000",
                    "updated": "2020-10-01T17:54:45.087+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/comment/17205727",
                    "id": "17205727",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "ARROW-9812 is similar, though that also talks about Parquet, not just Pandas.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-10-01T18:06:43.446+0000",
                    "updated": "2020-10-01T18:06:43.446+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/comment/17205730",
                    "id": "17205730",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
                        "name": "bryanc",
                        "key": "bryanc",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
                        },
                        "displayName": "Bryan Cutler",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Thanks David, I must have missed that one. I'll keep this open for Pandas conversion.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
                        "name": "bryanc",
                        "key": "bryanc",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
                        },
                        "displayName": "Bryan Cutler",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2020-10-01T18:10:02.304+0000",
                    "updated": "2020-10-01T18:10:02.304+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330418/comment/17209472",
                    "id": "17209472",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 8337\n[https://github.com/apache/arrow/pull/8337]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2020-10-07T11:09:08.014+0000",
                    "updated": "2020-10-07T11:09:08.014+0000"
                }
            ],
            "maxResults": 4,
            "total": 4,
            "startAt": 0
        },
        "customfield_12311820": "0|z0j3a0:",
        "customfield_12314139": null
    }
}