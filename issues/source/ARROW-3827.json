{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13199068",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13199068",
    "key": "ARROW-3827",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12347769",
                "id": "12347769",
                "description": "",
                "name": "1.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-07-24"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=paddyhoran",
            "name": "paddyhoran",
            "key": "paddyhoran",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Paddy Horan",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333773",
                "id": "12333773",
                "name": "Rust"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=paddyhoran",
            "name": "paddyhoran",
            "key": "paddyhoran",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Paddy Horan",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=paddyhoran",
            "name": "paddyhoran",
            "key": "paddyhoran",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Paddy Horan",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 12600,
            "total": 12600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 12600,
            "total": 12600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3827/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 21,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13199068/worklog/372757",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paddyhoran commented on pull request #6209: ARROW-3827: [Rust] Implement UnionArray\nURL: https://github.com/apache/arrow/pull/6209\n \n \n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-01-16T03:17:47.641+0000",
                    "updated": "2020-01-16T03:17:47.641+0000",
                    "started": "2020-01-16T03:17:47.640+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "372757",
                    "issueId": "13199068"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13199068/worklog/372762",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on issue #6209: ARROW-3827: [Rust] Implement UnionArray\nURL: https://github.com/apache/arrow/pull/6209#issuecomment-574965905\n \n \n   https://issues.apache.org/jira/browse/ARROW-3827\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-01-16T03:31:46.283+0000",
                    "updated": "2020-01-16T03:31:46.283+0000",
                    "started": "2020-01-16T03:31:46.283+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "372762",
                    "issueId": "13199068"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13199068/worklog/426321",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on a change in pull request #7004:\nURL: https://github.com/apache/arrow/pull/7004#discussion_r413407264\n\n\n\n##########\nFile path: rust/arrow/src/array/equal.rs\n##########\n@@ -692,6 +692,22 @@ impl ArrayEqual for StructArray {\n     }\n }\n \n+impl ArrayEqual for UnionArray {\n+    fn equals(&self, _other: &dyn Array) -> bool {\n+        unimplemented!()\n\nReview comment:\n       Is this intentionally unimplemented? If so, would be good to add a comment explaining that.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-22T23:44:51.646+0000",
                    "updated": "2020-04-22T23:44:51.646+0000",
                    "started": "2020-04-22T23:44:51.646+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426321",
                    "issueId": "13199068"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13199068/worklog/426322",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on a change in pull request #7004:\nURL: https://github.com/apache/arrow/pull/7004#discussion_r413407658\n\n\n\n##########\nFile path: rust/arrow/src/array/equal.rs\n##########\n@@ -692,6 +692,22 @@ impl ArrayEqual for StructArray {\n     }\n }\n \n+impl ArrayEqual for UnionArray {\n+    fn equals(&self, _other: &dyn Array) -> bool {\n+        unimplemented!()\n+    }\n+\n+    fn range_equals(\n+        &self,\n+        _other: &dyn Array,\n+        _start_idx: usize,\n+        _end_idx: usize,\n+        _other_start_idx: usize,\n+    ) -> bool {\n+        unimplemented!()\n\nReview comment:\n       Is this intentionally unimplemented? If so, would be good to add a comment explaining that.\n\n##########\nFile path: rust/arrow/src/array/equal.rs\n##########\n@@ -1046,6 +1062,30 @@ impl PartialEq<FixedSizeBinaryArray> for Value {\n     }\n }\n \n+impl JsonEqual for UnionArray {\n+    fn equals_json(&self, _json: &[&Value]) -> bool {\n+        unimplemented!()\n\nReview comment:\n       Is this intentionally unimplemented? If so, would be good to add a comment explaining that.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-22T23:45:55.068+0000",
                    "updated": "2020-04-22T23:45:55.068+0000",
                    "started": "2020-04-22T23:45:55.068+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426322",
                    "issueId": "13199068"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13199068/worklog/426323",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on a change in pull request #7004:\nURL: https://github.com/apache/arrow/pull/7004#discussion_r413408241\n\n\n\n##########\nFile path: rust/arrow/src/array/equal.rs\n##########\n@@ -1046,6 +1062,30 @@ impl PartialEq<FixedSizeBinaryArray> for Value {\n     }\n }\n \n+impl JsonEqual for UnionArray {\n+    fn equals_json(&self, _json: &[&Value]) -> bool {\n+        unimplemented!()\n+    }\n+}\n+\n+impl PartialEq<Value> for UnionArray {\n+    fn eq(&self, json: &Value) -> bool {\n+        match json {\n+            Value::Array(json_array) => self.equals_json_values(&json_array),\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl PartialEq<UnionArray> for Value {\n+    fn eq(&self, arrow: &UnionArray) -> bool {\n+        match self {\n\nReview comment:\n       nit: these two `eq` methods are very similar, but in one, you match on `self` and then compare to the argument and in the other one, this is transposed. It would be nice to make these consistent.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-22T23:47:22.113+0000",
                    "updated": "2020-04-22T23:47:22.113+0000",
                    "started": "2020-04-22T23:47:22.113+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426323",
                    "issueId": "13199068"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13199068/worklog/426324",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on a change in pull request #7004:\nURL: https://github.com/apache/arrow/pull/7004#discussion_r413408444\n\n\n\n##########\nFile path: rust/arrow/src/array/mod.rs\n##########\n@@ -85,6 +85,7 @@ mod array;\n mod builder;\n mod data;\n mod equal;\n+mod union;\n\nReview comment:\n       I agree that it makes sense to have submodules under array.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-22T23:47:55.462+0000",
                    "updated": "2020-04-22T23:47:55.462+0000",
                    "started": "2020-04-22T23:47:55.462+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426324",
                    "issueId": "13199068"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13199068/worklog/426828",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paddyhoran commented on pull request #7004:\nURL: https://github.com/apache/arrow/pull/7004#issuecomment-618761556\n\n\n   @andygrove just going to leave a general comment as it's all related.\r\n   \r\n   Overall, I felt this PR was getting big, I was trying to avoid getting into the IPC stuff in this PR, this is the reason I left some things `unimplemented`.  I created the following follow up JIRA's to address all these issues.\r\n   \r\n   Both `JsonEquals` (ARROW-8547) and `ArrayEquals` (ARROW-8576) were introduced to compare arrays as part of the IPC implementation but are required to be implemented to implement the `Array` trait.\r\n   \r\n   Adding `UnionArray` to `get_fb_field_type` is obviously IPC related as well (ARROW-8546).\r\n   \r\n   I waited until the recent release was cut before submitting this so as to make sure that the `unimplemented` didn't get released.\r\n   \r\n   I'll follow up on the items above once I get this much merged.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-24T02:07:45.676+0000",
                    "updated": "2020-04-24T02:07:45.676+0000",
                    "started": "2020-04-24T02:07:45.676+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426828",
                    "issueId": "13199068"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13199068/worklog/426829",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paddyhoran commented on a change in pull request #7004:\nURL: https://github.com/apache/arrow/pull/7004#discussion_r414240892\n\n\n\n##########\nFile path: rust/arrow/src/array/equal.rs\n##########\n@@ -1046,6 +1062,30 @@ impl PartialEq<FixedSizeBinaryArray> for Value {\n     }\n }\n \n+impl JsonEqual for UnionArray {\n+    fn equals_json(&self, _json: &[&Value]) -> bool {\n+        unimplemented!()\n+    }\n+}\n+\n+impl PartialEq<Value> for UnionArray {\n+    fn eq(&self, json: &Value) -> bool {\n+        match json {\n+            Value::Array(json_array) => self.equals_json_values(&json_array),\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl PartialEq<UnionArray> for Value {\n+    fn eq(&self, arrow: &UnionArray) -> bool {\n+        match self {\n\nReview comment:\n       Actually I was just following the pattern here, I thought that they must both be needed for IPC.  I removed them.  I'll add them back when I get to implementing IPC if needed.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-24T02:09:09.207+0000",
                    "updated": "2020-04-24T02:09:09.207+0000",
                    "started": "2020-04-24T02:09:09.207+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426829",
                    "issueId": "13199068"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13199068/worklog/426831",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paddyhoran commented on a change in pull request #7004:\nURL: https://github.com/apache/arrow/pull/7004#discussion_r414241189\n\n\n\n##########\nFile path: rust/arrow/src/array/mod.rs\n##########\n@@ -85,6 +85,7 @@ mod array;\n mod builder;\n mod data;\n mod equal;\n+mod union;\n\nReview comment:\n       Yea, even just to make the tests categorized better.  I'll open a JIRA once this is merged.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-24T02:10:05.132+0000",
                    "updated": "2020-04-24T02:10:05.132+0000",
                    "started": "2020-04-24T02:10:05.132+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426831",
                    "issueId": "13199068"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13199068/worklog/429851",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paddyhoran commented on pull request #7004:\nURL: https://github.com/apache/arrow/pull/7004#issuecomment-622984848\n\n\n   @andygrove @nevi-me should I break this into smaller PR's to make it easier to get merged?\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-02T17:08:54.465+0000",
                    "updated": "2020-05-02T17:08:54.465+0000",
                    "started": "2020-05-02T17:08:54.464+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "429851",
                    "issueId": "13199068"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13199068/worklog/429919",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #7004:\nURL: https://github.com/apache/arrow/pull/7004#discussion_r419074062\n\n\n\n##########\nFile path: rust/arrow/src/array/union.rs\n##########\n@@ -0,0 +1,1174 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Contains the `UnionArray` and `UnionBuilder` types.\n+//!\n+//! Each slot in a `UnionArray` can have a value chosen from a number of types.  Each of the\n+//! possible types are named like the fields of a [`StructArray`](crate::array::StructArray).\n+//! A `UnionArray` can have two possible memory layouts, \"dense\" or \"sparse\".  For more information\n+//! on please see the [specification](https://arrow.apache.org/docs/format/Columnar.html#union-layout).\n+//!\n+//! Builders are provided for `UnionArray`'s involving primitive types.  `UnionArray`'s of nested\n+//! types are also supported but not via `UnionBuilder`, see the tests for examples.\n+//!\n+//! # Example: Dense Memory Layout\n+//!\n+//! ```\n+//! use arrow::array::UnionBuilder;\n+//! use arrow::datatypes::{Float64Type, Int32Type};\n+//!\n+//! # fn main() -> arrow::error::Result<()> {\n+//! let mut builder = UnionBuilder::new_dense(3);\n+//! builder.append::<Int32Type>(\"a\", 1).unwrap();\n+//! builder.append::<Float64Type>(\"b\", 3.0).unwrap();\n+//! builder.append::<Int32Type>(\"a\", 4).unwrap();\n+//! let union = builder.build().unwrap();\n+//!\n+//! assert_eq!(union.type_id(0), 0_i8);\n+//! assert_eq!(union.type_id(1), 1_i8);\n+//! assert_eq!(union.type_id(2), 0_i8);\n+//!\n+//! assert_eq!(union.value_offset(0), 0_i32);\n+//! assert_eq!(union.value_offset(1), 0_i32);\n+//! assert_eq!(union.value_offset(2), 1_i32);\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+//!\n+//! # Example: Sparse Memory Layout\n+//! ```\n+//! use arrow::array::UnionBuilder;\n+//! use arrow::datatypes::{Float64Type, Int32Type};\n+//!\n+//! # fn main() -> arrow::error::Result<()> {\n+//! let mut builder = UnionBuilder::new_sparse(3);\n+//! builder.append::<Int32Type>(\"a\", 1).unwrap();\n+//! builder.append::<Float64Type>(\"b\", 3.0).unwrap();\n+//! builder.append::<Int32Type>(\"a\", 4).unwrap();\n+//! let union = builder.build().unwrap();\n+//!\n+//! assert_eq!(union.type_id(0), 0_i8);\n+//! assert_eq!(union.type_id(1), 1_i8);\n+//! assert_eq!(union.type_id(2), 0_i8);\n+//!\n+//! assert_eq!(union.value_offset(0), 0_i32);\n+//! assert_eq!(union.value_offset(1), 1_i32);\n+//! assert_eq!(union.value_offset(2), 2_i32);\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+use crate::array::{\n+    builder::{builder_to_mutable_buffer, mutable_buffer_to_builder, BufferBuilderTrait},\n+    make_array, Array, ArrayData, ArrayDataBuilder, ArrayDataRef, ArrayRef,\n+    BooleanBufferBuilder, BufferBuilder, Int32BufferBuilder, Int8BufferBuilder,\n+};\n+use crate::buffer::{Buffer, MutableBuffer};\n+use crate::datatypes::*;\n+use crate::error::{ArrowError, Result};\n+\n+use crate::util::bit_util;\n+use core::fmt;\n+use std::any::Any;\n+use std::collections::HashMap;\n+use std::mem::size_of;\n+\n+/// An Array that can represent slots of varying types\n+pub struct UnionArray {\n+    data: ArrayDataRef,\n+    boxed_fields: Vec<ArrayRef>,\n+}\n+\n+impl UnionArray {\n+    /// Creates a new `UnionArray`.\n+    ///\n+    /// Accepts type ids, child arrays and optionally offsets (for dense unions) to create\n+    /// a new `UnionArray`.  This method makes no attempt to validate the data provided by the\n+    /// caller and assumes that each of the components are correct and consistent with each other.\n+    /// See `try_new` for an alternative that validates the data provided.\n+    ///\n+    /// # Data Consistency\n+    ///\n+    /// The `type_ids` `Buffer` should contain `i8` values.  These values should be greater than\n+    /// zero and must be less than the number of children provided in `child_arrays`.  These values\n+    /// are used to index into the `child_arrays`.\n+    ///\n+    /// The `value_offsets` `Buffer` is only provided in the case of a dense union, sparse unions\n+    /// should use `None`.  If provided the `value_offsets` `Buffer` should contain `i32` values.\n+    /// These values should be greater than zero and must be less than the length of the overall\n+    /// array.\n+    ///\n+    /// In both cases above we use signed integer types to maintain compatibility with other\n+    /// Arrow implementations.\n+    ///\n+    /// In both of the cases above we are accepting `Buffer`'s which are assumed to be representing\n+    /// `i8` and `i32` values respectively.  `Buffer` objects are untyped and no attempt is made\n+    /// to ensure that the data provided is valid.\n+    pub fn new(\n+        type_ids: Buffer,\n+        value_offsets: Option<Buffer>,\n+        child_arrays: Vec<(Field, ArrayRef)>,\n+        bitmap_data: Option<(Buffer, usize)>,\n+    ) -> Self {\n+        let (field_types, field_values): (Vec<_>, Vec<_>) =\n+            child_arrays.into_iter().unzip();\n+        let len = type_ids.len();\n+        let mut builder = ArrayData::builder(DataType::Union(field_types))\n+            .add_buffer(type_ids)\n+            .child_data(field_values.into_iter().map(|a| a.data()).collect())\n+            .len(len);\n+        if let Some((bitmap, null_count)) = bitmap_data {\n+            builder = builder.null_bit_buffer(bitmap).null_count(null_count);\n+        }\n+        let data = match value_offsets {\n+            Some(b) => builder.add_buffer(b).build(),\n+            None => builder.build(),\n+        };\n+        Self::from(data)\n+    }\n+    /// Attempts to create a new `UnionArray` and validates the inputs provided.\n+    pub fn try_new(\n+        type_ids: Buffer,\n+        value_offsets: Option<Buffer>,\n+        child_arrays: Vec<(Field, ArrayRef)>,\n+        bitmap: Option<Buffer>,\n+    ) -> Result<Self> {\n+        let bitmap_data = bitmap.map(|b| {\n+            let null_count = type_ids.len() - bit_util::count_set_bits(b.data());\n+            (b, null_count)\n+        });\n+\n+        if let Some(b) = &value_offsets {\n+            let nulls = match bitmap_data {\n+                Some((_, n)) => n,\n+                None => 0,\n+            };\n+            if ((type_ids.len() - nulls) * 4) != b.len() {\n+                return Err(ArrowError::InvalidArgumentError(\n+                    \"Type Ids and Offsets represent a different number of array slots.\"\n+                        .to_string(),\n+                ));\n+            }\n+        }\n+\n+        // Check the type_ids\n+        let type_id_slice: &[i8] = unsafe { type_ids.typed_data() };\n+        let invalid_type_ids = type_id_slice\n+            .iter()\n+            .filter(|i| *i < &0)\n+            .collect::<Vec<&i8>>();\n+        if invalid_type_ids.len() > 0 {\n+            return Err(ArrowError::InvalidArgumentError(format!(\n+                \"Type Ids must be positive and cannot be greater than the number of \\\n+                child arrays, found:\\n{:?}\",\n+                invalid_type_ids\n+            )));\n+        }\n+\n+        // Check the value offsets if provided\n+        if let Some(offset_buffer) = &value_offsets {\n+            let max_len = type_ids.len() as i32;\n+            let offsets_slice: &[i32] = unsafe { offset_buffer.typed_data() };\n+            let invalid_offsets = offsets_slice\n+                .iter()\n+                .filter(|i| *i < &0 || *i > &max_len)\n+                .collect::<Vec<&i32>>();\n+            if invalid_offsets.len() > 0 {\n+                return Err(ArrowError::InvalidArgumentError(format!(\n+                    \"Offsets must be positive and within the length of the Array, \\\n+                    found:\\n{:?}\",\n+                    invalid_offsets\n+                )));\n+            }\n+        }\n+\n+        Ok(Self::new(\n+            type_ids,\n+            value_offsets,\n+            child_arrays,\n+            bitmap_data,\n+        ))\n+    }\n+\n+    /// Accesses the child array for `type_id`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the `type_id` provided is less than zero or greater than the number of types\n+    /// in the `Union`.\n+    pub fn child(&self, type_id: i8) -> ArrayRef {\n+        assert!(0 <= type_id);\n+        assert!((type_id as usize) < self.boxed_fields.len());\n+        self.boxed_fields[type_id as usize].clone()\n+    }\n+\n+    /// Returns the `type_id` for the array slot at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn type_id(&self, index: usize) -> i8 {\n+        assert!(index - self.offset() < self.len());\n+        self.data().buffers()[0].data()[index] as i8\n+    }\n+\n+    /// Returns the offset into the underlying values array for the array slot at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn value_offset(&self, index: usize) -> i32 {\n+        assert!(index - self.offset() < self.len());\n+        if self.is_dense() {\n+            let valid_slots = match self.data.null_buffer() {\n+                Some(b) => bit_util::count_set_bits_offset(b.data(), 0, index),\n+                None => index,\n+            };\n+            self.data().buffers()[1].data()[valid_slots * size_of::<i32>()] as i32\n+        } else {\n+            index as i32\n+        }\n+    }\n+\n+    /// Returns the array's value at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn value(&self, index: usize) -> ArrayRef {\n+        let type_id = self.type_id(self.offset() + index);\n+        let value_offset = self.value_offset(self.offset() + index) as usize;\n+        let child_data = self.boxed_fields[type_id as usize].clone();\n+        child_data.slice(value_offset, 1)\n+    }\n+\n+    /// Returns the names of the types in the union.\n+    pub fn type_names(&self) -> Vec<&str> {\n+        match self.data.data_type() {\n+            DataType::Union(fields) => fields\n+                .iter()\n+                .map(|f| f.name().as_str())\n+                .collect::<Vec<&str>>(),\n+            _ => unreachable!(\"Union array's data type is not a union!\"),\n+        }\n+    }\n+\n+    /// Returns whether the `UnionArray` is dense (or sparse if `false`).\n+    fn is_dense(&self) -> bool {\n+        self.data().buffers().len() == 2\n+    }\n+}\n+\n+impl From<ArrayDataRef> for UnionArray {\n+    fn from(data: ArrayDataRef) -> Self {\n+        let mut boxed_fields = vec![];\n+        for cd in data.child_data() {\n+            boxed_fields.push(make_array(cd.clone()));\n+        }\n+        Self { data, boxed_fields }\n+    }\n+}\n+\n+impl Array for UnionArray {\n+    fn as_any(&self) -> &Any {\n+        self\n+    }\n+\n+    fn data(&self) -> ArrayDataRef {\n+        self.data.clone()\n+    }\n+\n+    fn data_ref(&self) -> &ArrayDataRef {\n+        &self.data\n+    }\n+}\n+\n+impl fmt::Debug for UnionArray {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let header = if self.is_dense() {\n+            \"UnionArray(Dense)\\n[\\n\"\n+        } else {\n+            \"UnionArray(Sparse)\\n[\\n\"\n+        };\n+        write!(f, \"{}\", header)?;\n+\n+        write!(f, \"-- type id buffer:\\n\")?;\n+        write!(f, \"{:?}\\n\", self.data().buffers()[0])?;\n+\n+        if self.is_dense() {\n+            write!(f, \"-- offsets buffer:\\n\")?;\n+            write!(f, \"{:?}\\n\", self.data().buffers()[1])?;\n+        }\n+\n+        for (child_index, name) in self.type_names().iter().enumerate() {\n+            let column = &self.boxed_fields[child_index];\n+            write!(\n+                f,\n+                \"-- child {}: \\\"{}\\\" ({:?})\\n\",\n+                child_index,\n+                *name,\n+                column.data_type()\n+            )?;\n+            fmt::Debug::fmt(column, f)?;\n+            write!(f, \"\\n\")?;\n+        }\n+        write!(f, \"]\")\n+    }\n+}\n+\n+/// `FieldData` is a helper struct to track the state of the fields in the `UnionBuilder`.\n+struct FieldData {\n+    /// The type id for this field\n+    type_id: i8,\n+    /// The Arrow data type represented in the `values_buffer`, which is untyped\n+    data_type: DataType,\n+    /// A buffer containing the values for this field in raw bytes\n+    values_buffer: Option<MutableBuffer>,\n+    ///  The number of array slots represented by the buffer\n+    slots: usize,\n+    /// The number of null array slots in this child array\n+    null_count: usize,\n+    /// A builder for the bitmap if required\n\nReview comment:\n       When is this required vs not?\n\n##########\nFile path: rust/arrow/src/array/union.rs\n##########\n@@ -0,0 +1,1174 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Contains the `UnionArray` and `UnionBuilder` types.\n+//!\n+//! Each slot in a `UnionArray` can have a value chosen from a number of types.  Each of the\n+//! possible types are named like the fields of a [`StructArray`](crate::array::StructArray).\n+//! A `UnionArray` can have two possible memory layouts, \"dense\" or \"sparse\".  For more information\n+//! on please see the [specification](https://arrow.apache.org/docs/format/Columnar.html#union-layout).\n+//!\n+//! Builders are provided for `UnionArray`'s involving primitive types.  `UnionArray`'s of nested\n+//! types are also supported but not via `UnionBuilder`, see the tests for examples.\n+//!\n+//! # Example: Dense Memory Layout\n+//!\n+//! ```\n+//! use arrow::array::UnionBuilder;\n+//! use arrow::datatypes::{Float64Type, Int32Type};\n+//!\n+//! # fn main() -> arrow::error::Result<()> {\n+//! let mut builder = UnionBuilder::new_dense(3);\n+//! builder.append::<Int32Type>(\"a\", 1).unwrap();\n+//! builder.append::<Float64Type>(\"b\", 3.0).unwrap();\n+//! builder.append::<Int32Type>(\"a\", 4).unwrap();\n+//! let union = builder.build().unwrap();\n+//!\n+//! assert_eq!(union.type_id(0), 0_i8);\n+//! assert_eq!(union.type_id(1), 1_i8);\n+//! assert_eq!(union.type_id(2), 0_i8);\n+//!\n+//! assert_eq!(union.value_offset(0), 0_i32);\n+//! assert_eq!(union.value_offset(1), 0_i32);\n+//! assert_eq!(union.value_offset(2), 1_i32);\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+//!\n+//! # Example: Sparse Memory Layout\n+//! ```\n+//! use arrow::array::UnionBuilder;\n+//! use arrow::datatypes::{Float64Type, Int32Type};\n+//!\n+//! # fn main() -> arrow::error::Result<()> {\n+//! let mut builder = UnionBuilder::new_sparse(3);\n+//! builder.append::<Int32Type>(\"a\", 1).unwrap();\n+//! builder.append::<Float64Type>(\"b\", 3.0).unwrap();\n+//! builder.append::<Int32Type>(\"a\", 4).unwrap();\n+//! let union = builder.build().unwrap();\n+//!\n+//! assert_eq!(union.type_id(0), 0_i8);\n+//! assert_eq!(union.type_id(1), 1_i8);\n+//! assert_eq!(union.type_id(2), 0_i8);\n+//!\n+//! assert_eq!(union.value_offset(0), 0_i32);\n+//! assert_eq!(union.value_offset(1), 1_i32);\n+//! assert_eq!(union.value_offset(2), 2_i32);\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+use crate::array::{\n+    builder::{builder_to_mutable_buffer, mutable_buffer_to_builder, BufferBuilderTrait},\n+    make_array, Array, ArrayData, ArrayDataBuilder, ArrayDataRef, ArrayRef,\n+    BooleanBufferBuilder, BufferBuilder, Int32BufferBuilder, Int8BufferBuilder,\n+};\n+use crate::buffer::{Buffer, MutableBuffer};\n+use crate::datatypes::*;\n+use crate::error::{ArrowError, Result};\n+\n+use crate::util::bit_util;\n+use core::fmt;\n+use std::any::Any;\n+use std::collections::HashMap;\n+use std::mem::size_of;\n+\n+/// An Array that can represent slots of varying types\n+pub struct UnionArray {\n+    data: ArrayDataRef,\n+    boxed_fields: Vec<ArrayRef>,\n+}\n+\n+impl UnionArray {\n+    /// Creates a new `UnionArray`.\n+    ///\n+    /// Accepts type ids, child arrays and optionally offsets (for dense unions) to create\n+    /// a new `UnionArray`.  This method makes no attempt to validate the data provided by the\n+    /// caller and assumes that each of the components are correct and consistent with each other.\n+    /// See `try_new` for an alternative that validates the data provided.\n+    ///\n+    /// # Data Consistency\n+    ///\n+    /// The `type_ids` `Buffer` should contain `i8` values.  These values should be greater than\n+    /// zero and must be less than the number of children provided in `child_arrays`.  These values\n+    /// are used to index into the `child_arrays`.\n+    ///\n+    /// The `value_offsets` `Buffer` is only provided in the case of a dense union, sparse unions\n+    /// should use `None`.  If provided the `value_offsets` `Buffer` should contain `i32` values.\n+    /// These values should be greater than zero and must be less than the length of the overall\n+    /// array.\n+    ///\n+    /// In both cases above we use signed integer types to maintain compatibility with other\n+    /// Arrow implementations.\n+    ///\n+    /// In both of the cases above we are accepting `Buffer`'s which are assumed to be representing\n+    /// `i8` and `i32` values respectively.  `Buffer` objects are untyped and no attempt is made\n+    /// to ensure that the data provided is valid.\n+    pub fn new(\n+        type_ids: Buffer,\n+        value_offsets: Option<Buffer>,\n+        child_arrays: Vec<(Field, ArrayRef)>,\n+        bitmap_data: Option<(Buffer, usize)>,\n+    ) -> Self {\n+        let (field_types, field_values): (Vec<_>, Vec<_>) =\n+            child_arrays.into_iter().unzip();\n+        let len = type_ids.len();\n+        let mut builder = ArrayData::builder(DataType::Union(field_types))\n+            .add_buffer(type_ids)\n+            .child_data(field_values.into_iter().map(|a| a.data()).collect())\n+            .len(len);\n+        if let Some((bitmap, null_count)) = bitmap_data {\n+            builder = builder.null_bit_buffer(bitmap).null_count(null_count);\n+        }\n+        let data = match value_offsets {\n+            Some(b) => builder.add_buffer(b).build(),\n+            None => builder.build(),\n+        };\n+        Self::from(data)\n+    }\n+    /// Attempts to create a new `UnionArray` and validates the inputs provided.\n+    pub fn try_new(\n+        type_ids: Buffer,\n+        value_offsets: Option<Buffer>,\n+        child_arrays: Vec<(Field, ArrayRef)>,\n+        bitmap: Option<Buffer>,\n+    ) -> Result<Self> {\n+        let bitmap_data = bitmap.map(|b| {\n+            let null_count = type_ids.len() - bit_util::count_set_bits(b.data());\n+            (b, null_count)\n+        });\n+\n+        if let Some(b) = &value_offsets {\n+            let nulls = match bitmap_data {\n+                Some((_, n)) => n,\n+                None => 0,\n+            };\n+            if ((type_ids.len() - nulls) * 4) != b.len() {\n+                return Err(ArrowError::InvalidArgumentError(\n+                    \"Type Ids and Offsets represent a different number of array slots.\"\n+                        .to_string(),\n+                ));\n+            }\n+        }\n+\n+        // Check the type_ids\n+        let type_id_slice: &[i8] = unsafe { type_ids.typed_data() };\n+        let invalid_type_ids = type_id_slice\n+            .iter()\n+            .filter(|i| *i < &0)\n+            .collect::<Vec<&i8>>();\n+        if invalid_type_ids.len() > 0 {\n+            return Err(ArrowError::InvalidArgumentError(format!(\n+                \"Type Ids must be positive and cannot be greater than the number of \\\n+                child arrays, found:\\n{:?}\",\n+                invalid_type_ids\n+            )));\n+        }\n+\n+        // Check the value offsets if provided\n+        if let Some(offset_buffer) = &value_offsets {\n+            let max_len = type_ids.len() as i32;\n+            let offsets_slice: &[i32] = unsafe { offset_buffer.typed_data() };\n+            let invalid_offsets = offsets_slice\n+                .iter()\n+                .filter(|i| *i < &0 || *i > &max_len)\n+                .collect::<Vec<&i32>>();\n+            if invalid_offsets.len() > 0 {\n+                return Err(ArrowError::InvalidArgumentError(format!(\n+                    \"Offsets must be positive and within the length of the Array, \\\n+                    found:\\n{:?}\",\n+                    invalid_offsets\n+                )));\n+            }\n+        }\n+\n+        Ok(Self::new(\n+            type_ids,\n+            value_offsets,\n+            child_arrays,\n+            bitmap_data,\n+        ))\n+    }\n+\n+    /// Accesses the child array for `type_id`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the `type_id` provided is less than zero or greater than the number of types\n+    /// in the `Union`.\n+    pub fn child(&self, type_id: i8) -> ArrayRef {\n+        assert!(0 <= type_id);\n+        assert!((type_id as usize) < self.boxed_fields.len());\n+        self.boxed_fields[type_id as usize].clone()\n+    }\n+\n+    /// Returns the `type_id` for the array slot at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn type_id(&self, index: usize) -> i8 {\n+        assert!(index - self.offset() < self.len());\n+        self.data().buffers()[0].data()[index] as i8\n+    }\n+\n+    /// Returns the offset into the underlying values array for the array slot at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn value_offset(&self, index: usize) -> i32 {\n+        assert!(index - self.offset() < self.len());\n+        if self.is_dense() {\n+            let valid_slots = match self.data.null_buffer() {\n+                Some(b) => bit_util::count_set_bits_offset(b.data(), 0, index),\n+                None => index,\n+            };\n+            self.data().buffers()[1].data()[valid_slots * size_of::<i32>()] as i32\n+        } else {\n+            index as i32\n+        }\n+    }\n+\n+    /// Returns the array's value at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn value(&self, index: usize) -> ArrayRef {\n+        let type_id = self.type_id(self.offset() + index);\n+        let value_offset = self.value_offset(self.offset() + index) as usize;\n+        let child_data = self.boxed_fields[type_id as usize].clone();\n+        child_data.slice(value_offset, 1)\n+    }\n+\n+    /// Returns the names of the types in the union.\n+    pub fn type_names(&self) -> Vec<&str> {\n+        match self.data.data_type() {\n+            DataType::Union(fields) => fields\n+                .iter()\n+                .map(|f| f.name().as_str())\n+                .collect::<Vec<&str>>(),\n+            _ => unreachable!(\"Union array's data type is not a union!\"),\n+        }\n+    }\n+\n+    /// Returns whether the `UnionArray` is dense (or sparse if `false`).\n+    fn is_dense(&self) -> bool {\n+        self.data().buffers().len() == 2\n+    }\n+}\n+\n+impl From<ArrayDataRef> for UnionArray {\n+    fn from(data: ArrayDataRef) -> Self {\n+        let mut boxed_fields = vec![];\n+        for cd in data.child_data() {\n+            boxed_fields.push(make_array(cd.clone()));\n+        }\n+        Self { data, boxed_fields }\n+    }\n+}\n+\n+impl Array for UnionArray {\n+    fn as_any(&self) -> &Any {\n+        self\n+    }\n+\n+    fn data(&self) -> ArrayDataRef {\n+        self.data.clone()\n+    }\n+\n+    fn data_ref(&self) -> &ArrayDataRef {\n+        &self.data\n+    }\n+}\n+\n+impl fmt::Debug for UnionArray {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let header = if self.is_dense() {\n+            \"UnionArray(Dense)\\n[\\n\"\n+        } else {\n+            \"UnionArray(Sparse)\\n[\\n\"\n+        };\n+        write!(f, \"{}\", header)?;\n+\n+        write!(f, \"-- type id buffer:\\n\")?;\n\nReview comment:\n       There's a recent PR that fixed some `clippy` lints, I think `writeln!(f, \"...\")` is preferable over `write!(f, \"...\\n\")`\n\n##########\nFile path: rust/arrow/src/array/union.rs\n##########\n@@ -0,0 +1,1174 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Contains the `UnionArray` and `UnionBuilder` types.\n+//!\n+//! Each slot in a `UnionArray` can have a value chosen from a number of types.  Each of the\n+//! possible types are named like the fields of a [`StructArray`](crate::array::StructArray).\n+//! A `UnionArray` can have two possible memory layouts, \"dense\" or \"sparse\".  For more information\n+//! on please see the [specification](https://arrow.apache.org/docs/format/Columnar.html#union-layout).\n+//!\n+//! Builders are provided for `UnionArray`'s involving primitive types.  `UnionArray`'s of nested\n+//! types are also supported but not via `UnionBuilder`, see the tests for examples.\n+//!\n+//! # Example: Dense Memory Layout\n+//!\n+//! ```\n+//! use arrow::array::UnionBuilder;\n+//! use arrow::datatypes::{Float64Type, Int32Type};\n+//!\n+//! # fn main() -> arrow::error::Result<()> {\n+//! let mut builder = UnionBuilder::new_dense(3);\n+//! builder.append::<Int32Type>(\"a\", 1).unwrap();\n+//! builder.append::<Float64Type>(\"b\", 3.0).unwrap();\n+//! builder.append::<Int32Type>(\"a\", 4).unwrap();\n+//! let union = builder.build().unwrap();\n+//!\n+//! assert_eq!(union.type_id(0), 0_i8);\n+//! assert_eq!(union.type_id(1), 1_i8);\n+//! assert_eq!(union.type_id(2), 0_i8);\n+//!\n+//! assert_eq!(union.value_offset(0), 0_i32);\n+//! assert_eq!(union.value_offset(1), 0_i32);\n+//! assert_eq!(union.value_offset(2), 1_i32);\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+//!\n+//! # Example: Sparse Memory Layout\n+//! ```\n+//! use arrow::array::UnionBuilder;\n+//! use arrow::datatypes::{Float64Type, Int32Type};\n+//!\n+//! # fn main() -> arrow::error::Result<()> {\n+//! let mut builder = UnionBuilder::new_sparse(3);\n+//! builder.append::<Int32Type>(\"a\", 1).unwrap();\n+//! builder.append::<Float64Type>(\"b\", 3.0).unwrap();\n+//! builder.append::<Int32Type>(\"a\", 4).unwrap();\n+//! let union = builder.build().unwrap();\n+//!\n+//! assert_eq!(union.type_id(0), 0_i8);\n+//! assert_eq!(union.type_id(1), 1_i8);\n+//! assert_eq!(union.type_id(2), 0_i8);\n+//!\n+//! assert_eq!(union.value_offset(0), 0_i32);\n+//! assert_eq!(union.value_offset(1), 1_i32);\n+//! assert_eq!(union.value_offset(2), 2_i32);\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+use crate::array::{\n+    builder::{builder_to_mutable_buffer, mutable_buffer_to_builder, BufferBuilderTrait},\n+    make_array, Array, ArrayData, ArrayDataBuilder, ArrayDataRef, ArrayRef,\n+    BooleanBufferBuilder, BufferBuilder, Int32BufferBuilder, Int8BufferBuilder,\n+};\n+use crate::buffer::{Buffer, MutableBuffer};\n+use crate::datatypes::*;\n+use crate::error::{ArrowError, Result};\n+\n+use crate::util::bit_util;\n+use core::fmt;\n+use std::any::Any;\n+use std::collections::HashMap;\n+use std::mem::size_of;\n+\n+/// An Array that can represent slots of varying types\n+pub struct UnionArray {\n+    data: ArrayDataRef,\n+    boxed_fields: Vec<ArrayRef>,\n+}\n+\n+impl UnionArray {\n+    /// Creates a new `UnionArray`.\n+    ///\n+    /// Accepts type ids, child arrays and optionally offsets (for dense unions) to create\n+    /// a new `UnionArray`.  This method makes no attempt to validate the data provided by the\n+    /// caller and assumes that each of the components are correct and consistent with each other.\n+    /// See `try_new` for an alternative that validates the data provided.\n+    ///\n+    /// # Data Consistency\n+    ///\n+    /// The `type_ids` `Buffer` should contain `i8` values.  These values should be greater than\n+    /// zero and must be less than the number of children provided in `child_arrays`.  These values\n+    /// are used to index into the `child_arrays`.\n+    ///\n+    /// The `value_offsets` `Buffer` is only provided in the case of a dense union, sparse unions\n+    /// should use `None`.  If provided the `value_offsets` `Buffer` should contain `i32` values.\n+    /// These values should be greater than zero and must be less than the length of the overall\n+    /// array.\n+    ///\n+    /// In both cases above we use signed integer types to maintain compatibility with other\n+    /// Arrow implementations.\n+    ///\n+    /// In both of the cases above we are accepting `Buffer`'s which are assumed to be representing\n+    /// `i8` and `i32` values respectively.  `Buffer` objects are untyped and no attempt is made\n+    /// to ensure that the data provided is valid.\n+    pub fn new(\n+        type_ids: Buffer,\n+        value_offsets: Option<Buffer>,\n+        child_arrays: Vec<(Field, ArrayRef)>,\n+        bitmap_data: Option<(Buffer, usize)>,\n+    ) -> Self {\n+        let (field_types, field_values): (Vec<_>, Vec<_>) =\n+            child_arrays.into_iter().unzip();\n+        let len = type_ids.len();\n+        let mut builder = ArrayData::builder(DataType::Union(field_types))\n+            .add_buffer(type_ids)\n+            .child_data(field_values.into_iter().map(|a| a.data()).collect())\n+            .len(len);\n+        if let Some((bitmap, null_count)) = bitmap_data {\n+            builder = builder.null_bit_buffer(bitmap).null_count(null_count);\n+        }\n+        let data = match value_offsets {\n+            Some(b) => builder.add_buffer(b).build(),\n+            None => builder.build(),\n+        };\n+        Self::from(data)\n+    }\n+    /// Attempts to create a new `UnionArray` and validates the inputs provided.\n+    pub fn try_new(\n+        type_ids: Buffer,\n+        value_offsets: Option<Buffer>,\n+        child_arrays: Vec<(Field, ArrayRef)>,\n+        bitmap: Option<Buffer>,\n+    ) -> Result<Self> {\n+        let bitmap_data = bitmap.map(|b| {\n+            let null_count = type_ids.len() - bit_util::count_set_bits(b.data());\n+            (b, null_count)\n+        });\n+\n+        if let Some(b) = &value_offsets {\n+            let nulls = match bitmap_data {\n+                Some((_, n)) => n,\n+                None => 0,\n+            };\n+            if ((type_ids.len() - nulls) * 4) != b.len() {\n+                return Err(ArrowError::InvalidArgumentError(\n+                    \"Type Ids and Offsets represent a different number of array slots.\"\n+                        .to_string(),\n+                ));\n+            }\n+        }\n+\n+        // Check the type_ids\n+        let type_id_slice: &[i8] = unsafe { type_ids.typed_data() };\n+        let invalid_type_ids = type_id_slice\n+            .iter()\n+            .filter(|i| *i < &0)\n+            .collect::<Vec<&i8>>();\n+        if invalid_type_ids.len() > 0 {\n+            return Err(ArrowError::InvalidArgumentError(format!(\n+                \"Type Ids must be positive and cannot be greater than the number of \\\n+                child arrays, found:\\n{:?}\",\n+                invalid_type_ids\n+            )));\n+        }\n+\n+        // Check the value offsets if provided\n+        if let Some(offset_buffer) = &value_offsets {\n+            let max_len = type_ids.len() as i32;\n+            let offsets_slice: &[i32] = unsafe { offset_buffer.typed_data() };\n+            let invalid_offsets = offsets_slice\n+                .iter()\n+                .filter(|i| *i < &0 || *i > &max_len)\n+                .collect::<Vec<&i32>>();\n+            if invalid_offsets.len() > 0 {\n+                return Err(ArrowError::InvalidArgumentError(format!(\n+                    \"Offsets must be positive and within the length of the Array, \\\n+                    found:\\n{:?}\",\n+                    invalid_offsets\n+                )));\n+            }\n+        }\n+\n+        Ok(Self::new(\n+            type_ids,\n+            value_offsets,\n+            child_arrays,\n+            bitmap_data,\n+        ))\n+    }\n+\n+    /// Accesses the child array for `type_id`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the `type_id` provided is less than zero or greater than the number of types\n+    /// in the `Union`.\n+    pub fn child(&self, type_id: i8) -> ArrayRef {\n+        assert!(0 <= type_id);\n+        assert!((type_id as usize) < self.boxed_fields.len());\n+        self.boxed_fields[type_id as usize].clone()\n+    }\n+\n+    /// Returns the `type_id` for the array slot at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn type_id(&self, index: usize) -> i8 {\n+        assert!(index - self.offset() < self.len());\n+        self.data().buffers()[0].data()[index] as i8\n+    }\n+\n+    /// Returns the offset into the underlying values array for the array slot at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn value_offset(&self, index: usize) -> i32 {\n+        assert!(index - self.offset() < self.len());\n+        if self.is_dense() {\n+            let valid_slots = match self.data.null_buffer() {\n+                Some(b) => bit_util::count_set_bits_offset(b.data(), 0, index),\n+                None => index,\n+            };\n+            self.data().buffers()[1].data()[valid_slots * size_of::<i32>()] as i32\n+        } else {\n+            index as i32\n+        }\n+    }\n+\n+    /// Returns the array's value at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn value(&self, index: usize) -> ArrayRef {\n+        let type_id = self.type_id(self.offset() + index);\n+        let value_offset = self.value_offset(self.offset() + index) as usize;\n+        let child_data = self.boxed_fields[type_id as usize].clone();\n+        child_data.slice(value_offset, 1)\n+    }\n+\n+    /// Returns the names of the types in the union.\n+    pub fn type_names(&self) -> Vec<&str> {\n+        match self.data.data_type() {\n+            DataType::Union(fields) => fields\n+                .iter()\n+                .map(|f| f.name().as_str())\n+                .collect::<Vec<&str>>(),\n+            _ => unreachable!(\"Union array's data type is not a union!\"),\n+        }\n+    }\n+\n+    /// Returns whether the `UnionArray` is dense (or sparse if `false`).\n+    fn is_dense(&self) -> bool {\n+        self.data().buffers().len() == 2\n+    }\n+}\n+\n+impl From<ArrayDataRef> for UnionArray {\n+    fn from(data: ArrayDataRef) -> Self {\n+        let mut boxed_fields = vec![];\n+        for cd in data.child_data() {\n+            boxed_fields.push(make_array(cd.clone()));\n+        }\n+        Self { data, boxed_fields }\n+    }\n+}\n+\n+impl Array for UnionArray {\n+    fn as_any(&self) -> &Any {\n+        self\n+    }\n+\n+    fn data(&self) -> ArrayDataRef {\n+        self.data.clone()\n+    }\n+\n+    fn data_ref(&self) -> &ArrayDataRef {\n+        &self.data\n+    }\n+}\n+\n+impl fmt::Debug for UnionArray {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let header = if self.is_dense() {\n+            \"UnionArray(Dense)\\n[\\n\"\n+        } else {\n+            \"UnionArray(Sparse)\\n[\\n\"\n+        };\n+        write!(f, \"{}\", header)?;\n+\n+        write!(f, \"-- type id buffer:\\n\")?;\n+        write!(f, \"{:?}\\n\", self.data().buffers()[0])?;\n+\n+        if self.is_dense() {\n+            write!(f, \"-- offsets buffer:\\n\")?;\n+            write!(f, \"{:?}\\n\", self.data().buffers()[1])?;\n+        }\n+\n+        for (child_index, name) in self.type_names().iter().enumerate() {\n+            let column = &self.boxed_fields[child_index];\n+            write!(\n+                f,\n+                \"-- child {}: \\\"{}\\\" ({:?})\\n\",\n+                child_index,\n+                *name,\n+                column.data_type()\n+            )?;\n+            fmt::Debug::fmt(column, f)?;\n+            write!(f, \"\\n\")?;\n+        }\n+        write!(f, \"]\")\n+    }\n+}\n+\n+/// `FieldData` is a helper struct to track the state of the fields in the `UnionBuilder`.\n+struct FieldData {\n+    /// The type id for this field\n+    type_id: i8,\n+    /// The Arrow data type represented in the `values_buffer`, which is untyped\n+    data_type: DataType,\n+    /// A buffer containing the values for this field in raw bytes\n+    values_buffer: Option<MutableBuffer>,\n+    ///  The number of array slots represented by the buffer\n+    slots: usize,\n+    /// The number of null array slots in this child array\n+    null_count: usize,\n+    /// A builder for the bitmap if required\n+    bitmap_builder: Option<BooleanBufferBuilder>,\n+}\n+\n+impl FieldData {\n+    /// Creates a new `FieldData`.\n+    fn new(\n+        type_id: i8,\n+        data_type: DataType,\n+        bitmap_builder: Option<BooleanBufferBuilder>,\n+    ) -> Self {\n+        Self {\n+            type_id,\n+            data_type,\n+            // TODO: Should `MutableBuffer` implement `Default`?\n+            values_buffer: Some(MutableBuffer::new(1)),\n+            slots: 0,\n+            null_count: 0,\n+            bitmap_builder,\n+        }\n+    }\n+\n+    /// Appends a single value to this `FieldData`'s `values_buffer`.\n+    fn append_to_values_buffer<T: ArrowPrimitiveType>(\n+        &mut self,\n+        v: T::Native,\n+    ) -> Result<()> {\n+        let values_buffer = self\n+            .values_buffer\n+            .take()\n+            .expect(\"Values buffer was never created\");\n+        let mut builder: BufferBuilder<T> =\n+            mutable_buffer_to_builder(values_buffer, self.slots);\n+        builder.append(v)?;\n+        let mutable_buffer = builder_to_mutable_buffer(builder);\n+        self.values_buffer = Some(mutable_buffer);\n+\n+        self.slots += 1;\n+        if let Some(b) = &mut self.bitmap_builder {\n+            b.append(true)?\n+        };\n+        Ok(())\n+    }\n+\n+    /// Appends a null to this `FieldData`.\n+    fn append_null<T: ArrowPrimitiveType>(&mut self) -> Result<()> {\n+        if let Some(b) = &mut self.bitmap_builder {\n+            let values_buffer = self\n+                .values_buffer\n+                .take()\n+                .expect(\"Values buffer was never created\");\n+            let mut builder: BufferBuilder<T> =\n+                mutable_buffer_to_builder(values_buffer, self.slots);\n+            builder.advance(1)?;\n+            let mutable_buffer = builder_to_mutable_buffer(builder);\n+            self.values_buffer = Some(mutable_buffer);\n+            self.slots += 1;\n+            b.append(false)?;\n+        };\n+        Ok(())\n+    }\n+\n+    /// Appends a null to this `FieldData` when the type is not known at compile time.\n+    ///\n+    /// As the main `append` method of `UnionBuilder` is generic, we need a way to append null\n+    /// slots to the fields that are not being appended to in the case of sparse unions.  This\n+    /// method solves this problem by appending dynamically based on `DataType`.\n+    ///\n+    /// Note, this method does **not** update the length of the `UnionArray` (this is done by the\n+    /// main append operation) and assumes that it is called from a method that is generic over `T`\n+    /// where `T` satisfies the bound `ArrowPrimitiveType`.\n+    fn append_null_dynamic(&mut self) -> Result<()> {\n+        match self.data_type {\n+            DataType::Boolean => self.append_null::<BooleanType>()?,\n+            DataType::Int8 => self.append_null::<Int8Type>()?,\n+            DataType::Int16 => self.append_null::<Int16Type>()?,\n+            DataType::Int32\n+            | DataType::Date32(_)\n+            | DataType::Time32(_)\n+            | DataType::Interval(IntervalUnit::YearMonth) => {\n+                self.append_null::<Int32Type>()?\n+            }\n+            DataType::Int64\n+            | DataType::Timestamp(_, _)\n+            | DataType::Date64(_)\n+            | DataType::Time64(_)\n+            | DataType::Interval(IntervalUnit::DayTime)\n+            | DataType::Duration(_) => self.append_null::<Int64Type>()?,\n+            DataType::UInt8 => self.append_null::<UInt8Type>()?,\n+            DataType::UInt16 => self.append_null::<UInt16Type>()?,\n+            DataType::UInt32 => self.append_null::<UInt32Type>()?,\n+            DataType::UInt64 => self.append_null::<UInt64Type>()?,\n+            DataType::Float32 => self.append_null::<Float32Type>()?,\n+            DataType::Float64 => self.append_null::<Float64Type>()?,\n+            _ => unreachable!(\"All cases of types that satisfy the trait bounds over T are covered above.\"),\n+        };\n+        Ok(())\n+    }\n+}\n+\n+/// Builder type for creating a new `UnionArray`.\n+pub struct UnionBuilder {\n+    /// The current number of slots in the array\n+    len: usize,\n+    /// Maps field names to `FieldData` instances which track the builders for that field\n+    fields: HashMap<String, FieldData>,\n+    /// Builder to keep track of type ids\n+    type_id_builder: Int8BufferBuilder,\n+    /// Builder to keep track of offsets (`None` for sparse unions)\n+    value_offset_builder: Option<Int32BufferBuilder>,\n+    /// Optional builder for null slots\n+    bitmap_builder: Option<BooleanBufferBuilder>,\n+}\n+\n+impl UnionBuilder {\n+    /// Creates a new dense array builder.\n+    pub fn new_dense(capacity: usize) -> Self {\n+        Self {\n+            len: 0,\n+            fields: HashMap::default(),\n+            type_id_builder: Int8BufferBuilder::new(capacity),\n+            value_offset_builder: Some(Int32BufferBuilder::new(capacity)),\n+            bitmap_builder: None,\n+        }\n+    }\n+\n+    /// Creates a new sparse array builder.\n+    pub fn new_sparse(capacity: usize) -> Self {\n+        Self {\n+            len: 0,\n+            fields: HashMap::default(),\n+            type_id_builder: Int8BufferBuilder::new(capacity),\n+            value_offset_builder: None,\n+            bitmap_builder: None,\n+        }\n+    }\n+\n+    /// Appends a null to this builder.\n+    pub fn append_null(&mut self) -> Result<()> {\n+        if let None = self.bitmap_builder {\n\nReview comment:\n       Are you only creating the `bitmap_builder` when inserting the first null, for performance reasons?\n\n##########\nFile path: rust/arrow/src/array/union.rs\n##########\n@@ -0,0 +1,1174 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Contains the `UnionArray` and `UnionBuilder` types.\n+//!\n+//! Each slot in a `UnionArray` can have a value chosen from a number of types.  Each of the\n+//! possible types are named like the fields of a [`StructArray`](crate::array::StructArray).\n+//! A `UnionArray` can have two possible memory layouts, \"dense\" or \"sparse\".  For more information\n+//! on please see the [specification](https://arrow.apache.org/docs/format/Columnar.html#union-layout).\n+//!\n+//! Builders are provided for `UnionArray`'s involving primitive types.  `UnionArray`'s of nested\n+//! types are also supported but not via `UnionBuilder`, see the tests for examples.\n+//!\n+//! # Example: Dense Memory Layout\n+//!\n+//! ```\n+//! use arrow::array::UnionBuilder;\n+//! use arrow::datatypes::{Float64Type, Int32Type};\n+//!\n+//! # fn main() -> arrow::error::Result<()> {\n+//! let mut builder = UnionBuilder::new_dense(3);\n+//! builder.append::<Int32Type>(\"a\", 1).unwrap();\n+//! builder.append::<Float64Type>(\"b\", 3.0).unwrap();\n+//! builder.append::<Int32Type>(\"a\", 4).unwrap();\n+//! let union = builder.build().unwrap();\n+//!\n+//! assert_eq!(union.type_id(0), 0_i8);\n+//! assert_eq!(union.type_id(1), 1_i8);\n+//! assert_eq!(union.type_id(2), 0_i8);\n+//!\n+//! assert_eq!(union.value_offset(0), 0_i32);\n+//! assert_eq!(union.value_offset(1), 0_i32);\n+//! assert_eq!(union.value_offset(2), 1_i32);\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+//!\n+//! # Example: Sparse Memory Layout\n+//! ```\n+//! use arrow::array::UnionBuilder;\n+//! use arrow::datatypes::{Float64Type, Int32Type};\n+//!\n+//! # fn main() -> arrow::error::Result<()> {\n+//! let mut builder = UnionBuilder::new_sparse(3);\n+//! builder.append::<Int32Type>(\"a\", 1).unwrap();\n+//! builder.append::<Float64Type>(\"b\", 3.0).unwrap();\n+//! builder.append::<Int32Type>(\"a\", 4).unwrap();\n+//! let union = builder.build().unwrap();\n+//!\n+//! assert_eq!(union.type_id(0), 0_i8);\n+//! assert_eq!(union.type_id(1), 1_i8);\n+//! assert_eq!(union.type_id(2), 0_i8);\n+//!\n+//! assert_eq!(union.value_offset(0), 0_i32);\n+//! assert_eq!(union.value_offset(1), 1_i32);\n+//! assert_eq!(union.value_offset(2), 2_i32);\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+use crate::array::{\n+    builder::{builder_to_mutable_buffer, mutable_buffer_to_builder, BufferBuilderTrait},\n+    make_array, Array, ArrayData, ArrayDataBuilder, ArrayDataRef, ArrayRef,\n+    BooleanBufferBuilder, BufferBuilder, Int32BufferBuilder, Int8BufferBuilder,\n+};\n+use crate::buffer::{Buffer, MutableBuffer};\n+use crate::datatypes::*;\n+use crate::error::{ArrowError, Result};\n+\n+use crate::util::bit_util;\n+use core::fmt;\n+use std::any::Any;\n+use std::collections::HashMap;\n+use std::mem::size_of;\n+\n+/// An Array that can represent slots of varying types\n+pub struct UnionArray {\n+    data: ArrayDataRef,\n+    boxed_fields: Vec<ArrayRef>,\n+}\n+\n+impl UnionArray {\n+    /// Creates a new `UnionArray`.\n+    ///\n+    /// Accepts type ids, child arrays and optionally offsets (for dense unions) to create\n+    /// a new `UnionArray`.  This method makes no attempt to validate the data provided by the\n+    /// caller and assumes that each of the components are correct and consistent with each other.\n+    /// See `try_new` for an alternative that validates the data provided.\n+    ///\n+    /// # Data Consistency\n+    ///\n+    /// The `type_ids` `Buffer` should contain `i8` values.  These values should be greater than\n+    /// zero and must be less than the number of children provided in `child_arrays`.  These values\n+    /// are used to index into the `child_arrays`.\n+    ///\n+    /// The `value_offsets` `Buffer` is only provided in the case of a dense union, sparse unions\n+    /// should use `None`.  If provided the `value_offsets` `Buffer` should contain `i32` values.\n+    /// These values should be greater than zero and must be less than the length of the overall\n+    /// array.\n+    ///\n+    /// In both cases above we use signed integer types to maintain compatibility with other\n+    /// Arrow implementations.\n+    ///\n+    /// In both of the cases above we are accepting `Buffer`'s which are assumed to be representing\n+    /// `i8` and `i32` values respectively.  `Buffer` objects are untyped and no attempt is made\n+    /// to ensure that the data provided is valid.\n+    pub fn new(\n+        type_ids: Buffer,\n+        value_offsets: Option<Buffer>,\n+        child_arrays: Vec<(Field, ArrayRef)>,\n+        bitmap_data: Option<(Buffer, usize)>,\n+    ) -> Self {\n+        let (field_types, field_values): (Vec<_>, Vec<_>) =\n+            child_arrays.into_iter().unzip();\n+        let len = type_ids.len();\n+        let mut builder = ArrayData::builder(DataType::Union(field_types))\n+            .add_buffer(type_ids)\n+            .child_data(field_values.into_iter().map(|a| a.data()).collect())\n+            .len(len);\n+        if let Some((bitmap, null_count)) = bitmap_data {\n+            builder = builder.null_bit_buffer(bitmap).null_count(null_count);\n+        }\n+        let data = match value_offsets {\n+            Some(b) => builder.add_buffer(b).build(),\n+            None => builder.build(),\n+        };\n+        Self::from(data)\n+    }\n+    /// Attempts to create a new `UnionArray` and validates the inputs provided.\n+    pub fn try_new(\n+        type_ids: Buffer,\n+        value_offsets: Option<Buffer>,\n+        child_arrays: Vec<(Field, ArrayRef)>,\n+        bitmap: Option<Buffer>,\n+    ) -> Result<Self> {\n+        let bitmap_data = bitmap.map(|b| {\n+            let null_count = type_ids.len() - bit_util::count_set_bits(b.data());\n+            (b, null_count)\n+        });\n+\n+        if let Some(b) = &value_offsets {\n+            let nulls = match bitmap_data {\n+                Some((_, n)) => n,\n+                None => 0,\n+            };\n+            if ((type_ids.len() - nulls) * 4) != b.len() {\n+                return Err(ArrowError::InvalidArgumentError(\n+                    \"Type Ids and Offsets represent a different number of array slots.\"\n+                        .to_string(),\n+                ));\n+            }\n+        }\n+\n+        // Check the type_ids\n+        let type_id_slice: &[i8] = unsafe { type_ids.typed_data() };\n+        let invalid_type_ids = type_id_slice\n+            .iter()\n+            .filter(|i| *i < &0)\n+            .collect::<Vec<&i8>>();\n+        if invalid_type_ids.len() > 0 {\n+            return Err(ArrowError::InvalidArgumentError(format!(\n+                \"Type Ids must be positive and cannot be greater than the number of \\\n+                child arrays, found:\\n{:?}\",\n+                invalid_type_ids\n+            )));\n+        }\n+\n+        // Check the value offsets if provided\n+        if let Some(offset_buffer) = &value_offsets {\n+            let max_len = type_ids.len() as i32;\n+            let offsets_slice: &[i32] = unsafe { offset_buffer.typed_data() };\n+            let invalid_offsets = offsets_slice\n+                .iter()\n+                .filter(|i| *i < &0 || *i > &max_len)\n+                .collect::<Vec<&i32>>();\n+            if invalid_offsets.len() > 0 {\n+                return Err(ArrowError::InvalidArgumentError(format!(\n+                    \"Offsets must be positive and within the length of the Array, \\\n+                    found:\\n{:?}\",\n+                    invalid_offsets\n+                )));\n+            }\n+        }\n+\n+        Ok(Self::new(\n+            type_ids,\n+            value_offsets,\n+            child_arrays,\n+            bitmap_data,\n+        ))\n+    }\n+\n+    /// Accesses the child array for `type_id`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the `type_id` provided is less than zero or greater than the number of types\n+    /// in the `Union`.\n+    pub fn child(&self, type_id: i8) -> ArrayRef {\n+        assert!(0 <= type_id);\n+        assert!((type_id as usize) < self.boxed_fields.len());\n+        self.boxed_fields[type_id as usize].clone()\n+    }\n+\n+    /// Returns the `type_id` for the array slot at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn type_id(&self, index: usize) -> i8 {\n+        assert!(index - self.offset() < self.len());\n+        self.data().buffers()[0].data()[index] as i8\n+    }\n+\n+    /// Returns the offset into the underlying values array for the array slot at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn value_offset(&self, index: usize) -> i32 {\n+        assert!(index - self.offset() < self.len());\n+        if self.is_dense() {\n+            let valid_slots = match self.data.null_buffer() {\n+                Some(b) => bit_util::count_set_bits_offset(b.data(), 0, index),\n+                None => index,\n+            };\n+            self.data().buffers()[1].data()[valid_slots * size_of::<i32>()] as i32\n+        } else {\n+            index as i32\n+        }\n+    }\n+\n+    /// Returns the array's value at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn value(&self, index: usize) -> ArrayRef {\n+        let type_id = self.type_id(self.offset() + index);\n+        let value_offset = self.value_offset(self.offset() + index) as usize;\n+        let child_data = self.boxed_fields[type_id as usize].clone();\n+        child_data.slice(value_offset, 1)\n+    }\n+\n+    /// Returns the names of the types in the union.\n+    pub fn type_names(&self) -> Vec<&str> {\n+        match self.data.data_type() {\n+            DataType::Union(fields) => fields\n+                .iter()\n+                .map(|f| f.name().as_str())\n+                .collect::<Vec<&str>>(),\n+            _ => unreachable!(\"Union array's data type is not a union!\"),\n+        }\n+    }\n+\n+    /// Returns whether the `UnionArray` is dense (or sparse if `false`).\n+    fn is_dense(&self) -> bool {\n+        self.data().buffers().len() == 2\n+    }\n+}\n+\n+impl From<ArrayDataRef> for UnionArray {\n+    fn from(data: ArrayDataRef) -> Self {\n+        let mut boxed_fields = vec![];\n+        for cd in data.child_data() {\n+            boxed_fields.push(make_array(cd.clone()));\n+        }\n+        Self { data, boxed_fields }\n+    }\n+}\n+\n+impl Array for UnionArray {\n+    fn as_any(&self) -> &Any {\n+        self\n+    }\n+\n+    fn data(&self) -> ArrayDataRef {\n+        self.data.clone()\n+    }\n+\n+    fn data_ref(&self) -> &ArrayDataRef {\n+        &self.data\n+    }\n+}\n+\n+impl fmt::Debug for UnionArray {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let header = if self.is_dense() {\n+            \"UnionArray(Dense)\\n[\\n\"\n+        } else {\n+            \"UnionArray(Sparse)\\n[\\n\"\n+        };\n+        write!(f, \"{}\", header)?;\n+\n+        write!(f, \"-- type id buffer:\\n\")?;\n+        write!(f, \"{:?}\\n\", self.data().buffers()[0])?;\n+\n+        if self.is_dense() {\n+            write!(f, \"-- offsets buffer:\\n\")?;\n+            write!(f, \"{:?}\\n\", self.data().buffers()[1])?;\n+        }\n+\n+        for (child_index, name) in self.type_names().iter().enumerate() {\n+            let column = &self.boxed_fields[child_index];\n+            write!(\n+                f,\n+                \"-- child {}: \\\"{}\\\" ({:?})\\n\",\n+                child_index,\n+                *name,\n+                column.data_type()\n+            )?;\n+            fmt::Debug::fmt(column, f)?;\n+            write!(f, \"\\n\")?;\n+        }\n+        write!(f, \"]\")\n+    }\n+}\n+\n+/// `FieldData` is a helper struct to track the state of the fields in the `UnionBuilder`.\n+struct FieldData {\n+    /// The type id for this field\n+    type_id: i8,\n+    /// The Arrow data type represented in the `values_buffer`, which is untyped\n+    data_type: DataType,\n+    /// A buffer containing the values for this field in raw bytes\n+    values_buffer: Option<MutableBuffer>,\n+    ///  The number of array slots represented by the buffer\n+    slots: usize,\n+    /// The number of null array slots in this child array\n+    null_count: usize,\n+    /// A builder for the bitmap if required\n+    bitmap_builder: Option<BooleanBufferBuilder>,\n+}\n+\n+impl FieldData {\n+    /// Creates a new `FieldData`.\n+    fn new(\n+        type_id: i8,\n+        data_type: DataType,\n+        bitmap_builder: Option<BooleanBufferBuilder>,\n+    ) -> Self {\n+        Self {\n+            type_id,\n+            data_type,\n+            // TODO: Should `MutableBuffer` implement `Default`?\n+            values_buffer: Some(MutableBuffer::new(1)),\n+            slots: 0,\n+            null_count: 0,\n+            bitmap_builder,\n+        }\n+    }\n+\n+    /// Appends a single value to this `FieldData`'s `values_buffer`.\n+    fn append_to_values_buffer<T: ArrowPrimitiveType>(\n+        &mut self,\n+        v: T::Native,\n+    ) -> Result<()> {\n+        let values_buffer = self\n+            .values_buffer\n+            .take()\n+            .expect(\"Values buffer was never created\");\n+        let mut builder: BufferBuilder<T> =\n+            mutable_buffer_to_builder(values_buffer, self.slots);\n+        builder.append(v)?;\n+        let mutable_buffer = builder_to_mutable_buffer(builder);\n+        self.values_buffer = Some(mutable_buffer);\n+\n+        self.slots += 1;\n+        if let Some(b) = &mut self.bitmap_builder {\n+            b.append(true)?\n+        };\n+        Ok(())\n+    }\n+\n+    /// Appends a null to this `FieldData`.\n+    fn append_null<T: ArrowPrimitiveType>(&mut self) -> Result<()> {\n+        if let Some(b) = &mut self.bitmap_builder {\n+            let values_buffer = self\n+                .values_buffer\n+                .take()\n+                .expect(\"Values buffer was never created\");\n+            let mut builder: BufferBuilder<T> =\n+                mutable_buffer_to_builder(values_buffer, self.slots);\n+            builder.advance(1)?;\n+            let mutable_buffer = builder_to_mutable_buffer(builder);\n+            self.values_buffer = Some(mutable_buffer);\n+            self.slots += 1;\n\nReview comment:\n       Do we increment `self.slots` or `self.null_count` when appending null?\n\n##########\nFile path: rust/arrow/src/buffer.rs\n##########\n@@ -568,6 +568,25 @@ impl MutableBuffer {\n     }\n }\n \n+impl MutableBuffer {\n\nReview comment:\n       nit: why not add this to the `impl MutableBuffer` from L411?\n\n##########\nFile path: rust/arrow/src/buffer.rs\n##########\n@@ -568,6 +568,25 @@ impl MutableBuffer {\n     }\n }\n \n+impl MutableBuffer {\n+    /// Writes a byte slice to the underlying buffer and updates the `len`, i.e. the\n+    /// number array elements in the builder.  Also, converts the `io::Result`\n+    /// required by the `Write` trait to the Arrow `Result` type.\n+    pub fn write_bytes(&mut self, bytes: &[u8], len_added: usize) -> Result<()> {\n+        let write_result = self.write(bytes);\n+        // `io::Result` has many options one of which we use, so pattern matching is\n+        // overkill here\n+        if write_result.is_err() {\n+            Err(ArrowError::MemoryError(\n\nReview comment:\n       We have an `ArrowError::IoError`, or do you prefer `MemoryError` here?\n\n##########\nFile path: rust/arrow/src/array/union.rs\n##########\n@@ -0,0 +1,1174 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Contains the `UnionArray` and `UnionBuilder` types.\n+//!\n+//! Each slot in a `UnionArray` can have a value chosen from a number of types.  Each of the\n+//! possible types are named like the fields of a [`StructArray`](crate::array::StructArray).\n+//! A `UnionArray` can have two possible memory layouts, \"dense\" or \"sparse\".  For more information\n+//! on please see the [specification](https://arrow.apache.org/docs/format/Columnar.html#union-layout).\n+//!\n+//! Builders are provided for `UnionArray`'s involving primitive types.  `UnionArray`'s of nested\n+//! types are also supported but not via `UnionBuilder`, see the tests for examples.\n+//!\n+//! # Example: Dense Memory Layout\n+//!\n+//! ```\n+//! use arrow::array::UnionBuilder;\n+//! use arrow::datatypes::{Float64Type, Int32Type};\n+//!\n+//! # fn main() -> arrow::error::Result<()> {\n+//! let mut builder = UnionBuilder::new_dense(3);\n+//! builder.append::<Int32Type>(\"a\", 1).unwrap();\n+//! builder.append::<Float64Type>(\"b\", 3.0).unwrap();\n+//! builder.append::<Int32Type>(\"a\", 4).unwrap();\n+//! let union = builder.build().unwrap();\n+//!\n+//! assert_eq!(union.type_id(0), 0_i8);\n+//! assert_eq!(union.type_id(1), 1_i8);\n+//! assert_eq!(union.type_id(2), 0_i8);\n+//!\n+//! assert_eq!(union.value_offset(0), 0_i32);\n+//! assert_eq!(union.value_offset(1), 0_i32);\n+//! assert_eq!(union.value_offset(2), 1_i32);\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+//!\n+//! # Example: Sparse Memory Layout\n+//! ```\n+//! use arrow::array::UnionBuilder;\n+//! use arrow::datatypes::{Float64Type, Int32Type};\n+//!\n+//! # fn main() -> arrow::error::Result<()> {\n+//! let mut builder = UnionBuilder::new_sparse(3);\n+//! builder.append::<Int32Type>(\"a\", 1).unwrap();\n+//! builder.append::<Float64Type>(\"b\", 3.0).unwrap();\n+//! builder.append::<Int32Type>(\"a\", 4).unwrap();\n+//! let union = builder.build().unwrap();\n+//!\n+//! assert_eq!(union.type_id(0), 0_i8);\n+//! assert_eq!(union.type_id(1), 1_i8);\n+//! assert_eq!(union.type_id(2), 0_i8);\n+//!\n+//! assert_eq!(union.value_offset(0), 0_i32);\n+//! assert_eq!(union.value_offset(1), 1_i32);\n+//! assert_eq!(union.value_offset(2), 2_i32);\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+use crate::array::{\n+    builder::{builder_to_mutable_buffer, mutable_buffer_to_builder, BufferBuilderTrait},\n+    make_array, Array, ArrayData, ArrayDataBuilder, ArrayDataRef, ArrayRef,\n+    BooleanBufferBuilder, BufferBuilder, Int32BufferBuilder, Int8BufferBuilder,\n+};\n+use crate::buffer::{Buffer, MutableBuffer};\n+use crate::datatypes::*;\n+use crate::error::{ArrowError, Result};\n+\n+use crate::util::bit_util;\n+use core::fmt;\n+use std::any::Any;\n+use std::collections::HashMap;\n+use std::mem::size_of;\n+\n+/// An Array that can represent slots of varying types\n+pub struct UnionArray {\n+    data: ArrayDataRef,\n+    boxed_fields: Vec<ArrayRef>,\n+}\n+\n+impl UnionArray {\n+    /// Creates a new `UnionArray`.\n+    ///\n+    /// Accepts type ids, child arrays and optionally offsets (for dense unions) to create\n+    /// a new `UnionArray`.  This method makes no attempt to validate the data provided by the\n+    /// caller and assumes that each of the components are correct and consistent with each other.\n+    /// See `try_new` for an alternative that validates the data provided.\n+    ///\n+    /// # Data Consistency\n+    ///\n+    /// The `type_ids` `Buffer` should contain `i8` values.  These values should be greater than\n+    /// zero and must be less than the number of children provided in `child_arrays`.  These values\n+    /// are used to index into the `child_arrays`.\n+    ///\n+    /// The `value_offsets` `Buffer` is only provided in the case of a dense union, sparse unions\n+    /// should use `None`.  If provided the `value_offsets` `Buffer` should contain `i32` values.\n+    /// These values should be greater than zero and must be less than the length of the overall\n+    /// array.\n+    ///\n+    /// In both cases above we use signed integer types to maintain compatibility with other\n+    /// Arrow implementations.\n+    ///\n+    /// In both of the cases above we are accepting `Buffer`'s which are assumed to be representing\n+    /// `i8` and `i32` values respectively.  `Buffer` objects are untyped and no attempt is made\n+    /// to ensure that the data provided is valid.\n+    pub fn new(\n+        type_ids: Buffer,\n+        value_offsets: Option<Buffer>,\n+        child_arrays: Vec<(Field, ArrayRef)>,\n+        bitmap_data: Option<(Buffer, usize)>,\n+    ) -> Self {\n+        let (field_types, field_values): (Vec<_>, Vec<_>) =\n+            child_arrays.into_iter().unzip();\n+        let len = type_ids.len();\n+        let mut builder = ArrayData::builder(DataType::Union(field_types))\n+            .add_buffer(type_ids)\n+            .child_data(field_values.into_iter().map(|a| a.data()).collect())\n+            .len(len);\n+        if let Some((bitmap, null_count)) = bitmap_data {\n+            builder = builder.null_bit_buffer(bitmap).null_count(null_count);\n+        }\n+        let data = match value_offsets {\n+            Some(b) => builder.add_buffer(b).build(),\n+            None => builder.build(),\n+        };\n+        Self::from(data)\n+    }\n+    /// Attempts to create a new `UnionArray` and validates the inputs provided.\n+    pub fn try_new(\n+        type_ids: Buffer,\n+        value_offsets: Option<Buffer>,\n+        child_arrays: Vec<(Field, ArrayRef)>,\n+        bitmap: Option<Buffer>,\n+    ) -> Result<Self> {\n+        let bitmap_data = bitmap.map(|b| {\n+            let null_count = type_ids.len() - bit_util::count_set_bits(b.data());\n+            (b, null_count)\n+        });\n+\n+        if let Some(b) = &value_offsets {\n+            let nulls = match bitmap_data {\n+                Some((_, n)) => n,\n+                None => 0,\n+            };\n+            if ((type_ids.len() - nulls) * 4) != b.len() {\n+                return Err(ArrowError::InvalidArgumentError(\n+                    \"Type Ids and Offsets represent a different number of array slots.\"\n+                        .to_string(),\n+                ));\n+            }\n+        }\n+\n+        // Check the type_ids\n+        let type_id_slice: &[i8] = unsafe { type_ids.typed_data() };\n+        let invalid_type_ids = type_id_slice\n+            .iter()\n+            .filter(|i| *i < &0)\n+            .collect::<Vec<&i8>>();\n+        if invalid_type_ids.len() > 0 {\n+            return Err(ArrowError::InvalidArgumentError(format!(\n+                \"Type Ids must be positive and cannot be greater than the number of \\\n+                child arrays, found:\\n{:?}\",\n+                invalid_type_ids\n+            )));\n+        }\n+\n+        // Check the value offsets if provided\n+        if let Some(offset_buffer) = &value_offsets {\n+            let max_len = type_ids.len() as i32;\n+            let offsets_slice: &[i32] = unsafe { offset_buffer.typed_data() };\n+            let invalid_offsets = offsets_slice\n+                .iter()\n+                .filter(|i| *i < &0 || *i > &max_len)\n+                .collect::<Vec<&i32>>();\n+            if invalid_offsets.len() > 0 {\n+                return Err(ArrowError::InvalidArgumentError(format!(\n+                    \"Offsets must be positive and within the length of the Array, \\\n+                    found:\\n{:?}\",\n+                    invalid_offsets\n+                )));\n+            }\n+        }\n+\n+        Ok(Self::new(\n+            type_ids,\n+            value_offsets,\n+            child_arrays,\n+            bitmap_data,\n+        ))\n+    }\n+\n+    /// Accesses the child array for `type_id`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the `type_id` provided is less than zero or greater than the number of types\n+    /// in the `Union`.\n+    pub fn child(&self, type_id: i8) -> ArrayRef {\n+        assert!(0 <= type_id);\n+        assert!((type_id as usize) < self.boxed_fields.len());\n+        self.boxed_fields[type_id as usize].clone()\n+    }\n+\n+    /// Returns the `type_id` for the array slot at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn type_id(&self, index: usize) -> i8 {\n+        assert!(index - self.offset() < self.len());\n+        self.data().buffers()[0].data()[index] as i8\n+    }\n+\n+    /// Returns the offset into the underlying values array for the array slot at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn value_offset(&self, index: usize) -> i32 {\n+        assert!(index - self.offset() < self.len());\n+        if self.is_dense() {\n+            let valid_slots = match self.data.null_buffer() {\n+                Some(b) => bit_util::count_set_bits_offset(b.data(), 0, index),\n+                None => index,\n+            };\n+            self.data().buffers()[1].data()[valid_slots * size_of::<i32>()] as i32\n+        } else {\n+            index as i32\n+        }\n+    }\n+\n+    /// Returns the array's value at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn value(&self, index: usize) -> ArrayRef {\n+        let type_id = self.type_id(self.offset() + index);\n+        let value_offset = self.value_offset(self.offset() + index) as usize;\n+        let child_data = self.boxed_fields[type_id as usize].clone();\n+        child_data.slice(value_offset, 1)\n+    }\n+\n+    /// Returns the names of the types in the union.\n+    pub fn type_names(&self) -> Vec<&str> {\n+        match self.data.data_type() {\n+            DataType::Union(fields) => fields\n+                .iter()\n+                .map(|f| f.name().as_str())\n+                .collect::<Vec<&str>>(),\n+            _ => unreachable!(\"Union array's data type is not a union!\"),\n+        }\n+    }\n+\n+    /// Returns whether the `UnionArray` is dense (or sparse if `false`).\n+    fn is_dense(&self) -> bool {\n+        self.data().buffers().len() == 2\n+    }\n+}\n+\n+impl From<ArrayDataRef> for UnionArray {\n+    fn from(data: ArrayDataRef) -> Self {\n+        let mut boxed_fields = vec![];\n+        for cd in data.child_data() {\n+            boxed_fields.push(make_array(cd.clone()));\n+        }\n+        Self { data, boxed_fields }\n+    }\n+}\n+\n+impl Array for UnionArray {\n+    fn as_any(&self) -> &Any {\n+        self\n+    }\n+\n+    fn data(&self) -> ArrayDataRef {\n+        self.data.clone()\n+    }\n+\n+    fn data_ref(&self) -> &ArrayDataRef {\n+        &self.data\n+    }\n+}\n+\n+impl fmt::Debug for UnionArray {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let header = if self.is_dense() {\n+            \"UnionArray(Dense)\\n[\\n\"\n+        } else {\n+            \"UnionArray(Sparse)\\n[\\n\"\n+        };\n+        write!(f, \"{}\", header)?;\n+\n+        write!(f, \"-- type id buffer:\\n\")?;\n+        write!(f, \"{:?}\\n\", self.data().buffers()[0])?;\n+\n+        if self.is_dense() {\n+            write!(f, \"-- offsets buffer:\\n\")?;\n+            write!(f, \"{:?}\\n\", self.data().buffers()[1])?;\n+        }\n+\n+        for (child_index, name) in self.type_names().iter().enumerate() {\n+            let column = &self.boxed_fields[child_index];\n+            write!(\n+                f,\n+                \"-- child {}: \\\"{}\\\" ({:?})\\n\",\n+                child_index,\n+                *name,\n+                column.data_type()\n+            )?;\n+            fmt::Debug::fmt(column, f)?;\n+            write!(f, \"\\n\")?;\n+        }\n+        write!(f, \"]\")\n+    }\n+}\n+\n+/// `FieldData` is a helper struct to track the state of the fields in the `UnionBuilder`.\n+struct FieldData {\n+    /// The type id for this field\n+    type_id: i8,\n+    /// The Arrow data type represented in the `values_buffer`, which is untyped\n+    data_type: DataType,\n+    /// A buffer containing the values for this field in raw bytes\n+    values_buffer: Option<MutableBuffer>,\n+    ///  The number of array slots represented by the buffer\n+    slots: usize,\n+    /// The number of null array slots in this child array\n+    null_count: usize,\n+    /// A builder for the bitmap if required\n+    bitmap_builder: Option<BooleanBufferBuilder>,\n+}\n+\n+impl FieldData {\n+    /// Creates a new `FieldData`.\n+    fn new(\n+        type_id: i8,\n+        data_type: DataType,\n+        bitmap_builder: Option<BooleanBufferBuilder>,\n+    ) -> Self {\n+        Self {\n+            type_id,\n+            data_type,\n+            // TODO: Should `MutableBuffer` implement `Default`?\n+            values_buffer: Some(MutableBuffer::new(1)),\n+            slots: 0,\n+            null_count: 0,\n+            bitmap_builder,\n+        }\n+    }\n+\n+    /// Appends a single value to this `FieldData`'s `values_buffer`.\n+    fn append_to_values_buffer<T: ArrowPrimitiveType>(\n+        &mut self,\n+        v: T::Native,\n+    ) -> Result<()> {\n+        let values_buffer = self\n+            .values_buffer\n+            .take()\n+            .expect(\"Values buffer was never created\");\n+        let mut builder: BufferBuilder<T> =\n+            mutable_buffer_to_builder(values_buffer, self.slots);\n+        builder.append(v)?;\n+        let mutable_buffer = builder_to_mutable_buffer(builder);\n+        self.values_buffer = Some(mutable_buffer);\n+\n+        self.slots += 1;\n+        if let Some(b) = &mut self.bitmap_builder {\n+            b.append(true)?\n+        };\n+        Ok(())\n+    }\n+\n+    /// Appends a null to this `FieldData`.\n+    fn append_null<T: ArrowPrimitiveType>(&mut self) -> Result<()> {\n+        if let Some(b) = &mut self.bitmap_builder {\n+            let values_buffer = self\n+                .values_buffer\n+                .take()\n+                .expect(\"Values buffer was never created\");\n+            let mut builder: BufferBuilder<T> =\n+                mutable_buffer_to_builder(values_buffer, self.slots);\n+            builder.advance(1)?;\n+            let mutable_buffer = builder_to_mutable_buffer(builder);\n+            self.values_buffer = Some(mutable_buffer);\n+            self.slots += 1;\n+            b.append(false)?;\n+        };\n+        Ok(())\n+    }\n+\n+    /// Appends a null to this `FieldData` when the type is not known at compile time.\n+    ///\n+    /// As the main `append` method of `UnionBuilder` is generic, we need a way to append null\n+    /// slots to the fields that are not being appended to in the case of sparse unions.  This\n+    /// method solves this problem by appending dynamically based on `DataType`.\n+    ///\n+    /// Note, this method does **not** update the length of the `UnionArray` (this is done by the\n+    /// main append operation) and assumes that it is called from a method that is generic over `T`\n+    /// where `T` satisfies the bound `ArrowPrimitiveType`.\n+    fn append_null_dynamic(&mut self) -> Result<()> {\n+        match self.data_type {\n+            DataType::Boolean => self.append_null::<BooleanType>()?,\n+            DataType::Int8 => self.append_null::<Int8Type>()?,\n+            DataType::Int16 => self.append_null::<Int16Type>()?,\n+            DataType::Int32\n+            | DataType::Date32(_)\n+            | DataType::Time32(_)\n+            | DataType::Interval(IntervalUnit::YearMonth) => {\n+                self.append_null::<Int32Type>()?\n+            }\n+            DataType::Int64\n+            | DataType::Timestamp(_, _)\n+            | DataType::Date64(_)\n+            | DataType::Time64(_)\n+            | DataType::Interval(IntervalUnit::DayTime)\n+            | DataType::Duration(_) => self.append_null::<Int64Type>()?,\n+            DataType::UInt8 => self.append_null::<UInt8Type>()?,\n+            DataType::UInt16 => self.append_null::<UInt16Type>()?,\n+            DataType::UInt32 => self.append_null::<UInt32Type>()?,\n+            DataType::UInt64 => self.append_null::<UInt64Type>()?,\n+            DataType::Float32 => self.append_null::<Float32Type>()?,\n+            DataType::Float64 => self.append_null::<Float64Type>()?,\n+            _ => unreachable!(\"All cases of types that satisfy the trait bounds over T are covered above.\"),\n+        };\n+        Ok(())\n+    }\n+}\n+\n+/// Builder type for creating a new `UnionArray`.\n+pub struct UnionBuilder {\n+    /// The current number of slots in the array\n+    len: usize,\n+    /// Maps field names to `FieldData` instances which track the builders for that field\n+    fields: HashMap<String, FieldData>,\n+    /// Builder to keep track of type ids\n+    type_id_builder: Int8BufferBuilder,\n+    /// Builder to keep track of offsets (`None` for sparse unions)\n+    value_offset_builder: Option<Int32BufferBuilder>,\n+    /// Optional builder for null slots\n+    bitmap_builder: Option<BooleanBufferBuilder>,\n+}\n+\n+impl UnionBuilder {\n+    /// Creates a new dense array builder.\n+    pub fn new_dense(capacity: usize) -> Self {\n+        Self {\n+            len: 0,\n+            fields: HashMap::default(),\n+            type_id_builder: Int8BufferBuilder::new(capacity),\n+            value_offset_builder: Some(Int32BufferBuilder::new(capacity)),\n+            bitmap_builder: None,\n+        }\n+    }\n+\n+    /// Creates a new sparse array builder.\n+    pub fn new_sparse(capacity: usize) -> Self {\n+        Self {\n+            len: 0,\n+            fields: HashMap::default(),\n+            type_id_builder: Int8BufferBuilder::new(capacity),\n+            value_offset_builder: None,\n+            bitmap_builder: None,\n+        }\n+    }\n+\n+    /// Appends a null to this builder.\n+    pub fn append_null(&mut self) -> Result<()> {\n+        if let None = self.bitmap_builder {\n+            let mut builder = BooleanBufferBuilder::new(self.len + 1);\n+            for _ in 0..self.len {\n+                builder.append(true)?;\n+            }\n+            self.bitmap_builder = Some(builder)\n+        }\n+        self.bitmap_builder\n+            .as_mut()\n+            .expect(\"Cannot be None\")\n+            .append(false)?;\n+\n+        self.type_id_builder.append(i8::default())?;\n+\n+        // Handle sparse union\n+        if let None = self.value_offset_builder {\n+            for (_, fd) in self.fields.iter_mut() {\n+                fd.append_null_dynamic()?;\n+            }\n+        }\n+        self.len += 1;\n+        Ok(())\n+    }\n+\n+    /// Appends a value to this builder.\n+    pub fn append<T: ArrowPrimitiveType>(\n+        &mut self,\n+        type_name: &str,\n+        v: T::Native,\n+    ) -> Result<()> {\n+        let type_name = type_name.to_string();\n+\n+        let mut field_data = match self.fields.remove(&type_name) {\n+            Some(data) => data,\n+            None => {\n+                let field_data = match self.value_offset_builder {\n+                    Some(_) => {\n+                        FieldData::new(self.fields.len() as i8, T::get_data_type(), None)\n+                    }\n+                    None => {\n+                        let mut fd = FieldData::new(\n+                            self.fields.len() as i8,\n+                            T::get_data_type(),\n+                            Some(BooleanBufferBuilder::new(1)),\n+                        );\n+                        for _ in 0..self.len {\n+                            fd.append_null::<T>()?;\n+                        }\n+                        fd\n+                    }\n+                };\n+                field_data\n+            }\n+        };\n+        self.type_id_builder.append(field_data.type_id)?;\n+\n+        match &mut self.value_offset_builder {\n+            // Dense Union\n+            Some(offset_builder) => {\n+                offset_builder.append(field_data.slots as i32)?;\n+            }\n+            // Sparse Union\n+            None => {\n+                for (name, fd) in self.fields.iter_mut() {\n+                    if name != &type_name {\n+                        fd.append_null_dynamic()?;\n+                    }\n+                }\n+            }\n+        }\n+        field_data.append_to_values_buffer::<T>(v)?;\n+        self.fields.insert(type_name, field_data);\n+\n+        // Update the bitmap builder if it exists\n+        if let Some(b) = &mut self.bitmap_builder {\n+            b.append(true)?;\n+        }\n+        self.len += 1;\n+        Ok(())\n+    }\n+\n+    /// Builds this builder creating a new `UnionArray`.\n+    pub fn build(mut self) -> Result<UnionArray> {\n+        let type_id_buffer = self.type_id_builder.finish();\n+        let value_offsets_buffer = self.value_offset_builder.map(|mut b| b.finish());\n+        let mut children = Vec::new();\n+        for (\n+            name,\n+            FieldData {\n+                type_id,\n+                data_type,\n+                values_buffer,\n+                slots,\n+                bitmap_builder,\n+                null_count,\n+            },\n+        ) in self.fields.into_iter()\n+        {\n+            let buffer = values_buffer.expect(\"UPDATE LATER\").freeze();\n+            let arr_data_builder = ArrayDataBuilder::new(data_type.clone())\n+                .add_buffer(buffer)\n+                .null_count(null_count)\n+                .len(slots);\n+            //                .build();\n+            let arr_data_ref = match bitmap_builder {\n+                Some(mut bb) => {\n+                    // TODO: YOU'RE HERE\n+                    arr_data_builder.null_bit_buffer(bb.finish()).build()\n+                }\n+                None => arr_data_builder.build(),\n+            };\n+            let array_ref = make_array(arr_data_ref);\n+            children.push((type_id, (Field::new(&name, data_type, false), array_ref)))\n+        }\n+\n+        children.sort_by(|a, b| {\n+            a.0.partial_cmp(&b.0)\n+                .expect(\"This will never be Nono as type ids are always i8 values.\")\n\nReview comment:\n       `Nono` -> `None`\n\n##########\nFile path: rust/arrow/src/datatypes.rs\n##########\n@@ -930,6 +932,7 @@ impl DataType {\n                 json!({\"name\": \"fixedsizebinary\", \"byteWidth\": byte_width})\n             }\n             DataType::Struct(_) => json!({\"name\": \"struct\"}),\n+            DataType::Union(_) => json!({\"name\": \"union\"}),\n\nReview comment:\n       Some matches for `Union(_)` are missing, but I'm happy if we address them when dealing with IPC, as they're more relevant then.\n\n##########\nFile path: rust/arrow/src/array/union.rs\n##########\n@@ -0,0 +1,1174 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Contains the `UnionArray` and `UnionBuilder` types.\n+//!\n+//! Each slot in a `UnionArray` can have a value chosen from a number of types.  Each of the\n+//! possible types are named like the fields of a [`StructArray`](crate::array::StructArray).\n+//! A `UnionArray` can have two possible memory layouts, \"dense\" or \"sparse\".  For more information\n+//! on please see the [specification](https://arrow.apache.org/docs/format/Columnar.html#union-layout).\n+//!\n+//! Builders are provided for `UnionArray`'s involving primitive types.  `UnionArray`'s of nested\n+//! types are also supported but not via `UnionBuilder`, see the tests for examples.\n+//!\n+//! # Example: Dense Memory Layout\n+//!\n+//! ```\n+//! use arrow::array::UnionBuilder;\n+//! use arrow::datatypes::{Float64Type, Int32Type};\n+//!\n+//! # fn main() -> arrow::error::Result<()> {\n+//! let mut builder = UnionBuilder::new_dense(3);\n+//! builder.append::<Int32Type>(\"a\", 1).unwrap();\n+//! builder.append::<Float64Type>(\"b\", 3.0).unwrap();\n+//! builder.append::<Int32Type>(\"a\", 4).unwrap();\n+//! let union = builder.build().unwrap();\n+//!\n+//! assert_eq!(union.type_id(0), 0_i8);\n+//! assert_eq!(union.type_id(1), 1_i8);\n+//! assert_eq!(union.type_id(2), 0_i8);\n+//!\n+//! assert_eq!(union.value_offset(0), 0_i32);\n+//! assert_eq!(union.value_offset(1), 0_i32);\n+//! assert_eq!(union.value_offset(2), 1_i32);\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+//!\n+//! # Example: Sparse Memory Layout\n+//! ```\n+//! use arrow::array::UnionBuilder;\n+//! use arrow::datatypes::{Float64Type, Int32Type};\n+//!\n+//! # fn main() -> arrow::error::Result<()> {\n+//! let mut builder = UnionBuilder::new_sparse(3);\n+//! builder.append::<Int32Type>(\"a\", 1).unwrap();\n+//! builder.append::<Float64Type>(\"b\", 3.0).unwrap();\n+//! builder.append::<Int32Type>(\"a\", 4).unwrap();\n+//! let union = builder.build().unwrap();\n+//!\n+//! assert_eq!(union.type_id(0), 0_i8);\n+//! assert_eq!(union.type_id(1), 1_i8);\n+//! assert_eq!(union.type_id(2), 0_i8);\n+//!\n+//! assert_eq!(union.value_offset(0), 0_i32);\n+//! assert_eq!(union.value_offset(1), 1_i32);\n+//! assert_eq!(union.value_offset(2), 2_i32);\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+use crate::array::{\n+    builder::{builder_to_mutable_buffer, mutable_buffer_to_builder, BufferBuilderTrait},\n+    make_array, Array, ArrayData, ArrayDataBuilder, ArrayDataRef, ArrayRef,\n+    BooleanBufferBuilder, BufferBuilder, Int32BufferBuilder, Int8BufferBuilder,\n+};\n+use crate::buffer::{Buffer, MutableBuffer};\n+use crate::datatypes::*;\n+use crate::error::{ArrowError, Result};\n+\n+use crate::util::bit_util;\n+use core::fmt;\n+use std::any::Any;\n+use std::collections::HashMap;\n+use std::mem::size_of;\n+\n+/// An Array that can represent slots of varying types\n+pub struct UnionArray {\n+    data: ArrayDataRef,\n+    boxed_fields: Vec<ArrayRef>,\n+}\n+\n+impl UnionArray {\n+    /// Creates a new `UnionArray`.\n+    ///\n+    /// Accepts type ids, child arrays and optionally offsets (for dense unions) to create\n+    /// a new `UnionArray`.  This method makes no attempt to validate the data provided by the\n+    /// caller and assumes that each of the components are correct and consistent with each other.\n+    /// See `try_new` for an alternative that validates the data provided.\n+    ///\n+    /// # Data Consistency\n+    ///\n+    /// The `type_ids` `Buffer` should contain `i8` values.  These values should be greater than\n+    /// zero and must be less than the number of children provided in `child_arrays`.  These values\n+    /// are used to index into the `child_arrays`.\n+    ///\n+    /// The `value_offsets` `Buffer` is only provided in the case of a dense union, sparse unions\n+    /// should use `None`.  If provided the `value_offsets` `Buffer` should contain `i32` values.\n+    /// These values should be greater than zero and must be less than the length of the overall\n+    /// array.\n+    ///\n+    /// In both cases above we use signed integer types to maintain compatibility with other\n+    /// Arrow implementations.\n+    ///\n+    /// In both of the cases above we are accepting `Buffer`'s which are assumed to be representing\n+    /// `i8` and `i32` values respectively.  `Buffer` objects are untyped and no attempt is made\n+    /// to ensure that the data provided is valid.\n+    pub fn new(\n+        type_ids: Buffer,\n+        value_offsets: Option<Buffer>,\n+        child_arrays: Vec<(Field, ArrayRef)>,\n+        bitmap_data: Option<(Buffer, usize)>,\n+    ) -> Self {\n+        let (field_types, field_values): (Vec<_>, Vec<_>) =\n+            child_arrays.into_iter().unzip();\n+        let len = type_ids.len();\n+        let mut builder = ArrayData::builder(DataType::Union(field_types))\n+            .add_buffer(type_ids)\n+            .child_data(field_values.into_iter().map(|a| a.data()).collect())\n+            .len(len);\n+        if let Some((bitmap, null_count)) = bitmap_data {\n+            builder = builder.null_bit_buffer(bitmap).null_count(null_count);\n+        }\n+        let data = match value_offsets {\n+            Some(b) => builder.add_buffer(b).build(),\n+            None => builder.build(),\n+        };\n+        Self::from(data)\n+    }\n+    /// Attempts to create a new `UnionArray` and validates the inputs provided.\n+    pub fn try_new(\n+        type_ids: Buffer,\n+        value_offsets: Option<Buffer>,\n+        child_arrays: Vec<(Field, ArrayRef)>,\n+        bitmap: Option<Buffer>,\n+    ) -> Result<Self> {\n+        let bitmap_data = bitmap.map(|b| {\n+            let null_count = type_ids.len() - bit_util::count_set_bits(b.data());\n+            (b, null_count)\n+        });\n+\n+        if let Some(b) = &value_offsets {\n+            let nulls = match bitmap_data {\n+                Some((_, n)) => n,\n+                None => 0,\n+            };\n+            if ((type_ids.len() - nulls) * 4) != b.len() {\n+                return Err(ArrowError::InvalidArgumentError(\n+                    \"Type Ids and Offsets represent a different number of array slots.\"\n+                        .to_string(),\n+                ));\n+            }\n+        }\n+\n+        // Check the type_ids\n+        let type_id_slice: &[i8] = unsafe { type_ids.typed_data() };\n+        let invalid_type_ids = type_id_slice\n+            .iter()\n+            .filter(|i| *i < &0)\n+            .collect::<Vec<&i8>>();\n+        if invalid_type_ids.len() > 0 {\n+            return Err(ArrowError::InvalidArgumentError(format!(\n+                \"Type Ids must be positive and cannot be greater than the number of \\\n+                child arrays, found:\\n{:?}\",\n+                invalid_type_ids\n+            )));\n+        }\n+\n+        // Check the value offsets if provided\n+        if let Some(offset_buffer) = &value_offsets {\n+            let max_len = type_ids.len() as i32;\n+            let offsets_slice: &[i32] = unsafe { offset_buffer.typed_data() };\n+            let invalid_offsets = offsets_slice\n+                .iter()\n+                .filter(|i| *i < &0 || *i > &max_len)\n+                .collect::<Vec<&i32>>();\n+            if invalid_offsets.len() > 0 {\n+                return Err(ArrowError::InvalidArgumentError(format!(\n+                    \"Offsets must be positive and within the length of the Array, \\\n+                    found:\\n{:?}\",\n+                    invalid_offsets\n+                )));\n+            }\n+        }\n+\n+        Ok(Self::new(\n+            type_ids,\n+            value_offsets,\n+            child_arrays,\n+            bitmap_data,\n+        ))\n+    }\n+\n+    /// Accesses the child array for `type_id`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the `type_id` provided is less than zero or greater than the number of types\n+    /// in the `Union`.\n+    pub fn child(&self, type_id: i8) -> ArrayRef {\n+        assert!(0 <= type_id);\n+        assert!((type_id as usize) < self.boxed_fields.len());\n+        self.boxed_fields[type_id as usize].clone()\n+    }\n+\n+    /// Returns the `type_id` for the array slot at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn type_id(&self, index: usize) -> i8 {\n+        assert!(index - self.offset() < self.len());\n+        self.data().buffers()[0].data()[index] as i8\n+    }\n+\n+    /// Returns the offset into the underlying values array for the array slot at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn value_offset(&self, index: usize) -> i32 {\n+        assert!(index - self.offset() < self.len());\n+        if self.is_dense() {\n+            let valid_slots = match self.data.null_buffer() {\n+                Some(b) => bit_util::count_set_bits_offset(b.data(), 0, index),\n+                None => index,\n+            };\n+            self.data().buffers()[1].data()[valid_slots * size_of::<i32>()] as i32\n+        } else {\n+            index as i32\n+        }\n+    }\n+\n+    /// Returns the array's value at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn value(&self, index: usize) -> ArrayRef {\n+        let type_id = self.type_id(self.offset() + index);\n+        let value_offset = self.value_offset(self.offset() + index) as usize;\n+        let child_data = self.boxed_fields[type_id as usize].clone();\n+        child_data.slice(value_offset, 1)\n+    }\n+\n+    /// Returns the names of the types in the union.\n+    pub fn type_names(&self) -> Vec<&str> {\n+        match self.data.data_type() {\n+            DataType::Union(fields) => fields\n+                .iter()\n+                .map(|f| f.name().as_str())\n+                .collect::<Vec<&str>>(),\n+            _ => unreachable!(\"Union array's data type is not a union!\"),\n+        }\n+    }\n+\n+    /// Returns whether the `UnionArray` is dense (or sparse if `false`).\n+    fn is_dense(&self) -> bool {\n+        self.data().buffers().len() == 2\n+    }\n+}\n+\n+impl From<ArrayDataRef> for UnionArray {\n+    fn from(data: ArrayDataRef) -> Self {\n+        let mut boxed_fields = vec![];\n+        for cd in data.child_data() {\n+            boxed_fields.push(make_array(cd.clone()));\n+        }\n+        Self { data, boxed_fields }\n+    }\n+}\n+\n+impl Array for UnionArray {\n+    fn as_any(&self) -> &Any {\n+        self\n+    }\n+\n+    fn data(&self) -> ArrayDataRef {\n+        self.data.clone()\n+    }\n+\n+    fn data_ref(&self) -> &ArrayDataRef {\n+        &self.data\n+    }\n+}\n+\n+impl fmt::Debug for UnionArray {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let header = if self.is_dense() {\n+            \"UnionArray(Dense)\\n[\\n\"\n+        } else {\n+            \"UnionArray(Sparse)\\n[\\n\"\n+        };\n+        write!(f, \"{}\", header)?;\n+\n+        write!(f, \"-- type id buffer:\\n\")?;\n+        write!(f, \"{:?}\\n\", self.data().buffers()[0])?;\n+\n+        if self.is_dense() {\n+            write!(f, \"-- offsets buffer:\\n\")?;\n+            write!(f, \"{:?}\\n\", self.data().buffers()[1])?;\n+        }\n+\n+        for (child_index, name) in self.type_names().iter().enumerate() {\n+            let column = &self.boxed_fields[child_index];\n+            write!(\n+                f,\n+                \"-- child {}: \\\"{}\\\" ({:?})\\n\",\n+                child_index,\n+                *name,\n+                column.data_type()\n+            )?;\n+            fmt::Debug::fmt(column, f)?;\n+            write!(f, \"\\n\")?;\n+        }\n+        write!(f, \"]\")\n+    }\n+}\n+\n+/// `FieldData` is a helper struct to track the state of the fields in the `UnionBuilder`.\n+struct FieldData {\n+    /// The type id for this field\n+    type_id: i8,\n+    /// The Arrow data type represented in the `values_buffer`, which is untyped\n+    data_type: DataType,\n+    /// A buffer containing the values for this field in raw bytes\n+    values_buffer: Option<MutableBuffer>,\n+    ///  The number of array slots represented by the buffer\n+    slots: usize,\n+    /// The number of null array slots in this child array\n+    null_count: usize,\n+    /// A builder for the bitmap if required\n+    bitmap_builder: Option<BooleanBufferBuilder>,\n+}\n+\n+impl FieldData {\n+    /// Creates a new `FieldData`.\n+    fn new(\n+        type_id: i8,\n+        data_type: DataType,\n+        bitmap_builder: Option<BooleanBufferBuilder>,\n+    ) -> Self {\n+        Self {\n+            type_id,\n+            data_type,\n+            // TODO: Should `MutableBuffer` implement `Default`?\n+            values_buffer: Some(MutableBuffer::new(1)),\n+            slots: 0,\n+            null_count: 0,\n+            bitmap_builder,\n+        }\n+    }\n+\n+    /// Appends a single value to this `FieldData`'s `values_buffer`.\n+    fn append_to_values_buffer<T: ArrowPrimitiveType>(\n+        &mut self,\n+        v: T::Native,\n+    ) -> Result<()> {\n+        let values_buffer = self\n+            .values_buffer\n+            .take()\n+            .expect(\"Values buffer was never created\");\n+        let mut builder: BufferBuilder<T> =\n+            mutable_buffer_to_builder(values_buffer, self.slots);\n+        builder.append(v)?;\n+        let mutable_buffer = builder_to_mutable_buffer(builder);\n+        self.values_buffer = Some(mutable_buffer);\n+\n+        self.slots += 1;\n+        if let Some(b) = &mut self.bitmap_builder {\n+            b.append(true)?\n+        };\n+        Ok(())\n+    }\n+\n+    /// Appends a null to this `FieldData`.\n+    fn append_null<T: ArrowPrimitiveType>(&mut self) -> Result<()> {\n+        if let Some(b) = &mut self.bitmap_builder {\n+            let values_buffer = self\n+                .values_buffer\n+                .take()\n+                .expect(\"Values buffer was never created\");\n+            let mut builder: BufferBuilder<T> =\n+                mutable_buffer_to_builder(values_buffer, self.slots);\n+            builder.advance(1)?;\n+            let mutable_buffer = builder_to_mutable_buffer(builder);\n+            self.values_buffer = Some(mutable_buffer);\n+            self.slots += 1;\n+            b.append(false)?;\n+        };\n+        Ok(())\n+    }\n+\n+    /// Appends a null to this `FieldData` when the type is not known at compile time.\n+    ///\n+    /// As the main `append` method of `UnionBuilder` is generic, we need a way to append null\n+    /// slots to the fields that are not being appended to in the case of sparse unions.  This\n+    /// method solves this problem by appending dynamically based on `DataType`.\n+    ///\n+    /// Note, this method does **not** update the length of the `UnionArray` (this is done by the\n+    /// main append operation) and assumes that it is called from a method that is generic over `T`\n+    /// where `T` satisfies the bound `ArrowPrimitiveType`.\n+    fn append_null_dynamic(&mut self) -> Result<()> {\n+        match self.data_type {\n+            DataType::Boolean => self.append_null::<BooleanType>()?,\n+            DataType::Int8 => self.append_null::<Int8Type>()?,\n+            DataType::Int16 => self.append_null::<Int16Type>()?,\n+            DataType::Int32\n+            | DataType::Date32(_)\n+            | DataType::Time32(_)\n+            | DataType::Interval(IntervalUnit::YearMonth) => {\n+                self.append_null::<Int32Type>()?\n+            }\n+            DataType::Int64\n+            | DataType::Timestamp(_, _)\n+            | DataType::Date64(_)\n+            | DataType::Time64(_)\n+            | DataType::Interval(IntervalUnit::DayTime)\n+            | DataType::Duration(_) => self.append_null::<Int64Type>()?,\n+            DataType::UInt8 => self.append_null::<UInt8Type>()?,\n+            DataType::UInt16 => self.append_null::<UInt16Type>()?,\n+            DataType::UInt32 => self.append_null::<UInt32Type>()?,\n+            DataType::UInt64 => self.append_null::<UInt64Type>()?,\n+            DataType::Float32 => self.append_null::<Float32Type>()?,\n+            DataType::Float64 => self.append_null::<Float64Type>()?,\n+            _ => unreachable!(\"All cases of types that satisfy the trait bounds over T are covered above.\"),\n+        };\n+        Ok(())\n+    }\n+}\n+\n+/// Builder type for creating a new `UnionArray`.\n+pub struct UnionBuilder {\n+    /// The current number of slots in the array\n+    len: usize,\n+    /// Maps field names to `FieldData` instances which track the builders for that field\n+    fields: HashMap<String, FieldData>,\n+    /// Builder to keep track of type ids\n+    type_id_builder: Int8BufferBuilder,\n+    /// Builder to keep track of offsets (`None` for sparse unions)\n+    value_offset_builder: Option<Int32BufferBuilder>,\n+    /// Optional builder for null slots\n+    bitmap_builder: Option<BooleanBufferBuilder>,\n+}\n+\n+impl UnionBuilder {\n+    /// Creates a new dense array builder.\n+    pub fn new_dense(capacity: usize) -> Self {\n+        Self {\n+            len: 0,\n+            fields: HashMap::default(),\n+            type_id_builder: Int8BufferBuilder::new(capacity),\n+            value_offset_builder: Some(Int32BufferBuilder::new(capacity)),\n+            bitmap_builder: None,\n+        }\n+    }\n+\n+    /// Creates a new sparse array builder.\n+    pub fn new_sparse(capacity: usize) -> Self {\n+        Self {\n+            len: 0,\n+            fields: HashMap::default(),\n+            type_id_builder: Int8BufferBuilder::new(capacity),\n+            value_offset_builder: None,\n+            bitmap_builder: None,\n+        }\n+    }\n+\n+    /// Appends a null to this builder.\n+    pub fn append_null(&mut self) -> Result<()> {\n+        if let None = self.bitmap_builder {\n+            let mut builder = BooleanBufferBuilder::new(self.len + 1);\n+            for _ in 0..self.len {\n+                builder.append(true)?;\n+            }\n+            self.bitmap_builder = Some(builder)\n+        }\n+        self.bitmap_builder\n+            .as_mut()\n+            .expect(\"Cannot be None\")\n+            .append(false)?;\n+\n+        self.type_id_builder.append(i8::default())?;\n+\n+        // Handle sparse union\n+        if let None = self.value_offset_builder {\n+            for (_, fd) in self.fields.iter_mut() {\n+                fd.append_null_dynamic()?;\n+            }\n+        }\n+        self.len += 1;\n+        Ok(())\n+    }\n+\n+    /// Appends a value to this builder.\n+    pub fn append<T: ArrowPrimitiveType>(\n+        &mut self,\n+        type_name: &str,\n+        v: T::Native,\n+    ) -> Result<()> {\n+        let type_name = type_name.to_string();\n+\n+        let mut field_data = match self.fields.remove(&type_name) {\n+            Some(data) => data,\n+            None => {\n+                let field_data = match self.value_offset_builder {\n+                    Some(_) => {\n+                        FieldData::new(self.fields.len() as i8, T::get_data_type(), None)\n+                    }\n+                    None => {\n+                        let mut fd = FieldData::new(\n+                            self.fields.len() as i8,\n+                            T::get_data_type(),\n+                            Some(BooleanBufferBuilder::new(1)),\n+                        );\n+                        for _ in 0..self.len {\n+                            fd.append_null::<T>()?;\n+                        }\n+                        fd\n+                    }\n+                };\n+                field_data\n+            }\n+        };\n+        self.type_id_builder.append(field_data.type_id)?;\n+\n+        match &mut self.value_offset_builder {\n+            // Dense Union\n+            Some(offset_builder) => {\n+                offset_builder.append(field_data.slots as i32)?;\n+            }\n+            // Sparse Union\n+            None => {\n+                for (name, fd) in self.fields.iter_mut() {\n+                    if name != &type_name {\n+                        fd.append_null_dynamic()?;\n+                    }\n+                }\n+            }\n+        }\n+        field_data.append_to_values_buffer::<T>(v)?;\n+        self.fields.insert(type_name, field_data);\n+\n+        // Update the bitmap builder if it exists\n+        if let Some(b) = &mut self.bitmap_builder {\n+            b.append(true)?;\n+        }\n+        self.len += 1;\n+        Ok(())\n+    }\n+\n+    /// Builds this builder creating a new `UnionArray`.\n+    pub fn build(mut self) -> Result<UnionArray> {\n+        let type_id_buffer = self.type_id_builder.finish();\n+        let value_offsets_buffer = self.value_offset_builder.map(|mut b| b.finish());\n+        let mut children = Vec::new();\n+        for (\n+            name,\n+            FieldData {\n+                type_id,\n+                data_type,\n+                values_buffer,\n+                slots,\n+                bitmap_builder,\n+                null_count,\n+            },\n+        ) in self.fields.into_iter()\n+        {\n+            let buffer = values_buffer.expect(\"UPDATE LATER\").freeze();\n\nReview comment:\n       Reminder for the \"UPDATE LATER\", and TODO a few lines below\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-03T09:51:53.836+0000",
                    "updated": "2020-05-03T09:51:53.836+0000",
                    "started": "2020-05-03T09:51:53.836+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "429919",
                    "issueId": "13199068"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13199068/worklog/430358",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paddyhoran commented on a change in pull request #7004:\nURL: https://github.com/apache/arrow/pull/7004#discussion_r419653824\n\n\n\n##########\nFile path: rust/arrow/src/array/union.rs\n##########\n@@ -0,0 +1,1174 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Contains the `UnionArray` and `UnionBuilder` types.\n+//!\n+//! Each slot in a `UnionArray` can have a value chosen from a number of types.  Each of the\n+//! possible types are named like the fields of a [`StructArray`](crate::array::StructArray).\n+//! A `UnionArray` can have two possible memory layouts, \"dense\" or \"sparse\".  For more information\n+//! on please see the [specification](https://arrow.apache.org/docs/format/Columnar.html#union-layout).\n+//!\n+//! Builders are provided for `UnionArray`'s involving primitive types.  `UnionArray`'s of nested\n+//! types are also supported but not via `UnionBuilder`, see the tests for examples.\n+//!\n+//! # Example: Dense Memory Layout\n+//!\n+//! ```\n+//! use arrow::array::UnionBuilder;\n+//! use arrow::datatypes::{Float64Type, Int32Type};\n+//!\n+//! # fn main() -> arrow::error::Result<()> {\n+//! let mut builder = UnionBuilder::new_dense(3);\n+//! builder.append::<Int32Type>(\"a\", 1).unwrap();\n+//! builder.append::<Float64Type>(\"b\", 3.0).unwrap();\n+//! builder.append::<Int32Type>(\"a\", 4).unwrap();\n+//! let union = builder.build().unwrap();\n+//!\n+//! assert_eq!(union.type_id(0), 0_i8);\n+//! assert_eq!(union.type_id(1), 1_i8);\n+//! assert_eq!(union.type_id(2), 0_i8);\n+//!\n+//! assert_eq!(union.value_offset(0), 0_i32);\n+//! assert_eq!(union.value_offset(1), 0_i32);\n+//! assert_eq!(union.value_offset(2), 1_i32);\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+//!\n+//! # Example: Sparse Memory Layout\n+//! ```\n+//! use arrow::array::UnionBuilder;\n+//! use arrow::datatypes::{Float64Type, Int32Type};\n+//!\n+//! # fn main() -> arrow::error::Result<()> {\n+//! let mut builder = UnionBuilder::new_sparse(3);\n+//! builder.append::<Int32Type>(\"a\", 1).unwrap();\n+//! builder.append::<Float64Type>(\"b\", 3.0).unwrap();\n+//! builder.append::<Int32Type>(\"a\", 4).unwrap();\n+//! let union = builder.build().unwrap();\n+//!\n+//! assert_eq!(union.type_id(0), 0_i8);\n+//! assert_eq!(union.type_id(1), 1_i8);\n+//! assert_eq!(union.type_id(2), 0_i8);\n+//!\n+//! assert_eq!(union.value_offset(0), 0_i32);\n+//! assert_eq!(union.value_offset(1), 1_i32);\n+//! assert_eq!(union.value_offset(2), 2_i32);\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+use crate::array::{\n+    builder::{builder_to_mutable_buffer, mutable_buffer_to_builder, BufferBuilderTrait},\n+    make_array, Array, ArrayData, ArrayDataBuilder, ArrayDataRef, ArrayRef,\n+    BooleanBufferBuilder, BufferBuilder, Int32BufferBuilder, Int8BufferBuilder,\n+};\n+use crate::buffer::{Buffer, MutableBuffer};\n+use crate::datatypes::*;\n+use crate::error::{ArrowError, Result};\n+\n+use crate::util::bit_util;\n+use core::fmt;\n+use std::any::Any;\n+use std::collections::HashMap;\n+use std::mem::size_of;\n+\n+/// An Array that can represent slots of varying types\n+pub struct UnionArray {\n+    data: ArrayDataRef,\n+    boxed_fields: Vec<ArrayRef>,\n+}\n+\n+impl UnionArray {\n+    /// Creates a new `UnionArray`.\n+    ///\n+    /// Accepts type ids, child arrays and optionally offsets (for dense unions) to create\n+    /// a new `UnionArray`.  This method makes no attempt to validate the data provided by the\n+    /// caller and assumes that each of the components are correct and consistent with each other.\n+    /// See `try_new` for an alternative that validates the data provided.\n+    ///\n+    /// # Data Consistency\n+    ///\n+    /// The `type_ids` `Buffer` should contain `i8` values.  These values should be greater than\n+    /// zero and must be less than the number of children provided in `child_arrays`.  These values\n+    /// are used to index into the `child_arrays`.\n+    ///\n+    /// The `value_offsets` `Buffer` is only provided in the case of a dense union, sparse unions\n+    /// should use `None`.  If provided the `value_offsets` `Buffer` should contain `i32` values.\n+    /// These values should be greater than zero and must be less than the length of the overall\n+    /// array.\n+    ///\n+    /// In both cases above we use signed integer types to maintain compatibility with other\n+    /// Arrow implementations.\n+    ///\n+    /// In both of the cases above we are accepting `Buffer`'s which are assumed to be representing\n+    /// `i8` and `i32` values respectively.  `Buffer` objects are untyped and no attempt is made\n+    /// to ensure that the data provided is valid.\n+    pub fn new(\n+        type_ids: Buffer,\n+        value_offsets: Option<Buffer>,\n+        child_arrays: Vec<(Field, ArrayRef)>,\n+        bitmap_data: Option<(Buffer, usize)>,\n+    ) -> Self {\n+        let (field_types, field_values): (Vec<_>, Vec<_>) =\n+            child_arrays.into_iter().unzip();\n+        let len = type_ids.len();\n+        let mut builder = ArrayData::builder(DataType::Union(field_types))\n+            .add_buffer(type_ids)\n+            .child_data(field_values.into_iter().map(|a| a.data()).collect())\n+            .len(len);\n+        if let Some((bitmap, null_count)) = bitmap_data {\n+            builder = builder.null_bit_buffer(bitmap).null_count(null_count);\n+        }\n+        let data = match value_offsets {\n+            Some(b) => builder.add_buffer(b).build(),\n+            None => builder.build(),\n+        };\n+        Self::from(data)\n+    }\n+    /// Attempts to create a new `UnionArray` and validates the inputs provided.\n+    pub fn try_new(\n+        type_ids: Buffer,\n+        value_offsets: Option<Buffer>,\n+        child_arrays: Vec<(Field, ArrayRef)>,\n+        bitmap: Option<Buffer>,\n+    ) -> Result<Self> {\n+        let bitmap_data = bitmap.map(|b| {\n+            let null_count = type_ids.len() - bit_util::count_set_bits(b.data());\n+            (b, null_count)\n+        });\n+\n+        if let Some(b) = &value_offsets {\n+            let nulls = match bitmap_data {\n+                Some((_, n)) => n,\n+                None => 0,\n+            };\n+            if ((type_ids.len() - nulls) * 4) != b.len() {\n+                return Err(ArrowError::InvalidArgumentError(\n+                    \"Type Ids and Offsets represent a different number of array slots.\"\n+                        .to_string(),\n+                ));\n+            }\n+        }\n+\n+        // Check the type_ids\n+        let type_id_slice: &[i8] = unsafe { type_ids.typed_data() };\n+        let invalid_type_ids = type_id_slice\n+            .iter()\n+            .filter(|i| *i < &0)\n+            .collect::<Vec<&i8>>();\n+        if invalid_type_ids.len() > 0 {\n+            return Err(ArrowError::InvalidArgumentError(format!(\n+                \"Type Ids must be positive and cannot be greater than the number of \\\n+                child arrays, found:\\n{:?}\",\n+                invalid_type_ids\n+            )));\n+        }\n+\n+        // Check the value offsets if provided\n+        if let Some(offset_buffer) = &value_offsets {\n+            let max_len = type_ids.len() as i32;\n+            let offsets_slice: &[i32] = unsafe { offset_buffer.typed_data() };\n+            let invalid_offsets = offsets_slice\n+                .iter()\n+                .filter(|i| *i < &0 || *i > &max_len)\n+                .collect::<Vec<&i32>>();\n+            if invalid_offsets.len() > 0 {\n+                return Err(ArrowError::InvalidArgumentError(format!(\n+                    \"Offsets must be positive and within the length of the Array, \\\n+                    found:\\n{:?}\",\n+                    invalid_offsets\n+                )));\n+            }\n+        }\n+\n+        Ok(Self::new(\n+            type_ids,\n+            value_offsets,\n+            child_arrays,\n+            bitmap_data,\n+        ))\n+    }\n+\n+    /// Accesses the child array for `type_id`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the `type_id` provided is less than zero or greater than the number of types\n+    /// in the `Union`.\n+    pub fn child(&self, type_id: i8) -> ArrayRef {\n+        assert!(0 <= type_id);\n+        assert!((type_id as usize) < self.boxed_fields.len());\n+        self.boxed_fields[type_id as usize].clone()\n+    }\n+\n+    /// Returns the `type_id` for the array slot at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn type_id(&self, index: usize) -> i8 {\n+        assert!(index - self.offset() < self.len());\n+        self.data().buffers()[0].data()[index] as i8\n+    }\n+\n+    /// Returns the offset into the underlying values array for the array slot at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn value_offset(&self, index: usize) -> i32 {\n+        assert!(index - self.offset() < self.len());\n+        if self.is_dense() {\n+            let valid_slots = match self.data.null_buffer() {\n+                Some(b) => bit_util::count_set_bits_offset(b.data(), 0, index),\n+                None => index,\n+            };\n+            self.data().buffers()[1].data()[valid_slots * size_of::<i32>()] as i32\n+        } else {\n+            index as i32\n+        }\n+    }\n+\n+    /// Returns the array's value at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn value(&self, index: usize) -> ArrayRef {\n+        let type_id = self.type_id(self.offset() + index);\n+        let value_offset = self.value_offset(self.offset() + index) as usize;\n+        let child_data = self.boxed_fields[type_id as usize].clone();\n+        child_data.slice(value_offset, 1)\n+    }\n+\n+    /// Returns the names of the types in the union.\n+    pub fn type_names(&self) -> Vec<&str> {\n+        match self.data.data_type() {\n+            DataType::Union(fields) => fields\n+                .iter()\n+                .map(|f| f.name().as_str())\n+                .collect::<Vec<&str>>(),\n+            _ => unreachable!(\"Union array's data type is not a union!\"),\n+        }\n+    }\n+\n+    /// Returns whether the `UnionArray` is dense (or sparse if `false`).\n+    fn is_dense(&self) -> bool {\n+        self.data().buffers().len() == 2\n+    }\n+}\n+\n+impl From<ArrayDataRef> for UnionArray {\n+    fn from(data: ArrayDataRef) -> Self {\n+        let mut boxed_fields = vec![];\n+        for cd in data.child_data() {\n+            boxed_fields.push(make_array(cd.clone()));\n+        }\n+        Self { data, boxed_fields }\n+    }\n+}\n+\n+impl Array for UnionArray {\n+    fn as_any(&self) -> &Any {\n+        self\n+    }\n+\n+    fn data(&self) -> ArrayDataRef {\n+        self.data.clone()\n+    }\n+\n+    fn data_ref(&self) -> &ArrayDataRef {\n+        &self.data\n+    }\n+}\n+\n+impl fmt::Debug for UnionArray {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let header = if self.is_dense() {\n+            \"UnionArray(Dense)\\n[\\n\"\n+        } else {\n+            \"UnionArray(Sparse)\\n[\\n\"\n+        };\n+        write!(f, \"{}\", header)?;\n+\n+        write!(f, \"-- type id buffer:\\n\")?;\n\nReview comment:\n       Yep, will update.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-04T18:53:00.631+0000",
                    "updated": "2020-05-04T18:53:00.631+0000",
                    "started": "2020-05-04T18:53:00.631+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "430358",
                    "issueId": "13199068"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13199068/worklog/430360",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paddyhoran commented on a change in pull request #7004:\nURL: https://github.com/apache/arrow/pull/7004#discussion_r419657778\n\n\n\n##########\nFile path: rust/arrow/src/array/union.rs\n##########\n@@ -0,0 +1,1174 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Contains the `UnionArray` and `UnionBuilder` types.\n+//!\n+//! Each slot in a `UnionArray` can have a value chosen from a number of types.  Each of the\n+//! possible types are named like the fields of a [`StructArray`](crate::array::StructArray).\n+//! A `UnionArray` can have two possible memory layouts, \"dense\" or \"sparse\".  For more information\n+//! on please see the [specification](https://arrow.apache.org/docs/format/Columnar.html#union-layout).\n+//!\n+//! Builders are provided for `UnionArray`'s involving primitive types.  `UnionArray`'s of nested\n+//! types are also supported but not via `UnionBuilder`, see the tests for examples.\n+//!\n+//! # Example: Dense Memory Layout\n+//!\n+//! ```\n+//! use arrow::array::UnionBuilder;\n+//! use arrow::datatypes::{Float64Type, Int32Type};\n+//!\n+//! # fn main() -> arrow::error::Result<()> {\n+//! let mut builder = UnionBuilder::new_dense(3);\n+//! builder.append::<Int32Type>(\"a\", 1).unwrap();\n+//! builder.append::<Float64Type>(\"b\", 3.0).unwrap();\n+//! builder.append::<Int32Type>(\"a\", 4).unwrap();\n+//! let union = builder.build().unwrap();\n+//!\n+//! assert_eq!(union.type_id(0), 0_i8);\n+//! assert_eq!(union.type_id(1), 1_i8);\n+//! assert_eq!(union.type_id(2), 0_i8);\n+//!\n+//! assert_eq!(union.value_offset(0), 0_i32);\n+//! assert_eq!(union.value_offset(1), 0_i32);\n+//! assert_eq!(union.value_offset(2), 1_i32);\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+//!\n+//! # Example: Sparse Memory Layout\n+//! ```\n+//! use arrow::array::UnionBuilder;\n+//! use arrow::datatypes::{Float64Type, Int32Type};\n+//!\n+//! # fn main() -> arrow::error::Result<()> {\n+//! let mut builder = UnionBuilder::new_sparse(3);\n+//! builder.append::<Int32Type>(\"a\", 1).unwrap();\n+//! builder.append::<Float64Type>(\"b\", 3.0).unwrap();\n+//! builder.append::<Int32Type>(\"a\", 4).unwrap();\n+//! let union = builder.build().unwrap();\n+//!\n+//! assert_eq!(union.type_id(0), 0_i8);\n+//! assert_eq!(union.type_id(1), 1_i8);\n+//! assert_eq!(union.type_id(2), 0_i8);\n+//!\n+//! assert_eq!(union.value_offset(0), 0_i32);\n+//! assert_eq!(union.value_offset(1), 1_i32);\n+//! assert_eq!(union.value_offset(2), 2_i32);\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+use crate::array::{\n+    builder::{builder_to_mutable_buffer, mutable_buffer_to_builder, BufferBuilderTrait},\n+    make_array, Array, ArrayData, ArrayDataBuilder, ArrayDataRef, ArrayRef,\n+    BooleanBufferBuilder, BufferBuilder, Int32BufferBuilder, Int8BufferBuilder,\n+};\n+use crate::buffer::{Buffer, MutableBuffer};\n+use crate::datatypes::*;\n+use crate::error::{ArrowError, Result};\n+\n+use crate::util::bit_util;\n+use core::fmt;\n+use std::any::Any;\n+use std::collections::HashMap;\n+use std::mem::size_of;\n+\n+/// An Array that can represent slots of varying types\n+pub struct UnionArray {\n+    data: ArrayDataRef,\n+    boxed_fields: Vec<ArrayRef>,\n+}\n+\n+impl UnionArray {\n+    /// Creates a new `UnionArray`.\n+    ///\n+    /// Accepts type ids, child arrays and optionally offsets (for dense unions) to create\n+    /// a new `UnionArray`.  This method makes no attempt to validate the data provided by the\n+    /// caller and assumes that each of the components are correct and consistent with each other.\n+    /// See `try_new` for an alternative that validates the data provided.\n+    ///\n+    /// # Data Consistency\n+    ///\n+    /// The `type_ids` `Buffer` should contain `i8` values.  These values should be greater than\n+    /// zero and must be less than the number of children provided in `child_arrays`.  These values\n+    /// are used to index into the `child_arrays`.\n+    ///\n+    /// The `value_offsets` `Buffer` is only provided in the case of a dense union, sparse unions\n+    /// should use `None`.  If provided the `value_offsets` `Buffer` should contain `i32` values.\n+    /// These values should be greater than zero and must be less than the length of the overall\n+    /// array.\n+    ///\n+    /// In both cases above we use signed integer types to maintain compatibility with other\n+    /// Arrow implementations.\n+    ///\n+    /// In both of the cases above we are accepting `Buffer`'s which are assumed to be representing\n+    /// `i8` and `i32` values respectively.  `Buffer` objects are untyped and no attempt is made\n+    /// to ensure that the data provided is valid.\n+    pub fn new(\n+        type_ids: Buffer,\n+        value_offsets: Option<Buffer>,\n+        child_arrays: Vec<(Field, ArrayRef)>,\n+        bitmap_data: Option<(Buffer, usize)>,\n+    ) -> Self {\n+        let (field_types, field_values): (Vec<_>, Vec<_>) =\n+            child_arrays.into_iter().unzip();\n+        let len = type_ids.len();\n+        let mut builder = ArrayData::builder(DataType::Union(field_types))\n+            .add_buffer(type_ids)\n+            .child_data(field_values.into_iter().map(|a| a.data()).collect())\n+            .len(len);\n+        if let Some((bitmap, null_count)) = bitmap_data {\n+            builder = builder.null_bit_buffer(bitmap).null_count(null_count);\n+        }\n+        let data = match value_offsets {\n+            Some(b) => builder.add_buffer(b).build(),\n+            None => builder.build(),\n+        };\n+        Self::from(data)\n+    }\n+    /// Attempts to create a new `UnionArray` and validates the inputs provided.\n+    pub fn try_new(\n+        type_ids: Buffer,\n+        value_offsets: Option<Buffer>,\n+        child_arrays: Vec<(Field, ArrayRef)>,\n+        bitmap: Option<Buffer>,\n+    ) -> Result<Self> {\n+        let bitmap_data = bitmap.map(|b| {\n+            let null_count = type_ids.len() - bit_util::count_set_bits(b.data());\n+            (b, null_count)\n+        });\n+\n+        if let Some(b) = &value_offsets {\n+            let nulls = match bitmap_data {\n+                Some((_, n)) => n,\n+                None => 0,\n+            };\n+            if ((type_ids.len() - nulls) * 4) != b.len() {\n+                return Err(ArrowError::InvalidArgumentError(\n+                    \"Type Ids and Offsets represent a different number of array slots.\"\n+                        .to_string(),\n+                ));\n+            }\n+        }\n+\n+        // Check the type_ids\n+        let type_id_slice: &[i8] = unsafe { type_ids.typed_data() };\n+        let invalid_type_ids = type_id_slice\n+            .iter()\n+            .filter(|i| *i < &0)\n+            .collect::<Vec<&i8>>();\n+        if invalid_type_ids.len() > 0 {\n+            return Err(ArrowError::InvalidArgumentError(format!(\n+                \"Type Ids must be positive and cannot be greater than the number of \\\n+                child arrays, found:\\n{:?}\",\n+                invalid_type_ids\n+            )));\n+        }\n+\n+        // Check the value offsets if provided\n+        if let Some(offset_buffer) = &value_offsets {\n+            let max_len = type_ids.len() as i32;\n+            let offsets_slice: &[i32] = unsafe { offset_buffer.typed_data() };\n+            let invalid_offsets = offsets_slice\n+                .iter()\n+                .filter(|i| *i < &0 || *i > &max_len)\n+                .collect::<Vec<&i32>>();\n+            if invalid_offsets.len() > 0 {\n+                return Err(ArrowError::InvalidArgumentError(format!(\n+                    \"Offsets must be positive and within the length of the Array, \\\n+                    found:\\n{:?}\",\n+                    invalid_offsets\n+                )));\n+            }\n+        }\n+\n+        Ok(Self::new(\n+            type_ids,\n+            value_offsets,\n+            child_arrays,\n+            bitmap_data,\n+        ))\n+    }\n+\n+    /// Accesses the child array for `type_id`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the `type_id` provided is less than zero or greater than the number of types\n+    /// in the `Union`.\n+    pub fn child(&self, type_id: i8) -> ArrayRef {\n+        assert!(0 <= type_id);\n+        assert!((type_id as usize) < self.boxed_fields.len());\n+        self.boxed_fields[type_id as usize].clone()\n+    }\n+\n+    /// Returns the `type_id` for the array slot at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn type_id(&self, index: usize) -> i8 {\n+        assert!(index - self.offset() < self.len());\n+        self.data().buffers()[0].data()[index] as i8\n+    }\n+\n+    /// Returns the offset into the underlying values array for the array slot at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn value_offset(&self, index: usize) -> i32 {\n+        assert!(index - self.offset() < self.len());\n+        if self.is_dense() {\n+            let valid_slots = match self.data.null_buffer() {\n+                Some(b) => bit_util::count_set_bits_offset(b.data(), 0, index),\n+                None => index,\n+            };\n+            self.data().buffers()[1].data()[valid_slots * size_of::<i32>()] as i32\n+        } else {\n+            index as i32\n+        }\n+    }\n+\n+    /// Returns the array's value at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn value(&self, index: usize) -> ArrayRef {\n+        let type_id = self.type_id(self.offset() + index);\n+        let value_offset = self.value_offset(self.offset() + index) as usize;\n+        let child_data = self.boxed_fields[type_id as usize].clone();\n+        child_data.slice(value_offset, 1)\n+    }\n+\n+    /// Returns the names of the types in the union.\n+    pub fn type_names(&self) -> Vec<&str> {\n+        match self.data.data_type() {\n+            DataType::Union(fields) => fields\n+                .iter()\n+                .map(|f| f.name().as_str())\n+                .collect::<Vec<&str>>(),\n+            _ => unreachable!(\"Union array's data type is not a union!\"),\n+        }\n+    }\n+\n+    /// Returns whether the `UnionArray` is dense (or sparse if `false`).\n+    fn is_dense(&self) -> bool {\n+        self.data().buffers().len() == 2\n+    }\n+}\n+\n+impl From<ArrayDataRef> for UnionArray {\n+    fn from(data: ArrayDataRef) -> Self {\n+        let mut boxed_fields = vec![];\n+        for cd in data.child_data() {\n+            boxed_fields.push(make_array(cd.clone()));\n+        }\n+        Self { data, boxed_fields }\n+    }\n+}\n+\n+impl Array for UnionArray {\n+    fn as_any(&self) -> &Any {\n+        self\n+    }\n+\n+    fn data(&self) -> ArrayDataRef {\n+        self.data.clone()\n+    }\n+\n+    fn data_ref(&self) -> &ArrayDataRef {\n+        &self.data\n+    }\n+}\n+\n+impl fmt::Debug for UnionArray {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let header = if self.is_dense() {\n+            \"UnionArray(Dense)\\n[\\n\"\n+        } else {\n+            \"UnionArray(Sparse)\\n[\\n\"\n+        };\n+        write!(f, \"{}\", header)?;\n+\n+        write!(f, \"-- type id buffer:\\n\")?;\n+        write!(f, \"{:?}\\n\", self.data().buffers()[0])?;\n+\n+        if self.is_dense() {\n+            write!(f, \"-- offsets buffer:\\n\")?;\n+            write!(f, \"{:?}\\n\", self.data().buffers()[1])?;\n+        }\n+\n+        for (child_index, name) in self.type_names().iter().enumerate() {\n+            let column = &self.boxed_fields[child_index];\n+            write!(\n+                f,\n+                \"-- child {}: \\\"{}\\\" ({:?})\\n\",\n+                child_index,\n+                *name,\n+                column.data_type()\n+            )?;\n+            fmt::Debug::fmt(column, f)?;\n+            write!(f, \"\\n\")?;\n+        }\n+        write!(f, \"]\")\n+    }\n+}\n+\n+/// `FieldData` is a helper struct to track the state of the fields in the `UnionBuilder`.\n+struct FieldData {\n+    /// The type id for this field\n+    type_id: i8,\n+    /// The Arrow data type represented in the `values_buffer`, which is untyped\n+    data_type: DataType,\n+    /// A buffer containing the values for this field in raw bytes\n+    values_buffer: Option<MutableBuffer>,\n+    ///  The number of array slots represented by the buffer\n+    slots: usize,\n+    /// The number of null array slots in this child array\n+    null_count: usize,\n+    /// A builder for the bitmap if required\n+    bitmap_builder: Option<BooleanBufferBuilder>,\n+}\n+\n+impl FieldData {\n+    /// Creates a new `FieldData`.\n+    fn new(\n+        type_id: i8,\n+        data_type: DataType,\n+        bitmap_builder: Option<BooleanBufferBuilder>,\n+    ) -> Self {\n+        Self {\n+            type_id,\n+            data_type,\n+            // TODO: Should `MutableBuffer` implement `Default`?\n+            values_buffer: Some(MutableBuffer::new(1)),\n+            slots: 0,\n+            null_count: 0,\n+            bitmap_builder,\n+        }\n+    }\n+\n+    /// Appends a single value to this `FieldData`'s `values_buffer`.\n+    fn append_to_values_buffer<T: ArrowPrimitiveType>(\n+        &mut self,\n+        v: T::Native,\n+    ) -> Result<()> {\n+        let values_buffer = self\n+            .values_buffer\n+            .take()\n+            .expect(\"Values buffer was never created\");\n+        let mut builder: BufferBuilder<T> =\n+            mutable_buffer_to_builder(values_buffer, self.slots);\n+        builder.append(v)?;\n+        let mutable_buffer = builder_to_mutable_buffer(builder);\n+        self.values_buffer = Some(mutable_buffer);\n+\n+        self.slots += 1;\n+        if let Some(b) = &mut self.bitmap_builder {\n+            b.append(true)?\n+        };\n+        Ok(())\n+    }\n+\n+    /// Appends a null to this `FieldData`.\n+    fn append_null<T: ArrowPrimitiveType>(&mut self) -> Result<()> {\n+        if let Some(b) = &mut self.bitmap_builder {\n+            let values_buffer = self\n+                .values_buffer\n+                .take()\n+                .expect(\"Values buffer was never created\");\n+            let mut builder: BufferBuilder<T> =\n+                mutable_buffer_to_builder(values_buffer, self.slots);\n+            builder.advance(1)?;\n+            let mutable_buffer = builder_to_mutable_buffer(builder);\n+            self.values_buffer = Some(mutable_buffer);\n+            self.slots += 1;\n+            b.append(false)?;\n+        };\n+        Ok(())\n+    }\n+\n+    /// Appends a null to this `FieldData` when the type is not known at compile time.\n+    ///\n+    /// As the main `append` method of `UnionBuilder` is generic, we need a way to append null\n+    /// slots to the fields that are not being appended to in the case of sparse unions.  This\n+    /// method solves this problem by appending dynamically based on `DataType`.\n+    ///\n+    /// Note, this method does **not** update the length of the `UnionArray` (this is done by the\n+    /// main append operation) and assumes that it is called from a method that is generic over `T`\n+    /// where `T` satisfies the bound `ArrowPrimitiveType`.\n+    fn append_null_dynamic(&mut self) -> Result<()> {\n+        match self.data_type {\n+            DataType::Boolean => self.append_null::<BooleanType>()?,\n+            DataType::Int8 => self.append_null::<Int8Type>()?,\n+            DataType::Int16 => self.append_null::<Int16Type>()?,\n+            DataType::Int32\n+            | DataType::Date32(_)\n+            | DataType::Time32(_)\n+            | DataType::Interval(IntervalUnit::YearMonth) => {\n+                self.append_null::<Int32Type>()?\n+            }\n+            DataType::Int64\n+            | DataType::Timestamp(_, _)\n+            | DataType::Date64(_)\n+            | DataType::Time64(_)\n+            | DataType::Interval(IntervalUnit::DayTime)\n+            | DataType::Duration(_) => self.append_null::<Int64Type>()?,\n+            DataType::UInt8 => self.append_null::<UInt8Type>()?,\n+            DataType::UInt16 => self.append_null::<UInt16Type>()?,\n+            DataType::UInt32 => self.append_null::<UInt32Type>()?,\n+            DataType::UInt64 => self.append_null::<UInt64Type>()?,\n+            DataType::Float32 => self.append_null::<Float32Type>()?,\n+            DataType::Float64 => self.append_null::<Float64Type>()?,\n+            _ => unreachable!(\"All cases of types that satisfy the trait bounds over T are covered above.\"),\n+        };\n+        Ok(())\n+    }\n+}\n+\n+/// Builder type for creating a new `UnionArray`.\n+pub struct UnionBuilder {\n+    /// The current number of slots in the array\n+    len: usize,\n+    /// Maps field names to `FieldData` instances which track the builders for that field\n+    fields: HashMap<String, FieldData>,\n+    /// Builder to keep track of type ids\n+    type_id_builder: Int8BufferBuilder,\n+    /// Builder to keep track of offsets (`None` for sparse unions)\n+    value_offset_builder: Option<Int32BufferBuilder>,\n+    /// Optional builder for null slots\n+    bitmap_builder: Option<BooleanBufferBuilder>,\n+}\n+\n+impl UnionBuilder {\n+    /// Creates a new dense array builder.\n+    pub fn new_dense(capacity: usize) -> Self {\n+        Self {\n+            len: 0,\n+            fields: HashMap::default(),\n+            type_id_builder: Int8BufferBuilder::new(capacity),\n+            value_offset_builder: Some(Int32BufferBuilder::new(capacity)),\n+            bitmap_builder: None,\n+        }\n+    }\n+\n+    /// Creates a new sparse array builder.\n+    pub fn new_sparse(capacity: usize) -> Self {\n+        Self {\n+            len: 0,\n+            fields: HashMap::default(),\n+            type_id_builder: Int8BufferBuilder::new(capacity),\n+            value_offset_builder: None,\n+            bitmap_builder: None,\n+        }\n+    }\n+\n+    /// Appends a null to this builder.\n+    pub fn append_null(&mut self) -> Result<()> {\n+        if let None = self.bitmap_builder {\n\nReview comment:\n       Yes, I delay creating builder until the first null is appended.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-04T18:59:35.836+0000",
                    "updated": "2020-05-04T18:59:35.836+0000",
                    "started": "2020-05-04T18:59:35.836+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "430360",
                    "issueId": "13199068"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13199068/worklog/430362",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paddyhoran commented on a change in pull request #7004:\nURL: https://github.com/apache/arrow/pull/7004#discussion_r419658264\n\n\n\n##########\nFile path: rust/arrow/src/array/union.rs\n##########\n@@ -0,0 +1,1174 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Contains the `UnionArray` and `UnionBuilder` types.\n+//!\n+//! Each slot in a `UnionArray` can have a value chosen from a number of types.  Each of the\n+//! possible types are named like the fields of a [`StructArray`](crate::array::StructArray).\n+//! A `UnionArray` can have two possible memory layouts, \"dense\" or \"sparse\".  For more information\n+//! on please see the [specification](https://arrow.apache.org/docs/format/Columnar.html#union-layout).\n+//!\n+//! Builders are provided for `UnionArray`'s involving primitive types.  `UnionArray`'s of nested\n+//! types are also supported but not via `UnionBuilder`, see the tests for examples.\n+//!\n+//! # Example: Dense Memory Layout\n+//!\n+//! ```\n+//! use arrow::array::UnionBuilder;\n+//! use arrow::datatypes::{Float64Type, Int32Type};\n+//!\n+//! # fn main() -> arrow::error::Result<()> {\n+//! let mut builder = UnionBuilder::new_dense(3);\n+//! builder.append::<Int32Type>(\"a\", 1).unwrap();\n+//! builder.append::<Float64Type>(\"b\", 3.0).unwrap();\n+//! builder.append::<Int32Type>(\"a\", 4).unwrap();\n+//! let union = builder.build().unwrap();\n+//!\n+//! assert_eq!(union.type_id(0), 0_i8);\n+//! assert_eq!(union.type_id(1), 1_i8);\n+//! assert_eq!(union.type_id(2), 0_i8);\n+//!\n+//! assert_eq!(union.value_offset(0), 0_i32);\n+//! assert_eq!(union.value_offset(1), 0_i32);\n+//! assert_eq!(union.value_offset(2), 1_i32);\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+//!\n+//! # Example: Sparse Memory Layout\n+//! ```\n+//! use arrow::array::UnionBuilder;\n+//! use arrow::datatypes::{Float64Type, Int32Type};\n+//!\n+//! # fn main() -> arrow::error::Result<()> {\n+//! let mut builder = UnionBuilder::new_sparse(3);\n+//! builder.append::<Int32Type>(\"a\", 1).unwrap();\n+//! builder.append::<Float64Type>(\"b\", 3.0).unwrap();\n+//! builder.append::<Int32Type>(\"a\", 4).unwrap();\n+//! let union = builder.build().unwrap();\n+//!\n+//! assert_eq!(union.type_id(0), 0_i8);\n+//! assert_eq!(union.type_id(1), 1_i8);\n+//! assert_eq!(union.type_id(2), 0_i8);\n+//!\n+//! assert_eq!(union.value_offset(0), 0_i32);\n+//! assert_eq!(union.value_offset(1), 1_i32);\n+//! assert_eq!(union.value_offset(2), 2_i32);\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+use crate::array::{\n+    builder::{builder_to_mutable_buffer, mutable_buffer_to_builder, BufferBuilderTrait},\n+    make_array, Array, ArrayData, ArrayDataBuilder, ArrayDataRef, ArrayRef,\n+    BooleanBufferBuilder, BufferBuilder, Int32BufferBuilder, Int8BufferBuilder,\n+};\n+use crate::buffer::{Buffer, MutableBuffer};\n+use crate::datatypes::*;\n+use crate::error::{ArrowError, Result};\n+\n+use crate::util::bit_util;\n+use core::fmt;\n+use std::any::Any;\n+use std::collections::HashMap;\n+use std::mem::size_of;\n+\n+/// An Array that can represent slots of varying types\n+pub struct UnionArray {\n+    data: ArrayDataRef,\n+    boxed_fields: Vec<ArrayRef>,\n+}\n+\n+impl UnionArray {\n+    /// Creates a new `UnionArray`.\n+    ///\n+    /// Accepts type ids, child arrays and optionally offsets (for dense unions) to create\n+    /// a new `UnionArray`.  This method makes no attempt to validate the data provided by the\n+    /// caller and assumes that each of the components are correct and consistent with each other.\n+    /// See `try_new` for an alternative that validates the data provided.\n+    ///\n+    /// # Data Consistency\n+    ///\n+    /// The `type_ids` `Buffer` should contain `i8` values.  These values should be greater than\n+    /// zero and must be less than the number of children provided in `child_arrays`.  These values\n+    /// are used to index into the `child_arrays`.\n+    ///\n+    /// The `value_offsets` `Buffer` is only provided in the case of a dense union, sparse unions\n+    /// should use `None`.  If provided the `value_offsets` `Buffer` should contain `i32` values.\n+    /// These values should be greater than zero and must be less than the length of the overall\n+    /// array.\n+    ///\n+    /// In both cases above we use signed integer types to maintain compatibility with other\n+    /// Arrow implementations.\n+    ///\n+    /// In both of the cases above we are accepting `Buffer`'s which are assumed to be representing\n+    /// `i8` and `i32` values respectively.  `Buffer` objects are untyped and no attempt is made\n+    /// to ensure that the data provided is valid.\n+    pub fn new(\n+        type_ids: Buffer,\n+        value_offsets: Option<Buffer>,\n+        child_arrays: Vec<(Field, ArrayRef)>,\n+        bitmap_data: Option<(Buffer, usize)>,\n+    ) -> Self {\n+        let (field_types, field_values): (Vec<_>, Vec<_>) =\n+            child_arrays.into_iter().unzip();\n+        let len = type_ids.len();\n+        let mut builder = ArrayData::builder(DataType::Union(field_types))\n+            .add_buffer(type_ids)\n+            .child_data(field_values.into_iter().map(|a| a.data()).collect())\n+            .len(len);\n+        if let Some((bitmap, null_count)) = bitmap_data {\n+            builder = builder.null_bit_buffer(bitmap).null_count(null_count);\n+        }\n+        let data = match value_offsets {\n+            Some(b) => builder.add_buffer(b).build(),\n+            None => builder.build(),\n+        };\n+        Self::from(data)\n+    }\n+    /// Attempts to create a new `UnionArray` and validates the inputs provided.\n+    pub fn try_new(\n+        type_ids: Buffer,\n+        value_offsets: Option<Buffer>,\n+        child_arrays: Vec<(Field, ArrayRef)>,\n+        bitmap: Option<Buffer>,\n+    ) -> Result<Self> {\n+        let bitmap_data = bitmap.map(|b| {\n+            let null_count = type_ids.len() - bit_util::count_set_bits(b.data());\n+            (b, null_count)\n+        });\n+\n+        if let Some(b) = &value_offsets {\n+            let nulls = match bitmap_data {\n+                Some((_, n)) => n,\n+                None => 0,\n+            };\n+            if ((type_ids.len() - nulls) * 4) != b.len() {\n+                return Err(ArrowError::InvalidArgumentError(\n+                    \"Type Ids and Offsets represent a different number of array slots.\"\n+                        .to_string(),\n+                ));\n+            }\n+        }\n+\n+        // Check the type_ids\n+        let type_id_slice: &[i8] = unsafe { type_ids.typed_data() };\n+        let invalid_type_ids = type_id_slice\n+            .iter()\n+            .filter(|i| *i < &0)\n+            .collect::<Vec<&i8>>();\n+        if invalid_type_ids.len() > 0 {\n+            return Err(ArrowError::InvalidArgumentError(format!(\n+                \"Type Ids must be positive and cannot be greater than the number of \\\n+                child arrays, found:\\n{:?}\",\n+                invalid_type_ids\n+            )));\n+        }\n+\n+        // Check the value offsets if provided\n+        if let Some(offset_buffer) = &value_offsets {\n+            let max_len = type_ids.len() as i32;\n+            let offsets_slice: &[i32] = unsafe { offset_buffer.typed_data() };\n+            let invalid_offsets = offsets_slice\n+                .iter()\n+                .filter(|i| *i < &0 || *i > &max_len)\n+                .collect::<Vec<&i32>>();\n+            if invalid_offsets.len() > 0 {\n+                return Err(ArrowError::InvalidArgumentError(format!(\n+                    \"Offsets must be positive and within the length of the Array, \\\n+                    found:\\n{:?}\",\n+                    invalid_offsets\n+                )));\n+            }\n+        }\n+\n+        Ok(Self::new(\n+            type_ids,\n+            value_offsets,\n+            child_arrays,\n+            bitmap_data,\n+        ))\n+    }\n+\n+    /// Accesses the child array for `type_id`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the `type_id` provided is less than zero or greater than the number of types\n+    /// in the `Union`.\n+    pub fn child(&self, type_id: i8) -> ArrayRef {\n+        assert!(0 <= type_id);\n+        assert!((type_id as usize) < self.boxed_fields.len());\n+        self.boxed_fields[type_id as usize].clone()\n+    }\n+\n+    /// Returns the `type_id` for the array slot at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn type_id(&self, index: usize) -> i8 {\n+        assert!(index - self.offset() < self.len());\n+        self.data().buffers()[0].data()[index] as i8\n+    }\n+\n+    /// Returns the offset into the underlying values array for the array slot at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn value_offset(&self, index: usize) -> i32 {\n+        assert!(index - self.offset() < self.len());\n+        if self.is_dense() {\n+            let valid_slots = match self.data.null_buffer() {\n+                Some(b) => bit_util::count_set_bits_offset(b.data(), 0, index),\n+                None => index,\n+            };\n+            self.data().buffers()[1].data()[valid_slots * size_of::<i32>()] as i32\n+        } else {\n+            index as i32\n+        }\n+    }\n+\n+    /// Returns the array's value at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn value(&self, index: usize) -> ArrayRef {\n+        let type_id = self.type_id(self.offset() + index);\n+        let value_offset = self.value_offset(self.offset() + index) as usize;\n+        let child_data = self.boxed_fields[type_id as usize].clone();\n+        child_data.slice(value_offset, 1)\n+    }\n+\n+    /// Returns the names of the types in the union.\n+    pub fn type_names(&self) -> Vec<&str> {\n+        match self.data.data_type() {\n+            DataType::Union(fields) => fields\n+                .iter()\n+                .map(|f| f.name().as_str())\n+                .collect::<Vec<&str>>(),\n+            _ => unreachable!(\"Union array's data type is not a union!\"),\n+        }\n+    }\n+\n+    /// Returns whether the `UnionArray` is dense (or sparse if `false`).\n+    fn is_dense(&self) -> bool {\n+        self.data().buffers().len() == 2\n+    }\n+}\n+\n+impl From<ArrayDataRef> for UnionArray {\n+    fn from(data: ArrayDataRef) -> Self {\n+        let mut boxed_fields = vec![];\n+        for cd in data.child_data() {\n+            boxed_fields.push(make_array(cd.clone()));\n+        }\n+        Self { data, boxed_fields }\n+    }\n+}\n+\n+impl Array for UnionArray {\n+    fn as_any(&self) -> &Any {\n+        self\n+    }\n+\n+    fn data(&self) -> ArrayDataRef {\n+        self.data.clone()\n+    }\n+\n+    fn data_ref(&self) -> &ArrayDataRef {\n+        &self.data\n+    }\n+}\n+\n+impl fmt::Debug for UnionArray {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let header = if self.is_dense() {\n+            \"UnionArray(Dense)\\n[\\n\"\n+        } else {\n+            \"UnionArray(Sparse)\\n[\\n\"\n+        };\n+        write!(f, \"{}\", header)?;\n+\n+        write!(f, \"-- type id buffer:\\n\")?;\n+        write!(f, \"{:?}\\n\", self.data().buffers()[0])?;\n+\n+        if self.is_dense() {\n+            write!(f, \"-- offsets buffer:\\n\")?;\n+            write!(f, \"{:?}\\n\", self.data().buffers()[1])?;\n+        }\n+\n+        for (child_index, name) in self.type_names().iter().enumerate() {\n+            let column = &self.boxed_fields[child_index];\n+            write!(\n+                f,\n+                \"-- child {}: \\\"{}\\\" ({:?})\\n\",\n+                child_index,\n+                *name,\n+                column.data_type()\n+            )?;\n+            fmt::Debug::fmt(column, f)?;\n+            write!(f, \"\\n\")?;\n+        }\n+        write!(f, \"]\")\n+    }\n+}\n+\n+/// `FieldData` is a helper struct to track the state of the fields in the `UnionBuilder`.\n+struct FieldData {\n+    /// The type id for this field\n+    type_id: i8,\n+    /// The Arrow data type represented in the `values_buffer`, which is untyped\n+    data_type: DataType,\n+    /// A buffer containing the values for this field in raw bytes\n+    values_buffer: Option<MutableBuffer>,\n+    ///  The number of array slots represented by the buffer\n+    slots: usize,\n+    /// The number of null array slots in this child array\n+    null_count: usize,\n+    /// A builder for the bitmap if required\n+    bitmap_builder: Option<BooleanBufferBuilder>,\n+}\n+\n+impl FieldData {\n+    /// Creates a new `FieldData`.\n+    fn new(\n+        type_id: i8,\n+        data_type: DataType,\n+        bitmap_builder: Option<BooleanBufferBuilder>,\n+    ) -> Self {\n+        Self {\n+            type_id,\n+            data_type,\n+            // TODO: Should `MutableBuffer` implement `Default`?\n+            values_buffer: Some(MutableBuffer::new(1)),\n+            slots: 0,\n+            null_count: 0,\n+            bitmap_builder,\n+        }\n+    }\n+\n+    /// Appends a single value to this `FieldData`'s `values_buffer`.\n+    fn append_to_values_buffer<T: ArrowPrimitiveType>(\n+        &mut self,\n+        v: T::Native,\n+    ) -> Result<()> {\n+        let values_buffer = self\n+            .values_buffer\n+            .take()\n+            .expect(\"Values buffer was never created\");\n+        let mut builder: BufferBuilder<T> =\n+            mutable_buffer_to_builder(values_buffer, self.slots);\n+        builder.append(v)?;\n+        let mutable_buffer = builder_to_mutable_buffer(builder);\n+        self.values_buffer = Some(mutable_buffer);\n+\n+        self.slots += 1;\n+        if let Some(b) = &mut self.bitmap_builder {\n+            b.append(true)?\n+        };\n+        Ok(())\n+    }\n+\n+    /// Appends a null to this `FieldData`.\n+    fn append_null<T: ArrowPrimitiveType>(&mut self) -> Result<()> {\n+        if let Some(b) = &mut self.bitmap_builder {\n+            let values_buffer = self\n+                .values_buffer\n+                .take()\n+                .expect(\"Values buffer was never created\");\n+            let mut builder: BufferBuilder<T> =\n+                mutable_buffer_to_builder(values_buffer, self.slots);\n+            builder.advance(1)?;\n+            let mutable_buffer = builder_to_mutable_buffer(builder);\n+            self.values_buffer = Some(mutable_buffer);\n+            self.slots += 1;\n+            b.append(false)?;\n+        };\n+        Ok(())\n+    }\n+\n+    /// Appends a null to this `FieldData` when the type is not known at compile time.\n+    ///\n+    /// As the main `append` method of `UnionBuilder` is generic, we need a way to append null\n+    /// slots to the fields that are not being appended to in the case of sparse unions.  This\n+    /// method solves this problem by appending dynamically based on `DataType`.\n+    ///\n+    /// Note, this method does **not** update the length of the `UnionArray` (this is done by the\n+    /// main append operation) and assumes that it is called from a method that is generic over `T`\n+    /// where `T` satisfies the bound `ArrowPrimitiveType`.\n+    fn append_null_dynamic(&mut self) -> Result<()> {\n+        match self.data_type {\n+            DataType::Boolean => self.append_null::<BooleanType>()?,\n+            DataType::Int8 => self.append_null::<Int8Type>()?,\n+            DataType::Int16 => self.append_null::<Int16Type>()?,\n+            DataType::Int32\n+            | DataType::Date32(_)\n+            | DataType::Time32(_)\n+            | DataType::Interval(IntervalUnit::YearMonth) => {\n+                self.append_null::<Int32Type>()?\n+            }\n+            DataType::Int64\n+            | DataType::Timestamp(_, _)\n+            | DataType::Date64(_)\n+            | DataType::Time64(_)\n+            | DataType::Interval(IntervalUnit::DayTime)\n+            | DataType::Duration(_) => self.append_null::<Int64Type>()?,\n+            DataType::UInt8 => self.append_null::<UInt8Type>()?,\n+            DataType::UInt16 => self.append_null::<UInt16Type>()?,\n+            DataType::UInt32 => self.append_null::<UInt32Type>()?,\n+            DataType::UInt64 => self.append_null::<UInt64Type>()?,\n+            DataType::Float32 => self.append_null::<Float32Type>()?,\n+            DataType::Float64 => self.append_null::<Float64Type>()?,\n+            _ => unreachable!(\"All cases of types that satisfy the trait bounds over T are covered above.\"),\n+        };\n+        Ok(())\n+    }\n+}\n+\n+/// Builder type for creating a new `UnionArray`.\n+pub struct UnionBuilder {\n+    /// The current number of slots in the array\n+    len: usize,\n+    /// Maps field names to `FieldData` instances which track the builders for that field\n+    fields: HashMap<String, FieldData>,\n+    /// Builder to keep track of type ids\n+    type_id_builder: Int8BufferBuilder,\n+    /// Builder to keep track of offsets (`None` for sparse unions)\n+    value_offset_builder: Option<Int32BufferBuilder>,\n+    /// Optional builder for null slots\n+    bitmap_builder: Option<BooleanBufferBuilder>,\n+}\n+\n+impl UnionBuilder {\n+    /// Creates a new dense array builder.\n+    pub fn new_dense(capacity: usize) -> Self {\n+        Self {\n+            len: 0,\n+            fields: HashMap::default(),\n+            type_id_builder: Int8BufferBuilder::new(capacity),\n+            value_offset_builder: Some(Int32BufferBuilder::new(capacity)),\n+            bitmap_builder: None,\n+        }\n+    }\n+\n+    /// Creates a new sparse array builder.\n+    pub fn new_sparse(capacity: usize) -> Self {\n+        Self {\n+            len: 0,\n+            fields: HashMap::default(),\n+            type_id_builder: Int8BufferBuilder::new(capacity),\n+            value_offset_builder: None,\n+            bitmap_builder: None,\n+        }\n+    }\n+\n+    /// Appends a null to this builder.\n+    pub fn append_null(&mut self) -> Result<()> {\n+        if let None = self.bitmap_builder {\n+            let mut builder = BooleanBufferBuilder::new(self.len + 1);\n+            for _ in 0..self.len {\n+                builder.append(true)?;\n+            }\n+            self.bitmap_builder = Some(builder)\n+        }\n+        self.bitmap_builder\n+            .as_mut()\n+            .expect(\"Cannot be None\")\n+            .append(false)?;\n+\n+        self.type_id_builder.append(i8::default())?;\n+\n+        // Handle sparse union\n+        if let None = self.value_offset_builder {\n+            for (_, fd) in self.fields.iter_mut() {\n+                fd.append_null_dynamic()?;\n+            }\n+        }\n+        self.len += 1;\n+        Ok(())\n+    }\n+\n+    /// Appends a value to this builder.\n+    pub fn append<T: ArrowPrimitiveType>(\n+        &mut self,\n+        type_name: &str,\n+        v: T::Native,\n+    ) -> Result<()> {\n+        let type_name = type_name.to_string();\n+\n+        let mut field_data = match self.fields.remove(&type_name) {\n+            Some(data) => data,\n+            None => {\n+                let field_data = match self.value_offset_builder {\n+                    Some(_) => {\n+                        FieldData::new(self.fields.len() as i8, T::get_data_type(), None)\n+                    }\n+                    None => {\n+                        let mut fd = FieldData::new(\n+                            self.fields.len() as i8,\n+                            T::get_data_type(),\n+                            Some(BooleanBufferBuilder::new(1)),\n+                        );\n+                        for _ in 0..self.len {\n+                            fd.append_null::<T>()?;\n+                        }\n+                        fd\n+                    }\n+                };\n+                field_data\n+            }\n+        };\n+        self.type_id_builder.append(field_data.type_id)?;\n+\n+        match &mut self.value_offset_builder {\n+            // Dense Union\n+            Some(offset_builder) => {\n+                offset_builder.append(field_data.slots as i32)?;\n+            }\n+            // Sparse Union\n+            None => {\n+                for (name, fd) in self.fields.iter_mut() {\n+                    if name != &type_name {\n+                        fd.append_null_dynamic()?;\n+                    }\n+                }\n+            }\n+        }\n+        field_data.append_to_values_buffer::<T>(v)?;\n+        self.fields.insert(type_name, field_data);\n+\n+        // Update the bitmap builder if it exists\n+        if let Some(b) = &mut self.bitmap_builder {\n+            b.append(true)?;\n+        }\n+        self.len += 1;\n+        Ok(())\n+    }\n+\n+    /// Builds this builder creating a new `UnionArray`.\n+    pub fn build(mut self) -> Result<UnionArray> {\n+        let type_id_buffer = self.type_id_builder.finish();\n+        let value_offsets_buffer = self.value_offset_builder.map(|mut b| b.finish());\n+        let mut children = Vec::new();\n+        for (\n+            name,\n+            FieldData {\n+                type_id,\n+                data_type,\n+                values_buffer,\n+                slots,\n+                bitmap_builder,\n+                null_count,\n+            },\n+        ) in self.fields.into_iter()\n+        {\n+            let buffer = values_buffer.expect(\"UPDATE LATER\").freeze();\n\nReview comment:\n       Oh man.  Sorry about that, will fix.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-04T19:00:12.622+0000",
                    "updated": "2020-05-04T19:00:12.622+0000",
                    "started": "2020-05-04T19:00:12.622+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "430362",
                    "issueId": "13199068"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13199068/worklog/431378",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paddyhoran commented on a change in pull request #7004:\nURL: https://github.com/apache/arrow/pull/7004#discussion_r421036704\n\n\n\n##########\nFile path: rust/arrow/src/buffer.rs\n##########\n@@ -568,6 +568,25 @@ impl MutableBuffer {\n     }\n }\n \n+impl MutableBuffer {\n+    /// Writes a byte slice to the underlying buffer and updates the `len`, i.e. the\n+    /// number array elements in the builder.  Also, converts the `io::Result`\n+    /// required by the `Write` trait to the Arrow `Result` type.\n+    pub fn write_bytes(&mut self, bytes: &[u8], len_added: usize) -> Result<()> {\n+        let write_result = self.write(bytes);\n+        // `io::Result` has many options one of which we use, so pattern matching is\n+        // overkill here\n+        if write_result.is_err() {\n+            Err(ArrowError::MemoryError(\n\nReview comment:\n       I'm fine with `IoError`, will change.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-06T19:25:13.927+0000",
                    "updated": "2020-05-06T19:25:13.927+0000",
                    "started": "2020-05-06T19:25:13.926+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "431378",
                    "issueId": "13199068"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13199068/worklog/431380",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paddyhoran commented on a change in pull request #7004:\nURL: https://github.com/apache/arrow/pull/7004#discussion_r421038622\n\n\n\n##########\nFile path: rust/arrow/src/array/union.rs\n##########\n@@ -0,0 +1,1174 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Contains the `UnionArray` and `UnionBuilder` types.\n+//!\n+//! Each slot in a `UnionArray` can have a value chosen from a number of types.  Each of the\n+//! possible types are named like the fields of a [`StructArray`](crate::array::StructArray).\n+//! A `UnionArray` can have two possible memory layouts, \"dense\" or \"sparse\".  For more information\n+//! on please see the [specification](https://arrow.apache.org/docs/format/Columnar.html#union-layout).\n+//!\n+//! Builders are provided for `UnionArray`'s involving primitive types.  `UnionArray`'s of nested\n+//! types are also supported but not via `UnionBuilder`, see the tests for examples.\n+//!\n+//! # Example: Dense Memory Layout\n+//!\n+//! ```\n+//! use arrow::array::UnionBuilder;\n+//! use arrow::datatypes::{Float64Type, Int32Type};\n+//!\n+//! # fn main() -> arrow::error::Result<()> {\n+//! let mut builder = UnionBuilder::new_dense(3);\n+//! builder.append::<Int32Type>(\"a\", 1).unwrap();\n+//! builder.append::<Float64Type>(\"b\", 3.0).unwrap();\n+//! builder.append::<Int32Type>(\"a\", 4).unwrap();\n+//! let union = builder.build().unwrap();\n+//!\n+//! assert_eq!(union.type_id(0), 0_i8);\n+//! assert_eq!(union.type_id(1), 1_i8);\n+//! assert_eq!(union.type_id(2), 0_i8);\n+//!\n+//! assert_eq!(union.value_offset(0), 0_i32);\n+//! assert_eq!(union.value_offset(1), 0_i32);\n+//! assert_eq!(union.value_offset(2), 1_i32);\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+//!\n+//! # Example: Sparse Memory Layout\n+//! ```\n+//! use arrow::array::UnionBuilder;\n+//! use arrow::datatypes::{Float64Type, Int32Type};\n+//!\n+//! # fn main() -> arrow::error::Result<()> {\n+//! let mut builder = UnionBuilder::new_sparse(3);\n+//! builder.append::<Int32Type>(\"a\", 1).unwrap();\n+//! builder.append::<Float64Type>(\"b\", 3.0).unwrap();\n+//! builder.append::<Int32Type>(\"a\", 4).unwrap();\n+//! let union = builder.build().unwrap();\n+//!\n+//! assert_eq!(union.type_id(0), 0_i8);\n+//! assert_eq!(union.type_id(1), 1_i8);\n+//! assert_eq!(union.type_id(2), 0_i8);\n+//!\n+//! assert_eq!(union.value_offset(0), 0_i32);\n+//! assert_eq!(union.value_offset(1), 1_i32);\n+//! assert_eq!(union.value_offset(2), 2_i32);\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+use crate::array::{\n+    builder::{builder_to_mutable_buffer, mutable_buffer_to_builder, BufferBuilderTrait},\n+    make_array, Array, ArrayData, ArrayDataBuilder, ArrayDataRef, ArrayRef,\n+    BooleanBufferBuilder, BufferBuilder, Int32BufferBuilder, Int8BufferBuilder,\n+};\n+use crate::buffer::{Buffer, MutableBuffer};\n+use crate::datatypes::*;\n+use crate::error::{ArrowError, Result};\n+\n+use crate::util::bit_util;\n+use core::fmt;\n+use std::any::Any;\n+use std::collections::HashMap;\n+use std::mem::size_of;\n+\n+/// An Array that can represent slots of varying types\n+pub struct UnionArray {\n+    data: ArrayDataRef,\n+    boxed_fields: Vec<ArrayRef>,\n+}\n+\n+impl UnionArray {\n+    /// Creates a new `UnionArray`.\n+    ///\n+    /// Accepts type ids, child arrays and optionally offsets (for dense unions) to create\n+    /// a new `UnionArray`.  This method makes no attempt to validate the data provided by the\n+    /// caller and assumes that each of the components are correct and consistent with each other.\n+    /// See `try_new` for an alternative that validates the data provided.\n+    ///\n+    /// # Data Consistency\n+    ///\n+    /// The `type_ids` `Buffer` should contain `i8` values.  These values should be greater than\n+    /// zero and must be less than the number of children provided in `child_arrays`.  These values\n+    /// are used to index into the `child_arrays`.\n+    ///\n+    /// The `value_offsets` `Buffer` is only provided in the case of a dense union, sparse unions\n+    /// should use `None`.  If provided the `value_offsets` `Buffer` should contain `i32` values.\n+    /// These values should be greater than zero and must be less than the length of the overall\n+    /// array.\n+    ///\n+    /// In both cases above we use signed integer types to maintain compatibility with other\n+    /// Arrow implementations.\n+    ///\n+    /// In both of the cases above we are accepting `Buffer`'s which are assumed to be representing\n+    /// `i8` and `i32` values respectively.  `Buffer` objects are untyped and no attempt is made\n+    /// to ensure that the data provided is valid.\n+    pub fn new(\n+        type_ids: Buffer,\n+        value_offsets: Option<Buffer>,\n+        child_arrays: Vec<(Field, ArrayRef)>,\n+        bitmap_data: Option<(Buffer, usize)>,\n+    ) -> Self {\n+        let (field_types, field_values): (Vec<_>, Vec<_>) =\n+            child_arrays.into_iter().unzip();\n+        let len = type_ids.len();\n+        let mut builder = ArrayData::builder(DataType::Union(field_types))\n+            .add_buffer(type_ids)\n+            .child_data(field_values.into_iter().map(|a| a.data()).collect())\n+            .len(len);\n+        if let Some((bitmap, null_count)) = bitmap_data {\n+            builder = builder.null_bit_buffer(bitmap).null_count(null_count);\n+        }\n+        let data = match value_offsets {\n+            Some(b) => builder.add_buffer(b).build(),\n+            None => builder.build(),\n+        };\n+        Self::from(data)\n+    }\n+    /// Attempts to create a new `UnionArray` and validates the inputs provided.\n+    pub fn try_new(\n+        type_ids: Buffer,\n+        value_offsets: Option<Buffer>,\n+        child_arrays: Vec<(Field, ArrayRef)>,\n+        bitmap: Option<Buffer>,\n+    ) -> Result<Self> {\n+        let bitmap_data = bitmap.map(|b| {\n+            let null_count = type_ids.len() - bit_util::count_set_bits(b.data());\n+            (b, null_count)\n+        });\n+\n+        if let Some(b) = &value_offsets {\n+            let nulls = match bitmap_data {\n+                Some((_, n)) => n,\n+                None => 0,\n+            };\n+            if ((type_ids.len() - nulls) * 4) != b.len() {\n+                return Err(ArrowError::InvalidArgumentError(\n+                    \"Type Ids and Offsets represent a different number of array slots.\"\n+                        .to_string(),\n+                ));\n+            }\n+        }\n+\n+        // Check the type_ids\n+        let type_id_slice: &[i8] = unsafe { type_ids.typed_data() };\n+        let invalid_type_ids = type_id_slice\n+            .iter()\n+            .filter(|i| *i < &0)\n+            .collect::<Vec<&i8>>();\n+        if invalid_type_ids.len() > 0 {\n+            return Err(ArrowError::InvalidArgumentError(format!(\n+                \"Type Ids must be positive and cannot be greater than the number of \\\n+                child arrays, found:\\n{:?}\",\n+                invalid_type_ids\n+            )));\n+        }\n+\n+        // Check the value offsets if provided\n+        if let Some(offset_buffer) = &value_offsets {\n+            let max_len = type_ids.len() as i32;\n+            let offsets_slice: &[i32] = unsafe { offset_buffer.typed_data() };\n+            let invalid_offsets = offsets_slice\n+                .iter()\n+                .filter(|i| *i < &0 || *i > &max_len)\n+                .collect::<Vec<&i32>>();\n+            if invalid_offsets.len() > 0 {\n+                return Err(ArrowError::InvalidArgumentError(format!(\n+                    \"Offsets must be positive and within the length of the Array, \\\n+                    found:\\n{:?}\",\n+                    invalid_offsets\n+                )));\n+            }\n+        }\n+\n+        Ok(Self::new(\n+            type_ids,\n+            value_offsets,\n+            child_arrays,\n+            bitmap_data,\n+        ))\n+    }\n+\n+    /// Accesses the child array for `type_id`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the `type_id` provided is less than zero or greater than the number of types\n+    /// in the `Union`.\n+    pub fn child(&self, type_id: i8) -> ArrayRef {\n+        assert!(0 <= type_id);\n+        assert!((type_id as usize) < self.boxed_fields.len());\n+        self.boxed_fields[type_id as usize].clone()\n+    }\n+\n+    /// Returns the `type_id` for the array slot at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn type_id(&self, index: usize) -> i8 {\n+        assert!(index - self.offset() < self.len());\n+        self.data().buffers()[0].data()[index] as i8\n+    }\n+\n+    /// Returns the offset into the underlying values array for the array slot at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn value_offset(&self, index: usize) -> i32 {\n+        assert!(index - self.offset() < self.len());\n+        if self.is_dense() {\n+            let valid_slots = match self.data.null_buffer() {\n+                Some(b) => bit_util::count_set_bits_offset(b.data(), 0, index),\n+                None => index,\n+            };\n+            self.data().buffers()[1].data()[valid_slots * size_of::<i32>()] as i32\n+        } else {\n+            index as i32\n+        }\n+    }\n+\n+    /// Returns the array's value at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn value(&self, index: usize) -> ArrayRef {\n+        let type_id = self.type_id(self.offset() + index);\n+        let value_offset = self.value_offset(self.offset() + index) as usize;\n+        let child_data = self.boxed_fields[type_id as usize].clone();\n+        child_data.slice(value_offset, 1)\n+    }\n+\n+    /// Returns the names of the types in the union.\n+    pub fn type_names(&self) -> Vec<&str> {\n+        match self.data.data_type() {\n+            DataType::Union(fields) => fields\n+                .iter()\n+                .map(|f| f.name().as_str())\n+                .collect::<Vec<&str>>(),\n+            _ => unreachable!(\"Union array's data type is not a union!\"),\n+        }\n+    }\n+\n+    /// Returns whether the `UnionArray` is dense (or sparse if `false`).\n+    fn is_dense(&self) -> bool {\n+        self.data().buffers().len() == 2\n+    }\n+}\n+\n+impl From<ArrayDataRef> for UnionArray {\n+    fn from(data: ArrayDataRef) -> Self {\n+        let mut boxed_fields = vec![];\n+        for cd in data.child_data() {\n+            boxed_fields.push(make_array(cd.clone()));\n+        }\n+        Self { data, boxed_fields }\n+    }\n+}\n+\n+impl Array for UnionArray {\n+    fn as_any(&self) -> &Any {\n+        self\n+    }\n+\n+    fn data(&self) -> ArrayDataRef {\n+        self.data.clone()\n+    }\n+\n+    fn data_ref(&self) -> &ArrayDataRef {\n+        &self.data\n+    }\n+}\n+\n+impl fmt::Debug for UnionArray {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let header = if self.is_dense() {\n+            \"UnionArray(Dense)\\n[\\n\"\n+        } else {\n+            \"UnionArray(Sparse)\\n[\\n\"\n+        };\n+        write!(f, \"{}\", header)?;\n+\n+        write!(f, \"-- type id buffer:\\n\")?;\n+        write!(f, \"{:?}\\n\", self.data().buffers()[0])?;\n+\n+        if self.is_dense() {\n+            write!(f, \"-- offsets buffer:\\n\")?;\n+            write!(f, \"{:?}\\n\", self.data().buffers()[1])?;\n+        }\n+\n+        for (child_index, name) in self.type_names().iter().enumerate() {\n+            let column = &self.boxed_fields[child_index];\n+            write!(\n+                f,\n+                \"-- child {}: \\\"{}\\\" ({:?})\\n\",\n+                child_index,\n+                *name,\n+                column.data_type()\n+            )?;\n+            fmt::Debug::fmt(column, f)?;\n+            write!(f, \"\\n\")?;\n+        }\n+        write!(f, \"]\")\n+    }\n+}\n+\n+/// `FieldData` is a helper struct to track the state of the fields in the `UnionBuilder`.\n+struct FieldData {\n+    /// The type id for this field\n+    type_id: i8,\n+    /// The Arrow data type represented in the `values_buffer`, which is untyped\n+    data_type: DataType,\n+    /// A buffer containing the values for this field in raw bytes\n+    values_buffer: Option<MutableBuffer>,\n+    ///  The number of array slots represented by the buffer\n+    slots: usize,\n+    /// The number of null array slots in this child array\n+    null_count: usize,\n+    /// A builder for the bitmap if required\n\nReview comment:\n       It's required for sparse unions and not for dense, I'll update the doc comment.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-06T19:28:49.678+0000",
                    "updated": "2020-05-06T19:28:49.678+0000",
                    "started": "2020-05-06T19:28:49.678+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "431380",
                    "issueId": "13199068"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13199068/worklog/431381",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paddyhoran commented on a change in pull request #7004:\nURL: https://github.com/apache/arrow/pull/7004#discussion_r421040067\n\n\n\n##########\nFile path: rust/arrow/src/array/union.rs\n##########\n@@ -0,0 +1,1174 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Contains the `UnionArray` and `UnionBuilder` types.\n+//!\n+//! Each slot in a `UnionArray` can have a value chosen from a number of types.  Each of the\n+//! possible types are named like the fields of a [`StructArray`](crate::array::StructArray).\n+//! A `UnionArray` can have two possible memory layouts, \"dense\" or \"sparse\".  For more information\n+//! on please see the [specification](https://arrow.apache.org/docs/format/Columnar.html#union-layout).\n+//!\n+//! Builders are provided for `UnionArray`'s involving primitive types.  `UnionArray`'s of nested\n+//! types are also supported but not via `UnionBuilder`, see the tests for examples.\n+//!\n+//! # Example: Dense Memory Layout\n+//!\n+//! ```\n+//! use arrow::array::UnionBuilder;\n+//! use arrow::datatypes::{Float64Type, Int32Type};\n+//!\n+//! # fn main() -> arrow::error::Result<()> {\n+//! let mut builder = UnionBuilder::new_dense(3);\n+//! builder.append::<Int32Type>(\"a\", 1).unwrap();\n+//! builder.append::<Float64Type>(\"b\", 3.0).unwrap();\n+//! builder.append::<Int32Type>(\"a\", 4).unwrap();\n+//! let union = builder.build().unwrap();\n+//!\n+//! assert_eq!(union.type_id(0), 0_i8);\n+//! assert_eq!(union.type_id(1), 1_i8);\n+//! assert_eq!(union.type_id(2), 0_i8);\n+//!\n+//! assert_eq!(union.value_offset(0), 0_i32);\n+//! assert_eq!(union.value_offset(1), 0_i32);\n+//! assert_eq!(union.value_offset(2), 1_i32);\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+//!\n+//! # Example: Sparse Memory Layout\n+//! ```\n+//! use arrow::array::UnionBuilder;\n+//! use arrow::datatypes::{Float64Type, Int32Type};\n+//!\n+//! # fn main() -> arrow::error::Result<()> {\n+//! let mut builder = UnionBuilder::new_sparse(3);\n+//! builder.append::<Int32Type>(\"a\", 1).unwrap();\n+//! builder.append::<Float64Type>(\"b\", 3.0).unwrap();\n+//! builder.append::<Int32Type>(\"a\", 4).unwrap();\n+//! let union = builder.build().unwrap();\n+//!\n+//! assert_eq!(union.type_id(0), 0_i8);\n+//! assert_eq!(union.type_id(1), 1_i8);\n+//! assert_eq!(union.type_id(2), 0_i8);\n+//!\n+//! assert_eq!(union.value_offset(0), 0_i32);\n+//! assert_eq!(union.value_offset(1), 1_i32);\n+//! assert_eq!(union.value_offset(2), 2_i32);\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+use crate::array::{\n+    builder::{builder_to_mutable_buffer, mutable_buffer_to_builder, BufferBuilderTrait},\n+    make_array, Array, ArrayData, ArrayDataBuilder, ArrayDataRef, ArrayRef,\n+    BooleanBufferBuilder, BufferBuilder, Int32BufferBuilder, Int8BufferBuilder,\n+};\n+use crate::buffer::{Buffer, MutableBuffer};\n+use crate::datatypes::*;\n+use crate::error::{ArrowError, Result};\n+\n+use crate::util::bit_util;\n+use core::fmt;\n+use std::any::Any;\n+use std::collections::HashMap;\n+use std::mem::size_of;\n+\n+/// An Array that can represent slots of varying types\n+pub struct UnionArray {\n+    data: ArrayDataRef,\n+    boxed_fields: Vec<ArrayRef>,\n+}\n+\n+impl UnionArray {\n+    /// Creates a new `UnionArray`.\n+    ///\n+    /// Accepts type ids, child arrays and optionally offsets (for dense unions) to create\n+    /// a new `UnionArray`.  This method makes no attempt to validate the data provided by the\n+    /// caller and assumes that each of the components are correct and consistent with each other.\n+    /// See `try_new` for an alternative that validates the data provided.\n+    ///\n+    /// # Data Consistency\n+    ///\n+    /// The `type_ids` `Buffer` should contain `i8` values.  These values should be greater than\n+    /// zero and must be less than the number of children provided in `child_arrays`.  These values\n+    /// are used to index into the `child_arrays`.\n+    ///\n+    /// The `value_offsets` `Buffer` is only provided in the case of a dense union, sparse unions\n+    /// should use `None`.  If provided the `value_offsets` `Buffer` should contain `i32` values.\n+    /// These values should be greater than zero and must be less than the length of the overall\n+    /// array.\n+    ///\n+    /// In both cases above we use signed integer types to maintain compatibility with other\n+    /// Arrow implementations.\n+    ///\n+    /// In both of the cases above we are accepting `Buffer`'s which are assumed to be representing\n+    /// `i8` and `i32` values respectively.  `Buffer` objects are untyped and no attempt is made\n+    /// to ensure that the data provided is valid.\n+    pub fn new(\n+        type_ids: Buffer,\n+        value_offsets: Option<Buffer>,\n+        child_arrays: Vec<(Field, ArrayRef)>,\n+        bitmap_data: Option<(Buffer, usize)>,\n+    ) -> Self {\n+        let (field_types, field_values): (Vec<_>, Vec<_>) =\n+            child_arrays.into_iter().unzip();\n+        let len = type_ids.len();\n+        let mut builder = ArrayData::builder(DataType::Union(field_types))\n+            .add_buffer(type_ids)\n+            .child_data(field_values.into_iter().map(|a| a.data()).collect())\n+            .len(len);\n+        if let Some((bitmap, null_count)) = bitmap_data {\n+            builder = builder.null_bit_buffer(bitmap).null_count(null_count);\n+        }\n+        let data = match value_offsets {\n+            Some(b) => builder.add_buffer(b).build(),\n+            None => builder.build(),\n+        };\n+        Self::from(data)\n+    }\n+    /// Attempts to create a new `UnionArray` and validates the inputs provided.\n+    pub fn try_new(\n+        type_ids: Buffer,\n+        value_offsets: Option<Buffer>,\n+        child_arrays: Vec<(Field, ArrayRef)>,\n+        bitmap: Option<Buffer>,\n+    ) -> Result<Self> {\n+        let bitmap_data = bitmap.map(|b| {\n+            let null_count = type_ids.len() - bit_util::count_set_bits(b.data());\n+            (b, null_count)\n+        });\n+\n+        if let Some(b) = &value_offsets {\n+            let nulls = match bitmap_data {\n+                Some((_, n)) => n,\n+                None => 0,\n+            };\n+            if ((type_ids.len() - nulls) * 4) != b.len() {\n+                return Err(ArrowError::InvalidArgumentError(\n+                    \"Type Ids and Offsets represent a different number of array slots.\"\n+                        .to_string(),\n+                ));\n+            }\n+        }\n+\n+        // Check the type_ids\n+        let type_id_slice: &[i8] = unsafe { type_ids.typed_data() };\n+        let invalid_type_ids = type_id_slice\n+            .iter()\n+            .filter(|i| *i < &0)\n+            .collect::<Vec<&i8>>();\n+        if invalid_type_ids.len() > 0 {\n+            return Err(ArrowError::InvalidArgumentError(format!(\n+                \"Type Ids must be positive and cannot be greater than the number of \\\n+                child arrays, found:\\n{:?}\",\n+                invalid_type_ids\n+            )));\n+        }\n+\n+        // Check the value offsets if provided\n+        if let Some(offset_buffer) = &value_offsets {\n+            let max_len = type_ids.len() as i32;\n+            let offsets_slice: &[i32] = unsafe { offset_buffer.typed_data() };\n+            let invalid_offsets = offsets_slice\n+                .iter()\n+                .filter(|i| *i < &0 || *i > &max_len)\n+                .collect::<Vec<&i32>>();\n+            if invalid_offsets.len() > 0 {\n+                return Err(ArrowError::InvalidArgumentError(format!(\n+                    \"Offsets must be positive and within the length of the Array, \\\n+                    found:\\n{:?}\",\n+                    invalid_offsets\n+                )));\n+            }\n+        }\n+\n+        Ok(Self::new(\n+            type_ids,\n+            value_offsets,\n+            child_arrays,\n+            bitmap_data,\n+        ))\n+    }\n+\n+    /// Accesses the child array for `type_id`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the `type_id` provided is less than zero or greater than the number of types\n+    /// in the `Union`.\n+    pub fn child(&self, type_id: i8) -> ArrayRef {\n+        assert!(0 <= type_id);\n+        assert!((type_id as usize) < self.boxed_fields.len());\n+        self.boxed_fields[type_id as usize].clone()\n+    }\n+\n+    /// Returns the `type_id` for the array slot at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn type_id(&self, index: usize) -> i8 {\n+        assert!(index - self.offset() < self.len());\n+        self.data().buffers()[0].data()[index] as i8\n+    }\n+\n+    /// Returns the offset into the underlying values array for the array slot at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn value_offset(&self, index: usize) -> i32 {\n+        assert!(index - self.offset() < self.len());\n+        if self.is_dense() {\n+            let valid_slots = match self.data.null_buffer() {\n+                Some(b) => bit_util::count_set_bits_offset(b.data(), 0, index),\n+                None => index,\n+            };\n+            self.data().buffers()[1].data()[valid_slots * size_of::<i32>()] as i32\n+        } else {\n+            index as i32\n+        }\n+    }\n+\n+    /// Returns the array's value at `index`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than the length of the array.\n+    pub fn value(&self, index: usize) -> ArrayRef {\n+        let type_id = self.type_id(self.offset() + index);\n+        let value_offset = self.value_offset(self.offset() + index) as usize;\n+        let child_data = self.boxed_fields[type_id as usize].clone();\n+        child_data.slice(value_offset, 1)\n+    }\n+\n+    /// Returns the names of the types in the union.\n+    pub fn type_names(&self) -> Vec<&str> {\n+        match self.data.data_type() {\n+            DataType::Union(fields) => fields\n+                .iter()\n+                .map(|f| f.name().as_str())\n+                .collect::<Vec<&str>>(),\n+            _ => unreachable!(\"Union array's data type is not a union!\"),\n+        }\n+    }\n+\n+    /// Returns whether the `UnionArray` is dense (or sparse if `false`).\n+    fn is_dense(&self) -> bool {\n+        self.data().buffers().len() == 2\n+    }\n+}\n+\n+impl From<ArrayDataRef> for UnionArray {\n+    fn from(data: ArrayDataRef) -> Self {\n+        let mut boxed_fields = vec![];\n+        for cd in data.child_data() {\n+            boxed_fields.push(make_array(cd.clone()));\n+        }\n+        Self { data, boxed_fields }\n+    }\n+}\n+\n+impl Array for UnionArray {\n+    fn as_any(&self) -> &Any {\n+        self\n+    }\n+\n+    fn data(&self) -> ArrayDataRef {\n+        self.data.clone()\n+    }\n+\n+    fn data_ref(&self) -> &ArrayDataRef {\n+        &self.data\n+    }\n+}\n+\n+impl fmt::Debug for UnionArray {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let header = if self.is_dense() {\n+            \"UnionArray(Dense)\\n[\\n\"\n+        } else {\n+            \"UnionArray(Sparse)\\n[\\n\"\n+        };\n+        write!(f, \"{}\", header)?;\n+\n+        write!(f, \"-- type id buffer:\\n\")?;\n+        write!(f, \"{:?}\\n\", self.data().buffers()[0])?;\n+\n+        if self.is_dense() {\n+            write!(f, \"-- offsets buffer:\\n\")?;\n+            write!(f, \"{:?}\\n\", self.data().buffers()[1])?;\n+        }\n+\n+        for (child_index, name) in self.type_names().iter().enumerate() {\n+            let column = &self.boxed_fields[child_index];\n+            write!(\n+                f,\n+                \"-- child {}: \\\"{}\\\" ({:?})\\n\",\n+                child_index,\n+                *name,\n+                column.data_type()\n+            )?;\n+            fmt::Debug::fmt(column, f)?;\n+            write!(f, \"\\n\")?;\n+        }\n+        write!(f, \"]\")\n+    }\n+}\n+\n+/// `FieldData` is a helper struct to track the state of the fields in the `UnionBuilder`.\n+struct FieldData {\n+    /// The type id for this field\n+    type_id: i8,\n+    /// The Arrow data type represented in the `values_buffer`, which is untyped\n+    data_type: DataType,\n+    /// A buffer containing the values for this field in raw bytes\n+    values_buffer: Option<MutableBuffer>,\n+    ///  The number of array slots represented by the buffer\n+    slots: usize,\n+    /// The number of null array slots in this child array\n+    null_count: usize,\n+    /// A builder for the bitmap if required\n+    bitmap_builder: Option<BooleanBufferBuilder>,\n+}\n+\n+impl FieldData {\n+    /// Creates a new `FieldData`.\n+    fn new(\n+        type_id: i8,\n+        data_type: DataType,\n+        bitmap_builder: Option<BooleanBufferBuilder>,\n+    ) -> Self {\n+        Self {\n+            type_id,\n+            data_type,\n+            // TODO: Should `MutableBuffer` implement `Default`?\n+            values_buffer: Some(MutableBuffer::new(1)),\n+            slots: 0,\n+            null_count: 0,\n+            bitmap_builder,\n+        }\n+    }\n+\n+    /// Appends a single value to this `FieldData`'s `values_buffer`.\n+    fn append_to_values_buffer<T: ArrowPrimitiveType>(\n+        &mut self,\n+        v: T::Native,\n+    ) -> Result<()> {\n+        let values_buffer = self\n+            .values_buffer\n+            .take()\n+            .expect(\"Values buffer was never created\");\n+        let mut builder: BufferBuilder<T> =\n+            mutable_buffer_to_builder(values_buffer, self.slots);\n+        builder.append(v)?;\n+        let mutable_buffer = builder_to_mutable_buffer(builder);\n+        self.values_buffer = Some(mutable_buffer);\n+\n+        self.slots += 1;\n+        if let Some(b) = &mut self.bitmap_builder {\n+            b.append(true)?\n+        };\n+        Ok(())\n+    }\n+\n+    /// Appends a null to this `FieldData`.\n+    fn append_null<T: ArrowPrimitiveType>(&mut self) -> Result<()> {\n+        if let Some(b) = &mut self.bitmap_builder {\n+            let values_buffer = self\n+                .values_buffer\n+                .take()\n+                .expect(\"Values buffer was never created\");\n+            let mut builder: BufferBuilder<T> =\n+                mutable_buffer_to_builder(values_buffer, self.slots);\n+            builder.advance(1)?;\n+            let mutable_buffer = builder_to_mutable_buffer(builder);\n+            self.values_buffer = Some(mutable_buffer);\n+            self.slots += 1;\n\nReview comment:\n       Actually I should have incremented both.  The `null_count` of the `ArrayData` for the children was not set correctly.  Will update.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-06T19:31:16.844+0000",
                    "updated": "2020-05-06T19:31:16.844+0000",
                    "started": "2020-05-06T19:31:16.844+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "431381",
                    "issueId": "13199068"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13199068/worklog/431387",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paddyhoran commented on pull request #7004:\nURL: https://github.com/apache/arrow/pull/7004#issuecomment-624853357\n\n\n   @nevi-me @andygrove this is ready for re-review.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-06T19:48:13.673+0000",
                    "updated": "2020-05-06T19:48:13.673+0000",
                    "started": "2020-05-06T19:48:13.673+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "431387",
                    "issueId": "13199068"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13199068/worklog/433716",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on pull request #7004:\nURL: https://github.com/apache/arrow/pull/7004#issuecomment-629277167\n\n\n   > @nevi-me @andygrove this is ready for re-review.\r\n   \r\n   @andygrove do you want to have a look, or can we merge this?\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-15T14:49:38.707+0000",
                    "updated": "2020-05-15T14:49:38.707+0000",
                    "started": "2020-05-15T14:49:38.707+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "433716",
                    "issueId": "13199068"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13199068/worklog/433719",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on pull request #7004:\nURL: https://github.com/apache/arrow/pull/7004#issuecomment-629283277\n\n\n   @nevi-me Sorry, I forgot about this one. Please go ahead.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-15T15:01:52.473+0000",
                    "updated": "2020-05-15T15:01:52.473+0000",
                    "started": "2020-05-15T15:01:52.473+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "433719",
                    "issueId": "13199068"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 12600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@1a5b6d11[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7ba3eab6[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@18faf60d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@7c6859fe[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3ab88b47[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@22f6a133[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6d7361fe[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@53ea6207[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2df6398e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@3a1eea3a[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4c941016[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@4c6eb9d9[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 12600,
        "customfield_12312520": null,
        "customfield_12312521": "Fri May 15 16:34:15 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-05-15T16:34:14.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3827/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2018-11-17T01:46:55.000+0000",
        "updated": "2020-05-15T16:34:22.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "3.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 12600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust] Implement UnionArray",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13199068/comment/17108443",
                    "id": "17108443",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
                        "name": "nevi_me",
                        "key": "nevi_me",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
                        },
                        "displayName": "Neville Dipale",
                        "active": true,
                        "timeZone": "Africa/Johannesburg"
                    },
                    "body": "Issue resolved by pull request 7004\n[https://github.com/apache/arrow/pull/7004]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
                        "name": "nevi_me",
                        "key": "nevi_me",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
                        },
                        "displayName": "Neville Dipale",
                        "active": true,
                        "timeZone": "Africa/Johannesburg"
                    },
                    "created": "2020-05-15T16:34:15.044+0000",
                    "updated": "2020-05-15T16:34:15.044+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|s00lww:",
        "customfield_12314139": null
    }
}