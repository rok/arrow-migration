{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13322354",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322354",
    "key": "ARROW-9710",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12345977",
                "id": "12345977",
                "description": "",
                "name": "2.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-10-19"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=myzhong",
            "name": "myzhong",
            "key": "myzhong",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34058",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34058",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34058",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34058"
            },
            "displayName": "Mingyu Zhong",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
            "name": "emkornfield@gmail.com",
            "key": "emkornfield@gmail.com",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
            "name": "emkornfield@gmail.com",
            "key": "emkornfield@gmail.com",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 7200,
            "total": 7200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 7200,
            "total": 7200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9710/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 12,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322354/worklog/469915",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "MingyuZhong opened a new pull request #7945:\nURL: https://github.com/apache/arrow/pull/7945\n\n\n   Added a benchmark to decimal_benchmark.\r\n   \r\n   ```\r\n   Running release/arrow-decimal-benchmark\r\n   Run on (12 X 4500 MHz CPU s)\r\n   CPU Caches:\r\n     L1 Data 32 KiB (x6)\r\n     L1 Instruction 32 KiB (x6)\r\n     L2 Unified 1024 KiB (x6)\r\n     L3 Unified 8448 KiB (x1)\r\n   Load Average: 0.23, 0.22, 0.23\r\n   ----------------------------------------------------------------------------------\r\n   Benchmark                        Time             CPU   Iterations UserCounters...\r\n   ----------------------------------------------------------------------------------\r\n   ToString (before)             2205 ns         2205 ns       321603 items_per_second=2.72094M/s\r\n   ToString (after)               280 ns          280 ns      2486507 items_per_second=21.4211M/s\r\n   ```\r\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-12T20:01:55.109+0000",
                    "updated": "2020-08-12T20:01:55.109+0000",
                    "started": "2020-08-12T20:01:55.109+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "469915",
                    "issueId": "13322354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322354/worklog/469918",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #7945:\nURL: https://github.com/apache/arrow/pull/7945#issuecomment-673083492\n\n\n   https://issues.apache.org/jira/browse/ARROW-9710\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-12T20:05:25.499+0000",
                    "updated": "2020-08-12T20:05:25.499+0000",
                    "started": "2020-08-12T20:05:25.499+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "469918",
                    "issueId": "13322354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322354/worklog/470247",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #7945:\nURL: https://github.com/apache/arrow/pull/7945#discussion_r469967040\n\n\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -241,64 +284,43 @@ Decimal128::operator int64_t() const {\n   return static_cast<int64_t>(low_bits());\n }\n \n-static std::string ToStringNegativeScale(const std::string& str,\n-                                         int32_t adjusted_exponent, bool is_negative) {\n-  std::stringstream buf;\n-\n-  size_t offset = 0;\n-  buf << str[offset++];\n-\n-  if (is_negative) {\n-    buf << str[offset++];\n-  }\n-\n-  buf << '.' << str.substr(offset, std::string::npos) << 'E' << std::showpos\n-      << adjusted_exponent;\n-  return buf.str();\n-}\n-\n-std::string Decimal128::ToString(int32_t scale) const {\n-  const std::string str(ToIntegerString());\n-\n+static void AdjustIntegerStringWithScale(int32_t scale, std::string* str) {\n   if (scale == 0) {\n-    return str;\n+    return;\n   }\n \n-  const bool is_negative = *this < 0;\n-\n-  const auto len = static_cast<int32_t>(str.size());\n+  const bool is_negative = str->front() == '-';\n   const auto is_negative_offset = static_cast<int32_t>(is_negative);\n-  const int32_t adjusted_exponent = -scale + (len - 1 - is_negative_offset);\n+  const auto len = static_cast<int32_t>(str->size());\n+  const int32_t num_digits = len - is_negative_offset;\n+  const int32_t adjusted_exponent = num_digits - 1 - scale;\n \n   /// Note that the -6 is taken from the Java BigDecimal documentation.\n   if (scale < 0 || adjusted_exponent < -6) {\n-    return ToStringNegativeScale(str, adjusted_exponent, is_negative);\n+    str->insert(str->begin() + 1 + is_negative_offset, '.');\n+    str->push_back('E');\n+    // Use stringstream only for printing the exponent integer. It should be short\n+    // enough to avoid memory allocations.\n+    std::stringstream buf;\n+    buf << std::showpos << adjusted_exponent;\n+    *str += buf.str();\n+    return;\n   }\n \n-  if (is_negative) {\n-    if (len - 1 > scale) {\n-      const auto n = static_cast<size_t>(len - scale);\n-      return str.substr(0, n) + \".\" + str.substr(n, static_cast<size_t>(scale));\n-    }\n-\n-    if (len - 1 == scale) {\n-      return \"-0.\" + str.substr(1, std::string::npos);\n-    }\n-\n-    std::string result(\"-0.\" + std::string(static_cast<size_t>(scale - len + 1), '0'));\n-    return result + str.substr(1, std::string::npos);\n-  }\n-\n-  if (len > scale) {\n+  if (num_digits > scale) {\n     const auto n = static_cast<size_t>(len - scale);\n-    return str.substr(0, n) + \".\" + str.substr(n, static_cast<size_t>(scale));\n+    str->insert(str->begin() + n, '.');\n+    return;\n   }\n \n-  if (len == scale) {\n-    return \"0.\" + str;\n-  }\n+  str->insert(is_negative_offset, scale - num_digits + 2, '0');\n\nReview comment:\n       Same: can you explain what happens here?\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -195,42 +191,89 @@ double Decimal128::ToDouble(int32_t scale) const {\n   return DecimalDoubleConversion::ToReal(*this, scale);\n }\n \n-std::string Decimal128::ToIntegerString() const {\n-  Decimal128 remainder;\n-  std::stringstream buf;\n-  bool need_fill = false;\n-\n-  // get anything above 10 ** 36 and print it\n-  Decimal128 top;\n-  std::tie(top, remainder) = Divide(kTenTo36).ValueOrDie();\n-\n-  if (top != 0) {\n-    buf << static_cast<int64_t>(top);\n-    remainder.Abs();\n-    need_fill = true;\n+template <size_t n>\n+static void AppendLittleEndianArrayToString(const std::array<uint64_t, n>& array,\n+                                            std::string* result) {\n+  static_assert(n > 0, \"Array size must be positive\");\n+  size_t most_significant_elem_idx = n - 1;\n+  while (array[most_significant_elem_idx] == 0) {\n+    if (most_significant_elem_idx == 0) {\n+      result->push_back('0');\n+      return;\n+    }\n+    --most_significant_elem_idx;\n+  }\n+\n+  std::array<uint64_t, n> copy = array;\n+  constexpr uint32_t k1e9 = 1000000000U;\n+  constexpr size_t num_bits = n * 64;\n+  // Each segment holds at most 9 decimal digits.\n+  // The number of segments needed = ceil(num_bits * log(2) / log(1e9))\n+  // = ceil(num_bits / 29.897352854) <= ceil(num_bits / 29).\n+  std::array<uint32_t, (num_bits + 28) / 29> segments;\n+  size_t num_segments = 0;\n+  uint64_t* most_significant_elem = &copy[most_significant_elem_idx];\n+  do {\n+    // Compute remainder = copy % 1e9 and copy = copy / 1e9.\n+    uint32_t remainder = 0;\n+    uint64_t* elem = most_significant_elem;\n+    do {\n+      uint32_t hi = static_cast<uint32_t>(*elem >> 32);\n+      uint32_t lo = static_cast<uint32_t>(*elem & ~uint32_t{0});\n+      uint64_t dividend_hi = (static_cast<uint64_t>(remainder) << 32) | hi;\n+      uint64_t quotient_hi = dividend_hi / k1e9;\n+      remainder = static_cast<uint32_t>(dividend_hi % k1e9);\n+      uint64_t dividend_lo = (static_cast<uint64_t>(remainder) << 32) | lo;\n+      uint64_t quotient_lo = dividend_lo / k1e9;\n+      remainder = static_cast<uint32_t>(dividend_lo % k1e9);\n+      *elem = (quotient_hi << 32) | quotient_lo;\n+    } while (elem-- != copy.data());\n+\n+    segments[num_segments++] = remainder;\n+  } while (*most_significant_elem != 0 || most_significant_elem-- != copy.data());\n+\n+  size_t old_size = result->size();\n+  size_t new_size = old_size + num_segments * 9;\n+  result->resize(new_size);\n+  char* output = &result->at(0) + old_size;\n\nReview comment:\n       `char* output = &result[old_size]` perhaps?\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -195,42 +191,89 @@ double Decimal128::ToDouble(int32_t scale) const {\n   return DecimalDoubleConversion::ToReal(*this, scale);\n }\n \n-std::string Decimal128::ToIntegerString() const {\n-  Decimal128 remainder;\n-  std::stringstream buf;\n-  bool need_fill = false;\n-\n-  // get anything above 10 ** 36 and print it\n-  Decimal128 top;\n-  std::tie(top, remainder) = Divide(kTenTo36).ValueOrDie();\n-\n-  if (top != 0) {\n-    buf << static_cast<int64_t>(top);\n-    remainder.Abs();\n-    need_fill = true;\n+template <size_t n>\n+static void AppendLittleEndianArrayToString(const std::array<uint64_t, n>& array,\n+                                            std::string* result) {\n+  static_assert(n > 0, \"Array size must be positive\");\n+  size_t most_significant_elem_idx = n - 1;\n+  while (array[most_significant_elem_idx] == 0) {\n+    if (most_significant_elem_idx == 0) {\n+      result->push_back('0');\n+      return;\n+    }\n+    --most_significant_elem_idx;\n+  }\n+\n+  std::array<uint64_t, n> copy = array;\n+  constexpr uint32_t k1e9 = 1000000000U;\n+  constexpr size_t num_bits = n * 64;\n+  // Each segment holds at most 9 decimal digits.\n+  // The number of segments needed = ceil(num_bits * log(2) / log(1e9))\n+  // = ceil(num_bits / 29.897352854) <= ceil(num_bits / 29).\n+  std::array<uint32_t, (num_bits + 28) / 29> segments;\n+  size_t num_segments = 0;\n+  uint64_t* most_significant_elem = &copy[most_significant_elem_idx];\n+  do {\n+    // Compute remainder = copy % 1e9 and copy = copy / 1e9.\n+    uint32_t remainder = 0;\n+    uint64_t* elem = most_significant_elem;\n+    do {\n+      uint32_t hi = static_cast<uint32_t>(*elem >> 32);\n+      uint32_t lo = static_cast<uint32_t>(*elem & ~uint32_t{0});\n+      uint64_t dividend_hi = (static_cast<uint64_t>(remainder) << 32) | hi;\n+      uint64_t quotient_hi = dividend_hi / k1e9;\n+      remainder = static_cast<uint32_t>(dividend_hi % k1e9);\n+      uint64_t dividend_lo = (static_cast<uint64_t>(remainder) << 32) | lo;\n+      uint64_t quotient_lo = dividend_lo / k1e9;\n+      remainder = static_cast<uint32_t>(dividend_lo % k1e9);\n+      *elem = (quotient_hi << 32) | quotient_lo;\n+    } while (elem-- != copy.data());\n+\n+    segments[num_segments++] = remainder;\n+  } while (*most_significant_elem != 0 || most_significant_elem-- != copy.data());\n+\n+  size_t old_size = result->size();\n+  size_t new_size = old_size + num_segments * 9;\n+  result->resize(new_size);\n+  char* output = &result->at(0) + old_size;\n+  const uint32_t* segment = &segments[num_segments - 1];\n+  size_t num_digits_in_first_segment = 9;\n+  uint32_t digits = *segment;\n+  for (int j = 8; j >= 0; --j) {\n+    output[j] = static_cast<char>(digits % 10) + '0';\n\nReview comment:\n       We have formatting utilities in `arrow/util/formatting.h`, you should ideally reuse them instead of reinventing the wheel.\n\n##########\nFile path: cpp/src/arrow/util/decimal_test.cc\n##########\n@@ -106,6 +99,33 @@ TEST(DecimalTest, TestFromDecimalString128) {\n   ASSERT_NE(result.high_bits(), 0);\n }\n \n+TEST(DecimalTest, TestStringRoundTrip) {\n+  static constexpr uint64_t kTestBits[] = {\n+      0,\n+      1,\n+      999,\n+      1000,\n+      std::numeric_limits<int32_t>::max(),\n+      (1ull << 31),\n+      std::numeric_limits<uint32_t>::max(),\n+      (1ull << 32),\n+      std::numeric_limits<int64_t>::max(),\n+      (1ull << 63),\n+      std::numeric_limits<uint64_t>::max(),\n+  };\n+  static constexpr int32_t kScales[] = {-10, -1, 0, 1, 10};\n+  for (uint64_t high_bits : kTestBits) {\n\nReview comment:\n       We should probably test negative numbers as well.\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -241,64 +284,43 @@ Decimal128::operator int64_t() const {\n   return static_cast<int64_t>(low_bits());\n }\n \n-static std::string ToStringNegativeScale(const std::string& str,\n-                                         int32_t adjusted_exponent, bool is_negative) {\n-  std::stringstream buf;\n-\n-  size_t offset = 0;\n-  buf << str[offset++];\n-\n-  if (is_negative) {\n-    buf << str[offset++];\n-  }\n-\n-  buf << '.' << str.substr(offset, std::string::npos) << 'E' << std::showpos\n-      << adjusted_exponent;\n-  return buf.str();\n-}\n-\n-std::string Decimal128::ToString(int32_t scale) const {\n-  const std::string str(ToIntegerString());\n-\n+static void AdjustIntegerStringWithScale(int32_t scale, std::string* str) {\n   if (scale == 0) {\n-    return str;\n+    return;\n   }\n \n-  const bool is_negative = *this < 0;\n-\n-  const auto len = static_cast<int32_t>(str.size());\n+  const bool is_negative = str->front() == '-';\n   const auto is_negative_offset = static_cast<int32_t>(is_negative);\n-  const int32_t adjusted_exponent = -scale + (len - 1 - is_negative_offset);\n+  const auto len = static_cast<int32_t>(str->size());\n+  const int32_t num_digits = len - is_negative_offset;\n+  const int32_t adjusted_exponent = num_digits - 1 - scale;\n \n   /// Note that the -6 is taken from the Java BigDecimal documentation.\n   if (scale < 0 || adjusted_exponent < -6) {\n-    return ToStringNegativeScale(str, adjusted_exponent, is_negative);\n+    str->insert(str->begin() + 1 + is_negative_offset, '.');\n\nReview comment:\n       Can you explain what this is doing? It's not really obvious why `1 + is_negative_offset` is used as index.\n\n##########\nFile path: cpp/src/arrow/util/decimal_benchmark.cc\n##########\n@@ -26,14 +26,36 @@\n namespace arrow {\n namespace Decimal {\n \n-static void FromString(benchmark::State& state) {  // NOLINT non-const reference\n-  std::vector<std::string> values = {\"0\",\n-                                     \"1.23\",\n-                                     \"12.345e6\",\n-                                     \"-12.345e-6\",\n-                                     \"123456789.123456789\",\n-                                     \"1231234567890.451234567890\"};\n+static const std::vector<std::string>& GetValuesAsString() {\n+  static const std::vector<std::string>* values =\n+      new std::vector<std::string>{\"0\",\n\nReview comment:\n       This sounds like a really complicated way of creating a global static constant. Am I missing something?\r\n   Otherwise simply:\r\n   ```c++\r\n   static const std::vector<std::string> kDecimalStrings = {...};\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/decimal_benchmark.cc\n##########\n@@ -26,14 +26,36 @@\n namespace arrow {\n namespace Decimal {\n \n-static void FromString(benchmark::State& state) {  // NOLINT non-const reference\n-  std::vector<std::string> values = {\"0\",\n-                                     \"1.23\",\n-                                     \"12.345e6\",\n-                                     \"-12.345e-6\",\n-                                     \"123456789.123456789\",\n-                                     \"1231234567890.451234567890\"};\n+static const std::vector<std::string>& GetValuesAsString() {\n+  static const std::vector<std::string>* values =\n+      new std::vector<std::string>{\"0\",\n+                                   \"1.23\",\n+                                   \"12.345e6\",\n+                                   \"-12.345e-6\",\n+                                   \"123456789.123456789\",\n+                                   \"1231234567890.451234567890\"};\n+  return *values;\n+}\n+\n+static std::vector<std::pair<Decimal128, int32_t>> BuildDecimalValuesAndScales() {\n+  const std::vector<std::string>& value_strs = GetValuesAsString();\n+  std::vector<std::pair<Decimal128, int32_t>> result(value_strs.size());\n+  for (size_t i = 0; i < value_strs.size(); ++i) {\n+    int32_t precision;\n+    Decimal128::FromString(value_strs[i], &result[i].first, &result[i].second,\n+                           &precision);\n+  }\n+  return result;\n+}\n+\n+static const std::vector<std::pair<Decimal128, int32_t>>& GetDecimalValuesAndScales() {\n+  static const auto* values =\n+      new std::vector<std::pair<Decimal128, int32_t>>(BuildDecimalValuesAndScales());\n\nReview comment:\n       The caching is really pointless. The small setup is cheap enough.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-13T14:03:46.028+0000",
                    "updated": "2020-08-13T14:03:46.028+0000",
                    "started": "2020-08-13T14:03:46.027+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "470247",
                    "issueId": "13322354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322354/worklog/470313",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #7945:\nURL: https://github.com/apache/arrow/pull/7945#discussion_r469962283\n\n\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -195,42 +191,89 @@ double Decimal128::ToDouble(int32_t scale) const {\n   return DecimalDoubleConversion::ToReal(*this, scale);\n }\n \n-std::string Decimal128::ToIntegerString() const {\n-  Decimal128 remainder;\n-  std::stringstream buf;\n-  bool need_fill = false;\n-\n-  // get anything above 10 ** 36 and print it\n-  Decimal128 top;\n-  std::tie(top, remainder) = Divide(kTenTo36).ValueOrDie();\n-\n-  if (top != 0) {\n-    buf << static_cast<int64_t>(top);\n-    remainder.Abs();\n-    need_fill = true;\n+template <size_t n>\n+static void AppendLittleEndianArrayToString(const std::array<uint64_t, n>& array,\n+                                            std::string* result) {\n+  static_assert(n > 0, \"Array size must be positive\");\n+  size_t most_significant_elem_idx = n - 1;\n+  while (array[most_significant_elem_idx] == 0) {\n+    if (most_significant_elem_idx == 0) {\n+      result->push_back('0');\n+      return;\n+    }\n+    --most_significant_elem_idx;\n+  }\n+\n+  std::array<uint64_t, n> copy = array;\n+  constexpr uint32_t k1e9 = 1000000000U;\n+  constexpr size_t num_bits = n * 64;\n\nReview comment:\n       nit kNumBits?\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -195,42 +191,89 @@ double Decimal128::ToDouble(int32_t scale) const {\n   return DecimalDoubleConversion::ToReal(*this, scale);\n }\n \n-std::string Decimal128::ToIntegerString() const {\n-  Decimal128 remainder;\n-  std::stringstream buf;\n-  bool need_fill = false;\n-\n-  // get anything above 10 ** 36 and print it\n-  Decimal128 top;\n-  std::tie(top, remainder) = Divide(kTenTo36).ValueOrDie();\n-\n-  if (top != 0) {\n-    buf << static_cast<int64_t>(top);\n-    remainder.Abs();\n-    need_fill = true;\n+template <size_t n>\n+static void AppendLittleEndianArrayToString(const std::array<uint64_t, n>& array,\n+                                            std::string* result) {\n+  static_assert(n > 0, \"Array size must be positive\");\n+  size_t most_significant_elem_idx = n - 1;\n+  while (array[most_significant_elem_idx] == 0) {\n+    if (most_significant_elem_idx == 0) {\n+      result->push_back('0');\n+      return;\n+    }\n+    --most_significant_elem_idx;\n+  }\n+\n+  std::array<uint64_t, n> copy = array;\n+  constexpr uint32_t k1e9 = 1000000000U;\n+  constexpr size_t num_bits = n * 64;\n+  // Each segment holds at most 9 decimal digits.\n+  // The number of segments needed = ceil(num_bits * log(2) / log(1e9))\n+  // = ceil(num_bits / 29.897352854) <= ceil(num_bits / 29).\n+  std::array<uint32_t, (num_bits + 28) / 29> segments;\n+  size_t num_segments = 0;\n+  uint64_t* most_significant_elem = &copy[most_significant_elem_idx];\n+  do {\n+    // Compute remainder = copy % 1e9 and copy = copy / 1e9.\n+    uint32_t remainder = 0;\n+    uint64_t* elem = most_significant_elem;\n+    do {\n+      uint32_t hi = static_cast<uint32_t>(*elem >> 32);\n+      uint32_t lo = static_cast<uint32_t>(*elem & ~uint32_t{0});\n\nReview comment:\n       consider using [LeastSignficantBitMask](https://github.com/apache/arrow/blob/e0a9d0f28affdccb45bf76fde58d0eec1328cd40/cpp/src/arrow/util/bit_util.h#L144)\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -241,64 +284,43 @@ Decimal128::operator int64_t() const {\n   return static_cast<int64_t>(low_bits());\n }\n \n-static std::string ToStringNegativeScale(const std::string& str,\n-                                         int32_t adjusted_exponent, bool is_negative) {\n-  std::stringstream buf;\n-\n-  size_t offset = 0;\n-  buf << str[offset++];\n-\n-  if (is_negative) {\n-    buf << str[offset++];\n-  }\n-\n-  buf << '.' << str.substr(offset, std::string::npos) << 'E' << std::showpos\n-      << adjusted_exponent;\n-  return buf.str();\n-}\n-\n-std::string Decimal128::ToString(int32_t scale) const {\n-  const std::string str(ToIntegerString());\n-\n+static void AdjustIntegerStringWithScale(int32_t scale, std::string* str) {\n   if (scale == 0) {\n-    return str;\n+    return;\n   }\n \n-  const bool is_negative = *this < 0;\n-\n-  const auto len = static_cast<int32_t>(str.size());\n+  const bool is_negative = str->front() == '-';\n   const auto is_negative_offset = static_cast<int32_t>(is_negative);\n-  const int32_t adjusted_exponent = -scale + (len - 1 - is_negative_offset);\n+  const auto len = static_cast<int32_t>(str->size());\n+  const int32_t num_digits = len - is_negative_offset;\n+  const int32_t adjusted_exponent = num_digits - 1 - scale;\n \n   /// Note that the -6 is taken from the Java BigDecimal documentation.\n   if (scale < 0 || adjusted_exponent < -6) {\n-    return ToStringNegativeScale(str, adjusted_exponent, is_negative);\n+    str->insert(str->begin() + 1 + is_negative_offset, '.');\n+    str->push_back('E');\n+    // Use stringstream only for printing the exponent integer. It should be short\n\nReview comment:\n       nit: if you move buf initialization before str->insert(), you can then string::reserve(2 + str.size()).  In most cases this probably won't be a huge deal\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -195,42 +191,89 @@ double Decimal128::ToDouble(int32_t scale) const {\n   return DecimalDoubleConversion::ToReal(*this, scale);\n }\n \n-std::string Decimal128::ToIntegerString() const {\n-  Decimal128 remainder;\n-  std::stringstream buf;\n-  bool need_fill = false;\n-\n-  // get anything above 10 ** 36 and print it\n-  Decimal128 top;\n-  std::tie(top, remainder) = Divide(kTenTo36).ValueOrDie();\n-\n-  if (top != 0) {\n-    buf << static_cast<int64_t>(top);\n-    remainder.Abs();\n-    need_fill = true;\n+template <size_t n>\n+static void AppendLittleEndianArrayToString(const std::array<uint64_t, n>& array,\n+                                            std::string* result) {\n+  static_assert(n > 0, \"Array size must be positive\");\n+  size_t most_significant_elem_idx = n - 1;\n\nReview comment:\n       i think this code could be easier to read if iterators where used (also allows while loops below which I think are more common so easier to read the do/while.\r\n   \r\n   ```\r\n   auto most_significat_non_zero = find_if(array.rbegin(), array.rend(), [](uint64_t v) {v != 0;})\r\n   if (most_significat_non_zero == array.rend()) {\r\n     result->push_back('0');\r\n     return;\r\n   }\r\n   ```\r\n   \r\n   This is somewhat subjective, so I'm OK if this stays this way.\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -195,42 +191,89 @@ double Decimal128::ToDouble(int32_t scale) const {\n   return DecimalDoubleConversion::ToReal(*this, scale);\n }\n \n-std::string Decimal128::ToIntegerString() const {\n-  Decimal128 remainder;\n-  std::stringstream buf;\n-  bool need_fill = false;\n-\n-  // get anything above 10 ** 36 and print it\n-  Decimal128 top;\n-  std::tie(top, remainder) = Divide(kTenTo36).ValueOrDie();\n-\n-  if (top != 0) {\n-    buf << static_cast<int64_t>(top);\n-    remainder.Abs();\n-    need_fill = true;\n+template <size_t n>\n+static void AppendLittleEndianArrayToString(const std::array<uint64_t, n>& array,\n+                                            std::string* result) {\n+  static_assert(n > 0, \"Array size must be positive\");\n+  size_t most_significant_elem_idx = n - 1;\n+  while (array[most_significant_elem_idx] == 0) {\n+    if (most_significant_elem_idx == 0) {\n+      result->push_back('0');\n+      return;\n+    }\n+    --most_significant_elem_idx;\n+  }\n+\n+  std::array<uint64_t, n> copy = array;\n+  constexpr uint32_t k1e9 = 1000000000U;\n+  constexpr size_t num_bits = n * 64;\n+  // Each segment holds at most 9 decimal digits.\n+  // The number of segments needed = ceil(num_bits * log(2) / log(1e9))\n+  // = ceil(num_bits / 29.897352854) <= ceil(num_bits / 29).\n+  std::array<uint32_t, (num_bits + 28) / 29> segments;\n+  size_t num_segments = 0;\n+  uint64_t* most_significant_elem = &copy[most_significant_elem_idx];\n+  do {\n+    // Compute remainder = copy % 1e9 and copy = copy / 1e9.\n+    uint32_t remainder = 0;\n+    uint64_t* elem = most_significant_elem;\n+    do {\n+      uint32_t hi = static_cast<uint32_t>(*elem >> 32);\n+      uint32_t lo = static_cast<uint32_t>(*elem & ~uint32_t{0});\n+      uint64_t dividend_hi = (static_cast<uint64_t>(remainder) << 32) | hi;\n+      uint64_t quotient_hi = dividend_hi / k1e9;\n+      remainder = static_cast<uint32_t>(dividend_hi % k1e9);\n+      uint64_t dividend_lo = (static_cast<uint64_t>(remainder) << 32) | lo;\n+      uint64_t quotient_lo = dividend_lo / k1e9;\n+      remainder = static_cast<uint32_t>(dividend_lo % k1e9);\n+      *elem = (quotient_hi << 32) | quotient_lo;\n+    } while (elem-- != copy.data());\n+\n+    segments[num_segments++] = remainder;\n+  } while (*most_significant_elem != 0 || most_significant_elem-- != copy.data());\n+\n+  size_t old_size = result->size();\n+  size_t new_size = old_size + num_segments * 9;\n+  result->resize(new_size);\n+  char* output = &result->at(0) + old_size;\n\nReview comment:\n       nit: &result->at(old_size) \r\n   but really iterator might be better here.\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -195,42 +191,89 @@ double Decimal128::ToDouble(int32_t scale) const {\n   return DecimalDoubleConversion::ToReal(*this, scale);\n }\n \n-std::string Decimal128::ToIntegerString() const {\n-  Decimal128 remainder;\n-  std::stringstream buf;\n-  bool need_fill = false;\n-\n-  // get anything above 10 ** 36 and print it\n-  Decimal128 top;\n-  std::tie(top, remainder) = Divide(kTenTo36).ValueOrDie();\n-\n-  if (top != 0) {\n-    buf << static_cast<int64_t>(top);\n-    remainder.Abs();\n-    need_fill = true;\n+template <size_t n>\n+static void AppendLittleEndianArrayToString(const std::array<uint64_t, n>& array,\n+                                            std::string* result) {\n+  static_assert(n > 0, \"Array size must be positive\");\n+  size_t most_significant_elem_idx = n - 1;\n+  while (array[most_significant_elem_idx] == 0) {\n+    if (most_significant_elem_idx == 0) {\n+      result->push_back('0');\n+      return;\n+    }\n+    --most_significant_elem_idx;\n+  }\n+\n+  std::array<uint64_t, n> copy = array;\n+  constexpr uint32_t k1e9 = 1000000000U;\n+  constexpr size_t num_bits = n * 64;\n+  // Each segment holds at most 9 decimal digits.\n\nReview comment:\n       ```suggestion\r\n     // Segments will contain the twos complement array split into groups that map to decimal digits\r\n     // Each segment will hold at most 9 decimal digits.\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/decimal_benchmark.cc\n##########\n@@ -26,14 +26,36 @@\n namespace arrow {\n namespace Decimal {\n \n-static void FromString(benchmark::State& state) {  // NOLINT non-const reference\n-  std::vector<std::string> values = {\"0\",\n-                                     \"1.23\",\n-                                     \"12.345e6\",\n-                                     \"-12.345e-6\",\n-                                     \"123456789.123456789\",\n-                                     \"1231234567890.451234567890\"};\n+static const std::vector<std::string>& GetValuesAsString() {\n+  static const std::vector<std::string>* values =\n+      new std::vector<std::string>{\"0\",\n+                                   \"1.23\",\n+                                   \"12.345e6\",\n+                                   \"-12.345e-6\",\n+                                   \"123456789.123456789\",\n+                                   \"1231234567890.451234567890\"};\n+  return *values;\n+}\n+\n+static std::vector<std::pair<Decimal128, int32_t>> BuildDecimalValuesAndScales() {\n\nReview comment:\n       nit: making a struct instead of pair can make the code easier to read.\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -195,42 +191,89 @@ double Decimal128::ToDouble(int32_t scale) const {\n   return DecimalDoubleConversion::ToReal(*this, scale);\n }\n \n-std::string Decimal128::ToIntegerString() const {\n-  Decimal128 remainder;\n-  std::stringstream buf;\n-  bool need_fill = false;\n-\n-  // get anything above 10 ** 36 and print it\n-  Decimal128 top;\n-  std::tie(top, remainder) = Divide(kTenTo36).ValueOrDie();\n-\n-  if (top != 0) {\n-    buf << static_cast<int64_t>(top);\n-    remainder.Abs();\n-    need_fill = true;\n+template <size_t n>\n+static void AppendLittleEndianArrayToString(const std::array<uint64_t, n>& array,\n+                                            std::string* result) {\n+  static_assert(n > 0, \"Array size must be positive\");\n+  size_t most_significant_elem_idx = n - 1;\n+  while (array[most_significant_elem_idx] == 0) {\n+    if (most_significant_elem_idx == 0) {\n+      result->push_back('0');\n+      return;\n+    }\n+    --most_significant_elem_idx;\n+  }\n+\n+  std::array<uint64_t, n> copy = array;\n+  constexpr uint32_t k1e9 = 1000000000U;\n+  constexpr size_t num_bits = n * 64;\n+  // Each segment holds at most 9 decimal digits.\n\nReview comment:\n       There is probably a better description for segments, but that was my first pass.\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -195,42 +191,89 @@ double Decimal128::ToDouble(int32_t scale) const {\n   return DecimalDoubleConversion::ToReal(*this, scale);\n }\n \n-std::string Decimal128::ToIntegerString() const {\n-  Decimal128 remainder;\n-  std::stringstream buf;\n-  bool need_fill = false;\n-\n-  // get anything above 10 ** 36 and print it\n-  Decimal128 top;\n-  std::tie(top, remainder) = Divide(kTenTo36).ValueOrDie();\n-\n-  if (top != 0) {\n-    buf << static_cast<int64_t>(top);\n-    remainder.Abs();\n-    need_fill = true;\n+template <size_t n>\n+static void AppendLittleEndianArrayToString(const std::array<uint64_t, n>& array,\n+                                            std::string* result) {\n+  static_assert(n > 0, \"Array size must be positive\");\n+  size_t most_significant_elem_idx = n - 1;\n+  while (array[most_significant_elem_idx] == 0) {\n+    if (most_significant_elem_idx == 0) {\n+      result->push_back('0');\n+      return;\n+    }\n+    --most_significant_elem_idx;\n+  }\n+\n+  std::array<uint64_t, n> copy = array;\n+  constexpr uint32_t k1e9 = 1000000000U;\n+  constexpr size_t num_bits = n * 64;\n+  // Each segment holds at most 9 decimal digits.\n+  // The number of segments needed = ceil(num_bits * log(2) / log(1e9))\n+  // = ceil(num_bits / 29.897352854) <= ceil(num_bits / 29).\n+  std::array<uint32_t, (num_bits + 28) / 29> segments;\n+  size_t num_segments = 0;\n+  uint64_t* most_significant_elem = &copy[most_significant_elem_idx];\n+  do {\n+    // Compute remainder = copy % 1e9 and copy = copy / 1e9.\n+    uint32_t remainder = 0;\n+    uint64_t* elem = most_significant_elem;\n+    do {\n+      uint32_t hi = static_cast<uint32_t>(*elem >> 32);\n\nReview comment:\n       Please add a comment (or make the loop its own method with a descriptive name) indicating what this is doing in little bit more detail, it took me a while to grok it.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-13T16:25:56.667+0000",
                    "updated": "2020-08-13T16:25:56.667+0000",
                    "started": "2020-08-13T16:25:56.667+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "470313",
                    "issueId": "13322354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322354/worklog/470544",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "MingyuZhong commented on a change in pull request #7945:\nURL: https://github.com/apache/arrow/pull/7945#discussion_r470384562\n\n\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -195,42 +191,89 @@ double Decimal128::ToDouble(int32_t scale) const {\n   return DecimalDoubleConversion::ToReal(*this, scale);\n }\n \n-std::string Decimal128::ToIntegerString() const {\n-  Decimal128 remainder;\n-  std::stringstream buf;\n-  bool need_fill = false;\n-\n-  // get anything above 10 ** 36 and print it\n-  Decimal128 top;\n-  std::tie(top, remainder) = Divide(kTenTo36).ValueOrDie();\n-\n-  if (top != 0) {\n-    buf << static_cast<int64_t>(top);\n-    remainder.Abs();\n-    need_fill = true;\n+template <size_t n>\n+static void AppendLittleEndianArrayToString(const std::array<uint64_t, n>& array,\n+                                            std::string* result) {\n+  static_assert(n > 0, \"Array size must be positive\");\n+  size_t most_significant_elem_idx = n - 1;\n\nReview comment:\n       Done.\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -195,42 +191,89 @@ double Decimal128::ToDouble(int32_t scale) const {\n   return DecimalDoubleConversion::ToReal(*this, scale);\n }\n \n-std::string Decimal128::ToIntegerString() const {\n-  Decimal128 remainder;\n-  std::stringstream buf;\n-  bool need_fill = false;\n-\n-  // get anything above 10 ** 36 and print it\n-  Decimal128 top;\n-  std::tie(top, remainder) = Divide(kTenTo36).ValueOrDie();\n-\n-  if (top != 0) {\n-    buf << static_cast<int64_t>(top);\n-    remainder.Abs();\n-    need_fill = true;\n+template <size_t n>\n+static void AppendLittleEndianArrayToString(const std::array<uint64_t, n>& array,\n+                                            std::string* result) {\n+  static_assert(n > 0, \"Array size must be positive\");\n+  size_t most_significant_elem_idx = n - 1;\n+  while (array[most_significant_elem_idx] == 0) {\n+    if (most_significant_elem_idx == 0) {\n+      result->push_back('0');\n+      return;\n+    }\n+    --most_significant_elem_idx;\n+  }\n+\n+  std::array<uint64_t, n> copy = array;\n+  constexpr uint32_t k1e9 = 1000000000U;\n+  constexpr size_t num_bits = n * 64;\n\nReview comment:\n       Done.\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -195,42 +191,89 @@ double Decimal128::ToDouble(int32_t scale) const {\n   return DecimalDoubleConversion::ToReal(*this, scale);\n }\n \n-std::string Decimal128::ToIntegerString() const {\n-  Decimal128 remainder;\n-  std::stringstream buf;\n-  bool need_fill = false;\n-\n-  // get anything above 10 ** 36 and print it\n-  Decimal128 top;\n-  std::tie(top, remainder) = Divide(kTenTo36).ValueOrDie();\n-\n-  if (top != 0) {\n-    buf << static_cast<int64_t>(top);\n-    remainder.Abs();\n-    need_fill = true;\n+template <size_t n>\n+static void AppendLittleEndianArrayToString(const std::array<uint64_t, n>& array,\n+                                            std::string* result) {\n+  static_assert(n > 0, \"Array size must be positive\");\n+  size_t most_significant_elem_idx = n - 1;\n+  while (array[most_significant_elem_idx] == 0) {\n+    if (most_significant_elem_idx == 0) {\n+      result->push_back('0');\n+      return;\n+    }\n+    --most_significant_elem_idx;\n+  }\n+\n+  std::array<uint64_t, n> copy = array;\n+  constexpr uint32_t k1e9 = 1000000000U;\n+  constexpr size_t num_bits = n * 64;\n+  // Each segment holds at most 9 decimal digits.\n\nReview comment:\n       Updated comment. The input is always non-negative, so \"twos complement\" is irrelevant.\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -195,42 +191,89 @@ double Decimal128::ToDouble(int32_t scale) const {\n   return DecimalDoubleConversion::ToReal(*this, scale);\n }\n \n-std::string Decimal128::ToIntegerString() const {\n-  Decimal128 remainder;\n-  std::stringstream buf;\n-  bool need_fill = false;\n-\n-  // get anything above 10 ** 36 and print it\n-  Decimal128 top;\n-  std::tie(top, remainder) = Divide(kTenTo36).ValueOrDie();\n-\n-  if (top != 0) {\n-    buf << static_cast<int64_t>(top);\n-    remainder.Abs();\n-    need_fill = true;\n+template <size_t n>\n+static void AppendLittleEndianArrayToString(const std::array<uint64_t, n>& array,\n+                                            std::string* result) {\n+  static_assert(n > 0, \"Array size must be positive\");\n+  size_t most_significant_elem_idx = n - 1;\n+  while (array[most_significant_elem_idx] == 0) {\n+    if (most_significant_elem_idx == 0) {\n+      result->push_back('0');\n+      return;\n+    }\n+    --most_significant_elem_idx;\n+  }\n+\n+  std::array<uint64_t, n> copy = array;\n+  constexpr uint32_t k1e9 = 1000000000U;\n+  constexpr size_t num_bits = n * 64;\n+  // Each segment holds at most 9 decimal digits.\n+  // The number of segments needed = ceil(num_bits * log(2) / log(1e9))\n+  // = ceil(num_bits / 29.897352854) <= ceil(num_bits / 29).\n+  std::array<uint32_t, (num_bits + 28) / 29> segments;\n+  size_t num_segments = 0;\n+  uint64_t* most_significant_elem = &copy[most_significant_elem_idx];\n+  do {\n+    // Compute remainder = copy % 1e9 and copy = copy / 1e9.\n+    uint32_t remainder = 0;\n+    uint64_t* elem = most_significant_elem;\n+    do {\n+      uint32_t hi = static_cast<uint32_t>(*elem >> 32);\n\nReview comment:\n       Done.\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -195,42 +191,89 @@ double Decimal128::ToDouble(int32_t scale) const {\n   return DecimalDoubleConversion::ToReal(*this, scale);\n }\n \n-std::string Decimal128::ToIntegerString() const {\n-  Decimal128 remainder;\n-  std::stringstream buf;\n-  bool need_fill = false;\n-\n-  // get anything above 10 ** 36 and print it\n-  Decimal128 top;\n-  std::tie(top, remainder) = Divide(kTenTo36).ValueOrDie();\n-\n-  if (top != 0) {\n-    buf << static_cast<int64_t>(top);\n-    remainder.Abs();\n-    need_fill = true;\n+template <size_t n>\n+static void AppendLittleEndianArrayToString(const std::array<uint64_t, n>& array,\n+                                            std::string* result) {\n+  static_assert(n > 0, \"Array size must be positive\");\n+  size_t most_significant_elem_idx = n - 1;\n+  while (array[most_significant_elem_idx] == 0) {\n+    if (most_significant_elem_idx == 0) {\n+      result->push_back('0');\n+      return;\n+    }\n+    --most_significant_elem_idx;\n+  }\n+\n+  std::array<uint64_t, n> copy = array;\n+  constexpr uint32_t k1e9 = 1000000000U;\n+  constexpr size_t num_bits = n * 64;\n+  // Each segment holds at most 9 decimal digits.\n+  // The number of segments needed = ceil(num_bits * log(2) / log(1e9))\n+  // = ceil(num_bits / 29.897352854) <= ceil(num_bits / 29).\n+  std::array<uint32_t, (num_bits + 28) / 29> segments;\n+  size_t num_segments = 0;\n+  uint64_t* most_significant_elem = &copy[most_significant_elem_idx];\n+  do {\n+    // Compute remainder = copy % 1e9 and copy = copy / 1e9.\n+    uint32_t remainder = 0;\n+    uint64_t* elem = most_significant_elem;\n+    do {\n+      uint32_t hi = static_cast<uint32_t>(*elem >> 32);\n+      uint32_t lo = static_cast<uint32_t>(*elem & ~uint32_t{0});\n\nReview comment:\n       Done.\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -195,42 +191,89 @@ double Decimal128::ToDouble(int32_t scale) const {\n   return DecimalDoubleConversion::ToReal(*this, scale);\n }\n \n-std::string Decimal128::ToIntegerString() const {\n-  Decimal128 remainder;\n-  std::stringstream buf;\n-  bool need_fill = false;\n-\n-  // get anything above 10 ** 36 and print it\n-  Decimal128 top;\n-  std::tie(top, remainder) = Divide(kTenTo36).ValueOrDie();\n-\n-  if (top != 0) {\n-    buf << static_cast<int64_t>(top);\n-    remainder.Abs();\n-    need_fill = true;\n+template <size_t n>\n+static void AppendLittleEndianArrayToString(const std::array<uint64_t, n>& array,\n+                                            std::string* result) {\n+  static_assert(n > 0, \"Array size must be positive\");\n+  size_t most_significant_elem_idx = n - 1;\n+  while (array[most_significant_elem_idx] == 0) {\n+    if (most_significant_elem_idx == 0) {\n+      result->push_back('0');\n+      return;\n+    }\n+    --most_significant_elem_idx;\n+  }\n+\n+  std::array<uint64_t, n> copy = array;\n+  constexpr uint32_t k1e9 = 1000000000U;\n+  constexpr size_t num_bits = n * 64;\n+  // Each segment holds at most 9 decimal digits.\n+  // The number of segments needed = ceil(num_bits * log(2) / log(1e9))\n+  // = ceil(num_bits / 29.897352854) <= ceil(num_bits / 29).\n+  std::array<uint32_t, (num_bits + 28) / 29> segments;\n+  size_t num_segments = 0;\n+  uint64_t* most_significant_elem = &copy[most_significant_elem_idx];\n+  do {\n+    // Compute remainder = copy % 1e9 and copy = copy / 1e9.\n+    uint32_t remainder = 0;\n+    uint64_t* elem = most_significant_elem;\n+    do {\n+      uint32_t hi = static_cast<uint32_t>(*elem >> 32);\n+      uint32_t lo = static_cast<uint32_t>(*elem & ~uint32_t{0});\n+      uint64_t dividend_hi = (static_cast<uint64_t>(remainder) << 32) | hi;\n+      uint64_t quotient_hi = dividend_hi / k1e9;\n+      remainder = static_cast<uint32_t>(dividend_hi % k1e9);\n+      uint64_t dividend_lo = (static_cast<uint64_t>(remainder) << 32) | lo;\n+      uint64_t quotient_lo = dividend_lo / k1e9;\n+      remainder = static_cast<uint32_t>(dividend_lo % k1e9);\n+      *elem = (quotient_hi << 32) | quotient_lo;\n+    } while (elem-- != copy.data());\n+\n+    segments[num_segments++] = remainder;\n+  } while (*most_significant_elem != 0 || most_significant_elem-- != copy.data());\n+\n+  size_t old_size = result->size();\n+  size_t new_size = old_size + num_segments * 9;\n+  result->resize(new_size);\n+  char* output = &result->at(0) + old_size;\n\nReview comment:\n       Changed to \"&result->at(old_size)\". \"&result[old_size]\" would be a string* pointer.\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -195,42 +191,89 @@ double Decimal128::ToDouble(int32_t scale) const {\n   return DecimalDoubleConversion::ToReal(*this, scale);\n }\n \n-std::string Decimal128::ToIntegerString() const {\n-  Decimal128 remainder;\n-  std::stringstream buf;\n-  bool need_fill = false;\n-\n-  // get anything above 10 ** 36 and print it\n-  Decimal128 top;\n-  std::tie(top, remainder) = Divide(kTenTo36).ValueOrDie();\n-\n-  if (top != 0) {\n-    buf << static_cast<int64_t>(top);\n-    remainder.Abs();\n-    need_fill = true;\n+template <size_t n>\n+static void AppendLittleEndianArrayToString(const std::array<uint64_t, n>& array,\n+                                            std::string* result) {\n+  static_assert(n > 0, \"Array size must be positive\");\n+  size_t most_significant_elem_idx = n - 1;\n+  while (array[most_significant_elem_idx] == 0) {\n+    if (most_significant_elem_idx == 0) {\n+      result->push_back('0');\n+      return;\n+    }\n+    --most_significant_elem_idx;\n+  }\n+\n+  std::array<uint64_t, n> copy = array;\n+  constexpr uint32_t k1e9 = 1000000000U;\n+  constexpr size_t num_bits = n * 64;\n+  // Each segment holds at most 9 decimal digits.\n+  // The number of segments needed = ceil(num_bits * log(2) / log(1e9))\n+  // = ceil(num_bits / 29.897352854) <= ceil(num_bits / 29).\n+  std::array<uint32_t, (num_bits + 28) / 29> segments;\n+  size_t num_segments = 0;\n+  uint64_t* most_significant_elem = &copy[most_significant_elem_idx];\n+  do {\n+    // Compute remainder = copy % 1e9 and copy = copy / 1e9.\n+    uint32_t remainder = 0;\n+    uint64_t* elem = most_significant_elem;\n+    do {\n+      uint32_t hi = static_cast<uint32_t>(*elem >> 32);\n+      uint32_t lo = static_cast<uint32_t>(*elem & ~uint32_t{0});\n+      uint64_t dividend_hi = (static_cast<uint64_t>(remainder) << 32) | hi;\n+      uint64_t quotient_hi = dividend_hi / k1e9;\n+      remainder = static_cast<uint32_t>(dividend_hi % k1e9);\n+      uint64_t dividend_lo = (static_cast<uint64_t>(remainder) << 32) | lo;\n+      uint64_t quotient_lo = dividend_lo / k1e9;\n+      remainder = static_cast<uint32_t>(dividend_lo % k1e9);\n+      *elem = (quotient_hi << 32) | quotient_lo;\n+    } while (elem-- != copy.data());\n+\n+    segments[num_segments++] = remainder;\n+  } while (*most_significant_elem != 0 || most_significant_elem-- != copy.data());\n+\n+  size_t old_size = result->size();\n+  size_t new_size = old_size + num_segments * 9;\n+  result->resize(new_size);\n+  char* output = &result->at(0) + old_size;\n\nReview comment:\n       Changed to \"&result->at(old_size)\". Can't use iterator because of memmove.\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -195,42 +191,89 @@ double Decimal128::ToDouble(int32_t scale) const {\n   return DecimalDoubleConversion::ToReal(*this, scale);\n }\n \n-std::string Decimal128::ToIntegerString() const {\n-  Decimal128 remainder;\n-  std::stringstream buf;\n-  bool need_fill = false;\n-\n-  // get anything above 10 ** 36 and print it\n-  Decimal128 top;\n-  std::tie(top, remainder) = Divide(kTenTo36).ValueOrDie();\n-\n-  if (top != 0) {\n-    buf << static_cast<int64_t>(top);\n-    remainder.Abs();\n-    need_fill = true;\n+template <size_t n>\n+static void AppendLittleEndianArrayToString(const std::array<uint64_t, n>& array,\n+                                            std::string* result) {\n+  static_assert(n > 0, \"Array size must be positive\");\n+  size_t most_significant_elem_idx = n - 1;\n+  while (array[most_significant_elem_idx] == 0) {\n+    if (most_significant_elem_idx == 0) {\n+      result->push_back('0');\n+      return;\n+    }\n+    --most_significant_elem_idx;\n+  }\n+\n+  std::array<uint64_t, n> copy = array;\n+  constexpr uint32_t k1e9 = 1000000000U;\n+  constexpr size_t num_bits = n * 64;\n+  // Each segment holds at most 9 decimal digits.\n+  // The number of segments needed = ceil(num_bits * log(2) / log(1e9))\n+  // = ceil(num_bits / 29.897352854) <= ceil(num_bits / 29).\n+  std::array<uint32_t, (num_bits + 28) / 29> segments;\n+  size_t num_segments = 0;\n+  uint64_t* most_significant_elem = &copy[most_significant_elem_idx];\n+  do {\n+    // Compute remainder = copy % 1e9 and copy = copy / 1e9.\n+    uint32_t remainder = 0;\n+    uint64_t* elem = most_significant_elem;\n+    do {\n+      uint32_t hi = static_cast<uint32_t>(*elem >> 32);\n+      uint32_t lo = static_cast<uint32_t>(*elem & ~uint32_t{0});\n+      uint64_t dividend_hi = (static_cast<uint64_t>(remainder) << 32) | hi;\n+      uint64_t quotient_hi = dividend_hi / k1e9;\n+      remainder = static_cast<uint32_t>(dividend_hi % k1e9);\n+      uint64_t dividend_lo = (static_cast<uint64_t>(remainder) << 32) | lo;\n+      uint64_t quotient_lo = dividend_lo / k1e9;\n+      remainder = static_cast<uint32_t>(dividend_lo % k1e9);\n+      *elem = (quotient_hi << 32) | quotient_lo;\n+    } while (elem-- != copy.data());\n+\n+    segments[num_segments++] = remainder;\n+  } while (*most_significant_elem != 0 || most_significant_elem-- != copy.data());\n+\n+  size_t old_size = result->size();\n+  size_t new_size = old_size + num_segments * 9;\n+  result->resize(new_size);\n+  char* output = &result->at(0) + old_size;\n+  const uint32_t* segment = &segments[num_segments - 1];\n+  size_t num_digits_in_first_segment = 9;\n+  uint32_t digits = *segment;\n+  for (int j = 8; j >= 0; --j) {\n+    output[j] = static_cast<char>(digits % 10) + '0';\n\nReview comment:\n       Done.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-14T03:07:58.691+0000",
                    "updated": "2020-08-14T03:07:58.691+0000",
                    "started": "2020-08-14T03:07:58.691+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "470544",
                    "issueId": "13322354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322354/worklog/470545",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "MingyuZhong commented on a change in pull request #7945:\nURL: https://github.com/apache/arrow/pull/7945#discussion_r470384776\n\n\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -241,64 +284,43 @@ Decimal128::operator int64_t() const {\n   return static_cast<int64_t>(low_bits());\n }\n \n-static std::string ToStringNegativeScale(const std::string& str,\n-                                         int32_t adjusted_exponent, bool is_negative) {\n-  std::stringstream buf;\n-\n-  size_t offset = 0;\n-  buf << str[offset++];\n-\n-  if (is_negative) {\n-    buf << str[offset++];\n-  }\n-\n-  buf << '.' << str.substr(offset, std::string::npos) << 'E' << std::showpos\n-      << adjusted_exponent;\n-  return buf.str();\n-}\n-\n-std::string Decimal128::ToString(int32_t scale) const {\n-  const std::string str(ToIntegerString());\n-\n+static void AdjustIntegerStringWithScale(int32_t scale, std::string* str) {\n   if (scale == 0) {\n-    return str;\n+    return;\n   }\n \n-  const bool is_negative = *this < 0;\n-\n-  const auto len = static_cast<int32_t>(str.size());\n+  const bool is_negative = str->front() == '-';\n   const auto is_negative_offset = static_cast<int32_t>(is_negative);\n-  const int32_t adjusted_exponent = -scale + (len - 1 - is_negative_offset);\n+  const auto len = static_cast<int32_t>(str->size());\n+  const int32_t num_digits = len - is_negative_offset;\n+  const int32_t adjusted_exponent = num_digits - 1 - scale;\n \n   /// Note that the -6 is taken from the Java BigDecimal documentation.\n   if (scale < 0 || adjusted_exponent < -6) {\n-    return ToStringNegativeScale(str, adjusted_exponent, is_negative);\n+    str->insert(str->begin() + 1 + is_negative_offset, '.');\n\nReview comment:\n       Added examples. If the value is negative, the decimal point needs to be shifted by one character to account for the sign character.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-14T03:08:12.201+0000",
                    "updated": "2020-08-14T03:08:12.201+0000",
                    "started": "2020-08-14T03:08:12.201+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "470545",
                    "issueId": "13322354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322354/worklog/470546",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "MingyuZhong commented on a change in pull request #7945:\nURL: https://github.com/apache/arrow/pull/7945#discussion_r470384877\n\n\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -241,64 +284,43 @@ Decimal128::operator int64_t() const {\n   return static_cast<int64_t>(low_bits());\n }\n \n-static std::string ToStringNegativeScale(const std::string& str,\n-                                         int32_t adjusted_exponent, bool is_negative) {\n-  std::stringstream buf;\n-\n-  size_t offset = 0;\n-  buf << str[offset++];\n-\n-  if (is_negative) {\n-    buf << str[offset++];\n-  }\n-\n-  buf << '.' << str.substr(offset, std::string::npos) << 'E' << std::showpos\n-      << adjusted_exponent;\n-  return buf.str();\n-}\n-\n-std::string Decimal128::ToString(int32_t scale) const {\n-  const std::string str(ToIntegerString());\n-\n+static void AdjustIntegerStringWithScale(int32_t scale, std::string* str) {\n   if (scale == 0) {\n-    return str;\n+    return;\n   }\n \n-  const bool is_negative = *this < 0;\n-\n-  const auto len = static_cast<int32_t>(str.size());\n+  const bool is_negative = str->front() == '-';\n   const auto is_negative_offset = static_cast<int32_t>(is_negative);\n-  const int32_t adjusted_exponent = -scale + (len - 1 - is_negative_offset);\n+  const auto len = static_cast<int32_t>(str->size());\n+  const int32_t num_digits = len - is_negative_offset;\n+  const int32_t adjusted_exponent = num_digits - 1 - scale;\n \n   /// Note that the -6 is taken from the Java BigDecimal documentation.\n   if (scale < 0 || adjusted_exponent < -6) {\n-    return ToStringNegativeScale(str, adjusted_exponent, is_negative);\n+    str->insert(str->begin() + 1 + is_negative_offset, '.');\n+    str->push_back('E');\n+    // Use stringstream only for printing the exponent integer. It should be short\n+    // enough to avoid memory allocations.\n+    std::stringstream buf;\n+    buf << std::showpos << adjusted_exponent;\n+    *str += buf.str();\n+    return;\n   }\n \n-  if (is_negative) {\n-    if (len - 1 > scale) {\n-      const auto n = static_cast<size_t>(len - scale);\n-      return str.substr(0, n) + \".\" + str.substr(n, static_cast<size_t>(scale));\n-    }\n-\n-    if (len - 1 == scale) {\n-      return \"-0.\" + str.substr(1, std::string::npos);\n-    }\n-\n-    std::string result(\"-0.\" + std::string(static_cast<size_t>(scale - len + 1), '0'));\n-    return result + str.substr(1, std::string::npos);\n-  }\n-\n-  if (len > scale) {\n+  if (num_digits > scale) {\n     const auto n = static_cast<size_t>(len - scale);\n-    return str.substr(0, n) + \".\" + str.substr(n, static_cast<size_t>(scale));\n+    str->insert(str->begin() + n, '.');\n+    return;\n   }\n \n-  if (len == scale) {\n-    return \"0.\" + str;\n-  }\n+  str->insert(is_negative_offset, scale - num_digits + 2, '0');\n\nReview comment:\n       Added examples.\n\n##########\nFile path: cpp/src/arrow/util/decimal_benchmark.cc\n##########\n@@ -26,14 +26,36 @@\n namespace arrow {\n namespace Decimal {\n \n-static void FromString(benchmark::State& state) {  // NOLINT non-const reference\n-  std::vector<std::string> values = {\"0\",\n-                                     \"1.23\",\n-                                     \"12.345e6\",\n-                                     \"-12.345e-6\",\n-                                     \"123456789.123456789\",\n-                                     \"1231234567890.451234567890\"};\n+static const std::vector<std::string>& GetValuesAsString() {\n+  static const std::vector<std::string>* values =\n+      new std::vector<std::string>{\"0\",\n\nReview comment:\n       Done. In my organization, we are disallowed to define non-POD static variables, so I got this habit.\n\n##########\nFile path: cpp/src/arrow/util/decimal_benchmark.cc\n##########\n@@ -26,14 +26,36 @@\n namespace arrow {\n namespace Decimal {\n \n-static void FromString(benchmark::State& state) {  // NOLINT non-const reference\n-  std::vector<std::string> values = {\"0\",\n-                                     \"1.23\",\n-                                     \"12.345e6\",\n-                                     \"-12.345e-6\",\n-                                     \"123456789.123456789\",\n-                                     \"1231234567890.451234567890\"};\n+static const std::vector<std::string>& GetValuesAsString() {\n+  static const std::vector<std::string>* values =\n+      new std::vector<std::string>{\"0\",\n+                                   \"1.23\",\n+                                   \"12.345e6\",\n+                                   \"-12.345e-6\",\n+                                   \"123456789.123456789\",\n+                                   \"1231234567890.451234567890\"};\n+  return *values;\n+}\n+\n+static std::vector<std::pair<Decimal128, int32_t>> BuildDecimalValuesAndScales() {\n\nReview comment:\n       Done.\n\n##########\nFile path: cpp/src/arrow/util/decimal_benchmark.cc\n##########\n@@ -26,14 +26,36 @@\n namespace arrow {\n namespace Decimal {\n \n-static void FromString(benchmark::State& state) {  // NOLINT non-const reference\n-  std::vector<std::string> values = {\"0\",\n-                                     \"1.23\",\n-                                     \"12.345e6\",\n-                                     \"-12.345e-6\",\n-                                     \"123456789.123456789\",\n-                                     \"1231234567890.451234567890\"};\n+static const std::vector<std::string>& GetValuesAsString() {\n+  static const std::vector<std::string>* values =\n+      new std::vector<std::string>{\"0\",\n+                                   \"1.23\",\n+                                   \"12.345e6\",\n+                                   \"-12.345e-6\",\n+                                   \"123456789.123456789\",\n+                                   \"1231234567890.451234567890\"};\n+  return *values;\n+}\n+\n+static std::vector<std::pair<Decimal128, int32_t>> BuildDecimalValuesAndScales() {\n+  const std::vector<std::string>& value_strs = GetValuesAsString();\n+  std::vector<std::pair<Decimal128, int32_t>> result(value_strs.size());\n+  for (size_t i = 0; i < value_strs.size(); ++i) {\n+    int32_t precision;\n+    Decimal128::FromString(value_strs[i], &result[i].first, &result[i].second,\n+                           &precision);\n+  }\n+  return result;\n+}\n+\n+static const std::vector<std::pair<Decimal128, int32_t>>& GetDecimalValuesAndScales() {\n+  static const auto* values =\n+      new std::vector<std::pair<Decimal128, int32_t>>(BuildDecimalValuesAndScales());\n\nReview comment:\n       Moved the caching to the static variable in ToString. Completely removing caching would add 1ns to the benchmark.\n\n##########\nFile path: cpp/src/arrow/util/decimal_test.cc\n##########\n@@ -106,6 +99,33 @@ TEST(DecimalTest, TestFromDecimalString128) {\n   ASSERT_NE(result.high_bits(), 0);\n }\n \n+TEST(DecimalTest, TestStringRoundTrip) {\n+  static constexpr uint64_t kTestBits[] = {\n+      0,\n+      1,\n+      999,\n+      1000,\n+      std::numeric_limits<int32_t>::max(),\n+      (1ull << 31),\n+      std::numeric_limits<uint32_t>::max(),\n+      (1ull << 32),\n+      std::numeric_limits<int64_t>::max(),\n+      (1ull << 63),\n+      std::numeric_limits<uint64_t>::max(),\n+  };\n+  static constexpr int32_t kScales[] = {-10, -1, 0, 1, 10};\n+  for (uint64_t high_bits : kTestBits) {\n\nReview comment:\n       It's already covered. Added a comment. Decimal128ToStringTest has more explicit tests on negative values.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-14T03:09:06.297+0000",
                    "updated": "2020-08-14T03:09:06.297+0000",
                    "started": "2020-08-14T03:09:06.297+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "470546",
                    "issueId": "13322354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322354/worklog/470550",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "MingyuZhong commented on a change in pull request #7945:\nURL: https://github.com/apache/arrow/pull/7945#discussion_r470393889\n\n\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -241,64 +284,43 @@ Decimal128::operator int64_t() const {\n   return static_cast<int64_t>(low_bits());\n }\n \n-static std::string ToStringNegativeScale(const std::string& str,\n-                                         int32_t adjusted_exponent, bool is_negative) {\n-  std::stringstream buf;\n-\n-  size_t offset = 0;\n-  buf << str[offset++];\n-\n-  if (is_negative) {\n-    buf << str[offset++];\n-  }\n-\n-  buf << '.' << str.substr(offset, std::string::npos) << 'E' << std::showpos\n-      << adjusted_exponent;\n-  return buf.str();\n-}\n-\n-std::string Decimal128::ToString(int32_t scale) const {\n-  const std::string str(ToIntegerString());\n-\n+static void AdjustIntegerStringWithScale(int32_t scale, std::string* str) {\n   if (scale == 0) {\n-    return str;\n+    return;\n   }\n \n-  const bool is_negative = *this < 0;\n-\n-  const auto len = static_cast<int32_t>(str.size());\n+  const bool is_negative = str->front() == '-';\n   const auto is_negative_offset = static_cast<int32_t>(is_negative);\n-  const int32_t adjusted_exponent = -scale + (len - 1 - is_negative_offset);\n+  const auto len = static_cast<int32_t>(str->size());\n+  const int32_t num_digits = len - is_negative_offset;\n+  const int32_t adjusted_exponent = num_digits - 1 - scale;\n \n   /// Note that the -6 is taken from the Java BigDecimal documentation.\n   if (scale < 0 || adjusted_exponent < -6) {\n-    return ToStringNegativeScale(str, adjusted_exponent, is_negative);\n+    str->insert(str->begin() + 1 + is_negative_offset, '.');\n+    str->push_back('E');\n+    // Use stringstream only for printing the exponent integer. It should be short\n\nReview comment:\n       std::string doubles the capacity in every growth and the initial allocation size is > 23, so I don't think this code block can possibly trigger 2+ allocations, and thus reserve() will not save any allocation.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-14T03:46:54.868+0000",
                    "updated": "2020-08-14T03:46:54.868+0000",
                    "started": "2020-08-14T03:46:54.868+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "470550",
                    "issueId": "13322354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322354/worklog/470564",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #7945:\nURL: https://github.com/apache/arrow/pull/7945#issuecomment-673878158\n\n\n   LGTM.  @pitrou any more comments?\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-14T04:35:25.667+0000",
                    "updated": "2020-08-14T04:35:25.667+0000",
                    "started": "2020-08-14T04:35:25.667+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "470564",
                    "issueId": "13322354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322354/worklog/471484",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #7945:\nURL: https://github.com/apache/arrow/pull/7945#discussion_r471472052\n\n\n\n##########\nFile path: cpp/src/arrow/util/decimal.cc\n##########\n@@ -241,64 +284,43 @@ Decimal128::operator int64_t() const {\n   return static_cast<int64_t>(low_bits());\n }\n \n-static std::string ToStringNegativeScale(const std::string& str,\n-                                         int32_t adjusted_exponent, bool is_negative) {\n-  std::stringstream buf;\n-\n-  size_t offset = 0;\n-  buf << str[offset++];\n-\n-  if (is_negative) {\n-    buf << str[offset++];\n-  }\n-\n-  buf << '.' << str.substr(offset, std::string::npos) << 'E' << std::showpos\n-      << adjusted_exponent;\n-  return buf.str();\n-}\n-\n-std::string Decimal128::ToString(int32_t scale) const {\n-  const std::string str(ToIntegerString());\n-\n+static void AdjustIntegerStringWithScale(int32_t scale, std::string* str) {\n   if (scale == 0) {\n-    return str;\n+    return;\n   }\n \n-  const bool is_negative = *this < 0;\n-\n-  const auto len = static_cast<int32_t>(str.size());\n+  const bool is_negative = str->front() == '-';\n   const auto is_negative_offset = static_cast<int32_t>(is_negative);\n-  const int32_t adjusted_exponent = -scale + (len - 1 - is_negative_offset);\n+  const auto len = static_cast<int32_t>(str->size());\n+  const int32_t num_digits = len - is_negative_offset;\n+  const int32_t adjusted_exponent = num_digits - 1 - scale;\n \n   /// Note that the -6 is taken from the Java BigDecimal documentation.\n   if (scale < 0 || adjusted_exponent < -6) {\n-    return ToStringNegativeScale(str, adjusted_exponent, is_negative);\n+    str->insert(str->begin() + 1 + is_negative_offset, '.');\n+    str->push_back('E');\n+    // Use stringstream only for printing the exponent integer. It should be short\n+    // enough to avoid memory allocations.\n+    std::stringstream buf;\n+    buf << std::showpos << adjusted_exponent;\n+    *str += buf.str();\n+    return;\n   }\n \n-  if (is_negative) {\n-    if (len - 1 > scale) {\n-      const auto n = static_cast<size_t>(len - scale);\n-      return str.substr(0, n) + \".\" + str.substr(n, static_cast<size_t>(scale));\n-    }\n-\n-    if (len - 1 == scale) {\n-      return \"-0.\" + str.substr(1, std::string::npos);\n-    }\n-\n-    std::string result(\"-0.\" + std::string(static_cast<size_t>(scale - len + 1), '0'));\n-    return result + str.substr(1, std::string::npos);\n-  }\n-\n-  if (len > scale) {\n+  if (num_digits > scale) {\n     const auto n = static_cast<size_t>(len - scale);\n-    return str.substr(0, n) + \".\" + str.substr(n, static_cast<size_t>(scale));\n+    str->insert(str->begin() + n, '.');\n+    return;\n   }\n \n-  if (len == scale) {\n-    return \"0.\" + str;\n-  }\n+  str->insert(is_negative_offset, scale - num_digits + 2, '0');\n\nReview comment:\n       Thank you!\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-17T13:18:44.376+0000",
                    "updated": "2020-08-17T13:18:44.376+0000",
                    "started": "2020-08-17T13:18:44.376+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "471484",
                    "issueId": "13322354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322354/worklog/471490",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #7945:\nURL: https://github.com/apache/arrow/pull/7945#issuecomment-674884766\n\n\n   Will merge if CI passes. Thank you @MingyuZhong !\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-17T13:34:30.045+0000",
                    "updated": "2020-08-17T13:34:30.045+0000",
                    "started": "2020-08-17T13:34:30.045+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "471490",
                    "issueId": "13322354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322354/worklog/471594",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou closed pull request #7945:\nURL: https://github.com/apache/arrow/pull/7945\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-17T18:07:14.699+0000",
                    "updated": "2020-08-17T18:07:14.699+0000",
                    "started": "2020-08-17T18:07:14.699+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "471594",
                    "issueId": "13322354"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 7200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@8ab76dc[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2cb60078[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@260b6809[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@3aa21970[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1b69a2dd[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@4199be6e[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3cafdd74[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@16ec2a08[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@40451d42[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@4ca3a1ea[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@ea59177[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@796e46c1[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 7200,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Aug 17 18:07:07 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-08-17T18:07:07.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9710/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-08-12T19:32:12.000+0000",
        "updated": "2020-08-17T18:07:15.000+0000",
        "timeoriginalestimate": null,
        "description": "Generalize Decimal ToString method in preparation for introducing Decimal256 bit type (and other bit widths as needed).\u00a0\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 7200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Generalize Decimal ToString in preparation for Decimal256",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322354/comment/17179158",
                    "id": "17179158",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 7945\n[https://github.com/apache/arrow/pull/7945]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2020-08-17T18:07:07.377+0000",
                    "updated": "2020-08-17T18:07:07.377+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0hpm0:",
        "customfield_12314139": null
    }
}