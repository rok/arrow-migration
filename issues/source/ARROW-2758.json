{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13168718",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13168718",
    "key": "ARROW-2758",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12342562",
                "id": "12342562",
                "description": "",
                "name": "0.10.0",
                "archived": false,
                "released": true,
                "releaseDate": "2018-08-06"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=guoyuhong85",
            "name": "guoyuhong85",
            "key": "guoyuhong85",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=guoyuhong85&avatarId=36251",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=guoyuhong85&avatarId=36251",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=guoyuhong85&avatarId=36251",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=guoyuhong85&avatarId=36251"
            },
            "displayName": "Yuhong Guo",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12332956",
                "id": "12332956",
                "name": "C++ - Plasma"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=pcmoritz",
            "name": "pcmoritz",
            "key": "pcmoritz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Philipp Moritz",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=pcmoritz",
            "name": "pcmoritz",
            "key": "pcmoritz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Philipp Moritz",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 2400,
            "total": 2400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 2400,
            "total": 2400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2758/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 4,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13168718/worklog/116593",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pcmoritz closed pull request #2179: ARROW-2758: [Plasma] Use Scope enum in Plasma\nURL: https://github.com/apache/arrow/pull/2179\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/cpp/src/plasma/CMakeLists.txt b/cpp/src/plasma/CMakeLists.txt\nindex 8797d9643a..744f9ad23b 100644\n--- a/cpp/src/plasma/CMakeLists.txt\n+++ b/cpp/src/plasma/CMakeLists.txt\n@@ -57,7 +57,7 @@ add_custom_command(\n   # flatbuffers message Message, which can be used to store deserialized\n   # messages in data structures. This is currently used for ObjectInfo for\n   # example.\n-  COMMAND ${FLATBUFFERS_COMPILER} -c -o ${OUTPUT_DIR} ${PLASMA_FBS_SRC} --gen-object-api\n+  COMMAND ${FLATBUFFERS_COMPILER} -c -o ${OUTPUT_DIR} ${PLASMA_FBS_SRC} --gen-object-api --scoped-enums\n   DEPENDS ${PLASMA_FBS_SRC}\n   COMMENT \"Running flatc compiler on ${PLASMA_FBS_SRC}\"\n   VERBATIM)\ndiff --git a/cpp/src/plasma/client.cc b/cpp/src/plasma/client.cc\nindex 30d2e43d32..8e66cf463c 100644\n--- a/cpp/src/plasma/client.cc\n+++ b/cpp/src/plasma/client.cc\n@@ -366,7 +366,7 @@ Status PlasmaClient::Impl::Create(const ObjectID& object_id, int64_t data_size,\n   RETURN_NOT_OK(\n       SendCreateRequest(store_conn_, object_id, data_size, metadata_size, device_num));\n   std::vector<uint8_t> buffer;\n-  RETURN_NOT_OK(PlasmaReceive(store_conn_, MessageType_PlasmaCreateReply, &buffer));\n+  RETURN_NOT_OK(PlasmaReceive(store_conn_, MessageType::PlasmaCreateReply, &buffer));\n   ObjectID id;\n   PlasmaObject object;\n   int store_fd;\n@@ -475,7 +475,7 @@ Status PlasmaClient::Impl::GetBuffers(\n   // client, so we need to send a request to the plasma store.\n   RETURN_NOT_OK(SendGetRequest(store_conn_, &object_ids[0], num_objects, timeout_ms));\n   std::vector<uint8_t> buffer;\n-  RETURN_NOT_OK(PlasmaReceive(store_conn_, MessageType_PlasmaGetReply, &buffer));\n+  RETURN_NOT_OK(PlasmaReceive(store_conn_, MessageType::PlasmaGetReply, &buffer));\n   std::vector<ObjectID> received_object_ids(num_objects);\n   std::vector<PlasmaObject> object_data(num_objects);\n   PlasmaObject* object;\n@@ -677,7 +677,7 @@ Status PlasmaClient::Impl::Contains(const ObjectID& object_id, bool* has_object)\n     // to see if we have the object.\n     RETURN_NOT_OK(SendContainsRequest(store_conn_, object_id));\n     std::vector<uint8_t> buffer;\n-    RETURN_NOT_OK(PlasmaReceive(store_conn_, MessageType_PlasmaContainsReply, &buffer));\n+    RETURN_NOT_OK(PlasmaReceive(store_conn_, MessageType::PlasmaContainsReply, &buffer));\n     ObjectID object_id2;\n     DCHECK_GT(buffer.size(), 0);\n     RETURN_NOT_OK(\n@@ -803,7 +803,7 @@ Status PlasmaClient::Impl::Abort(const ObjectID& object_id) {\n \n   std::vector<uint8_t> buffer;\n   ObjectID id;\n-  int64_t type;\n+  MessageType type;\n   RETURN_NOT_OK(ReadMessage(store_conn_, &type, &buffer));\n   return ReadAbortReply(buffer.data(), buffer.size(), &id);\n }\n@@ -817,7 +817,7 @@ Status PlasmaClient::Impl::Delete(const ObjectID& object_id) {\n     // If we don't already have a reference to the object, we can try to remove the object\n     RETURN_NOT_OK(SendDeleteRequest(store_conn_, object_id));\n     std::vector<uint8_t> buffer;\n-    RETURN_NOT_OK(PlasmaReceive(store_conn_, MessageType_PlasmaDeleteReply, &buffer));\n+    RETURN_NOT_OK(PlasmaReceive(store_conn_, MessageType::PlasmaDeleteReply, &buffer));\n     ObjectID object_id2;\n     DCHECK_GT(buffer.size(), 0);\n     RETURN_NOT_OK(ReadDeleteReply(buffer.data(), buffer.size(), &object_id2));\n@@ -830,7 +830,7 @@ Status PlasmaClient::Impl::Evict(int64_t num_bytes, int64_t& num_bytes_evicted)\n   RETURN_NOT_OK(SendEvictRequest(store_conn_, num_bytes));\n   // Wait for a response with the number of bytes actually evicted.\n   std::vector<uint8_t> buffer;\n-  int64_t type;\n+  MessageType type;\n   RETURN_NOT_OK(ReadMessage(store_conn_, &type, &buffer));\n   return ReadEvictReply(buffer.data(), buffer.size(), num_bytes_evicted);\n }\n@@ -904,7 +904,7 @@ Status PlasmaClient::Impl::Connect(const std::string& store_socket_name,\n   // Send a ConnectRequest to the store to get its memory capacity.\n   RETURN_NOT_OK(SendConnectRequest(store_conn_));\n   std::vector<uint8_t> buffer;\n-  RETURN_NOT_OK(PlasmaReceive(store_conn_, MessageType_PlasmaConnectReply, &buffer));\n+  RETURN_NOT_OK(PlasmaReceive(store_conn_, MessageType::PlasmaConnectReply, &buffer));\n   RETURN_NOT_OK(ReadConnectReply(buffer.data(), buffer.size(), &store_capacity_));\n   return Status::OK();\n }\n@@ -942,7 +942,7 @@ Status PlasmaClient::Impl::Info(const ObjectID& object_id, int* object_status) {\n \n   RETURN_NOT_OK(SendStatusRequest(manager_conn_, &object_id, 1));\n   std::vector<uint8_t> buffer;\n-  RETURN_NOT_OK(PlasmaReceive(manager_conn_, MessageType_PlasmaStatusReply, &buffer));\n+  RETURN_NOT_OK(PlasmaReceive(manager_conn_, MessageType::PlasmaStatusReply, &buffer));\n   ObjectID id;\n   RETURN_NOT_OK(ReadStatusReply(buffer.data(), buffer.size(), &id, object_status, 1));\n   ARROW_CHECK(object_id == id);\n@@ -958,32 +958,32 @@ Status PlasmaClient::Impl::Wait(int64_t num_object_requests,\n   ARROW_CHECK(num_ready_objects <= num_object_requests);\n \n   for (int i = 0; i < num_object_requests; ++i) {\n-    ARROW_CHECK(object_requests[i].type == PLASMA_QUERY_LOCAL ||\n-                object_requests[i].type == PLASMA_QUERY_ANYWHERE);\n+    ARROW_CHECK(object_requests[i].type == ObjectRequestType::PLASMA_QUERY_LOCAL ||\n+                object_requests[i].type == ObjectRequestType::PLASMA_QUERY_ANYWHERE);\n   }\n \n   RETURN_NOT_OK(SendWaitRequest(manager_conn_, object_requests, num_object_requests,\n                                 num_ready_objects, timeout_ms));\n   std::vector<uint8_t> buffer;\n-  RETURN_NOT_OK(PlasmaReceive(manager_conn_, MessageType_PlasmaWaitReply, &buffer));\n+  RETURN_NOT_OK(PlasmaReceive(manager_conn_, MessageType::PlasmaWaitReply, &buffer));\n   RETURN_NOT_OK(\n       ReadWaitReply(buffer.data(), buffer.size(), object_requests, &num_ready_objects));\n \n   *num_objects_ready = 0;\n   for (int i = 0; i < num_object_requests; ++i) {\n-    int type = object_requests[i].type;\n-    int status = object_requests[i].status;\n+    ObjectRequestType type = object_requests[i].type;\n+    ObjectStatus status = object_requests[i].status;\n     switch (type) {\n-      case PLASMA_QUERY_LOCAL:\n-        if (status == ObjectStatus_Local) {\n+      case ObjectRequestType::PLASMA_QUERY_LOCAL:\n+        if (status == ObjectStatus::Local) {\n           *num_objects_ready += 1;\n         }\n         break;\n-      case PLASMA_QUERY_ANYWHERE:\n-        if (status == ObjectStatus_Local || status == ObjectStatus_Remote) {\n+      case ObjectRequestType::PLASMA_QUERY_ANYWHERE:\n+        if (status == ObjectStatus::Local || status == ObjectStatus::Remote) {\n           *num_objects_ready += 1;\n         } else {\n-          ARROW_CHECK(status == ObjectStatus_Nonexistent);\n+          ARROW_CHECK(status == ObjectStatus::Nonexistent);\n         }\n         break;\n       default:\ndiff --git a/cpp/src/plasma/client.h b/cpp/src/plasma/client.h\nindex c3b5548728..5501488144 100644\n--- a/cpp/src/plasma/client.h\n+++ b/cpp/src/plasma/client.h\n@@ -259,15 +259,15 @@ class ARROW_EXPORT PlasmaClient {\n   ///        \"type\" field.\n   ///        - A PLASMA_QUERY_LOCAL request is satisfied when object_id becomes\n   ///          available in the local Plasma Store. In this case, this function\n-  ///          sets the \"status\" field to ObjectStatus_Local. Note, if the\n+  ///          sets the \"status\" field to ObjectStatus::Local. Note, if the\n   ///          status\n-  ///          is not ObjectStatus_Local, it will be ObjectStatus_Nonexistent,\n+  ///          is not ObjectStatus::Local, it will be ObjectStatus::Nonexistent,\n   ///          but it may exist elsewhere in the system.\n   ///        - A PLASMA_QUERY_ANYWHERE request is satisfied when object_id\n   ///        becomes\n   ///          available either at the local Plasma Store or on a remote Plasma\n   ///          Store. In this case, the functions sets the \"status\" field to\n-  ///          ObjectStatus_Local or ObjectStatus_Remote.\n+  ///          ObjectStatus::Local or ObjectStatus::Remote.\n   /// \\param num_ready_objects The number of requests in object_requests array\n   /// that\n   ///        must be satisfied before the function returns, unless it timeouts.\ndiff --git a/cpp/src/plasma/common.cc b/cpp/src/plasma/common.cc\nindex 7ac5413552..2e3899b80a 100644\n--- a/cpp/src/plasma/common.cc\n+++ b/cpp/src/plasma/common.cc\n@@ -78,24 +78,24 @@ bool UniqueID::operator==(const UniqueID& rhs) const {\n   return std::memcmp(data(), rhs.data(), kUniqueIDSize) == 0;\n }\n \n-Status plasma_error_status(int plasma_error) {\n+Status plasma_error_status(PlasmaError plasma_error) {\n   switch (plasma_error) {\n-    case PlasmaError_OK:\n+    case PlasmaError::OK:\n       return Status::OK();\n-    case PlasmaError_ObjectExists:\n+    case PlasmaError::ObjectExists:\n       return Status::PlasmaObjectExists(\"object already exists in the plasma store\");\n-    case PlasmaError_ObjectNonexistent:\n+    case PlasmaError::ObjectNonexistent:\n       return Status::PlasmaObjectNonexistent(\"object does not exist in the plasma store\");\n-    case PlasmaError_OutOfMemory:\n+    case PlasmaError::OutOfMemory:\n       return Status::PlasmaStoreFull(\"object does not fit in the plasma store\");\n     default:\n-      ARROW_LOG(FATAL) << \"unknown plasma error code \" << plasma_error;\n+      ARROW_LOG(FATAL) << \"unknown plasma error code \" << static_cast<int>(plasma_error);\n   }\n   return Status::OK();\n }\n \n-ARROW_EXPORT int ObjectStatusLocal = ObjectStatus_Local;\n-ARROW_EXPORT int ObjectStatusRemote = ObjectStatus_Remote;\n+ARROW_EXPORT ObjectStatus ObjectStatusLocal = ObjectStatus::Local;\n+ARROW_EXPORT ObjectStatus ObjectStatusRemote = ObjectStatus::Remote;\n \n const PlasmaStoreInfo* plasma_config;\n \ndiff --git a/cpp/src/plasma/common.h b/cpp/src/plasma/common.h\nindex 7dbcf804b0..90cd6a0eff 100644\n--- a/cpp/src/plasma/common.h\n+++ b/cpp/src/plasma/common.h\n@@ -31,6 +31,10 @@\n #include \"arrow/status.h\"\n #include \"arrow/util/logging.h\"\n \n+// Forward declaration outside the namespace, which is defined in plasma_generated.h.\n+enum class PlasmaError : int32_t;\n+enum class ObjectStatus : int32_t;\n+\n namespace plasma {\n \n constexpr int64_t kUniqueIDSize = 20;\n@@ -54,11 +58,18 @@ static_assert(std::is_pod<UniqueID>::value, \"UniqueID must be plain old data\");\n \n typedef UniqueID ObjectID;\n \n-arrow::Status plasma_error_status(int plasma_error);\n+arrow::Status plasma_error_status(PlasmaError plasma_error);\n \n /// Size of object hash digests.\n constexpr int64_t kDigestSize = sizeof(uint64_t);\n \n+enum class ObjectRequestType : int {\n+  /// Query for object in the local plasma store.\n+  PLASMA_QUERY_LOCAL = 1,\n+  /// Query for object in the local plasma store or in a remote plasma store.\n+  PLASMA_QUERY_ANYWHERE\n+};\n+\n /// Object request data structure. Used for Wait.\n struct ObjectRequest {\n   /// The ID of the requested object. If ID_NIL request any object.\n@@ -68,26 +79,19 @@ struct ObjectRequest {\n   ///    local Plasma Store.\n   ///  - PLASMA_QUERY_ANYWHERE: return if or when the object is available in\n   ///    the system (i.e., either in the local or a remote Plasma Store).\n-  int type;\n+  ObjectRequestType type;\n   /// Object status. Same as the status returned by plasma_status() function\n   /// call. This is filled in by plasma_wait_for_objects1():\n-  ///  - ObjectStatus_Local: object is ready at the local Plasma Store.\n-  ///  - ObjectStatus_Remote: object is ready at a remote Plasma Store.\n-  ///  - ObjectStatus_Nonexistent: object does not exist in the system.\n+  ///  - ObjectStatus::Local: object is ready at the local Plasma Store.\n+  ///  - ObjectStatus::Remote: object is ready at a remote Plasma Store.\n+  ///  - ObjectStatus::Nonexistent: object does not exist in the system.\n   ///  - PLASMA_CLIENT_IN_TRANSFER, if the object is currently being scheduled\n   ///    for being transferred or it is transferring.\n-  int status;\n-};\n-\n-enum ObjectRequestType {\n-  /// Query for object in the local plasma store.\n-  PLASMA_QUERY_LOCAL = 1,\n-  /// Query for object in the local plasma store or in a remote plasma store.\n-  PLASMA_QUERY_ANYWHERE\n+  ObjectStatus status;\n };\n \n-extern int ObjectStatusLocal;\n-extern int ObjectStatusRemote;\n+extern ObjectStatus ObjectStatusLocal;\n+extern ObjectStatus ObjectStatusRemote;\n \n /// Globally accessible reference to plasma store configuration.\n /// TODO(pcm): This can be avoided with some refactoring of existing code\ndiff --git a/cpp/src/plasma/format/plasma.fbs b/cpp/src/plasma/format/plasma.fbs\nindex 6a58fb0d58..0bc7a072bf 100644\n--- a/cpp/src/plasma/format/plasma.fbs\n+++ b/cpp/src/plasma/format/plasma.fbs\n@@ -17,7 +17,7 @@\n \n // Plasma protocol specification\n \n-enum MessageType:int {\n+enum MessageType:long {\n   // Message that gets send when a client hangs up.\n   PlasmaDisconnectClient = 0,\n   // Create a new object.\n@@ -301,7 +301,7 @@ table ObjectReply {\n   // ID of the object.\n   object_id: string;\n   // The object status. This specifies where the object is stored.\n-  status: int;\n+  status: ObjectStatus;\n }\n \n table PlasmaWaitReply {\ndiff --git a/cpp/src/plasma/io.cc b/cpp/src/plasma/io.cc\nindex aefd297376..d9e805ca5c 100644\n--- a/cpp/src/plasma/io.cc\n+++ b/cpp/src/plasma/io.cc\n@@ -59,7 +59,7 @@ Status WriteBytes(int fd, uint8_t* cursor, size_t length) {\n   return Status::OK();\n }\n \n-Status WriteMessage(int fd, int64_t type, int64_t length, uint8_t* bytes) {\n+Status WriteMessage(int fd, MessageType type, int64_t length, uint8_t* bytes) {\n   int64_t version = kPlasmaProtocolVersion;\n   RETURN_NOT_OK(WriteBytes(fd, reinterpret_cast<uint8_t*>(&version), sizeof(version)));\n   RETURN_NOT_OK(WriteBytes(fd, reinterpret_cast<uint8_t*>(&type), sizeof(type)));\n@@ -90,24 +90,24 @@ Status ReadBytes(int fd, uint8_t* cursor, size_t length) {\n   return Status::OK();\n }\n \n-Status ReadMessage(int fd, int64_t* type, std::vector<uint8_t>* buffer) {\n+Status ReadMessage(int fd, MessageType* type, std::vector<uint8_t>* buffer) {\n   int64_t version;\n   RETURN_NOT_OK_ELSE(ReadBytes(fd, reinterpret_cast<uint8_t*>(&version), sizeof(version)),\n-                     *type = MessageType_PlasmaDisconnectClient);\n+                     *type = MessageType::PlasmaDisconnectClient);\n   ARROW_CHECK(version == kPlasmaProtocolVersion) << \"version = \" << version;\n   RETURN_NOT_OK_ELSE(ReadBytes(fd, reinterpret_cast<uint8_t*>(type), sizeof(*type)),\n-                     *type = MessageType_PlasmaDisconnectClient);\n+                     *type = MessageType::PlasmaDisconnectClient);\n   int64_t length_temp;\n   RETURN_NOT_OK_ELSE(\n       ReadBytes(fd, reinterpret_cast<uint8_t*>(&length_temp), sizeof(length_temp)),\n-      *type = MessageType_PlasmaDisconnectClient);\n+      *type = MessageType::PlasmaDisconnectClient);\n   // The length must be read as an int64_t, but it should be used as a size_t.\n   size_t length = static_cast<size_t>(length_temp);\n   if (length > buffer->size()) {\n     buffer->resize(length);\n   }\n   RETURN_NOT_OK_ELSE(ReadBytes(fd, buffer->data(), length),\n-                     *type = MessageType_PlasmaDisconnectClient);\n+                     *type = MessageType::PlasmaDisconnectClient);\n   return Status::OK();\n }\n \ndiff --git a/cpp/src/plasma/io.h b/cpp/src/plasma/io.h\nindex f0d57c04e6..9fc2d1cea5 100644\n--- a/cpp/src/plasma/io.h\n+++ b/cpp/src/plasma/io.h\n@@ -30,6 +30,9 @@\n #include \"arrow/status.h\"\n #include \"plasma/compat.h\"\n \n+// Forward declaration outside the namespace, which is defined in plasma_generated.h.\n+enum class MessageType : int64_t;\n+\n namespace plasma {\n \n // TODO(pcm): Replace our own custom message header (message type,\n@@ -41,11 +44,11 @@ using arrow::Status;\n \n Status WriteBytes(int fd, uint8_t* cursor, size_t length);\n \n-Status WriteMessage(int fd, int64_t type, int64_t length, uint8_t* bytes);\n+Status WriteMessage(int fd, MessageType type, int64_t length, uint8_t* bytes);\n \n Status ReadBytes(int fd, uint8_t* cursor, size_t length);\n \n-Status ReadMessage(int fd, int64_t* type, std::vector<uint8_t>* buffer);\n+Status ReadMessage(int fd, MessageType* type, std::vector<uint8_t>* buffer);\n \n int bind_ipc_sock(const std::string& pathname, bool shall_listen);\n \ndiff --git a/cpp/src/plasma/lib/java/org_apache_arrow_plasma_PlasmaClientJNI.cc b/cpp/src/plasma/lib/java/org_apache_arrow_plasma_PlasmaClientJNI.cc\nindex 8ddfeebe69..270e6968d0 100644\n--- a/cpp/src/plasma/lib/java/org_apache_arrow_plasma_PlasmaClientJNI.cc\n+++ b/cpp/src/plasma/lib/java/org_apache_arrow_plasma_PlasmaClientJNI.cc\n@@ -252,7 +252,7 @@ JNIEXPORT jobjectArray JNICALL Java_org_apache_arrow_plasma_PlasmaClientJNI_wait\n     jbyteArray_to_object_id(\n         env, reinterpret_cast<jbyteArray>(env->GetObjectArrayElement(object_ids, i)),\n         &oreqs[i].object_id);\n-    oreqs[i].type = plasma::PLASMA_QUERY_ANYWHERE;\n+    oreqs[i].type = plasma::ObjectRequestType::PLASMA_QUERY_ANYWHERE;\n   }\n \n   int num_return_objects;\ndiff --git a/cpp/src/plasma/plasma.h b/cpp/src/plasma/plasma.h\nindex 43a749684b..8cc7cacb35 100644\n--- a/cpp/src/plasma/plasma.h\n+++ b/cpp/src/plasma/plasma.h\n@@ -95,14 +95,14 @@ struct PlasmaObject {\n   int device_num;\n };\n \n-enum object_state {\n+enum class object_state : int {\n   /// Object was created but not sealed in the local Plasma Store.\n   PLASMA_CREATED = 1,\n   /// Object is sealed and stored in the local Plasma Store.\n   PLASMA_SEALED\n };\n \n-enum object_status {\n+enum class object_status : int {\n   /// The object was not found.\n   OBJECT_NOT_FOUND = 0,\n   /// The object was found.\ndiff --git a/cpp/src/plasma/protocol.cc b/cpp/src/plasma/protocol.cc\nindex e5cce752cd..0503e10f54 100644\n--- a/cpp/src/plasma/protocol.cc\n+++ b/cpp/src/plasma/protocol.cc\n@@ -41,16 +41,17 @@ to_flatbuffer(flatbuffers::FlatBufferBuilder* fbb, const ObjectID* object_ids,\n   return fbb->CreateVector(results);\n }\n \n-Status PlasmaReceive(int sock, int64_t message_type, std::vector<uint8_t>* buffer) {\n-  int64_t type;\n+Status PlasmaReceive(int sock, MessageType message_type, std::vector<uint8_t>* buffer) {\n+  MessageType type;\n   RETURN_NOT_OK(ReadMessage(sock, &type, buffer));\n   ARROW_CHECK(type == message_type)\n-      << \"type = \" << type << \", message_type = \" << message_type;\n+      << \"type = \" << static_cast<int64_t>(type)\n+      << \", message_type = \" << static_cast<int64_t>(message_type);\n   return Status::OK();\n }\n \n template <typename Message>\n-Status PlasmaSend(int sock, int64_t message_type, flatbuffers::FlatBufferBuilder* fbb,\n+Status PlasmaSend(int sock, MessageType message_type, flatbuffers::FlatBufferBuilder* fbb,\n                   const Message& message) {\n   fbb->Finish(message);\n   return WriteMessage(sock, message_type, fbb->GetSize(), fbb->GetBufferPointer());\n@@ -63,7 +64,7 @@ Status SendCreateRequest(int sock, ObjectID object_id, int64_t data_size,\n   flatbuffers::FlatBufferBuilder fbb;\n   auto message = CreatePlasmaCreateRequest(fbb, fbb.CreateString(object_id.binary()),\n                                            data_size, metadata_size, device_num);\n-  return PlasmaSend(sock, MessageType_PlasmaCreateRequest, &fbb, message);\n+  return PlasmaSend(sock, MessageType::PlasmaCreateRequest, &fbb, message);\n }\n \n Status ReadCreateRequest(uint8_t* data, size_t size, ObjectID* object_id,\n@@ -78,8 +79,8 @@ Status ReadCreateRequest(uint8_t* data, size_t size, ObjectID* object_id,\n   return Status::OK();\n }\n \n-Status SendCreateReply(int sock, ObjectID object_id, PlasmaObject* object, int error_code,\n-                       int64_t mmap_size) {\n+Status SendCreateReply(int sock, ObjectID object_id, PlasmaObject* object,\n+                       PlasmaError error_code, int64_t mmap_size) {\n   flatbuffers::FlatBufferBuilder fbb;\n   PlasmaObjectSpec plasma_object(object->store_fd, object->data_offset, object->data_size,\n                                  object->metadata_offset, object->metadata_size,\n@@ -107,7 +108,7 @@ Status SendCreateReply(int sock, ObjectID object_id, PlasmaObject* object, int e\n #endif\n   }\n   auto message = crb.Finish();\n-  return PlasmaSend(sock, MessageType_PlasmaCreateReply, &fbb, message);\n+  return PlasmaSend(sock, MessageType::PlasmaCreateReply, &fbb, message);\n }\n \n Status ReadCreateReply(uint8_t* data, size_t size, ObjectID* object_id,\n@@ -138,7 +139,7 @@ Status ReadCreateReply(uint8_t* data, size_t size, ObjectID* object_id,\n Status SendAbortRequest(int sock, ObjectID object_id) {\n   flatbuffers::FlatBufferBuilder fbb;\n   auto message = CreatePlasmaAbortRequest(fbb, fbb.CreateString(object_id.binary()));\n-  return PlasmaSend(sock, MessageType_PlasmaAbortRequest, &fbb, message);\n+  return PlasmaSend(sock, MessageType::PlasmaAbortRequest, &fbb, message);\n }\n \n Status ReadAbortRequest(uint8_t* data, size_t size, ObjectID* object_id) {\n@@ -152,7 +153,7 @@ Status ReadAbortRequest(uint8_t* data, size_t size, ObjectID* object_id) {\n Status SendAbortReply(int sock, ObjectID object_id) {\n   flatbuffers::FlatBufferBuilder fbb;\n   auto message = CreatePlasmaAbortReply(fbb, fbb.CreateString(object_id.binary()));\n-  return PlasmaSend(sock, MessageType_PlasmaAbortReply, &fbb, message);\n+  return PlasmaSend(sock, MessageType::PlasmaAbortReply, &fbb, message);\n }\n \n Status ReadAbortReply(uint8_t* data, size_t size, ObjectID* object_id) {\n@@ -170,7 +171,7 @@ Status SendSealRequest(int sock, ObjectID object_id, unsigned char* digest) {\n   auto digest_string = fbb.CreateString(reinterpret_cast<char*>(digest), kDigestSize);\n   auto message =\n       CreatePlasmaSealRequest(fbb, fbb.CreateString(object_id.binary()), digest_string);\n-  return PlasmaSend(sock, MessageType_PlasmaSealRequest, &fbb, message);\n+  return PlasmaSend(sock, MessageType::PlasmaSealRequest, &fbb, message);\n }\n \n Status ReadSealRequest(uint8_t* data, size_t size, ObjectID* object_id,\n@@ -184,11 +185,10 @@ Status ReadSealRequest(uint8_t* data, size_t size, ObjectID* object_id,\n   return Status::OK();\n }\n \n-Status SendSealReply(int sock, ObjectID object_id, int error) {\n+Status SendSealReply(int sock, ObjectID object_id, PlasmaError error) {\n   flatbuffers::FlatBufferBuilder fbb;\n-  auto message = CreatePlasmaSealReply(fbb, fbb.CreateString(object_id.binary()),\n-                                       static_cast<PlasmaError>(error));\n-  return PlasmaSend(sock, MessageType_PlasmaSealReply, &fbb, message);\n+  auto message = CreatePlasmaSealReply(fbb, fbb.CreateString(object_id.binary()), error);\n+  return PlasmaSend(sock, MessageType::PlasmaSealReply, &fbb, message);\n }\n \n Status ReadSealReply(uint8_t* data, size_t size, ObjectID* object_id) {\n@@ -204,7 +204,7 @@ Status ReadSealReply(uint8_t* data, size_t size, ObjectID* object_id) {\n Status SendReleaseRequest(int sock, ObjectID object_id) {\n   flatbuffers::FlatBufferBuilder fbb;\n   auto message = CreatePlasmaReleaseRequest(fbb, fbb.CreateString(object_id.binary()));\n-  return PlasmaSend(sock, MessageType_PlasmaReleaseRequest, &fbb, message);\n+  return PlasmaSend(sock, MessageType::PlasmaReleaseRequest, &fbb, message);\n }\n \n Status ReadReleaseRequest(uint8_t* data, size_t size, ObjectID* object_id) {\n@@ -215,11 +215,11 @@ Status ReadReleaseRequest(uint8_t* data, size_t size, ObjectID* object_id) {\n   return Status::OK();\n }\n \n-Status SendReleaseReply(int sock, ObjectID object_id, int error) {\n+Status SendReleaseReply(int sock, ObjectID object_id, PlasmaError error) {\n   flatbuffers::FlatBufferBuilder fbb;\n-  auto message = CreatePlasmaReleaseReply(fbb, fbb.CreateString(object_id.binary()),\n-                                          static_cast<PlasmaError>(error));\n-  return PlasmaSend(sock, MessageType_PlasmaReleaseReply, &fbb, message);\n+  auto message =\n+      CreatePlasmaReleaseReply(fbb, fbb.CreateString(object_id.binary()), error);\n+  return PlasmaSend(sock, MessageType::PlasmaReleaseReply, &fbb, message);\n }\n \n Status ReadReleaseReply(uint8_t* data, size_t size, ObjectID* object_id) {\n@@ -235,7 +235,7 @@ Status ReadReleaseReply(uint8_t* data, size_t size, ObjectID* object_id) {\n Status SendDeleteRequest(int sock, ObjectID object_id) {\n   flatbuffers::FlatBufferBuilder fbb;\n   auto message = CreatePlasmaDeleteRequest(fbb, fbb.CreateString(object_id.binary()));\n-  return PlasmaSend(sock, MessageType_PlasmaDeleteRequest, &fbb, message);\n+  return PlasmaSend(sock, MessageType::PlasmaDeleteRequest, &fbb, message);\n }\n \n Status ReadDeleteRequest(uint8_t* data, size_t size, ObjectID* object_id) {\n@@ -246,11 +246,11 @@ Status ReadDeleteRequest(uint8_t* data, size_t size, ObjectID* object_id) {\n   return Status::OK();\n }\n \n-Status SendDeleteReply(int sock, ObjectID object_id, int error) {\n+Status SendDeleteReply(int sock, ObjectID object_id, PlasmaError error) {\n   flatbuffers::FlatBufferBuilder fbb;\n-  auto message = CreatePlasmaDeleteReply(fbb, fbb.CreateString(object_id.binary()),\n-                                         static_cast<PlasmaError>(error));\n-  return PlasmaSend(sock, MessageType_PlasmaDeleteReply, &fbb, message);\n+  auto message =\n+      CreatePlasmaDeleteReply(fbb, fbb.CreateString(object_id.binary()), error);\n+  return PlasmaSend(sock, MessageType::PlasmaDeleteReply, &fbb, message);\n }\n \n Status ReadDeleteReply(uint8_t* data, size_t size, ObjectID* object_id) {\n@@ -267,7 +267,7 @@ Status SendStatusRequest(int sock, const ObjectID* object_ids, int64_t num_objec\n   flatbuffers::FlatBufferBuilder fbb;\n   auto message =\n       CreatePlasmaStatusRequest(fbb, to_flatbuffer(&fbb, object_ids, num_objects));\n-  return PlasmaSend(sock, MessageType_PlasmaStatusRequest, &fbb, message);\n+  return PlasmaSend(sock, MessageType::PlasmaStatusRequest, &fbb, message);\n }\n \n Status ReadStatusRequest(uint8_t* data, size_t size, ObjectID object_ids[],\n@@ -287,7 +287,7 @@ Status SendStatusReply(int sock, ObjectID object_ids[], int object_status[],\n   auto message =\n       CreatePlasmaStatusReply(fbb, to_flatbuffer(&fbb, object_ids, num_objects),\n                               fbb.CreateVector(object_status, num_objects));\n-  return PlasmaSend(sock, MessageType_PlasmaStatusReply, &fbb, message);\n+  return PlasmaSend(sock, MessageType::PlasmaStatusReply, &fbb, message);\n }\n \n int64_t ReadStatusReply_num_objects(uint8_t* data, size_t size) {\n@@ -316,7 +316,7 @@ Status ReadStatusReply(uint8_t* data, size_t size, ObjectID object_ids[],\n Status SendContainsRequest(int sock, ObjectID object_id) {\n   flatbuffers::FlatBufferBuilder fbb;\n   auto message = CreatePlasmaContainsRequest(fbb, fbb.CreateString(object_id.binary()));\n-  return PlasmaSend(sock, MessageType_PlasmaContainsRequest, &fbb, message);\n+  return PlasmaSend(sock, MessageType::PlasmaContainsRequest, &fbb, message);\n }\n \n Status ReadContainsRequest(uint8_t* data, size_t size, ObjectID* object_id) {\n@@ -331,7 +331,7 @@ Status SendContainsReply(int sock, ObjectID object_id, bool has_object) {\n   flatbuffers::FlatBufferBuilder fbb;\n   auto message =\n       CreatePlasmaContainsReply(fbb, fbb.CreateString(object_id.binary()), has_object);\n-  return PlasmaSend(sock, MessageType_PlasmaContainsReply, &fbb, message);\n+  return PlasmaSend(sock, MessageType::PlasmaContainsReply, &fbb, message);\n }\n \n Status ReadContainsReply(uint8_t* data, size_t size, ObjectID* object_id,\n@@ -349,7 +349,7 @@ Status ReadContainsReply(uint8_t* data, size_t size, ObjectID* object_id,\n Status SendConnectRequest(int sock) {\n   flatbuffers::FlatBufferBuilder fbb;\n   auto message = CreatePlasmaConnectRequest(fbb);\n-  return PlasmaSend(sock, MessageType_PlasmaConnectRequest, &fbb, message);\n+  return PlasmaSend(sock, MessageType::PlasmaConnectRequest, &fbb, message);\n }\n \n Status ReadConnectRequest(uint8_t* data) { return Status::OK(); }\n@@ -357,7 +357,7 @@ Status ReadConnectRequest(uint8_t* data) { return Status::OK(); }\n Status SendConnectReply(int sock, int64_t memory_capacity) {\n   flatbuffers::FlatBufferBuilder fbb;\n   auto message = CreatePlasmaConnectReply(fbb, memory_capacity);\n-  return PlasmaSend(sock, MessageType_PlasmaConnectReply, &fbb, message);\n+  return PlasmaSend(sock, MessageType::PlasmaConnectReply, &fbb, message);\n }\n \n Status ReadConnectReply(uint8_t* data, size_t size, int64_t* memory_capacity) {\n@@ -373,7 +373,7 @@ Status ReadConnectReply(uint8_t* data, size_t size, int64_t* memory_capacity) {\n Status SendEvictRequest(int sock, int64_t num_bytes) {\n   flatbuffers::FlatBufferBuilder fbb;\n   auto message = CreatePlasmaEvictRequest(fbb, num_bytes);\n-  return PlasmaSend(sock, MessageType_PlasmaEvictRequest, &fbb, message);\n+  return PlasmaSend(sock, MessageType::PlasmaEvictRequest, &fbb, message);\n }\n \n Status ReadEvictRequest(uint8_t* data, size_t size, int64_t* num_bytes) {\n@@ -387,7 +387,7 @@ Status ReadEvictRequest(uint8_t* data, size_t size, int64_t* num_bytes) {\n Status SendEvictReply(int sock, int64_t num_bytes) {\n   flatbuffers::FlatBufferBuilder fbb;\n   auto message = CreatePlasmaEvictReply(fbb, num_bytes);\n-  return PlasmaSend(sock, MessageType_PlasmaEvictReply, &fbb, message);\n+  return PlasmaSend(sock, MessageType::PlasmaEvictReply, &fbb, message);\n }\n \n Status ReadEvictReply(uint8_t* data, size_t size, int64_t& num_bytes) {\n@@ -405,7 +405,7 @@ Status SendGetRequest(int sock, const ObjectID* object_ids, int64_t num_objects,\n   flatbuffers::FlatBufferBuilder fbb;\n   auto message = CreatePlasmaGetRequest(fbb, to_flatbuffer(&fbb, object_ids, num_objects),\n                                         timeout_ms);\n-  return PlasmaSend(sock, MessageType_PlasmaGetRequest, &fbb, message);\n+  return PlasmaSend(sock, MessageType::PlasmaGetRequest, &fbb, message);\n }\n \n Status ReadGetRequest(uint8_t* data, size_t size, std::vector<ObjectID>& object_ids,\n@@ -447,7 +447,7 @@ Status SendGetReply(int sock, ObjectID object_ids[],\n       fbb, to_flatbuffer(&fbb, object_ids, num_objects),\n       fbb.CreateVectorOfStructs(objects.data(), num_objects), fbb.CreateVector(store_fds),\n       fbb.CreateVector(mmap_sizes), fbb.CreateVector(handles));\n-  return PlasmaSend(sock, MessageType_PlasmaGetReply, &fbb, message);\n+  return PlasmaSend(sock, MessageType::PlasmaGetReply, &fbb, message);\n }\n \n Status ReadGetReply(uint8_t* data, size_t size, ObjectID object_ids[],\n@@ -491,7 +491,7 @@ Status SendFetchRequest(int sock, const ObjectID* object_ids, int64_t num_object\n   flatbuffers::FlatBufferBuilder fbb;\n   auto message =\n       CreatePlasmaFetchRequest(fbb, to_flatbuffer(&fbb, object_ids, num_objects));\n-  return PlasmaSend(sock, MessageType_PlasmaFetchRequest, &fbb, message);\n+  return PlasmaSend(sock, MessageType::PlasmaFetchRequest, &fbb, message);\n }\n \n Status ReadFetchRequest(uint8_t* data, size_t size, std::vector<ObjectID>& object_ids) {\n@@ -514,12 +514,12 @@ Status SendWaitRequest(int sock, ObjectRequest object_requests[], int64_t num_re\n   for (int i = 0; i < num_requests; i++) {\n     object_request_specs.push_back(CreateObjectRequestSpec(\n         fbb, fbb.CreateString(object_requests[i].object_id.binary()),\n-        object_requests[i].type));\n+        static_cast<int>(object_requests[i].type)));\n   }\n \n   auto message = CreatePlasmaWaitRequest(fbb, fbb.CreateVector(object_request_specs),\n                                          num_ready_objects, timeout_ms);\n-  return PlasmaSend(sock, MessageType_PlasmaWaitRequest, &fbb, message);\n+  return PlasmaSend(sock, MessageType::PlasmaWaitRequest, &fbb, message);\n }\n \n Status ReadWaitRequest(uint8_t* data, size_t size, ObjectRequestMap& object_requests,\n@@ -533,8 +533,10 @@ Status ReadWaitRequest(uint8_t* data, size_t size, ObjectRequestMap& object_requ\n   for (uoffset_t i = 0; i < message->object_requests()->size(); i++) {\n     ObjectID object_id =\n         ObjectID::from_binary(message->object_requests()->Get(i)->object_id()->str());\n-    ObjectRequest object_request({object_id, message->object_requests()->Get(i)->type(),\n-                                  ObjectStatus_Nonexistent});\n+    ObjectRequest object_request(\n+        {object_id,\n+         static_cast<ObjectRequestType>(message->object_requests()->Get(i)->type()),\n+         ObjectStatus::Nonexistent});\n     object_requests[object_id] = object_request;\n   }\n   return Status::OK();\n@@ -553,7 +555,7 @@ Status SendWaitReply(int sock, const ObjectRequestMap& object_requests,\n \n   auto message = CreatePlasmaWaitReply(\n       fbb, fbb.CreateVector(object_replies.data(), num_ready_objects), num_ready_objects);\n-  return PlasmaSend(sock, MessageType_PlasmaWaitReply, &fbb, message);\n+  return PlasmaSend(sock, MessageType::PlasmaWaitReply, &fbb, message);\n }\n \n Status ReadWaitReply(uint8_t* data, size_t size, ObjectRequest object_requests[],\n@@ -576,7 +578,7 @@ Status ReadWaitReply(uint8_t* data, size_t size, ObjectRequest object_requests[]\n Status SendSubscribeRequest(int sock) {\n   flatbuffers::FlatBufferBuilder fbb;\n   auto message = CreatePlasmaSubscribeRequest(fbb);\n-  return PlasmaSend(sock, MessageType_PlasmaSubscribeRequest, &fbb, message);\n+  return PlasmaSend(sock, MessageType::PlasmaSubscribeRequest, &fbb, message);\n }\n \n // Data messages.\n@@ -586,7 +588,7 @@ Status SendDataRequest(int sock, ObjectID object_id, const char* address, int po\n   auto addr = fbb.CreateString(address, strlen(address));\n   auto message =\n       CreatePlasmaDataRequest(fbb, fbb.CreateString(object_id.binary()), addr, port);\n-  return PlasmaSend(sock, MessageType_PlasmaDataRequest, &fbb, message);\n+  return PlasmaSend(sock, MessageType::PlasmaDataRequest, &fbb, message);\n }\n \n Status ReadDataRequest(uint8_t* data, size_t size, ObjectID* object_id, char** address,\n@@ -606,7 +608,7 @@ Status SendDataReply(int sock, ObjectID object_id, int64_t object_size,\n   flatbuffers::FlatBufferBuilder fbb;\n   auto message = CreatePlasmaDataReply(fbb, fbb.CreateString(object_id.binary()),\n                                        object_size, metadata_size);\n-  return PlasmaSend(sock, MessageType_PlasmaDataReply, &fbb, message);\n+  return PlasmaSend(sock, MessageType::PlasmaDataReply, &fbb, message);\n }\n \n Status ReadDataReply(uint8_t* data, size_t size, ObjectID* object_id,\ndiff --git a/cpp/src/plasma/protocol.h b/cpp/src/plasma/protocol.h\nindex 702813278d..2b477a8a3d 100644\n--- a/cpp/src/plasma/protocol.h\n+++ b/cpp/src/plasma/protocol.h\n@@ -38,7 +38,7 @@ bool verify_flatbuffer(T* object, uint8_t* data, size_t size) {\n \n /* Plasma receive message. */\n \n-Status PlasmaReceive(int sock, int64_t message_type, std::vector<uint8_t>* buffer);\n+Status PlasmaReceive(int sock, MessageType message_type, std::vector<uint8_t>* buffer);\n \n /* Plasma Create message functions. */\n \n@@ -48,8 +48,8 @@ Status SendCreateRequest(int sock, ObjectID object_id, int64_t data_size,\n Status ReadCreateRequest(uint8_t* data, size_t size, ObjectID* object_id,\n                          int64_t* data_size, int64_t* metadata_size, int* device_num);\n \n-Status SendCreateReply(int sock, ObjectID object_id, PlasmaObject* object, int error,\n-                       int64_t mmap_size);\n+Status SendCreateReply(int sock, ObjectID object_id, PlasmaObject* object,\n+                       PlasmaError error, int64_t mmap_size);\n \n Status ReadCreateReply(uint8_t* data, size_t size, ObjectID* object_id,\n                        PlasmaObject* object, int* store_fd, int64_t* mmap_size);\n@@ -69,7 +69,7 @@ Status SendSealRequest(int sock, ObjectID object_id, unsigned char* digest);\n Status ReadSealRequest(uint8_t* data, size_t size, ObjectID* object_id,\n                        unsigned char* digest);\n \n-Status SendSealReply(int sock, ObjectID object_id, int error);\n+Status SendSealReply(int sock, ObjectID object_id, PlasmaError error);\n \n Status ReadSealReply(uint8_t* data, size_t size, ObjectID* object_id);\n \n@@ -96,7 +96,7 @@ Status SendReleaseRequest(int sock, ObjectID object_id);\n \n Status ReadReleaseRequest(uint8_t* data, size_t size, ObjectID* object_id);\n \n-Status SendReleaseReply(int sock, ObjectID object_id, int error);\n+Status SendReleaseReply(int sock, ObjectID object_id, PlasmaError error);\n \n Status ReadReleaseReply(uint8_t* data, size_t size, ObjectID* object_id);\n \n@@ -106,7 +106,7 @@ Status SendDeleteRequest(int sock, ObjectID object_id);\n \n Status ReadDeleteRequest(uint8_t* data, size_t size, ObjectID* object_id);\n \n-Status SendDeleteReply(int sock, ObjectID object_id, int error);\n+Status SendDeleteReply(int sock, ObjectID object_id, PlasmaError error);\n \n Status ReadDeleteReply(uint8_t* data, size_t size, ObjectID* object_id);\n \ndiff --git a/cpp/src/plasma/store.cc b/cpp/src/plasma/store.cc\nindex 69a02dc0f2..e86db21dcb 100644\n--- a/cpp/src/plasma/store.cc\n+++ b/cpp/src/plasma/store.cc\n@@ -144,14 +144,14 @@ void PlasmaStore::add_to_client_object_ids(ObjectTableEntry* entry, Client* clie\n }\n \n // Create a new object buffer in the hash table.\n-int PlasmaStore::create_object(const ObjectID& object_id, int64_t data_size,\n-                               int64_t metadata_size, int device_num, Client* client,\n-                               PlasmaObject* result) {\n+PlasmaError PlasmaStore::create_object(const ObjectID& object_id, int64_t data_size,\n+                                       int64_t metadata_size, int device_num,\n+                                       Client* client, PlasmaObject* result) {\n   ARROW_LOG(DEBUG) << \"creating object \" << object_id.hex();\n   if (store_info_.objects.count(object_id) != 0) {\n     // There is already an object with the same ID in the Plasma Store, so\n     // ignore this requst.\n-    return PlasmaError_ObjectExists;\n+    return PlasmaError::ObjectExists;\n   }\n   // Try to evict objects until there is enough space.\n   uint8_t* pointer;\n@@ -182,7 +182,7 @@ int PlasmaStore::create_object(const ObjectID& object_id, int64_t data_size,\n         // Return an error to the client if not enough space could be freed to\n         // create the object.\n         if (!success) {\n-          return PlasmaError_OutOfMemory;\n+          return PlasmaError::OutOfMemory;\n         }\n       } else {\n         break;\n@@ -211,7 +211,7 @@ int PlasmaStore::create_object(const ObjectID& object_id, int64_t data_size,\n   entry->fd = fd;\n   entry->map_size = map_size;\n   entry->offset = offset;\n-  entry->state = PLASMA_CREATED;\n+  entry->state = object_state::PLASMA_CREATED;\n   entry->device_num = device_num;\n #ifdef PLASMA_GPU\n   if (device_num != 0) {\n@@ -232,13 +232,13 @@ int PlasmaStore::create_object(const ObjectID& object_id, int64_t data_size,\n   eviction_policy_.object_created(object_id);\n   // Record that this client is using this object.\n   add_to_client_object_ids(store_info_.objects[object_id].get(), client);\n-  return PlasmaError_OK;\n+  return PlasmaError::OK;\n }\n \n void PlasmaObject_init(PlasmaObject* object, ObjectTableEntry* entry) {\n   DCHECK(object != NULL);\n   DCHECK(entry != NULL);\n-  DCHECK(entry->state == PLASMA_SEALED);\n+  DCHECK(entry->state == object_state::PLASMA_SEALED);\n #ifdef PLASMA_GPU\n   if (entry->device_num != 0) {\n     object->ipc_handle = entry->ipc_handle;\n@@ -357,7 +357,7 @@ void PlasmaStore::process_get_request(Client* client,\n     // Check if this object is already present locally. If so, record that the\n     // object is being used and mark it as accounted for.\n     auto entry = get_object_table_entry(&store_info_, object_id);\n-    if (entry && entry->state == PLASMA_SEALED) {\n+    if (entry && entry->state == object_state::PLASMA_SEALED) {\n       // Update the get request to take into account the present object.\n       PlasmaObject_init(&get_req->objects[object_id], entry);\n       get_req->num_satisfied += 1;\n@@ -419,9 +419,11 @@ void PlasmaStore::release_object(const ObjectID& object_id, Client* client) {\n }\n \n // Check if an object is present.\n-int PlasmaStore::contains_object(const ObjectID& object_id) {\n+object_status PlasmaStore::contains_object(const ObjectID& object_id) {\n   auto entry = get_object_table_entry(&store_info_, object_id);\n-  return entry && (entry->state == PLASMA_SEALED) ? OBJECT_FOUND : OBJECT_NOT_FOUND;\n+  return entry && (entry->state == object_state::PLASMA_SEALED)\n+             ? object_status::OBJECT_FOUND\n+             : object_status::OBJECT_NOT_FOUND;\n }\n \n // Seal an object that has been created in the hash table.\n@@ -429,9 +431,9 @@ void PlasmaStore::seal_object(const ObjectID& object_id, unsigned char digest[])\n   ARROW_LOG(DEBUG) << \"sealing object \" << object_id.hex();\n   auto entry = get_object_table_entry(&store_info_, object_id);\n   ARROW_CHECK(entry != NULL);\n-  ARROW_CHECK(entry->state == PLASMA_CREATED);\n+  ARROW_CHECK(entry->state == object_state::PLASMA_CREATED);\n   // Set the state of object to SEALED.\n-  entry->state = PLASMA_SEALED;\n+  entry->state = object_state::PLASMA_SEALED;\n   // Set the object digest.\n   entry->info.digest = std::string(reinterpret_cast<char*>(&digest[0]), kDigestSize);\n   // Inform all subscribers that a new object has been sealed.\n@@ -444,7 +446,7 @@ void PlasmaStore::seal_object(const ObjectID& object_id, unsigned char digest[])\n int PlasmaStore::abort_object(const ObjectID& object_id, Client* client) {\n   auto entry = get_object_table_entry(&store_info_, object_id);\n   ARROW_CHECK(entry != NULL) << \"To abort an object it must be in the object table.\";\n-  ARROW_CHECK(entry->state != PLASMA_SEALED)\n+  ARROW_CHECK(entry->state != object_state::PLASMA_SEALED)\n       << \"To abort an object it must not have been sealed.\";\n   auto it = client->object_ids.find(object_id);\n   if (it == client->object_ids.end()) {\n@@ -458,24 +460,24 @@ int PlasmaStore::abort_object(const ObjectID& object_id, Client* client) {\n   }\n }\n \n-int PlasmaStore::delete_object(ObjectID& object_id) {\n+PlasmaError PlasmaStore::delete_object(ObjectID& object_id) {\n   auto entry = get_object_table_entry(&store_info_, object_id);\n   // TODO(rkn): This should probably not fail, but should instead throw an\n   // error. Maybe we should also support deleting objects that have been\n   // created but not sealed.\n   if (entry == NULL) {\n     // To delete an object it must be in the object table.\n-    return PlasmaError_ObjectNonexistent;\n+    return PlasmaError::ObjectNonexistent;\n   }\n \n-  if (entry->state != PLASMA_SEALED) {\n+  if (entry->state != object_state::PLASMA_SEALED) {\n     // To delete an object it must have been sealed.\n-    return PlasmaError_ObjectNotSealed;\n+    return PlasmaError::ObjectNotSealed;\n   }\n \n   if (entry->ref_count != 0) {\n     // To delete an object, there must be no clients currently using it.\n-    return PlasmaError_ObjectInUse;\n+    return PlasmaError::ObjectInUse;\n   }\n \n   eviction_policy_.remove_object(object_id);\n@@ -487,7 +489,7 @@ int PlasmaStore::delete_object(ObjectID& object_id) {\n   notification.is_deletion = true;\n   push_notification(&notification);\n \n-  return PlasmaError_OK;\n+  return PlasmaError::OK;\n }\n \n void PlasmaStore::delete_objects(const std::vector<ObjectID>& object_ids) {\n@@ -498,7 +500,7 @@ void PlasmaStore::delete_objects(const std::vector<ObjectID>& object_ids) {\n     // error. Maybe we should also support deleting objects that have been\n     // created but not sealed.\n     ARROW_CHECK(entry != NULL) << \"To delete an object it must be in the object table.\";\n-    ARROW_CHECK(entry->state == PLASMA_SEALED)\n+    ARROW_CHECK(entry->state == object_state::PLASMA_SEALED)\n         << \"To delete an object it must have been sealed.\";\n     ARROW_CHECK(entry->ref_count == 0)\n         << \"To delete an object, there must be no clients currently using it.\";\n@@ -545,7 +547,7 @@ void PlasmaStore::disconnect_client(int client_fd) {\n       continue;\n     }\n \n-    if (it->second->state == PLASMA_SEALED) {\n+    if (it->second->state == object_state::PLASMA_SEALED) {\n       // Add sealed objects to a temporary list of object IDs. Do not perform\n       // the remove here, since it potentially modifies the object_ids table.\n       sealed_objects.push_back(it->second.get());\n@@ -683,14 +685,14 @@ void PlasmaStore::subscribe_to_updates(Client* client) {\n \n   // Push notifications to the new subscriber about existing sealed objects.\n   for (const auto& entry : store_info_.objects) {\n-    if (entry.second->state == PLASMA_SEALED) {\n+    if (entry.second->state == object_state::PLASMA_SEALED) {\n       push_notification(&entry.second->info, fd);\n     }\n   }\n }\n \n Status PlasmaStore::process_message(Client* client) {\n-  int64_t type;\n+  MessageType type;\n   Status s = ReadMessage(client->fd, &type, &input_buffer_);\n   ARROW_CHECK(s.ok() || s.IsIOError());\n \n@@ -703,61 +705,61 @@ Status PlasmaStore::process_message(Client* client) {\n \n   // Process the different types of requests.\n   switch (type) {\n-    case MessageType_PlasmaCreateRequest: {\n+    case MessageType::PlasmaCreateRequest: {\n       int64_t data_size;\n       int64_t metadata_size;\n       int device_num;\n       RETURN_NOT_OK(ReadCreateRequest(input, input_size, &object_id, &data_size,\n                                       &metadata_size, &device_num));\n-      int error_code =\n+      PlasmaError error_code =\n           create_object(object_id, data_size, metadata_size, device_num, client, &object);\n       int64_t mmap_size = 0;\n-      if (error_code == PlasmaError_OK && device_num == 0) {\n+      if (error_code == PlasmaError::OK && device_num == 0) {\n         mmap_size = get_mmap_size(object.store_fd);\n       }\n       HANDLE_SIGPIPE(\n           SendCreateReply(client->fd, object_id, &object, error_code, mmap_size),\n           client->fd);\n-      if (error_code == PlasmaError_OK && device_num == 0) {\n+      if (error_code == PlasmaError::OK && device_num == 0) {\n         warn_if_sigpipe(send_fd(client->fd, object.store_fd), client->fd);\n       }\n     } break;\n-    case MessageType_PlasmaAbortRequest: {\n+    case MessageType::PlasmaAbortRequest: {\n       RETURN_NOT_OK(ReadAbortRequest(input, input_size, &object_id));\n       ARROW_CHECK(abort_object(object_id, client) == 1) << \"To abort an object, the only \"\n                                                            \"client currently using it \"\n                                                            \"must be the creator.\";\n       HANDLE_SIGPIPE(SendAbortReply(client->fd, object_id), client->fd);\n     } break;\n-    case MessageType_PlasmaGetRequest: {\n+    case MessageType::PlasmaGetRequest: {\n       std::vector<ObjectID> object_ids_to_get;\n       int64_t timeout_ms;\n       RETURN_NOT_OK(ReadGetRequest(input, input_size, object_ids_to_get, &timeout_ms));\n       process_get_request(client, object_ids_to_get, timeout_ms);\n     } break;\n-    case MessageType_PlasmaReleaseRequest: {\n+    case MessageType::PlasmaReleaseRequest: {\n       RETURN_NOT_OK(ReadReleaseRequest(input, input_size, &object_id));\n       release_object(object_id, client);\n     } break;\n-    case MessageType_PlasmaDeleteRequest: {\n+    case MessageType::PlasmaDeleteRequest: {\n       RETURN_NOT_OK(ReadDeleteRequest(input, input_size, &object_id));\n-      int error_code = delete_object(object_id);\n+      PlasmaError error_code = delete_object(object_id);\n       HANDLE_SIGPIPE(SendDeleteReply(client->fd, object_id, error_code), client->fd);\n     } break;\n-    case MessageType_PlasmaContainsRequest: {\n+    case MessageType::PlasmaContainsRequest: {\n       RETURN_NOT_OK(ReadContainsRequest(input, input_size, &object_id));\n-      if (contains_object(object_id) == OBJECT_FOUND) {\n+      if (contains_object(object_id) == object_status::OBJECT_FOUND) {\n         HANDLE_SIGPIPE(SendContainsReply(client->fd, object_id, 1), client->fd);\n       } else {\n         HANDLE_SIGPIPE(SendContainsReply(client->fd, object_id, 0), client->fd);\n       }\n     } break;\n-    case MessageType_PlasmaSealRequest: {\n+    case MessageType::PlasmaSealRequest: {\n       unsigned char digest[kDigestSize];\n       RETURN_NOT_OK(ReadSealRequest(input, input_size, &object_id, &digest[0]));\n       seal_object(object_id, &digest[0]);\n     } break;\n-    case MessageType_PlasmaEvictRequest: {\n+    case MessageType::PlasmaEvictRequest: {\n       // This code path should only be used for testing.\n       int64_t num_bytes;\n       RETURN_NOT_OK(ReadEvictRequest(input, input_size, &num_bytes));\n@@ -767,14 +769,14 @@ Status PlasmaStore::process_message(Client* client) {\n       delete_objects(objects_to_evict);\n       HANDLE_SIGPIPE(SendEvictReply(client->fd, num_bytes_evicted), client->fd);\n     } break;\n-    case MessageType_PlasmaSubscribeRequest:\n+    case MessageType::PlasmaSubscribeRequest:\n       subscribe_to_updates(client);\n       break;\n-    case MessageType_PlasmaConnectRequest: {\n+    case MessageType::PlasmaConnectRequest: {\n       HANDLE_SIGPIPE(SendConnectReply(client->fd, store_info_.memory_capacity),\n                      client->fd);\n     } break;\n-    case MessageType_PlasmaDisconnectClient:\n+    case MessageType::PlasmaDisconnectClient:\n       ARROW_LOG(DEBUG) << \"Disconnecting client on fd \" << client->fd;\n       disconnect_client(client->fd);\n       break;\ndiff --git a/cpp/src/plasma/store.h b/cpp/src/plasma/store.h\nindex e5ef9172ee..e40f0401a7 100644\n--- a/cpp/src/plasma/store.h\n+++ b/cpp/src/plasma/store.h\n@@ -83,15 +83,16 @@ class PlasmaStore {\n   /// @param client The client that created the object.\n   /// @param result The object that has been created.\n   /// @return One of the following error codes:\n-  ///  - PlasmaError_OK, if the object was created successfully.\n-  ///  - PlasmaError_ObjectExists, if an object with this ID is already\n+  ///  - PlasmaError::OK, if the object was created successfully.\n+  ///  - PlasmaError::ObjectExists, if an object with this ID is already\n   ///    present in the store. In this case, the client should not call\n   ///    plasma_release.\n-  ///  - PlasmaError_OutOfMemory, if the store is out of memory and\n+  ///  - PlasmaError::OutOfMemory, if the store is out of memory and\n   ///    cannot create the object. In this case, the client should not call\n   ///    plasma_release.\n-  int create_object(const ObjectID& object_id, int64_t data_size, int64_t metadata_size,\n-                    int device_num, Client* client, PlasmaObject* result);\n+  PlasmaError create_object(const ObjectID& object_id, int64_t data_size,\n+                            int64_t metadata_size, int device_num, Client* client,\n+                            PlasmaObject* result);\n \n   /// Abort a created but unsealed object. If the client is not the\n   /// creator, then the abort will fail.\n@@ -106,10 +107,10 @@ class PlasmaStore {\n   ///\n   /// @param object_id Object ID of the object to be deleted.\n   /// @return One of the following error codes:\n-  ///  - PlasmaError_OK, if the object was delete successfully.\n-  ///  - PlasmaError_ObjectNonexistent, if ths object isn't existed.\n-  ///  - PlasmaError_ObjectInUse, if the object is in use.\n-  int delete_object(ObjectID& object_id);\n+  ///  - PlasmaError::OK, if the object was delete successfully.\n+  ///  - PlasmaError::ObjectNonexistent, if ths object isn't existed.\n+  ///  - PlasmaError::ObjectInUse, if the object is in use.\n+  PlasmaError delete_object(ObjectID& object_id);\n \n   /// Delete objects that have been created in the hash table. This should only\n   /// be called on objects that are returned by the eviction policy to evict.\n@@ -144,7 +145,7 @@ class PlasmaStore {\n   /// @param object_id Object ID that will be checked.\n   /// @return OBJECT_FOUND if the object is in the store, OBJECT_NOT_FOUND if\n   /// not\n-  int contains_object(const ObjectID& object_id);\n+  object_status contains_object(const ObjectID& object_id);\n \n   /// Record the fact that a particular client is no longer using an object.\n   ///\ndiff --git a/cpp/src/plasma/test/serialization_tests.cc b/cpp/src/plasma/test/serialization_tests.cc\nindex 006fa74ba7..e05c1b4f62 100644\n--- a/cpp/src/plasma/test/serialization_tests.cc\n+++ b/cpp/src/plasma/test/serialization_tests.cc\n@@ -48,10 +48,10 @@ int create_temp_file(void) {\n  * @return Pointer to the content of the message. Needs to be freed by the\n  * caller.\n  */\n-std::vector<uint8_t> read_message_from_file(int fd, int message_type) {\n+std::vector<uint8_t> read_message_from_file(int fd, MessageType message_type) {\n   /* Go to the beginning of the file. */\n   lseek(fd, 0, SEEK_SET);\n-  int64_t type;\n+  MessageType type;\n   std::vector<uint8_t> data;\n   ARROW_CHECK_OK(ReadMessage(fd, &type, &data));\n   ARROW_CHECK(type == message_type);\n@@ -80,7 +80,8 @@ TEST(PlasmaSerialization, CreateRequest) {\n   int device_num1 = 0;\n   ARROW_CHECK_OK(\n       SendCreateRequest(fd, object_id1, data_size1, metadata_size1, device_num1));\n-  std::vector<uint8_t> data = read_message_from_file(fd, MessageType_PlasmaCreateRequest);\n+  std::vector<uint8_t> data =\n+      read_message_from_file(fd, MessageType::PlasmaCreateRequest);\n   ObjectID object_id2;\n   int64_t data_size2;\n   int64_t metadata_size2;\n@@ -99,8 +100,8 @@ TEST(PlasmaSerialization, CreateReply) {\n   ObjectID object_id1 = ObjectID::from_random();\n   PlasmaObject object1 = random_plasma_object();\n   int64_t mmap_size1 = 1000000;\n-  ARROW_CHECK_OK(SendCreateReply(fd, object_id1, &object1, 0, mmap_size1));\n-  std::vector<uint8_t> data = read_message_from_file(fd, MessageType_PlasmaCreateReply);\n+  ARROW_CHECK_OK(SendCreateReply(fd, object_id1, &object1, PlasmaError::OK, mmap_size1));\n+  std::vector<uint8_t> data = read_message_from_file(fd, MessageType::PlasmaCreateReply);\n   ObjectID object_id2;\n   PlasmaObject object2;\n   memset(&object2, 0, sizeof(object2));\n@@ -121,7 +122,7 @@ TEST(PlasmaSerialization, SealRequest) {\n   unsigned char digest1[kDigestSize];\n   memset(&digest1[0], 7, kDigestSize);\n   ARROW_CHECK_OK(SendSealRequest(fd, object_id1, &digest1[0]));\n-  std::vector<uint8_t> data = read_message_from_file(fd, MessageType_PlasmaSealRequest);\n+  std::vector<uint8_t> data = read_message_from_file(fd, MessageType::PlasmaSealRequest);\n   ObjectID object_id2;\n   unsigned char digest2[kDigestSize];\n   ARROW_CHECK_OK(ReadSealRequest(data.data(), data.size(), &object_id2, &digest2[0]));\n@@ -133,8 +134,8 @@ TEST(PlasmaSerialization, SealRequest) {\n TEST(PlasmaSerialization, SealReply) {\n   int fd = create_temp_file();\n   ObjectID object_id1 = ObjectID::from_random();\n-  ARROW_CHECK_OK(SendSealReply(fd, object_id1, PlasmaError_ObjectExists));\n-  std::vector<uint8_t> data = read_message_from_file(fd, MessageType_PlasmaSealReply);\n+  ARROW_CHECK_OK(SendSealReply(fd, object_id1, PlasmaError::ObjectExists));\n+  std::vector<uint8_t> data = read_message_from_file(fd, MessageType::PlasmaSealReply);\n   ObjectID object_id2;\n   Status s = ReadSealReply(data.data(), data.size(), &object_id2);\n   ASSERT_EQ(object_id1, object_id2);\n@@ -149,7 +150,7 @@ TEST(PlasmaSerialization, GetRequest) {\n   object_ids[1] = ObjectID::from_random();\n   int64_t timeout_ms = 1234;\n   ARROW_CHECK_OK(SendGetRequest(fd, object_ids, 2, timeout_ms));\n-  std::vector<uint8_t> data = read_message_from_file(fd, MessageType_PlasmaGetRequest);\n+  std::vector<uint8_t> data = read_message_from_file(fd, MessageType::PlasmaGetRequest);\n   std::vector<ObjectID> object_ids_return;\n   int64_t timeout_ms_return;\n   ARROW_CHECK_OK(\n@@ -172,7 +173,7 @@ TEST(PlasmaSerialization, GetReply) {\n   std::vector<int64_t> mmap_sizes = {100, 200, 300};\n   ARROW_CHECK_OK(SendGetReply(fd, object_ids, plasma_objects, 2, store_fds, mmap_sizes));\n \n-  std::vector<uint8_t> data = read_message_from_file(fd, MessageType_PlasmaGetReply);\n+  std::vector<uint8_t> data = read_message_from_file(fd, MessageType::PlasmaGetReply);\n   ObjectID object_ids_return[2];\n   PlasmaObject plasma_objects_return[2];\n   std::vector<int> store_fds_return;\n@@ -200,7 +201,7 @@ TEST(PlasmaSerialization, ReleaseRequest) {\n   ObjectID object_id1 = ObjectID::from_random();\n   ARROW_CHECK_OK(SendReleaseRequest(fd, object_id1));\n   std::vector<uint8_t> data =\n-      read_message_from_file(fd, MessageType_PlasmaReleaseRequest);\n+      read_message_from_file(fd, MessageType::PlasmaReleaseRequest);\n   ObjectID object_id2;\n   ARROW_CHECK_OK(ReadReleaseRequest(data.data(), data.size(), &object_id2));\n   ASSERT_EQ(object_id1, object_id2);\n@@ -210,8 +211,8 @@ TEST(PlasmaSerialization, ReleaseRequest) {\n TEST(PlasmaSerialization, ReleaseReply) {\n   int fd = create_temp_file();\n   ObjectID object_id1 = ObjectID::from_random();\n-  ARROW_CHECK_OK(SendReleaseReply(fd, object_id1, PlasmaError_ObjectExists));\n-  std::vector<uint8_t> data = read_message_from_file(fd, MessageType_PlasmaReleaseReply);\n+  ARROW_CHECK_OK(SendReleaseReply(fd, object_id1, PlasmaError::ObjectExists));\n+  std::vector<uint8_t> data = read_message_from_file(fd, MessageType::PlasmaReleaseReply);\n   ObjectID object_id2;\n   Status s = ReadReleaseReply(data.data(), data.size(), &object_id2);\n   ASSERT_EQ(object_id1, object_id2);\n@@ -223,7 +224,8 @@ TEST(PlasmaSerialization, DeleteRequest) {\n   int fd = create_temp_file();\n   ObjectID object_id1 = ObjectID::from_random();\n   ARROW_CHECK_OK(SendDeleteRequest(fd, object_id1));\n-  std::vector<uint8_t> data = read_message_from_file(fd, MessageType_PlasmaDeleteRequest);\n+  std::vector<uint8_t> data =\n+      read_message_from_file(fd, MessageType::PlasmaDeleteRequest);\n   ObjectID object_id2;\n   ARROW_CHECK_OK(ReadDeleteRequest(data.data(), data.size(), &object_id2));\n   ASSERT_EQ(object_id1, object_id2);\n@@ -233,9 +235,9 @@ TEST(PlasmaSerialization, DeleteRequest) {\n TEST(PlasmaSerialization, DeleteReply) {\n   int fd = create_temp_file();\n   ObjectID object_id1 = ObjectID::from_random();\n-  int error1 = PlasmaError_ObjectExists;\n+  PlasmaError error1 = PlasmaError::ObjectExists;\n   ARROW_CHECK_OK(SendDeleteReply(fd, object_id1, error1));\n-  std::vector<uint8_t> data = read_message_from_file(fd, MessageType_PlasmaDeleteReply);\n+  std::vector<uint8_t> data = read_message_from_file(fd, MessageType::PlasmaDeleteReply);\n   ObjectID object_id2;\n   Status s = ReadDeleteReply(data.data(), data.size(), &object_id2);\n   ASSERT_EQ(object_id1, object_id2);\n@@ -250,7 +252,8 @@ TEST(PlasmaSerialization, StatusRequest) {\n   object_ids[0] = ObjectID::from_random();\n   object_ids[1] = ObjectID::from_random();\n   ARROW_CHECK_OK(SendStatusRequest(fd, object_ids, num_objects));\n-  std::vector<uint8_t> data = read_message_from_file(fd, MessageType_PlasmaStatusRequest);\n+  std::vector<uint8_t> data =\n+      read_message_from_file(fd, MessageType::PlasmaStatusRequest);\n   ObjectID object_ids_read[num_objects];\n   ARROW_CHECK_OK(\n       ReadStatusRequest(data.data(), data.size(), object_ids_read, num_objects));\n@@ -266,7 +269,7 @@ TEST(PlasmaSerialization, StatusReply) {\n   object_ids[1] = ObjectID::from_random();\n   int object_statuses[2] = {42, 43};\n   ARROW_CHECK_OK(SendStatusReply(fd, object_ids, object_statuses, 2));\n-  std::vector<uint8_t> data = read_message_from_file(fd, MessageType_PlasmaStatusReply);\n+  std::vector<uint8_t> data = read_message_from_file(fd, MessageType::PlasmaStatusReply);\n   int64_t num_objects = ReadStatusReply_num_objects(data.data(), data.size());\n \n   std::vector<ObjectID> object_ids_read(num_objects);\n@@ -284,7 +287,7 @@ TEST(PlasmaSerialization, EvictRequest) {\n   int fd = create_temp_file();\n   int64_t num_bytes = 111;\n   ARROW_CHECK_OK(SendEvictRequest(fd, num_bytes));\n-  std::vector<uint8_t> data = read_message_from_file(fd, MessageType_PlasmaEvictRequest);\n+  std::vector<uint8_t> data = read_message_from_file(fd, MessageType::PlasmaEvictRequest);\n   int64_t num_bytes_received;\n   ARROW_CHECK_OK(ReadEvictRequest(data.data(), data.size(), &num_bytes_received));\n   ASSERT_EQ(num_bytes, num_bytes_received);\n@@ -295,7 +298,7 @@ TEST(PlasmaSerialization, EvictReply) {\n   int fd = create_temp_file();\n   int64_t num_bytes = 111;\n   ARROW_CHECK_OK(SendEvictReply(fd, num_bytes));\n-  std::vector<uint8_t> data = read_message_from_file(fd, MessageType_PlasmaEvictReply);\n+  std::vector<uint8_t> data = read_message_from_file(fd, MessageType::PlasmaEvictReply);\n   int64_t num_bytes_received;\n   ARROW_CHECK_OK(ReadEvictReply(data.data(), data.size(), num_bytes_received));\n   ASSERT_EQ(num_bytes, num_bytes_received);\n@@ -308,7 +311,7 @@ TEST(PlasmaSerialization, FetchRequest) {\n   object_ids[0] = ObjectID::from_random();\n   object_ids[1] = ObjectID::from_random();\n   ARROW_CHECK_OK(SendFetchRequest(fd, object_ids, 2));\n-  std::vector<uint8_t> data = read_message_from_file(fd, MessageType_PlasmaFetchRequest);\n+  std::vector<uint8_t> data = read_message_from_file(fd, MessageType::PlasmaFetchRequest);\n   std::vector<ObjectID> object_ids_read;\n   ARROW_CHECK_OK(ReadFetchRequest(data.data(), data.size(), object_ids_read));\n   ASSERT_EQ(object_ids[0], object_ids_read[0]);\n@@ -320,15 +323,17 @@ TEST(PlasmaSerialization, WaitRequest) {\n   int fd = create_temp_file();\n   const int num_objects_in = 2;\n   ObjectRequest object_requests_in[num_objects_in] = {\n-      ObjectRequest({ObjectID::from_random(), PLASMA_QUERY_ANYWHERE, 0}),\n-      ObjectRequest({ObjectID::from_random(), PLASMA_QUERY_LOCAL, 0})};\n+      ObjectRequest({ObjectID::from_random(), ObjectRequestType::PLASMA_QUERY_ANYWHERE,\n+                     ObjectStatus::Local}),\n+      ObjectRequest({ObjectID::from_random(), ObjectRequestType::PLASMA_QUERY_LOCAL,\n+                     ObjectStatus::Local})};\n   const int num_ready_objects_in = 1;\n   int64_t timeout_ms = 1000;\n \n   ARROW_CHECK_OK(SendWaitRequest(fd, &object_requests_in[0], num_objects_in,\n                                  num_ready_objects_in, timeout_ms));\n   /* Read message back. */\n-  std::vector<uint8_t> data = read_message_from_file(fd, MessageType_PlasmaWaitRequest);\n+  std::vector<uint8_t> data = read_message_from_file(fd, MessageType::PlasmaWaitRequest);\n   int num_ready_objects_out;\n   int64_t timeout_ms_read;\n   ObjectRequestMap object_requests_out;\n@@ -353,13 +358,15 @@ TEST(PlasmaSerialization, WaitReply) {\n   /* Create a map with two ObjectRequests in it. */\n   ObjectRequestMap objects_in(num_objects_in);\n   ObjectID id1 = ObjectID::from_random();\n-  objects_in[id1] = ObjectRequest({id1, 0, ObjectStatus_Local});\n+  objects_in[id1] =\n+      ObjectRequest({id1, ObjectRequestType::PLASMA_QUERY_LOCAL, ObjectStatus::Local});\n   ObjectID id2 = ObjectID::from_random();\n-  objects_in[id2] = ObjectRequest({id2, 0, ObjectStatus_Nonexistent});\n+  objects_in[id2] = ObjectRequest(\n+      {id2, ObjectRequestType::PLASMA_QUERY_LOCAL, ObjectStatus::Nonexistent});\n \n   ARROW_CHECK_OK(SendWaitReply(fd, objects_in, num_objects_in));\n   /* Read message back. */\n-  std::vector<uint8_t> data = read_message_from_file(fd, MessageType_PlasmaWaitReply);\n+  std::vector<uint8_t> data = read_message_from_file(fd, MessageType::PlasmaWaitReply);\n   ObjectRequest objects_out[2];\n   int num_objects_out;\n   ARROW_CHECK_OK(\n@@ -383,7 +390,7 @@ TEST(PlasmaSerialization, DataRequest) {\n   int port1 = 12345;\n   ARROW_CHECK_OK(SendDataRequest(fd, object_id1, address1, port1));\n   /* Reading message back. */\n-  std::vector<uint8_t> data = read_message_from_file(fd, MessageType_PlasmaDataRequest);\n+  std::vector<uint8_t> data = read_message_from_file(fd, MessageType::PlasmaDataRequest);\n   ObjectID object_id2;\n   char* address2;\n   int port2;\n@@ -403,7 +410,7 @@ TEST(PlasmaSerialization, DataReply) {\n   int64_t metadata_size1 = 198;\n   ARROW_CHECK_OK(SendDataReply(fd, object_id1, object_size1, metadata_size1));\n   /* Reading message back. */\n-  std::vector<uint8_t> data = read_message_from_file(fd, MessageType_PlasmaDataReply);\n+  std::vector<uint8_t> data = read_message_from_file(fd, MessageType::PlasmaDataReply);\n   ObjectID object_id2;\n   int64_t object_size2;\n   int64_t metadata_size2;\ndiff --git a/python/pyarrow/_plasma.pyx b/python/pyarrow/_plasma.pyx\nindex 8845b871ee..1e2cb66816 100644\n--- a/python/pyarrow/_plasma.pyx\n+++ b/python/pyarrow/_plasma.pyx\n@@ -63,8 +63,8 @@ cdef extern from \"plasma/common.h\":\n     cdef int64_t kDigestSize\" plasma::kDigestSize\"\n \n     cdef enum ObjectRequestType:\n-        PLASMA_QUERY_LOCAL\"plasma::PLASMA_QUERY_LOCAL\",\n-        PLASMA_QUERY_ANYWHERE\"plasma::PLASMA_QUERY_ANYWHERE\"\n+        PLASMA_QUERY_LOCAL\"plasma::ObjectRequestType::PLASMA_QUERY_LOCAL\",\n+        PLASMA_QUERY_ANYWHERE\"plasma::ObjectRequestType::PLASMA_QUERY_ANYWHERE\"\n \n     cdef int ObjectStatusLocal\"plasma::ObjectStatusLocal\"\n     cdef int ObjectStatusRemote\"plasma::ObjectStatusRemote\"\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-06-27T20:35:05.682+0000",
                    "updated": "2018-06-27T20:35:05.682+0000",
                    "started": "2018-06-27T20:35:05.682+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "116593",
                    "issueId": "13168718"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13168718/worklog/116594",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pcmoritz commented on issue #2179: ARROW-2758: [Plasma] Use Scope enum in Plasma\nURL: https://github.com/apache/arrow/pull/2179#issuecomment-400820377\n \n \n   @guoyuhong Can you create an account on the ARROW JIRA so I can assign this to you: https://issues.apache.org/jira/browse/ARROW-2758?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-06-27T20:35:51.500+0000",
                    "updated": "2018-06-27T20:35:51.500+0000",
                    "started": "2018-06-27T20:35:51.500+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "116594",
                    "issueId": "13168718"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13168718/worklog/116734",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "guoyuhong commented on a change in pull request #2179: ARROW-2758: [Plasma] Use Scope enum in Plasma\nURL: https://github.com/apache/arrow/pull/2179#discussion_r198696710\n \n \n\n ##########\n File path: cpp/src/plasma/test/serialization_tests.cc\n ##########\n @@ -353,13 +358,15 @@ TEST(PlasmaSerialization, WaitReply) {\n   /* Create a map with two ObjectRequests in it. */\n   ObjectRequestMap objects_in(num_objects_in);\n   ObjectID id1 = ObjectID::from_random();\n-  objects_in[id1] = ObjectRequest({id1, 0, ObjectStatus_Local});\n \n Review comment:\n   In this test case, the init value for the second argument is 0. However, in ObjectRequestType definition, there is no corresponding enum value to 0. I changed the value to ObjectRequestType::PLASMA_QUERY_LOCAL which equals to 1. The test has no problem. Will this change cause other problems? Maybe this is the benefit from scoped enum. We cannot assign arbitrary value to a enum type. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-06-28T03:05:22.875+0000",
                    "updated": "2018-06-28T03:05:22.875+0000",
                    "started": "2018-06-28T03:05:22.875+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "116734",
                    "issueId": "13168718"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13168718/worklog/116735",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "guoyuhong commented on issue #2179: ARROW-2758: [Plasma] Use Scope enum in Plasma\nURL: https://github.com/apache/arrow/pull/2179#issuecomment-400896537\n \n \n   Hi Philipp, I have create an account on the ARROW JIRA and left a comment is the page. I also left a comment in the test case change. Please take a look. Thanks.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-06-28T03:07:30.361+0000",
                    "updated": "2018-06-28T03:07:30.361+0000",
                    "started": "2018-06-28T03:07:30.361+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "116735",
                    "issueId": "13168718"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 2400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@555a2ab8[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@778485c1[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1d25693e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@4e5c5dd6[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@39c12512[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@5478a134[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@62a24e1c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@4ebc1d73[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7ee55803[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@6f8527ea[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1f2756a8[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@315e87ba[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 2400,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Jun 28 12:24:13 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-06-27T20:35:06.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2758/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2018-06-27T20:33:20.000+0000",
        "updated": "2018-06-28T12:24:13.000+0000",
        "timeoriginalestimate": null,
        "description": "Modernize our usage of enums in plasma:\r\n # add option \"--scoped-enum\" to Flat Buffer Compiler.\r\n # change the old-styled c++ enum to c++11 style.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 2400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Plasma] Use Scope enum in Plasma",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13168718/comment/16525586",
                    "id": "16525586",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pcmoritz",
                        "name": "pcmoritz",
                        "key": "pcmoritz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Philipp Moritz",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Issue resolved by pull request 2179\n[https://github.com/apache/arrow/pull/2179]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pcmoritz",
                        "name": "pcmoritz",
                        "key": "pcmoritz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Philipp Moritz",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-06-27T20:35:06.464+0000",
                    "updated": "2018-06-27T20:35:06.464+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13168718/comment/16525851",
                    "id": "16525851",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=guoyuhong85",
                        "name": "guoyuhong85",
                        "key": "guoyuhong85",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=guoyuhong85&avatarId=36251",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=guoyuhong85&avatarId=36251",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=guoyuhong85&avatarId=36251",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=guoyuhong85&avatarId=36251"
                        },
                        "displayName": "Yuhong Guo",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Hi Philipp, this is Yuhong. Please assign this task to me. Thanks!",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=guoyuhong85",
                        "name": "guoyuhong85",
                        "key": "guoyuhong85",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=guoyuhong85&avatarId=36251",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=guoyuhong85&avatarId=36251",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=guoyuhong85&avatarId=36251",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=guoyuhong85&avatarId=36251"
                        },
                        "displayName": "Yuhong Guo",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-06-28T02:55:17.924+0000",
                    "updated": "2018-06-28T02:55:17.924+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13168718/comment/16526260",
                    "id": "16526260",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "body": "[~guoyuhong85] Assigned you and gave you the necessary karma to self-assign tickets in future. Thanks for contributing.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "created": "2018-06-28T12:24:13.501+0000",
                    "updated": "2018-06-28T12:24:13.501+0000"
                }
            ],
            "maxResults": 3,
            "total": 3,
            "startAt": 0
        },
        "customfield_12311820": "0|i3vb6v:",
        "customfield_12314139": null
    }
}