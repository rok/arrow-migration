{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13327372",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372",
    "key": "ARROW-9991",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12608916",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12608916",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "inwardIssue": {
                    "id": "13042654",
                    "key": "ARROW-555",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13042654",
                    "fields": {
                        "summary": "[C++] String algorithm library for StringArray/BinaryArray",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12615307",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12615307",
                "type": {
                    "id": "10001",
                    "name": "dependent",
                    "inward": "is depended upon by",
                    "outward": "depends upon",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10001"
                },
                "inwardIssue": {
                    "id": "13357188",
                    "key": "ARROW-11515",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13357188",
                    "fields": {
                        "summary": "[R] Bindings for strsplit",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=maartenbreddels",
            "name": "maartenbreddels",
            "key": "maartenbreddels",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Maarten Breddels",
            "active": true,
            "timeZone": "Europe/Amsterdam"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=maartenbreddels",
            "name": "maartenbreddels",
            "key": "maartenbreddels",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Maarten Breddels",
            "active": true,
            "timeZone": "Europe/Amsterdam"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=maartenbreddels",
            "name": "maartenbreddels",
            "key": "maartenbreddels",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Maarten Breddels",
            "active": true,
            "timeZone": "Europe/Amsterdam"
        },
        "aggregateprogress": {
            "progress": 28200,
            "total": 28200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 28200,
            "total": 28200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9991/votes",
            "votes": 1,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 47,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372/worklog/490690",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels opened a new pull request #8271:\nURL: https://github.com/apache/arrow/pull/8271\n\n\n   Contains:\r\n    * split_pattern kernel with max_split and reverse option\r\n    * split_whitespace_ascii similar to Python's bytes.split\r\n    * split_whitespace_utf8 similar to Python's str.split\r\n   \r\n   It should be easy to add new split methods, e.g. a regex one in the future.\r\n   \r\n   This PR mostly done, except for:\r\n    * Expose the options/kernels to Python, like done in #7593 \r\n    * There is 1 test commented out, because it fails for unknown reasons:\r\n   ```c++\r\n     this->CheckUnary(\"split_pattern\", R\"([\"foo bar\", \"foo\", null])\", this->list_type(),\r\n                      R\"([[\"foo\", \"bar\"], [\"foo\"], null])\", &options);\r\n   ```\r\n   Fails with the following output:\r\n   ```\r\n   Failed:\r\n   Got: \r\n     [\r\n       [\r\n         [\r\n           \"foo\",\r\n           \"bar\"\r\n         ]\r\n       ],\r\n       [\r\n         [\r\n           \"foo\"\r\n         ],\r\n         null\r\n       ]\r\n     ]\r\n   Expected: \r\n     [\r\n       [\r\n         [\r\n           \"foo\",\r\n           \"bar\"\r\n         ]\r\n       ],\r\n       [\r\n         [\r\n           \"foo\"\r\n         ],\r\n         null\r\n       ]\r\n     ]\r\n   ```\r\n   \r\n   It seems the test framework does not consider these equal, possibly due to the null value.\r\n   \r\n   This also raised a question: Should both the list entry *and* the string array entry have a missing/null value if the input string contains a null value? I think it should because if we ask for the underlying string array, and the string value that the missing list entry points to is not a missing value, it will be an empty string, which seems odd to me.\r\n   \r\n   In the code, I've commented out the null_builder, instead of removing it, for reviewing, enabling it also does not pass the unit test (that was commented out).\r\n   \r\n   Similar to `match_substring`, the kernel `split_pattern` could also be executed on BinaryArray's, but I'm not sure what the proper way is to make this work. Instantiating new templates would increase the binary size, so maybe there is a smarter way to do this. And possibly this should be done in a different PR, together with `match_substring`.\r\n   \r\n   cc @TomAugspurger \r\n   \r\n   Related #8231 \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-25T11:59:44.575+0000",
                    "updated": "2020-09-25T11:59:44.575+0000",
                    "started": "2020-09-25T11:59:44.575+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "490690",
                    "issueId": "13327372"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372/worklog/490691",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8271:\nURL: https://github.com/apache/arrow/pull/8271#issuecomment-698894038\n\n\n   https://issues.apache.org/jira/browse/ARROW-9991\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-25T12:12:51.809+0000",
                    "updated": "2020-09-25T12:12:51.809+0000",
                    "started": "2020-09-25T12:12:51.808+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "490691",
                    "issueId": "13327372"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372/worklog/491160",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels opened a new pull request #8271:\nURL: https://github.com/apache/arrow/pull/8271\n\n\n   Contains:\r\n    * split_pattern kernel with max_split and reverse option\r\n    * split_whitespace_ascii similar to Python's bytes.split\r\n    * split_whitespace_utf8 similar to Python's str.split\r\n   \r\n   It should be easy to add new split methods, e.g. a regex one in the future.\r\n   \r\n   This PR mostly done, except for:\r\n    * Expose the options/kernels to Python, like done in #7593 \r\n    * There is 1 test commented out, because it fails for unknown reasons:\r\n   ```c++\r\n     this->CheckUnary(\"split_pattern\", R\"([\"foo bar\", \"foo\", null])\", this->list_type(),\r\n                      R\"([[\"foo\", \"bar\"], [\"foo\"], null])\", &options);\r\n   ```\r\n   Fails with the following output:\r\n   ```\r\n   Failed:\r\n   Got: \r\n     [\r\n       [\r\n         [\r\n           \"foo\",\r\n           \"bar\"\r\n         ]\r\n       ],\r\n       [\r\n         [\r\n           \"foo\"\r\n         ],\r\n         null\r\n       ]\r\n     ]\r\n   Expected: \r\n     [\r\n       [\r\n         [\r\n           \"foo\",\r\n           \"bar\"\r\n         ]\r\n       ],\r\n       [\r\n         [\r\n           \"foo\"\r\n         ],\r\n         null\r\n       ]\r\n     ]\r\n   ```\r\n   \r\n   It seems the test framework does not consider these equal, possibly due to the null value.\r\n   \r\n   This also raised a question: Should both the list entry *and* the string array entry have a missing/null value if the input string contains a null value? I think it should because if we ask for the underlying string array, and the string value that the missing list entry points to is not a missing value, it will be an empty string, which seems odd to me.\r\n   \r\n   In the code, I've commented out the null_builder, instead of removing it, for reviewing, enabling it also does not pass the unit test (that was commented out).\r\n   \r\n   Similar to `match_substring`, the kernel `split_pattern` could also be executed on BinaryArray's, but I'm not sure what the proper way is to make this work. Instantiating new templates would increase the binary size, so maybe there is a smarter way to do this. And possibly this should be done in a different PR, together with `match_substring`.\r\n   \r\n   cc @TomAugspurger \r\n   \r\n   Related #8231 \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-25T13:47:59.847+0000",
                    "updated": "2020-09-25T13:47:59.847+0000",
                    "started": "2020-09-25T13:47:59.847+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "491160",
                    "issueId": "13327372"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372/worklog/491195",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8271:\nURL: https://github.com/apache/arrow/pull/8271#issuecomment-698894038\n\n\n   https://issues.apache.org/jira/browse/ARROW-9991\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-25T13:50:59.446+0000",
                    "updated": "2020-09-25T13:50:59.446+0000",
                    "started": "2020-09-25T13:50:59.446+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "491195",
                    "issueId": "13327372"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372/worklog/492944",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on a change in pull request #8271:\nURL: https://github.com/apache/arrow/pull/8271#discussion_r497481336\n\n\n\n##########\nFile path: python/pyarrow/compute.py\n##########\n@@ -253,6 +255,68 @@ def match_substring(array, pattern):\n                          MatchSubstringOptions(pattern))\n \n \n+def split_pattern(array, pattern, max_splits=-1, reverse=False):\n+    \"\"\"\n+    Replace string by a list of strings, separated by *pattern*.\n+\n+    Parameters\n+    ----------\n+    array : pyarrow.Array or pyarrow.ChunkedArray\n+    pattern : str\n+        pattern to split by\n+    max_splits : int\n+        If not -1, the maximum number of splits.\n+    reverse : bool\n+        Start splitting from the right, only meaningful when max_splits != -1\n+\n+    Returns\n+    -------\n+    result : pyarrow.Array or pyarrow.ChunkedArray\n+    \"\"\"\n+    return call_function(\"split_pattern\", [array],\n+                         SplitPatternOptions(pattern, max_splits, reverse))\n\nReview comment:\n       This might be premature optimization, but in theory the `pattern` could also be a second argument (`[array, pattern]`), keeping the option open to later implement `[array, array_of_patterns]` where both could be an array of the same length? (in case you want a different split pattern per value)  \r\n   That would also make SplitOptions could be shared between both `split_pattern` and `split_whitespace`\n\n##########\nFile path: cpp/src/arrow/compute/api_scalar.h\n##########\n@@ -49,6 +49,23 @@ struct ARROW_EXPORT MatchSubstringOptions : public FunctionOptions {\n   std::string pattern;\n };\n \n+struct ARROW_EXPORT SplitOptions : public FunctionOptions {\n+  explicit SplitOptions(int64_t max_splits = -1, bool reverse = false)\n+      : max_splits(max_splits), reverse(reverse) {}\n+\n+  int64_t max_splits;\n+  bool reverse;\n\nReview comment:\n       Can you add a doc comment here?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -809,6 +809,475 @@ struct IsUpperAscii : CharacterPredicateAscii<IsUpperAscii> {\n   }\n };\n \n+// splitting\n+\n+template <typename Type, typename ListType, typename Options, typename Derived>\n+struct SplitBaseTransform {\n+  // TODO: assert offsets types are the same?\n+  using offset_type = typename Type::offset_type;\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using ArrayListType = typename TypeTraits<ListType>::ArrayType;\n+  using ListScalarType = typename TypeTraits<ListType>::ScalarType;\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  using Builder = typename TypeTraits<Type>::BuilderType;\n+  using State = OptionsWrapper<Options>;\n+\n+  static void Split(const uint8_t* input_string, offset_type input_string_nbytes,\n+                    offset_type** output_string_offsets, offset_type* string_output_count,\n+                    offset_type* string_output_offset, uint8_t** output_string_data,\n+                    const Options& options) {\n+    const uint8_t* begin = input_string;\n+    const uint8_t* end = begin + input_string_nbytes;\n+\n+    int64_t max_splits = options.max_splits;\n+    // if there is no max splits, reversing does not make sense (and is probably less\n+    // efficient), but is useful for testing\n+    if (options.reverse) {\n+      // note that i points 1 further than the 'current'\n+      const uint8_t* i = end;\n+      // we will record the parts in reverse order\n+      std::vector<std::pair<const uint8_t*, const uint8_t*>> parts;\n+      if (max_splits > -1) {\n+        parts.reserve(max_splits + 1);\n+      }\n+      while (max_splits != 0) {\n+        const uint8_t *separator_begin, *separator_end;\n+        // find with whatever algo the part we will 'cut out'\n+        if (Derived::FindReverse(begin, i, &separator_begin, &separator_end, options)) {\n+          parts.emplace_back(separator_end, i);\n+          i = separator_begin;\n+          max_splits--;\n+        } else {\n+          // if we cannot find a separator, we're done\n+          break;\n+        }\n+      }\n+      parts.emplace_back(begin, i);\n+      // now we do the copying\n+      for (auto it = parts.rbegin(); it != parts.rend(); ++it) {\n+        auto part = *it;\n+        // copy the string data\n+        for (auto j = part.first; j < part.second; j++) {\n+          *(*output_string_data)++ = *j;\n+          (*string_output_offset)++;\n+        }\n+        // write out the string entry (offset)\n+        *(*output_string_offsets)++ = *string_output_offset;\n+        (*string_output_count)++;\n+      }\n+    } else {\n+      const uint8_t* i = begin;\n+      while (max_splits != 0) {\n+        const uint8_t *separator_begin, *separator_end;\n+        // find with whatever algo the part we will 'cut out'\n+        if (Derived::Find(i, end, &separator_begin, &separator_end, options)) {\n+          // copy the part till the beginning of the 'cut'\n+          while (i < separator_begin) {\n+            *(*output_string_data)++ = *i++;\n+            (*string_output_offset)++;\n+          }\n+          // 'finish' the string by writing the offset\n+          *(*output_string_offsets)++ = *string_output_offset;\n+          (*string_output_count)++;\n+          // jump of the part we cut out\n+          i = separator_end;\n+          max_splits--;\n+        } else {\n+          // if we cannot find a separator, we're done\n+          break;\n+        }\n+      }\n+      // copy bytes after the pattern\n+      while (i < end) {\n+        *(*output_string_data)++ = *i++;\n+        (*string_output_offset)++;\n+      }\n+      // and write out the trailing part (can be an empty string)\n+      *(*output_string_offsets)++ = *string_output_offset;\n+      (*string_output_count)++;\n+    }\n+  }\n+  static Status CheckOptions(const Options& options) { return Status::OK(); }\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();  // only needed for unicode\n+    Options options = State::Get(ctx);\n+    KERNEL_RETURN_IF_ERROR(ctx, Derived::CheckOptions(options));\n+\n+    if (batch[0].kind() == Datum::ARRAY) {\n+      const ArrayData& input = *batch[0].array();\n+      ArrayType input_boxed(batch[0].array());\n+      ArrayData* output_list_data = out->mutable_array();\n+\n+      offset_type input_nbytes = input_boxed.total_values_length();\n+      offset_type input_nstrings = static_cast<offset_type>(input.length);\n+\n+      offset_type output_nbytes_max = input_nbytes;\n+      int64_t output_nstrings_max = Derived::CalculateMaxSplits(input_boxed, options);\n+      if (output_nstrings_max > std::numeric_limits<offset_type>::max()) {\n+        ctx->SetStatus(\n+            Status::CapacityError(\"Result might not fit in a 32bit list or string array, \"\n+                                  \"convert to large_utf8\"));\n+        return;\n+      }\n+\n+      // Why is the offset buffer not preallocated?\n+      KERNEL_ASSIGN_OR_RAISE(output_list_data->buffers[1], ctx,\n+                             ctx->Allocate((input_nstrings + 1) * sizeof(offset_type)));\n+      offset_type* output_list_offsets =\n+          output_list_data->GetMutableValues<offset_type>(1);\n+\n+      // allocate output string array data\n+      // this is a bit low level, should we use a builder?\n+      KERNEL_ASSIGN_OR_RAISE(auto buffer_output_string_data, ctx,\n+                             ctx->Allocate((output_nbytes_max)));\n+      KERNEL_ASSIGN_OR_RAISE(auto buffer_output_string_offsets, ctx,\n+                             ctx->Allocate(output_nstrings_max * sizeof(offset_type)));\n+\n+      offset_type* output_string_offsets =\n+          reinterpret_cast<offset_type*>(buffer_output_string_offsets->mutable_data());\n+      uint8_t* output_string_data = buffer_output_string_data->mutable_data();\n+      // TypedBufferBuilder<bool> null_builder;  // TODO: should we pass a mem poool?\n+      // KERNEL_RETURN_IF_ERROR(ctx, null_builder.Reserve(output_nstrings_max));\n+\n+      // FirstTimeBitmapWriter bitmap_writer(buffer_output_string_bitmap->mutable_data(),\n+      //                                     /*offset=*/0, output_nstrings_max);\n+\n+      // the output offset goes slightly slower then the input (due to skipping pattern)\n+      offset_type output_string_offset = 0;\n+      offset_type output_string_count = 0;\n+\n+      // we always start at the beginning\n+      *output_list_offsets++ = output_string_count;\n+      *output_string_offsets++ = output_string_offset;\n+\n+      for (int64_t i = 0; i < input_nstrings; i++) {\n+        offset_type input_string_nbytes;\n+        const uint8_t* input_string = input_boxed.GetValue(i, &input_string_nbytes);\n+        // if (input_boxed.IsValid(i)) {\n+        Split(input_string, input_string_nbytes, &output_string_offsets,\n+              &output_string_count, &output_string_offset, &output_string_data, options);\n+        //   null_builder.UnsafeAppend(true);\n+        // } else {\n+        //   null_builder.UnsafeAppend(false);\n+        // }\n+\n+        *output_list_offsets++ = output_string_count;\n+      }\n+      // bitmap_writer.Finish();\n+      // trim off extra memory usage\n+      KERNEL_RETURN_IF_ERROR(ctx,\n+                             buffer_output_string_data->Resize(output_string_offsets[-1],\n+                                                               /*shrink_to_fit=*/true));\n+      KERNEL_RETURN_IF_ERROR(ctx, buffer_output_string_offsets->Resize(\n+                                      (output_string_count + 1) * sizeof(offset_type),\n+                                      /*shrink_to_fit=*/true));\n+      // TODO: how to truncate the bitmap?\n+      auto output_string_null_count = 0;  // null_builder.false_count();\n+      std::shared_ptr<Buffer> buffer_output_string_bitmap = nullptr;\n+      // KERNEL_RETURN_IF_ERROR(ctx, null_builder.Finish(&buffer_output_string_bitmap));\n+\n+      std::shared_ptr<ArrayData> output_string_array =\n+          ArrayData::Make(input.type, output_string_count,\n+                          {buffer_output_string_bitmap, buffer_output_string_offsets,\n+                           buffer_output_string_data},\n+                          output_string_null_count);\n+      output_list_data->child_data.push_back(output_string_array);\n+\n+    } else {\n+      const auto& input = checked_cast<const ScalarType&>(*batch[0].scalar());\n+      auto result = checked_pointer_cast<ListScalarType>(MakeNullScalar(out->type()));\n+      if (input.is_valid) {\n+        result->is_valid = true;\n+        offset_type input_nbytes = static_cast<offset_type>(input.value->size());\n+\n+        offset_type output_nbytes_max = input_nbytes;\n+\n+        int64_t output_nstrings_max = Derived::CalculateMaxSplits(input, options);\n+        if (output_nstrings_max > std::numeric_limits<offset_type>::max()) {\n+          ctx->SetStatus(Status::CapacityError(\n+              \"Result might not fit in a 32bit list or string array, \"\n+              \"convert to large_utf8\"));\n+          return;\n+        }\n+\n+        KERNEL_ASSIGN_OR_RAISE(auto buffer_output_string_data, ctx,\n+                               ctx->Allocate((output_nbytes_max)));\n+        KERNEL_ASSIGN_OR_RAISE(auto buffer_output_string_offsets, ctx,\n+                               ctx->Allocate(output_nstrings_max * sizeof(offset_type)));\n+        offset_type* output_string_offsets =\n+            reinterpret_cast<offset_type*>(buffer_output_string_offsets->mutable_data());\n+        uint8_t* output_string_data = buffer_output_string_data->mutable_data();\n+\n+        // the output offset goes slightly slower then the input (due to skipping pattern)\n+        offset_type string_output_offset = 0;\n+        offset_type string_output_count = 0;\n+\n+        // we always start at the beginning\n+        *output_string_offsets++ = string_output_offset;\n+\n+        const uint8_t* input_string = input.value->data();\n+        Split(input_string, input_nbytes, &output_string_offsets, &string_output_count,\n+              &string_output_offset, &output_string_data, options);\n+\n+        KERNEL_RETURN_IF_ERROR(\n+            ctx, buffer_output_string_data->Resize(output_string_offsets[-1],\n+                                                   /*shrink_to_fit=*/true));\n+        KERNEL_RETURN_IF_ERROR(ctx, buffer_output_string_offsets->Resize(\n+                                        (string_output_count + 1) * sizeof(offset_type),\n+                                        /*shrink_to_fit=*/true));\n+\n+        std::shared_ptr<ArrayData> output_string_array = ArrayData::Make(\n+            input.type, string_output_count,\n+            {nullptr, buffer_output_string_offsets, buffer_output_string_data});\n+        result->value = std::make_shared<ArrayType>(output_string_array);\n+      }\n+      out->value = result;\n+    }\n+  }\n+};\n+\n+template <typename Type, typename ListType>\n+struct SplitPatternTransform : SplitBaseTransform<Type, ListType, SplitPatternOptions,\n+                                                  SplitPatternTransform<Type, ListType>> {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  using offset_type = typename Type::offset_type;\n+  static Status CheckOptions(const SplitPatternOptions& options) {\n+    if (options.pattern.length() == 0) {\n+      return Status::Invalid(\"Empty separator\");\n+    }\n+    return Status::OK();\n+  }\n+  static bool Find(const uint8_t* begin, const uint8_t* end,\n+                   const uint8_t** separator_begin, const uint8_t** separator_end,\n+                   const SplitPatternOptions& options) {\n+    const uint8_t* pattern = reinterpret_cast<const uint8_t*>(options.pattern.c_str());\n+    const int64_t pattern_length = options.pattern.length();\n+    const uint8_t* i = begin;\n+    // this is O(n*m) complexity, we could use the Knuth-Morris-Pratt algorithm used in\n+    // the match kernel\n+    while ((i + pattern_length <= end)) {\n+      i = std::search(i, end, pattern, pattern + pattern_length);\n+      if (i != end) {\n+        *separator_begin = i;\n+        *separator_end = i + pattern_length;\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+  static bool FindReverse(const uint8_t* begin, const uint8_t* end,\n+                          const uint8_t** separator_begin, const uint8_t** separator_end,\n+                          const SplitPatternOptions& options) {\n+    const uint8_t* pattern = reinterpret_cast<const uint8_t*>(options.pattern.c_str());\n+    const int64_t pattern_length = options.pattern.length();\n+    // this is O(n*m) complexity, we could use the Knuth-Morris-Pratt algorithm used in\n+    // the match kernel\n+    std::reverse_iterator<const uint8_t*> ri(end);\n+    std::reverse_iterator<const uint8_t*> rend(begin);\n+    std::reverse_iterator<const uint8_t*> pattern_rbegin(pattern + pattern_length);\n+    std::reverse_iterator<const uint8_t*> pattern_rend(pattern);\n+    while (begin <= ri.base() - pattern_length) {\n+      ri = std::search(ri, rend, pattern_rbegin, pattern_rend);\n+      if (ri != rend) {\n+        *separator_begin = ri.base() - pattern_length;\n+        *separator_end = ri.base();\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+  static int64_t CalculateMaxSplits(const ArrayType& input,\n+                                    const SplitPatternOptions& options) {\n+    // Worst case is e.g. ['  ', ' '] split by ' ' -> [['', '', ''], ['', '']]\n+    // i.e. the length of each string divided by the pattern length + 1\n+    // This can double the amount of strings, thus not fit into a (32bit) list or string\n+    // anymore\n+    int64_t output_nstrings_max = 0;\n+    for (offset_type i = 0; i < input.length(); i++) {\n+      output_nstrings_max += 1 + input.value_length(i) / options.pattern.length();\n+    }\n+    return output_nstrings_max;\n+  }\n+  static int64_t CalculateMaxSplits(const ScalarType& input,\n+                                    const SplitPatternOptions& options) {\n+    // Worst case is e.g. ['  ', ' '] split by ' ' -> [['', '', ''], ['', '']]\n+    // i.e. the length of each string divided by the pattern length + 1\n+    // This can double the amount of strings, thus not fit into a (32bit) list or string\n+    // anymore\n+    return 1 + input.value->size() / options.pattern.length();\n+  }\n+};\n+\n+void AddSplitPattern(FunctionRegistry* registry) {\n+  auto func = std::make_shared<ScalarFunction>(\"split_pattern\", Arity::Unary());\n\nReview comment:\n       Should the kernel name be `string_split_pattern` instead of `split_pattern`? (like we have `string_is_ascii` and not `is_ascii` and `binary_length` and not `length`)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-30T13:02:57.503+0000",
                    "updated": "2020-09-30T13:02:57.503+0000",
                    "started": "2020-09-30T13:02:57.503+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "492944",
                    "issueId": "13327372"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372/worklog/492945",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on a change in pull request #8271:\nURL: https://github.com/apache/arrow/pull/8271#discussion_r497492333\n\n\n\n##########\nFile path: python/pyarrow/compute.py\n##########\n@@ -253,6 +255,68 @@ def match_substring(array, pattern):\n                          MatchSubstringOptions(pattern))\n \n \n+def split_pattern(array, pattern, max_splits=-1, reverse=False):\n+    \"\"\"\n+    Replace string by a list of strings, separated by *pattern*.\n+\n+    Parameters\n+    ----------\n+    array : pyarrow.Array or pyarrow.ChunkedArray\n+    pattern : str\n+        pattern to split by\n+    max_splits : int\n+        If not -1, the maximum number of splits.\n+    reverse : bool\n+        Start splitting from the right, only meaningful when max_splits != -1\n+\n+    Returns\n+    -------\n+    result : pyarrow.Array or pyarrow.ChunkedArray\n+    \"\"\"\n+    return call_function(\"split_pattern\", [array],\n+                         SplitPatternOptions(pattern, max_splits, reverse))\n\nReview comment:\n       (ah, I see you commented about that above yourself)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-30T13:04:34.007+0000",
                    "updated": "2020-09-30T13:04:34.007+0000",
                    "started": "2020-09-30T13:04:34.006+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "492945",
                    "issueId": "13327372"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372/worklog/492947",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on pull request #8271:\nURL: https://github.com/apache/arrow/pull/8271#issuecomment-701380049\n\n\n   > This also raised a question: Should both the list entry and the string array entry have a missing/null value if the input string contains a null value? I think it should because if we ask for the underlying string array, and the string value that the missing list entry points to is not a missing value, it will be an empty string, which seems odd to me.\r\n   \r\n   Buf if the original string was a null, then the output also contains a (top-level) null, and not a list with a null?\r\n   \r\n   And then such top-level nulls are typically not put as an entry in the actual values array (or at least when arrow is building up a list array itself, the format might also not allow otherwise). Eg:\r\n   \r\n   ```\r\n   In [10]: arr = pa.array([[\"a\", \"b\"], None, [\"c\"], [None]])\r\n   \r\n   In [11]: arr\r\n   Out[11]: \r\n   <pyarrow.lib.ListArray object at 0x7f2316c1d108>\r\n   [\r\n     [\r\n       \"a\",\r\n       \"b\"\r\n     ],\r\n     null,\r\n     [\r\n       \"c\"\r\n     ],\r\n     [\r\n       null\r\n     ]\r\n   ]\r\n   \r\n   In [12]: arr.values\r\n   Out[12]: \r\n   <pyarrow.lib.StringArray object at 0x7f2316c1d5e8>\r\n   [\r\n     \"a\",\r\n     \"b\",\r\n     \"c\",\r\n     null\r\n   ]\r\n   ```\r\n   \r\n   (so only the null that was inside a list is represented as null in the underlying values array)\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-30T13:09:57.574+0000",
                    "updated": "2020-09-30T13:09:57.574+0000",
                    "started": "2020-09-30T13:09:57.573+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "492947",
                    "issueId": "13327372"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372/worklog/492997",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8271:\nURL: https://github.com/apache/arrow/pull/8271#discussion_r497546569\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string_benchmark.cc\n##########\n@@ -66,6 +66,11 @@ static void MatchSubstring(benchmark::State& state) {\n   UnaryStringBenchmark(state, \"match_substring\", &options);\n }\n \n+static void SplitPattern(benchmark::State& state) {\n+  SplitPatternOptions options(\"abac\");\n+  UnaryStringBenchmark(state, \"split_pattern\", &options);\n\nReview comment:\n       Is there really a point in benchmarking random data? Presumably 0 split will happen...\r\n   You also don't need to worry about benchmarks in this PR, they may be added later.\n\n##########\nFile path: cpp/src/arrow/util/utf8.h\n##########\n@@ -350,6 +362,42 @@ static inline bool UTF8Decode(const uint8_t** data, uint32_t* codepoint) {\n   return true;\n }\n \n+static inline bool UTF8DecodeReverse(const uint8_t** data, uint32_t* codepoint) {\n+  const uint8_t* str = *data;\n+  if (*str < 0x80) {  // ascci\n+    *codepoint = *str--;\n+  } else if (ARROW_PREDICT_TRUE(Utf8IsContinuation(*str))) {\n\nReview comment:\n       Nit: instead of the `if` nesting here, it may be clearer to handle errors before:\r\n   ```c++\r\n   if (ARROW_PREDICT_FALSE(!Utf8IsContinuation(*str))) {\r\n     return false;\r\n   }\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string_test.cc\n##########\n@@ -53,8 +53,19 @@ class BaseTestStringKernels : public ::testing::Test {\n   std::shared_ptr<DataType> offset_type() {\n     return TypeTraits<OffsetType>::type_singleton();\n   }\n+  std::shared_ptr<DataType> list_type();\n };\n \n+template <>\n+std::shared_ptr<DataType> BaseTestStringKernels<LargeStringType>::list_type() {\n+  return large_list(this->type());\n\nReview comment:\n       I don't think that makes sense. Why would you return a large list when the embedded type is a large string?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -809,6 +809,475 @@ struct IsUpperAscii : CharacterPredicateAscii<IsUpperAscii> {\n   }\n };\n \n+// splitting\n+\n+template <typename Type, typename ListType, typename Options, typename Derived>\n+struct SplitBaseTransform {\n+  // TODO: assert offsets types are the same?\n+  using offset_type = typename Type::offset_type;\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using ArrayListType = typename TypeTraits<ListType>::ArrayType;\n+  using ListScalarType = typename TypeTraits<ListType>::ScalarType;\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  using Builder = typename TypeTraits<Type>::BuilderType;\n+  using State = OptionsWrapper<Options>;\n+\n+  static void Split(const uint8_t* input_string, offset_type input_string_nbytes,\n+                    offset_type** output_string_offsets, offset_type* string_output_count,\n+                    offset_type* string_output_offset, uint8_t** output_string_data,\n+                    const Options& options) {\n+    const uint8_t* begin = input_string;\n+    const uint8_t* end = begin + input_string_nbytes;\n+\n+    int64_t max_splits = options.max_splits;\n+    // if there is no max splits, reversing does not make sense (and is probably less\n+    // efficient), but is useful for testing\n+    if (options.reverse) {\n+      // note that i points 1 further than the 'current'\n+      const uint8_t* i = end;\n+      // we will record the parts in reverse order\n+      std::vector<std::pair<const uint8_t*, const uint8_t*>> parts;\n\nReview comment:\n       Hmm, can you use `arrow::util::string_view` instead?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -809,6 +809,475 @@ struct IsUpperAscii : CharacterPredicateAscii<IsUpperAscii> {\n   }\n };\n \n+// splitting\n+\n+template <typename Type, typename ListType, typename Options, typename Derived>\n+struct SplitBaseTransform {\n+  // TODO: assert offsets types are the same?\n+  using offset_type = typename Type::offset_type;\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using ArrayListType = typename TypeTraits<ListType>::ArrayType;\n+  using ListScalarType = typename TypeTraits<ListType>::ScalarType;\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  using Builder = typename TypeTraits<Type>::BuilderType;\n+  using State = OptionsWrapper<Options>;\n+\n+  static void Split(const uint8_t* input_string, offset_type input_string_nbytes,\n+                    offset_type** output_string_offsets, offset_type* string_output_count,\n+                    offset_type* string_output_offset, uint8_t** output_string_data,\n+                    const Options& options) {\n+    const uint8_t* begin = input_string;\n+    const uint8_t* end = begin + input_string_nbytes;\n+\n+    int64_t max_splits = options.max_splits;\n+    // if there is no max splits, reversing does not make sense (and is probably less\n+    // efficient), but is useful for testing\n+    if (options.reverse) {\n+      // note that i points 1 further than the 'current'\n+      const uint8_t* i = end;\n+      // we will record the parts in reverse order\n+      std::vector<std::pair<const uint8_t*, const uint8_t*>> parts;\n+      if (max_splits > -1) {\n+        parts.reserve(max_splits + 1);\n+      }\n+      while (max_splits != 0) {\n+        const uint8_t *separator_begin, *separator_end;\n+        // find with whatever algo the part we will 'cut out'\n+        if (Derived::FindReverse(begin, i, &separator_begin, &separator_end, options)) {\n+          parts.emplace_back(separator_end, i);\n+          i = separator_begin;\n+          max_splits--;\n+        } else {\n+          // if we cannot find a separator, we're done\n+          break;\n+        }\n+      }\n+      parts.emplace_back(begin, i);\n+      // now we do the copying\n+      for (auto it = parts.rbegin(); it != parts.rend(); ++it) {\n+        auto part = *it;\n+        // copy the string data\n+        for (auto j = part.first; j < part.second; j++) {\n+          *(*output_string_data)++ = *j;\n+          (*string_output_offset)++;\n+        }\n+        // write out the string entry (offset)\n+        *(*output_string_offsets)++ = *string_output_offset;\n+        (*string_output_count)++;\n+      }\n+    } else {\n+      const uint8_t* i = begin;\n+      while (max_splits != 0) {\n+        const uint8_t *separator_begin, *separator_end;\n+        // find with whatever algo the part we will 'cut out'\n+        if (Derived::Find(i, end, &separator_begin, &separator_end, options)) {\n+          // copy the part till the beginning of the 'cut'\n+          while (i < separator_begin) {\n+            *(*output_string_data)++ = *i++;\n+            (*string_output_offset)++;\n+          }\n+          // 'finish' the string by writing the offset\n+          *(*output_string_offsets)++ = *string_output_offset;\n+          (*string_output_count)++;\n+          // jump of the part we cut out\n+          i = separator_end;\n+          max_splits--;\n+        } else {\n+          // if we cannot find a separator, we're done\n+          break;\n+        }\n+      }\n+      // copy bytes after the pattern\n+      while (i < end) {\n+        *(*output_string_data)++ = *i++;\n+        (*string_output_offset)++;\n+      }\n+      // and write out the trailing part (can be an empty string)\n+      *(*output_string_offsets)++ = *string_output_offset;\n+      (*string_output_count)++;\n+    }\n+  }\n+  static Status CheckOptions(const Options& options) { return Status::OK(); }\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();  // only needed for unicode\n+    Options options = State::Get(ctx);\n+    KERNEL_RETURN_IF_ERROR(ctx, Derived::CheckOptions(options));\n+\n+    if (batch[0].kind() == Datum::ARRAY) {\n+      const ArrayData& input = *batch[0].array();\n+      ArrayType input_boxed(batch[0].array());\n\nReview comment:\n       I think you should try using `VisitArrayDataInline<Type>` instead of redoing all this by hand.\n\n##########\nFile path: python/pyarrow/tests/test_compute.py\n##########\n@@ -230,6 +230,51 @@ def test_match_substring():\n     assert expected.equals(result)\n \n \n+def test_split_pattern():\n\nReview comment:\n       It doesn't really make sense to duplicate C++ tests on the Python side.\n\n##########\nFile path: python/pyarrow/_compute.pyx\n##########\n@@ -560,6 +560,29 @@ cdef class MatchSubstringOptions(FunctionOptions):\n         return self.match_substring_options.get()\n \n \n+cdef class SplitOptions(FunctionOptions):\n+    cdef:\n+        unique_ptr[CSplitOptions] split_options\n+\n+    def __init__(self, max_splits, reverse):\n+        self.split_options.reset(\n+            new CSplitOptions(max_splits, reverse))\n+\n+    cdef const CFunctionOptions* get_options(self) except NULL:\n+        return self.split_options.get()\n+\n+\n+cdef class SplitPatternOptions(FunctionOptions):\n+    cdef:\n+        unique_ptr[CSplitPatternOptions] split_pattern_options\n+\n+    def __init__(self, pattern, max_splits, reverse):\n\nReview comment:\n       Perhaps:\r\n   ```python\r\n       def __init__(self, pattern, *, max_splits, reverse):\r\n   ```\r\n   ?\n\n##########\nFile path: python/pyarrow/compute.py\n##########\n@@ -253,6 +255,68 @@ def match_substring(array, pattern):\n                          MatchSubstringOptions(pattern))\n \n \n+def split_pattern(array, pattern, max_splits=-1, reverse=False):\n\nReview comment:\n       You don't need this, it will be exposed automatically. However, you'll need to expand `_option_classes`.\n\n##########\nFile path: python/pyarrow/_compute.pyx\n##########\n@@ -560,6 +560,29 @@ cdef class MatchSubstringOptions(FunctionOptions):\n         return self.match_substring_options.get()\n \n \n+cdef class SplitOptions(FunctionOptions):\n+    cdef:\n+        unique_ptr[CSplitOptions] split_options\n+\n+    def __init__(self, max_splits, reverse):\n\nReview comment:\n       We should probably use keyword-only arguments here:\r\n   ```python\r\n       def __init__(self, *, max_splits, reverse):\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -809,6 +809,475 @@ struct IsUpperAscii : CharacterPredicateAscii<IsUpperAscii> {\n   }\n };\n \n+// splitting\n+\n+template <typename Type, typename ListType, typename Options, typename Derived>\n+struct SplitBaseTransform {\n+  // TODO: assert offsets types are the same?\n+  using offset_type = typename Type::offset_type;\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using ArrayListType = typename TypeTraits<ListType>::ArrayType;\n+  using ListScalarType = typename TypeTraits<ListType>::ScalarType;\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  using Builder = typename TypeTraits<Type>::BuilderType;\n+  using State = OptionsWrapper<Options>;\n+\n+  static void Split(const uint8_t* input_string, offset_type input_string_nbytes,\n+                    offset_type** output_string_offsets, offset_type* string_output_count,\n+                    offset_type* string_output_offset, uint8_t** output_string_data,\n+                    const Options& options) {\n+    const uint8_t* begin = input_string;\n+    const uint8_t* end = begin + input_string_nbytes;\n+\n+    int64_t max_splits = options.max_splits;\n+    // if there is no max splits, reversing does not make sense (and is probably less\n+    // efficient), but is useful for testing\n+    if (options.reverse) {\n+      // note that i points 1 further than the 'current'\n+      const uint8_t* i = end;\n+      // we will record the parts in reverse order\n+      std::vector<std::pair<const uint8_t*, const uint8_t*>> parts;\n+      if (max_splits > -1) {\n+        parts.reserve(max_splits + 1);\n+      }\n+      while (max_splits != 0) {\n+        const uint8_t *separator_begin, *separator_end;\n+        // find with whatever algo the part we will 'cut out'\n+        if (Derived::FindReverse(begin, i, &separator_begin, &separator_end, options)) {\n+          parts.emplace_back(separator_end, i);\n+          i = separator_begin;\n+          max_splits--;\n+        } else {\n+          // if we cannot find a separator, we're done\n+          break;\n+        }\n+      }\n+      parts.emplace_back(begin, i);\n+      // now we do the copying\n+      for (auto it = parts.rbegin(); it != parts.rend(); ++it) {\n+        auto part = *it;\n+        // copy the string data\n+        for (auto j = part.first; j < part.second; j++) {\n+          *(*output_string_data)++ = *j;\n+          (*string_output_offset)++;\n+        }\n+        // write out the string entry (offset)\n+        *(*output_string_offsets)++ = *string_output_offset;\n+        (*string_output_count)++;\n+      }\n+    } else {\n+      const uint8_t* i = begin;\n+      while (max_splits != 0) {\n+        const uint8_t *separator_begin, *separator_end;\n+        // find with whatever algo the part we will 'cut out'\n+        if (Derived::Find(i, end, &separator_begin, &separator_end, options)) {\n+          // copy the part till the beginning of the 'cut'\n+          while (i < separator_begin) {\n+            *(*output_string_data)++ = *i++;\n+            (*string_output_offset)++;\n+          }\n+          // 'finish' the string by writing the offset\n+          *(*output_string_offsets)++ = *string_output_offset;\n+          (*string_output_count)++;\n+          // jump of the part we cut out\n+          i = separator_end;\n+          max_splits--;\n+        } else {\n+          // if we cannot find a separator, we're done\n+          break;\n+        }\n+      }\n+      // copy bytes after the pattern\n+      while (i < end) {\n+        *(*output_string_data)++ = *i++;\n+        (*string_output_offset)++;\n+      }\n+      // and write out the trailing part (can be an empty string)\n+      *(*output_string_offsets)++ = *string_output_offset;\n+      (*string_output_count)++;\n+    }\n+  }\n+  static Status CheckOptions(const Options& options) { return Status::OK(); }\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();  // only needed for unicode\n+    Options options = State::Get(ctx);\n+    KERNEL_RETURN_IF_ERROR(ctx, Derived::CheckOptions(options));\n+\n+    if (batch[0].kind() == Datum::ARRAY) {\n+      const ArrayData& input = *batch[0].array();\n+      ArrayType input_boxed(batch[0].array());\n+      ArrayData* output_list_data = out->mutable_array();\n+\n+      offset_type input_nbytes = input_boxed.total_values_length();\n+      offset_type input_nstrings = static_cast<offset_type>(input.length);\n+\n+      offset_type output_nbytes_max = input_nbytes;\n+      int64_t output_nstrings_max = Derived::CalculateMaxSplits(input_boxed, options);\n+      if (output_nstrings_max > std::numeric_limits<offset_type>::max()) {\n+        ctx->SetStatus(\n+            Status::CapacityError(\"Result might not fit in a 32bit list or string array, \"\n+                                  \"convert to large_utf8\"));\n+        return;\n+      }\n+\n+      // Why is the offset buffer not preallocated?\n+      KERNEL_ASSIGN_OR_RAISE(output_list_data->buffers[1], ctx,\n+                             ctx->Allocate((input_nstrings + 1) * sizeof(offset_type)));\n+      offset_type* output_list_offsets =\n+          output_list_data->GetMutableValues<offset_type>(1);\n+\n+      // allocate output string array data\n+      // this is a bit low level, should we use a builder?\n+      KERNEL_ASSIGN_OR_RAISE(auto buffer_output_string_data, ctx,\n+                             ctx->Allocate((output_nbytes_max)));\n+      KERNEL_ASSIGN_OR_RAISE(auto buffer_output_string_offsets, ctx,\n+                             ctx->Allocate(output_nstrings_max * sizeof(offset_type)));\n+\n+      offset_type* output_string_offsets =\n+          reinterpret_cast<offset_type*>(buffer_output_string_offsets->mutable_data());\n+      uint8_t* output_string_data = buffer_output_string_data->mutable_data();\n+      // TypedBufferBuilder<bool> null_builder;  // TODO: should we pass a mem poool?\n+      // KERNEL_RETURN_IF_ERROR(ctx, null_builder.Reserve(output_nstrings_max));\n+\n+      // FirstTimeBitmapWriter bitmap_writer(buffer_output_string_bitmap->mutable_data(),\n+      //                                     /*offset=*/0, output_nstrings_max);\n+\n+      // the output offset goes slightly slower then the input (due to skipping pattern)\n+      offset_type output_string_offset = 0;\n+      offset_type output_string_count = 0;\n+\n+      // we always start at the beginning\n+      *output_list_offsets++ = output_string_count;\n+      *output_string_offsets++ = output_string_offset;\n+\n+      for (int64_t i = 0; i < input_nstrings; i++) {\n+        offset_type input_string_nbytes;\n+        const uint8_t* input_string = input_boxed.GetValue(i, &input_string_nbytes);\n+        // if (input_boxed.IsValid(i)) {\n+        Split(input_string, input_string_nbytes, &output_string_offsets,\n+              &output_string_count, &output_string_offset, &output_string_data, options);\n+        //   null_builder.UnsafeAppend(true);\n+        // } else {\n+        //   null_builder.UnsafeAppend(false);\n+        // }\n+\n+        *output_list_offsets++ = output_string_count;\n+      }\n+      // bitmap_writer.Finish();\n+      // trim off extra memory usage\n+      KERNEL_RETURN_IF_ERROR(ctx,\n+                             buffer_output_string_data->Resize(output_string_offsets[-1],\n+                                                               /*shrink_to_fit=*/true));\n+      KERNEL_RETURN_IF_ERROR(ctx, buffer_output_string_offsets->Resize(\n+                                      (output_string_count + 1) * sizeof(offset_type),\n+                                      /*shrink_to_fit=*/true));\n+      // TODO: how to truncate the bitmap?\n+      auto output_string_null_count = 0;  // null_builder.false_count();\n+      std::shared_ptr<Buffer> buffer_output_string_bitmap = nullptr;\n+      // KERNEL_RETURN_IF_ERROR(ctx, null_builder.Finish(&buffer_output_string_bitmap));\n+\n+      std::shared_ptr<ArrayData> output_string_array =\n+          ArrayData::Make(input.type, output_string_count,\n+                          {buffer_output_string_bitmap, buffer_output_string_offsets,\n+                           buffer_output_string_data},\n+                          output_string_null_count);\n+      output_list_data->child_data.push_back(output_string_array);\n+\n+    } else {\n+      const auto& input = checked_cast<const ScalarType&>(*batch[0].scalar());\n+      auto result = checked_pointer_cast<ListScalarType>(MakeNullScalar(out->type()));\n+      if (input.is_valid) {\n+        result->is_valid = true;\n+        offset_type input_nbytes = static_cast<offset_type>(input.value->size());\n+\n+        offset_type output_nbytes_max = input_nbytes;\n+\n+        int64_t output_nstrings_max = Derived::CalculateMaxSplits(input, options);\n+        if (output_nstrings_max > std::numeric_limits<offset_type>::max()) {\n+          ctx->SetStatus(Status::CapacityError(\n+              \"Result might not fit in a 32bit list or string array, \"\n+              \"convert to large_utf8\"));\n+          return;\n+        }\n+\n+        KERNEL_ASSIGN_OR_RAISE(auto buffer_output_string_data, ctx,\n+                               ctx->Allocate((output_nbytes_max)));\n+        KERNEL_ASSIGN_OR_RAISE(auto buffer_output_string_offsets, ctx,\n+                               ctx->Allocate(output_nstrings_max * sizeof(offset_type)));\n+        offset_type* output_string_offsets =\n+            reinterpret_cast<offset_type*>(buffer_output_string_offsets->mutable_data());\n+        uint8_t* output_string_data = buffer_output_string_data->mutable_data();\n+\n+        // the output offset goes slightly slower then the input (due to skipping pattern)\n+        offset_type string_output_offset = 0;\n+        offset_type string_output_count = 0;\n+\n+        // we always start at the beginning\n+        *output_string_offsets++ = string_output_offset;\n+\n+        const uint8_t* input_string = input.value->data();\n+        Split(input_string, input_nbytes, &output_string_offsets, &string_output_count,\n+              &string_output_offset, &output_string_data, options);\n+\n+        KERNEL_RETURN_IF_ERROR(\n+            ctx, buffer_output_string_data->Resize(output_string_offsets[-1],\n+                                                   /*shrink_to_fit=*/true));\n+        KERNEL_RETURN_IF_ERROR(ctx, buffer_output_string_offsets->Resize(\n+                                        (string_output_count + 1) * sizeof(offset_type),\n+                                        /*shrink_to_fit=*/true));\n+\n+        std::shared_ptr<ArrayData> output_string_array = ArrayData::Make(\n+            input.type, string_output_count,\n+            {nullptr, buffer_output_string_offsets, buffer_output_string_data});\n+        result->value = std::make_shared<ArrayType>(output_string_array);\n+      }\n+      out->value = result;\n+    }\n+  }\n+};\n+\n+template <typename Type, typename ListType>\n+struct SplitPatternTransform : SplitBaseTransform<Type, ListType, SplitPatternOptions,\n+                                                  SplitPatternTransform<Type, ListType>> {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  using offset_type = typename Type::offset_type;\n+  static Status CheckOptions(const SplitPatternOptions& options) {\n+    if (options.pattern.length() == 0) {\n+      return Status::Invalid(\"Empty separator\");\n+    }\n+    return Status::OK();\n+  }\n+  static bool Find(const uint8_t* begin, const uint8_t* end,\n+                   const uint8_t** separator_begin, const uint8_t** separator_end,\n+                   const SplitPatternOptions& options) {\n+    const uint8_t* pattern = reinterpret_cast<const uint8_t*>(options.pattern.c_str());\n+    const int64_t pattern_length = options.pattern.length();\n+    const uint8_t* i = begin;\n+    // this is O(n*m) complexity, we could use the Knuth-Morris-Pratt algorithm used in\n+    // the match kernel\n+    while ((i + pattern_length <= end)) {\n+      i = std::search(i, end, pattern, pattern + pattern_length);\n+      if (i != end) {\n+        *separator_begin = i;\n+        *separator_end = i + pattern_length;\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+  static bool FindReverse(const uint8_t* begin, const uint8_t* end,\n+                          const uint8_t** separator_begin, const uint8_t** separator_end,\n+                          const SplitPatternOptions& options) {\n+    const uint8_t* pattern = reinterpret_cast<const uint8_t*>(options.pattern.c_str());\n+    const int64_t pattern_length = options.pattern.length();\n+    // this is O(n*m) complexity, we could use the Knuth-Morris-Pratt algorithm used in\n+    // the match kernel\n+    std::reverse_iterator<const uint8_t*> ri(end);\n+    std::reverse_iterator<const uint8_t*> rend(begin);\n+    std::reverse_iterator<const uint8_t*> pattern_rbegin(pattern + pattern_length);\n+    std::reverse_iterator<const uint8_t*> pattern_rend(pattern);\n+    while (begin <= ri.base() - pattern_length) {\n+      ri = std::search(ri, rend, pattern_rbegin, pattern_rend);\n+      if (ri != rend) {\n+        *separator_begin = ri.base() - pattern_length;\n+        *separator_end = ri.base();\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+  static int64_t CalculateMaxSplits(const ArrayType& input,\n+                                    const SplitPatternOptions& options) {\n+    // Worst case is e.g. ['  ', ' '] split by ' ' -> [['', '', ''], ['', '']]\n+    // i.e. the length of each string divided by the pattern length + 1\n+    // This can double the amount of strings, thus not fit into a (32bit) list or string\n\nReview comment:\n       More than double. Your example shows it growing from 2 to 5, but if the pattern is length 1 (probably a common case?) you're really allocating one output string per input byte. This is probably too much.\r\n   \r\n   Instead, you may use:\r\n   * a presized `BufferBuilder` for the string bytes\r\n   * a dynamically-sized `TypedBufferBuilder<offset_type>` for the string offsets\r\n   * a presized `TypedBufferBuilder<int32_t>` for the list offsets\r\n   \r\n   And the output's null bitmap is the same as the input's null bitmap, so no need to recompute it!\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -809,6 +809,475 @@ struct IsUpperAscii : CharacterPredicateAscii<IsUpperAscii> {\n   }\n };\n \n+// splitting\n+\n+template <typename Type, typename ListType, typename Options, typename Derived>\n+struct SplitBaseTransform {\n+  // TODO: assert offsets types are the same?\n+  using offset_type = typename Type::offset_type;\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using ArrayListType = typename TypeTraits<ListType>::ArrayType;\n+  using ListScalarType = typename TypeTraits<ListType>::ScalarType;\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  using Builder = typename TypeTraits<Type>::BuilderType;\n+  using State = OptionsWrapper<Options>;\n+\n+  static void Split(const uint8_t* input_string, offset_type input_string_nbytes,\n+                    offset_type** output_string_offsets, offset_type* string_output_count,\n+                    offset_type* string_output_offset, uint8_t** output_string_data,\n+                    const Options& options) {\n+    const uint8_t* begin = input_string;\n+    const uint8_t* end = begin + input_string_nbytes;\n+\n+    int64_t max_splits = options.max_splits;\n+    // if there is no max splits, reversing does not make sense (and is probably less\n+    // efficient), but is useful for testing\n+    if (options.reverse) {\n+      // note that i points 1 further than the 'current'\n+      const uint8_t* i = end;\n+      // we will record the parts in reverse order\n+      std::vector<std::pair<const uint8_t*, const uint8_t*>> parts;\n+      if (max_splits > -1) {\n+        parts.reserve(max_splits + 1);\n+      }\n+      while (max_splits != 0) {\n+        const uint8_t *separator_begin, *separator_end;\n+        // find with whatever algo the part we will 'cut out'\n+        if (Derived::FindReverse(begin, i, &separator_begin, &separator_end, options)) {\n+          parts.emplace_back(separator_end, i);\n+          i = separator_begin;\n+          max_splits--;\n+        } else {\n+          // if we cannot find a separator, we're done\n+          break;\n+        }\n+      }\n+      parts.emplace_back(begin, i);\n+      // now we do the copying\n+      for (auto it = parts.rbegin(); it != parts.rend(); ++it) {\n+        auto part = *it;\n+        // copy the string data\n+        for (auto j = part.first; j < part.second; j++) {\n+          *(*output_string_data)++ = *j;\n+          (*string_output_offset)++;\n+        }\n+        // write out the string entry (offset)\n+        *(*output_string_offsets)++ = *string_output_offset;\n+        (*string_output_count)++;\n+      }\n+    } else {\n+      const uint8_t* i = begin;\n+      while (max_splits != 0) {\n+        const uint8_t *separator_begin, *separator_end;\n+        // find with whatever algo the part we will 'cut out'\n+        if (Derived::Find(i, end, &separator_begin, &separator_end, options)) {\n+          // copy the part till the beginning of the 'cut'\n+          while (i < separator_begin) {\n+            *(*output_string_data)++ = *i++;\n+            (*string_output_offset)++;\n+          }\n+          // 'finish' the string by writing the offset\n+          *(*output_string_offsets)++ = *string_output_offset;\n+          (*string_output_count)++;\n+          // jump of the part we cut out\n+          i = separator_end;\n+          max_splits--;\n+        } else {\n+          // if we cannot find a separator, we're done\n+          break;\n+        }\n+      }\n+      // copy bytes after the pattern\n+      while (i < end) {\n+        *(*output_string_data)++ = *i++;\n+        (*string_output_offset)++;\n+      }\n+      // and write out the trailing part (can be an empty string)\n+      *(*output_string_offsets)++ = *string_output_offset;\n+      (*string_output_count)++;\n+    }\n+  }\n+  static Status CheckOptions(const Options& options) { return Status::OK(); }\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();  // only needed for unicode\n+    Options options = State::Get(ctx);\n+    KERNEL_RETURN_IF_ERROR(ctx, Derived::CheckOptions(options));\n+\n+    if (batch[0].kind() == Datum::ARRAY) {\n+      const ArrayData& input = *batch[0].array();\n+      ArrayType input_boxed(batch[0].array());\n+      ArrayData* output_list_data = out->mutable_array();\n+\n+      offset_type input_nbytes = input_boxed.total_values_length();\n+      offset_type input_nstrings = static_cast<offset_type>(input.length);\n+\n+      offset_type output_nbytes_max = input_nbytes;\n+      int64_t output_nstrings_max = Derived::CalculateMaxSplits(input_boxed, options);\n+      if (output_nstrings_max > std::numeric_limits<offset_type>::max()) {\n+        ctx->SetStatus(\n+            Status::CapacityError(\"Result might not fit in a 32bit list or string array, \"\n+                                  \"convert to large_utf8\"));\n+        return;\n+      }\n+\n+      // Why is the offset buffer not preallocated?\n+      KERNEL_ASSIGN_OR_RAISE(output_list_data->buffers[1], ctx,\n+                             ctx->Allocate((input_nstrings + 1) * sizeof(offset_type)));\n+      offset_type* output_list_offsets =\n+          output_list_data->GetMutableValues<offset_type>(1);\n+\n+      // allocate output string array data\n+      // this is a bit low level, should we use a builder?\n+      KERNEL_ASSIGN_OR_RAISE(auto buffer_output_string_data, ctx,\n+                             ctx->Allocate((output_nbytes_max)));\n+      KERNEL_ASSIGN_OR_RAISE(auto buffer_output_string_offsets, ctx,\n+                             ctx->Allocate(output_nstrings_max * sizeof(offset_type)));\n+\n+      offset_type* output_string_offsets =\n+          reinterpret_cast<offset_type*>(buffer_output_string_offsets->mutable_data());\n+      uint8_t* output_string_data = buffer_output_string_data->mutable_data();\n+      // TypedBufferBuilder<bool> null_builder;  // TODO: should we pass a mem poool?\n+      // KERNEL_RETURN_IF_ERROR(ctx, null_builder.Reserve(output_nstrings_max));\n\nReview comment:\n       Why is all this commented out? Is this PR unfinished?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -809,6 +809,475 @@ struct IsUpperAscii : CharacterPredicateAscii<IsUpperAscii> {\n   }\n };\n \n+// splitting\n+\n+template <typename Type, typename ListType, typename Options, typename Derived>\n+struct SplitBaseTransform {\n+  // TODO: assert offsets types are the same?\n+  using offset_type = typename Type::offset_type;\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using ArrayListType = typename TypeTraits<ListType>::ArrayType;\n+  using ListScalarType = typename TypeTraits<ListType>::ScalarType;\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  using Builder = typename TypeTraits<Type>::BuilderType;\n+  using State = OptionsWrapper<Options>;\n+\n+  static void Split(const uint8_t* input_string, offset_type input_string_nbytes,\n+                    offset_type** output_string_offsets, offset_type* string_output_count,\n+                    offset_type* string_output_offset, uint8_t** output_string_data,\n+                    const Options& options) {\n+    const uint8_t* begin = input_string;\n+    const uint8_t* end = begin + input_string_nbytes;\n+\n+    int64_t max_splits = options.max_splits;\n+    // if there is no max splits, reversing does not make sense (and is probably less\n+    // efficient), but is useful for testing\n+    if (options.reverse) {\n+      // note that i points 1 further than the 'current'\n+      const uint8_t* i = end;\n+      // we will record the parts in reverse order\n+      std::vector<std::pair<const uint8_t*, const uint8_t*>> parts;\n+      if (max_splits > -1) {\n+        parts.reserve(max_splits + 1);\n+      }\n+      while (max_splits != 0) {\n+        const uint8_t *separator_begin, *separator_end;\n+        // find with whatever algo the part we will 'cut out'\n+        if (Derived::FindReverse(begin, i, &separator_begin, &separator_end, options)) {\n+          parts.emplace_back(separator_end, i);\n+          i = separator_begin;\n+          max_splits--;\n+        } else {\n+          // if we cannot find a separator, we're done\n+          break;\n+        }\n+      }\n+      parts.emplace_back(begin, i);\n+      // now we do the copying\n+      for (auto it = parts.rbegin(); it != parts.rend(); ++it) {\n+        auto part = *it;\n+        // copy the string data\n+        for (auto j = part.first; j < part.second; j++) {\n+          *(*output_string_data)++ = *j;\n+          (*string_output_offset)++;\n+        }\n+        // write out the string entry (offset)\n+        *(*output_string_offsets)++ = *string_output_offset;\n+        (*string_output_count)++;\n+      }\n+    } else {\n+      const uint8_t* i = begin;\n+      while (max_splits != 0) {\n+        const uint8_t *separator_begin, *separator_end;\n+        // find with whatever algo the part we will 'cut out'\n+        if (Derived::Find(i, end, &separator_begin, &separator_end, options)) {\n+          // copy the part till the beginning of the 'cut'\n+          while (i < separator_begin) {\n+            *(*output_string_data)++ = *i++;\n+            (*string_output_offset)++;\n+          }\n+          // 'finish' the string by writing the offset\n+          *(*output_string_offsets)++ = *string_output_offset;\n+          (*string_output_count)++;\n+          // jump of the part we cut out\n+          i = separator_end;\n+          max_splits--;\n+        } else {\n+          // if we cannot find a separator, we're done\n+          break;\n+        }\n+      }\n+      // copy bytes after the pattern\n+      while (i < end) {\n+        *(*output_string_data)++ = *i++;\n+        (*string_output_offset)++;\n+      }\n+      // and write out the trailing part (can be an empty string)\n+      *(*output_string_offsets)++ = *string_output_offset;\n+      (*string_output_count)++;\n+    }\n+  }\n+  static Status CheckOptions(const Options& options) { return Status::OK(); }\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();  // only needed for unicode\n+    Options options = State::Get(ctx);\n+    KERNEL_RETURN_IF_ERROR(ctx, Derived::CheckOptions(options));\n+\n+    if (batch[0].kind() == Datum::ARRAY) {\n+      const ArrayData& input = *batch[0].array();\n+      ArrayType input_boxed(batch[0].array());\n+      ArrayData* output_list_data = out->mutable_array();\n+\n+      offset_type input_nbytes = input_boxed.total_values_length();\n+      offset_type input_nstrings = static_cast<offset_type>(input.length);\n+\n+      offset_type output_nbytes_max = input_nbytes;\n+      int64_t output_nstrings_max = Derived::CalculateMaxSplits(input_boxed, options);\n+      if (output_nstrings_max > std::numeric_limits<offset_type>::max()) {\n+        ctx->SetStatus(\n+            Status::CapacityError(\"Result might not fit in a 32bit list or string array, \"\n+                                  \"convert to large_utf8\"));\n+        return;\n+      }\n+\n+      // Why is the offset buffer not preallocated?\n\nReview comment:\n       If so, can you open a JIRA so that this doesn't get lost?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -809,6 +809,475 @@ struct IsUpperAscii : CharacterPredicateAscii<IsUpperAscii> {\n   }\n };\n \n+// splitting\n+\n+template <typename Type, typename ListType, typename Options, typename Derived>\n+struct SplitBaseTransform {\n+  // TODO: assert offsets types are the same?\n+  using offset_type = typename Type::offset_type;\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using ArrayListType = typename TypeTraits<ListType>::ArrayType;\n+  using ListScalarType = typename TypeTraits<ListType>::ScalarType;\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  using Builder = typename TypeTraits<Type>::BuilderType;\n+  using State = OptionsWrapper<Options>;\n+\n+  static void Split(const uint8_t* input_string, offset_type input_string_nbytes,\n+                    offset_type** output_string_offsets, offset_type* string_output_count,\n+                    offset_type* string_output_offset, uint8_t** output_string_data,\n+                    const Options& options) {\n+    const uint8_t* begin = input_string;\n+    const uint8_t* end = begin + input_string_nbytes;\n+\n+    int64_t max_splits = options.max_splits;\n+    // if there is no max splits, reversing does not make sense (and is probably less\n+    // efficient), but is useful for testing\n+    if (options.reverse) {\n+      // note that i points 1 further than the 'current'\n+      const uint8_t* i = end;\n+      // we will record the parts in reverse order\n+      std::vector<std::pair<const uint8_t*, const uint8_t*>> parts;\n+      if (max_splits > -1) {\n+        parts.reserve(max_splits + 1);\n+      }\n+      while (max_splits != 0) {\n+        const uint8_t *separator_begin, *separator_end;\n+        // find with whatever algo the part we will 'cut out'\n+        if (Derived::FindReverse(begin, i, &separator_begin, &separator_end, options)) {\n+          parts.emplace_back(separator_end, i);\n+          i = separator_begin;\n+          max_splits--;\n+        } else {\n+          // if we cannot find a separator, we're done\n+          break;\n+        }\n+      }\n+      parts.emplace_back(begin, i);\n+      // now we do the copying\n+      for (auto it = parts.rbegin(); it != parts.rend(); ++it) {\n+        auto part = *it;\n+        // copy the string data\n+        for (auto j = part.first; j < part.second; j++) {\n+          *(*output_string_data)++ = *j;\n+          (*string_output_offset)++;\n+        }\n+        // write out the string entry (offset)\n+        *(*output_string_offsets)++ = *string_output_offset;\n+        (*string_output_count)++;\n+      }\n+    } else {\n+      const uint8_t* i = begin;\n+      while (max_splits != 0) {\n+        const uint8_t *separator_begin, *separator_end;\n+        // find with whatever algo the part we will 'cut out'\n+        if (Derived::Find(i, end, &separator_begin, &separator_end, options)) {\n+          // copy the part till the beginning of the 'cut'\n+          while (i < separator_begin) {\n+            *(*output_string_data)++ = *i++;\n+            (*string_output_offset)++;\n+          }\n+          // 'finish' the string by writing the offset\n+          *(*output_string_offsets)++ = *string_output_offset;\n+          (*string_output_count)++;\n+          // jump of the part we cut out\n+          i = separator_end;\n+          max_splits--;\n+        } else {\n+          // if we cannot find a separator, we're done\n+          break;\n+        }\n+      }\n+      // copy bytes after the pattern\n+      while (i < end) {\n+        *(*output_string_data)++ = *i++;\n+        (*string_output_offset)++;\n+      }\n+      // and write out the trailing part (can be an empty string)\n+      *(*output_string_offsets)++ = *string_output_offset;\n+      (*string_output_count)++;\n+    }\n+  }\n+  static Status CheckOptions(const Options& options) { return Status::OK(); }\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();  // only needed for unicode\n+    Options options = State::Get(ctx);\n+    KERNEL_RETURN_IF_ERROR(ctx, Derived::CheckOptions(options));\n+\n+    if (batch[0].kind() == Datum::ARRAY) {\n+      const ArrayData& input = *batch[0].array();\n+      ArrayType input_boxed(batch[0].array());\n+      ArrayData* output_list_data = out->mutable_array();\n+\n+      offset_type input_nbytes = input_boxed.total_values_length();\n+      offset_type input_nstrings = static_cast<offset_type>(input.length);\n+\n+      offset_type output_nbytes_max = input_nbytes;\n+      int64_t output_nstrings_max = Derived::CalculateMaxSplits(input_boxed, options);\n+      if (output_nstrings_max > std::numeric_limits<offset_type>::max()) {\n+        ctx->SetStatus(\n+            Status::CapacityError(\"Result might not fit in a 32bit list or string array, \"\n+                                  \"convert to large_utf8\"));\n+        return;\n+      }\n+\n+      // Why is the offset buffer not preallocated?\n\nReview comment:\n       Well, it depends. Did you declare a scalar kernel?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-30T14:46:31.238+0000",
                    "updated": "2020-09-30T14:46:31.238+0000",
                    "started": "2020-09-30T14:46:31.238+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "492997",
                    "issueId": "13327372"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372/worklog/492998",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8271:\nURL: https://github.com/apache/arrow/pull/8271#discussion_r497570569\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -809,6 +809,475 @@ struct IsUpperAscii : CharacterPredicateAscii<IsUpperAscii> {\n   }\n };\n \n+// splitting\n+\n+template <typename Type, typename ListType, typename Options, typename Derived>\n+struct SplitBaseTransform {\n+  // TODO: assert offsets types are the same?\n+  using offset_type = typename Type::offset_type;\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using ArrayListType = typename TypeTraits<ListType>::ArrayType;\n+  using ListScalarType = typename TypeTraits<ListType>::ScalarType;\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  using Builder = typename TypeTraits<Type>::BuilderType;\n+  using State = OptionsWrapper<Options>;\n+\n+  static void Split(const uint8_t* input_string, offset_type input_string_nbytes,\n+                    offset_type** output_string_offsets, offset_type* string_output_count,\n+                    offset_type* string_output_offset, uint8_t** output_string_data,\n+                    const Options& options) {\n+    const uint8_t* begin = input_string;\n+    const uint8_t* end = begin + input_string_nbytes;\n+\n+    int64_t max_splits = options.max_splits;\n+    // if there is no max splits, reversing does not make sense (and is probably less\n+    // efficient), but is useful for testing\n+    if (options.reverse) {\n+      // note that i points 1 further than the 'current'\n+      const uint8_t* i = end;\n+      // we will record the parts in reverse order\n+      std::vector<std::pair<const uint8_t*, const uint8_t*>> parts;\n\nReview comment:\n       I'll also note it's a pity to allocate a `vector` dynamically for each input string. Perhaps you can store this scratch space on the instance instead?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-30T14:47:45.112+0000",
                    "updated": "2020-09-30T14:47:45.112+0000",
                    "started": "2020-09-30T14:47:45.112+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "492998",
                    "issueId": "13327372"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372/worklog/495770",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels commented on a change in pull request #8271:\nURL: https://github.com/apache/arrow/pull/8271#discussion_r500071766\n\n\n\n##########\nFile path: python/pyarrow/compute.py\n##########\n@@ -253,6 +255,68 @@ def match_substring(array, pattern):\n                          MatchSubstringOptions(pattern))\n \n \n+def split_pattern(array, pattern, max_splits=-1, reverse=False):\n+    \"\"\"\n+    Replace string by a list of strings, separated by *pattern*.\n+\n+    Parameters\n+    ----------\n+    array : pyarrow.Array or pyarrow.ChunkedArray\n+    pattern : str\n+        pattern to split by\n+    max_splits : int\n+        If not -1, the maximum number of splits.\n+    reverse : bool\n+        Start splitting from the right, only meaningful when max_splits != -1\n+\n+    Returns\n+    -------\n+    result : pyarrow.Array or pyarrow.ChunkedArray\n+    \"\"\"\n+    return call_function(\"split_pattern\", [array],\n+                         SplitPatternOptions(pattern, max_splits, reverse))\n\nReview comment:\n       I can take a look, I think it makes sense to add this indeed.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-06T07:47:55.651+0000",
                    "updated": "2020-10-06T07:47:55.651+0000",
                    "started": "2020-10-06T07:47:55.650+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "495770",
                    "issueId": "13327372"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372/worklog/495777",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels commented on a change in pull request #8271:\nURL: https://github.com/apache/arrow/pull/8271#discussion_r500084727\n\n\n\n##########\nFile path: python/pyarrow/compute.py\n##########\n@@ -253,6 +255,68 @@ def match_substring(array, pattern):\n                          MatchSubstringOptions(pattern))\n \n \n+def split_pattern(array, pattern, max_splits=-1, reverse=False):\n\nReview comment:\n       I see that changed in #8163, nice work. But that would make the API less friendly, having to pass in the options, instead of having an argument with default parameters. If you are strongly in favor of this, I'm ok with it, I'm not sure how 'user friendly' the arrow API needs to be.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-06T08:10:03.114+0000",
                    "updated": "2020-10-06T08:10:03.114+0000",
                    "started": "2020-10-06T08:10:03.114+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "495777",
                    "issueId": "13327372"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372/worklog/495880",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels commented on a change in pull request #8271:\nURL: https://github.com/apache/arrow/pull/8271#discussion_r500243584\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string_test.cc\n##########\n@@ -53,8 +53,19 @@ class BaseTestStringKernels : public ::testing::Test {\n   std::shared_ptr<DataType> offset_type() {\n     return TypeTraits<OffsetType>::type_singleton();\n   }\n+  std::shared_ptr<DataType> list_type();\n };\n \n+template <>\n+std::shared_ptr<DataType> BaseTestStringKernels<LargeStringType>::list_type() {\n+  return large_list(this->type());\n\nReview comment:\n       because it may have a lot of elements, leading to a long list. But you are right, all cases are possible, e.g. a large string with just a few really large elements, or a normal string that will split into more elements.\r\n   Any idea what to do? this made the most sense to me.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-06T12:42:58.667+0000",
                    "updated": "2020-10-06T12:42:58.667+0000",
                    "started": "2020-10-06T12:42:58.667+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "495880",
                    "issueId": "13327372"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372/worklog/495890",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8271:\nURL: https://github.com/apache/arrow/pull/8271#discussion_r500265136\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string_test.cc\n##########\n@@ -53,8 +53,19 @@ class BaseTestStringKernels : public ::testing::Test {\n   std::shared_ptr<DataType> offset_type() {\n     return TypeTraits<OffsetType>::type_singleton();\n   }\n+  std::shared_ptr<DataType> list_type();\n };\n \n+template <>\n+std::shared_ptr<DataType> BaseTestStringKernels<LargeStringType>::list_type() {\n+  return large_list(this->type());\n\nReview comment:\n       I think this is overkill for now. Let's just always return a regular list. Large lists will have a sizeable overhead, especially with many small splits.\r\n   If there's a user request for it, we may later add an option to return a large list instead.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-06T13:14:28.515+0000",
                    "updated": "2020-10-06T13:14:28.515+0000",
                    "started": "2020-10-06T13:14:28.515+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "495890",
                    "issueId": "13327372"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372/worklog/495892",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8271:\nURL: https://github.com/apache/arrow/pull/8271#discussion_r500266219\n\n\n\n##########\nFile path: python/pyarrow/compute.py\n##########\n@@ -253,6 +255,68 @@ def match_substring(array, pattern):\n                          MatchSubstringOptions(pattern))\n \n \n+def split_pattern(array, pattern, max_splits=-1, reverse=False):\n\nReview comment:\n       No, it should work with direct keyword arguments. See https://github.com/apache/arrow/blob/master/python/pyarrow/tests/test_compute.py#L233-L260 for a test.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-06T13:15:52.559+0000",
                    "updated": "2020-10-06T13:15:52.559+0000",
                    "started": "2020-10-06T13:15:52.558+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "495892",
                    "issueId": "13327372"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372/worklog/495893",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8271:\nURL: https://github.com/apache/arrow/pull/8271#discussion_r500268258\n\n\n\n##########\nFile path: python/pyarrow/compute.py\n##########\n@@ -253,6 +255,68 @@ def match_substring(array, pattern):\n                          MatchSubstringOptions(pattern))\n \n \n+def split_pattern(array, pattern, max_splits=-1, reverse=False):\n\nReview comment:\n       It's true that the docstring is a bit suboptimal still. Hopefully we can improve that in the future:\r\n   ```\r\n   >>> pc.min_max?\r\n   Signature: pc.min_max(arg, *, options=None, memory_pool=None, **kwargs)\r\n   Docstring:\r\n   Call compute function 'min_max' with the given argument.\r\n   \r\n   Parameters\r\n   ----------\r\n   arg : Array-like or scalar-like\r\n       Argument to compute function\r\n   memory_pool : pyarrow.MemoryPool, optional\r\n       If not passed, will allocate memory from the default memory pool.\r\n   options : pyarrow.compute.MinMaxOptions, optional\r\n       Parameters altering compute function semantics\r\n   **kwargs: optional\r\n       Parameters for MinMaxOptions constructor.  Either `options`\r\n       or `**kwargs` can be passed, but not both at the same time.\r\n   ```\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-06T13:18:48.957+0000",
                    "updated": "2020-10-06T13:18:48.957+0000",
                    "started": "2020-10-06T13:18:48.957+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "495893",
                    "issueId": "13327372"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372/worklog/495900",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels commented on a change in pull request #8271:\nURL: https://github.com/apache/arrow/pull/8271#discussion_r500275273\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -809,6 +809,475 @@ struct IsUpperAscii : CharacterPredicateAscii<IsUpperAscii> {\n   }\n };\n \n+// splitting\n+\n+template <typename Type, typename ListType, typename Options, typename Derived>\n+struct SplitBaseTransform {\n+  // TODO: assert offsets types are the same?\n+  using offset_type = typename Type::offset_type;\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using ArrayListType = typename TypeTraits<ListType>::ArrayType;\n+  using ListScalarType = typename TypeTraits<ListType>::ScalarType;\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  using Builder = typename TypeTraits<Type>::BuilderType;\n+  using State = OptionsWrapper<Options>;\n+\n+  static void Split(const uint8_t* input_string, offset_type input_string_nbytes,\n+                    offset_type** output_string_offsets, offset_type* string_output_count,\n+                    offset_type* string_output_offset, uint8_t** output_string_data,\n+                    const Options& options) {\n+    const uint8_t* begin = input_string;\n+    const uint8_t* end = begin + input_string_nbytes;\n+\n+    int64_t max_splits = options.max_splits;\n+    // if there is no max splits, reversing does not make sense (and is probably less\n+    // efficient), but is useful for testing\n+    if (options.reverse) {\n+      // note that i points 1 further than the 'current'\n+      const uint8_t* i = end;\n+      // we will record the parts in reverse order\n+      std::vector<std::pair<const uint8_t*, const uint8_t*>> parts;\n+      if (max_splits > -1) {\n+        parts.reserve(max_splits + 1);\n+      }\n+      while (max_splits != 0) {\n+        const uint8_t *separator_begin, *separator_end;\n+        // find with whatever algo the part we will 'cut out'\n+        if (Derived::FindReverse(begin, i, &separator_begin, &separator_end, options)) {\n+          parts.emplace_back(separator_end, i);\n+          i = separator_begin;\n+          max_splits--;\n+        } else {\n+          // if we cannot find a separator, we're done\n+          break;\n+        }\n+      }\n+      parts.emplace_back(begin, i);\n+      // now we do the copying\n+      for (auto it = parts.rbegin(); it != parts.rend(); ++it) {\n+        auto part = *it;\n+        // copy the string data\n+        for (auto j = part.first; j < part.second; j++) {\n+          *(*output_string_data)++ = *j;\n+          (*string_output_offset)++;\n+        }\n+        // write out the string entry (offset)\n+        *(*output_string_offsets)++ = *string_output_offset;\n+        (*string_output_count)++;\n+      }\n+    } else {\n+      const uint8_t* i = begin;\n+      while (max_splits != 0) {\n+        const uint8_t *separator_begin, *separator_end;\n+        // find with whatever algo the part we will 'cut out'\n+        if (Derived::Find(i, end, &separator_begin, &separator_end, options)) {\n+          // copy the part till the beginning of the 'cut'\n+          while (i < separator_begin) {\n+            *(*output_string_data)++ = *i++;\n+            (*string_output_offset)++;\n+          }\n+          // 'finish' the string by writing the offset\n+          *(*output_string_offsets)++ = *string_output_offset;\n+          (*string_output_count)++;\n+          // jump of the part we cut out\n+          i = separator_end;\n+          max_splits--;\n+        } else {\n+          // if we cannot find a separator, we're done\n+          break;\n+        }\n+      }\n+      // copy bytes after the pattern\n+      while (i < end) {\n+        *(*output_string_data)++ = *i++;\n+        (*string_output_offset)++;\n+      }\n+      // and write out the trailing part (can be an empty string)\n+      *(*output_string_offsets)++ = *string_output_offset;\n+      (*string_output_count)++;\n+    }\n+  }\n+  static Status CheckOptions(const Options& options) { return Status::OK(); }\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();  // only needed for unicode\n+    Options options = State::Get(ctx);\n+    KERNEL_RETURN_IF_ERROR(ctx, Derived::CheckOptions(options));\n+\n+    if (batch[0].kind() == Datum::ARRAY) {\n+      const ArrayData& input = *batch[0].array();\n+      ArrayType input_boxed(batch[0].array());\n+      ArrayData* output_list_data = out->mutable_array();\n+\n+      offset_type input_nbytes = input_boxed.total_values_length();\n+      offset_type input_nstrings = static_cast<offset_type>(input.length);\n+\n+      offset_type output_nbytes_max = input_nbytes;\n+      int64_t output_nstrings_max = Derived::CalculateMaxSplits(input_boxed, options);\n+      if (output_nstrings_max > std::numeric_limits<offset_type>::max()) {\n+        ctx->SetStatus(\n+            Status::CapacityError(\"Result might not fit in a 32bit list or string array, \"\n+                                  \"convert to large_utf8\"));\n+        return;\n+      }\n+\n+      // Why is the offset buffer not preallocated?\n+      KERNEL_ASSIGN_OR_RAISE(output_list_data->buffers[1], ctx,\n+                             ctx->Allocate((input_nstrings + 1) * sizeof(offset_type)));\n+      offset_type* output_list_offsets =\n+          output_list_data->GetMutableValues<offset_type>(1);\n+\n+      // allocate output string array data\n+      // this is a bit low level, should we use a builder?\n+      KERNEL_ASSIGN_OR_RAISE(auto buffer_output_string_data, ctx,\n+                             ctx->Allocate((output_nbytes_max)));\n+      KERNEL_ASSIGN_OR_RAISE(auto buffer_output_string_offsets, ctx,\n+                             ctx->Allocate(output_nstrings_max * sizeof(offset_type)));\n+\n+      offset_type* output_string_offsets =\n+          reinterpret_cast<offset_type*>(buffer_output_string_offsets->mutable_data());\n+      uint8_t* output_string_data = buffer_output_string_data->mutable_data();\n+      // TypedBufferBuilder<bool> null_builder;  // TODO: should we pass a mem poool?\n+      // KERNEL_RETURN_IF_ERROR(ctx, null_builder.Reserve(output_nstrings_max));\n\nReview comment:\n       This was related to the issue related to the test that is commented out (and described in the opening post). Reading @jorisvandenbossche explanation I think I did it correctly, and this code can be ignored. I think there is an issue with equality testing and null values in lists (as described above).\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-06T13:28:10.700+0000",
                    "updated": "2020-10-06T13:28:10.700+0000",
                    "started": "2020-10-06T13:28:10.700+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "495900",
                    "issueId": "13327372"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372/worklog/495903",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8271:\nURL: https://github.com/apache/arrow/pull/8271#discussion_r500282031\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -809,6 +809,475 @@ struct IsUpperAscii : CharacterPredicateAscii<IsUpperAscii> {\n   }\n };\n \n+// splitting\n+\n+template <typename Type, typename ListType, typename Options, typename Derived>\n+struct SplitBaseTransform {\n+  // TODO: assert offsets types are the same?\n+  using offset_type = typename Type::offset_type;\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using ArrayListType = typename TypeTraits<ListType>::ArrayType;\n+  using ListScalarType = typename TypeTraits<ListType>::ScalarType;\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  using Builder = typename TypeTraits<Type>::BuilderType;\n+  using State = OptionsWrapper<Options>;\n+\n+  static void Split(const uint8_t* input_string, offset_type input_string_nbytes,\n+                    offset_type** output_string_offsets, offset_type* string_output_count,\n+                    offset_type* string_output_offset, uint8_t** output_string_data,\n+                    const Options& options) {\n+    const uint8_t* begin = input_string;\n+    const uint8_t* end = begin + input_string_nbytes;\n+\n+    int64_t max_splits = options.max_splits;\n+    // if there is no max splits, reversing does not make sense (and is probably less\n+    // efficient), but is useful for testing\n+    if (options.reverse) {\n+      // note that i points 1 further than the 'current'\n+      const uint8_t* i = end;\n+      // we will record the parts in reverse order\n+      std::vector<std::pair<const uint8_t*, const uint8_t*>> parts;\n+      if (max_splits > -1) {\n+        parts.reserve(max_splits + 1);\n+      }\n+      while (max_splits != 0) {\n+        const uint8_t *separator_begin, *separator_end;\n+        // find with whatever algo the part we will 'cut out'\n+        if (Derived::FindReverse(begin, i, &separator_begin, &separator_end, options)) {\n+          parts.emplace_back(separator_end, i);\n+          i = separator_begin;\n+          max_splits--;\n+        } else {\n+          // if we cannot find a separator, we're done\n+          break;\n+        }\n+      }\n+      parts.emplace_back(begin, i);\n+      // now we do the copying\n+      for (auto it = parts.rbegin(); it != parts.rend(); ++it) {\n+        auto part = *it;\n+        // copy the string data\n+        for (auto j = part.first; j < part.second; j++) {\n+          *(*output_string_data)++ = *j;\n+          (*string_output_offset)++;\n+        }\n+        // write out the string entry (offset)\n+        *(*output_string_offsets)++ = *string_output_offset;\n+        (*string_output_count)++;\n+      }\n+    } else {\n+      const uint8_t* i = begin;\n+      while (max_splits != 0) {\n+        const uint8_t *separator_begin, *separator_end;\n+        // find with whatever algo the part we will 'cut out'\n+        if (Derived::Find(i, end, &separator_begin, &separator_end, options)) {\n+          // copy the part till the beginning of the 'cut'\n+          while (i < separator_begin) {\n+            *(*output_string_data)++ = *i++;\n+            (*string_output_offset)++;\n+          }\n+          // 'finish' the string by writing the offset\n+          *(*output_string_offsets)++ = *string_output_offset;\n+          (*string_output_count)++;\n+          // jump of the part we cut out\n+          i = separator_end;\n+          max_splits--;\n+        } else {\n+          // if we cannot find a separator, we're done\n+          break;\n+        }\n+      }\n+      // copy bytes after the pattern\n+      while (i < end) {\n+        *(*output_string_data)++ = *i++;\n+        (*string_output_offset)++;\n+      }\n+      // and write out the trailing part (can be an empty string)\n+      *(*output_string_offsets)++ = *string_output_offset;\n+      (*string_output_count)++;\n+    }\n+  }\n+  static Status CheckOptions(const Options& options) { return Status::OK(); }\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();  // only needed for unicode\n+    Options options = State::Get(ctx);\n+    KERNEL_RETURN_IF_ERROR(ctx, Derived::CheckOptions(options));\n+\n+    if (batch[0].kind() == Datum::ARRAY) {\n+      const ArrayData& input = *batch[0].array();\n+      ArrayType input_boxed(batch[0].array());\n+      ArrayData* output_list_data = out->mutable_array();\n+\n+      offset_type input_nbytes = input_boxed.total_values_length();\n+      offset_type input_nstrings = static_cast<offset_type>(input.length);\n+\n+      offset_type output_nbytes_max = input_nbytes;\n+      int64_t output_nstrings_max = Derived::CalculateMaxSplits(input_boxed, options);\n+      if (output_nstrings_max > std::numeric_limits<offset_type>::max()) {\n+        ctx->SetStatus(\n+            Status::CapacityError(\"Result might not fit in a 32bit list or string array, \"\n+                                  \"convert to large_utf8\"));\n+        return;\n+      }\n+\n+      // Why is the offset buffer not preallocated?\n+      KERNEL_ASSIGN_OR_RAISE(output_list_data->buffers[1], ctx,\n+                             ctx->Allocate((input_nstrings + 1) * sizeof(offset_type)));\n+      offset_type* output_list_offsets =\n+          output_list_data->GetMutableValues<offset_type>(1);\n+\n+      // allocate output string array data\n+      // this is a bit low level, should we use a builder?\n+      KERNEL_ASSIGN_OR_RAISE(auto buffer_output_string_data, ctx,\n+                             ctx->Allocate((output_nbytes_max)));\n+      KERNEL_ASSIGN_OR_RAISE(auto buffer_output_string_offsets, ctx,\n+                             ctx->Allocate(output_nstrings_max * sizeof(offset_type)));\n+\n+      offset_type* output_string_offsets =\n+          reinterpret_cast<offset_type*>(buffer_output_string_offsets->mutable_data());\n+      uint8_t* output_string_data = buffer_output_string_data->mutable_data();\n+      // TypedBufferBuilder<bool> null_builder;  // TODO: should we pass a mem poool?\n+      // KERNEL_RETURN_IF_ERROR(ctx, null_builder.Reserve(output_nstrings_max));\n\nReview comment:\n       If there is such an issue, it would be good to open a dedicated JIRA with a reproducer. Let's not bury this in the comments of a string compute PR :-)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-06T13:35:56.593+0000",
                    "updated": "2020-10-06T13:35:56.593+0000",
                    "started": "2020-10-06T13:35:56.593+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "495903",
                    "issueId": "13327372"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372/worklog/496410",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels commented on a change in pull request #8271:\nURL: https://github.com/apache/arrow/pull/8271#discussion_r500867702\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -809,6 +809,475 @@ struct IsUpperAscii : CharacterPredicateAscii<IsUpperAscii> {\n   }\n };\n \n+// splitting\n+\n+template <typename Type, typename ListType, typename Options, typename Derived>\n+struct SplitBaseTransform {\n+  // TODO: assert offsets types are the same?\n+  using offset_type = typename Type::offset_type;\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using ArrayListType = typename TypeTraits<ListType>::ArrayType;\n+  using ListScalarType = typename TypeTraits<ListType>::ScalarType;\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  using Builder = typename TypeTraits<Type>::BuilderType;\n+  using State = OptionsWrapper<Options>;\n+\n+  static void Split(const uint8_t* input_string, offset_type input_string_nbytes,\n+                    offset_type** output_string_offsets, offset_type* string_output_count,\n+                    offset_type* string_output_offset, uint8_t** output_string_data,\n+                    const Options& options) {\n+    const uint8_t* begin = input_string;\n+    const uint8_t* end = begin + input_string_nbytes;\n+\n+    int64_t max_splits = options.max_splits;\n+    // if there is no max splits, reversing does not make sense (and is probably less\n+    // efficient), but is useful for testing\n+    if (options.reverse) {\n+      // note that i points 1 further than the 'current'\n+      const uint8_t* i = end;\n+      // we will record the parts in reverse order\n+      std::vector<std::pair<const uint8_t*, const uint8_t*>> parts;\n+      if (max_splits > -1) {\n+        parts.reserve(max_splits + 1);\n+      }\n+      while (max_splits != 0) {\n+        const uint8_t *separator_begin, *separator_end;\n+        // find with whatever algo the part we will 'cut out'\n+        if (Derived::FindReverse(begin, i, &separator_begin, &separator_end, options)) {\n+          parts.emplace_back(separator_end, i);\n+          i = separator_begin;\n+          max_splits--;\n+        } else {\n+          // if we cannot find a separator, we're done\n+          break;\n+        }\n+      }\n+      parts.emplace_back(begin, i);\n+      // now we do the copying\n+      for (auto it = parts.rbegin(); it != parts.rend(); ++it) {\n+        auto part = *it;\n+        // copy the string data\n+        for (auto j = part.first; j < part.second; j++) {\n+          *(*output_string_data)++ = *j;\n+          (*string_output_offset)++;\n+        }\n+        // write out the string entry (offset)\n+        *(*output_string_offsets)++ = *string_output_offset;\n+        (*string_output_count)++;\n+      }\n+    } else {\n+      const uint8_t* i = begin;\n+      while (max_splits != 0) {\n+        const uint8_t *separator_begin, *separator_end;\n+        // find with whatever algo the part we will 'cut out'\n+        if (Derived::Find(i, end, &separator_begin, &separator_end, options)) {\n+          // copy the part till the beginning of the 'cut'\n+          while (i < separator_begin) {\n+            *(*output_string_data)++ = *i++;\n+            (*string_output_offset)++;\n+          }\n+          // 'finish' the string by writing the offset\n+          *(*output_string_offsets)++ = *string_output_offset;\n+          (*string_output_count)++;\n+          // jump of the part we cut out\n+          i = separator_end;\n+          max_splits--;\n+        } else {\n+          // if we cannot find a separator, we're done\n+          break;\n+        }\n+      }\n+      // copy bytes after the pattern\n+      while (i < end) {\n+        *(*output_string_data)++ = *i++;\n+        (*string_output_offset)++;\n+      }\n+      // and write out the trailing part (can be an empty string)\n+      *(*output_string_offsets)++ = *string_output_offset;\n+      (*string_output_count)++;\n+    }\n+  }\n+  static Status CheckOptions(const Options& options) { return Status::OK(); }\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();  // only needed for unicode\n+    Options options = State::Get(ctx);\n+    KERNEL_RETURN_IF_ERROR(ctx, Derived::CheckOptions(options));\n+\n+    if (batch[0].kind() == Datum::ARRAY) {\n+      const ArrayData& input = *batch[0].array();\n+      ArrayType input_boxed(batch[0].array());\n+      ArrayData* output_list_data = out->mutable_array();\n+\n+      offset_type input_nbytes = input_boxed.total_values_length();\n+      offset_type input_nstrings = static_cast<offset_type>(input.length);\n+\n+      offset_type output_nbytes_max = input_nbytes;\n+      int64_t output_nstrings_max = Derived::CalculateMaxSplits(input_boxed, options);\n+      if (output_nstrings_max > std::numeric_limits<offset_type>::max()) {\n+        ctx->SetStatus(\n+            Status::CapacityError(\"Result might not fit in a 32bit list or string array, \"\n+                                  \"convert to large_utf8\"));\n+        return;\n+      }\n+\n+      // Why is the offset buffer not preallocated?\n+      KERNEL_ASSIGN_OR_RAISE(output_list_data->buffers[1], ctx,\n+                             ctx->Allocate((input_nstrings + 1) * sizeof(offset_type)));\n+      offset_type* output_list_offsets =\n+          output_list_data->GetMutableValues<offset_type>(1);\n+\n+      // allocate output string array data\n+      // this is a bit low level, should we use a builder?\n+      KERNEL_ASSIGN_OR_RAISE(auto buffer_output_string_data, ctx,\n+                             ctx->Allocate((output_nbytes_max)));\n+      KERNEL_ASSIGN_OR_RAISE(auto buffer_output_string_offsets, ctx,\n+                             ctx->Allocate(output_nstrings_max * sizeof(offset_type)));\n+\n+      offset_type* output_string_offsets =\n+          reinterpret_cast<offset_type*>(buffer_output_string_offsets->mutable_data());\n+      uint8_t* output_string_data = buffer_output_string_data->mutable_data();\n+      // TypedBufferBuilder<bool> null_builder;  // TODO: should we pass a mem poool?\n+      // KERNEL_RETURN_IF_ERROR(ctx, null_builder.Reserve(output_nstrings_max));\n\nReview comment:\n       done https://issues.apache.org/jira/browse/ARROW-10208\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-07T09:26:22.765+0000",
                    "updated": "2020-10-07T09:26:22.765+0000",
                    "started": "2020-10-07T09:26:22.765+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "496410",
                    "issueId": "13327372"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372/worklog/496412",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels commented on a change in pull request #8271:\nURL: https://github.com/apache/arrow/pull/8271#discussion_r500868020\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -809,6 +809,475 @@ struct IsUpperAscii : CharacterPredicateAscii<IsUpperAscii> {\n   }\n };\n \n+// splitting\n+\n+template <typename Type, typename ListType, typename Options, typename Derived>\n+struct SplitBaseTransform {\n+  // TODO: assert offsets types are the same?\n+  using offset_type = typename Type::offset_type;\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using ArrayListType = typename TypeTraits<ListType>::ArrayType;\n+  using ListScalarType = typename TypeTraits<ListType>::ScalarType;\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  using Builder = typename TypeTraits<Type>::BuilderType;\n+  using State = OptionsWrapper<Options>;\n+\n+  static void Split(const uint8_t* input_string, offset_type input_string_nbytes,\n+                    offset_type** output_string_offsets, offset_type* string_output_count,\n+                    offset_type* string_output_offset, uint8_t** output_string_data,\n+                    const Options& options) {\n+    const uint8_t* begin = input_string;\n+    const uint8_t* end = begin + input_string_nbytes;\n+\n+    int64_t max_splits = options.max_splits;\n+    // if there is no max splits, reversing does not make sense (and is probably less\n+    // efficient), but is useful for testing\n+    if (options.reverse) {\n+      // note that i points 1 further than the 'current'\n+      const uint8_t* i = end;\n+      // we will record the parts in reverse order\n+      std::vector<std::pair<const uint8_t*, const uint8_t*>> parts;\n+      if (max_splits > -1) {\n+        parts.reserve(max_splits + 1);\n+      }\n+      while (max_splits != 0) {\n+        const uint8_t *separator_begin, *separator_end;\n+        // find with whatever algo the part we will 'cut out'\n+        if (Derived::FindReverse(begin, i, &separator_begin, &separator_end, options)) {\n+          parts.emplace_back(separator_end, i);\n+          i = separator_begin;\n+          max_splits--;\n+        } else {\n+          // if we cannot find a separator, we're done\n+          break;\n+        }\n+      }\n+      parts.emplace_back(begin, i);\n+      // now we do the copying\n+      for (auto it = parts.rbegin(); it != parts.rend(); ++it) {\n+        auto part = *it;\n+        // copy the string data\n+        for (auto j = part.first; j < part.second; j++) {\n+          *(*output_string_data)++ = *j;\n+          (*string_output_offset)++;\n+        }\n+        // write out the string entry (offset)\n+        *(*output_string_offsets)++ = *string_output_offset;\n+        (*string_output_count)++;\n+      }\n+    } else {\n+      const uint8_t* i = begin;\n+      while (max_splits != 0) {\n+        const uint8_t *separator_begin, *separator_end;\n+        // find with whatever algo the part we will 'cut out'\n+        if (Derived::Find(i, end, &separator_begin, &separator_end, options)) {\n+          // copy the part till the beginning of the 'cut'\n+          while (i < separator_begin) {\n+            *(*output_string_data)++ = *i++;\n+            (*string_output_offset)++;\n+          }\n+          // 'finish' the string by writing the offset\n+          *(*output_string_offsets)++ = *string_output_offset;\n+          (*string_output_count)++;\n+          // jump of the part we cut out\n+          i = separator_end;\n+          max_splits--;\n+        } else {\n+          // if we cannot find a separator, we're done\n+          break;\n+        }\n+      }\n+      // copy bytes after the pattern\n+      while (i < end) {\n+        *(*output_string_data)++ = *i++;\n+        (*string_output_offset)++;\n+      }\n+      // and write out the trailing part (can be an empty string)\n+      *(*output_string_offsets)++ = *string_output_offset;\n+      (*string_output_count)++;\n+    }\n+  }\n+  static Status CheckOptions(const Options& options) { return Status::OK(); }\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();  // only needed for unicode\n+    Options options = State::Get(ctx);\n+    KERNEL_RETURN_IF_ERROR(ctx, Derived::CheckOptions(options));\n+\n+    if (batch[0].kind() == Datum::ARRAY) {\n+      const ArrayData& input = *batch[0].array();\n+      ArrayType input_boxed(batch[0].array());\n+      ArrayData* output_list_data = out->mutable_array();\n+\n+      offset_type input_nbytes = input_boxed.total_values_length();\n+      offset_type input_nstrings = static_cast<offset_type>(input.length);\n+\n+      offset_type output_nbytes_max = input_nbytes;\n+      int64_t output_nstrings_max = Derived::CalculateMaxSplits(input_boxed, options);\n+      if (output_nstrings_max > std::numeric_limits<offset_type>::max()) {\n+        ctx->SetStatus(\n+            Status::CapacityError(\"Result might not fit in a 32bit list or string array, \"\n+                                  \"convert to large_utf8\"));\n+        return;\n+      }\n+\n+      // Why is the offset buffer not preallocated?\n\nReview comment:\n       done https://issues.apache.org/jira/browse/ARROW-10207\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-07T09:26:58.963+0000",
                    "updated": "2020-10-07T09:26:58.963+0000",
                    "started": "2020-10-07T09:26:58.963+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "496412",
                    "issueId": "13327372"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372/worklog/496417",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels commented on a change in pull request #8271:\nURL: https://github.com/apache/arrow/pull/8271#discussion_r500873548\n\n\n\n##########\nFile path: python/pyarrow/_compute.pyx\n##########\n@@ -560,6 +560,29 @@ cdef class MatchSubstringOptions(FunctionOptions):\n         return self.match_substring_options.get()\n \n \n+cdef class SplitOptions(FunctionOptions):\n+    cdef:\n+        unique_ptr[CSplitOptions] split_options\n+\n+    def __init__(self, max_splits, reverse):\n+        self.split_options.reset(\n+            new CSplitOptions(max_splits, reverse))\n+\n+    cdef const CFunctionOptions* get_options(self) except NULL:\n+        return self.split_options.get()\n+\n+\n+cdef class SplitPatternOptions(FunctionOptions):\n+    cdef:\n+        unique_ptr[CSplitPatternOptions] split_pattern_options\n+\n+    def __init__(self, pattern, max_splits, reverse):\n\nReview comment:\n       Yes, that would be nicer, but *args is not passed in the auto compute wrapper. Also, https://github.com/apache/arrow/blob/master/python/pyarrow/tests/test_compute.py#L68 would fail.\r\n   \r\n   However, given @jorisvandenbossche comment about having pattern an array/scalar (i.e. making the kernel binary) would remove the issue.\r\n   \r\n   I make it `*, pattern` now, with the downside of having to write ` pc.utf8_split_whitespace(arr, options={})` instead of no arguments.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-07T09:35:43.715+0000",
                    "updated": "2020-10-07T09:35:43.715+0000",
                    "started": "2020-10-07T09:35:43.715+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "496417",
                    "issueId": "13327372"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 28200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@5f8419b5[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@66a8c307[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@e32d95[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@20f37675[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@cc704c5[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@5d1011a4[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@44061016[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@7ffd963d[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4b28542b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@1668f1db[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@621ac5a0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@71c5fba0[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 28200,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Oct 19 14:33:17 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-10-19T14:33:16.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9991/watchers",
            "watchCount": 5,
            "isWatching": false
        },
        "created": "2020-09-14T07:46:19.000+0000",
        "updated": "2021-05-10T13:43:25.000+0000",
        "timeoriginalestimate": null,
        "description": "Similar to Python str.split and bytes.split, we'd like to have a way to convert str into list[str] (and similarly for bytes).\r\n\r\nWhen the separator is given, the algorithms for both types are the same. Python, however, overloads strip. When given no separator, the algorithm will split considering all whitespace (unicode for str, ascii for bytes)\u00a0as separator.\r\n\r\nI'd rather see not too much overloaded kernels, e.g.\r\n\r\nbinary_split (takes string/binary separator, and maxsplit arg, no special utf8 version needed)\r\n\r\nutf8_split_whitespace (similar to Python's version given no separator)\r\n\r\nascii_split_whitespace (similar to Python's version given no separator, but considering ascii, although this could work on any binary data)\r\n\r\nthere can also be rsplit versions of these, or they could be an argument.\r\n\r\n\u00a0",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "7h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 28200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] split kernels for strings/binary",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372/comment/17195508",
                    "id": "17195508",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "body": "And I suppose \"whitespace\" here is more than a split on \" \" ? (also multiple spaces, different kinds of newlines, tabs, etc?) In that case, a separate specialized kernel seems indeed best. ",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "created": "2020-09-14T14:55:45.795+0000",
                    "updated": "2020-09-14T14:55:45.795+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372/comment/17196786",
                    "id": "17196786",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=maartenbreddels",
                        "name": "maartenbreddels",
                        "key": "maartenbreddels",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Maarten Breddels",
                        "active": true,
                        "timeZone": "Europe/Amsterdam"
                    },
                    "body": "Indeed, and whatever Unicode specifies as 'whitespace' for the utf8 version.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=maartenbreddels",
                        "name": "maartenbreddels",
                        "key": "maartenbreddels",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Maarten Breddels",
                        "active": true,
                        "timeZone": "Europe/Amsterdam"
                    },
                    "created": "2020-09-16T08:34:21.668+0000",
                    "updated": "2020-09-16T08:34:21.668+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327372/comment/17216772",
                    "id": "17216772",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 8271\n[https://github.com/apache/arrow/pull/8271]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2020-10-19T14:33:17.007+0000",
                    "updated": "2020-10-19T14:33:17.007+0000"
                }
            ],
            "maxResults": 3,
            "total": 3,
            "startAt": 0
        },
        "customfield_12311820": "0|z0ikio:",
        "customfield_12314139": null
    }
}