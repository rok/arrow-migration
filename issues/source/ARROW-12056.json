{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13366987",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13366987",
    "key": "ARROW-12056",
    "fields": {
        "parent": {
            "id": "13264619",
            "key": "ARROW-7001",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13264619",
            "fields": {
                "summary": "[C++] Develop threading APIs to accommodate nested parallelism ",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                    "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                    "name": "Resolved",
                    "id": "5",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                    "id": "2",
                    "description": "A new feature of the product, which has yet to be developed.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                    "name": "New Feature",
                    "subtask": false,
                    "avatarId": 21141
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349493",
                "id": "12349493",
                "description": "",
                "name": "4.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-04-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 14400,
            "total": 14400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 14400,
            "total": 14400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12056/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 24,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13366987/worklog/570429",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace opened a new pull request #9779:\nURL: https://github.com/apache/arrow/pull/9779\n\n\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-23T13:23:57.225+0000",
                    "updated": "2021-03-23T13:23:57.225+0000",
                    "started": "2021-03-23T13:23:57.224+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "570429",
                    "issueId": "13366987"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13366987/worklog/570512",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #9779:\nURL: https://github.com/apache/arrow/pull/9779#discussion_r599611113\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -278,6 +278,147 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->queue.empty()) {\n+        if (!state_->queue.top().ok() ||\n+            state_->is_next(state_->previous_value, *state_->queue.top())) {\n+          result = std::move(state_->queue.top());\n+          if (result->ok()) {\n+            state_->previous_value = **result;\n+          }\n+          state_->queue.pop();\n+        }\n+      }\n+      if (!result.has_value()) {\n+        if (state_->finished) {\n+          return AsyncGeneratorEnd<T>();\n+        }\n+        auto new_waiting_fut = Future<T>::Make();\n+        state_->waiting_future = new_waiting_fut;\n+        guard.Unlock();\n+        state_->source().AddCallback(Callback{state_});\n+        return new_waiting_fut;\n+      }\n+      return Future<T>::MakeFinished(*result);\n+    }\n+  }\n+\n+ private:\n+  struct WrappedComp {\n+    bool operator()(const Result<T>& left, const Result<T>& right) {\n+      if (!left.ok() || !right.ok()) {\n+        return false;\n+      }\n+      return compare(*left, *right);\n+    }\n+    Comp compare;\n+  };\n+\n+  struct State {\n+    State(AsyncGenerator<T> source, Comp compare, IsNext is_next, T initial_value)\n+        : source(std::move(source)),\n+          is_next(std::move(is_next)),\n+          previous_value(std::move(initial_value)),\n+          waiting_future(),\n+          queue(WrappedComp{compare}),\n+          finished(false),\n+          mutex() {}\n+\n+    AsyncGenerator<T> source;\n+    IsNext is_next;\n+    T previous_value;\n+    Future<T> waiting_future;\n+    std::priority_queue<Result<T>, std::vector<Result<T>>, WrappedComp> queue;\n+    bool finished;\n+    util::Mutex mutex;\n+  };\n+\n+  class Callback {\n+   public:\n+    explicit Callback(std::shared_ptr<State> state) : state_(std::move(state)) {}\n+\n+    void operator()(const Result<T> result) {\n+      Future<T> to_deliver;\n+      bool finished;\n+      {\n+        auto guard = state_->mutex.Lock();\n+        bool ready_to_deliver = false;\n+        if (!result.ok()) {\n+          while (!state_->queue.empty()) {\n+            state_->queue.pop();\n+          }\n+          ready_to_deliver = true;\n+          state_->finished = true;\n+        } else if (IsIterationEnd<T>(result.ValueUnsafe())) {\n+          ready_to_deliver = state_->queue.empty();\n+          state_->finished = true;\n+        } else {\n+          ready_to_deliver = state_->is_next(state_->previous_value, *result);\n+        }\n+\n+        if (ready_to_deliver && state_->waiting_future.is_valid()) {\n+          to_deliver = state_->waiting_future;\n+          if (result.ok()) {\n+            state_->previous_value = *result;\n+          }\n+        } else {\n+          state_->queue.push(result);\n+        }\n+        finished = state_->finished;\n+      }\n+      if (to_deliver.is_valid()) {\n+        to_deliver.MarkFinished(result);\n+      } else {\n+        if (!finished) {\n+          state_->source().AddCallback(Callback{state_});\n+        }\n+      }\n+    }\n+\n+   private:\n+    const std::shared_ptr<State> state_;\n+  };\n+\n+  const std::shared_ptr<State> state_;\n+};\n+\n+/// \\brief Buffers an AsyncGenerator to return values in sequence order  Comp and IsNext\n+/// determine the sequence order.\n+///\n+/// Comp should be STL Compare https://en.cppreference.com/w/cpp/named_req/Compare It\n+/// should return true only if a is later than b\n+///\n+/// IsNext should be a BinaryPredicate that returns true, given `a` and `b`, only if\n+/// `b` follows immediately after `a`.  It should return true given `initial_value` and\n+/// `b` if `b` is the first item in the sequence.\n+///\n+/// This operator will queue unboundedly while waiting for the next item.  It is intended\n+/// for jittery sources that might scatter an ordered sequence.  It is NOT intended to\n+/// sort.  Using it to try and sort could result in deadlock.  Imagine a sequence of 10\n+/// items returned in reverse order with a readahead of 8.  The first item will never\n+/// reach this operator and the chain will halt.\n\nReview comment:\n       I worry this is a footgun, or will lead to hard-to-debug deadlocks, because even if we don't use this to sort per se, this paragraph means that any reordering beyond the readahead 'window' will lead to a deadlock, right? E.g. if you get items in the order 2 3 4 5 1 and have readahead = 4. Unless we have a way to limit how much reordering happens. (I'm assuming this is intended for use with MergeMap, but even if you're only merging two sources, you could have unbounded reordering if the first source is slow.)\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -278,6 +278,147 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->queue.empty()) {\n+        if (!state_->queue.top().ok() ||\n+            state_->is_next(state_->previous_value, *state_->queue.top())) {\n+          result = std::move(state_->queue.top());\n+          if (result->ok()) {\n+            state_->previous_value = **result;\n+          }\n+          state_->queue.pop();\n+        }\n+      }\n+      if (!result.has_value()) {\n+        if (state_->finished) {\n+          return AsyncGeneratorEnd<T>();\n+        }\n+        auto new_waiting_fut = Future<T>::Make();\n+        state_->waiting_future = new_waiting_fut;\n+        guard.Unlock();\n+        state_->source().AddCallback(Callback{state_});\n+        return new_waiting_fut;\n+      }\n+      return Future<T>::MakeFinished(*result);\n+    }\n+  }\n+\n+ private:\n+  struct WrappedComp {\n+    bool operator()(const Result<T>& left, const Result<T>& right) {\n+      if (!left.ok() || !right.ok()) {\n+        return false;\n+      }\n+      return compare(*left, *right);\n+    }\n+    Comp compare;\n+  };\n+\n+  struct State {\n+    State(AsyncGenerator<T> source, Comp compare, IsNext is_next, T initial_value)\n+        : source(std::move(source)),\n+          is_next(std::move(is_next)),\n+          previous_value(std::move(initial_value)),\n+          waiting_future(),\n+          queue(WrappedComp{compare}),\n+          finished(false),\n+          mutex() {}\n+\n+    AsyncGenerator<T> source;\n+    IsNext is_next;\n+    T previous_value;\n+    Future<T> waiting_future;\n+    std::priority_queue<Result<T>, std::vector<Result<T>>, WrappedComp> queue;\n+    bool finished;\n+    util::Mutex mutex;\n+  };\n+\n+  class Callback {\n+   public:\n+    explicit Callback(std::shared_ptr<State> state) : state_(std::move(state)) {}\n+\n+    void operator()(const Result<T> result) {\n+      Future<T> to_deliver;\n+      bool finished;\n+      {\n+        auto guard = state_->mutex.Lock();\n+        bool ready_to_deliver = false;\n+        if (!result.ok()) {\n+          while (!state_->queue.empty()) {\n+            state_->queue.pop();\n+          }\n+          ready_to_deliver = true;\n+          state_->finished = true;\n+        } else if (IsIterationEnd<T>(result.ValueUnsafe())) {\n+          ready_to_deliver = state_->queue.empty();\n+          state_->finished = true;\n+        } else {\n+          ready_to_deliver = state_->is_next(state_->previous_value, *result);\n+        }\n+\n+        if (ready_to_deliver && state_->waiting_future.is_valid()) {\n+          to_deliver = state_->waiting_future;\n+          if (result.ok()) {\n+            state_->previous_value = *result;\n+          }\n+        } else {\n+          state_->queue.push(result);\n+        }\n+        finished = state_->finished;\n+      }\n+      if (to_deliver.is_valid()) {\n+        to_deliver.MarkFinished(result);\n+      } else {\n+        if (!finished) {\n+          state_->source().AddCallback(Callback{state_});\n+        }\n+      }\n+    }\n+\n+   private:\n+    const std::shared_ptr<State> state_;\n+  };\n+\n+  const std::shared_ptr<State> state_;\n+};\n+\n+/// \\brief Buffers an AsyncGenerator to return values in sequence order  Comp and IsNext\n+/// determine the sequence order.\n+///\n+/// Comp should be STL Compare https://en.cppreference.com/w/cpp/named_req/Compare It\n+/// should return true only if a is later than b\n+///\n+/// IsNext should be a BinaryPredicate that returns true, given `a` and `b`, only if\n+/// `b` follows immediately after `a`.  It should return true given `initial_value` and\n+/// `b` if `b` is the first item in the sequence.\n+///\n+/// This operator will queue unboundedly while waiting for the next item.  It is intended\n+/// for jittery sources that might scatter an ordered sequence.  It is NOT intended to\n+/// sort.  Using it to try and sort could result in deadlock.  Imagine a sequence of 10\n+/// items returned in reverse order with a readahead of 8.  The first item will never\n+/// reach this operator and the chain will halt.\n\nReview comment:\n       Though, from my reading of the implementation, I think this _will_ effectively sort? Since the generator will (non-async-reentrantly) pull from the underlying generator until it reaches the 'next' item.\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -278,6 +278,147 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->queue.empty()) {\n+        if (!state_->queue.top().ok() ||\n+            state_->is_next(state_->previous_value, *state_->queue.top())) {\n+          result = std::move(state_->queue.top());\n+          if (result->ok()) {\n+            state_->previous_value = **result;\n+          }\n+          state_->queue.pop();\n+        }\n+      }\n+      if (!result.has_value()) {\n+        if (state_->finished) {\n+          return AsyncGeneratorEnd<T>();\n+        }\n+        auto new_waiting_fut = Future<T>::Make();\n+        state_->waiting_future = new_waiting_fut;\n+        guard.Unlock();\n+        state_->source().AddCallback(Callback{state_});\n+        return new_waiting_fut;\n+      }\n+      return Future<T>::MakeFinished(*result);\n+    }\n+  }\n+\n+ private:\n+  struct WrappedComp {\n+    bool operator()(const Result<T>& left, const Result<T>& right) {\n+      if (!left.ok() || !right.ok()) {\n+        return false;\n+      }\n+      return compare(*left, *right);\n+    }\n+    Comp compare;\n+  };\n+\n+  struct State {\n+    State(AsyncGenerator<T> source, Comp compare, IsNext is_next, T initial_value)\n+        : source(std::move(source)),\n+          is_next(std::move(is_next)),\n+          previous_value(std::move(initial_value)),\n+          waiting_future(),\n+          queue(WrappedComp{compare}),\n+          finished(false),\n+          mutex() {}\n+\n+    AsyncGenerator<T> source;\n+    IsNext is_next;\n+    T previous_value;\n+    Future<T> waiting_future;\n+    std::priority_queue<Result<T>, std::vector<Result<T>>, WrappedComp> queue;\n+    bool finished;\n+    util::Mutex mutex;\n+  };\n+\n+  class Callback {\n+   public:\n+    explicit Callback(std::shared_ptr<State> state) : state_(std::move(state)) {}\n+\n+    void operator()(const Result<T> result) {\n+      Future<T> to_deliver;\n+      bool finished;\n+      {\n+        auto guard = state_->mutex.Lock();\n+        bool ready_to_deliver = false;\n+        if (!result.ok()) {\n+          while (!state_->queue.empty()) {\n+            state_->queue.pop();\n+          }\n+          ready_to_deliver = true;\n+          state_->finished = true;\n+        } else if (IsIterationEnd<T>(result.ValueUnsafe())) {\n+          ready_to_deliver = state_->queue.empty();\n+          state_->finished = true;\n+        } else {\n+          ready_to_deliver = state_->is_next(state_->previous_value, *result);\n+        }\n+\n+        if (ready_to_deliver && state_->waiting_future.is_valid()) {\n+          to_deliver = state_->waiting_future;\n+          if (result.ok()) {\n+            state_->previous_value = *result;\n+          }\n+        } else {\n+          state_->queue.push(result);\n+        }\n+        finished = state_->finished;\n+      }\n+      if (to_deliver.is_valid()) {\n+        to_deliver.MarkFinished(result);\n+      } else {\n+        if (!finished) {\n\nReview comment:\n       nit: collapse these branches?\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -278,6 +278,147 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->queue.empty()) {\n+        if (!state_->queue.top().ok() ||\n+            state_->is_next(state_->previous_value, *state_->queue.top())) {\n+          result = std::move(state_->queue.top());\n+          if (result->ok()) {\n+            state_->previous_value = **result;\n+          }\n+          state_->queue.pop();\n+        }\n+      }\n+      if (!result.has_value()) {\n+        if (state_->finished) {\n+          return AsyncGeneratorEnd<T>();\n+        }\n+        auto new_waiting_fut = Future<T>::Make();\n+        state_->waiting_future = new_waiting_fut;\n+        guard.Unlock();\n+        state_->source().AddCallback(Callback{state_});\n+        return new_waiting_fut;\n+      }\n+      return Future<T>::MakeFinished(*result);\n+    }\n+  }\n+\n+ private:\n+  struct WrappedComp {\n+    bool operator()(const Result<T>& left, const Result<T>& right) {\n+      if (!left.ok() || !right.ok()) {\n+        return false;\n+      }\n+      return compare(*left, *right);\n+    }\n+    Comp compare;\n+  };\n+\n+  struct State {\n+    State(AsyncGenerator<T> source, Comp compare, IsNext is_next, T initial_value)\n+        : source(std::move(source)),\n+          is_next(std::move(is_next)),\n+          previous_value(std::move(initial_value)),\n+          waiting_future(),\n+          queue(WrappedComp{compare}),\n+          finished(false),\n+          mutex() {}\n+\n+    AsyncGenerator<T> source;\n+    IsNext is_next;\n+    T previous_value;\n+    Future<T> waiting_future;\n+    std::priority_queue<Result<T>, std::vector<Result<T>>, WrappedComp> queue;\n+    bool finished;\n+    util::Mutex mutex;\n+  };\n+\n+  class Callback {\n+   public:\n+    explicit Callback(std::shared_ptr<State> state) : state_(std::move(state)) {}\n+\n+    void operator()(const Result<T> result) {\n+      Future<T> to_deliver;\n+      bool finished;\n+      {\n+        auto guard = state_->mutex.Lock();\n+        bool ready_to_deliver = false;\n+        if (!result.ok()) {\n+          while (!state_->queue.empty()) {\n+            state_->queue.pop();\n+          }\n+          ready_to_deliver = true;\n+          state_->finished = true;\n+        } else if (IsIterationEnd<T>(result.ValueUnsafe())) {\n+          ready_to_deliver = state_->queue.empty();\n+          state_->finished = true;\n+        } else {\n+          ready_to_deliver = state_->is_next(state_->previous_value, *result);\n+        }\n+\n+        if (ready_to_deliver && state_->waiting_future.is_valid()) {\n+          to_deliver = state_->waiting_future;\n+          if (result.ok()) {\n+            state_->previous_value = *result;\n+          }\n+        } else {\n+          state_->queue.push(result);\n+        }\n+        finished = state_->finished;\n+      }\n+      if (to_deliver.is_valid()) {\n+        to_deliver.MarkFinished(result);\n+      } else {\n+        if (!finished) {\n\nReview comment:\n       nit: it seems redundant to have a local finished variable given that it always has the value of state->finished\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-23T14:32:34.186+0000",
                    "updated": "2021-03-23T14:32:34.186+0000",
                    "started": "2021-03-23T14:32:34.186+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "570512",
                    "issueId": "13366987"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13366987/worklog/570538",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #9779:\nURL: https://github.com/apache/arrow/pull/9779#issuecomment-804986295\n\n\n   https://issues.apache.org/jira/browse/ARROW-12056\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-23T15:14:31.915+0000",
                    "updated": "2021-03-23T15:14:31.915+0000",
                    "started": "2021-03-23T15:14:31.915+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "570538",
                    "issueId": "13366987"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13366987/worklog/570716",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9779:\nURL: https://github.com/apache/arrow/pull/9779#discussion_r599849880\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -278,6 +278,147 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->queue.empty()) {\n+        if (!state_->queue.top().ok() ||\n+            state_->is_next(state_->previous_value, *state_->queue.top())) {\n+          result = std::move(state_->queue.top());\n+          if (result->ok()) {\n+            state_->previous_value = **result;\n+          }\n+          state_->queue.pop();\n+        }\n+      }\n+      if (!result.has_value()) {\n+        if (state_->finished) {\n+          return AsyncGeneratorEnd<T>();\n+        }\n+        auto new_waiting_fut = Future<T>::Make();\n+        state_->waiting_future = new_waiting_fut;\n+        guard.Unlock();\n+        state_->source().AddCallback(Callback{state_});\n+        return new_waiting_fut;\n+      }\n+      return Future<T>::MakeFinished(*result);\n+    }\n+  }\n+\n+ private:\n+  struct WrappedComp {\n+    bool operator()(const Result<T>& left, const Result<T>& right) {\n+      if (!left.ok() || !right.ok()) {\n+        return false;\n+      }\n+      return compare(*left, *right);\n+    }\n+    Comp compare;\n+  };\n+\n+  struct State {\n+    State(AsyncGenerator<T> source, Comp compare, IsNext is_next, T initial_value)\n+        : source(std::move(source)),\n+          is_next(std::move(is_next)),\n+          previous_value(std::move(initial_value)),\n+          waiting_future(),\n+          queue(WrappedComp{compare}),\n+          finished(false),\n+          mutex() {}\n+\n+    AsyncGenerator<T> source;\n+    IsNext is_next;\n+    T previous_value;\n+    Future<T> waiting_future;\n+    std::priority_queue<Result<T>, std::vector<Result<T>>, WrappedComp> queue;\n+    bool finished;\n+    util::Mutex mutex;\n+  };\n+\n+  class Callback {\n+   public:\n+    explicit Callback(std::shared_ptr<State> state) : state_(std::move(state)) {}\n+\n+    void operator()(const Result<T> result) {\n+      Future<T> to_deliver;\n+      bool finished;\n+      {\n+        auto guard = state_->mutex.Lock();\n+        bool ready_to_deliver = false;\n+        if (!result.ok()) {\n+          while (!state_->queue.empty()) {\n+            state_->queue.pop();\n+          }\n+          ready_to_deliver = true;\n+          state_->finished = true;\n+        } else if (IsIterationEnd<T>(result.ValueUnsafe())) {\n+          ready_to_deliver = state_->queue.empty();\n+          state_->finished = true;\n+        } else {\n+          ready_to_deliver = state_->is_next(state_->previous_value, *result);\n+        }\n+\n+        if (ready_to_deliver && state_->waiting_future.is_valid()) {\n+          to_deliver = state_->waiting_future;\n+          if (result.ok()) {\n+            state_->previous_value = *result;\n+          }\n+        } else {\n+          state_->queue.push(result);\n+        }\n+        finished = state_->finished;\n+      }\n+      if (to_deliver.is_valid()) {\n+        to_deliver.MarkFinished(result);\n+      } else {\n+        if (!finished) {\n+          state_->source().AddCallback(Callback{state_});\n+        }\n+      }\n+    }\n+\n+   private:\n+    const std::shared_ptr<State> state_;\n+  };\n+\n+  const std::shared_ptr<State> state_;\n+};\n+\n+/// \\brief Buffers an AsyncGenerator to return values in sequence order  Comp and IsNext\n+/// determine the sequence order.\n+///\n+/// Comp should be STL Compare https://en.cppreference.com/w/cpp/named_req/Compare It\n+/// should return true only if a is later than b\n+///\n+/// IsNext should be a BinaryPredicate that returns true, given `a` and `b`, only if\n+/// `b` follows immediately after `a`.  It should return true given `initial_value` and\n+/// `b` if `b` is the first item in the sequence.\n+///\n+/// This operator will queue unboundedly while waiting for the next item.  It is intended\n+/// for jittery sources that might scatter an ordered sequence.  It is NOT intended to\n+/// sort.  Using it to try and sort could result in deadlock.  Imagine a sequence of 10\n+/// items returned in reverse order with a readahead of 8.  The first item will never\n+/// reach this operator and the chain will halt.\n\nReview comment:\n       Ok, you're right.  I had been worrying about the footgun too but you are correct that it won't actually matter what the upstream readahead is set to.  Instead, if you do something foolish (e.g. try and sort input with this), then the failure behavior will be excessive RAM usage and not deadlock.  This is probably preferred.  The max this can queue will depend on how out-of-order your sources can get.  If that becomes a problem then we can modify AddReadahead to have max_readahead and max_ahead_of_first.  I'll update the comment but does that logic seem right?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-23T18:56:38.706+0000",
                    "updated": "2021-03-23T18:56:38.706+0000",
                    "started": "2021-03-23T18:56:38.706+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "570716",
                    "issueId": "13366987"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13366987/worklog/570718",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9779:\nURL: https://github.com/apache/arrow/pull/9779#discussion_r599852706\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -278,6 +278,147 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->queue.empty()) {\n+        if (!state_->queue.top().ok() ||\n+            state_->is_next(state_->previous_value, *state_->queue.top())) {\n+          result = std::move(state_->queue.top());\n+          if (result->ok()) {\n+            state_->previous_value = **result;\n+          }\n+          state_->queue.pop();\n+        }\n+      }\n+      if (!result.has_value()) {\n+        if (state_->finished) {\n+          return AsyncGeneratorEnd<T>();\n+        }\n+        auto new_waiting_fut = Future<T>::Make();\n+        state_->waiting_future = new_waiting_fut;\n+        guard.Unlock();\n+        state_->source().AddCallback(Callback{state_});\n+        return new_waiting_fut;\n+      }\n+      return Future<T>::MakeFinished(*result);\n+    }\n+  }\n+\n+ private:\n+  struct WrappedComp {\n+    bool operator()(const Result<T>& left, const Result<T>& right) {\n+      if (!left.ok() || !right.ok()) {\n+        return false;\n+      }\n+      return compare(*left, *right);\n+    }\n+    Comp compare;\n+  };\n+\n+  struct State {\n+    State(AsyncGenerator<T> source, Comp compare, IsNext is_next, T initial_value)\n+        : source(std::move(source)),\n+          is_next(std::move(is_next)),\n+          previous_value(std::move(initial_value)),\n+          waiting_future(),\n+          queue(WrappedComp{compare}),\n+          finished(false),\n+          mutex() {}\n+\n+    AsyncGenerator<T> source;\n+    IsNext is_next;\n+    T previous_value;\n+    Future<T> waiting_future;\n+    std::priority_queue<Result<T>, std::vector<Result<T>>, WrappedComp> queue;\n+    bool finished;\n+    util::Mutex mutex;\n+  };\n+\n+  class Callback {\n+   public:\n+    explicit Callback(std::shared_ptr<State> state) : state_(std::move(state)) {}\n+\n+    void operator()(const Result<T> result) {\n+      Future<T> to_deliver;\n+      bool finished;\n+      {\n+        auto guard = state_->mutex.Lock();\n+        bool ready_to_deliver = false;\n+        if (!result.ok()) {\n+          while (!state_->queue.empty()) {\n+            state_->queue.pop();\n+          }\n+          ready_to_deliver = true;\n+          state_->finished = true;\n+        } else if (IsIterationEnd<T>(result.ValueUnsafe())) {\n+          ready_to_deliver = state_->queue.empty();\n+          state_->finished = true;\n+        } else {\n+          ready_to_deliver = state_->is_next(state_->previous_value, *result);\n+        }\n+\n+        if (ready_to_deliver && state_->waiting_future.is_valid()) {\n+          to_deliver = state_->waiting_future;\n+          if (result.ok()) {\n+            state_->previous_value = *result;\n+          }\n+        } else {\n+          state_->queue.push(result);\n+        }\n+        finished = state_->finished;\n+      }\n+      if (to_deliver.is_valid()) {\n+        to_deliver.MarkFinished(result);\n+      } else {\n+        if (!finished) {\n\nReview comment:\n       I capture finished while I'm still in the critical section.  I can't call `AddCallback` or `MarkFinished` while holding the mutex.  So the first block is figuring out which action to take (queue, do nothing, mark existing finished) and the second block is performing the action.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-23T19:00:48.241+0000",
                    "updated": "2021-03-23T19:00:48.241+0000",
                    "started": "2021-03-23T19:00:48.241+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "570718",
                    "issueId": "13366987"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13366987/worklog/570743",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #9779:\nURL: https://github.com/apache/arrow/pull/9779#discussion_r599902529\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -278,6 +278,147 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->queue.empty()) {\n+        if (!state_->queue.top().ok() ||\n+            state_->is_next(state_->previous_value, *state_->queue.top())) {\n+          result = std::move(state_->queue.top());\n+          if (result->ok()) {\n+            state_->previous_value = **result;\n+          }\n+          state_->queue.pop();\n+        }\n+      }\n+      if (!result.has_value()) {\n+        if (state_->finished) {\n+          return AsyncGeneratorEnd<T>();\n+        }\n+        auto new_waiting_fut = Future<T>::Make();\n+        state_->waiting_future = new_waiting_fut;\n+        guard.Unlock();\n+        state_->source().AddCallback(Callback{state_});\n+        return new_waiting_fut;\n+      }\n+      return Future<T>::MakeFinished(*result);\n+    }\n+  }\n+\n+ private:\n+  struct WrappedComp {\n+    bool operator()(const Result<T>& left, const Result<T>& right) {\n+      if (!left.ok() || !right.ok()) {\n+        return false;\n+      }\n+      return compare(*left, *right);\n+    }\n+    Comp compare;\n+  };\n+\n+  struct State {\n+    State(AsyncGenerator<T> source, Comp compare, IsNext is_next, T initial_value)\n+        : source(std::move(source)),\n+          is_next(std::move(is_next)),\n+          previous_value(std::move(initial_value)),\n+          waiting_future(),\n+          queue(WrappedComp{compare}),\n+          finished(false),\n+          mutex() {}\n+\n+    AsyncGenerator<T> source;\n+    IsNext is_next;\n+    T previous_value;\n+    Future<T> waiting_future;\n+    std::priority_queue<Result<T>, std::vector<Result<T>>, WrappedComp> queue;\n+    bool finished;\n+    util::Mutex mutex;\n+  };\n+\n+  class Callback {\n+   public:\n+    explicit Callback(std::shared_ptr<State> state) : state_(std::move(state)) {}\n+\n+    void operator()(const Result<T> result) {\n+      Future<T> to_deliver;\n+      bool finished;\n+      {\n+        auto guard = state_->mutex.Lock();\n+        bool ready_to_deliver = false;\n+        if (!result.ok()) {\n+          while (!state_->queue.empty()) {\n+            state_->queue.pop();\n+          }\n+          ready_to_deliver = true;\n+          state_->finished = true;\n+        } else if (IsIterationEnd<T>(result.ValueUnsafe())) {\n+          ready_to_deliver = state_->queue.empty();\n+          state_->finished = true;\n+        } else {\n+          ready_to_deliver = state_->is_next(state_->previous_value, *result);\n+        }\n+\n+        if (ready_to_deliver && state_->waiting_future.is_valid()) {\n+          to_deliver = state_->waiting_future;\n+          if (result.ok()) {\n+            state_->previous_value = *result;\n+          }\n+        } else {\n+          state_->queue.push(result);\n+        }\n+        finished = state_->finished;\n+      }\n+      if (to_deliver.is_valid()) {\n+        to_deliver.MarkFinished(result);\n+      } else {\n+        if (!finished) {\n+          state_->source().AddCallback(Callback{state_});\n+        }\n+      }\n+    }\n+\n+   private:\n+    const std::shared_ptr<State> state_;\n+  };\n+\n+  const std::shared_ptr<State> state_;\n+};\n+\n+/// \\brief Buffers an AsyncGenerator to return values in sequence order  Comp and IsNext\n+/// determine the sequence order.\n+///\n+/// Comp should be STL Compare https://en.cppreference.com/w/cpp/named_req/Compare It\n+/// should return true only if a is later than b\n+///\n+/// IsNext should be a BinaryPredicate that returns true, given `a` and `b`, only if\n+/// `b` follows immediately after `a`.  It should return true given `initial_value` and\n+/// `b` if `b` is the first item in the sequence.\n+///\n+/// This operator will queue unboundedly while waiting for the next item.  It is intended\n+/// for jittery sources that might scatter an ordered sequence.  It is NOT intended to\n+/// sort.  Using it to try and sort could result in deadlock.  Imagine a sequence of 10\n+/// items returned in reverse order with a readahead of 8.  The first item will never\n+/// reach this operator and the chain will halt.\n\nReview comment:\n       Yeah, that sounds right to me.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-23T20:10:47.186+0000",
                    "updated": "2021-03-23T20:10:47.186+0000",
                    "started": "2021-03-23T20:10:47.186+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "570743",
                    "issueId": "13366987"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13366987/worklog/570841",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9779:\nURL: https://github.com/apache/arrow/pull/9779#discussion_r600007226\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -278,6 +278,147 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->queue.empty()) {\n+        if (!state_->queue.top().ok() ||\n+            state_->is_next(state_->previous_value, *state_->queue.top())) {\n+          result = std::move(state_->queue.top());\n+          if (result->ok()) {\n+            state_->previous_value = **result;\n+          }\n+          state_->queue.pop();\n+        }\n+      }\n+      if (!result.has_value()) {\n+        if (state_->finished) {\n+          return AsyncGeneratorEnd<T>();\n+        }\n+        auto new_waiting_fut = Future<T>::Make();\n+        state_->waiting_future = new_waiting_fut;\n+        guard.Unlock();\n+        state_->source().AddCallback(Callback{state_});\n+        return new_waiting_fut;\n+      }\n+      return Future<T>::MakeFinished(*result);\n+    }\n+  }\n+\n+ private:\n+  struct WrappedComp {\n+    bool operator()(const Result<T>& left, const Result<T>& right) {\n+      if (!left.ok() || !right.ok()) {\n+        return false;\n+      }\n+      return compare(*left, *right);\n+    }\n+    Comp compare;\n+  };\n+\n+  struct State {\n+    State(AsyncGenerator<T> source, Comp compare, IsNext is_next, T initial_value)\n+        : source(std::move(source)),\n+          is_next(std::move(is_next)),\n+          previous_value(std::move(initial_value)),\n+          waiting_future(),\n+          queue(WrappedComp{compare}),\n+          finished(false),\n+          mutex() {}\n+\n+    AsyncGenerator<T> source;\n+    IsNext is_next;\n+    T previous_value;\n+    Future<T> waiting_future;\n+    std::priority_queue<Result<T>, std::vector<Result<T>>, WrappedComp> queue;\n+    bool finished;\n+    util::Mutex mutex;\n+  };\n+\n+  class Callback {\n+   public:\n+    explicit Callback(std::shared_ptr<State> state) : state_(std::move(state)) {}\n+\n+    void operator()(const Result<T> result) {\n+      Future<T> to_deliver;\n+      bool finished;\n+      {\n+        auto guard = state_->mutex.Lock();\n+        bool ready_to_deliver = false;\n+        if (!result.ok()) {\n+          while (!state_->queue.empty()) {\n+            state_->queue.pop();\n+          }\n+          ready_to_deliver = true;\n+          state_->finished = true;\n+        } else if (IsIterationEnd<T>(result.ValueUnsafe())) {\n+          ready_to_deliver = state_->queue.empty();\n+          state_->finished = true;\n+        } else {\n+          ready_to_deliver = state_->is_next(state_->previous_value, *result);\n+        }\n+\n+        if (ready_to_deliver && state_->waiting_future.is_valid()) {\n+          to_deliver = state_->waiting_future;\n+          if (result.ok()) {\n+            state_->previous_value = *result;\n+          }\n+        } else {\n+          state_->queue.push(result);\n+        }\n+        finished = state_->finished;\n+      }\n+      if (to_deliver.is_valid()) {\n+        to_deliver.MarkFinished(result);\n+      } else {\n+        if (!finished) {\n+          state_->source().AddCallback(Callback{state_});\n+        }\n+      }\n+    }\n+\n+   private:\n+    const std::shared_ptr<State> state_;\n+  };\n+\n+  const std::shared_ptr<State> state_;\n+};\n+\n+/// \\brief Buffers an AsyncGenerator to return values in sequence order  Comp and IsNext\n+/// determine the sequence order.\n+///\n+/// Comp should be STL Compare https://en.cppreference.com/w/cpp/named_req/Compare It\n+/// should return true only if a is later than b\n+///\n+/// IsNext should be a BinaryPredicate that returns true, given `a` and `b`, only if\n+/// `b` follows immediately after `a`.  It should return true given `initial_value` and\n+/// `b` if `b` is the first item in the sequence.\n+///\n+/// This operator will queue unboundedly while waiting for the next item.  It is intended\n+/// for jittery sources that might scatter an ordered sequence.  It is NOT intended to\n+/// sort.  Using it to try and sort could result in deadlock.  Imagine a sequence of 10\n+/// items returned in reverse order with a readahead of 8.  The first item will never\n+/// reach this operator and the chain will halt.\n\nReview comment:\n       Ok, I have updated the comments.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-23T22:42:53.618+0000",
                    "updated": "2021-03-23T22:42:53.618+0000",
                    "started": "2021-03-23T22:42:53.618+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "570841",
                    "issueId": "13366987"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13366987/worklog/571731",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on pull request #9779:\nURL: https://github.com/apache/arrow/pull/9779#issuecomment-806482907\n\n\n   Only failing build was rust.  Rebased to pull in fix.  Consider merging if CI passes.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-25T09:04:19.511+0000",
                    "updated": "2021-03-25T09:04:19.511+0000",
                    "started": "2021-03-25T09:04:19.510+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "571731",
                    "issueId": "13366987"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13366987/worklog/571759",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #9779:\nURL: https://github.com/apache/arrow/pull/9779#discussion_r601240917\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -280,6 +280,150 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+/// \\see MakeSequencingGenerator\n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->queue.empty()) {\n+        if (!state_->queue.top().ok() ||\n+            state_->is_next(state_->previous_value, *state_->queue.top())) {\n+          result = std::move(state_->queue.top());\n+          if (result->ok()) {\n+            state_->previous_value = **result;\n+          }\n+          state_->queue.pop();\n+        }\n+      }\n+      if (!result.has_value()) {\n+        if (state_->finished) {\n+          return AsyncGeneratorEnd<T>();\n+        }\n+        auto new_waiting_fut = Future<T>::Make();\n+        state_->waiting_future = new_waiting_fut;\n+        guard.Unlock();\n+        state_->source().AddCallback(Callback{state_});\n+        return new_waiting_fut;\n+      }\n+      return Future<T>::MakeFinished(*result);\n+    }\n+  }\n+\n+ private:\n+  struct WrappedComp {\n+    bool operator()(const Result<T>& left, const Result<T>& right) {\n+      if (!left.ok() || !right.ok()) {\n+        return false;\n+      }\n+      return compare(*left, *right);\n+    }\n+    Comp compare;\n+  };\n+\n+  struct State {\n+    State(AsyncGenerator<T> source, Comp compare, IsNext is_next, T initial_value)\n+        : source(std::move(source)),\n+          is_next(std::move(is_next)),\n+          previous_value(std::move(initial_value)),\n+          waiting_future(),\n+          queue(WrappedComp{compare}),\n+          finished(false),\n+          mutex() {}\n+\n+    AsyncGenerator<T> source;\n+    IsNext is_next;\n+    T previous_value;\n+    Future<T> waiting_future;\n+    std::priority_queue<Result<T>, std::vector<Result<T>>, WrappedComp> queue;\n+    bool finished;\n+    util::Mutex mutex;\n+  };\n+\n+  class Callback {\n+   public:\n+    explicit Callback(std::shared_ptr<State> state) : state_(std::move(state)) {}\n+\n+    void operator()(const Result<T> result) {\n+      Future<T> to_deliver;\n+      bool finished;\n+      {\n+        auto guard = state_->mutex.Lock();\n+        bool ready_to_deliver = false;\n+        if (!result.ok()) {\n+          while (!state_->queue.empty()) {\n+            state_->queue.pop();\n+          }\n+          ready_to_deliver = true;\n+          state_->finished = true;\n+        } else if (IsIterationEnd<T>(result.ValueUnsafe())) {\n+          ready_to_deliver = state_->queue.empty();\n+          state_->finished = true;\n+        } else {\n+          ready_to_deliver = state_->is_next(state_->previous_value, *result);\n+        }\n+\n+        if (ready_to_deliver && state_->waiting_future.is_valid()) {\n+          to_deliver = state_->waiting_future;\n+          if (result.ok()) {\n+            state_->previous_value = *result;\n+          }\n+        } else {\n+          state_->queue.push(result);\n+        }\n+        finished = state_->finished;\n+      }\n+      if (to_deliver.is_valid()) {\n+        to_deliver.MarkFinished(result);\n+      } else {\n+        if (!finished) {\n+          state_->source().AddCallback(Callback{state_});\n+        }\n+      }\n+    }\n+\n+   private:\n+    const std::shared_ptr<State> state_;\n+  };\n+\n+  const std::shared_ptr<State> state_;\n+};\n+\n+/// \\brief Buffers an AsyncGenerator to return values in sequence order  Comp and IsNext\n+/// determine the sequence order.\n+///\n+/// Comp should be STL Compare https://en.cppreference.com/w/cpp/named_req/Compare It\n+/// should return true only if a is later than b\n\nReview comment:\n       Hmm, the STL doc says \"true if the first argument of the call appears _before_ the second\".\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -280,6 +280,150 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+/// \\see MakeSequencingGenerator\n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->queue.empty()) {\n+        if (!state_->queue.top().ok() ||\n+            state_->is_next(state_->previous_value, *state_->queue.top())) {\n+          result = std::move(state_->queue.top());\n+          if (result->ok()) {\n+            state_->previous_value = **result;\n+          }\n+          state_->queue.pop();\n+        }\n\nReview comment:\n       Moving here `return Future<T>::MakeFinished(*result)` here will make this function slightly more readable.\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -280,6 +280,150 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+/// \\see MakeSequencingGenerator\n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->queue.empty()) {\n+        if (!state_->queue.top().ok() ||\n+            state_->is_next(state_->previous_value, *state_->queue.top())) {\n+          result = std::move(state_->queue.top());\n+          if (result->ok()) {\n+            state_->previous_value = **result;\n+          }\n+          state_->queue.pop();\n+        }\n+      }\n+      if (!result.has_value()) {\n+        if (state_->finished) {\n+          return AsyncGeneratorEnd<T>();\n+        }\n+        auto new_waiting_fut = Future<T>::Make();\n+        state_->waiting_future = new_waiting_fut;\n+        guard.Unlock();\n+        state_->source().AddCallback(Callback{state_});\n+        return new_waiting_fut;\n+      }\n+      return Future<T>::MakeFinished(*result);\n+    }\n+  }\n+\n+ private:\n+  struct WrappedComp {\n+    bool operator()(const Result<T>& left, const Result<T>& right) {\n+      if (!left.ok() || !right.ok()) {\n+        return false;\n+      }\n+      return compare(*left, *right);\n+    }\n+    Comp compare;\n+  };\n+\n+  struct State {\n+    State(AsyncGenerator<T> source, Comp compare, IsNext is_next, T initial_value)\n+        : source(std::move(source)),\n+          is_next(std::move(is_next)),\n+          previous_value(std::move(initial_value)),\n+          waiting_future(),\n+          queue(WrappedComp{compare}),\n+          finished(false),\n+          mutex() {}\n+\n+    AsyncGenerator<T> source;\n+    IsNext is_next;\n+    T previous_value;\n+    Future<T> waiting_future;\n+    std::priority_queue<Result<T>, std::vector<Result<T>>, WrappedComp> queue;\n+    bool finished;\n+    util::Mutex mutex;\n+  };\n+\n+  class Callback {\n+   public:\n+    explicit Callback(std::shared_ptr<State> state) : state_(std::move(state)) {}\n+\n+    void operator()(const Result<T> result) {\n+      Future<T> to_deliver;\n+      bool finished;\n+      {\n+        auto guard = state_->mutex.Lock();\n+        bool ready_to_deliver = false;\n+        if (!result.ok()) {\n+          while (!state_->queue.empty()) {\n+            state_->queue.pop();\n\nReview comment:\n       Wow, `std::priority_queue` doesn't allow to clear the queue in a single call? (except by using `std::swap` it seems...)\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -278,6 +278,147 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->queue.empty()) {\n+        if (!state_->queue.top().ok() ||\n+            state_->is_next(state_->previous_value, *state_->queue.top())) {\n+          result = std::move(state_->queue.top());\n+          if (result->ok()) {\n+            state_->previous_value = **result;\n+          }\n+          state_->queue.pop();\n+        }\n+      }\n+      if (!result.has_value()) {\n+        if (state_->finished) {\n+          return AsyncGeneratorEnd<T>();\n+        }\n+        auto new_waiting_fut = Future<T>::Make();\n+        state_->waiting_future = new_waiting_fut;\n+        guard.Unlock();\n+        state_->source().AddCallback(Callback{state_});\n+        return new_waiting_fut;\n+      }\n+      return Future<T>::MakeFinished(*result);\n+    }\n+  }\n+\n+ private:\n+  struct WrappedComp {\n+    bool operator()(const Result<T>& left, const Result<T>& right) {\n+      if (!left.ok() || !right.ok()) {\n+        return false;\n+      }\n+      return compare(*left, *right);\n+    }\n+    Comp compare;\n+  };\n+\n+  struct State {\n+    State(AsyncGenerator<T> source, Comp compare, IsNext is_next, T initial_value)\n+        : source(std::move(source)),\n+          is_next(std::move(is_next)),\n+          previous_value(std::move(initial_value)),\n+          waiting_future(),\n+          queue(WrappedComp{compare}),\n+          finished(false),\n+          mutex() {}\n+\n+    AsyncGenerator<T> source;\n+    IsNext is_next;\n+    T previous_value;\n+    Future<T> waiting_future;\n+    std::priority_queue<Result<T>, std::vector<Result<T>>, WrappedComp> queue;\n+    bool finished;\n+    util::Mutex mutex;\n+  };\n+\n+  class Callback {\n+   public:\n+    explicit Callback(std::shared_ptr<State> state) : state_(std::move(state)) {}\n+\n+    void operator()(const Result<T> result) {\n+      Future<T> to_deliver;\n+      bool finished;\n+      {\n+        auto guard = state_->mutex.Lock();\n+        bool ready_to_deliver = false;\n+        if (!result.ok()) {\n+          while (!state_->queue.empty()) {\n+            state_->queue.pop();\n+          }\n+          ready_to_deliver = true;\n+          state_->finished = true;\n+        } else if (IsIterationEnd<T>(result.ValueUnsafe())) {\n+          ready_to_deliver = state_->queue.empty();\n+          state_->finished = true;\n+        } else {\n+          ready_to_deliver = state_->is_next(state_->previous_value, *result);\n+        }\n+\n+        if (ready_to_deliver && state_->waiting_future.is_valid()) {\n+          to_deliver = state_->waiting_future;\n+          if (result.ok()) {\n+            state_->previous_value = *result;\n+          }\n+        } else {\n+          state_->queue.push(result);\n+        }\n+        finished = state_->finished;\n+      }\n+      if (to_deliver.is_valid()) {\n+        to_deliver.MarkFinished(result);\n+      } else {\n+        if (!finished) {\n\nReview comment:\n       You may want to add a comment pointing this out, so that this doesn't look gratuitously weird.\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -280,6 +280,150 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+/// \\see MakeSequencingGenerator\n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->queue.empty()) {\n+        if (!state_->queue.top().ok() ||\n+            state_->is_next(state_->previous_value, *state_->queue.top())) {\n+          result = std::move(state_->queue.top());\n+          if (result->ok()) {\n+            state_->previous_value = **result;\n+          }\n+          state_->queue.pop();\n+        }\n+      }\n+      if (!result.has_value()) {\n+        if (state_->finished) {\n+          return AsyncGeneratorEnd<T>();\n+        }\n+        auto new_waiting_fut = Future<T>::Make();\n+        state_->waiting_future = new_waiting_fut;\n+        guard.Unlock();\n+        state_->source().AddCallback(Callback{state_});\n+        return new_waiting_fut;\n+      }\n+      return Future<T>::MakeFinished(*result);\n+    }\n+  }\n+\n+ private:\n+  struct WrappedComp {\n+    bool operator()(const Result<T>& left, const Result<T>& right) {\n+      if (!left.ok() || !right.ok()) {\n+        return false;\n\nReview comment:\n       I'm not sure this is correct. Do you mean something like (or the converse):\r\n   ```c++\r\n       bool operator()(const Result<T>& left, const Result<T>& right) {\r\n         // Errors always come before non-errors\r\n         if (!left.ok()) {\r\n           return false;\r\n         }\r\n         if (right.ok()) {\r\n           return true;\r\n         }\r\n         return compare(*left, *right);\r\n       }\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -280,6 +280,150 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+/// \\see MakeSequencingGenerator\n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->queue.empty()) {\n+        if (!state_->queue.top().ok() ||\n+            state_->is_next(state_->previous_value, *state_->queue.top())) {\n+          result = std::move(state_->queue.top());\n+          if (result->ok()) {\n+            state_->previous_value = **result;\n+          }\n+          state_->queue.pop();\n+        }\n+      }\n+      if (!result.has_value()) {\n+        if (state_->finished) {\n+          return AsyncGeneratorEnd<T>();\n+        }\n+        auto new_waiting_fut = Future<T>::Make();\n+        state_->waiting_future = new_waiting_fut;\n+        guard.Unlock();\n+        state_->source().AddCallback(Callback{state_});\n+        return new_waiting_fut;\n+      }\n+      return Future<T>::MakeFinished(*result);\n+    }\n+  }\n+\n+ private:\n+  struct WrappedComp {\n+    bool operator()(const Result<T>& left, const Result<T>& right) {\n+      if (!left.ok() || !right.ok()) {\n+        return false;\n+      }\n+      return compare(*left, *right);\n+    }\n+    Comp compare;\n+  };\n+\n+  struct State {\n+    State(AsyncGenerator<T> source, Comp compare, IsNext is_next, T initial_value)\n+        : source(std::move(source)),\n+          is_next(std::move(is_next)),\n+          previous_value(std::move(initial_value)),\n+          waiting_future(),\n+          queue(WrappedComp{compare}),\n+          finished(false),\n+          mutex() {}\n+\n+    AsyncGenerator<T> source;\n+    IsNext is_next;\n+    T previous_value;\n+    Future<T> waiting_future;\n+    std::priority_queue<Result<T>, std::vector<Result<T>>, WrappedComp> queue;\n+    bool finished;\n+    util::Mutex mutex;\n+  };\n+\n+  class Callback {\n+   public:\n+    explicit Callback(std::shared_ptr<State> state) : state_(std::move(state)) {}\n+\n+    void operator()(const Result<T> result) {\n+      Future<T> to_deliver;\n+      bool finished;\n+      {\n+        auto guard = state_->mutex.Lock();\n+        bool ready_to_deliver = false;\n+        if (!result.ok()) {\n+          while (!state_->queue.empty()) {\n+            state_->queue.pop();\n+          }\n+          ready_to_deliver = true;\n+          state_->finished = true;\n+        } else if (IsIterationEnd<T>(result.ValueUnsafe())) {\n+          ready_to_deliver = state_->queue.empty();\n+          state_->finished = true;\n+        } else {\n+          ready_to_deliver = state_->is_next(state_->previous_value, *result);\n+        }\n+\n+        if (ready_to_deliver && state_->waiting_future.is_valid()) {\n+          to_deliver = state_->waiting_future;\n+          if (result.ok()) {\n+            state_->previous_value = *result;\n+          }\n+        } else {\n+          state_->queue.push(result);\n+        }\n+        finished = state_->finished;\n+      }\n+      if (to_deliver.is_valid()) {\n+        to_deliver.MarkFinished(result);\n+      } else {\n+        if (!finished) {\n+          state_->source().AddCallback(Callback{state_});\n+        }\n+      }\n+    }\n+\n+   private:\n+    const std::shared_ptr<State> state_;\n+  };\n+\n+  const std::shared_ptr<State> state_;\n+};\n+\n+/// \\brief Buffers an AsyncGenerator to return values in sequence order  Comp and IsNext\n+/// determine the sequence order.\n+///\n+/// Comp should be STL Compare https://en.cppreference.com/w/cpp/named_req/Compare It\n+/// should return true only if a is later than b\n\nReview comment:\n       Can Comp be renamed something more explicit, such as \"IsBefore\" or \"IsAfter\" (or \"ComesBefore\" etc.)?\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -280,6 +280,150 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+/// \\see MakeSequencingGenerator\n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n\nReview comment:\n       I don't think there's a reason to declare this upfront using an `optional` if you reorganize the `if` branches a bit.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-25T09:35:27.854+0000",
                    "updated": "2021-03-25T09:35:27.854+0000",
                    "started": "2021-03-25T09:35:27.854+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "571759",
                    "issueId": "13366987"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13366987/worklog/572309",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9779:\nURL: https://github.com/apache/arrow/pull/9779#discussion_r601829413\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -280,6 +280,150 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+/// \\see MakeSequencingGenerator\n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->queue.empty()) {\n+        if (!state_->queue.top().ok() ||\n+            state_->is_next(state_->previous_value, *state_->queue.top())) {\n+          result = std::move(state_->queue.top());\n+          if (result->ok()) {\n+            state_->previous_value = **result;\n+          }\n+          state_->queue.pop();\n+        }\n+      }\n+      if (!result.has_value()) {\n+        if (state_->finished) {\n+          return AsyncGeneratorEnd<T>();\n+        }\n+        auto new_waiting_fut = Future<T>::Make();\n+        state_->waiting_future = new_waiting_fut;\n+        guard.Unlock();\n+        state_->source().AddCallback(Callback{state_});\n+        return new_waiting_fut;\n+      }\n+      return Future<T>::MakeFinished(*result);\n+    }\n+  }\n+\n+ private:\n+  struct WrappedComp {\n+    bool operator()(const Result<T>& left, const Result<T>& right) {\n+      if (!left.ok() || !right.ok()) {\n+        return false;\n+      }\n+      return compare(*left, *right);\n+    }\n+    Comp compare;\n+  };\n+\n+  struct State {\n+    State(AsyncGenerator<T> source, Comp compare, IsNext is_next, T initial_value)\n+        : source(std::move(source)),\n+          is_next(std::move(is_next)),\n+          previous_value(std::move(initial_value)),\n+          waiting_future(),\n+          queue(WrappedComp{compare}),\n+          finished(false),\n+          mutex() {}\n+\n+    AsyncGenerator<T> source;\n+    IsNext is_next;\n+    T previous_value;\n+    Future<T> waiting_future;\n+    std::priority_queue<Result<T>, std::vector<Result<T>>, WrappedComp> queue;\n+    bool finished;\n+    util::Mutex mutex;\n+  };\n+\n+  class Callback {\n+   public:\n+    explicit Callback(std::shared_ptr<State> state) : state_(std::move(state)) {}\n+\n+    void operator()(const Result<T> result) {\n+      Future<T> to_deliver;\n+      bool finished;\n+      {\n+        auto guard = state_->mutex.Lock();\n+        bool ready_to_deliver = false;\n+        if (!result.ok()) {\n+          while (!state_->queue.empty()) {\n+            state_->queue.pop();\n+          }\n+          ready_to_deliver = true;\n+          state_->finished = true;\n+        } else if (IsIterationEnd<T>(result.ValueUnsafe())) {\n+          ready_to_deliver = state_->queue.empty();\n+          state_->finished = true;\n+        } else {\n+          ready_to_deliver = state_->is_next(state_->previous_value, *result);\n+        }\n+\n+        if (ready_to_deliver && state_->waiting_future.is_valid()) {\n+          to_deliver = state_->waiting_future;\n+          if (result.ok()) {\n+            state_->previous_value = *result;\n+          }\n+        } else {\n+          state_->queue.push(result);\n+        }\n+        finished = state_->finished;\n+      }\n+      if (to_deliver.is_valid()) {\n+        to_deliver.MarkFinished(result);\n+      } else {\n+        if (!finished) {\n+          state_->source().AddCallback(Callback{state_});\n+        }\n+      }\n+    }\n+\n+   private:\n+    const std::shared_ptr<State> state_;\n+  };\n+\n+  const std::shared_ptr<State> state_;\n+};\n+\n+/// \\brief Buffers an AsyncGenerator to return values in sequence order  Comp and IsNext\n+/// determine the sequence order.\n+///\n+/// Comp should be STL Compare https://en.cppreference.com/w/cpp/named_req/Compare It\n+/// should return true only if a is later than b\n\nReview comment:\n       Yes, we want a specific kind of Compare anyways.  The STL language is very confusing \"if the first argument of the call appears before the second in the strict weak ordering relation induced by this type\".  The \"strict weak ordering relation\" in this case is largest-to-smallest so the bigger item comes before the smaller in the relation. I went ahead and just made it plain English.\r\n   \r\n   A priority queue with std::less (smallest-to-largest) puts the largest item on top and std::greater (largest-to-smallest) puts the smallest on top.  Since we want the smallest it is more of a \"greater than\" relationship.\r\n   \r\n   I renamed it to ComesAfter.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-25T20:48:57.136+0000",
                    "updated": "2021-03-25T20:48:57.136+0000",
                    "started": "2021-03-25T20:48:57.135+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "572309",
                    "issueId": "13366987"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13366987/worklog/572310",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9779:\nURL: https://github.com/apache/arrow/pull/9779#discussion_r601829862\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -280,6 +280,150 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+/// \\see MakeSequencingGenerator\n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->queue.empty()) {\n+        if (!state_->queue.top().ok() ||\n+            state_->is_next(state_->previous_value, *state_->queue.top())) {\n+          result = std::move(state_->queue.top());\n+          if (result->ok()) {\n+            state_->previous_value = **result;\n+          }\n+          state_->queue.pop();\n+        }\n\nReview comment:\n       Good observation.  I reworked the logic based on this and I think it is much clearer now (and I got rid of the optional)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-25T20:49:40.357+0000",
                    "updated": "2021-03-25T20:49:40.357+0000",
                    "started": "2021-03-25T20:49:40.357+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "572310",
                    "issueId": "13366987"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13366987/worklog/572312",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9779:\nURL: https://github.com/apache/arrow/pull/9779#discussion_r601830091\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -280,6 +280,150 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+/// \\see MakeSequencingGenerator\n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n\nReview comment:\n       Done.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-25T20:50:05.604+0000",
                    "updated": "2021-03-25T20:50:05.604+0000",
                    "started": "2021-03-25T20:50:05.603+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "572312",
                    "issueId": "13366987"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13366987/worklog/572319",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9779:\nURL: https://github.com/apache/arrow/pull/9779#discussion_r601831609\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -280,6 +280,150 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+/// \\see MakeSequencingGenerator\n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->queue.empty()) {\n+        if (!state_->queue.top().ok() ||\n+            state_->is_next(state_->previous_value, *state_->queue.top())) {\n+          result = std::move(state_->queue.top());\n+          if (result->ok()) {\n+            state_->previous_value = **result;\n+          }\n+          state_->queue.pop();\n+        }\n+      }\n+      if (!result.has_value()) {\n+        if (state_->finished) {\n+          return AsyncGeneratorEnd<T>();\n+        }\n+        auto new_waiting_fut = Future<T>::Make();\n+        state_->waiting_future = new_waiting_fut;\n+        guard.Unlock();\n+        state_->source().AddCallback(Callback{state_});\n+        return new_waiting_fut;\n+      }\n+      return Future<T>::MakeFinished(*result);\n+    }\n+  }\n+\n+ private:\n+  struct WrappedComp {\n+    bool operator()(const Result<T>& left, const Result<T>& right) {\n+      if (!left.ok() || !right.ok()) {\n+        return false;\n\nReview comment:\n       You're right in a way.  However, once an error is placed in the queue there should never again be another item placed on the queue so this operator should not be called on an invalid result.\r\n   Would it be better to just use ValueUnsafe directly and let it explode?  I suppose that's the equivalent of DCHECK_OK (which I think I can't use in this context).\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-25T20:52:44.880+0000",
                    "updated": "2021-03-25T20:52:44.880+0000",
                    "started": "2021-03-25T20:52:44.880+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "572319",
                    "issueId": "13366987"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13366987/worklog/572320",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9779:\nURL: https://github.com/apache/arrow/pull/9779#discussion_r601832029\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -280,6 +280,150 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+/// \\see MakeSequencingGenerator\n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->queue.empty()) {\n+        if (!state_->queue.top().ok() ||\n+            state_->is_next(state_->previous_value, *state_->queue.top())) {\n+          result = std::move(state_->queue.top());\n+          if (result->ok()) {\n+            state_->previous_value = **result;\n+          }\n+          state_->queue.pop();\n+        }\n+      }\n+      if (!result.has_value()) {\n+        if (state_->finished) {\n+          return AsyncGeneratorEnd<T>();\n+        }\n+        auto new_waiting_fut = Future<T>::Make();\n+        state_->waiting_future = new_waiting_fut;\n+        guard.Unlock();\n+        state_->source().AddCallback(Callback{state_});\n+        return new_waiting_fut;\n+      }\n+      return Future<T>::MakeFinished(*result);\n+    }\n+  }\n+\n+ private:\n+  struct WrappedComp {\n+    bool operator()(const Result<T>& left, const Result<T>& right) {\n+      if (!left.ok() || !right.ok()) {\n+        return false;\n+      }\n+      return compare(*left, *right);\n+    }\n+    Comp compare;\n+  };\n+\n+  struct State {\n+    State(AsyncGenerator<T> source, Comp compare, IsNext is_next, T initial_value)\n+        : source(std::move(source)),\n+          is_next(std::move(is_next)),\n+          previous_value(std::move(initial_value)),\n+          waiting_future(),\n+          queue(WrappedComp{compare}),\n+          finished(false),\n+          mutex() {}\n+\n+    AsyncGenerator<T> source;\n+    IsNext is_next;\n+    T previous_value;\n+    Future<T> waiting_future;\n+    std::priority_queue<Result<T>, std::vector<Result<T>>, WrappedComp> queue;\n+    bool finished;\n+    util::Mutex mutex;\n+  };\n+\n+  class Callback {\n+   public:\n+    explicit Callback(std::shared_ptr<State> state) : state_(std::move(state)) {}\n+\n+    void operator()(const Result<T> result) {\n+      Future<T> to_deliver;\n+      bool finished;\n+      {\n+        auto guard = state_->mutex.Lock();\n+        bool ready_to_deliver = false;\n+        if (!result.ok()) {\n+          while (!state_->queue.empty()) {\n+            state_->queue.pop();\n\nReview comment:\n       Some googling suggests creating a new queue should work well so I went with that.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-25T20:53:38.176+0000",
                    "updated": "2021-03-25T20:53:38.176+0000",
                    "started": "2021-03-25T20:53:38.175+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "572320",
                    "issueId": "13366987"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13366987/worklog/572321",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #9779:\nURL: https://github.com/apache/arrow/pull/9779#discussion_r601832723\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -280,6 +280,150 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+/// \\see MakeSequencingGenerator\n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->queue.empty()) {\n+        if (!state_->queue.top().ok() ||\n+            state_->is_next(state_->previous_value, *state_->queue.top())) {\n+          result = std::move(state_->queue.top());\n+          if (result->ok()) {\n+            state_->previous_value = **result;\n+          }\n+          state_->queue.pop();\n+        }\n+      }\n+      if (!result.has_value()) {\n+        if (state_->finished) {\n+          return AsyncGeneratorEnd<T>();\n+        }\n+        auto new_waiting_fut = Future<T>::Make();\n+        state_->waiting_future = new_waiting_fut;\n+        guard.Unlock();\n+        state_->source().AddCallback(Callback{state_});\n+        return new_waiting_fut;\n+      }\n+      return Future<T>::MakeFinished(*result);\n+    }\n+  }\n+\n+ private:\n+  struct WrappedComp {\n+    bool operator()(const Result<T>& left, const Result<T>& right) {\n+      if (!left.ok() || !right.ok()) {\n+        return false;\n\nReview comment:\n       Let's keep as-is then.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-25T20:54:41.392+0000",
                    "updated": "2021-03-25T20:54:41.392+0000",
                    "started": "2021-03-25T20:54:41.392+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "572321",
                    "issueId": "13366987"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13366987/worklog/572332",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9779:\nURL: https://github.com/apache/arrow/pull/9779#discussion_r601844175\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -278,6 +278,147 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->queue.empty()) {\n+        if (!state_->queue.top().ok() ||\n+            state_->is_next(state_->previous_value, *state_->queue.top())) {\n+          result = std::move(state_->queue.top());\n+          if (result->ok()) {\n+            state_->previous_value = **result;\n+          }\n+          state_->queue.pop();\n+        }\n+      }\n+      if (!result.has_value()) {\n+        if (state_->finished) {\n+          return AsyncGeneratorEnd<T>();\n+        }\n+        auto new_waiting_fut = Future<T>::Make();\n+        state_->waiting_future = new_waiting_fut;\n+        guard.Unlock();\n+        state_->source().AddCallback(Callback{state_});\n+        return new_waiting_fut;\n+      }\n+      return Future<T>::MakeFinished(*result);\n+    }\n+  }\n+\n+ private:\n+  struct WrappedComp {\n+    bool operator()(const Result<T>& left, const Result<T>& right) {\n+      if (!left.ok() || !right.ok()) {\n+        return false;\n+      }\n+      return compare(*left, *right);\n+    }\n+    Comp compare;\n+  };\n+\n+  struct State {\n+    State(AsyncGenerator<T> source, Comp compare, IsNext is_next, T initial_value)\n+        : source(std::move(source)),\n+          is_next(std::move(is_next)),\n+          previous_value(std::move(initial_value)),\n+          waiting_future(),\n+          queue(WrappedComp{compare}),\n+          finished(false),\n+          mutex() {}\n+\n+    AsyncGenerator<T> source;\n+    IsNext is_next;\n+    T previous_value;\n+    Future<T> waiting_future;\n+    std::priority_queue<Result<T>, std::vector<Result<T>>, WrappedComp> queue;\n+    bool finished;\n+    util::Mutex mutex;\n+  };\n+\n+  class Callback {\n+   public:\n+    explicit Callback(std::shared_ptr<State> state) : state_(std::move(state)) {}\n+\n+    void operator()(const Result<T> result) {\n+      Future<T> to_deliver;\n+      bool finished;\n+      {\n+        auto guard = state_->mutex.Lock();\n+        bool ready_to_deliver = false;\n+        if (!result.ok()) {\n+          while (!state_->queue.empty()) {\n+            state_->queue.pop();\n+          }\n+          ready_to_deliver = true;\n+          state_->finished = true;\n+        } else if (IsIterationEnd<T>(result.ValueUnsafe())) {\n+          ready_to_deliver = state_->queue.empty();\n+          state_->finished = true;\n+        } else {\n+          ready_to_deliver = state_->is_next(state_->previous_value, *result);\n+        }\n+\n+        if (ready_to_deliver && state_->waiting_future.is_valid()) {\n+          to_deliver = state_->waiting_future;\n+          if (result.ok()) {\n+            state_->previous_value = *result;\n+          }\n+        } else {\n+          state_->queue.push(result);\n+        }\n+        finished = state_->finished;\n+      }\n+      if (to_deliver.is_valid()) {\n+        to_deliver.MarkFinished(result);\n+      } else {\n+        if (!finished) {\n\nReview comment:\n       I added one.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-25T21:15:07.562+0000",
                    "updated": "2021-03-25T21:15:07.562+0000",
                    "started": "2021-03-25T21:15:07.562+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "572332",
                    "issueId": "13366987"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13366987/worklog/572446",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on pull request #9779:\nURL: https://github.com/apache/arrow/pull/9779#issuecomment-807921383\n\n\n   Failing check unrelated.  I believe I have addressed all feedback.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-26T04:09:38.183+0000",
                    "updated": "2021-03-26T04:09:38.183+0000",
                    "started": "2021-03-26T04:09:38.182+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "572446",
                    "issueId": "13366987"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13366987/worklog/572956",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9779:\nURL: https://github.com/apache/arrow/pull/9779#discussion_r602642902\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -280,6 +280,150 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+/// \\see MakeSequencingGenerator\n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->queue.empty()) {\n+        if (!state_->queue.top().ok() ||\n+            state_->is_next(state_->previous_value, *state_->queue.top())) {\n+          result = std::move(state_->queue.top());\n+          if (result->ok()) {\n+            state_->previous_value = **result;\n+          }\n+          state_->queue.pop();\n+        }\n+      }\n+      if (!result.has_value()) {\n+        if (state_->finished) {\n+          return AsyncGeneratorEnd<T>();\n+        }\n+        auto new_waiting_fut = Future<T>::Make();\n+        state_->waiting_future = new_waiting_fut;\n+        guard.Unlock();\n+        state_->source().AddCallback(Callback{state_});\n+        return new_waiting_fut;\n+      }\n+      return Future<T>::MakeFinished(*result);\n+    }\n+  }\n+\n+ private:\n+  struct WrappedComp {\n+    bool operator()(const Result<T>& left, const Result<T>& right) {\n+      if (!left.ok() || !right.ok()) {\n+        return false;\n+      }\n+      return compare(*left, *right);\n+    }\n+    Comp compare;\n+  };\n+\n+  struct State {\n+    State(AsyncGenerator<T> source, Comp compare, IsNext is_next, T initial_value)\n+        : source(std::move(source)),\n+          is_next(std::move(is_next)),\n+          previous_value(std::move(initial_value)),\n+          waiting_future(),\n+          queue(WrappedComp{compare}),\n+          finished(false),\n+          mutex() {}\n+\n+    AsyncGenerator<T> source;\n+    IsNext is_next;\n+    T previous_value;\n+    Future<T> waiting_future;\n+    std::priority_queue<Result<T>, std::vector<Result<T>>, WrappedComp> queue;\n+    bool finished;\n+    util::Mutex mutex;\n+  };\n+\n+  class Callback {\n+   public:\n+    explicit Callback(std::shared_ptr<State> state) : state_(std::move(state)) {}\n+\n+    void operator()(const Result<T> result) {\n+      Future<T> to_deliver;\n+      bool finished;\n+      {\n+        auto guard = state_->mutex.Lock();\n+        bool ready_to_deliver = false;\n+        if (!result.ok()) {\n+          while (!state_->queue.empty()) {\n+            state_->queue.pop();\n\nReview comment:\n       Nevermind.  Both `state_->queue = {}` and `swap` fail if the callables are lambdas because (I think) of lambda's deleted copy assignment operator.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-27T00:34:07.608+0000",
                    "updated": "2021-03-27T00:34:07.608+0000",
                    "started": "2021-03-27T00:34:07.608+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "572956",
                    "issueId": "13366987"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13366987/worklog/572957",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9779:\nURL: https://github.com/apache/arrow/pull/9779#discussion_r602644112\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -280,6 +280,150 @@ AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n   return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n }\n \n+/// \\see MakeSequencingGenerator\n+template <typename T, typename Comp, typename IsNext>\n+class SequencingGenerator {\n+ public:\n+  SequencingGenerator(AsyncGenerator<T> source, Comp compare, IsNext is_next,\n+                      T initial_value)\n+      : state_(std::make_shared<State>(std::move(source), std::move(compare),\n+                                       std::move(is_next), std::move(initial_value))) {}\n+\n+  Future<T> operator()() {\n+    util::optional<Result<T>> result;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->queue.empty()) {\n+        if (!state_->queue.top().ok() ||\n+            state_->is_next(state_->previous_value, *state_->queue.top())) {\n+          result = std::move(state_->queue.top());\n+          if (result->ok()) {\n+            state_->previous_value = **result;\n+          }\n+          state_->queue.pop();\n+        }\n+      }\n+      if (!result.has_value()) {\n+        if (state_->finished) {\n+          return AsyncGeneratorEnd<T>();\n+        }\n+        auto new_waiting_fut = Future<T>::Make();\n+        state_->waiting_future = new_waiting_fut;\n+        guard.Unlock();\n+        state_->source().AddCallback(Callback{state_});\n+        return new_waiting_fut;\n+      }\n+      return Future<T>::MakeFinished(*result);\n+    }\n+  }\n+\n+ private:\n+  struct WrappedComp {\n+    bool operator()(const Result<T>& left, const Result<T>& right) {\n+      if (!left.ok() || !right.ok()) {\n+        return false;\n+      }\n+      return compare(*left, *right);\n+    }\n+    Comp compare;\n+  };\n+\n+  struct State {\n+    State(AsyncGenerator<T> source, Comp compare, IsNext is_next, T initial_value)\n+        : source(std::move(source)),\n+          is_next(std::move(is_next)),\n+          previous_value(std::move(initial_value)),\n+          waiting_future(),\n+          queue(WrappedComp{compare}),\n+          finished(false),\n+          mutex() {}\n+\n+    AsyncGenerator<T> source;\n+    IsNext is_next;\n+    T previous_value;\n+    Future<T> waiting_future;\n+    std::priority_queue<Result<T>, std::vector<Result<T>>, WrappedComp> queue;\n+    bool finished;\n+    util::Mutex mutex;\n+  };\n+\n+  class Callback {\n+   public:\n+    explicit Callback(std::shared_ptr<State> state) : state_(std::move(state)) {}\n+\n+    void operator()(const Result<T> result) {\n+      Future<T> to_deliver;\n+      bool finished;\n+      {\n+        auto guard = state_->mutex.Lock();\n+        bool ready_to_deliver = false;\n+        if (!result.ok()) {\n+          while (!state_->queue.empty()) {\n+            state_->queue.pop();\n\nReview comment:\n       Ah, `= {}` fails because there is no assignment and `swap` fails because I cannot create a queue without an instance of `comp`.  I can create a second empty queue when I create the first one but that is kind of clumsy and it can only swap once (although it should only have to swap once).\r\n   \r\n   At that point, it would probably just be cleaner to have a dedicated spot for the \"final result\" and call the destructor on the queue instead of clearing it.\r\n   \r\n   I think I'll just keep it how it is.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-27T00:41:47.718+0000",
                    "updated": "2021-03-27T00:41:47.718+0000",
                    "started": "2021-03-27T00:41:47.718+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "572957",
                    "issueId": "13366987"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13366987/worklog/573476",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #9779:\nURL: https://github.com/apache/arrow/pull/9779#discussion_r603274804\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator_test.cc\n##########\n@@ -793,6 +794,118 @@ TEST(TestAsyncUtil, ReadaheadFailed) {\n   ASSERT_TRUE(IsIterationEnd(definitely_last));\n }\n \n+class SequencerTestFixture : public GeneratorTestFixture {\n+ protected:\n+  void RandomShuffle(std::vector<TestInt>& values) {\n+    std::default_random_engine gen(seed_++);\n+    std::shuffle(values.begin(), values.end(), gen);\n+  }\n+\n+  int seed_ = 42;\n+  std::function<bool(const TestInt&, const TestInt&)> cmp_ =\n+      [](const TestInt& left, const TestInt& right) { return left.value > right.value; };\n+  // Let's increment by 2's to make it interesting\n+  std::function<bool(const TestInt&, const TestInt&)> is_next_ =\n+      [](const TestInt& left, const TestInt& right) {\n+        return left.value + 2 == right.value;\n+      };\n+};\n+\n+TEST_P(SequencerTestFixture, SequenceBasic) {\n+  // Basic sequencing\n+  auto original = MakeSource({6, 4, 2});\n+  auto sequenced = MakeSequencingGenerator(original, cmp_, is_next_, TestInt(0));\n+  AssertAsyncGeneratorMatch({2, 4, 6}, sequenced);\n+\n+  // From ordered input\n+  original = MakeSource({2, 4, 6});\n+  sequenced = MakeSequencingGenerator(original, cmp_, is_next_, TestInt(0));\n+  AssertAsyncGeneratorMatch({2, 4, 6}, sequenced);\n+}\n+\n+TEST_P(SequencerTestFixture, SequenceLambda) {\n+  auto cmp = [](const TestInt& left, const TestInt& right) {\n+    return left.value > right.value;\n+  };\n+  auto is_next = [](const TestInt& left, const TestInt& right) {\n+    return left.value + 2 == right.value;\n+  };\n+  // Basic sequencing\n+  auto original = MakeSource({6, 4, 2});\n+  auto sequenced = MakeSequencingGenerator(original, cmp, is_next, TestInt(0));\n+  AssertAsyncGeneratorMatch({2, 4, 6}, sequenced);\n+}\n+\n+TEST_P(SequencerTestFixture, SequenceError) {\n+  {\n+    auto original = MakeSource({6, 4, 2});\n+    original = FailsAt(original, 1);\n+    auto sequenced = MakeSequencingGenerator(original, cmp_, is_next_, TestInt(0));\n+    auto collected = CollectAsyncGenerator(sequenced);\n+    ASSERT_FINISHES_AND_RAISES(Invalid, collected);\n+  }\n+  {\n+    // Failure should clear old items out of the queue immediately\n+    // shared_ptr versions of cmp_ and is_next_\n+    auto cmp = cmp_;\n+    std::function<bool(const std::shared_ptr<TestInt>&, const std::shared_ptr<TestInt>&)>\n+        ptr_cmp =\n+            [cmp](const std::shared_ptr<TestInt>& left,\n+                  const std::shared_ptr<TestInt>& right) { return cmp(*left, *right); };\n+    auto is_next = is_next_;\n+    std::function<bool(const std::shared_ptr<TestInt>&, const std::shared_ptr<TestInt>&)>\n+        ptr_is_next = [is_next](const std::shared_ptr<TestInt>& left,\n+                                const std::shared_ptr<TestInt>& right) {\n+          return is_next(*left, *right);\n+        };\n+\n+    PushGenerator<std::shared_ptr<TestInt>> source;\n+    auto sequenced = MakeSequencingGenerator(\n+        static_cast<AsyncGenerator<std::shared_ptr<TestInt>>>(source), ptr_cmp,\n+        ptr_is_next, std::make_shared<TestInt>(0));\n+\n+    auto should_be_cleared = std::make_shared<TestInt>(4);\n+    std::weak_ptr<TestInt> ref = should_be_cleared;\n+    auto producer = source.producer();\n+    auto next_fut = sequenced();\n+    producer.Push(std::move(should_be_cleared));\n+    producer.Push(Status::Invalid(\"XYZ\"));\n+    ASSERT_TRUE(ref.expired());\n+\n+    ASSERT_FINISHES_AND_RAISES(Invalid, next_fut);\n+  }\n+  {\n+    // Failure should interrupt pumping\n+    PushGenerator<TestInt> source;\n+    auto sequenced = MakeSequencingGenerator(static_cast<AsyncGenerator<TestInt>>(source),\n+                                             cmp_, is_next_, TestInt(0));\n+\n+    auto producer = source.producer();\n+    auto next_fut = sequenced();\n+    producer.Push(TestInt(4));\n+    producer.Push(Status::Invalid(\"XYZ\"));\n+    producer.Push(TestInt(2));\n+    ASSERT_FINISHES_AND_RAISES(Invalid, next_fut);\n+    // The sequencer should not have pulled the 2 out of the source because it should\n+    // have stopped pumping on error\n+    ASSERT_FINISHES_OK_AND_EQ(TestInt(2), source());\n+  }\n+}\n+\n+TEST_P(SequencerTestFixture, SequenceStress) {\n+  constexpr int NITEMS = 100;\n+  for (auto task_index = 0; task_index < GetNumItersForStress(); task_index++) {\n+    auto input = RangeVector(NITEMS, 2);\n+    RandomShuffle(input);\n+    auto original = MakeSource(input);\n+    auto sequenced = MakeSequencingGenerator(original, cmp_, is_next_, TestInt(-2));\n+    AssertAsyncGeneratorMatch(RangeVector(NITEMS, 2), sequenced);\n+  }\n+}\n+\n+INSTANTIATE_TEST_SUITE_P(SequencerTests, SequencerTestFixture,\n+                         ::testing::Values(false, true));\n\nReview comment:\n       I'm probably being dense or distracted, but I don't see the parameter being used anywhere. Could you point it out to me? :-S\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-29T13:03:31.599+0000",
                    "updated": "2021-03-29T13:03:31.599+0000",
                    "started": "2021-03-29T13:03:31.599+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "573476",
                    "issueId": "13366987"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 14400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@567c8381[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@48e16895[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@77fa1724[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@341c7c8e[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1bd56538[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@19db56f5[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3e3f31dd[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@6910c298[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@59dc8627[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@1af30f17[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5d85744d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@32ee7967[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 14400,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Mar 30 09:41:36 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-03-30T09:41:36.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12056/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2021-03-23T13:20:27.000+0000",
        "updated": "2021-03-30T09:41:56.000+0000",
        "timeoriginalestimate": null,
        "description": "ARROW-7001 needs a sequencing operator to reorder fragments & scan tasks that arrive out of order.\u00a0 This AsyncGenerator would poll source and buffer results until the \"next\" result arrives.\u00a0 For example, given a source of 6,2,1,3,4,5 the operator would return 1,2,3,4,5,6 and would need to buffer 2 items (6 & 2 at the beginning).\r\n\r\nThe Next(T t) will be configurable via function.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "4h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 14400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Create sequencing AsyncGenerator",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13366987/comment/17311335",
                    "id": "17311335",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 9779\n[https://github.com/apache/arrow/pull/9779]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-03-30T09:41:36.770+0000",
                    "updated": "2021-03-30T09:41:36.770+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0p38o:",
        "customfield_12314139": null
    }
}