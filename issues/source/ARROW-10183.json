{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13333811",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811",
    "key": "ARROW-10183",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349493",
                "id": "12349493",
                "description": "",
                "name": "4.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-04-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "1.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 96000,
            "total": 96000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 96000,
            "total": 96000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10183/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 160,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/worklog/508277",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz opened a new pull request #8603:\nURL: https://github.com/apache/arrow/pull/8603\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-05T22:12:07.744+0000",
                    "updated": "2020-11-05T22:12:07.744+0000",
                    "started": "2020-11-05T22:12:07.744+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "508277",
                    "issueId": "13333811"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/worklog/508283",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8603:\nURL: https://github.com/apache/arrow/pull/8603#issuecomment-722680143\n\n\n   https://issues.apache.org/jira/browse/ARROW-10183\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-05T22:22:45.168+0000",
                    "updated": "2020-11-05T22:22:45.168+0000",
                    "started": "2020-11-05T22:22:45.167+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "508283",
                    "issueId": "13333811"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/worklog/522450",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz closed pull request #8603:\nURL: https://github.com/apache/arrow/pull/8603\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-09T22:34:33.267+0000",
                    "updated": "2020-12-09T22:34:33.267+0000",
                    "started": "2020-12-09T22:34:33.267+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "522450",
                    "issueId": "13333811"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/worklog/530810",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #9095:\nURL: https://github.com/apache/arrow/pull/9095#issuecomment-754142555\n\n\n   https://issues.apache.org/jira/browse/ARROW-10183\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-04T18:36:32.252+0000",
                    "updated": "2021-01-04T18:36:32.252+0000",
                    "started": "2021-01-04T18:36:32.252+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "530810",
                    "issueId": "13333811"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/worklog/530859",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] removed a comment on pull request #9095:\nURL: https://github.com/apache/arrow/pull/9095#issuecomment-754137607\n\n\n   <!--\n     Licensed to the Apache Software Foundation (ASF) under one\n     or more contributor license agreements.  See the NOTICE file\n     distributed with this work for additional information\n     regarding copyright ownership.  The ASF licenses this file\n     to you under the Apache License, Version 2.0 (the\n     \"License\"); you may not use this file except in compliance\n     with the License.  You may obtain a copy of the License at\n   \n       http://www.apache.org/licenses/LICENSE-2.0\n   \n     Unless required by applicable law or agreed to in writing,\n     software distributed under the License is distributed on an\n     \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n     KIND, either express or implied.  See the License for the\n     specific language governing permissions and limitations\n     under the License.\n   -->\n   \n   Thanks for opening a pull request!\n   \n   Could you open an issue for this pull request on JIRA?\n   https://issues.apache.org/jira/browse/ARROW\n   \n   Then could you also rename pull request title in the following format?\n   \n       ARROW-${JIRA_ID}: [${COMPONENT}] ${SUMMARY}\n   \n   See also:\n   \n     * [Other pull requests](https://github.com/apache/arrow/pulls/)\n     * [Contribution Guidelines - How to contribute patches](https://arrow.apache.org/docs/developers/contributing.html#how-to-contribute-patches)\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-04T20:08:53.717+0000",
                    "updated": "2021-01-04T20:08:53.717+0000",
                    "started": "2021-01-04T20:08:53.717+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "530859",
                    "issueId": "13333811"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/worklog/533224",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #9095:\nURL: https://github.com/apache/arrow/pull/9095#discussion_r554155616\n\n\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -35,6 +36,13 @@\n \n namespace arrow {\n \n+namespace detail {\n+\n+template <typename Signature>\n+using result_of_t = typename std::result_of<Signature>::type;\n\nReview comment:\n       It's technically legal to have this both here and in future.h, but for clarity we should probably have a single alias decl. util/functional.h would be a reasonable place to put it\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n+\n+  bool HasValue() const { return yield_value_.has_value(); }\n+  bool Finished() const { return finished_; }\n+  Status status() const { return status_; }\n+  bool Ok() const { return status_.ok(); }\n+  bool ReadyForNext() const { return ready_for_next_; }\n+  T Value() const { return *yield_value_; }\n+\n+  bool finished_;\n+  bool ready_for_next_;\n+  Status status_;\n+  util::optional<YieldValueType> yield_value_;\n+};\n+\n+struct TransformFinish {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(true, true);\n+  }\n+};\n+\n+struct TransformSkip {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(false, true);\n+  }\n+};\n+\n+template <typename T>\n+TransformFlow<T> TransformYield(T value = {}, bool ready_for_next = true) {\n+  return TransformFlow<T>(std::move(value), ready_for_next);\n+}\n+\n+template <typename T, typename V>\n+using Transformer = std::function<TransformFlow<V>(T)>;\n+\n+template <typename T, typename V>\n+class TransformIterator {\n+ public:\n+  explicit TransformIterator(Iterator<T> it, Transformer<T, V> transformer)\n+      : it_(std::move(it)),\n+        transformer_(std::move(transformer)),\n+        last_value_(),\n+        finished_() {}\n+\n+  util::optional<Result<V>> Pump() {\n+    while (!finished_ && last_value_.has_value()) {\n+      TransformFlow<V> next = transformer_(*last_value_);\n+      if (next.ReadyForNext()) {\n+        last_value_.reset();\n+      }\n+      if (next.Finished()) {\n+        finished_ = true;\n+      }\n+      if (!next.Ok()) {\n+        return next.status();\n+      }\n+      if (next.HasValue()) {\n+        return next.Value();\n+      }\n+    }\n+    if (finished_) {\n+      return IterationTraits<V>::End();\n+    }\n+    return util::optional<V>();\n+  }\n+\n+  Result<V> Next() {\n+    while (!finished_) {\n+      util::optional<Result<V>> next = Pump();\n+      if (next.has_value()) {\n+        return *next;\n+      }\n+      ARROW_ASSIGN_OR_RAISE(last_value_, it_.Next());\n+    }\n+    return IterationTraits<V>::End();\n+  }\n+\n+ private:\n+  Iterator<T> it_;\n+  Transformer<T, V> transformer_;\n+  util::optional<T> last_value_;\n+  bool finished_;\n\nReview comment:\n       ```suggestion\r\n     bool finished_ = false;\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n+\n+  bool HasValue() const { return yield_value_.has_value(); }\n+  bool Finished() const { return finished_; }\n+  Status status() const { return status_; }\n+  bool Ok() const { return status_.ok(); }\n+  bool ReadyForNext() const { return ready_for_next_; }\n+  T Value() const { return *yield_value_; }\n+\n+  bool finished_;\n+  bool ready_for_next_;\n+  Status status_;\n+  util::optional<YieldValueType> yield_value_;\n+};\n+\n+struct TransformFinish {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(true, true);\n+  }\n+};\n+\n+struct TransformSkip {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(false, true);\n+  }\n+};\n+\n+template <typename T>\n+TransformFlow<T> TransformYield(T value = {}, bool ready_for_next = true) {\n+  return TransformFlow<T>(std::move(value), ready_for_next);\n+}\n+\n+template <typename T, typename V>\n+using Transformer = std::function<TransformFlow<V>(T)>;\n+\n+template <typename T, typename V>\n+class TransformIterator {\n+ public:\n+  explicit TransformIterator(Iterator<T> it, Transformer<T, V> transformer)\n+      : it_(std::move(it)),\n+        transformer_(std::move(transformer)),\n+        last_value_(),\n+        finished_() {}\n+\n+  util::optional<Result<V>> Pump() {\n+    while (!finished_ && last_value_.has_value()) {\n\nReview comment:\n       This loop is very confusing. Could you rewrite it with a singular condition (`while (!finished_)`, maybe) then include a break statement below?\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n+\n+  bool HasValue() const { return yield_value_.has_value(); }\n+  bool Finished() const { return finished_; }\n+  Status status() const { return status_; }\n+  bool Ok() const { return status_.ok(); }\n+  bool ReadyForNext() const { return ready_for_next_; }\n+  T Value() const { return *yield_value_; }\n+\n+  bool finished_;\n+  bool ready_for_next_;\n+  Status status_;\n+  util::optional<YieldValueType> yield_value_;\n+};\n+\n+struct TransformFinish {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(true, true);\n+  }\n+};\n+\n+struct TransformSkip {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(false, true);\n+  }\n+};\n+\n+template <typename T>\n+TransformFlow<T> TransformYield(T value = {}, bool ready_for_next = true) {\n+  return TransformFlow<T>(std::move(value), ready_for_next);\n+}\n+\n+template <typename T, typename V>\n+using Transformer = std::function<TransformFlow<V>(T)>;\n+\n+template <typename T, typename V>\n+class TransformIterator {\n+ public:\n+  explicit TransformIterator(Iterator<T> it, Transformer<T, V> transformer)\n+      : it_(std::move(it)),\n+        transformer_(std::move(transformer)),\n+        last_value_(),\n+        finished_() {}\n+\n+  util::optional<Result<V>> Pump() {\n+    while (!finished_ && last_value_.has_value()) {\n+      TransformFlow<V> next = transformer_(*last_value_);\n+      if (next.ReadyForNext()) {\n+        last_value_.reset();\n+      }\n+      if (next.Finished()) {\n+        finished_ = true;\n+      }\n+      if (!next.Ok()) {\n+        return next.status();\n+      }\n+      if (next.HasValue()) {\n+        return next.Value();\n+      }\n+    }\n+    if (finished_) {\n+      return IterationTraits<V>::End();\n+    }\n+    return util::optional<V>();\n+  }\n+\n+  Result<V> Next() {\n+    while (!finished_) {\n+      util::optional<Result<V>> next = Pump();\n+      if (next.has_value()) {\n+        return *next;\n\nReview comment:\n       ```suggestion\r\n           return std::move(*next);\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -580,4 +611,73 @@ inline std::vector<int> WaitForAny(const std::vector<Future<T>*>& futures,\n   return waiter->MoveFinishedFutures();\n }\n \n+template <typename T = detail::Empty>\n+struct ControlFlow {\n+  using BreakValueType = T;\n+\n+  bool IsBreak() const { return break_value_.has_value(); }\n+\n+  static Result<BreakValueType> MoveBreakValue(const ControlFlow& cf) {\n+    return std::move(*cf.break_value_);\n+  }\n+\n+  mutable util::optional<BreakValueType> break_value_;\n+};\n+\n+struct Continue {\n+  template <typename T>\n+  operator ControlFlow<T>() && {  // NOLINT explicit\n+    return {};\n+  }\n+};\n+\n+template <typename T = detail::Empty>\n+ControlFlow<T> Break(T break_value = {}) {\n+  return ControlFlow<T>{std::move(break_value)};\n+}\n+\n+template <typename Iterate,\n+          typename Control = typename detail::result_of_t<Iterate()>::ValueType,\n+          typename BreakValueType = typename Control::BreakValueType>\n+Future<BreakValueType> Loop(Iterate iterate) {\n\nReview comment:\n       Maybe the typedef for AsyncGenerator would be useful here; then we could write\r\n   \r\n   ```suggestion\r\n   template <typename T>\r\n   using AsyncGenerator = std::function<Future<T>()>;\r\n   \r\n   template <typename BreakValue>\r\n   Future<BreakValue> Loop(AsyncGenerator<ControlFlow<BreakValue>> iterate) {\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -832,6 +832,145 @@ TEST(FutureCompletionTest, FutureVoid) {\n   }\n }\n \n+TEST(FutureAllTest, Simple) {\n+  auto f1 = Future<int>::Make();\n+  auto f2 = Future<int>::Make();\n+  std::vector<Future<int>> futures = {f1, f2};\n+  auto combined = arrow::All(futures);\n+\n+  ARROW_UNUSED(combined.Then([](std::vector<Result<int>> results) {\n+    ASSERT_EQ(2, results.size());\n+    ASSERT_EQ(1, *results[0]);\n+    ASSERT_EQ(2, *results[1]);\n+  }));\n+\n+  // Finish in reverse order, results should still be delivered in proper order\n+  AssertNotFinished(combined);\n+  f2.MarkFinished(2);\n+  AssertNotFinished(combined);\n+  f1.MarkFinished(1);\n+  AssertSuccessful(combined);\n+}\n+\n+TEST(FutureAllTest, Failure) {\n+  auto f1 = Future<int>::Make();\n+  auto f2 = Future<int>::Make();\n+  auto f3 = Future<int>::Make();\n+  std::vector<Future<int>> futures = {f1, f2, f3};\n+  auto combined = arrow::All(futures);\n+\n+  ARROW_UNUSED(combined.Then([](std::vector<Result<int>> results) {\n+    ASSERT_EQ(3, results.size());\n+    ASSERT_EQ(1, *results[0]);\n+    ASSERT_EQ(Status::IOError(\"XYZ\"), results[1].status());\n+    ASSERT_EQ(3, *results[2]);\n+  }));\n+\n+  f1.MarkFinished(1);\n+  f2.MarkFinished(Status::IOError(\"XYZ\"));\n+  f3.MarkFinished(3);\n+\n+  AssertFinished(combined);\n+}\n+\n+TEST(FutureLoopTest, Sync) {\n+  struct {\n+    int i = 0;\n+    Future<int> Get() { return Future<int>::MakeFinished(i++); }\n+  } IntSource;\n+\n+  bool do_fail = false;\n+  std::vector<int> ints;\n+  auto loop_body = [&] {\n+    return IntSource.Get().Then([&](int i) -> Result<ControlFlow<int>> {\n+      if (do_fail && i == 3) {\n+        return Status::IOError(\"xxx\");\n+      }\n+\n+      if (i == 5) {\n+        int sum = 0;\n+        for (int i : ints) sum += i;\n+        return Break(sum);\n+      }\n+\n+      ints.push_back(i);\n+      return Continue();\n+    });\n+  };\n+\n+  {\n+    auto sum_fut = Loop(loop_body);\n+    AssertSuccessful(sum_fut);\n+\n+    ASSERT_OK_AND_ASSIGN(auto sum, sum_fut.result());\n+    ASSERT_EQ(sum, 0 + 1 + 2 + 3 + 4);\n+  }\n+\n+  {\n+    do_fail = true;\n+    IntSource.i = 0;\n+    auto sum_fut = Loop(loop_body);\n+    AssertFailed(sum_fut);\n+    ASSERT_RAISES(IOError, sum_fut.result());\n+  }\n+}\n+\n+TEST(FutureLoopTest, EmptyBreakValue) {\n+  Future<> none_fut =\n+      Loop([&] { return Future<>::MakeFinished().Then([&](...) { return Break(); }); });\n+  AssertSuccessful(none_fut);\n+}\n+\n+TEST(FutureLoopTest, MoveOnlyBreakValue) {\n\nReview comment:\n       It'd be good to have a stress test for `Loop` as well\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n+\n+  bool HasValue() const { return yield_value_.has_value(); }\n+  bool Finished() const { return finished_; }\n+  Status status() const { return status_; }\n+  bool Ok() const { return status_.ok(); }\n+  bool ReadyForNext() const { return ready_for_next_; }\n+  T Value() const { return *yield_value_; }\n+\n+  bool finished_;\n+  bool ready_for_next_;\n+  Status status_;\n+  util::optional<YieldValueType> yield_value_;\n+};\n+\n+struct TransformFinish {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(true, true);\n+  }\n+};\n+\n+struct TransformSkip {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(false, true);\n+  }\n+};\n+\n+template <typename T>\n+TransformFlow<T> TransformYield(T value = {}, bool ready_for_next = true) {\n+  return TransformFlow<T>(std::move(value), ready_for_next);\n+}\n+\n+template <typename T, typename V>\n+using Transformer = std::function<TransformFlow<V>(T)>;\n+\n+template <typename T, typename V>\n+class TransformIterator {\n+ public:\n+  explicit TransformIterator(Iterator<T> it, Transformer<T, V> transformer)\n+      : it_(std::move(it)),\n+        transformer_(std::move(transformer)),\n+        last_value_(),\n+        finished_() {}\n+\n+  util::optional<Result<V>> Pump() {\n+    while (!finished_ && last_value_.has_value()) {\n\nReview comment:\n       Could you also include a comment describing the control flow, the contract of transformer functions, ...?\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n\nReview comment:\n       Instead of having TransformFlow potentially be an error, perhaps we could just rely on Result and have `using Transformer = std::function<Result<TransformFlow<V>>(T)>;`?\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n+\n+  bool HasValue() const { return yield_value_.has_value(); }\n+  bool Finished() const { return finished_; }\n+  Status status() const { return status_; }\n+  bool Ok() const { return status_.ok(); }\n+  bool ReadyForNext() const { return ready_for_next_; }\n+  T Value() const { return *yield_value_; }\n+\n+  bool finished_;\n+  bool ready_for_next_;\n+  Status status_;\n+  util::optional<YieldValueType> yield_value_;\n+};\n+\n+struct TransformFinish {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(true, true);\n+  }\n+};\n+\n+struct TransformSkip {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(false, true);\n+  }\n+};\n+\n+template <typename T>\n+TransformFlow<T> TransformYield(T value = {}, bool ready_for_next = true) {\n+  return TransformFlow<T>(std::move(value), ready_for_next);\n+}\n+\n+template <typename T, typename V>\n+using Transformer = std::function<TransformFlow<V>(T)>;\n+\n+template <typename T, typename V>\n+class TransformIterator {\n+ public:\n+  explicit TransformIterator(Iterator<T> it, Transformer<T, V> transformer)\n+      : it_(std::move(it)),\n+        transformer_(std::move(transformer)),\n+        last_value_(),\n+        finished_() {}\n+\n+  util::optional<Result<V>> Pump() {\n\nReview comment:\n       I'd usually expect `Result<>` to be outermost in a return type:\r\n   ```suggestion\r\n     Result<util::optional<V>> Pump() {\r\n   ```\r\n   Additionally, that'd enable you to use `ARROW_RETURN_NOT_OK` below\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n+\n+  bool HasValue() const { return yield_value_.has_value(); }\n+  bool Finished() const { return finished_; }\n+  Status status() const { return status_; }\n+  bool Ok() const { return status_.ok(); }\n+  bool ReadyForNext() const { return ready_for_next_; }\n+  T Value() const { return *yield_value_; }\n+\n+  bool finished_;\n+  bool ready_for_next_;\n\nReview comment:\n       Use member initializers for fields with no default constructor:\r\n   ```suggestion\r\n     bool finished_ = false;\r\n     bool ready_for_next_ = false;\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n+\n+  bool HasValue() const { return yield_value_.has_value(); }\n+  bool Finished() const { return finished_; }\n+  Status status() const { return status_; }\n+  bool Ok() const { return status_.ok(); }\n+  bool ReadyForNext() const { return ready_for_next_; }\n+  T Value() const { return *yield_value_; }\n+\n+  bool finished_;\n+  bool ready_for_next_;\n+  Status status_;\n+  util::optional<YieldValueType> yield_value_;\n+};\n+\n+struct TransformFinish {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(true, true);\n+  }\n+};\n+\n+struct TransformSkip {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(false, true);\n+  }\n+};\n+\n+template <typename T>\n+TransformFlow<T> TransformYield(T value = {}, bool ready_for_next = true) {\n+  return TransformFlow<T>(std::move(value), ready_for_next);\n+}\n+\n+template <typename T, typename V>\n+using Transformer = std::function<TransformFlow<V>(T)>;\n+\n+template <typename T, typename V>\n+class TransformIterator {\n+ public:\n+  explicit TransformIterator(Iterator<T> it, Transformer<T, V> transformer)\n+      : it_(std::move(it)),\n+        transformer_(std::move(transformer)),\n+        last_value_(),\n+        finished_() {}\n+\n+  util::optional<Result<V>> Pump() {\n+    while (!finished_ && last_value_.has_value()) {\n+      TransformFlow<V> next = transformer_(*last_value_);\n+      if (next.ReadyForNext()) {\n+        last_value_.reset();\n+      }\n+      if (next.Finished()) {\n+        finished_ = true;\n+      }\n+      if (!next.Ok()) {\n+        return next.status();\n+      }\n+      if (next.HasValue()) {\n+        return next.Value();\n+      }\n+    }\n+    if (finished_) {\n+      return IterationTraits<V>::End();\n+    }\n+    return util::optional<V>();\n\nReview comment:\n       This doesn't match the return type of the function, please use `return {};` or `return util::nullopt;` to be more clear\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -556,6 +560,33 @@ inline bool WaitForAll(const std::vector<Future<T>*>& futures,\n   return waiter->Wait(seconds);\n }\n \n+template <typename T>\n\nReview comment:\n       ```suggestion\r\n   /// \\brief Create a Future which completes when all of `futures` complete.\r\n   ///\r\n   /// The future's result is a vector of the results of `futures`.\r\n   /// Note that this future will never be marked \"failed\"; failed results\r\n   /// will be stored in the result vector alongside successful results.\r\n   template <typename T>\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/iterator.cc\n##########\n@@ -67,6 +67,8 @@ class ReadaheadQueue::Impl : public std::enable_shared_from_this<ReadaheadQueue:\n   }\n \n   Status PopDone(std::unique_ptr<ReadaheadPromise>* out) {\n+    DCHECK_GT(max_readahead_, 0);  // This function has no purpose and should not be\n+                                   // called if using the queue unbounded\n\nReview comment:\n       `DCHECK` macros (except `DCHECK_OK`) can be streamed into, which makes assert failures more helpful and searchable:\r\n   ```suggestion\r\n       DCHECK_GT(max_readahead_, 0) << \"PopDone should never be called if using the queue unbounded\";\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -832,6 +832,145 @@ TEST(FutureCompletionTest, FutureVoid) {\n   }\n }\n \n+TEST(FutureAllTest, Simple) {\n+  auto f1 = Future<int>::Make();\n+  auto f2 = Future<int>::Make();\n+  std::vector<Future<int>> futures = {f1, f2};\n+  auto combined = arrow::All(futures);\n+\n+  ARROW_UNUSED(combined.Then([](std::vector<Result<int>> results) {\n+    ASSERT_EQ(2, results.size());\n+    ASSERT_EQ(1, *results[0]);\n+    ASSERT_EQ(2, *results[1]);\n+  }));\n+\n+  // Finish in reverse order, results should still be delivered in proper order\n+  AssertNotFinished(combined);\n+  f2.MarkFinished(2);\n+  AssertNotFinished(combined);\n+  f1.MarkFinished(1);\n+  AssertSuccessful(combined);\n+}\n+\n+TEST(FutureAllTest, Failure) {\n+  auto f1 = Future<int>::Make();\n+  auto f2 = Future<int>::Make();\n+  auto f3 = Future<int>::Make();\n+  std::vector<Future<int>> futures = {f1, f2, f3};\n+  auto combined = arrow::All(futures);\n+\n+  ARROW_UNUSED(combined.Then([](std::vector<Result<int>> results) {\n+    ASSERT_EQ(3, results.size());\n+    ASSERT_EQ(1, *results[0]);\n+    ASSERT_EQ(Status::IOError(\"XYZ\"), results[1].status());\n+    ASSERT_EQ(3, *results[2]);\n+  }));\n+\n+  f1.MarkFinished(1);\n+  f2.MarkFinished(Status::IOError(\"XYZ\"));\n+  f3.MarkFinished(3);\n+\n+  AssertFinished(combined);\n+}\n+\n+TEST(FutureLoopTest, Sync) {\n+  struct {\n+    int i = 0;\n+    Future<int> Get() { return Future<int>::MakeFinished(i++); }\n+  } IntSource;\n+\n+  bool do_fail = false;\n+  std::vector<int> ints;\n+  auto loop_body = [&] {\n+    return IntSource.Get().Then([&](int i) -> Result<ControlFlow<int>> {\n+      if (do_fail && i == 3) {\n+        return Status::IOError(\"xxx\");\n+      }\n+\n+      if (i == 5) {\n+        int sum = 0;\n+        for (int i : ints) sum += i;\n+        return Break(sum);\n+      }\n+\n+      ints.push_back(i);\n+      return Continue();\n+    });\n+  };\n+\n+  {\n+    auto sum_fut = Loop(loop_body);\n+    AssertSuccessful(sum_fut);\n+\n+    ASSERT_OK_AND_ASSIGN(auto sum, sum_fut.result());\n+    ASSERT_EQ(sum, 0 + 1 + 2 + 3 + 4);\n+  }\n+\n+  {\n+    do_fail = true;\n+    IntSource.i = 0;\n+    auto sum_fut = Loop(loop_body);\n+    AssertFailed(sum_fut);\n+    ASSERT_RAISES(IOError, sum_fut.result());\n+  }\n+}\n+\n+TEST(FutureLoopTest, EmptyBreakValue) {\n+  Future<> none_fut =\n+      Loop([&] { return Future<>::MakeFinished().Then([&](...) { return Break(); }); });\n+  AssertSuccessful(none_fut);\n+}\n+\n+TEST(FutureLoopTest, MoveOnlyBreakValue) {\n+  Future<MoveOnlyDataType> one_fut = Loop([&] {\n+    return Future<int>::MakeFinished(1).Then(\n+        [&](int i) { return Break(MoveOnlyDataType(i)); });\n+  });\n+  AssertSuccessful(one_fut);\n+  ASSERT_OK_AND_ASSIGN(auto one, std::move(one_fut).result());\n+  ASSERT_EQ(one, 1);\n+}\n+\n+TEST(FutureLoopTest, StackOverflow) {\n+  // Looping over futures is normally a rather recursive task.  If the futures complete\n+  // synchronously (because they are already finished) it could lead to a stack overflow\n+  // if care is not taken.\n+  int counter = 0;\n+  auto loop_body = [&counter]() -> Future<ControlFlow<int>> {\n+    while (counter < 1000000) {\n+      counter++;\n+      return Future<ControlFlow<int>>::MakeFinished(Continue());\n\nReview comment:\n       Maybe it'd be useful to have an implicit constructor `Future<T>(Result<T>)` for finished futures, then I think we'd be able to just write\r\n   ```c++\r\n         return Continue();\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -580,4 +611,73 @@ inline std::vector<int> WaitForAny(const std::vector<Future<T>*>& futures,\n   return waiter->MoveFinishedFutures();\n }\n \n+template <typename T = detail::Empty>\n+struct ControlFlow {\n+  using BreakValueType = T;\n+\n+  bool IsBreak() const { return break_value_.has_value(); }\n+\n+  static Result<BreakValueType> MoveBreakValue(const ControlFlow& cf) {\n+    return std::move(*cf.break_value_);\n+  }\n+\n+  mutable util::optional<BreakValueType> break_value_;\n+};\n+\n+struct Continue {\n+  template <typename T>\n+  operator ControlFlow<T>() && {  // NOLINT explicit\n+    return {};\n+  }\n+};\n+\n+template <typename T = detail::Empty>\n+ControlFlow<T> Break(T break_value = {}) {\n+  return ControlFlow<T>{std::move(break_value)};\n+}\n+\n+template <typename Iterate,\n\nReview comment:\n       ```suggestion\r\n   /// \\brief Loop through an asynchronous sequence\r\n   ///\r\n   /// \\param[in] iterate A generator of Future<ControlFlow<BreakValue>>. On completion of each yielded\r\n   /// future the resulting ControlFlow will be examined. A Break will terminate the loop, while a Continue\r\n   /// will re-invoke `iterate`.\r\n   /// \\return A future which will complete when a Future returned by iterate completes with a Break\r\n   template <typename Iterate,\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/iterator_test.cc\n##########\n@@ -129,11 +130,47 @@ template <typename T>\n inline Iterator<T> EmptyIt() {\n   return MakeEmptyIterator<T>();\n }\n-\n inline Iterator<TestInt> VectorIt(std::vector<TestInt> v) {\n   return MakeVectorIterator<TestInt>(std::move(v));\n }\n \n+std::function<Future<TestInt>()> AsyncVectorIt(std::vector<TestInt> v) {\n+  auto index = std::make_shared<size_t>(0);\n+  auto vec = std::make_shared<std::vector<TestInt>>(std::move(v));\n+  return [index, vec]() -> Future<TestInt> {\n+    if (*index >= vec->size()) {\n+      return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\n+    }\n+    auto next = (*vec)[*index];\n+    (*index)++;\n+    return Future<TestInt>::MakeFinished(next);\n+  };\n\nReview comment:\n       ```suggestion\r\n     size_t index = 0;\r\n     return [index, v]() mutable -> Future<TestInt> {\r\n       if (index >= vec.size()) {\r\n         return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\r\n       }\r\n       return Future<TestInt>::MakeFinished(v[index++]);\r\n     };\r\n   ```\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-08T21:08:45.485+0000",
                    "updated": "2021-01-08T21:08:45.485+0000",
                    "started": "2021-01-08T21:08:45.485+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "533224",
                    "issueId": "13333811"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/worklog/533871",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #9095:\nURL: https://github.com/apache/arrow/pull/9095#discussion_r554155616\n\n\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -35,6 +36,13 @@\n \n namespace arrow {\n \n+namespace detail {\n+\n+template <typename Signature>\n+using result_of_t = typename std::result_of<Signature>::type;\n\nReview comment:\n       It's technically legal to have this both here and in future.h, but for clarity we should probably have a single alias decl. util/functional.h would be a reasonable place to put it\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n+\n+  bool HasValue() const { return yield_value_.has_value(); }\n+  bool Finished() const { return finished_; }\n+  Status status() const { return status_; }\n+  bool Ok() const { return status_.ok(); }\n+  bool ReadyForNext() const { return ready_for_next_; }\n+  T Value() const { return *yield_value_; }\n+\n+  bool finished_;\n+  bool ready_for_next_;\n+  Status status_;\n+  util::optional<YieldValueType> yield_value_;\n+};\n+\n+struct TransformFinish {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(true, true);\n+  }\n+};\n+\n+struct TransformSkip {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(false, true);\n+  }\n+};\n+\n+template <typename T>\n+TransformFlow<T> TransformYield(T value = {}, bool ready_for_next = true) {\n+  return TransformFlow<T>(std::move(value), ready_for_next);\n+}\n+\n+template <typename T, typename V>\n+using Transformer = std::function<TransformFlow<V>(T)>;\n+\n+template <typename T, typename V>\n+class TransformIterator {\n+ public:\n+  explicit TransformIterator(Iterator<T> it, Transformer<T, V> transformer)\n+      : it_(std::move(it)),\n+        transformer_(std::move(transformer)),\n+        last_value_(),\n+        finished_() {}\n+\n+  util::optional<Result<V>> Pump() {\n+    while (!finished_ && last_value_.has_value()) {\n+      TransformFlow<V> next = transformer_(*last_value_);\n+      if (next.ReadyForNext()) {\n+        last_value_.reset();\n+      }\n+      if (next.Finished()) {\n+        finished_ = true;\n+      }\n+      if (!next.Ok()) {\n+        return next.status();\n+      }\n+      if (next.HasValue()) {\n+        return next.Value();\n+      }\n+    }\n+    if (finished_) {\n+      return IterationTraits<V>::End();\n+    }\n+    return util::optional<V>();\n+  }\n+\n+  Result<V> Next() {\n+    while (!finished_) {\n+      util::optional<Result<V>> next = Pump();\n+      if (next.has_value()) {\n+        return *next;\n+      }\n+      ARROW_ASSIGN_OR_RAISE(last_value_, it_.Next());\n+    }\n+    return IterationTraits<V>::End();\n+  }\n+\n+ private:\n+  Iterator<T> it_;\n+  Transformer<T, V> transformer_;\n+  util::optional<T> last_value_;\n+  bool finished_;\n\nReview comment:\n       ```suggestion\r\n     bool finished_ = false;\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n+\n+  bool HasValue() const { return yield_value_.has_value(); }\n+  bool Finished() const { return finished_; }\n+  Status status() const { return status_; }\n+  bool Ok() const { return status_.ok(); }\n+  bool ReadyForNext() const { return ready_for_next_; }\n+  T Value() const { return *yield_value_; }\n+\n+  bool finished_;\n+  bool ready_for_next_;\n+  Status status_;\n+  util::optional<YieldValueType> yield_value_;\n+};\n+\n+struct TransformFinish {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(true, true);\n+  }\n+};\n+\n+struct TransformSkip {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(false, true);\n+  }\n+};\n+\n+template <typename T>\n+TransformFlow<T> TransformYield(T value = {}, bool ready_for_next = true) {\n+  return TransformFlow<T>(std::move(value), ready_for_next);\n+}\n+\n+template <typename T, typename V>\n+using Transformer = std::function<TransformFlow<V>(T)>;\n+\n+template <typename T, typename V>\n+class TransformIterator {\n+ public:\n+  explicit TransformIterator(Iterator<T> it, Transformer<T, V> transformer)\n+      : it_(std::move(it)),\n+        transformer_(std::move(transformer)),\n+        last_value_(),\n+        finished_() {}\n+\n+  util::optional<Result<V>> Pump() {\n+    while (!finished_ && last_value_.has_value()) {\n\nReview comment:\n       This loop is very confusing. Could you rewrite it with a singular condition (`while (!finished_)`, maybe) then include a break statement below?\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n+\n+  bool HasValue() const { return yield_value_.has_value(); }\n+  bool Finished() const { return finished_; }\n+  Status status() const { return status_; }\n+  bool Ok() const { return status_.ok(); }\n+  bool ReadyForNext() const { return ready_for_next_; }\n+  T Value() const { return *yield_value_; }\n+\n+  bool finished_;\n+  bool ready_for_next_;\n+  Status status_;\n+  util::optional<YieldValueType> yield_value_;\n+};\n+\n+struct TransformFinish {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(true, true);\n+  }\n+};\n+\n+struct TransformSkip {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(false, true);\n+  }\n+};\n+\n+template <typename T>\n+TransformFlow<T> TransformYield(T value = {}, bool ready_for_next = true) {\n+  return TransformFlow<T>(std::move(value), ready_for_next);\n+}\n+\n+template <typename T, typename V>\n+using Transformer = std::function<TransformFlow<V>(T)>;\n+\n+template <typename T, typename V>\n+class TransformIterator {\n+ public:\n+  explicit TransformIterator(Iterator<T> it, Transformer<T, V> transformer)\n+      : it_(std::move(it)),\n+        transformer_(std::move(transformer)),\n+        last_value_(),\n+        finished_() {}\n+\n+  util::optional<Result<V>> Pump() {\n+    while (!finished_ && last_value_.has_value()) {\n+      TransformFlow<V> next = transformer_(*last_value_);\n+      if (next.ReadyForNext()) {\n+        last_value_.reset();\n+      }\n+      if (next.Finished()) {\n+        finished_ = true;\n+      }\n+      if (!next.Ok()) {\n+        return next.status();\n+      }\n+      if (next.HasValue()) {\n+        return next.Value();\n+      }\n+    }\n+    if (finished_) {\n+      return IterationTraits<V>::End();\n+    }\n+    return util::optional<V>();\n+  }\n+\n+  Result<V> Next() {\n+    while (!finished_) {\n+      util::optional<Result<V>> next = Pump();\n+      if (next.has_value()) {\n+        return *next;\n\nReview comment:\n       ```suggestion\r\n           return std::move(*next);\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -580,4 +611,73 @@ inline std::vector<int> WaitForAny(const std::vector<Future<T>*>& futures,\n   return waiter->MoveFinishedFutures();\n }\n \n+template <typename T = detail::Empty>\n+struct ControlFlow {\n+  using BreakValueType = T;\n+\n+  bool IsBreak() const { return break_value_.has_value(); }\n+\n+  static Result<BreakValueType> MoveBreakValue(const ControlFlow& cf) {\n+    return std::move(*cf.break_value_);\n+  }\n+\n+  mutable util::optional<BreakValueType> break_value_;\n+};\n+\n+struct Continue {\n+  template <typename T>\n+  operator ControlFlow<T>() && {  // NOLINT explicit\n+    return {};\n+  }\n+};\n+\n+template <typename T = detail::Empty>\n+ControlFlow<T> Break(T break_value = {}) {\n+  return ControlFlow<T>{std::move(break_value)};\n+}\n+\n+template <typename Iterate,\n+          typename Control = typename detail::result_of_t<Iterate()>::ValueType,\n+          typename BreakValueType = typename Control::BreakValueType>\n+Future<BreakValueType> Loop(Iterate iterate) {\n\nReview comment:\n       Maybe the typedef for AsyncGenerator would be useful here; then we could write\r\n   \r\n   ```suggestion\r\n   template <typename T>\r\n   using AsyncGenerator = std::function<Future<T>()>;\r\n   \r\n   template <typename BreakValue>\r\n   Future<BreakValue> Loop(AsyncGenerator<ControlFlow<BreakValue>> iterate) {\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -832,6 +832,145 @@ TEST(FutureCompletionTest, FutureVoid) {\n   }\n }\n \n+TEST(FutureAllTest, Simple) {\n+  auto f1 = Future<int>::Make();\n+  auto f2 = Future<int>::Make();\n+  std::vector<Future<int>> futures = {f1, f2};\n+  auto combined = arrow::All(futures);\n+\n+  ARROW_UNUSED(combined.Then([](std::vector<Result<int>> results) {\n+    ASSERT_EQ(2, results.size());\n+    ASSERT_EQ(1, *results[0]);\n+    ASSERT_EQ(2, *results[1]);\n+  }));\n+\n+  // Finish in reverse order, results should still be delivered in proper order\n+  AssertNotFinished(combined);\n+  f2.MarkFinished(2);\n+  AssertNotFinished(combined);\n+  f1.MarkFinished(1);\n+  AssertSuccessful(combined);\n+}\n+\n+TEST(FutureAllTest, Failure) {\n+  auto f1 = Future<int>::Make();\n+  auto f2 = Future<int>::Make();\n+  auto f3 = Future<int>::Make();\n+  std::vector<Future<int>> futures = {f1, f2, f3};\n+  auto combined = arrow::All(futures);\n+\n+  ARROW_UNUSED(combined.Then([](std::vector<Result<int>> results) {\n+    ASSERT_EQ(3, results.size());\n+    ASSERT_EQ(1, *results[0]);\n+    ASSERT_EQ(Status::IOError(\"XYZ\"), results[1].status());\n+    ASSERT_EQ(3, *results[2]);\n+  }));\n+\n+  f1.MarkFinished(1);\n+  f2.MarkFinished(Status::IOError(\"XYZ\"));\n+  f3.MarkFinished(3);\n+\n+  AssertFinished(combined);\n+}\n+\n+TEST(FutureLoopTest, Sync) {\n+  struct {\n+    int i = 0;\n+    Future<int> Get() { return Future<int>::MakeFinished(i++); }\n+  } IntSource;\n+\n+  bool do_fail = false;\n+  std::vector<int> ints;\n+  auto loop_body = [&] {\n+    return IntSource.Get().Then([&](int i) -> Result<ControlFlow<int>> {\n+      if (do_fail && i == 3) {\n+        return Status::IOError(\"xxx\");\n+      }\n+\n+      if (i == 5) {\n+        int sum = 0;\n+        for (int i : ints) sum += i;\n+        return Break(sum);\n+      }\n+\n+      ints.push_back(i);\n+      return Continue();\n+    });\n+  };\n+\n+  {\n+    auto sum_fut = Loop(loop_body);\n+    AssertSuccessful(sum_fut);\n+\n+    ASSERT_OK_AND_ASSIGN(auto sum, sum_fut.result());\n+    ASSERT_EQ(sum, 0 + 1 + 2 + 3 + 4);\n+  }\n+\n+  {\n+    do_fail = true;\n+    IntSource.i = 0;\n+    auto sum_fut = Loop(loop_body);\n+    AssertFailed(sum_fut);\n+    ASSERT_RAISES(IOError, sum_fut.result());\n+  }\n+}\n+\n+TEST(FutureLoopTest, EmptyBreakValue) {\n+  Future<> none_fut =\n+      Loop([&] { return Future<>::MakeFinished().Then([&](...) { return Break(); }); });\n+  AssertSuccessful(none_fut);\n+}\n+\n+TEST(FutureLoopTest, MoveOnlyBreakValue) {\n\nReview comment:\n       It'd be good to have a stress test for `Loop` as well\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n+\n+  bool HasValue() const { return yield_value_.has_value(); }\n+  bool Finished() const { return finished_; }\n+  Status status() const { return status_; }\n+  bool Ok() const { return status_.ok(); }\n+  bool ReadyForNext() const { return ready_for_next_; }\n+  T Value() const { return *yield_value_; }\n+\n+  bool finished_;\n+  bool ready_for_next_;\n+  Status status_;\n+  util::optional<YieldValueType> yield_value_;\n+};\n+\n+struct TransformFinish {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(true, true);\n+  }\n+};\n+\n+struct TransformSkip {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(false, true);\n+  }\n+};\n+\n+template <typename T>\n+TransformFlow<T> TransformYield(T value = {}, bool ready_for_next = true) {\n+  return TransformFlow<T>(std::move(value), ready_for_next);\n+}\n+\n+template <typename T, typename V>\n+using Transformer = std::function<TransformFlow<V>(T)>;\n+\n+template <typename T, typename V>\n+class TransformIterator {\n+ public:\n+  explicit TransformIterator(Iterator<T> it, Transformer<T, V> transformer)\n+      : it_(std::move(it)),\n+        transformer_(std::move(transformer)),\n+        last_value_(),\n+        finished_() {}\n+\n+  util::optional<Result<V>> Pump() {\n+    while (!finished_ && last_value_.has_value()) {\n\nReview comment:\n       Could you also include a comment describing the control flow, the contract of transformer functions, ...?\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n\nReview comment:\n       Instead of having TransformFlow potentially be an error, perhaps we could just rely on Result and have `using Transformer = std::function<Result<TransformFlow<V>>(T)>;`?\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n+\n+  bool HasValue() const { return yield_value_.has_value(); }\n+  bool Finished() const { return finished_; }\n+  Status status() const { return status_; }\n+  bool Ok() const { return status_.ok(); }\n+  bool ReadyForNext() const { return ready_for_next_; }\n+  T Value() const { return *yield_value_; }\n+\n+  bool finished_;\n+  bool ready_for_next_;\n+  Status status_;\n+  util::optional<YieldValueType> yield_value_;\n+};\n+\n+struct TransformFinish {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(true, true);\n+  }\n+};\n+\n+struct TransformSkip {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(false, true);\n+  }\n+};\n+\n+template <typename T>\n+TransformFlow<T> TransformYield(T value = {}, bool ready_for_next = true) {\n+  return TransformFlow<T>(std::move(value), ready_for_next);\n+}\n+\n+template <typename T, typename V>\n+using Transformer = std::function<TransformFlow<V>(T)>;\n+\n+template <typename T, typename V>\n+class TransformIterator {\n+ public:\n+  explicit TransformIterator(Iterator<T> it, Transformer<T, V> transformer)\n+      : it_(std::move(it)),\n+        transformer_(std::move(transformer)),\n+        last_value_(),\n+        finished_() {}\n+\n+  util::optional<Result<V>> Pump() {\n\nReview comment:\n       I'd usually expect `Result<>` to be outermost in a return type:\r\n   ```suggestion\r\n     Result<util::optional<V>> Pump() {\r\n   ```\r\n   Additionally, that'd enable you to use `ARROW_RETURN_NOT_OK` below\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n+\n+  bool HasValue() const { return yield_value_.has_value(); }\n+  bool Finished() const { return finished_; }\n+  Status status() const { return status_; }\n+  bool Ok() const { return status_.ok(); }\n+  bool ReadyForNext() const { return ready_for_next_; }\n+  T Value() const { return *yield_value_; }\n+\n+  bool finished_;\n+  bool ready_for_next_;\n\nReview comment:\n       Use member initializers for fields with no default constructor:\r\n   ```suggestion\r\n     bool finished_ = false;\r\n     bool ready_for_next_ = false;\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n+\n+  bool HasValue() const { return yield_value_.has_value(); }\n+  bool Finished() const { return finished_; }\n+  Status status() const { return status_; }\n+  bool Ok() const { return status_.ok(); }\n+  bool ReadyForNext() const { return ready_for_next_; }\n+  T Value() const { return *yield_value_; }\n+\n+  bool finished_;\n+  bool ready_for_next_;\n+  Status status_;\n+  util::optional<YieldValueType> yield_value_;\n+};\n+\n+struct TransformFinish {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(true, true);\n+  }\n+};\n+\n+struct TransformSkip {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(false, true);\n+  }\n+};\n+\n+template <typename T>\n+TransformFlow<T> TransformYield(T value = {}, bool ready_for_next = true) {\n+  return TransformFlow<T>(std::move(value), ready_for_next);\n+}\n+\n+template <typename T, typename V>\n+using Transformer = std::function<TransformFlow<V>(T)>;\n+\n+template <typename T, typename V>\n+class TransformIterator {\n+ public:\n+  explicit TransformIterator(Iterator<T> it, Transformer<T, V> transformer)\n+      : it_(std::move(it)),\n+        transformer_(std::move(transformer)),\n+        last_value_(),\n+        finished_() {}\n+\n+  util::optional<Result<V>> Pump() {\n+    while (!finished_ && last_value_.has_value()) {\n+      TransformFlow<V> next = transformer_(*last_value_);\n+      if (next.ReadyForNext()) {\n+        last_value_.reset();\n+      }\n+      if (next.Finished()) {\n+        finished_ = true;\n+      }\n+      if (!next.Ok()) {\n+        return next.status();\n+      }\n+      if (next.HasValue()) {\n+        return next.Value();\n+      }\n+    }\n+    if (finished_) {\n+      return IterationTraits<V>::End();\n+    }\n+    return util::optional<V>();\n\nReview comment:\n       This doesn't match the return type of the function, please use `return {};` or `return util::nullopt;` to be more clear\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -556,6 +560,33 @@ inline bool WaitForAll(const std::vector<Future<T>*>& futures,\n   return waiter->Wait(seconds);\n }\n \n+template <typename T>\n\nReview comment:\n       ```suggestion\r\n   /// \\brief Create a Future which completes when all of `futures` complete.\r\n   ///\r\n   /// The future's result is a vector of the results of `futures`.\r\n   /// Note that this future will never be marked \"failed\"; failed results\r\n   /// will be stored in the result vector alongside successful results.\r\n   template <typename T>\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/iterator.cc\n##########\n@@ -67,6 +67,8 @@ class ReadaheadQueue::Impl : public std::enable_shared_from_this<ReadaheadQueue:\n   }\n \n   Status PopDone(std::unique_ptr<ReadaheadPromise>* out) {\n+    DCHECK_GT(max_readahead_, 0);  // This function has no purpose and should not be\n+                                   // called if using the queue unbounded\n\nReview comment:\n       `DCHECK` macros (except `DCHECK_OK`) can be streamed into, which makes assert failures more helpful and searchable:\r\n   ```suggestion\r\n       DCHECK_GT(max_readahead_, 0) << \"PopDone should never be called if using the queue unbounded\";\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -832,6 +832,145 @@ TEST(FutureCompletionTest, FutureVoid) {\n   }\n }\n \n+TEST(FutureAllTest, Simple) {\n+  auto f1 = Future<int>::Make();\n+  auto f2 = Future<int>::Make();\n+  std::vector<Future<int>> futures = {f1, f2};\n+  auto combined = arrow::All(futures);\n+\n+  ARROW_UNUSED(combined.Then([](std::vector<Result<int>> results) {\n+    ASSERT_EQ(2, results.size());\n+    ASSERT_EQ(1, *results[0]);\n+    ASSERT_EQ(2, *results[1]);\n+  }));\n+\n+  // Finish in reverse order, results should still be delivered in proper order\n+  AssertNotFinished(combined);\n+  f2.MarkFinished(2);\n+  AssertNotFinished(combined);\n+  f1.MarkFinished(1);\n+  AssertSuccessful(combined);\n+}\n+\n+TEST(FutureAllTest, Failure) {\n+  auto f1 = Future<int>::Make();\n+  auto f2 = Future<int>::Make();\n+  auto f3 = Future<int>::Make();\n+  std::vector<Future<int>> futures = {f1, f2, f3};\n+  auto combined = arrow::All(futures);\n+\n+  ARROW_UNUSED(combined.Then([](std::vector<Result<int>> results) {\n+    ASSERT_EQ(3, results.size());\n+    ASSERT_EQ(1, *results[0]);\n+    ASSERT_EQ(Status::IOError(\"XYZ\"), results[1].status());\n+    ASSERT_EQ(3, *results[2]);\n+  }));\n+\n+  f1.MarkFinished(1);\n+  f2.MarkFinished(Status::IOError(\"XYZ\"));\n+  f3.MarkFinished(3);\n+\n+  AssertFinished(combined);\n+}\n+\n+TEST(FutureLoopTest, Sync) {\n+  struct {\n+    int i = 0;\n+    Future<int> Get() { return Future<int>::MakeFinished(i++); }\n+  } IntSource;\n+\n+  bool do_fail = false;\n+  std::vector<int> ints;\n+  auto loop_body = [&] {\n+    return IntSource.Get().Then([&](int i) -> Result<ControlFlow<int>> {\n+      if (do_fail && i == 3) {\n+        return Status::IOError(\"xxx\");\n+      }\n+\n+      if (i == 5) {\n+        int sum = 0;\n+        for (int i : ints) sum += i;\n+        return Break(sum);\n+      }\n+\n+      ints.push_back(i);\n+      return Continue();\n+    });\n+  };\n+\n+  {\n+    auto sum_fut = Loop(loop_body);\n+    AssertSuccessful(sum_fut);\n+\n+    ASSERT_OK_AND_ASSIGN(auto sum, sum_fut.result());\n+    ASSERT_EQ(sum, 0 + 1 + 2 + 3 + 4);\n+  }\n+\n+  {\n+    do_fail = true;\n+    IntSource.i = 0;\n+    auto sum_fut = Loop(loop_body);\n+    AssertFailed(sum_fut);\n+    ASSERT_RAISES(IOError, sum_fut.result());\n+  }\n+}\n+\n+TEST(FutureLoopTest, EmptyBreakValue) {\n+  Future<> none_fut =\n+      Loop([&] { return Future<>::MakeFinished().Then([&](...) { return Break(); }); });\n+  AssertSuccessful(none_fut);\n+}\n+\n+TEST(FutureLoopTest, MoveOnlyBreakValue) {\n+  Future<MoveOnlyDataType> one_fut = Loop([&] {\n+    return Future<int>::MakeFinished(1).Then(\n+        [&](int i) { return Break(MoveOnlyDataType(i)); });\n+  });\n+  AssertSuccessful(one_fut);\n+  ASSERT_OK_AND_ASSIGN(auto one, std::move(one_fut).result());\n+  ASSERT_EQ(one, 1);\n+}\n+\n+TEST(FutureLoopTest, StackOverflow) {\n+  // Looping over futures is normally a rather recursive task.  If the futures complete\n+  // synchronously (because they are already finished) it could lead to a stack overflow\n+  // if care is not taken.\n+  int counter = 0;\n+  auto loop_body = [&counter]() -> Future<ControlFlow<int>> {\n+    while (counter < 1000000) {\n+      counter++;\n+      return Future<ControlFlow<int>>::MakeFinished(Continue());\n\nReview comment:\n       Maybe it'd be useful to have an implicit constructor `Future<T>(Result<T>)` for finished futures, then I think we'd be able to just write\r\n   ```c++\r\n         return Continue();\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -580,4 +611,73 @@ inline std::vector<int> WaitForAny(const std::vector<Future<T>*>& futures,\n   return waiter->MoveFinishedFutures();\n }\n \n+template <typename T = detail::Empty>\n+struct ControlFlow {\n+  using BreakValueType = T;\n+\n+  bool IsBreak() const { return break_value_.has_value(); }\n+\n+  static Result<BreakValueType> MoveBreakValue(const ControlFlow& cf) {\n+    return std::move(*cf.break_value_);\n+  }\n+\n+  mutable util::optional<BreakValueType> break_value_;\n+};\n+\n+struct Continue {\n+  template <typename T>\n+  operator ControlFlow<T>() && {  // NOLINT explicit\n+    return {};\n+  }\n+};\n+\n+template <typename T = detail::Empty>\n+ControlFlow<T> Break(T break_value = {}) {\n+  return ControlFlow<T>{std::move(break_value)};\n+}\n+\n+template <typename Iterate,\n\nReview comment:\n       ```suggestion\r\n   /// \\brief Loop through an asynchronous sequence\r\n   ///\r\n   /// \\param[in] iterate A generator of Future<ControlFlow<BreakValue>>. On completion of each yielded\r\n   /// future the resulting ControlFlow will be examined. A Break will terminate the loop, while a Continue\r\n   /// will re-invoke `iterate`.\r\n   /// \\return A future which will complete when a Future returned by iterate completes with a Break\r\n   template <typename Iterate,\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/iterator_test.cc\n##########\n@@ -129,11 +130,47 @@ template <typename T>\n inline Iterator<T> EmptyIt() {\n   return MakeEmptyIterator<T>();\n }\n-\n inline Iterator<TestInt> VectorIt(std::vector<TestInt> v) {\n   return MakeVectorIterator<TestInt>(std::move(v));\n }\n \n+std::function<Future<TestInt>()> AsyncVectorIt(std::vector<TestInt> v) {\n+  auto index = std::make_shared<size_t>(0);\n+  auto vec = std::make_shared<std::vector<TestInt>>(std::move(v));\n+  return [index, vec]() -> Future<TestInt> {\n+    if (*index >= vec->size()) {\n+      return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\n+    }\n+    auto next = (*vec)[*index];\n+    (*index)++;\n+    return Future<TestInt>::MakeFinished(next);\n+  };\n\nReview comment:\n       ```suggestion\r\n     size_t index = 0;\r\n     return [index, v]() mutable -> Future<TestInt> {\r\n       if (index >= vec.size()) {\r\n         return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\r\n       }\r\n       return Future<TestInt>::MakeFinished(v[index++]);\r\n     };\r\n   ```\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-10T04:27:24.322+0000",
                    "updated": "2021-01-10T04:27:24.322+0000",
                    "started": "2021-01-10T04:27:24.322+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "533871",
                    "issueId": "13333811"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/worklog/534344",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9095:\nURL: https://github.com/apache/arrow/pull/9095#discussion_r555194510\n\n\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -35,6 +36,13 @@\n \n namespace arrow {\n \n+namespace detail {\n+\n+template <typename Signature>\n+using result_of_t = typename std::result_of<Signature>::type;\n\nReview comment:\n       It was unused in iterator.h so I just removed it.  I think I pulled it in because I was using Loop as a base for the transforming iterator but it mutated enough to longer require this.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-11T16:54:29.240+0000",
                    "updated": "2021-01-11T16:54:29.240+0000",
                    "started": "2021-01-11T16:54:29.239+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534344",
                    "issueId": "13333811"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/worklog/534345",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9095:\nURL: https://github.com/apache/arrow/pull/9095#discussion_r555194653\n\n\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n+\n+  bool HasValue() const { return yield_value_.has_value(); }\n+  bool Finished() const { return finished_; }\n+  Status status() const { return status_; }\n+  bool Ok() const { return status_.ok(); }\n+  bool ReadyForNext() const { return ready_for_next_; }\n+  T Value() const { return *yield_value_; }\n+\n+  bool finished_;\n+  bool ready_for_next_;\n\nReview comment:\n       done\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n+\n+  bool HasValue() const { return yield_value_.has_value(); }\n+  bool Finished() const { return finished_; }\n+  Status status() const { return status_; }\n+  bool Ok() const { return status_.ok(); }\n+  bool ReadyForNext() const { return ready_for_next_; }\n+  T Value() const { return *yield_value_; }\n+\n+  bool finished_;\n+  bool ready_for_next_;\n+  Status status_;\n+  util::optional<YieldValueType> yield_value_;\n+};\n+\n+struct TransformFinish {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(true, true);\n+  }\n+};\n+\n+struct TransformSkip {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(false, true);\n+  }\n+};\n+\n+template <typename T>\n+TransformFlow<T> TransformYield(T value = {}, bool ready_for_next = true) {\n+  return TransformFlow<T>(std::move(value), ready_for_next);\n+}\n+\n+template <typename T, typename V>\n+using Transformer = std::function<TransformFlow<V>(T)>;\n+\n+template <typename T, typename V>\n+class TransformIterator {\n+ public:\n+  explicit TransformIterator(Iterator<T> it, Transformer<T, V> transformer)\n+      : it_(std::move(it)),\n+        transformer_(std::move(transformer)),\n+        last_value_(),\n+        finished_() {}\n+\n+  util::optional<Result<V>> Pump() {\n+    while (!finished_ && last_value_.has_value()) {\n+      TransformFlow<V> next = transformer_(*last_value_);\n+      if (next.ReadyForNext()) {\n+        last_value_.reset();\n+      }\n+      if (next.Finished()) {\n+        finished_ = true;\n+      }\n+      if (!next.Ok()) {\n+        return next.status();\n+      }\n+      if (next.HasValue()) {\n+        return next.Value();\n+      }\n+    }\n+    if (finished_) {\n+      return IterationTraits<V>::End();\n+    }\n+    return util::optional<V>();\n+  }\n+\n+  Result<V> Next() {\n+    while (!finished_) {\n+      util::optional<Result<V>> next = Pump();\n+      if (next.has_value()) {\n+        return *next;\n+      }\n+      ARROW_ASSIGN_OR_RAISE(last_value_, it_.Next());\n+    }\n+    return IterationTraits<V>::End();\n+  }\n+\n+ private:\n+  Iterator<T> it_;\n+  Transformer<T, V> transformer_;\n+  util::optional<T> last_value_;\n+  bool finished_;\n\nReview comment:\n       done\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-11T16:54:52.446+0000",
                    "updated": "2021-01-11T16:54:52.446+0000",
                    "started": "2021-01-11T16:54:52.445+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534345",
                    "issueId": "13333811"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/worklog/534346",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9095:\nURL: https://github.com/apache/arrow/pull/9095#discussion_r555194884\n\n\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n\nReview comment:\n       Done, this is much simpler.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-11T16:55:05.657+0000",
                    "updated": "2021-01-11T16:55:05.657+0000",
                    "started": "2021-01-11T16:55:05.657+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534346",
                    "issueId": "13333811"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/worklog/534347",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9095:\nURL: https://github.com/apache/arrow/pull/9095#discussion_r555195471\n\n\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n+\n+  bool HasValue() const { return yield_value_.has_value(); }\n+  bool Finished() const { return finished_; }\n+  Status status() const { return status_; }\n+  bool Ok() const { return status_.ok(); }\n+  bool ReadyForNext() const { return ready_for_next_; }\n+  T Value() const { return *yield_value_; }\n+\n+  bool finished_;\n+  bool ready_for_next_;\n+  Status status_;\n+  util::optional<YieldValueType> yield_value_;\n+};\n+\n+struct TransformFinish {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(true, true);\n+  }\n+};\n+\n+struct TransformSkip {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(false, true);\n+  }\n+};\n+\n+template <typename T>\n+TransformFlow<T> TransformYield(T value = {}, bool ready_for_next = true) {\n+  return TransformFlow<T>(std::move(value), ready_for_next);\n+}\n+\n+template <typename T, typename V>\n+using Transformer = std::function<TransformFlow<V>(T)>;\n+\n+template <typename T, typename V>\n+class TransformIterator {\n+ public:\n+  explicit TransformIterator(Iterator<T> it, Transformer<T, V> transformer)\n+      : it_(std::move(it)),\n+        transformer_(std::move(transformer)),\n+        last_value_(),\n+        finished_() {}\n+\n+  util::optional<Result<V>> Pump() {\n+    while (!finished_ && last_value_.has_value()) {\n\nReview comment:\n       I added a comment to MakeTransformedIterator and TransformAsynchronousGenerator.  I also cleaned up the logic in these loops a little.  In fact, `Pump` no longer contains a `while` loop as it was guaranteed to be executed only once anyways.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-11T16:55:59.287+0000",
                    "updated": "2021-01-11T16:55:59.287+0000",
                    "started": "2021-01-11T16:55:59.287+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534347",
                    "issueId": "13333811"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/worklog/534408",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9095:\nURL: https://github.com/apache/arrow/pull/9095#discussion_r555259293\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -580,4 +611,73 @@ inline std::vector<int> WaitForAny(const std::vector<Future<T>*>& futures,\n   return waiter->MoveFinishedFutures();\n }\n \n+template <typename T = detail::Empty>\n+struct ControlFlow {\n+  using BreakValueType = T;\n+\n+  bool IsBreak() const { return break_value_.has_value(); }\n+\n+  static Result<BreakValueType> MoveBreakValue(const ControlFlow& cf) {\n+    return std::move(*cf.break_value_);\n+  }\n+\n+  mutable util::optional<BreakValueType> break_value_;\n+};\n+\n+struct Continue {\n+  template <typename T>\n+  operator ControlFlow<T>() && {  // NOLINT explicit\n+    return {};\n+  }\n+};\n+\n+template <typename T = detail::Empty>\n+ControlFlow<T> Break(T break_value = {}) {\n+  return ControlFlow<T>{std::move(break_value)};\n+}\n+\n+template <typename Iterate,\n+          typename Control = typename detail::result_of_t<Iterate()>::ValueType,\n+          typename BreakValueType = typename Control::BreakValueType>\n+Future<BreakValueType> Loop(Iterate iterate) {\n\nReview comment:\n       As long as you don't mind changing Loop to use std::function instead of a template parameter?  It's not a big change but it is different.\r\n   \r\n   I think this fits as you can sort of (implicitly) think of `Break(...) == IterationTraits<ControlFlow<T>>::End()`\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-11T18:38:47.826+0000",
                    "updated": "2021-01-11T18:38:47.826+0000",
                    "started": "2021-01-11T18:38:47.826+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534408",
                    "issueId": "13333811"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/worklog/534413",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9095:\nURL: https://github.com/apache/arrow/pull/9095#discussion_r555260518\n\n\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n+\n+  bool HasValue() const { return yield_value_.has_value(); }\n+  bool Finished() const { return finished_; }\n+  Status status() const { return status_; }\n+  bool Ok() const { return status_.ok(); }\n+  bool ReadyForNext() const { return ready_for_next_; }\n+  T Value() const { return *yield_value_; }\n+\n+  bool finished_;\n+  bool ready_for_next_;\n+  Status status_;\n+  util::optional<YieldValueType> yield_value_;\n+};\n+\n+struct TransformFinish {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(true, true);\n+  }\n+};\n+\n+struct TransformSkip {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(false, true);\n+  }\n+};\n+\n+template <typename T>\n+TransformFlow<T> TransformYield(T value = {}, bool ready_for_next = true) {\n+  return TransformFlow<T>(std::move(value), ready_for_next);\n+}\n+\n+template <typename T, typename V>\n+using Transformer = std::function<TransformFlow<V>(T)>;\n+\n+template <typename T, typename V>\n+class TransformIterator {\n+ public:\n+  explicit TransformIterator(Iterator<T> it, Transformer<T, V> transformer)\n+      : it_(std::move(it)),\n+        transformer_(std::move(transformer)),\n+        last_value_(),\n+        finished_() {}\n+\n+  util::optional<Result<V>> Pump() {\n+    while (!finished_ && last_value_.has_value()) {\n\nReview comment:\n       I added comments to MakeTransformedIterator and TransformAsyncGenerator\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-11T18:41:14.808+0000",
                    "updated": "2021-01-11T18:41:14.808+0000",
                    "started": "2021-01-11T18:41:14.808+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534413",
                    "issueId": "13333811"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/worklog/534414",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9095:\nURL: https://github.com/apache/arrow/pull/9095#discussion_r555260697\n\n\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n\nReview comment:\n       Done.\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n+\n+  bool HasValue() const { return yield_value_.has_value(); }\n+  bool Finished() const { return finished_; }\n+  Status status() const { return status_; }\n+  bool Ok() const { return status_.ok(); }\n+  bool ReadyForNext() const { return ready_for_next_; }\n+  T Value() const { return *yield_value_; }\n+\n+  bool finished_;\n+  bool ready_for_next_;\n+  Status status_;\n+  util::optional<YieldValueType> yield_value_;\n+};\n+\n+struct TransformFinish {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(true, true);\n+  }\n+};\n+\n+struct TransformSkip {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(false, true);\n+  }\n+};\n+\n+template <typename T>\n+TransformFlow<T> TransformYield(T value = {}, bool ready_for_next = true) {\n+  return TransformFlow<T>(std::move(value), ready_for_next);\n+}\n+\n+template <typename T, typename V>\n+using Transformer = std::function<TransformFlow<V>(T)>;\n+\n+template <typename T, typename V>\n+class TransformIterator {\n+ public:\n+  explicit TransformIterator(Iterator<T> it, Transformer<T, V> transformer)\n+      : it_(std::move(it)),\n+        transformer_(std::move(transformer)),\n+        last_value_(),\n+        finished_() {}\n+\n+  util::optional<Result<V>> Pump() {\n+    while (!finished_ && last_value_.has_value()) {\n+      TransformFlow<V> next = transformer_(*last_value_);\n+      if (next.ReadyForNext()) {\n+        last_value_.reset();\n+      }\n+      if (next.Finished()) {\n+        finished_ = true;\n+      }\n+      if (!next.Ok()) {\n+        return next.status();\n+      }\n+      if (next.HasValue()) {\n+        return next.Value();\n+      }\n+    }\n+    if (finished_) {\n+      return IterationTraits<V>::End();\n+    }\n+    return util::optional<V>();\n+  }\n+\n+  Result<V> Next() {\n+    while (!finished_) {\n+      util::optional<Result<V>> next = Pump();\n+      if (next.has_value()) {\n+        return *next;\n+      }\n+      ARROW_ASSIGN_OR_RAISE(last_value_, it_.Next());\n+    }\n+    return IterationTraits<V>::End();\n+  }\n+\n+ private:\n+  Iterator<T> it_;\n+  Transformer<T, V> transformer_;\n+  util::optional<T> last_value_;\n+  bool finished_;\n\nReview comment:\n       Done\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +194,109 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        status_(),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), status_(), yield_value_() {}\n+  TransformFlow(Status s)  // NOLINT runtime/explicit\n+      : finished_(true), ready_for_next_(false), status_(s), yield_value_() {}\n+\n+  bool HasValue() const { return yield_value_.has_value(); }\n+  bool Finished() const { return finished_; }\n+  Status status() const { return status_; }\n+  bool Ok() const { return status_.ok(); }\n+  bool ReadyForNext() const { return ready_for_next_; }\n+  T Value() const { return *yield_value_; }\n+\n+  bool finished_;\n+  bool ready_for_next_;\n\nReview comment:\n       Done\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-11T18:41:37.853+0000",
                    "updated": "2021-01-11T18:41:37.853+0000",
                    "started": "2021-01-11T18:41:37.853+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534414",
                    "issueId": "13333811"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/worklog/534415",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9095:\nURL: https://github.com/apache/arrow/pull/9095#discussion_r555261490\n\n\n\n##########\nFile path: cpp/src/arrow/util/iterator_test.cc\n##########\n@@ -129,11 +130,47 @@ template <typename T>\n inline Iterator<T> EmptyIt() {\n   return MakeEmptyIterator<T>();\n }\n-\n inline Iterator<TestInt> VectorIt(std::vector<TestInt> v) {\n   return MakeVectorIterator<TestInt>(std::move(v));\n }\n \n+std::function<Future<TestInt>()> AsyncVectorIt(std::vector<TestInt> v) {\n+  auto index = std::make_shared<size_t>(0);\n+  auto vec = std::make_shared<std::vector<TestInt>>(std::move(v));\n+  return [index, vec]() -> Future<TestInt> {\n+    if (*index >= vec->size()) {\n+      return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\n+    }\n+    auto next = (*vec)[*index];\n+    (*index)++;\n+    return Future<TestInt>::MakeFinished(next);\n+  };\n\nReview comment:\n       This is good.  I changed all of the tests in iterator_test.cc to make use of captured lambda state instead of shared pointer state.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-11T18:42:55.086+0000",
                    "updated": "2021-01-11T18:42:55.086+0000",
                    "started": "2021-01-11T18:42:55.086+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534415",
                    "issueId": "13333811"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/worklog/534434",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9095:\nURL: https://github.com/apache/arrow/pull/9095#discussion_r555266265\n\n\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -832,6 +832,145 @@ TEST(FutureCompletionTest, FutureVoid) {\n   }\n }\n \n+TEST(FutureAllTest, Simple) {\n+  auto f1 = Future<int>::Make();\n+  auto f2 = Future<int>::Make();\n+  std::vector<Future<int>> futures = {f1, f2};\n+  auto combined = arrow::All(futures);\n+\n+  ARROW_UNUSED(combined.Then([](std::vector<Result<int>> results) {\n+    ASSERT_EQ(2, results.size());\n+    ASSERT_EQ(1, *results[0]);\n+    ASSERT_EQ(2, *results[1]);\n+  }));\n+\n+  // Finish in reverse order, results should still be delivered in proper order\n+  AssertNotFinished(combined);\n+  f2.MarkFinished(2);\n+  AssertNotFinished(combined);\n+  f1.MarkFinished(1);\n+  AssertSuccessful(combined);\n+}\n+\n+TEST(FutureAllTest, Failure) {\n+  auto f1 = Future<int>::Make();\n+  auto f2 = Future<int>::Make();\n+  auto f3 = Future<int>::Make();\n+  std::vector<Future<int>> futures = {f1, f2, f3};\n+  auto combined = arrow::All(futures);\n+\n+  ARROW_UNUSED(combined.Then([](std::vector<Result<int>> results) {\n+    ASSERT_EQ(3, results.size());\n+    ASSERT_EQ(1, *results[0]);\n+    ASSERT_EQ(Status::IOError(\"XYZ\"), results[1].status());\n+    ASSERT_EQ(3, *results[2]);\n+  }));\n+\n+  f1.MarkFinished(1);\n+  f2.MarkFinished(Status::IOError(\"XYZ\"));\n+  f3.MarkFinished(3);\n+\n+  AssertFinished(combined);\n+}\n+\n+TEST(FutureLoopTest, Sync) {\n+  struct {\n+    int i = 0;\n+    Future<int> Get() { return Future<int>::MakeFinished(i++); }\n+  } IntSource;\n+\n+  bool do_fail = false;\n+  std::vector<int> ints;\n+  auto loop_body = [&] {\n+    return IntSource.Get().Then([&](int i) -> Result<ControlFlow<int>> {\n+      if (do_fail && i == 3) {\n+        return Status::IOError(\"xxx\");\n+      }\n+\n+      if (i == 5) {\n+        int sum = 0;\n+        for (int i : ints) sum += i;\n+        return Break(sum);\n+      }\n+\n+      ints.push_back(i);\n+      return Continue();\n+    });\n+  };\n+\n+  {\n+    auto sum_fut = Loop(loop_body);\n+    AssertSuccessful(sum_fut);\n+\n+    ASSERT_OK_AND_ASSIGN(auto sum, sum_fut.result());\n+    ASSERT_EQ(sum, 0 + 1 + 2 + 3 + 4);\n+  }\n+\n+  {\n+    do_fail = true;\n+    IntSource.i = 0;\n+    auto sum_fut = Loop(loop_body);\n+    AssertFailed(sum_fut);\n+    ASSERT_RAISES(IOError, sum_fut.result());\n+  }\n+}\n+\n+TEST(FutureLoopTest, EmptyBreakValue) {\n+  Future<> none_fut =\n+      Loop([&] { return Future<>::MakeFinished().Then([&](...) { return Break(); }); });\n+  AssertSuccessful(none_fut);\n+}\n+\n+TEST(FutureLoopTest, MoveOnlyBreakValue) {\n+  Future<MoveOnlyDataType> one_fut = Loop([&] {\n+    return Future<int>::MakeFinished(1).Then(\n+        [&](int i) { return Break(MoveOnlyDataType(i)); });\n+  });\n+  AssertSuccessful(one_fut);\n+  ASSERT_OK_AND_ASSIGN(auto one, std::move(one_fut).result());\n+  ASSERT_EQ(one, 1);\n+}\n+\n+TEST(FutureLoopTest, StackOverflow) {\n+  // Looping over futures is normally a rather recursive task.  If the futures complete\n+  // synchronously (because they are already finished) it could lead to a stack overflow\n+  // if care is not taken.\n+  int counter = 0;\n+  auto loop_body = [&counter]() -> Future<ControlFlow<int>> {\n+    while (counter < 1000000) {\n+      counter++;\n+      return Future<ControlFlow<int>>::MakeFinished(Continue());\n\nReview comment:\n       Hmm...I'm a little torn here.  Could this make return type inference even harder?  For example, if you change\r\n   \r\n   ```\r\n   auto some_future = [] {\r\n     if (some_base_case) {\r\n       return Future<T>::MakeFinished(0);\r\n     }\r\n     return SomeAsyncFunction.Then(...);\r\n   };\r\n   ```\r\n   \r\n   to...\r\n   \r\n   ```\r\n   auto some_future = [] {\r\n     if (some_base_case) {\r\n       return 0;\r\n     }\r\n     return SomeAsyncFunction.Then(...);\r\n   };\r\n   ```\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-11T18:51:39.544+0000",
                    "updated": "2021-01-11T18:51:39.544+0000",
                    "started": "2021-01-11T18:51:39.544+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534434",
                    "issueId": "13333811"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/worklog/534964",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #9095:\nURL: https://github.com/apache/arrow/pull/9095#discussion_r555975697\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -580,4 +611,73 @@ inline std::vector<int> WaitForAny(const std::vector<Future<T>*>& futures,\n   return waiter->MoveFinishedFutures();\n }\n \n+template <typename T = detail::Empty>\n+struct ControlFlow {\n+  using BreakValueType = T;\n+\n+  bool IsBreak() const { return break_value_.has_value(); }\n+\n+  static Result<BreakValueType> MoveBreakValue(const ControlFlow& cf) {\n+    return std::move(*cf.break_value_);\n+  }\n+\n+  mutable util::optional<BreakValueType> break_value_;\n+};\n+\n+struct Continue {\n+  template <typename T>\n+  operator ControlFlow<T>() && {  // NOLINT explicit\n+    return {};\n+  }\n+};\n+\n+template <typename T = detail::Empty>\n+ControlFlow<T> Break(T break_value = {}) {\n+  return ControlFlow<T>{std::move(break_value)};\n+}\n+\n+template <typename Iterate,\n+          typename Control = typename detail::result_of_t<Iterate()>::ValueType,\n+          typename BreakValueType = typename Control::BreakValueType>\n+Future<BreakValueType> Loop(Iterate iterate) {\n\nReview comment:\n       NVM; type deduction isn't clever enough to infer return type like this\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-12T18:12:10.353+0000",
                    "updated": "2021-01-12T18:12:10.353+0000",
                    "started": "2021-01-12T18:12:10.353+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534964",
                    "issueId": "13333811"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/worklog/535064",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #9095:\nURL: https://github.com/apache/arrow/pull/9095#discussion_r556129806\n\n\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -832,6 +832,145 @@ TEST(FutureCompletionTest, FutureVoid) {\n   }\n }\n \n+TEST(FutureAllTest, Simple) {\n+  auto f1 = Future<int>::Make();\n+  auto f2 = Future<int>::Make();\n+  std::vector<Future<int>> futures = {f1, f2};\n+  auto combined = arrow::All(futures);\n+\n+  ARROW_UNUSED(combined.Then([](std::vector<Result<int>> results) {\n+    ASSERT_EQ(2, results.size());\n+    ASSERT_EQ(1, *results[0]);\n+    ASSERT_EQ(2, *results[1]);\n+  }));\n+\n+  // Finish in reverse order, results should still be delivered in proper order\n+  AssertNotFinished(combined);\n+  f2.MarkFinished(2);\n+  AssertNotFinished(combined);\n+  f1.MarkFinished(1);\n+  AssertSuccessful(combined);\n+}\n+\n+TEST(FutureAllTest, Failure) {\n+  auto f1 = Future<int>::Make();\n+  auto f2 = Future<int>::Make();\n+  auto f3 = Future<int>::Make();\n+  std::vector<Future<int>> futures = {f1, f2, f3};\n+  auto combined = arrow::All(futures);\n+\n+  ARROW_UNUSED(combined.Then([](std::vector<Result<int>> results) {\n+    ASSERT_EQ(3, results.size());\n+    ASSERT_EQ(1, *results[0]);\n+    ASSERT_EQ(Status::IOError(\"XYZ\"), results[1].status());\n+    ASSERT_EQ(3, *results[2]);\n+  }));\n+\n+  f1.MarkFinished(1);\n+  f2.MarkFinished(Status::IOError(\"XYZ\"));\n+  f3.MarkFinished(3);\n+\n+  AssertFinished(combined);\n+}\n+\n+TEST(FutureLoopTest, Sync) {\n+  struct {\n+    int i = 0;\n+    Future<int> Get() { return Future<int>::MakeFinished(i++); }\n+  } IntSource;\n+\n+  bool do_fail = false;\n+  std::vector<int> ints;\n+  auto loop_body = [&] {\n+    return IntSource.Get().Then([&](int i) -> Result<ControlFlow<int>> {\n+      if (do_fail && i == 3) {\n+        return Status::IOError(\"xxx\");\n+      }\n+\n+      if (i == 5) {\n+        int sum = 0;\n+        for (int i : ints) sum += i;\n+        return Break(sum);\n+      }\n+\n+      ints.push_back(i);\n+      return Continue();\n+    });\n+  };\n+\n+  {\n+    auto sum_fut = Loop(loop_body);\n+    AssertSuccessful(sum_fut);\n+\n+    ASSERT_OK_AND_ASSIGN(auto sum, sum_fut.result());\n+    ASSERT_EQ(sum, 0 + 1 + 2 + 3 + 4);\n+  }\n+\n+  {\n+    do_fail = true;\n+    IntSource.i = 0;\n+    auto sum_fut = Loop(loop_body);\n+    AssertFailed(sum_fut);\n+    ASSERT_RAISES(IOError, sum_fut.result());\n+  }\n+}\n+\n+TEST(FutureLoopTest, EmptyBreakValue) {\n+  Future<> none_fut =\n+      Loop([&] { return Future<>::MakeFinished().Then([&](...) { return Break(); }); });\n+  AssertSuccessful(none_fut);\n+}\n+\n+TEST(FutureLoopTest, MoveOnlyBreakValue) {\n+  Future<MoveOnlyDataType> one_fut = Loop([&] {\n+    return Future<int>::MakeFinished(1).Then(\n+        [&](int i) { return Break(MoveOnlyDataType(i)); });\n+  });\n+  AssertSuccessful(one_fut);\n+  ASSERT_OK_AND_ASSIGN(auto one, std::move(one_fut).result());\n+  ASSERT_EQ(one, 1);\n+}\n+\n+TEST(FutureLoopTest, StackOverflow) {\n+  // Looping over futures is normally a rather recursive task.  If the futures complete\n+  // synchronously (because they are already finished) it could lead to a stack overflow\n+  // if care is not taken.\n+  int counter = 0;\n+  auto loop_body = [&counter]() -> Future<ControlFlow<int>> {\n+    while (counter < 1000000) {\n+      counter++;\n+      return Future<ControlFlow<int>>::MakeFinished(Continue());\n\nReview comment:\n       For lambdas without an explicit trailing return type, all return statements *must* return the same type. \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-12T22:12:43.318+0000",
                    "updated": "2021-01-12T22:12:43.318+0000",
                    "started": "2021-01-12T22:12:43.318+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "535064",
                    "issueId": "13333811"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/worklog/535066",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #9095:\nURL: https://github.com/apache/arrow/pull/9095#discussion_r556129806\n\n\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -832,6 +832,145 @@ TEST(FutureCompletionTest, FutureVoid) {\n   }\n }\n \n+TEST(FutureAllTest, Simple) {\n+  auto f1 = Future<int>::Make();\n+  auto f2 = Future<int>::Make();\n+  std::vector<Future<int>> futures = {f1, f2};\n+  auto combined = arrow::All(futures);\n+\n+  ARROW_UNUSED(combined.Then([](std::vector<Result<int>> results) {\n+    ASSERT_EQ(2, results.size());\n+    ASSERT_EQ(1, *results[0]);\n+    ASSERT_EQ(2, *results[1]);\n+  }));\n+\n+  // Finish in reverse order, results should still be delivered in proper order\n+  AssertNotFinished(combined);\n+  f2.MarkFinished(2);\n+  AssertNotFinished(combined);\n+  f1.MarkFinished(1);\n+  AssertSuccessful(combined);\n+}\n+\n+TEST(FutureAllTest, Failure) {\n+  auto f1 = Future<int>::Make();\n+  auto f2 = Future<int>::Make();\n+  auto f3 = Future<int>::Make();\n+  std::vector<Future<int>> futures = {f1, f2, f3};\n+  auto combined = arrow::All(futures);\n+\n+  ARROW_UNUSED(combined.Then([](std::vector<Result<int>> results) {\n+    ASSERT_EQ(3, results.size());\n+    ASSERT_EQ(1, *results[0]);\n+    ASSERT_EQ(Status::IOError(\"XYZ\"), results[1].status());\n+    ASSERT_EQ(3, *results[2]);\n+  }));\n+\n+  f1.MarkFinished(1);\n+  f2.MarkFinished(Status::IOError(\"XYZ\"));\n+  f3.MarkFinished(3);\n+\n+  AssertFinished(combined);\n+}\n+\n+TEST(FutureLoopTest, Sync) {\n+  struct {\n+    int i = 0;\n+    Future<int> Get() { return Future<int>::MakeFinished(i++); }\n+  } IntSource;\n+\n+  bool do_fail = false;\n+  std::vector<int> ints;\n+  auto loop_body = [&] {\n+    return IntSource.Get().Then([&](int i) -> Result<ControlFlow<int>> {\n+      if (do_fail && i == 3) {\n+        return Status::IOError(\"xxx\");\n+      }\n+\n+      if (i == 5) {\n+        int sum = 0;\n+        for (int i : ints) sum += i;\n+        return Break(sum);\n+      }\n+\n+      ints.push_back(i);\n+      return Continue();\n+    });\n+  };\n+\n+  {\n+    auto sum_fut = Loop(loop_body);\n+    AssertSuccessful(sum_fut);\n+\n+    ASSERT_OK_AND_ASSIGN(auto sum, sum_fut.result());\n+    ASSERT_EQ(sum, 0 + 1 + 2 + 3 + 4);\n+  }\n+\n+  {\n+    do_fail = true;\n+    IntSource.i = 0;\n+    auto sum_fut = Loop(loop_body);\n+    AssertFailed(sum_fut);\n+    ASSERT_RAISES(IOError, sum_fut.result());\n+  }\n+}\n+\n+TEST(FutureLoopTest, EmptyBreakValue) {\n+  Future<> none_fut =\n+      Loop([&] { return Future<>::MakeFinished().Then([&](...) { return Break(); }); });\n+  AssertSuccessful(none_fut);\n+}\n+\n+TEST(FutureLoopTest, MoveOnlyBreakValue) {\n+  Future<MoveOnlyDataType> one_fut = Loop([&] {\n+    return Future<int>::MakeFinished(1).Then(\n+        [&](int i) { return Break(MoveOnlyDataType(i)); });\n+  });\n+  AssertSuccessful(one_fut);\n+  ASSERT_OK_AND_ASSIGN(auto one, std::move(one_fut).result());\n+  ASSERT_EQ(one, 1);\n+}\n+\n+TEST(FutureLoopTest, StackOverflow) {\n+  // Looping over futures is normally a rather recursive task.  If the futures complete\n+  // synchronously (because they are already finished) it could lead to a stack overflow\n+  // if care is not taken.\n+  int counter = 0;\n+  auto loop_body = [&counter]() -> Future<ControlFlow<int>> {\n+    while (counter < 1000000) {\n+      counter++;\n+      return Future<ControlFlow<int>>::MakeFinished(Continue());\n\nReview comment:\n       For lambdas without an explicit trailing return type, all return statements *must* return the same type, so you'd have to choose which boilerplate is preferable. IMHO, the trailing return type and implicit conversion look prettiest\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-12T22:14:11.451+0000",
                    "updated": "2021-01-12T22:14:11.451+0000",
                    "started": "2021-01-12T22:14:11.450+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "535066",
                    "issueId": "13333811"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/worklog/542257",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #9095:\nURL: https://github.com/apache/arrow/pull/9095#discussion_r564534403\n\n\n\n##########\nFile path: cpp/src/arrow/csv/reader_benchmark.cc\n##########\n@@ -0,0 +1,139 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"benchmark/benchmark.h\"\n+\n+#include <string>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/csv/options.h\"\n+#include \"arrow/csv/reader.h\"\n+#include \"arrow/csv/test_common.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+namespace csv {\n+\n+class SlowInputStream : public io::InputStream {\n\nReview comment:\n       Hmm... why don't you use `SlowInputStream` from `arrow/io/slow.h`?\n\n##########\nFile path: cpp/src/arrow/csv/reader_benchmark.cc\n##########\n@@ -0,0 +1,139 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"benchmark/benchmark.h\"\n+\n+#include <string>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/csv/options.h\"\n+#include \"arrow/csv/reader.h\"\n+#include \"arrow/csv/test_common.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+namespace csv {\n+\n+class SlowInputStream : public io::InputStream {\n+ public:\n+  explicit SlowInputStream(std::shared_ptr<io::BufferReader> target, int64_t latency_ms)\n+      : target_(std::move(target)) {\n+    latency_s_ = static_cast<double>(latency_ms) / 1000.0;\n+  }\n+  virtual ~SlowInputStream() {}\n+\n+  Result<util::string_view> Peek(int64_t nbytes) override {\n+    return target_->Peek(nbytes);\n+  }\n+  bool supports_zero_copy() const override { return target_->supports_zero_copy(); }\n+  Status Close() override { return target_->Close(); }\n+  Status Abort() override { return target_->Abort(); }\n+  Result<int64_t> Tell() const override { return target_->Tell(); }\n+  bool closed() const override { return target_->closed(); }\n+  Result<int64_t> Read(int64_t nbytes, void* out) override {\n+    if (latency_s_ > 0) {\n+      SleepFor(latency_s_);\n+    }\n+    return target_->Read(nbytes, out);\n+  }\n+  Result<std::shared_ptr<Buffer>> Read(int64_t nbytes) override {\n+    if (latency_s_ > 0) {\n+      SleepFor(latency_s_);\n+    }\n+    return target_->Read(nbytes);\n+  }\n+  Status Seek(int64_t pos) { return target_->Seek(pos); }\n+\n+ private:\n+  std::shared_ptr<io::BufferReader> target_;\n+  double latency_s_;\n+};\n+\n+static ReadOptions CreateReadOptions(bool use_threads, bool use_async) {\n+  auto result = csv::ReadOptions::Defaults();\n+  result.use_threads = use_threads;\n+  result.legacy_blocking_reads = !use_async;\n+  // Simulate larger files by using smaller block files so the impact of multiple\n+  // blocks is seen but we don't have to spend the time waiting on the large I/O\n\nReview comment:\n       I'm not sure this is exactly the same. Using a very small block size (I assume the below is 10kB?) may emphasize fixed costs (managing vectors of shared_ptrs etc.) rather than actual reading/parsing costs.\r\n   \n\n##########\nFile path: cpp/src/arrow/csv/reader_benchmark.cc\n##########\n@@ -0,0 +1,139 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"benchmark/benchmark.h\"\n+\n+#include <string>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/csv/options.h\"\n+#include \"arrow/csv/reader.h\"\n+#include \"arrow/csv/test_common.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+namespace csv {\n+\n+class SlowInputStream : public io::InputStream {\n+ public:\n+  explicit SlowInputStream(std::shared_ptr<io::BufferReader> target, int64_t latency_ms)\n+      : target_(std::move(target)) {\n+    latency_s_ = static_cast<double>(latency_ms) / 1000.0;\n+  }\n+  virtual ~SlowInputStream() {}\n+\n+  Result<util::string_view> Peek(int64_t nbytes) override {\n+    return target_->Peek(nbytes);\n+  }\n+  bool supports_zero_copy() const override { return target_->supports_zero_copy(); }\n+  Status Close() override { return target_->Close(); }\n+  Status Abort() override { return target_->Abort(); }\n+  Result<int64_t> Tell() const override { return target_->Tell(); }\n+  bool closed() const override { return target_->closed(); }\n+  Result<int64_t> Read(int64_t nbytes, void* out) override {\n+    if (latency_s_ > 0) {\n+      SleepFor(latency_s_);\n+    }\n+    return target_->Read(nbytes, out);\n+  }\n+  Result<std::shared_ptr<Buffer>> Read(int64_t nbytes) override {\n+    if (latency_s_ > 0) {\n+      SleepFor(latency_s_);\n+    }\n+    return target_->Read(nbytes);\n+  }\n+  Status Seek(int64_t pos) { return target_->Seek(pos); }\n+\n+ private:\n+  std::shared_ptr<io::BufferReader> target_;\n+  double latency_s_;\n+};\n+\n+static ReadOptions CreateReadOptions(bool use_threads, bool use_async) {\n+  auto result = csv::ReadOptions::Defaults();\n+  result.use_threads = use_threads;\n+  result.legacy_blocking_reads = !use_async;\n+  // Simulate larger files by using smaller block files so the impact of multiple\n+  // blocks is seen but we don't have to spend the time waiting on the large I/O\n+  result.block_size = (1 << 20) / 100;\n+  return result;\n+}\n+\n+static std::shared_ptr<SlowInputStream> CreateStreamReader(std::shared_ptr<Buffer> buffer,\n+                                                           int64_t latency_ms) {\n+  auto buffer_reader = std::make_shared<io::BufferReader>(buffer);\n+  return std::make_shared<SlowInputStream>(buffer_reader, latency_ms);\n+}\n+\n+static void BenchmarkReader(benchmark::State& state, bool use_threads, bool use_async) {\n+  auto latency_ms = state.range(0);\n+  auto num_rows = state.range(1);\n+  auto num_files = state.range(2);\n+  if (num_files > 5 && use_threads && !use_async) {\n\nReview comment:\n       Why `5`? Is it related to the thread pool size below?\n\n##########\nFile path: cpp/src/arrow/csv/reader_test.cc\n##########\n@@ -0,0 +1,169 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstdint>\n+#include <string>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/csv/options.h\"\n+#include \"arrow/csv/reader.h\"\n+#include \"arrow/csv/test_common.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+namespace csv {\n+\n+void StressTableReader(\n+    std::function<Result<std::shared_ptr<TableReader>>(std::shared_ptr<io::InputStream>)>\n+        reader_factory) {\n+  const int NTASKS = 100;\n+  const int NROWS = 1000;\n+  ASSERT_OK_AND_ASSIGN(auto table_buffer, MakeSampleCsvBuffer(NROWS));\n+\n+  std::vector<Future<std::shared_ptr<Table>>> task_futures(NTASKS);\n+  for (int i = 0; i < NTASKS; i++) {\n+    auto input = std::make_shared<io::BufferReader>(table_buffer);\n+    ASSERT_OK_AND_ASSIGN(auto reader, reader_factory(input));\n+    task_futures[i] = reader->ReadAsync();\n+  }\n+  auto combined_future = All(task_futures);\n+  combined_future.Wait();\n+\n+  ASSERT_OK_AND_ASSIGN(std::vector<Result<std::shared_ptr<Table>>> results,\n+                       combined_future.result());\n+  for (auto&& result : results) {\n+    ASSERT_OK_AND_ASSIGN(auto table, result);\n+    ASSERT_EQ(NROWS, table->num_rows());\n+  }\n+}\n+\n+void TestNestedParallelism(\n+    std::shared_ptr<internal::ThreadPool> thread_pool,\n+    std::function<Result<std::shared_ptr<TableReader>>(std::shared_ptr<io::InputStream>)>\n+        reader_factory) {\n+  const int NROWS = 1000;\n+  ASSERT_OK_AND_ASSIGN(auto table_buffer, MakeSampleCsvBuffer(NROWS));\n+  auto input = std::make_shared<io::BufferReader>(table_buffer);\n+  ASSERT_OK_AND_ASSIGN(auto reader, reader_factory(input));\n+\n+  Future<std::shared_ptr<Table>> table_future;\n+\n+  auto read_task = [&reader, &table_future]() mutable {\n+    table_future = reader->ReadAsync();\n+    return Status::OK();\n+  };\n+  ASSERT_OK_AND_ASSIGN(auto future, thread_pool->Submit(read_task));\n+  ASSERT_TRUE(future.Wait(1));\n+\n+  if (future.is_finished()) {\n+    ASSERT_TRUE(table_future.Wait(1));\n+    if (table_future.is_finished()) {\n\nReview comment:\n       Same question here.\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -832,9 +832,203 @@ TEST(FutureCompletionTest, FutureVoid) {\n   }\n }\n \n+TEST(FutureAllTest, Simple) {\n+  auto f1 = Future<int>::Make();\n+  auto f2 = Future<int>::Make();\n+  std::vector<Future<int>> futures = {f1, f2};\n+  auto combined = arrow::All(futures);\n+\n+  ARROW_UNUSED(combined.Then([](std::vector<Result<int>> results) {\n\nReview comment:\n       It would seem more robust and readable to test for the `result()` below.\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -580,4 +615,74 @@ inline std::vector<int> WaitForAny(const std::vector<Future<T>*>& futures,\n   return waiter->MoveFinishedFutures();\n }\n \n+template <typename T = detail::Empty>\n+struct ControlFlow {\n+  using BreakValueType = T;\n+\n+  bool IsBreak() const { return break_value_.has_value(); }\n+\n+  static Result<BreakValueType> MoveBreakValue(const ControlFlow& cf) {\n+    return std::move(*cf.break_value_);\n+  }\n+\n+  mutable util::optional<BreakValueType> break_value_;\n+};\n+\n+struct Continue {\n+  template <typename T>\n+  operator ControlFlow<T>() && {  // NOLINT explicit\n+    return {};\n+  }\n+};\n+\n+template <typename T = detail::Empty>\n+ControlFlow<T> Break(T break_value = {}) {\n+  return ControlFlow<T>{std::move(break_value)};\n+}\n+\n+template <typename Iterate,\n+          typename Control = typename detail::result_of_t<Iterate()>::ValueType,\n+          typename BreakValueType = typename Control::BreakValueType>\n+Future<BreakValueType> Loop(Iterate iterate) {\n+  auto break_fut = Future<BreakValueType>::Make();\n+\n+  struct Callback {\n+    bool CheckForTermination(const Result<Control>& maybe_control) {\n+      if (!maybe_control.ok() || maybe_control->IsBreak()) {\n+        Result<BreakValueType> maybe_break = maybe_control.Map(Control::MoveBreakValue);\n+        break_fut.MarkFinished(std::move(maybe_break));\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    void operator()(const Result<Control>& maybe_control) && {\n+      if (CheckForTermination(maybe_control)) return;\n+\n+      auto control_fut = iterate();\n+      while (control_fut.is_finished()) {\n+        // There's no need to AddCallback on a finished future; we can CheckForTermination\n+        // now. This also avoids recursion and potential stack overflow.\n+        if (CheckForTermination(control_fut.result())) return;\n+\n+        control_fut = iterate();\n+      }\n+      control_fut.AddCallback(std::move(*this));\n+    }\n+\n+    Iterate iterate;\n+    // If the future returned by control_fut is never completed then we will be hanging on\n+    // to break_fut forever even if the listener has given up listening on it.  Instead we\n+    // rely on the fact that a producer (the caller of Future<>::Make) is always\n+    // responsible for completing the futures they create.\n+    // TODO: Could avoid this kind of situation with \"future abandonment\" similar to mesos\n+    Future<BreakValueType> break_fut;\n\nReview comment:\n       Can't we simply use `WeakFuture` to avoid the aforementioned problem?\n\n##########\nFile path: cpp/src/arrow/util/iterator_test.cc\n##########\n@@ -214,6 +255,270 @@ TEST(TestVectorIterator, RangeForLoop) {\n   ASSERT_EQ(ints_it, ints.end());\n }\n \n+template <typename T>\n+Transformer<T, T> MakeFirstN(int n) {\n+  int remaining = n;\n+  return [remaining](T next) mutable -> Result<TransformFlow<T>> {\n+    if (remaining > 0) {\n+      remaining--;\n+      return TransformYield(next);\n+    }\n+    return TransformFinish();\n+  };\n+}\n+\n+TEST(TestIteratorTransform, Truncating) {\n+  auto original = VectorIt({1, 2, 3});\n+  auto truncated = MakeTransformedIterator(std::move(original), MakeFirstN<TestInt>(2));\n+  AssertIteratorMatch({1, 2}, std::move(truncated));\n+}\n+\n+TEST(TestIteratorTransform, TestPointer) {\n+  auto original = VectorIt<std::shared_ptr<int>>(\n+      {std::make_shared<int>(1), std::make_shared<int>(2), std::make_shared<int>(3)});\n+  auto truncated =\n+      MakeTransformedIterator(std::move(original), MakeFirstN<std::shared_ptr<int>>(2));\n+  ASSERT_OK_AND_ASSIGN(auto result, truncated.ToVector());\n+  ASSERT_EQ(2, result.size());\n+}\n+\n+TEST(TestIteratorTransform, TruncatingShort) {\n+  // Tests the failsafe case where we never call Finish\n+  auto original = VectorIt({1});\n+  auto truncated = MakeTransformedIterator<TestInt, TestInt>(std::move(original),\n+                                                             MakeFirstN<TestInt>(2));\n+  AssertIteratorMatch({1}, std::move(truncated));\n+}\n+\n+TEST(TestAsyncUtil, Background) {\n+  std::vector<TestInt> expected = {1, 2, 3};\n+  auto background = BackgroundAsyncVectorIt(expected);\n+  auto future = CollectAsyncGenerator(background);\n+  ASSERT_FALSE(future.is_finished());\n+  future.Wait();\n+  ASSERT_TRUE(future.is_finished());\n+  ASSERT_EQ(expected, *future.result());\n+}\n+\n+struct SlowEmptyIterator {\n+  Result<TestInt> Next() {\n+    if (called_) {\n+      return Status::Invalid(\"Should not have been called twice\");\n+    }\n+    SleepFor(0.1);\n+    return IterationTraits<TestInt>::End();\n+  }\n+\n+ private:\n+  bool called_ = false;\n+};\n+\n+TEST(TestAsyncUtil, BackgroundRepeatEnd) {\n+  // Ensure that the background iterator properly fulfills the asyncgenerator contract\n+  // and can be called after it ends.\n+  auto iterator = Iterator<TestInt>(SlowEmptyIterator());\n+  ASSERT_OK_AND_ASSIGN(\n+      auto background_iter,\n+      MakeBackgroundIterator(std::move(iterator), internal::GetCpuThreadPool()));\n+\n+  auto one = background_iter();\n+  auto two = background_iter();\n+\n+  ASSERT_TRUE(one.Wait(0.5));\n+\n+  if (one.is_finished()) {\n+    ASSERT_EQ(IterationTraits<TestInt>::End(), *one.result());\n+  }\n+\n+  ASSERT_TRUE(two.Wait(0.5));\n+  ASSERT_TRUE(two.is_finished());\n+  if (two.is_finished()) {\n+    ASSERT_EQ(IterationTraits<TestInt>::End(), *two.result());\n+  }\n+}\n+\n+TEST(TestAsyncUtil, SynchronousFinish) {\n+  AsyncGenerator<TestInt> generator = []() {\n+    return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\n+  };\n+  Transformer<TestInt, TestInt> skip_all = [](TestInt value) { return TransformSkip(); };\n+  auto transformed = TransformAsyncGenerator(generator, skip_all);\n+  auto future = CollectAsyncGenerator(transformed);\n+  ASSERT_TRUE(future.is_finished());\n+  ASSERT_OK_AND_ASSIGN(auto actual, future.result());\n+  ASSERT_EQ(std::vector<TestInt>(), actual);\n+}\n+\n+TEST(TestAsyncUtil, CompleteBackgroundStressTest) {\n+  auto expected = RangeVector(100);\n+  std::vector<Future<std::vector<TestInt>>> futures;\n+  for (unsigned int i = 0; i < 100; i++) {\n+    auto background = BackgroundAsyncVectorIt(expected);\n+    futures.push_back(CollectAsyncGenerator(background));\n+  }\n+  auto combined = All(futures);\n+  combined.Wait(2);\n+  if (combined.is_finished()) {\n+    ASSERT_OK_AND_ASSIGN(auto completed_vectors, combined.result());\n+    for (auto&& vector : completed_vectors) {\n+      ASSERT_EQ(vector, expected);\n+    }\n+  } else {\n+    FAIL() << \"After 2 seconds all background iterators had not finished collecting\";\n+  }\n+}\n+\n+TEST(TestAsyncUtil, StackOverflow) {\n+  int counter = 0;\n+  AsyncGenerator<TestInt> generator = [&counter]() {\n+    if (counter < 1000000) {\n+      return Future<TestInt>::MakeFinished(counter++);\n+    } else {\n+      return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\n+    }\n+  };\n+  Transformer<TestInt, TestInt> discard =\n+      [](TestInt next) -> Result<TransformFlow<TestInt>> { return TransformSkip(); };\n+  auto transformed = TransformAsyncGenerator(generator, discard);\n+  auto collected_future = CollectAsyncGenerator(transformed);\n+  ASSERT_TRUE(collected_future.Wait(5));\n+  if (collected_future.is_finished()) {\n+    ASSERT_OK_AND_ASSIGN(auto collected, collected_future.result());\n+    ASSERT_EQ(0, collected.size());\n+  }\n+}\n+\n+TEST(TestAsyncUtil, Visit) {\n+  auto generator = AsyncVectorIt({1, 2, 3});\n+  unsigned int sum = 0;\n+  auto sum_future = VisitAsyncGenerator<TestInt>(generator, [&sum](TestInt item) {\n+    sum += item.value;\n+    return Status::OK();\n+  });\n+  // Should be superfluous\n+  sum_future.Wait();\n+  ASSERT_EQ(6, sum);\n+}\n+\n+TEST(TestAsyncUtil, Collect) {\n+  std::vector<TestInt> expected = {1, 2, 3};\n+  auto generator = AsyncVectorIt(expected);\n+  auto collected = CollectAsyncGenerator(generator);\n+  ASSERT_EQ(expected, *collected.result());\n+}\n+\n+template <typename T>\n+Transformer<T, T> MakeRepeatN(int repeat_count) {\n+  int current_repeat = 0;\n+  return [repeat_count, current_repeat](T next) mutable -> Result<TransformFlow<T>> {\n+    current_repeat++;\n+    bool ready_for_next = false;\n+    if (current_repeat == repeat_count) {\n+      current_repeat = 0;\n+      ready_for_next = true;\n+    }\n+    return TransformYield(next, ready_for_next);\n+  };\n+}\n+\n+TEST(TestIteratorTransform, Repeating) {\n+  auto original = VectorIt({1, 2, 3});\n+  auto repeated = MakeTransformedIterator<TestInt, TestInt>(std::move(original),\n+                                                            MakeRepeatN<TestInt>(2));\n+  AssertIteratorMatch({1, 1, 2, 2, 3, 3}, std::move(repeated));\n+}\n+\n+template <typename T>\n+Transformer<T, T> MakeFilter(std::function<bool(T&)> filter) {\n+  return [filter](T next) -> Result<TransformFlow<T>> {\n+    if (filter(next)) {\n+      return TransformYield(next);\n+    } else {\n+      return TransformSkip();\n+    }\n+  };\n+}\n+\n+template <typename T>\n+Transformer<T, T> MakeAbortOnSecond() {\n+  int counter = 0;\n+  return [counter](T next) mutable -> Result<TransformFlow<T>> {\n+    if (counter++ == 1) {\n+      return Status::Invalid(\"X\");\n+    }\n+    return TransformYield(next);\n+  };\n+}\n+\n+TEST(TestIteratorTransform, SkipSome) {\n+  // Exercises TransformSkip\n+  auto original = VectorIt({1, 2, 3});\n+  auto filter = MakeFilter<TestInt>([](TestInt& t) { return t.value != 2; });\n+  auto filtered = MakeTransformedIterator(std::move(original), filter);\n+  AssertIteratorMatch({1, 3}, std::move(filtered));\n+}\n+\n+TEST(TestIteratorTransform, SkipAll) {\n+  // Exercises TransformSkip\n+  auto original = VectorIt({1, 2, 3});\n+  auto filter = MakeFilter<TestInt>([](TestInt& t) { return false; });\n+  auto filtered = MakeTransformedIterator(std::move(original), filter);\n+  AssertIteratorMatch({}, std::move(filtered));\n+}\n+\n+TEST(TestIteratorTransform, Abort) {\n+  auto original = VectorIt({1, 2, 3});\n+  auto transformed =\n+      MakeTransformedIterator(std::move(original), MakeAbortOnSecond<TestInt>());\n+  ASSERT_OK(transformed.Next());\n+  ASSERT_RAISES(Invalid, transformed.Next());\n+}\n+\n+TEST(TestAsyncIteratorTransform, SkipSome) {\n+  auto original = AsyncVectorIt({1, 2, 3});\n+  auto filter = MakeFilter<TestInt>([](TestInt& t) { return t.value != 2; });\n+  auto filtered = TransformAsyncGenerator(std::move(original), filter);\n+  AssertAsyncGeneratorMatch({1, 3}, std::move(filtered));\n+}\n+\n+TEST(TestAsyncUtil, ReadaheadFailed) {\n+  auto source = []() -> Future<TestInt> {\n+    return Future<TestInt>::MakeFinished(Status::Invalid(\"X\"));\n+  };\n+  auto readahead = AddReadahead<TestInt>(source, 10);\n+  auto next = readahead();\n+  ASSERT_EQ(Status::Invalid(\"X\"), next.status());\n+}\n+\n+TEST(TestAsyncUtil, Readahead) {\n+  int num_delivered = 0;\n+  auto source = [&num_delivered]() {\n+    if (num_delivered < 5) {\n+      return Future<TestInt>::MakeFinished(num_delivered++);\n+    } else {\n+      return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\n+    }\n+  };\n+  auto readahead = AddReadahead<TestInt>(source, 10);\n+  // Should not pump until first item requested\n\nReview comment:\n       Sounds weird. Is there a motivation for this?\n\n##########\nFile path: cpp/src/arrow/util/task_group.cc\n##########\n@@ -135,6 +149,18 @@ class ThreadedTaskGroup : public TaskGroup {\n       // before cv.notify_one() has returned\n       std::unique_lock<std::mutex> lock(mutex_);\n       cv_.notify_one();\n+      if (completion_future_.has_value()) {\n+        // MarkFinished could be slow.  We don't want to call it while we are holding\n+        // the lock.\n+        // TODO: If optional is thread safe then we can skip this locking entirely\n+        auto future = *completion_future_;\n\nReview comment:\n       `auto&`?\n\n##########\nFile path: cpp/src/arrow/util/task_group.cc\n##########\n@@ -135,6 +149,18 @@ class ThreadedTaskGroup : public TaskGroup {\n       // before cv.notify_one() has returned\n       std::unique_lock<std::mutex> lock(mutex_);\n       cv_.notify_one();\n+      if (completion_future_.has_value()) {\n+        // MarkFinished could be slow.  We don't want to call it while we are holding\n+        // the lock.\n+        // TODO: If optional is thread safe then we can skip this locking entirely\n+        auto future = *completion_future_;\n+        auto finished = completion_future_->is_finished();\n+        auto status = status_;\n+        lock.unlock();\n+        if (!finished) {\n+          future.MarkFinished(status);\n\nReview comment:\n       It seems it is possible for `MarkFinished` to be called from several threads at once here, but it's not thread-safe.\n\n##########\nFile path: cpp/src/arrow/util/async_iterator.h\n##########\n@@ -0,0 +1,295 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+#include <queue>\n+\n+#include \"arrow/util/functional.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+template <typename T>\n+using AsyncGenerator = std::function<Future<T>()>;\n+\n+/// Iterates through a generator of futures, visiting the result of each one and\n+/// returning a future that completes when all have been visited\n+template <typename T>\n+Future<> VisitAsyncGenerator(AsyncGenerator<T> generator,\n+                             std::function<Status(T)> visitor) {\n+  auto loop_body = [generator, visitor] {\n+    auto next = generator();\n+    return next.Then([visitor](const T& result) -> Result<ControlFlow<detail::Empty>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(detail::Empty());\n+      } else {\n+        auto visited = visitor(result);\n+        if (visited.ok()) {\n+          return Continue();\n+        } else {\n+          return visited;\n+        }\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T>\n+Future<std::vector<T>> CollectAsyncGenerator(AsyncGenerator<T> generator) {\n+  auto vec = std::make_shared<std::vector<T>>();\n+  auto loop_body = [generator, vec] {\n+    auto next = generator();\n+    return next.Then([vec](const T& result) -> Result<ControlFlow<std::vector<T>>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(*vec);\n+      } else {\n+        vec->push_back(result);\n+        return Continue();\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T, typename V>\n+class TransformingGenerator {\n+ public:\n+  explicit TransformingGenerator(AsyncGenerator<T> generator,\n+                                 Transformer<T, V> transformer)\n+      : finished_(), last_value_(), generator_(generator), transformer_(transformer) {}\n+\n+  // See comment on TransformingIterator::Pump\n+  Result<util::optional<V>> Pump() {\n+    if (!finished_ && last_value_.has_value()) {\n+      ARROW_ASSIGN_OR_RAISE(TransformFlow<V> next, transformer_(*last_value_));\n+      if (next.ReadyForNext()) {\n+        if (*last_value_ == IterationTraits<T>::End()) {\n+          finished_ = true;\n+        }\n+        last_value_.reset();\n+      }\n+      if (next.Finished()) {\n+        finished_ = true;\n+      }\n+      if (next.HasValue()) {\n+        return next.Value();\n+      }\n+    }\n+    if (finished_) {\n+      return IterationTraits<V>::End();\n+    }\n+    return util::nullopt;\n+  }\n+\n+  Future<V> operator()() {\n+    while (true) {\n+      auto maybe_next_result = Pump();\n+      if (!maybe_next_result.ok()) {\n+        return Future<V>::MakeFinished(maybe_next_result.status());\n+      }\n+      auto maybe_next = maybe_next_result.ValueUnsafe();\n+      if (maybe_next.has_value()) {\n+        return Future<V>::MakeFinished(*maybe_next);\n+      }\n+\n+      auto next_fut = generator_();\n+      // If finished already, process results immediately inside the loop to avoid stack\n+      // overflow\n+      if (next_fut.is_finished()) {\n+        auto next_result = next_fut.result();\n+        if (next_result.ok()) {\n+          last_value_ = *next_result;\n+        } else {\n+          return Future<V>::MakeFinished(next_result.status());\n+        }\n+        // Otherwise, if not finished immediately, add callback to process results\n+      } else {\n+        return next_fut.Then([this](const Result<T>& next_result) {\n+          if (next_result.ok()) {\n+            last_value_ = *next_result;\n+            return (*this)();\n+          } else {\n+            return Future<V>::MakeFinished(next_result.status());\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+ protected:\n+  bool finished_;\n+  util::optional<T> last_value_;\n+  AsyncGenerator<T> generator_;\n+  Transformer<T, V> transformer_;\n+};\n+\n+template <typename T>\n+static std::function<void(const Result<T>&)> MakeCallback(\n+    std::shared_ptr<bool> finished) {\n+  return [finished](const Result<T>& next_result) {\n+    if (!next_result.ok()) {\n+      *finished = true;\n+    } else {\n+      auto next = *next_result;\n+      *finished = (next == IterationTraits<T>::End());\n+    }\n+  };\n+}\n+\n+template <typename T>\n+AsyncGenerator<T> AddReadahead(AsyncGenerator<T> source_generator, int max_readahead) {\n+  // Using a shared_ptr instead of a lambda capture here because it's possible that\n+  // the inner mark_finished_if_done outlives the outer lambda\n+  auto finished = std::make_shared<bool>(false);\n+  auto mark_finished_if_done = [finished](const Result<T>& next_result) {\n+    if (!next_result.ok()) {\n+      *finished = true;\n+    } else {\n+      auto next = *next_result;\n+      *finished = (next == IterationTraits<T>::End());\n+    }\n+  };\n+\n+  std::queue<Future<T>> readahead_queue;\n+  return [=]() mutable -> Future<T> {\n+    if (readahead_queue.empty()) {\n+      // This is the first request, let's pump the underlying queue\n+      for (int i = 0; i < max_readahead; i++) {\n+        auto next = source_generator();\n+        next.AddCallback(mark_finished_if_done);\n+        readahead_queue.push(std::move(next));\n+      }\n+    }\n+    // Pop one and add one\n+    auto result = readahead_queue.front();\n+    readahead_queue.pop();\n+    if (*finished) {\n+      readahead_queue.push(Future<T>::MakeFinished(IterationTraits<T>::End()));\n+    } else {\n+      auto back_of_queue = source_generator();\n+      back_of_queue.AddCallback(mark_finished_if_done);\n+      readahead_queue.push(std::move(back_of_queue));\n+    }\n+    return result;\n+  };\n+}\n+\n+/// \\brief Transforms an async generator using a transformer function returning a new\n+/// AsyncGenerator\n+///\n+/// The transform function here behaves exactly the same as the transform function in\n+/// MakeTransformedIterator and you can safely use the same transform function to\n+/// transform both synchronous and asynchronous streams.\n+template <typename T, typename V>\n+AsyncGenerator<V> TransformAsyncGenerator(AsyncGenerator<T> generator,\n+                                          Transformer<T, V> transformer) {\n+  return TransformingGenerator<T, V>(generator, transformer);\n+}\n+\n+namespace detail {\n+\n+template <typename T>\n+struct BackgroundIteratorPromise : ReadaheadPromise {\n+  ~BackgroundIteratorPromise() override {}\n+\n+  explicit BackgroundIteratorPromise(Iterator<T>* it) : it_(it) {}\n+\n+  bool Call() override {\n+    auto next = it_->Next();\n+    auto finished = next == IterationTraits<T>::End();\n+    out_.MarkFinished(std::move(next));\n+    return finished;\n+  }\n+\n+  void End() override { out_.MarkFinished(IterationTraits<T>::End()); }\n+\n+  Iterator<T>* it_;\n+  Future<T> out_ = Future<T>::Make();\n+};\n+\n+}  // namespace detail\n+\n+/// \\brief Async generator that iterates on an underlying iterator in a\n+/// separate thread.\n+template <typename T>\n+class BackgroundIterator {\n+  using PromiseType = typename detail::BackgroundIteratorPromise<T>;\n+\n+ public:\n+  explicit BackgroundIterator(Iterator<T> it, internal::Executor* executor)\n+      : it_(new Iterator<T>(std::move(it))),\n+        queue_(new detail::ReadaheadQueue(0)),\n+        executor_(executor),\n+        done_() {}\n+\n+  ~BackgroundIterator() {\n+    if (queue_) {\n+      // Make sure the queue doesn't call any promises after this object\n+      // is destroyed.\n+      queue_->EnsureShutdownOrDie();\n+    }\n+  }\n+\n+  ARROW_DEFAULT_MOVE_AND_ASSIGN(BackgroundIterator);\n+  ARROW_DISALLOW_COPY_AND_ASSIGN(BackgroundIterator);\n+\n+  Future<T> operator()() {\n+    if (done_) {\n+      return Future<T>::MakeFinished(IterationTraits<T>::End());\n+    }\n+    auto promise = std::unique_ptr<PromiseType>(new PromiseType{it_.get()});\n+    auto result = Future<T>(promise->out_);\n\nReview comment:\n       `result` is a bit misleading...\n\n##########\nFile path: cpp/src/arrow/csv/reader_benchmark.cc\n##########\n@@ -0,0 +1,139 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"benchmark/benchmark.h\"\n+\n+#include <string>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/csv/options.h\"\n+#include \"arrow/csv/reader.h\"\n+#include \"arrow/csv/test_common.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+namespace csv {\n+\n+class SlowInputStream : public io::InputStream {\n+ public:\n+  explicit SlowInputStream(std::shared_ptr<io::BufferReader> target, int64_t latency_ms)\n+      : target_(std::move(target)) {\n+    latency_s_ = static_cast<double>(latency_ms) / 1000.0;\n+  }\n+  virtual ~SlowInputStream() {}\n+\n+  Result<util::string_view> Peek(int64_t nbytes) override {\n+    return target_->Peek(nbytes);\n+  }\n+  bool supports_zero_copy() const override { return target_->supports_zero_copy(); }\n+  Status Close() override { return target_->Close(); }\n+  Status Abort() override { return target_->Abort(); }\n+  Result<int64_t> Tell() const override { return target_->Tell(); }\n+  bool closed() const override { return target_->closed(); }\n+  Result<int64_t> Read(int64_t nbytes, void* out) override {\n+    if (latency_s_ > 0) {\n+      SleepFor(latency_s_);\n+    }\n+    return target_->Read(nbytes, out);\n+  }\n+  Result<std::shared_ptr<Buffer>> Read(int64_t nbytes) override {\n+    if (latency_s_ > 0) {\n+      SleepFor(latency_s_);\n+    }\n+    return target_->Read(nbytes);\n+  }\n+  Status Seek(int64_t pos) { return target_->Seek(pos); }\n+\n+ private:\n+  std::shared_ptr<io::BufferReader> target_;\n+  double latency_s_;\n+};\n+\n+static ReadOptions CreateReadOptions(bool use_threads, bool use_async) {\n+  auto result = csv::ReadOptions::Defaults();\n+  result.use_threads = use_threads;\n+  result.legacy_blocking_reads = !use_async;\n+  // Simulate larger files by using smaller block files so the impact of multiple\n+  // blocks is seen but we don't have to spend the time waiting on the large I/O\n+  result.block_size = (1 << 20) / 100;\n+  return result;\n+}\n+\n+static std::shared_ptr<SlowInputStream> CreateStreamReader(std::shared_ptr<Buffer> buffer,\n+                                                           int64_t latency_ms) {\n+  auto buffer_reader = std::make_shared<io::BufferReader>(buffer);\n+  return std::make_shared<SlowInputStream>(buffer_reader, latency_ms);\n+}\n+\n+static void BenchmarkReader(benchmark::State& state, bool use_threads, bool use_async) {\n+  auto latency_ms = state.range(0);\n+  auto num_rows = state.range(1);\n+  auto num_files = state.range(2);\n+  if (num_files > 5 && use_threads && !use_async) {\n+    state.SkipWithError(\"Would deadlock\");\n+  }\n+  auto input_buffer = *MakeSampleCsvBuffer(num_rows);\n+  // Hard coding # of threads so we don't deadlock if there are too few cores\n+  ASSIGN_OR_ABORT(auto thread_pool, internal::ThreadPool::Make(6));\n+  io::AsyncContext async_context(thread_pool.get());\n+  while (state.KeepRunning()) {\n+    std::vector<Future<std::shared_ptr<Table>>> table_futures;\n+    for (int i = 0; i < num_files; i++) {\n+      auto stream_reader = CreateStreamReader(input_buffer, latency_ms);\n+      auto table_reader = *csv::TableReader::Make(\n+          default_memory_pool(), async_context, stream_reader,\n+          CreateReadOptions(use_threads, use_async), csv::ParseOptions::Defaults(),\n+          csv::ConvertOptions::Defaults());\n+      if (use_async) {\n+        table_futures.push_back(table_reader->ReadAsync());\n+      } else {\n+        ASSERT_OK_AND_ASSIGN(auto table_future,\n+                             async_context.executor->Submit(\n+                                 [table_reader] { return table_reader->Read(); }));\n+        table_futures.push_back(table_future);\n+      }\n+    }\n+    auto combined = All(table_futures);\n+    ASSIGN_OR_ABORT(auto result, combined.result());\n+    for (auto&& table : result) {\n+      ABORT_NOT_OK(table);\n+    }\n+  }\n+  state.SetItemsProcessed(state.iterations() * num_rows);\n\nReview comment:\n       Do we want to also multiply by `num_files`?\n\n##########\nFile path: cpp/src/arrow/csv/test_common.cc\n##########\n@@ -61,5 +61,47 @@ void MakeColumnParser(std::vector<std::string> items, std::shared_ptr<BlockParse\n   ASSERT_EQ((*out)->num_rows(), items.size());\n }\n \n+const std::vector<std::string> int64_rows = {\"123\", \"4\", \"-317005557\", \"\", \"N/A\", \"0\"};\n+const std::vector<std::string> float_rows = {\"0\", \"123.456\", \"-3170.55766\", \"\", \"N/A\"};\n+const std::vector<std::string> decimal128_rows = {\"0\", \"123.456\", \"-3170.55766\",\n+                                                  \"\",  \"N/A\",     \"1233456789.123456789\"};\n+const std::vector<std::string> iso8601_rows = {\"1917-10-17\", \"2018-09-13\",\n+                                               \"1941-06-22 04:00\", \"1945-05-09 09:45:38\"};\n+const std::vector<std::string> strptime_rows = {\"10/17/1917\", \"9/13/2018\", \"9/5/1945\"};\n\nReview comment:\n       Unless you're passing an explicit schema, the decimal128 and strptime rows won't be type-inferred as you seem to expect them to?\n\n##########\nFile path: cpp/src/arrow/util/iterator_test.cc\n##########\n@@ -214,6 +255,270 @@ TEST(TestVectorIterator, RangeForLoop) {\n   ASSERT_EQ(ints_it, ints.end());\n }\n \n+template <typename T>\n+Transformer<T, T> MakeFirstN(int n) {\n+  int remaining = n;\n+  return [remaining](T next) mutable -> Result<TransformFlow<T>> {\n+    if (remaining > 0) {\n+      remaining--;\n+      return TransformYield(next);\n+    }\n+    return TransformFinish();\n+  };\n+}\n+\n+TEST(TestIteratorTransform, Truncating) {\n\nReview comment:\n       Iterator transform tests should use two different types for `T` and `V` (for example `int` and `std::string`), IMHO, to make sure that there's no place where the original value is passed through by mistake.\n\n##########\nFile path: cpp/src/arrow/csv/reader_test.cc\n##########\n@@ -0,0 +1,169 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstdint>\n+#include <string>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/csv/options.h\"\n+#include \"arrow/csv/reader.h\"\n+#include \"arrow/csv/test_common.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+namespace csv {\n+\n+void StressTableReader(\n+    std::function<Result<std::shared_ptr<TableReader>>(std::shared_ptr<io::InputStream>)>\n+        reader_factory) {\n+  const int NTASKS = 100;\n+  const int NROWS = 1000;\n+  ASSERT_OK_AND_ASSIGN(auto table_buffer, MakeSampleCsvBuffer(NROWS));\n+\n+  std::vector<Future<std::shared_ptr<Table>>> task_futures(NTASKS);\n+  for (int i = 0; i < NTASKS; i++) {\n+    auto input = std::make_shared<io::BufferReader>(table_buffer);\n+    ASSERT_OK_AND_ASSIGN(auto reader, reader_factory(input));\n+    task_futures[i] = reader->ReadAsync();\n+  }\n+  auto combined_future = All(task_futures);\n+  combined_future.Wait();\n+\n+  ASSERT_OK_AND_ASSIGN(std::vector<Result<std::shared_ptr<Table>>> results,\n+                       combined_future.result());\n+  for (auto&& result : results) {\n+    ASSERT_OK_AND_ASSIGN(auto table, result);\n+    ASSERT_EQ(NROWS, table->num_rows());\n+  }\n+}\n+\n+void TestNestedParallelism(\n+    std::shared_ptr<internal::ThreadPool> thread_pool,\n+    std::function<Result<std::shared_ptr<TableReader>>(std::shared_ptr<io::InputStream>)>\n+        reader_factory) {\n+  const int NROWS = 1000;\n+  ASSERT_OK_AND_ASSIGN(auto table_buffer, MakeSampleCsvBuffer(NROWS));\n+  auto input = std::make_shared<io::BufferReader>(table_buffer);\n+  ASSERT_OK_AND_ASSIGN(auto reader, reader_factory(input));\n+\n+  Future<std::shared_ptr<Table>> table_future;\n+\n+  auto read_task = [&reader, &table_future]() mutable {\n+    table_future = reader->ReadAsync();\n+    return Status::OK();\n+  };\n+  ASSERT_OK_AND_ASSIGN(auto future, thread_pool->Submit(read_task));\n+  ASSERT_TRUE(future.Wait(1));\n+\n+  if (future.is_finished()) {\n\nReview comment:\n       Hmm... what if it's not finished? Does it mean we should error out?\n\n##########\nFile path: cpp/src/arrow/csv/reader_test.cc\n##########\n@@ -0,0 +1,169 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstdint>\n+#include <string>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/csv/options.h\"\n+#include \"arrow/csv/reader.h\"\n+#include \"arrow/csv/test_common.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+namespace csv {\n+\n+void StressTableReader(\n+    std::function<Result<std::shared_ptr<TableReader>>(std::shared_ptr<io::InputStream>)>\n+        reader_factory) {\n\nReview comment:\n       Hide the `std::function<...>` behing a type alias (`using TableReaderFactory = ...`) to avoid repeating it several times?\n\n##########\nFile path: cpp/src/arrow/csv/test_common.cc\n##########\n@@ -61,5 +61,47 @@ void MakeColumnParser(std::vector<std::string> items, std::shared_ptr<BlockParse\n   ASSERT_EQ((*out)->num_rows(), items.size());\n }\n \n+const std::vector<std::string> int64_rows = {\"123\", \"4\", \"-317005557\", \"\", \"N/A\", \"0\"};\n+const std::vector<std::string> float_rows = {\"0\", \"123.456\", \"-3170.55766\", \"\", \"N/A\"};\n+const std::vector<std::string> decimal128_rows = {\"0\", \"123.456\", \"-3170.55766\",\n+                                                  \"\",  \"N/A\",     \"1233456789.123456789\"};\n+const std::vector<std::string> iso8601_rows = {\"1917-10-17\", \"2018-09-13\",\n+                                               \"1941-06-22 04:00\", \"1945-05-09 09:45:38\"};\n+const std::vector<std::string> strptime_rows = {\"10/17/1917\", \"9/13/2018\", \"9/5/1945\"};\n+\n+static void WriteHeader(std::ostream& writer) {\n+  writer << \"Int64,Float,Decimal128,ISO8601,Strptime\" << std::endl;\n+}\n+\n+static std::string GetCell(std::vector<std::string> base_rows, size_t row_index) {\n\nReview comment:\n       Nit, but a const-ref is more efficient here.\n\n##########\nFile path: cpp/src/arrow/csv/test_common.cc\n##########\n@@ -61,5 +61,47 @@ void MakeColumnParser(std::vector<std::string> items, std::shared_ptr<BlockParse\n   ASSERT_EQ((*out)->num_rows(), items.size());\n }\n \n+const std::vector<std::string> int64_rows = {\"123\", \"4\", \"-317005557\", \"\", \"N/A\", \"0\"};\n\nReview comment:\n       Everything that's not exposed in a `.h` should be enclosed in the anonymous namespace, to miminize exported symbols.\n\n##########\nFile path: cpp/src/arrow/csv/test_common.h\n##########\n@@ -22,6 +22,7 @@\n #include <vector>\n \n #include \"arrow/csv/parser.h\"\n+#include \"arrow/io/memory.h\"\n\nReview comment:\n       You don't need this include in this `.h` file.\n\n##########\nFile path: cpp/src/arrow/csv/reader_test.cc\n##########\n@@ -0,0 +1,169 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstdint>\n+#include <string>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/csv/options.h\"\n+#include \"arrow/csv/reader.h\"\n+#include \"arrow/csv/test_common.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+namespace csv {\n+\n+void StressTableReader(\n+    std::function<Result<std::shared_ptr<TableReader>>(std::shared_ptr<io::InputStream>)>\n+        reader_factory) {\n+  const int NTASKS = 100;\n+  const int NROWS = 1000;\n+  ASSERT_OK_AND_ASSIGN(auto table_buffer, MakeSampleCsvBuffer(NROWS));\n+\n+  std::vector<Future<std::shared_ptr<Table>>> task_futures(NTASKS);\n+  for (int i = 0; i < NTASKS; i++) {\n+    auto input = std::make_shared<io::BufferReader>(table_buffer);\n+    ASSERT_OK_AND_ASSIGN(auto reader, reader_factory(input));\n+    task_futures[i] = reader->ReadAsync();\n+  }\n+  auto combined_future = All(task_futures);\n+  combined_future.Wait();\n+\n+  ASSERT_OK_AND_ASSIGN(std::vector<Result<std::shared_ptr<Table>>> results,\n+                       combined_future.result());\n+  for (auto&& result : results) {\n+    ASSERT_OK_AND_ASSIGN(auto table, result);\n+    ASSERT_EQ(NROWS, table->num_rows());\n+  }\n+}\n+\n+void TestNestedParallelism(\n+    std::shared_ptr<internal::ThreadPool> thread_pool,\n+    std::function<Result<std::shared_ptr<TableReader>>(std::shared_ptr<io::InputStream>)>\n+        reader_factory) {\n+  const int NROWS = 1000;\n+  ASSERT_OK_AND_ASSIGN(auto table_buffer, MakeSampleCsvBuffer(NROWS));\n+  auto input = std::make_shared<io::BufferReader>(table_buffer);\n+  ASSERT_OK_AND_ASSIGN(auto reader, reader_factory(input));\n+\n+  Future<std::shared_ptr<Table>> table_future;\n+\n+  auto read_task = [&reader, &table_future]() mutable {\n+    table_future = reader->ReadAsync();\n+    return Status::OK();\n+  };\n+  ASSERT_OK_AND_ASSIGN(auto future, thread_pool->Submit(read_task));\n+  ASSERT_TRUE(future.Wait(1));\n+\n+  if (future.is_finished()) {\n+    ASSERT_TRUE(table_future.Wait(1));\n+    if (table_future.is_finished()) {\n+      ASSERT_OK_AND_ASSIGN(auto table, table_future.result());\n+      ASSERT_EQ(table->num_rows(), NROWS);\n+    }\n+  }\n+}  // namespace csv\n+\n+TEST(SerialReaderTests, Stress) {\n+  auto task_factory = [](std::shared_ptr<io::InputStream> input_stream) {\n+    return TableReader::Make(default_memory_pool(), io::AsyncContext(), input_stream,\n+                             ReadOptions::Defaults(), ParseOptions::Defaults(),\n+                             ConvertOptions::Defaults());\n+  };\n+  StressTableReader(task_factory);\n+}\n+\n+TEST(SerialReaderTests, NestedParallelism) {\n+  ASSERT_OK_AND_ASSIGN(auto thread_pool, internal::ThreadPool::Make(1));\n\nReview comment:\n       This is testing a harmless kind of nested parallelism with two different thread pools, right?\r\n   (the one instantiated above and the one used by default for CPU tasks)\n\n##########\nFile path: cpp/src/arrow/csv/reader.cc\n##########\n@@ -837,20 +885,121 @@ class ThreadedTableReader : public BaseTableReader {\n   }\n \n  protected:\n-  ThreadPool* thread_pool_;\n+  Executor* thread_pool_;\n+  Iterator<std::shared_ptr<Buffer>> buffer_iterator_;\n+};\n+\n+class AsyncThreadedTableReader\n+    : public BaseTableReader,\n+      public std::enable_shared_from_this<AsyncThreadedTableReader> {\n+ public:\n+  using BaseTableReader::BaseTableReader;\n+\n+  AsyncThreadedTableReader(MemoryPool* pool, std::shared_ptr<io::InputStream> input,\n+                           const ReadOptions& read_options,\n+                           const ParseOptions& parse_options,\n+                           const ConvertOptions& convert_options, Executor* thread_pool)\n+      : BaseTableReader(pool, input, read_options, parse_options, convert_options),\n+        thread_pool_(thread_pool) {}\n+\n+  ~AsyncThreadedTableReader() override {\n+    if (task_group_) {\n+      // In case of error, make sure all pending tasks are finished before\n+      // we start destroying BaseTableReader members\n+      ARROW_UNUSED(task_group_->Finish());\n+    }\n+  }\n+\n+  Status Init() override {\n+    ARROW_ASSIGN_OR_RAISE(auto istream_it,\n+                          io::MakeInputStreamIterator(input_, read_options_.block_size));\n+\n+    ARROW_ASSIGN_OR_RAISE(auto bg_it,\n+                          MakeBackgroundIterator(std::move(istream_it), thread_pool_));\n+\n+    int32_t block_queue_size = thread_pool_->GetCapacity();\n+    auto rh_it = AddReadahead(bg_it, block_queue_size);\n+    buffer_generator_ = CSVBufferIterator::MakeAsync(std::move(rh_it));\n+    return Status::OK();\n+  }\n+\n+  Result<std::shared_ptr<Table>> Read() override { return ReadAsync().result(); }\n+\n+  Future<std::shared_ptr<Table>> ReadAsync() override {\n+    task_group_ = internal::TaskGroup::MakeThreaded(thread_pool_);\n\nReview comment:\n       Do you have plans to remove TaskGroup from the picture? Ideally we should be able to call `Future::Then` on an executor, or something similar?\n\n##########\nFile path: cpp/src/arrow/result.h\n##########\n@@ -331,6 +332,7 @@ class ARROW_MUST_USE_TYPE Result : public util::EqualityComparable<Result<T>> {\n     return ValueUnsafe();\n   }\n   T& operator*() & { return ValueOrDie(); }\n+  T* operator->() { return &ValueOrDie(); }\n\nReview comment:\n       I don't know if it makes sense to add a rvalue variant below?\n\n##########\nFile path: cpp/src/arrow/util/iterator_test.cc\n##########\n@@ -129,11 +130,44 @@ template <typename T>\n inline Iterator<T> EmptyIt() {\n   return MakeEmptyIterator<T>();\n }\n-\n inline Iterator<TestInt> VectorIt(std::vector<TestInt> v) {\n   return MakeVectorIterator<TestInt>(std::move(v));\n }\n \n+std::function<Future<TestInt>()> AsyncVectorIt(std::vector<TestInt> v) {\n\nReview comment:\n       Return `AsyncGenerator<TestInt>`?\n\n##########\nFile path: cpp/src/arrow/csv/reader_test.cc\n##########\n@@ -0,0 +1,169 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstdint>\n+#include <string>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/csv/options.h\"\n+#include \"arrow/csv/reader.h\"\n+#include \"arrow/csv/test_common.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+namespace csv {\n+\n+void StressTableReader(\n+    std::function<Result<std::shared_ptr<TableReader>>(std::shared_ptr<io::InputStream>)>\n+        reader_factory) {\n+  const int NTASKS = 100;\n+  const int NROWS = 1000;\n+  ASSERT_OK_AND_ASSIGN(auto table_buffer, MakeSampleCsvBuffer(NROWS));\n+\n+  std::vector<Future<std::shared_ptr<Table>>> task_futures(NTASKS);\n+  for (int i = 0; i < NTASKS; i++) {\n+    auto input = std::make_shared<io::BufferReader>(table_buffer);\n+    ASSERT_OK_AND_ASSIGN(auto reader, reader_factory(input));\n+    task_futures[i] = reader->ReadAsync();\n+  }\n+  auto combined_future = All(task_futures);\n+  combined_future.Wait();\n+\n+  ASSERT_OK_AND_ASSIGN(std::vector<Result<std::shared_ptr<Table>>> results,\n+                       combined_future.result());\n+  for (auto&& result : results) {\n+    ASSERT_OK_AND_ASSIGN(auto table, result);\n+    ASSERT_EQ(NROWS, table->num_rows());\n+  }\n+}\n+\n+void TestNestedParallelism(\n+    std::shared_ptr<internal::ThreadPool> thread_pool,\n+    std::function<Result<std::shared_ptr<TableReader>>(std::shared_ptr<io::InputStream>)>\n+        reader_factory) {\n+  const int NROWS = 1000;\n+  ASSERT_OK_AND_ASSIGN(auto table_buffer, MakeSampleCsvBuffer(NROWS));\n+  auto input = std::make_shared<io::BufferReader>(table_buffer);\n+  ASSERT_OK_AND_ASSIGN(auto reader, reader_factory(input));\n+\n+  Future<std::shared_ptr<Table>> table_future;\n+\n+  auto read_task = [&reader, &table_future]() mutable {\n+    table_future = reader->ReadAsync();\n+    return Status::OK();\n+  };\n+  ASSERT_OK_AND_ASSIGN(auto future, thread_pool->Submit(read_task));\n+  ASSERT_TRUE(future.Wait(1));\n+\n+  if (future.is_finished()) {\n+    ASSERT_TRUE(table_future.Wait(1));\n+    if (table_future.is_finished()) {\n+      ASSERT_OK_AND_ASSIGN(auto table, table_future.result());\n+      ASSERT_EQ(table->num_rows(), NROWS);\n+    }\n+  }\n+}  // namespace csv\n+\n+TEST(SerialReaderTests, Stress) {\n+  auto task_factory = [](std::shared_ptr<io::InputStream> input_stream) {\n+    return TableReader::Make(default_memory_pool(), io::AsyncContext(), input_stream,\n+                             ReadOptions::Defaults(), ParseOptions::Defaults(),\n+                             ConvertOptions::Defaults());\n+  };\n+  StressTableReader(task_factory);\n+}\n+\n+TEST(SerialReaderTests, NestedParallelism) {\n+  ASSERT_OK_AND_ASSIGN(auto thread_pool, internal::ThreadPool::Make(1));\n+  auto task_factory = [](std::shared_ptr<io::InputStream> input_stream) {\n+    return TableReader::Make(default_memory_pool(), io::AsyncContext(), input_stream,\n+                             ReadOptions::Defaults(), ParseOptions::Defaults(),\n+                             ConvertOptions::Defaults());\n+  };\n+  TestNestedParallelism(thread_pool, task_factory);\n+}\n+\n+TEST(ThreadedReaderTests, Stress) {\n+  ASSERT_OK_AND_ASSIGN(auto thread_pool, internal::ThreadPool::Make(1));\n+  auto task_factory = [&thread_pool](std::shared_ptr<io::InputStream> input_stream)\n+      -> Result<std::shared_ptr<TableReader>> {\n+    ReadOptions read_options = ReadOptions::Defaults();\n+    read_options.use_threads = true;\n+    read_options.legacy_blocking_reads = true;\n+    auto table_reader = TableReader::Make(\n+        default_memory_pool(), io::AsyncContext(thread_pool.get()), input_stream,\n\nReview comment:\n       I'm not sure what difference it makes to change the executor used by the `AsyncContext`?\r\n   (in any case it's an executor for IO tasks, which should be distinct from the executor for CPU tasks)\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -556,6 +559,38 @@ inline bool WaitForAll(const std::vector<Future<T>*>& futures,\n   return waiter->Wait(seconds);\n }\n \n+/// \\brief Create a Future which completes when all of `futures` complete.\n+///\n+/// The future's result is a vector of the results of `futures`.\n+/// Note that this future will never be marked \"failed\"; failed results\n+/// will be stored in the result vector alongside successful results.\n+template <typename T>\n+Future<std::vector<Result<T>>> All(std::vector<Future<T>> futures) {\n+  struct State {\n+    explicit State(std::vector<Future<T>> f)\n+        : futures(std::move(f)), n_remaining(futures.size()) {}\n+\n+    std::vector<Future<T>> futures;\n+    std::atomic<size_t> n_remaining;\n+  };\n\nReview comment:\n       Hmm... did you investigate whether it was possible to reuse `FutureWaiter` instead of recreating a similar logic here?\n\n##########\nFile path: cpp/src/arrow/util/async_iterator.h\n##########\n@@ -0,0 +1,295 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+#include <queue>\n+\n+#include \"arrow/util/functional.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/thread_pool.h\"\n\nReview comment:\n       Please check whether all these includes are necessary. At least `thread_pool.h` doesn't seem necessary, unless I'm mistaken.\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +187,122 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), yield_value_() {}\n+\n+  bool HasValue() const { return yield_value_.has_value(); }\n+  bool Finished() const { return finished_; }\n+  bool ReadyForNext() const { return ready_for_next_; }\n+  T Value() const { return *yield_value_; }\n+\n+  bool finished_ = false;\n+  bool ready_for_next_ = false;\n+  util::optional<YieldValueType> yield_value_;\n+};\n+\n+struct TransformFinish {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(true, true);\n+  }\n+};\n+\n+struct TransformSkip {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(false, true);\n+  }\n+};\n+\n+template <typename T>\n+TransformFlow<T> TransformYield(T value = {}, bool ready_for_next = true) {\n\nReview comment:\n       What is \"ready_for_next\"?\n\n##########\nFile path: cpp/src/arrow/util/async_iterator.h\n##########\n@@ -0,0 +1,295 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+#include <queue>\n+\n+#include \"arrow/util/functional.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+template <typename T>\n+using AsyncGenerator = std::function<Future<T>()>;\n+\n+/// Iterates through a generator of futures, visiting the result of each one and\n+/// returning a future that completes when all have been visited\n+template <typename T>\n+Future<> VisitAsyncGenerator(AsyncGenerator<T> generator,\n+                             std::function<Status(T)> visitor) {\n+  auto loop_body = [generator, visitor] {\n+    auto next = generator();\n+    return next.Then([visitor](const T& result) -> Result<ControlFlow<detail::Empty>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(detail::Empty());\n+      } else {\n+        auto visited = visitor(result);\n+        if (visited.ok()) {\n+          return Continue();\n+        } else {\n+          return visited;\n+        }\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T>\n+Future<std::vector<T>> CollectAsyncGenerator(AsyncGenerator<T> generator) {\n+  auto vec = std::make_shared<std::vector<T>>();\n+  auto loop_body = [generator, vec] {\n+    auto next = generator();\n+    return next.Then([vec](const T& result) -> Result<ControlFlow<std::vector<T>>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(*vec);\n+      } else {\n+        vec->push_back(result);\n+        return Continue();\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T, typename V>\n+class TransformingGenerator {\n+ public:\n+  explicit TransformingGenerator(AsyncGenerator<T> generator,\n+                                 Transformer<T, V> transformer)\n+      : finished_(), last_value_(), generator_(generator), transformer_(transformer) {}\n+\n+  // See comment on TransformingIterator::Pump\n+  Result<util::optional<V>> Pump() {\n\nReview comment:\n       Is this supposed to be a public method?\n\n##########\nFile path: cpp/src/arrow/util/async_iterator.h\n##########\n@@ -0,0 +1,295 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+#include <queue>\n+\n+#include \"arrow/util/functional.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+template <typename T>\n+using AsyncGenerator = std::function<Future<T>()>;\n+\n+/// Iterates through a generator of futures, visiting the result of each one and\n+/// returning a future that completes when all have been visited\n+template <typename T>\n+Future<> VisitAsyncGenerator(AsyncGenerator<T> generator,\n+                             std::function<Status(T)> visitor) {\n+  auto loop_body = [generator, visitor] {\n\nReview comment:\n       Since we don't know how much state the generator and visitor carry, I think it would be better to move-construct an anonymous callable object.\n\n##########\nFile path: cpp/src/arrow/csv/reader_benchmark.cc\n##########\n@@ -0,0 +1,139 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"benchmark/benchmark.h\"\n+\n+#include <string>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/csv/options.h\"\n+#include \"arrow/csv/reader.h\"\n+#include \"arrow/csv/test_common.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+namespace csv {\n+\n+class SlowInputStream : public io::InputStream {\n+ public:\n+  explicit SlowInputStream(std::shared_ptr<io::BufferReader> target, int64_t latency_ms)\n+      : target_(std::move(target)) {\n+    latency_s_ = static_cast<double>(latency_ms) / 1000.0;\n+  }\n+  virtual ~SlowInputStream() {}\n+\n+  Result<util::string_view> Peek(int64_t nbytes) override {\n+    return target_->Peek(nbytes);\n+  }\n+  bool supports_zero_copy() const override { return target_->supports_zero_copy(); }\n+  Status Close() override { return target_->Close(); }\n+  Status Abort() override { return target_->Abort(); }\n+  Result<int64_t> Tell() const override { return target_->Tell(); }\n+  bool closed() const override { return target_->closed(); }\n+  Result<int64_t> Read(int64_t nbytes, void* out) override {\n+    if (latency_s_ > 0) {\n+      SleepFor(latency_s_);\n+    }\n+    return target_->Read(nbytes, out);\n+  }\n+  Result<std::shared_ptr<Buffer>> Read(int64_t nbytes) override {\n+    if (latency_s_ > 0) {\n+      SleepFor(latency_s_);\n+    }\n+    return target_->Read(nbytes);\n+  }\n+  Status Seek(int64_t pos) { return target_->Seek(pos); }\n+\n+ private:\n+  std::shared_ptr<io::BufferReader> target_;\n+  double latency_s_;\n+};\n+\n+static ReadOptions CreateReadOptions(bool use_threads, bool use_async) {\n+  auto result = csv::ReadOptions::Defaults();\n+  result.use_threads = use_threads;\n+  result.legacy_blocking_reads = !use_async;\n+  // Simulate larger files by using smaller block files so the impact of multiple\n+  // blocks is seen but we don't have to spend the time waiting on the large I/O\n+  result.block_size = (1 << 20) / 100;\n+  return result;\n+}\n+\n+static std::shared_ptr<SlowInputStream> CreateStreamReader(std::shared_ptr<Buffer> buffer,\n+                                                           int64_t latency_ms) {\n+  auto buffer_reader = std::make_shared<io::BufferReader>(buffer);\n+  return std::make_shared<SlowInputStream>(buffer_reader, latency_ms);\n+}\n+\n+static void BenchmarkReader(benchmark::State& state, bool use_threads, bool use_async) {\n+  auto latency_ms = state.range(0);\n+  auto num_rows = state.range(1);\n+  auto num_files = state.range(2);\n+  if (num_files > 5 && use_threads && !use_async) {\n+    state.SkipWithError(\"Would deadlock\");\n+  }\n+  auto input_buffer = *MakeSampleCsvBuffer(num_rows);\n+  // Hard coding # of threads so we don't deadlock if there are too few cores\n\nReview comment:\n       Can you make it a `constexpr something` at least?\r\n   \r\n   Also, why would we deadlock? The implementation should certainly prevent that. The user may be running in a 1- or 2-core VM.\n\n##########\nFile path: cpp/src/arrow/util/async_iterator.h\n##########\n@@ -0,0 +1,295 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+#include <queue>\n+\n+#include \"arrow/util/functional.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+template <typename T>\n+using AsyncGenerator = std::function<Future<T>()>;\n+\n+/// Iterates through a generator of futures, visiting the result of each one and\n+/// returning a future that completes when all have been visited\n+template <typename T>\n+Future<> VisitAsyncGenerator(AsyncGenerator<T> generator,\n+                             std::function<Status(T)> visitor) {\n\nReview comment:\n       I'm skeptical about taking `std::function<>` and praying that the compiler optimizes common cases fine, instead of a callable template argument.\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -832,9 +832,203 @@ TEST(FutureCompletionTest, FutureVoid) {\n   }\n }\n \n+TEST(FutureAllTest, Simple) {\n+  auto f1 = Future<int>::Make();\n+  auto f2 = Future<int>::Make();\n+  std::vector<Future<int>> futures = {f1, f2};\n+  auto combined = arrow::All(futures);\n+\n+  ARROW_UNUSED(combined.Then([](std::vector<Result<int>> results) {\n+    ASSERT_EQ(2, results.size());\n+    ASSERT_EQ(1, *results[0]);\n+    ASSERT_EQ(2, *results[1]);\n+  }));\n+\n+  // Finish in reverse order, results should still be delivered in proper order\n+  AssertNotFinished(combined);\n+  f2.MarkFinished(2);\n+  AssertNotFinished(combined);\n+  f1.MarkFinished(1);\n+  AssertSuccessful(combined);\n+}\n+\n+TEST(FutureAllTest, Failure) {\n+  auto f1 = Future<int>::Make();\n+  auto f2 = Future<int>::Make();\n+  auto f3 = Future<int>::Make();\n+  std::vector<Future<int>> futures = {f1, f2, f3};\n+  auto combined = arrow::All(futures);\n+\n+  ARROW_UNUSED(combined.Then([](std::vector<Result<int>> results) {\n\nReview comment:\n       Same here.\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -832,9 +832,203 @@ TEST(FutureCompletionTest, FutureVoid) {\n   }\n }\n \n+TEST(FutureAllTest, Simple) {\n+  auto f1 = Future<int>::Make();\n+  auto f2 = Future<int>::Make();\n+  std::vector<Future<int>> futures = {f1, f2};\n+  auto combined = arrow::All(futures);\n+\n+  ARROW_UNUSED(combined.Then([](std::vector<Result<int>> results) {\n+    ASSERT_EQ(2, results.size());\n+    ASSERT_EQ(1, *results[0]);\n+    ASSERT_EQ(2, *results[1]);\n+  }));\n+\n+  // Finish in reverse order, results should still be delivered in proper order\n+  AssertNotFinished(combined);\n+  f2.MarkFinished(2);\n+  AssertNotFinished(combined);\n+  f1.MarkFinished(1);\n+  AssertSuccessful(combined);\n+}\n+\n+TEST(FutureAllTest, Failure) {\n+  auto f1 = Future<int>::Make();\n+  auto f2 = Future<int>::Make();\n+  auto f3 = Future<int>::Make();\n+  std::vector<Future<int>> futures = {f1, f2, f3};\n+  auto combined = arrow::All(futures);\n+\n+  ARROW_UNUSED(combined.Then([](std::vector<Result<int>> results) {\n+    ASSERT_EQ(3, results.size());\n+    ASSERT_EQ(1, *results[0]);\n+    ASSERT_EQ(Status::IOError(\"XYZ\"), results[1].status());\n+    ASSERT_EQ(3, *results[2]);\n+  }));\n+\n+  f1.MarkFinished(1);\n+  f2.MarkFinished(Status::IOError(\"XYZ\"));\n+  f3.MarkFinished(3);\n+\n+  AssertFinished(combined);\n+}\n+\n+TEST(FutureLoopTest, Sync) {\n+  struct {\n+    int i = 0;\n+    Future<int> Get() { return Future<int>::MakeFinished(i++); }\n+  } IntSource;\n+\n+  bool do_fail = false;\n+  std::vector<int> ints;\n+  auto loop_body = [&] {\n+    return IntSource.Get().Then([&](int i) -> Result<ControlFlow<int>> {\n+      if (do_fail && i == 3) {\n+        return Status::IOError(\"xxx\");\n+      }\n+\n+      if (i == 5) {\n+        int sum = 0;\n+        for (int i : ints) sum += i;\n+        return Break(sum);\n+      }\n+\n+      ints.push_back(i);\n+      return Continue();\n+    });\n+  };\n+\n+  {\n+    auto sum_fut = Loop(loop_body);\n+    AssertSuccessful(sum_fut);\n+\n+    ASSERT_OK_AND_ASSIGN(auto sum, sum_fut.result());\n+    ASSERT_EQ(sum, 0 + 1 + 2 + 3 + 4);\n+  }\n+\n+  {\n+    do_fail = true;\n+    IntSource.i = 0;\n+    auto sum_fut = Loop(loop_body);\n+    AssertFailed(sum_fut);\n+    ASSERT_RAISES(IOError, sum_fut.result());\n+  }\n+}\n+\n+TEST(FutureLoopTest, EmptyBreakValue) {\n+  Future<> none_fut =\n+      Loop([&] { return Future<>::MakeFinished().Then([&](...) { return Break(); }); });\n+  AssertSuccessful(none_fut);\n+}\n+\n+TEST(FutureLoopTest, MoveOnlyBreakValue) {\n+  Future<MoveOnlyDataType> one_fut = Loop([&] {\n+    return Future<int>::MakeFinished(1).Then(\n+        [&](int i) { return Break(MoveOnlyDataType(i)); });\n+  });\n+  AssertSuccessful(one_fut);\n+  ASSERT_OK_AND_ASSIGN(auto one, std::move(one_fut).result());\n+  ASSERT_EQ(one, 1);\n+}\n+\n+TEST(FutureLoopTest, StackOverflow) {\n+  // Looping over futures is normally a rather recursive task.  If the futures complete\n+  // synchronously (because they are already finished) it could lead to a stack overflow\n+  // if care is not taken.\n+  int counter = 0;\n+  auto loop_body = [&counter]() -> Future<ControlFlow<int>> {\n+    while (counter < 1000000) {\n+      counter++;\n+      return Future<ControlFlow<int>>::MakeFinished(Continue());\n+    }\n+    return Future<ControlFlow<int>>::MakeFinished(Break(-1));\n+  };\n+  auto loop_fut = Loop(loop_body);\n+  ASSERT_TRUE(loop_fut.Wait(0.1));\n+}\n+\n+TEST(FutureLoopTest, AllowsBreakFutToBeDiscarded) {\n+  int counter = 0;\n+  auto loop_body = [&counter]() -> Future<ControlFlow<int>> {\n+    while (counter < 10) {\n+      counter++;\n+      return Future<ControlFlow<int>>::MakeFinished(Continue());\n+    }\n+    return Future<ControlFlow<int>>::MakeFinished(Break(-1));\n+  };\n+  auto loop_fut = Loop(loop_body).Then([](...) { return Status::OK(); });\n+  ASSERT_TRUE(loop_fut.Wait(0.1));\n+}\n+\n+TEST(FutureLoopTest, EmptyLoop) {\n+  auto loop_body = []() -> Future<ControlFlow<int>> {\n+    return Future<ControlFlow<int>>::MakeFinished(Break(0));\n+  };\n+  auto loop_fut = Loop(loop_body);\n+  ASSERT_TRUE(loop_fut.Wait(0.1));\n+  if (loop_fut.is_finished()) {\n\nReview comment:\n       Why the `if`?\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -580,4 +615,74 @@ inline std::vector<int> WaitForAny(const std::vector<Future<T>*>& futures,\n   return waiter->MoveFinishedFutures();\n }\n \n+template <typename T = detail::Empty>\n+struct ControlFlow {\n+  using BreakValueType = T;\n+\n+  bool IsBreak() const { return break_value_.has_value(); }\n+\n+  static Result<BreakValueType> MoveBreakValue(const ControlFlow& cf) {\n+    return std::move(*cf.break_value_);\n+  }\n+\n+  mutable util::optional<BreakValueType> break_value_;\n+};\n+\n+struct Continue {\n+  template <typename T>\n+  operator ControlFlow<T>() && {  // NOLINT explicit\n+    return {};\n+  }\n+};\n+\n+template <typename T = detail::Empty>\n+ControlFlow<T> Break(T break_value = {}) {\n+  return ControlFlow<T>{std::move(break_value)};\n+}\n+\n+template <typename Iterate,\n+          typename Control = typename detail::result_of_t<Iterate()>::ValueType,\n+          typename BreakValueType = typename Control::BreakValueType>\n+Future<BreakValueType> Loop(Iterate iterate) {\n+  auto break_fut = Future<BreakValueType>::Make();\n+\n+  struct Callback {\n+    bool CheckForTermination(const Result<Control>& maybe_control) {\n+      if (!maybe_control.ok() || maybe_control->IsBreak()) {\n+        Result<BreakValueType> maybe_break = maybe_control.Map(Control::MoveBreakValue);\n+        break_fut.MarkFinished(std::move(maybe_break));\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    void operator()(const Result<Control>& maybe_control) && {\n+      if (CheckForTermination(maybe_control)) return;\n+\n+      auto control_fut = iterate();\n+      while (control_fut.is_finished()) {\n+        // There's no need to AddCallback on a finished future; we can CheckForTermination\n+        // now. This also avoids recursion and potential stack overflow.\n\nReview comment:\n       But note the future may finish between here and the `AddCallback()` call below. So while this reduces the risk of stack overflow, it doesn't eliminate it.\r\n   \r\n   Is there a way to avoid such fragility?\r\n   \n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -428,10 +547,16 @@ struct ReadaheadIteratorPromise : ReadaheadPromise {\n \n   explicit ReadaheadIteratorPromise(Iterator<T>* it) : it_(it) {}\n \n-  void Call() override {\n+  bool Call() override {\n     assert(!called_);\n     out_ = it_->Next();\n     called_ = true;\n+    return out_ == IterationTraits<T>::End();\n+  }\n+\n+  void End() override {\n+    // No need to do anything for the synchronous case.  No one is waiting on this\n+    // called_ = true;\n\nReview comment:\n       Why is this commented out?\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -580,4 +615,74 @@ inline std::vector<int> WaitForAny(const std::vector<Future<T>*>& futures,\n   return waiter->MoveFinishedFutures();\n }\n \n+template <typename T = detail::Empty>\n+struct ControlFlow {\n+  using BreakValueType = T;\n+\n+  bool IsBreak() const { return break_value_.has_value(); }\n+\n+  static Result<BreakValueType> MoveBreakValue(const ControlFlow& cf) {\n+    return std::move(*cf.break_value_);\n+  }\n+\n+  mutable util::optional<BreakValueType> break_value_;\n+};\n+\n+struct Continue {\n+  template <typename T>\n+  operator ControlFlow<T>() && {  // NOLINT explicit\n+    return {};\n+  }\n+};\n+\n+template <typename T = detail::Empty>\n+ControlFlow<T> Break(T break_value = {}) {\n+  return ControlFlow<T>{std::move(break_value)};\n+}\n+\n+template <typename Iterate,\n+          typename Control = typename detail::result_of_t<Iterate()>::ValueType,\n+          typename BreakValueType = typename Control::BreakValueType>\n\nReview comment:\n       Hmm... can't `ControlFlow<T>` simply be a `util::optional<T>`?\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +187,122 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), yield_value_() {}\n+\n+  bool HasValue() const { return yield_value_.has_value(); }\n+  bool Finished() const { return finished_; }\n+  bool ReadyForNext() const { return ready_for_next_; }\n+  T Value() const { return *yield_value_; }\n+\n+  bool finished_ = false;\n+  bool ready_for_next_ = false;\n+  util::optional<YieldValueType> yield_value_;\n+};\n+\n+struct TransformFinish {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(true, true);\n+  }\n+};\n+\n+struct TransformSkip {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(false, true);\n+  }\n+};\n+\n+template <typename T>\n+TransformFlow<T> TransformYield(T value = {}, bool ready_for_next = true) {\n+  return TransformFlow<T>(std::move(value), ready_for_next);\n+}\n+\n+template <typename T, typename V>\n+using Transformer = std::function<Result<TransformFlow<V>>(T)>;\n+\n+template <typename T, typename V>\n+class TransformIterator {\n+ public:\n+  explicit TransformIterator(Iterator<T> it, Transformer<T, V> transformer)\n+      : it_(std::move(it)),\n+        transformer_(std::move(transformer)),\n+        last_value_(),\n+        finished_() {}\n+\n+  // Calls the transform function on the current value.  Can return in several ways\n+  // * If the next value is requested (e.g. skip) it will return an empty optional\n+  // * If an invalid status is encountered that will be returned\n+  // * If finished it will return IterationTraits<V>::End()\n+  // * If a value is returned by the transformer that will be returned\n+  Result<util::optional<V>> Pump() {\n\nReview comment:\n       Is this public?\n\n##########\nFile path: cpp/src/arrow/util/task_group.h\n##########\n@@ -63,6 +63,20 @@ class ARROW_EXPORT TaskGroup : public std::enable_shared_from_this<TaskGroup> {\n   /// task (or subgroup).\n   virtual Status Finish() = 0;\n \n+  /// Returns a future that will complete the first time all tasks are finished.\n+  /// This should be called only after all top level tasks\n+  /// have been added to the task group.\n+  ///\n+  /// If you are using a TaskGroup asyncrhonously there are a few considerations to keep\n\nReview comment:\n       \"asynchronously\"\n\n##########\nFile path: cpp/src/arrow/util/iterator_test.cc\n##########\n@@ -214,6 +255,270 @@ TEST(TestVectorIterator, RangeForLoop) {\n   ASSERT_EQ(ints_it, ints.end());\n }\n \n+template <typename T>\n+Transformer<T, T> MakeFirstN(int n) {\n+  int remaining = n;\n+  return [remaining](T next) mutable -> Result<TransformFlow<T>> {\n+    if (remaining > 0) {\n+      remaining--;\n+      return TransformYield(next);\n+    }\n+    return TransformFinish();\n+  };\n+}\n+\n+TEST(TestIteratorTransform, Truncating) {\n+  auto original = VectorIt({1, 2, 3});\n+  auto truncated = MakeTransformedIterator(std::move(original), MakeFirstN<TestInt>(2));\n+  AssertIteratorMatch({1, 2}, std::move(truncated));\n+}\n+\n+TEST(TestIteratorTransform, TestPointer) {\n+  auto original = VectorIt<std::shared_ptr<int>>(\n+      {std::make_shared<int>(1), std::make_shared<int>(2), std::make_shared<int>(3)});\n+  auto truncated =\n+      MakeTransformedIterator(std::move(original), MakeFirstN<std::shared_ptr<int>>(2));\n+  ASSERT_OK_AND_ASSIGN(auto result, truncated.ToVector());\n+  ASSERT_EQ(2, result.size());\n+}\n+\n+TEST(TestIteratorTransform, TruncatingShort) {\n+  // Tests the failsafe case where we never call Finish\n+  auto original = VectorIt({1});\n+  auto truncated = MakeTransformedIterator<TestInt, TestInt>(std::move(original),\n+                                                             MakeFirstN<TestInt>(2));\n+  AssertIteratorMatch({1}, std::move(truncated));\n+}\n+\n+TEST(TestAsyncUtil, Background) {\n+  std::vector<TestInt> expected = {1, 2, 3};\n+  auto background = BackgroundAsyncVectorIt(expected);\n+  auto future = CollectAsyncGenerator(background);\n+  ASSERT_FALSE(future.is_finished());\n+  future.Wait();\n+  ASSERT_TRUE(future.is_finished());\n+  ASSERT_EQ(expected, *future.result());\n+}\n+\n+struct SlowEmptyIterator {\n+  Result<TestInt> Next() {\n+    if (called_) {\n+      return Status::Invalid(\"Should not have been called twice\");\n+    }\n+    SleepFor(0.1);\n+    return IterationTraits<TestInt>::End();\n+  }\n+\n+ private:\n+  bool called_ = false;\n+};\n+\n+TEST(TestAsyncUtil, BackgroundRepeatEnd) {\n+  // Ensure that the background iterator properly fulfills the asyncgenerator contract\n+  // and can be called after it ends.\n+  auto iterator = Iterator<TestInt>(SlowEmptyIterator());\n+  ASSERT_OK_AND_ASSIGN(\n+      auto background_iter,\n+      MakeBackgroundIterator(std::move(iterator), internal::GetCpuThreadPool()));\n+\n+  auto one = background_iter();\n+  auto two = background_iter();\n+\n+  ASSERT_TRUE(one.Wait(0.5));\n+\n+  if (one.is_finished()) {\n\nReview comment:\n       Why `if`?\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -186,6 +187,122 @@ class Iterator : public util::EqualityComparable<Iterator<T>> {\n   Result<T> (*next_)(void*) = NULLPTR;\n };\n \n+template <typename T>\n+struct TransformFlow {\n+  using YieldValueType = T;\n+\n+  TransformFlow(YieldValueType value, bool ready_for_next)\n+      : finished_(false),\n+        ready_for_next_(ready_for_next),\n+        yield_value_(std::move(value)) {}\n+  TransformFlow(bool finished, bool ready_for_next)\n+      : finished_(finished), ready_for_next_(ready_for_next), yield_value_() {}\n+\n+  bool HasValue() const { return yield_value_.has_value(); }\n+  bool Finished() const { return finished_; }\n+  bool ReadyForNext() const { return ready_for_next_; }\n+  T Value() const { return *yield_value_; }\n+\n+  bool finished_ = false;\n+  bool ready_for_next_ = false;\n+  util::optional<YieldValueType> yield_value_;\n+};\n+\n+struct TransformFinish {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(true, true);\n+  }\n+};\n+\n+struct TransformSkip {\n+  template <typename T>\n+  operator TransformFlow<T>() && {  // NOLINT explicit\n+    return TransformFlow<T>(false, true);\n+  }\n+};\n+\n+template <typename T>\n+TransformFlow<T> TransformYield(T value = {}, bool ready_for_next = true) {\n+  return TransformFlow<T>(std::move(value), ready_for_next);\n+}\n+\n+template <typename T, typename V>\n+using Transformer = std::function<Result<TransformFlow<V>>(T)>;\n+\n+template <typename T, typename V>\n+class TransformIterator {\n+ public:\n+  explicit TransformIterator(Iterator<T> it, Transformer<T, V> transformer)\n+      : it_(std::move(it)),\n+        transformer_(std::move(transformer)),\n+        last_value_(),\n+        finished_() {}\n+\n+  // Calls the transform function on the current value.  Can return in several ways\n+  // * If the next value is requested (e.g. skip) it will return an empty optional\n+  // * If an invalid status is encountered that will be returned\n+  // * If finished it will return IterationTraits<V>::End()\n+  // * If a value is returned by the transformer that will be returned\n+  Result<util::optional<V>> Pump() {\n+    if (!finished_ && last_value_.has_value()) {\n+      ARROW_ASSIGN_OR_RAISE(TransformFlow<V> next, transformer_(*last_value_));\n+      if (next.ReadyForNext()) {\n+        if (*last_value_ == IterationTraits<T>::End()) {\n+          finished_ = true;\n+        }\n+        last_value_.reset();\n+      }\n+      if (next.Finished()) {\n+        finished_ = true;\n+      }\n+      if (next.HasValue()) {\n+        return next.Value();\n+      }\n+    }\n+    if (finished_) {\n+      return IterationTraits<V>::End();\n+    }\n+    return util::nullopt;\n+  }\n+\n+  Result<V> Next() {\n+    while (!finished_) {\n+      ARROW_ASSIGN_OR_RAISE(util::optional<V> next, Pump());\n+      if (next.has_value()) {\n+        return *next;\n+      }\n+      ARROW_ASSIGN_OR_RAISE(last_value_, it_.Next());\n+    }\n+    return IterationTraits<V>::End();\n+  }\n+\n+ private:\n+  Iterator<T> it_;\n+  Transformer<T, V> transformer_;\n+  util::optional<T> last_value_;\n+  bool finished_ = false;\n+};\n+\n+/// \\brief Transforms an iterator according to a transformer, returning a new Iterator.\n+///\n+/// The transformer will be called on each element of the source iterator and for each\n+/// call it can yield a value, skip, or finish the iteration.  When yielding a value the\n+/// transformer can choose to consume the source item (the default, ready_for_next = true)\n+/// or to keep it and it will be called again on the same value.\n\nReview comment:\n       Why called again on the same value? Is there some non-toy use case?\n\n##########\nFile path: cpp/src/arrow/util/iterator_test.cc\n##########\n@@ -214,6 +255,270 @@ TEST(TestVectorIterator, RangeForLoop) {\n   ASSERT_EQ(ints_it, ints.end());\n }\n \n+template <typename T>\n+Transformer<T, T> MakeFirstN(int n) {\n+  int remaining = n;\n+  return [remaining](T next) mutable -> Result<TransformFlow<T>> {\n+    if (remaining > 0) {\n+      remaining--;\n+      return TransformYield(next);\n+    }\n+    return TransformFinish();\n+  };\n+}\n+\n+TEST(TestIteratorTransform, Truncating) {\n+  auto original = VectorIt({1, 2, 3});\n+  auto truncated = MakeTransformedIterator(std::move(original), MakeFirstN<TestInt>(2));\n+  AssertIteratorMatch({1, 2}, std::move(truncated));\n+}\n+\n+TEST(TestIteratorTransform, TestPointer) {\n+  auto original = VectorIt<std::shared_ptr<int>>(\n+      {std::make_shared<int>(1), std::make_shared<int>(2), std::make_shared<int>(3)});\n+  auto truncated =\n+      MakeTransformedIterator(std::move(original), MakeFirstN<std::shared_ptr<int>>(2));\n+  ASSERT_OK_AND_ASSIGN(auto result, truncated.ToVector());\n+  ASSERT_EQ(2, result.size());\n+}\n+\n+TEST(TestIteratorTransform, TruncatingShort) {\n+  // Tests the failsafe case where we never call Finish\n+  auto original = VectorIt({1});\n+  auto truncated = MakeTransformedIterator<TestInt, TestInt>(std::move(original),\n+                                                             MakeFirstN<TestInt>(2));\n+  AssertIteratorMatch({1}, std::move(truncated));\n+}\n+\n+TEST(TestAsyncUtil, Background) {\n+  std::vector<TestInt> expected = {1, 2, 3};\n+  auto background = BackgroundAsyncVectorIt(expected);\n+  auto future = CollectAsyncGenerator(background);\n+  ASSERT_FALSE(future.is_finished());\n+  future.Wait();\n+  ASSERT_TRUE(future.is_finished());\n+  ASSERT_EQ(expected, *future.result());\n+}\n+\n+struct SlowEmptyIterator {\n+  Result<TestInt> Next() {\n+    if (called_) {\n+      return Status::Invalid(\"Should not have been called twice\");\n+    }\n+    SleepFor(0.1);\n+    return IterationTraits<TestInt>::End();\n+  }\n+\n+ private:\n+  bool called_ = false;\n+};\n+\n+TEST(TestAsyncUtil, BackgroundRepeatEnd) {\n+  // Ensure that the background iterator properly fulfills the asyncgenerator contract\n+  // and can be called after it ends.\n+  auto iterator = Iterator<TestInt>(SlowEmptyIterator());\n+  ASSERT_OK_AND_ASSIGN(\n+      auto background_iter,\n+      MakeBackgroundIterator(std::move(iterator), internal::GetCpuThreadPool()));\n+\n+  auto one = background_iter();\n+  auto two = background_iter();\n+\n+  ASSERT_TRUE(one.Wait(0.5));\n+\n+  if (one.is_finished()) {\n+    ASSERT_EQ(IterationTraits<TestInt>::End(), *one.result());\n+  }\n+\n+  ASSERT_TRUE(two.Wait(0.5));\n+  ASSERT_TRUE(two.is_finished());\n+  if (two.is_finished()) {\n+    ASSERT_EQ(IterationTraits<TestInt>::End(), *two.result());\n+  }\n+}\n+\n+TEST(TestAsyncUtil, SynchronousFinish) {\n+  AsyncGenerator<TestInt> generator = []() {\n+    return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\n+  };\n+  Transformer<TestInt, TestInt> skip_all = [](TestInt value) { return TransformSkip(); };\n+  auto transformed = TransformAsyncGenerator(generator, skip_all);\n+  auto future = CollectAsyncGenerator(transformed);\n+  ASSERT_TRUE(future.is_finished());\n+  ASSERT_OK_AND_ASSIGN(auto actual, future.result());\n+  ASSERT_EQ(std::vector<TestInt>(), actual);\n+}\n+\n+TEST(TestAsyncUtil, CompleteBackgroundStressTest) {\n+  auto expected = RangeVector(100);\n+  std::vector<Future<std::vector<TestInt>>> futures;\n+  for (unsigned int i = 0; i < 100; i++) {\n+    auto background = BackgroundAsyncVectorIt(expected);\n+    futures.push_back(CollectAsyncGenerator(background));\n+  }\n+  auto combined = All(futures);\n+  combined.Wait(2);\n+  if (combined.is_finished()) {\n+    ASSERT_OK_AND_ASSIGN(auto completed_vectors, combined.result());\n+    for (auto&& vector : completed_vectors) {\n+      ASSERT_EQ(vector, expected);\n+    }\n+  } else {\n+    FAIL() << \"After 2 seconds all background iterators had not finished collecting\";\n+  }\n+}\n+\n+TEST(TestAsyncUtil, StackOverflow) {\n+  int counter = 0;\n+  AsyncGenerator<TestInt> generator = [&counter]() {\n+    if (counter < 1000000) {\n+      return Future<TestInt>::MakeFinished(counter++);\n+    } else {\n+      return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\n+    }\n+  };\n+  Transformer<TestInt, TestInt> discard =\n+      [](TestInt next) -> Result<TransformFlow<TestInt>> { return TransformSkip(); };\n+  auto transformed = TransformAsyncGenerator(generator, discard);\n+  auto collected_future = CollectAsyncGenerator(transformed);\n+  ASSERT_TRUE(collected_future.Wait(5));\n+  if (collected_future.is_finished()) {\n+    ASSERT_OK_AND_ASSIGN(auto collected, collected_future.result());\n+    ASSERT_EQ(0, collected.size());\n+  }\n+}\n+\n+TEST(TestAsyncUtil, Visit) {\n+  auto generator = AsyncVectorIt({1, 2, 3});\n+  unsigned int sum = 0;\n+  auto sum_future = VisitAsyncGenerator<TestInt>(generator, [&sum](TestInt item) {\n+    sum += item.value;\n+    return Status::OK();\n+  });\n+  // Should be superfluous\n+  sum_future.Wait();\n+  ASSERT_EQ(6, sum);\n+}\n+\n+TEST(TestAsyncUtil, Collect) {\n+  std::vector<TestInt> expected = {1, 2, 3};\n+  auto generator = AsyncVectorIt(expected);\n+  auto collected = CollectAsyncGenerator(generator);\n+  ASSERT_EQ(expected, *collected.result());\n+}\n+\n+template <typename T>\n+Transformer<T, T> MakeRepeatN(int repeat_count) {\n+  int current_repeat = 0;\n+  return [repeat_count, current_repeat](T next) mutable -> Result<TransformFlow<T>> {\n+    current_repeat++;\n+    bool ready_for_next = false;\n+    if (current_repeat == repeat_count) {\n+      current_repeat = 0;\n+      ready_for_next = true;\n+    }\n+    return TransformYield(next, ready_for_next);\n+  };\n+}\n+\n+TEST(TestIteratorTransform, Repeating) {\n\nReview comment:\n       Can you take care to group the tests semantically?\r\n   I would expect all `TestIteratorTransform`s to be grouped together.\r\n   Also it would be nice to have async iterator tests grouped separately from regular iterator tests.\r\n   Also, basic primitives (e.g. `CollectAsyncGenerator`) should generally be tested before more complex ones.\r\n   \r\n   Without any care for test ordering, test files become write-only.\n\n##########\nFile path: cpp/src/arrow/util/iterator_test.cc\n##########\n@@ -214,6 +255,270 @@ TEST(TestVectorIterator, RangeForLoop) {\n   ASSERT_EQ(ints_it, ints.end());\n }\n \n+template <typename T>\n+Transformer<T, T> MakeFirstN(int n) {\n+  int remaining = n;\n+  return [remaining](T next) mutable -> Result<TransformFlow<T>> {\n+    if (remaining > 0) {\n+      remaining--;\n+      return TransformYield(next);\n+    }\n+    return TransformFinish();\n+  };\n+}\n+\n+TEST(TestIteratorTransform, Truncating) {\n+  auto original = VectorIt({1, 2, 3});\n+  auto truncated = MakeTransformedIterator(std::move(original), MakeFirstN<TestInt>(2));\n+  AssertIteratorMatch({1, 2}, std::move(truncated));\n+}\n+\n+TEST(TestIteratorTransform, TestPointer) {\n+  auto original = VectorIt<std::shared_ptr<int>>(\n+      {std::make_shared<int>(1), std::make_shared<int>(2), std::make_shared<int>(3)});\n+  auto truncated =\n+      MakeTransformedIterator(std::move(original), MakeFirstN<std::shared_ptr<int>>(2));\n+  ASSERT_OK_AND_ASSIGN(auto result, truncated.ToVector());\n+  ASSERT_EQ(2, result.size());\n+}\n+\n+TEST(TestIteratorTransform, TruncatingShort) {\n+  // Tests the failsafe case where we never call Finish\n+  auto original = VectorIt({1});\n+  auto truncated = MakeTransformedIterator<TestInt, TestInt>(std::move(original),\n+                                                             MakeFirstN<TestInt>(2));\n+  AssertIteratorMatch({1}, std::move(truncated));\n+}\n+\n+TEST(TestAsyncUtil, Background) {\n+  std::vector<TestInt> expected = {1, 2, 3};\n+  auto background = BackgroundAsyncVectorIt(expected);\n+  auto future = CollectAsyncGenerator(background);\n+  ASSERT_FALSE(future.is_finished());\n+  future.Wait();\n+  ASSERT_TRUE(future.is_finished());\n+  ASSERT_EQ(expected, *future.result());\n+}\n+\n+struct SlowEmptyIterator {\n+  Result<TestInt> Next() {\n+    if (called_) {\n+      return Status::Invalid(\"Should not have been called twice\");\n+    }\n+    SleepFor(0.1);\n+    return IterationTraits<TestInt>::End();\n+  }\n+\n+ private:\n+  bool called_ = false;\n+};\n+\n+TEST(TestAsyncUtil, BackgroundRepeatEnd) {\n+  // Ensure that the background iterator properly fulfills the asyncgenerator contract\n+  // and can be called after it ends.\n+  auto iterator = Iterator<TestInt>(SlowEmptyIterator());\n+  ASSERT_OK_AND_ASSIGN(\n+      auto background_iter,\n+      MakeBackgroundIterator(std::move(iterator), internal::GetCpuThreadPool()));\n+\n+  auto one = background_iter();\n+  auto two = background_iter();\n+\n+  ASSERT_TRUE(one.Wait(0.5));\n+\n+  if (one.is_finished()) {\n+    ASSERT_EQ(IterationTraits<TestInt>::End(), *one.result());\n+  }\n+\n+  ASSERT_TRUE(two.Wait(0.5));\n+  ASSERT_TRUE(two.is_finished());\n+  if (two.is_finished()) {\n+    ASSERT_EQ(IterationTraits<TestInt>::End(), *two.result());\n+  }\n+}\n+\n+TEST(TestAsyncUtil, SynchronousFinish) {\n+  AsyncGenerator<TestInt> generator = []() {\n+    return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\n+  };\n+  Transformer<TestInt, TestInt> skip_all = [](TestInt value) { return TransformSkip(); };\n+  auto transformed = TransformAsyncGenerator(generator, skip_all);\n+  auto future = CollectAsyncGenerator(transformed);\n+  ASSERT_TRUE(future.is_finished());\n+  ASSERT_OK_AND_ASSIGN(auto actual, future.result());\n+  ASSERT_EQ(std::vector<TestInt>(), actual);\n+}\n+\n+TEST(TestAsyncUtil, CompleteBackgroundStressTest) {\n+  auto expected = RangeVector(100);\n+  std::vector<Future<std::vector<TestInt>>> futures;\n+  for (unsigned int i = 0; i < 100; i++) {\n+    auto background = BackgroundAsyncVectorIt(expected);\n+    futures.push_back(CollectAsyncGenerator(background));\n+  }\n+  auto combined = All(futures);\n+  combined.Wait(2);\n+  if (combined.is_finished()) {\n+    ASSERT_OK_AND_ASSIGN(auto completed_vectors, combined.result());\n+    for (auto&& vector : completed_vectors) {\n+      ASSERT_EQ(vector, expected);\n\nReview comment:\n       Hmm... unless I'm mistaken, `vector` should be a `Result<std::vector<TestInt>>`? How can it be compared with a `std::vector<TestInt>`?\n\n##########\nFile path: cpp/src/arrow/util/iterator_test.cc\n##########\n@@ -214,6 +255,270 @@ TEST(TestVectorIterator, RangeForLoop) {\n   ASSERT_EQ(ints_it, ints.end());\n }\n \n+template <typename T>\n+Transformer<T, T> MakeFirstN(int n) {\n+  int remaining = n;\n+  return [remaining](T next) mutable -> Result<TransformFlow<T>> {\n+    if (remaining > 0) {\n+      remaining--;\n+      return TransformYield(next);\n+    }\n+    return TransformFinish();\n+  };\n+}\n+\n+TEST(TestIteratorTransform, Truncating) {\n+  auto original = VectorIt({1, 2, 3});\n+  auto truncated = MakeTransformedIterator(std::move(original), MakeFirstN<TestInt>(2));\n+  AssertIteratorMatch({1, 2}, std::move(truncated));\n+}\n+\n+TEST(TestIteratorTransform, TestPointer) {\n+  auto original = VectorIt<std::shared_ptr<int>>(\n+      {std::make_shared<int>(1), std::make_shared<int>(2), std::make_shared<int>(3)});\n+  auto truncated =\n+      MakeTransformedIterator(std::move(original), MakeFirstN<std::shared_ptr<int>>(2));\n+  ASSERT_OK_AND_ASSIGN(auto result, truncated.ToVector());\n+  ASSERT_EQ(2, result.size());\n+}\n+\n+TEST(TestIteratorTransform, TruncatingShort) {\n+  // Tests the failsafe case where we never call Finish\n+  auto original = VectorIt({1});\n+  auto truncated = MakeTransformedIterator<TestInt, TestInt>(std::move(original),\n+                                                             MakeFirstN<TestInt>(2));\n+  AssertIteratorMatch({1}, std::move(truncated));\n+}\n+\n+TEST(TestAsyncUtil, Background) {\n+  std::vector<TestInt> expected = {1, 2, 3};\n+  auto background = BackgroundAsyncVectorIt(expected);\n+  auto future = CollectAsyncGenerator(background);\n+  ASSERT_FALSE(future.is_finished());\n+  future.Wait();\n+  ASSERT_TRUE(future.is_finished());\n+  ASSERT_EQ(expected, *future.result());\n+}\n+\n+struct SlowEmptyIterator {\n+  Result<TestInt> Next() {\n+    if (called_) {\n+      return Status::Invalid(\"Should not have been called twice\");\n+    }\n+    SleepFor(0.1);\n+    return IterationTraits<TestInt>::End();\n+  }\n+\n+ private:\n+  bool called_ = false;\n+};\n+\n+TEST(TestAsyncUtil, BackgroundRepeatEnd) {\n+  // Ensure that the background iterator properly fulfills the asyncgenerator contract\n+  // and can be called after it ends.\n+  auto iterator = Iterator<TestInt>(SlowEmptyIterator());\n+  ASSERT_OK_AND_ASSIGN(\n+      auto background_iter,\n+      MakeBackgroundIterator(std::move(iterator), internal::GetCpuThreadPool()));\n+\n+  auto one = background_iter();\n+  auto two = background_iter();\n+\n+  ASSERT_TRUE(one.Wait(0.5));\n+\n+  if (one.is_finished()) {\n+    ASSERT_EQ(IterationTraits<TestInt>::End(), *one.result());\n+  }\n+\n+  ASSERT_TRUE(two.Wait(0.5));\n+  ASSERT_TRUE(two.is_finished());\n+  if (two.is_finished()) {\n+    ASSERT_EQ(IterationTraits<TestInt>::End(), *two.result());\n+  }\n+}\n+\n+TEST(TestAsyncUtil, SynchronousFinish) {\n+  AsyncGenerator<TestInt> generator = []() {\n+    return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\n+  };\n+  Transformer<TestInt, TestInt> skip_all = [](TestInt value) { return TransformSkip(); };\n+  auto transformed = TransformAsyncGenerator(generator, skip_all);\n+  auto future = CollectAsyncGenerator(transformed);\n+  ASSERT_TRUE(future.is_finished());\n+  ASSERT_OK_AND_ASSIGN(auto actual, future.result());\n+  ASSERT_EQ(std::vector<TestInt>(), actual);\n+}\n+\n+TEST(TestAsyncUtil, CompleteBackgroundStressTest) {\n+  auto expected = RangeVector(100);\n+  std::vector<Future<std::vector<TestInt>>> futures;\n+  for (unsigned int i = 0; i < 100; i++) {\n+    auto background = BackgroundAsyncVectorIt(expected);\n+    futures.push_back(CollectAsyncGenerator(background));\n+  }\n+  auto combined = All(futures);\n+  combined.Wait(2);\n+  if (combined.is_finished()) {\n+    ASSERT_OK_AND_ASSIGN(auto completed_vectors, combined.result());\n+    for (auto&& vector : completed_vectors) {\n+      ASSERT_EQ(vector, expected);\n+    }\n+  } else {\n+    FAIL() << \"After 2 seconds all background iterators had not finished collecting\";\n+  }\n+}\n+\n+TEST(TestAsyncUtil, StackOverflow) {\n+  int counter = 0;\n+  AsyncGenerator<TestInt> generator = [&counter]() {\n+    if (counter < 1000000) {\n+      return Future<TestInt>::MakeFinished(counter++);\n+    } else {\n+      return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\n+    }\n+  };\n+  Transformer<TestInt, TestInt> discard =\n+      [](TestInt next) -> Result<TransformFlow<TestInt>> { return TransformSkip(); };\n+  auto transformed = TransformAsyncGenerator(generator, discard);\n+  auto collected_future = CollectAsyncGenerator(transformed);\n+  ASSERT_TRUE(collected_future.Wait(5));\n+  if (collected_future.is_finished()) {\n+    ASSERT_OK_AND_ASSIGN(auto collected, collected_future.result());\n+    ASSERT_EQ(0, collected.size());\n+  }\n+}\n+\n+TEST(TestAsyncUtil, Visit) {\n+  auto generator = AsyncVectorIt({1, 2, 3});\n+  unsigned int sum = 0;\n+  auto sum_future = VisitAsyncGenerator<TestInt>(generator, [&sum](TestInt item) {\n+    sum += item.value;\n+    return Status::OK();\n+  });\n+  // Should be superfluous\n+  sum_future.Wait();\n+  ASSERT_EQ(6, sum);\n+}\n+\n+TEST(TestAsyncUtil, Collect) {\n+  std::vector<TestInt> expected = {1, 2, 3};\n+  auto generator = AsyncVectorIt(expected);\n+  auto collected = CollectAsyncGenerator(generator);\n+  ASSERT_EQ(expected, *collected.result());\n+}\n+\n+template <typename T>\n+Transformer<T, T> MakeRepeatN(int repeat_count) {\n+  int current_repeat = 0;\n+  return [repeat_count, current_repeat](T next) mutable -> Result<TransformFlow<T>> {\n+    current_repeat++;\n+    bool ready_for_next = false;\n+    if (current_repeat == repeat_count) {\n+      current_repeat = 0;\n+      ready_for_next = true;\n+    }\n+    return TransformYield(next, ready_for_next);\n+  };\n+}\n+\n+TEST(TestIteratorTransform, Repeating) {\n+  auto original = VectorIt({1, 2, 3});\n+  auto repeated = MakeTransformedIterator<TestInt, TestInt>(std::move(original),\n+                                                            MakeRepeatN<TestInt>(2));\n+  AssertIteratorMatch({1, 1, 2, 2, 3, 3}, std::move(repeated));\n+}\n+\n+template <typename T>\n+Transformer<T, T> MakeFilter(std::function<bool(T&)> filter) {\n+  return [filter](T next) -> Result<TransformFlow<T>> {\n+    if (filter(next)) {\n+      return TransformYield(next);\n+    } else {\n+      return TransformSkip();\n+    }\n+  };\n+}\n+\n+template <typename T>\n+Transformer<T, T> MakeAbortOnSecond() {\n+  int counter = 0;\n+  return [counter](T next) mutable -> Result<TransformFlow<T>> {\n+    if (counter++ == 1) {\n+      return Status::Invalid(\"X\");\n+    }\n+    return TransformYield(next);\n+  };\n+}\n+\n+TEST(TestIteratorTransform, SkipSome) {\n+  // Exercises TransformSkip\n+  auto original = VectorIt({1, 2, 3});\n+  auto filter = MakeFilter<TestInt>([](TestInt& t) { return t.value != 2; });\n+  auto filtered = MakeTransformedIterator(std::move(original), filter);\n+  AssertIteratorMatch({1, 3}, std::move(filtered));\n+}\n+\n+TEST(TestIteratorTransform, SkipAll) {\n+  // Exercises TransformSkip\n+  auto original = VectorIt({1, 2, 3});\n+  auto filter = MakeFilter<TestInt>([](TestInt& t) { return false; });\n+  auto filtered = MakeTransformedIterator(std::move(original), filter);\n+  AssertIteratorMatch({}, std::move(filtered));\n+}\n+\n+TEST(TestIteratorTransform, Abort) {\n+  auto original = VectorIt({1, 2, 3});\n+  auto transformed =\n+      MakeTransformedIterator(std::move(original), MakeAbortOnSecond<TestInt>());\n+  ASSERT_OK(transformed.Next());\n+  ASSERT_RAISES(Invalid, transformed.Next());\n+}\n+\n+TEST(TestAsyncIteratorTransform, SkipSome) {\n+  auto original = AsyncVectorIt({1, 2, 3});\n+  auto filter = MakeFilter<TestInt>([](TestInt& t) { return t.value != 2; });\n+  auto filtered = TransformAsyncGenerator(std::move(original), filter);\n+  AssertAsyncGeneratorMatch({1, 3}, std::move(filtered));\n+}\n+\n+TEST(TestAsyncUtil, ReadaheadFailed) {\n+  auto source = []() -> Future<TestInt> {\n+    return Future<TestInt>::MakeFinished(Status::Invalid(\"X\"));\n+  };\n+  auto readahead = AddReadahead<TestInt>(source, 10);\n+  auto next = readahead();\n+  ASSERT_EQ(Status::Invalid(\"X\"), next.status());\n\nReview comment:\n       Should the next ones also fail? With the same error / different one?\n\n##########\nFile path: cpp/src/arrow/util/iterator_test.cc\n##########\n@@ -214,6 +255,270 @@ TEST(TestVectorIterator, RangeForLoop) {\n   ASSERT_EQ(ints_it, ints.end());\n }\n \n+template <typename T>\n+Transformer<T, T> MakeFirstN(int n) {\n+  int remaining = n;\n+  return [remaining](T next) mutable -> Result<TransformFlow<T>> {\n+    if (remaining > 0) {\n+      remaining--;\n+      return TransformYield(next);\n+    }\n+    return TransformFinish();\n+  };\n+}\n+\n+TEST(TestIteratorTransform, Truncating) {\n+  auto original = VectorIt({1, 2, 3});\n+  auto truncated = MakeTransformedIterator(std::move(original), MakeFirstN<TestInt>(2));\n+  AssertIteratorMatch({1, 2}, std::move(truncated));\n+}\n+\n+TEST(TestIteratorTransform, TestPointer) {\n+  auto original = VectorIt<std::shared_ptr<int>>(\n+      {std::make_shared<int>(1), std::make_shared<int>(2), std::make_shared<int>(3)});\n+  auto truncated =\n+      MakeTransformedIterator(std::move(original), MakeFirstN<std::shared_ptr<int>>(2));\n+  ASSERT_OK_AND_ASSIGN(auto result, truncated.ToVector());\n+  ASSERT_EQ(2, result.size());\n+}\n+\n+TEST(TestIteratorTransform, TruncatingShort) {\n+  // Tests the failsafe case where we never call Finish\n+  auto original = VectorIt({1});\n+  auto truncated = MakeTransformedIterator<TestInt, TestInt>(std::move(original),\n+                                                             MakeFirstN<TestInt>(2));\n+  AssertIteratorMatch({1}, std::move(truncated));\n+}\n+\n+TEST(TestAsyncUtil, Background) {\n+  std::vector<TestInt> expected = {1, 2, 3};\n+  auto background = BackgroundAsyncVectorIt(expected);\n+  auto future = CollectAsyncGenerator(background);\n+  ASSERT_FALSE(future.is_finished());\n+  future.Wait();\n+  ASSERT_TRUE(future.is_finished());\n+  ASSERT_EQ(expected, *future.result());\n+}\n+\n+struct SlowEmptyIterator {\n+  Result<TestInt> Next() {\n+    if (called_) {\n+      return Status::Invalid(\"Should not have been called twice\");\n+    }\n+    SleepFor(0.1);\n+    return IterationTraits<TestInt>::End();\n+  }\n+\n+ private:\n+  bool called_ = false;\n+};\n+\n+TEST(TestAsyncUtil, BackgroundRepeatEnd) {\n+  // Ensure that the background iterator properly fulfills the asyncgenerator contract\n+  // and can be called after it ends.\n+  auto iterator = Iterator<TestInt>(SlowEmptyIterator());\n+  ASSERT_OK_AND_ASSIGN(\n+      auto background_iter,\n+      MakeBackgroundIterator(std::move(iterator), internal::GetCpuThreadPool()));\n+\n+  auto one = background_iter();\n+  auto two = background_iter();\n+\n+  ASSERT_TRUE(one.Wait(0.5));\n+\n+  if (one.is_finished()) {\n+    ASSERT_EQ(IterationTraits<TestInt>::End(), *one.result());\n+  }\n+\n+  ASSERT_TRUE(two.Wait(0.5));\n+  ASSERT_TRUE(two.is_finished());\n+  if (two.is_finished()) {\n+    ASSERT_EQ(IterationTraits<TestInt>::End(), *two.result());\n+  }\n+}\n+\n+TEST(TestAsyncUtil, SynchronousFinish) {\n+  AsyncGenerator<TestInt> generator = []() {\n+    return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\n+  };\n+  Transformer<TestInt, TestInt> skip_all = [](TestInt value) { return TransformSkip(); };\n+  auto transformed = TransformAsyncGenerator(generator, skip_all);\n+  auto future = CollectAsyncGenerator(transformed);\n+  ASSERT_TRUE(future.is_finished());\n+  ASSERT_OK_AND_ASSIGN(auto actual, future.result());\n+  ASSERT_EQ(std::vector<TestInt>(), actual);\n+}\n+\n+TEST(TestAsyncUtil, CompleteBackgroundStressTest) {\n+  auto expected = RangeVector(100);\n+  std::vector<Future<std::vector<TestInt>>> futures;\n+  for (unsigned int i = 0; i < 100; i++) {\n+    auto background = BackgroundAsyncVectorIt(expected);\n+    futures.push_back(CollectAsyncGenerator(background));\n+  }\n+  auto combined = All(futures);\n+  combined.Wait(2);\n+  if (combined.is_finished()) {\n+    ASSERT_OK_AND_ASSIGN(auto completed_vectors, combined.result());\n+    for (auto&& vector : completed_vectors) {\n+      ASSERT_EQ(vector, expected);\n+    }\n+  } else {\n+    FAIL() << \"After 2 seconds all background iterators had not finished collecting\";\n+  }\n+}\n+\n+TEST(TestAsyncUtil, StackOverflow) {\n+  int counter = 0;\n+  AsyncGenerator<TestInt> generator = [&counter]() {\n+    if (counter < 1000000) {\n+      return Future<TestInt>::MakeFinished(counter++);\n+    } else {\n+      return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\n+    }\n+  };\n+  Transformer<TestInt, TestInt> discard =\n+      [](TestInt next) -> Result<TransformFlow<TestInt>> { return TransformSkip(); };\n+  auto transformed = TransformAsyncGenerator(generator, discard);\n+  auto collected_future = CollectAsyncGenerator(transformed);\n+  ASSERT_TRUE(collected_future.Wait(5));\n+  if (collected_future.is_finished()) {\n+    ASSERT_OK_AND_ASSIGN(auto collected, collected_future.result());\n+    ASSERT_EQ(0, collected.size());\n+  }\n+}\n+\n+TEST(TestAsyncUtil, Visit) {\n+  auto generator = AsyncVectorIt({1, 2, 3});\n+  unsigned int sum = 0;\n+  auto sum_future = VisitAsyncGenerator<TestInt>(generator, [&sum](TestInt item) {\n+    sum += item.value;\n+    return Status::OK();\n+  });\n+  // Should be superfluous\n+  sum_future.Wait();\n+  ASSERT_EQ(6, sum);\n+}\n+\n+TEST(TestAsyncUtil, Collect) {\n+  std::vector<TestInt> expected = {1, 2, 3};\n+  auto generator = AsyncVectorIt(expected);\n+  auto collected = CollectAsyncGenerator(generator);\n+  ASSERT_EQ(expected, *collected.result());\n+}\n+\n+template <typename T>\n+Transformer<T, T> MakeRepeatN(int repeat_count) {\n+  int current_repeat = 0;\n+  return [repeat_count, current_repeat](T next) mutable -> Result<TransformFlow<T>> {\n+    current_repeat++;\n+    bool ready_for_next = false;\n+    if (current_repeat == repeat_count) {\n+      current_repeat = 0;\n+      ready_for_next = true;\n+    }\n+    return TransformYield(next, ready_for_next);\n+  };\n+}\n+\n+TEST(TestIteratorTransform, Repeating) {\n+  auto original = VectorIt({1, 2, 3});\n+  auto repeated = MakeTransformedIterator<TestInt, TestInt>(std::move(original),\n+                                                            MakeRepeatN<TestInt>(2));\n+  AssertIteratorMatch({1, 1, 2, 2, 3, 3}, std::move(repeated));\n+}\n+\n+template <typename T>\n+Transformer<T, T> MakeFilter(std::function<bool(T&)> filter) {\n+  return [filter](T next) -> Result<TransformFlow<T>> {\n+    if (filter(next)) {\n+      return TransformYield(next);\n+    } else {\n+      return TransformSkip();\n+    }\n+  };\n+}\n+\n+template <typename T>\n+Transformer<T, T> MakeAbortOnSecond() {\n+  int counter = 0;\n+  return [counter](T next) mutable -> Result<TransformFlow<T>> {\n+    if (counter++ == 1) {\n+      return Status::Invalid(\"X\");\n+    }\n+    return TransformYield(next);\n+  };\n+}\n+\n+TEST(TestIteratorTransform, SkipSome) {\n+  // Exercises TransformSkip\n+  auto original = VectorIt({1, 2, 3});\n+  auto filter = MakeFilter<TestInt>([](TestInt& t) { return t.value != 2; });\n+  auto filtered = MakeTransformedIterator(std::move(original), filter);\n+  AssertIteratorMatch({1, 3}, std::move(filtered));\n+}\n+\n+TEST(TestIteratorTransform, SkipAll) {\n+  // Exercises TransformSkip\n+  auto original = VectorIt({1, 2, 3});\n+  auto filter = MakeFilter<TestInt>([](TestInt& t) { return false; });\n+  auto filtered = MakeTransformedIterator(std::move(original), filter);\n+  AssertIteratorMatch({}, std::move(filtered));\n+}\n+\n+TEST(TestIteratorTransform, Abort) {\n+  auto original = VectorIt({1, 2, 3});\n+  auto transformed =\n+      MakeTransformedIterator(std::move(original), MakeAbortOnSecond<TestInt>());\n+  ASSERT_OK(transformed.Next());\n+  ASSERT_RAISES(Invalid, transformed.Next());\n+}\n\nReview comment:\n       Should the third one still succeed?\n\n##########\nFile path: cpp/src/arrow/util/thread_pool.h\n##########\n@@ -87,6 +87,21 @@ class ARROW_EXPORT Executor {\n     return SpawnReal(hints, std::forward<Function>(func));\n   }\n \n+  template <typename T>\n+  Future<T> Transfer(Future<T> future) {\n\nReview comment:\n       Hmm... so the only thing that will be spawed on the executor (presumably a thread pool) is a `MarkFinished` called?\r\n   I suppose the intent is so that `Then()` calls are also made on the executor?\r\n   \r\n   In any case, please add a comment or docstring describing this and the intent.\n\n##########\nFile path: cpp/src/arrow/util/iterator_test.cc\n##########\n@@ -214,6 +255,270 @@ TEST(TestVectorIterator, RangeForLoop) {\n   ASSERT_EQ(ints_it, ints.end());\n }\n \n+template <typename T>\n+Transformer<T, T> MakeFirstN(int n) {\n+  int remaining = n;\n+  return [remaining](T next) mutable -> Result<TransformFlow<T>> {\n+    if (remaining > 0) {\n+      remaining--;\n+      return TransformYield(next);\n+    }\n+    return TransformFinish();\n+  };\n+}\n+\n+TEST(TestIteratorTransform, Truncating) {\n+  auto original = VectorIt({1, 2, 3});\n+  auto truncated = MakeTransformedIterator(std::move(original), MakeFirstN<TestInt>(2));\n+  AssertIteratorMatch({1, 2}, std::move(truncated));\n+}\n+\n+TEST(TestIteratorTransform, TestPointer) {\n+  auto original = VectorIt<std::shared_ptr<int>>(\n+      {std::make_shared<int>(1), std::make_shared<int>(2), std::make_shared<int>(3)});\n+  auto truncated =\n+      MakeTransformedIterator(std::move(original), MakeFirstN<std::shared_ptr<int>>(2));\n+  ASSERT_OK_AND_ASSIGN(auto result, truncated.ToVector());\n+  ASSERT_EQ(2, result.size());\n+}\n+\n+TEST(TestIteratorTransform, TruncatingShort) {\n+  // Tests the failsafe case where we never call Finish\n+  auto original = VectorIt({1});\n+  auto truncated = MakeTransformedIterator<TestInt, TestInt>(std::move(original),\n+                                                             MakeFirstN<TestInt>(2));\n+  AssertIteratorMatch({1}, std::move(truncated));\n+}\n+\n+TEST(TestAsyncUtil, Background) {\n+  std::vector<TestInt> expected = {1, 2, 3};\n+  auto background = BackgroundAsyncVectorIt(expected);\n+  auto future = CollectAsyncGenerator(background);\n+  ASSERT_FALSE(future.is_finished());\n+  future.Wait();\n+  ASSERT_TRUE(future.is_finished());\n+  ASSERT_EQ(expected, *future.result());\n+}\n+\n+struct SlowEmptyIterator {\n+  Result<TestInt> Next() {\n+    if (called_) {\n+      return Status::Invalid(\"Should not have been called twice\");\n+    }\n+    SleepFor(0.1);\n+    return IterationTraits<TestInt>::End();\n+  }\n+\n+ private:\n+  bool called_ = false;\n+};\n+\n+TEST(TestAsyncUtil, BackgroundRepeatEnd) {\n+  // Ensure that the background iterator properly fulfills the asyncgenerator contract\n+  // and can be called after it ends.\n+  auto iterator = Iterator<TestInt>(SlowEmptyIterator());\n+  ASSERT_OK_AND_ASSIGN(\n+      auto background_iter,\n+      MakeBackgroundIterator(std::move(iterator), internal::GetCpuThreadPool()));\n+\n+  auto one = background_iter();\n+  auto two = background_iter();\n+\n+  ASSERT_TRUE(one.Wait(0.5));\n+\n+  if (one.is_finished()) {\n+    ASSERT_EQ(IterationTraits<TestInt>::End(), *one.result());\n+  }\n+\n+  ASSERT_TRUE(two.Wait(0.5));\n+  ASSERT_TRUE(two.is_finished());\n+  if (two.is_finished()) {\n+    ASSERT_EQ(IterationTraits<TestInt>::End(), *two.result());\n+  }\n+}\n+\n+TEST(TestAsyncUtil, SynchronousFinish) {\n+  AsyncGenerator<TestInt> generator = []() {\n+    return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\n+  };\n+  Transformer<TestInt, TestInt> skip_all = [](TestInt value) { return TransformSkip(); };\n+  auto transformed = TransformAsyncGenerator(generator, skip_all);\n+  auto future = CollectAsyncGenerator(transformed);\n+  ASSERT_TRUE(future.is_finished());\n+  ASSERT_OK_AND_ASSIGN(auto actual, future.result());\n+  ASSERT_EQ(std::vector<TestInt>(), actual);\n+}\n+\n+TEST(TestAsyncUtil, CompleteBackgroundStressTest) {\n+  auto expected = RangeVector(100);\n+  std::vector<Future<std::vector<TestInt>>> futures;\n+  for (unsigned int i = 0; i < 100; i++) {\n+    auto background = BackgroundAsyncVectorIt(expected);\n+    futures.push_back(CollectAsyncGenerator(background));\n+  }\n+  auto combined = All(futures);\n+  combined.Wait(2);\n+  if (combined.is_finished()) {\n+    ASSERT_OK_AND_ASSIGN(auto completed_vectors, combined.result());\n+    for (auto&& vector : completed_vectors) {\n+      ASSERT_EQ(vector, expected);\n+    }\n+  } else {\n+    FAIL() << \"After 2 seconds all background iterators had not finished collecting\";\n+  }\n+}\n+\n+TEST(TestAsyncUtil, StackOverflow) {\n+  int counter = 0;\n+  AsyncGenerator<TestInt> generator = [&counter]() {\n+    if (counter < 1000000) {\n+      return Future<TestInt>::MakeFinished(counter++);\n+    } else {\n+      return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\n+    }\n+  };\n+  Transformer<TestInt, TestInt> discard =\n+      [](TestInt next) -> Result<TransformFlow<TestInt>> { return TransformSkip(); };\n+  auto transformed = TransformAsyncGenerator(generator, discard);\n+  auto collected_future = CollectAsyncGenerator(transformed);\n+  ASSERT_TRUE(collected_future.Wait(5));\n+  if (collected_future.is_finished()) {\n+    ASSERT_OK_AND_ASSIGN(auto collected, collected_future.result());\n+    ASSERT_EQ(0, collected.size());\n+  }\n+}\n+\n+TEST(TestAsyncUtil, Visit) {\n+  auto generator = AsyncVectorIt({1, 2, 3});\n+  unsigned int sum = 0;\n+  auto sum_future = VisitAsyncGenerator<TestInt>(generator, [&sum](TestInt item) {\n+    sum += item.value;\n+    return Status::OK();\n+  });\n+  // Should be superfluous\n\nReview comment:\n       Then replace it with `ASSERT_TRUE(sum_future.finished())`?\n\n##########\nFile path: cpp/src/arrow/util/thread_pool.h\n##########\n@@ -87,6 +87,21 @@ class ARROW_EXPORT Executor {\n     return SpawnReal(hints, std::forward<Function>(func));\n   }\n \n+  template <typename T>\n+  Future<T> Transfer(Future<T> future) {\n+    auto transferred = Future<T>::Make();\n+    future.AddCallback([this, transferred](const Result<T>& result) mutable {\n+      Result<T> result_copy(result);\n+      auto spawn_status = Spawn([transferred, result_copy]() mutable {\n+        transferred.MarkFinished(result_copy);\n\nReview comment:\n       and this is a third one?\n\n##########\nFile path: cpp/src/arrow/util/task_group.cc\n##########\n@@ -135,6 +149,18 @@ class ThreadedTaskGroup : public TaskGroup {\n       // before cv.notify_one() has returned\n       std::unique_lock<std::mutex> lock(mutex_);\n       cv_.notify_one();\n+      if (completion_future_.has_value()) {\n+        // MarkFinished could be slow.  We don't want to call it while we are holding\n+        // the lock.\n+        // TODO: If optional is thread safe then we can skip this locking entirely\n+        auto future = *completion_future_;\n+        auto finished = completion_future_->is_finished();\n+        auto status = status_;\n\nReview comment:\n       `const auto&`?\n\n##########\nFile path: cpp/src/arrow/util/thread_pool.h\n##########\n@@ -87,6 +87,21 @@ class ARROW_EXPORT Executor {\n     return SpawnReal(hints, std::forward<Function>(func));\n   }\n \n+  template <typename T>\n+  Future<T> Transfer(Future<T> future) {\n+    auto transferred = Future<T>::Make();\n+    future.AddCallback([this, transferred](const Result<T>& result) mutable {\n+      Result<T> result_copy(result);\n+      auto spawn_status = Spawn([transferred, result_copy]() mutable {\n\nReview comment:\n       This is a second copy.\n\n##########\nFile path: cpp/src/arrow/util/task_group.cc\n##########\n@@ -135,6 +149,18 @@ class ThreadedTaskGroup : public TaskGroup {\n       // before cv.notify_one() has returned\n       std::unique_lock<std::mutex> lock(mutex_);\n       cv_.notify_one();\n+      if (completion_future_.has_value()) {\n+        // MarkFinished could be slow.  We don't want to call it while we are holding\n+        // the lock.\n+        // TODO: If optional is thread safe then we can skip this locking entirely\n\nReview comment:\n       Well, the locking is necessary anyway, so I'm not sure the TODO is very useful.\n\n##########\nFile path: cpp/src/arrow/util/iterator_test.cc\n##########\n@@ -16,6 +16,7 @@\n // under the License.\n \n #include \"arrow/util/iterator.h\"\n+#include \"arrow/util/async_iterator.h\"\n\nReview comment:\n       Nit: keep includes sorted in lexicographic order.\n\n##########\nFile path: cpp/src/arrow/util/async_iterator.h\n##########\n@@ -0,0 +1,295 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+#include <queue>\n+\n+#include \"arrow/util/functional.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+template <typename T>\n+using AsyncGenerator = std::function<Future<T>()>;\n+\n+/// Iterates through a generator of futures, visiting the result of each one and\n+/// returning a future that completes when all have been visited\n+template <typename T>\n+Future<> VisitAsyncGenerator(AsyncGenerator<T> generator,\n+                             std::function<Status(T)> visitor) {\n+  auto loop_body = [generator, visitor] {\n+    auto next = generator();\n+    return next.Then([visitor](const T& result) -> Result<ControlFlow<detail::Empty>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(detail::Empty());\n+      } else {\n+        auto visited = visitor(result);\n+        if (visited.ok()) {\n+          return Continue();\n+        } else {\n+          return visited;\n+        }\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T>\n+Future<std::vector<T>> CollectAsyncGenerator(AsyncGenerator<T> generator) {\n+  auto vec = std::make_shared<std::vector<T>>();\n+  auto loop_body = [generator, vec] {\n+    auto next = generator();\n+    return next.Then([vec](const T& result) -> Result<ControlFlow<std::vector<T>>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(*vec);\n+      } else {\n+        vec->push_back(result);\n+        return Continue();\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T, typename V>\n+class TransformingGenerator {\n+ public:\n+  explicit TransformingGenerator(AsyncGenerator<T> generator,\n+                                 Transformer<T, V> transformer)\n+      : finished_(), last_value_(), generator_(generator), transformer_(transformer) {}\n+\n+  // See comment on TransformingIterator::Pump\n+  Result<util::optional<V>> Pump() {\n+    if (!finished_ && last_value_.has_value()) {\n+      ARROW_ASSIGN_OR_RAISE(TransformFlow<V> next, transformer_(*last_value_));\n+      if (next.ReadyForNext()) {\n+        if (*last_value_ == IterationTraits<T>::End()) {\n+          finished_ = true;\n+        }\n+        last_value_.reset();\n+      }\n+      if (next.Finished()) {\n+        finished_ = true;\n+      }\n+      if (next.HasValue()) {\n+        return next.Value();\n+      }\n+    }\n+    if (finished_) {\n+      return IterationTraits<V>::End();\n+    }\n+    return util::nullopt;\n+  }\n+\n+  Future<V> operator()() {\n+    while (true) {\n+      auto maybe_next_result = Pump();\n+      if (!maybe_next_result.ok()) {\n+        return Future<V>::MakeFinished(maybe_next_result.status());\n+      }\n+      auto maybe_next = maybe_next_result.ValueUnsafe();\n+      if (maybe_next.has_value()) {\n+        return Future<V>::MakeFinished(*maybe_next);\n+      }\n+\n+      auto next_fut = generator_();\n+      // If finished already, process results immediately inside the loop to avoid stack\n+      // overflow\n+      if (next_fut.is_finished()) {\n+        auto next_result = next_fut.result();\n+        if (next_result.ok()) {\n+          last_value_ = *next_result;\n+        } else {\n+          return Future<V>::MakeFinished(next_result.status());\n+        }\n+        // Otherwise, if not finished immediately, add callback to process results\n+      } else {\n+        return next_fut.Then([this](const Result<T>& next_result) {\n+          if (next_result.ok()) {\n+            last_value_ = *next_result;\n+            return (*this)();\n+          } else {\n+            return Future<V>::MakeFinished(next_result.status());\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+ protected:\n+  bool finished_;\n+  util::optional<T> last_value_;\n+  AsyncGenerator<T> generator_;\n+  Transformer<T, V> transformer_;\n+};\n+\n+template <typename T>\n+static std::function<void(const Result<T>&)> MakeCallback(\n\nReview comment:\n       This seems unused?\n\n##########\nFile path: cpp/src/arrow/util/async_iterator.h\n##########\n@@ -0,0 +1,295 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+#include <queue>\n+\n+#include \"arrow/util/functional.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+template <typename T>\n+using AsyncGenerator = std::function<Future<T>()>;\n+\n+/// Iterates through a generator of futures, visiting the result of each one and\n+/// returning a future that completes when all have been visited\n+template <typename T>\n+Future<> VisitAsyncGenerator(AsyncGenerator<T> generator,\n+                             std::function<Status(T)> visitor) {\n+  auto loop_body = [generator, visitor] {\n+    auto next = generator();\n+    return next.Then([visitor](const T& result) -> Result<ControlFlow<detail::Empty>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(detail::Empty());\n+      } else {\n+        auto visited = visitor(result);\n+        if (visited.ok()) {\n+          return Continue();\n+        } else {\n+          return visited;\n+        }\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T>\n+Future<std::vector<T>> CollectAsyncGenerator(AsyncGenerator<T> generator) {\n+  auto vec = std::make_shared<std::vector<T>>();\n+  auto loop_body = [generator, vec] {\n+    auto next = generator();\n+    return next.Then([vec](const T& result) -> Result<ControlFlow<std::vector<T>>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(*vec);\n+      } else {\n+        vec->push_back(result);\n+        return Continue();\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T, typename V>\n+class TransformingGenerator {\n+ public:\n+  explicit TransformingGenerator(AsyncGenerator<T> generator,\n+                                 Transformer<T, V> transformer)\n+      : finished_(), last_value_(), generator_(generator), transformer_(transformer) {}\n+\n+  // See comment on TransformingIterator::Pump\n+  Result<util::optional<V>> Pump() {\n+    if (!finished_ && last_value_.has_value()) {\n+      ARROW_ASSIGN_OR_RAISE(TransformFlow<V> next, transformer_(*last_value_));\n+      if (next.ReadyForNext()) {\n+        if (*last_value_ == IterationTraits<T>::End()) {\n+          finished_ = true;\n+        }\n+        last_value_.reset();\n+      }\n+      if (next.Finished()) {\n+        finished_ = true;\n+      }\n+      if (next.HasValue()) {\n+        return next.Value();\n+      }\n+    }\n+    if (finished_) {\n+      return IterationTraits<V>::End();\n+    }\n+    return util::nullopt;\n+  }\n+\n+  Future<V> operator()() {\n+    while (true) {\n+      auto maybe_next_result = Pump();\n+      if (!maybe_next_result.ok()) {\n+        return Future<V>::MakeFinished(maybe_next_result.status());\n+      }\n+      auto maybe_next = maybe_next_result.ValueUnsafe();\n+      if (maybe_next.has_value()) {\n+        return Future<V>::MakeFinished(*maybe_next);\n+      }\n+\n+      auto next_fut = generator_();\n+      // If finished already, process results immediately inside the loop to avoid stack\n+      // overflow\n+      if (next_fut.is_finished()) {\n+        auto next_result = next_fut.result();\n+        if (next_result.ok()) {\n+          last_value_ = *next_result;\n\nReview comment:\n       `*std::move(next_result)`\n\n##########\nFile path: cpp/src/arrow/util/async_iterator.h\n##########\n@@ -0,0 +1,295 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+#include <queue>\n+\n+#include \"arrow/util/functional.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+template <typename T>\n+using AsyncGenerator = std::function<Future<T>()>;\n+\n+/// Iterates through a generator of futures, visiting the result of each one and\n+/// returning a future that completes when all have been visited\n+template <typename T>\n+Future<> VisitAsyncGenerator(AsyncGenerator<T> generator,\n+                             std::function<Status(T)> visitor) {\n+  auto loop_body = [generator, visitor] {\n+    auto next = generator();\n+    return next.Then([visitor](const T& result) -> Result<ControlFlow<detail::Empty>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(detail::Empty());\n+      } else {\n+        auto visited = visitor(result);\n+        if (visited.ok()) {\n+          return Continue();\n+        } else {\n+          return visited;\n+        }\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T>\n+Future<std::vector<T>> CollectAsyncGenerator(AsyncGenerator<T> generator) {\n+  auto vec = std::make_shared<std::vector<T>>();\n+  auto loop_body = [generator, vec] {\n+    auto next = generator();\n+    return next.Then([vec](const T& result) -> Result<ControlFlow<std::vector<T>>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(*vec);\n+      } else {\n+        vec->push_back(result);\n+        return Continue();\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T, typename V>\n+class TransformingGenerator {\n+ public:\n+  explicit TransformingGenerator(AsyncGenerator<T> generator,\n+                                 Transformer<T, V> transformer)\n+      : finished_(), last_value_(), generator_(generator), transformer_(transformer) {}\n\nReview comment:\n       `std::move(generator)` and `std::move(transformer)`\n\n##########\nFile path: cpp/src/arrow/util/async_iterator.h\n##########\n@@ -0,0 +1,295 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+#include <queue>\n+\n+#include \"arrow/util/functional.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+template <typename T>\n+using AsyncGenerator = std::function<Future<T>()>;\n+\n+/// Iterates through a generator of futures, visiting the result of each one and\n+/// returning a future that completes when all have been visited\n+template <typename T>\n+Future<> VisitAsyncGenerator(AsyncGenerator<T> generator,\n+                             std::function<Status(T)> visitor) {\n+  auto loop_body = [generator, visitor] {\n+    auto next = generator();\n+    return next.Then([visitor](const T& result) -> Result<ControlFlow<detail::Empty>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(detail::Empty());\n+      } else {\n+        auto visited = visitor(result);\n+        if (visited.ok()) {\n+          return Continue();\n+        } else {\n+          return visited;\n+        }\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T>\n+Future<std::vector<T>> CollectAsyncGenerator(AsyncGenerator<T> generator) {\n+  auto vec = std::make_shared<std::vector<T>>();\n+  auto loop_body = [generator, vec] {\n+    auto next = generator();\n+    return next.Then([vec](const T& result) -> Result<ControlFlow<std::vector<T>>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(*vec);\n+      } else {\n+        vec->push_back(result);\n+        return Continue();\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T, typename V>\n+class TransformingGenerator {\n+ public:\n+  explicit TransformingGenerator(AsyncGenerator<T> generator,\n+                                 Transformer<T, V> transformer)\n+      : finished_(), last_value_(), generator_(generator), transformer_(transformer) {}\n+\n+  // See comment on TransformingIterator::Pump\n+  Result<util::optional<V>> Pump() {\n+    if (!finished_ && last_value_.has_value()) {\n+      ARROW_ASSIGN_OR_RAISE(TransformFlow<V> next, transformer_(*last_value_));\n+      if (next.ReadyForNext()) {\n+        if (*last_value_ == IterationTraits<T>::End()) {\n+          finished_ = true;\n+        }\n+        last_value_.reset();\n+      }\n+      if (next.Finished()) {\n+        finished_ = true;\n+      }\n+      if (next.HasValue()) {\n+        return next.Value();\n+      }\n+    }\n+    if (finished_) {\n+      return IterationTraits<V>::End();\n+    }\n+    return util::nullopt;\n+  }\n+\n+  Future<V> operator()() {\n+    while (true) {\n+      auto maybe_next_result = Pump();\n+      if (!maybe_next_result.ok()) {\n+        return Future<V>::MakeFinished(maybe_next_result.status());\n+      }\n+      auto maybe_next = maybe_next_result.ValueUnsafe();\n\nReview comment:\n       `std::move(maybe_next_result).ValueUnsafe()`?\n\n##########\nFile path: cpp/src/arrow/util/thread_pool.h\n##########\n@@ -87,6 +87,21 @@ class ARROW_EXPORT Executor {\n     return SpawnReal(hints, std::forward<Function>(func));\n   }\n \n+  template <typename T>\n+  Future<T> Transfer(Future<T> future) {\n+    auto transferred = Future<T>::Make();\n+    future.AddCallback([this, transferred](const Result<T>& result) mutable {\n+      Result<T> result_copy(result);\n\nReview comment:\n       This is a first copy.\n\n##########\nFile path: cpp/src/arrow/util/async_iterator.h\n##########\n@@ -0,0 +1,295 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+#include <queue>\n+\n+#include \"arrow/util/functional.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+template <typename T>\n+using AsyncGenerator = std::function<Future<T>()>;\n+\n+/// Iterates through a generator of futures, visiting the result of each one and\n+/// returning a future that completes when all have been visited\n+template <typename T>\n+Future<> VisitAsyncGenerator(AsyncGenerator<T> generator,\n+                             std::function<Status(T)> visitor) {\n+  auto loop_body = [generator, visitor] {\n+    auto next = generator();\n+    return next.Then([visitor](const T& result) -> Result<ControlFlow<detail::Empty>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(detail::Empty());\n+      } else {\n+        auto visited = visitor(result);\n+        if (visited.ok()) {\n+          return Continue();\n+        } else {\n+          return visited;\n+        }\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T>\n+Future<std::vector<T>> CollectAsyncGenerator(AsyncGenerator<T> generator) {\n+  auto vec = std::make_shared<std::vector<T>>();\n+  auto loop_body = [generator, vec] {\n+    auto next = generator();\n+    return next.Then([vec](const T& result) -> Result<ControlFlow<std::vector<T>>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(*vec);\n+      } else {\n+        vec->push_back(result);\n+        return Continue();\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T, typename V>\n+class TransformingGenerator {\n+ public:\n+  explicit TransformingGenerator(AsyncGenerator<T> generator,\n+                                 Transformer<T, V> transformer)\n+      : finished_(), last_value_(), generator_(generator), transformer_(transformer) {}\n+\n+  // See comment on TransformingIterator::Pump\n+  Result<util::optional<V>> Pump() {\n+    if (!finished_ && last_value_.has_value()) {\n+      ARROW_ASSIGN_OR_RAISE(TransformFlow<V> next, transformer_(*last_value_));\n+      if (next.ReadyForNext()) {\n+        if (*last_value_ == IterationTraits<T>::End()) {\n+          finished_ = true;\n+        }\n+        last_value_.reset();\n+      }\n+      if (next.Finished()) {\n+        finished_ = true;\n+      }\n+      if (next.HasValue()) {\n+        return next.Value();\n+      }\n+    }\n+    if (finished_) {\n+      return IterationTraits<V>::End();\n+    }\n+    return util::nullopt;\n+  }\n+\n+  Future<V> operator()() {\n+    while (true) {\n+      auto maybe_next_result = Pump();\n+      if (!maybe_next_result.ok()) {\n+        return Future<V>::MakeFinished(maybe_next_result.status());\n+      }\n+      auto maybe_next = maybe_next_result.ValueUnsafe();\n+      if (maybe_next.has_value()) {\n+        return Future<V>::MakeFinished(*maybe_next);\n+      }\n+\n+      auto next_fut = generator_();\n+      // If finished already, process results immediately inside the loop to avoid stack\n+      // overflow\n+      if (next_fut.is_finished()) {\n+        auto next_result = next_fut.result();\n+        if (next_result.ok()) {\n+          last_value_ = *next_result;\n+        } else {\n+          return Future<V>::MakeFinished(next_result.status());\n+        }\n+        // Otherwise, if not finished immediately, add callback to process results\n+      } else {\n+        return next_fut.Then([this](const Result<T>& next_result) {\n+          if (next_result.ok()) {\n+            last_value_ = *next_result;\n+            return (*this)();\n+          } else {\n+            return Future<V>::MakeFinished(next_result.status());\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+ protected:\n+  bool finished_;\n+  util::optional<T> last_value_;\n+  AsyncGenerator<T> generator_;\n+  Transformer<T, V> transformer_;\n+};\n+\n+template <typename T>\n+static std::function<void(const Result<T>&)> MakeCallback(\n+    std::shared_ptr<bool> finished) {\n+  return [finished](const Result<T>& next_result) {\n+    if (!next_result.ok()) {\n+      *finished = true;\n+    } else {\n+      auto next = *next_result;\n+      *finished = (next == IterationTraits<T>::End());\n+    }\n+  };\n+}\n+\n+template <typename T>\n+AsyncGenerator<T> AddReadahead(AsyncGenerator<T> source_generator, int max_readahead) {\n+  // Using a shared_ptr instead of a lambda capture here because it's possible that\n+  // the inner mark_finished_if_done outlives the outer lambda\n+  auto finished = std::make_shared<bool>(false);\n+  auto mark_finished_if_done = [finished](const Result<T>& next_result) {\n+    if (!next_result.ok()) {\n+      *finished = true;\n+    } else {\n+      auto next = *next_result;\n+      *finished = (next == IterationTraits<T>::End());\n+    }\n+  };\n+\n+  std::queue<Future<T>> readahead_queue;\n+  return [=]() mutable -> Future<T> {\n+    if (readahead_queue.empty()) {\n+      // This is the first request, let's pump the underlying queue\n\nReview comment:\n       Why not pump as soon as `AddReadahead` is called? It would be more consistent with `ReadaheadIterator`.\n\n##########\nFile path: cpp/src/arrow/util/async_iterator.h\n##########\n@@ -0,0 +1,295 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+#include <queue>\n+\n+#include \"arrow/util/functional.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+template <typename T>\n+using AsyncGenerator = std::function<Future<T>()>;\n+\n+/// Iterates through a generator of futures, visiting the result of each one and\n+/// returning a future that completes when all have been visited\n+template <typename T>\n+Future<> VisitAsyncGenerator(AsyncGenerator<T> generator,\n+                             std::function<Status(T)> visitor) {\n+  auto loop_body = [generator, visitor] {\n+    auto next = generator();\n+    return next.Then([visitor](const T& result) -> Result<ControlFlow<detail::Empty>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(detail::Empty());\n+      } else {\n+        auto visited = visitor(result);\n+        if (visited.ok()) {\n+          return Continue();\n+        } else {\n+          return visited;\n+        }\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T>\n+Future<std::vector<T>> CollectAsyncGenerator(AsyncGenerator<T> generator) {\n+  auto vec = std::make_shared<std::vector<T>>();\n+  auto loop_body = [generator, vec] {\n\nReview comment:\n       Will make a copy of `generator`.\n\n##########\nFile path: cpp/src/arrow/util/async_iterator.h\n##########\n@@ -0,0 +1,295 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+#include <queue>\n+\n+#include \"arrow/util/functional.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+template <typename T>\n+using AsyncGenerator = std::function<Future<T>()>;\n+\n+/// Iterates through a generator of futures, visiting the result of each one and\n+/// returning a future that completes when all have been visited\n+template <typename T>\n+Future<> VisitAsyncGenerator(AsyncGenerator<T> generator,\n+                             std::function<Status(T)> visitor) {\n+  auto loop_body = [generator, visitor] {\n+    auto next = generator();\n+    return next.Then([visitor](const T& result) -> Result<ControlFlow<detail::Empty>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(detail::Empty());\n+      } else {\n+        auto visited = visitor(result);\n+        if (visited.ok()) {\n+          return Continue();\n+        } else {\n+          return visited;\n+        }\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T>\n+Future<std::vector<T>> CollectAsyncGenerator(AsyncGenerator<T> generator) {\n+  auto vec = std::make_shared<std::vector<T>>();\n\nReview comment:\n       Instead of this, use an anonymous callable object?\n\n##########\nFile path: cpp/src/arrow/util/async_iterator.h\n##########\n@@ -0,0 +1,295 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+#include <queue>\n+\n+#include \"arrow/util/functional.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+template <typename T>\n+using AsyncGenerator = std::function<Future<T>()>;\n+\n+/// Iterates through a generator of futures, visiting the result of each one and\n+/// returning a future that completes when all have been visited\n+template <typename T>\n+Future<> VisitAsyncGenerator(AsyncGenerator<T> generator,\n+                             std::function<Status(T)> visitor) {\n+  auto loop_body = [generator, visitor] {\n+    auto next = generator();\n+    return next.Then([visitor](const T& result) -> Result<ControlFlow<detail::Empty>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(detail::Empty());\n+      } else {\n+        auto visited = visitor(result);\n+        if (visited.ok()) {\n+          return Continue();\n+        } else {\n+          return visited;\n+        }\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T>\n+Future<std::vector<T>> CollectAsyncGenerator(AsyncGenerator<T> generator) {\n+  auto vec = std::make_shared<std::vector<T>>();\n+  auto loop_body = [generator, vec] {\n+    auto next = generator();\n+    return next.Then([vec](const T& result) -> Result<ControlFlow<std::vector<T>>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(*vec);\n+      } else {\n+        vec->push_back(result);\n+        return Continue();\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T, typename V>\n+class TransformingGenerator {\n+ public:\n+  explicit TransformingGenerator(AsyncGenerator<T> generator,\n+                                 Transformer<T, V> transformer)\n+      : finished_(), last_value_(), generator_(generator), transformer_(transformer) {}\n+\n+  // See comment on TransformingIterator::Pump\n+  Result<util::optional<V>> Pump() {\n+    if (!finished_ && last_value_.has_value()) {\n+      ARROW_ASSIGN_OR_RAISE(TransformFlow<V> next, transformer_(*last_value_));\n+      if (next.ReadyForNext()) {\n+        if (*last_value_ == IterationTraits<T>::End()) {\n+          finished_ = true;\n+        }\n+        last_value_.reset();\n+      }\n+      if (next.Finished()) {\n+        finished_ = true;\n+      }\n+      if (next.HasValue()) {\n+        return next.Value();\n+      }\n+    }\n+    if (finished_) {\n+      return IterationTraits<V>::End();\n+    }\n+    return util::nullopt;\n+  }\n+\n+  Future<V> operator()() {\n+    while (true) {\n+      auto maybe_next_result = Pump();\n+      if (!maybe_next_result.ok()) {\n+        return Future<V>::MakeFinished(maybe_next_result.status());\n+      }\n+      auto maybe_next = maybe_next_result.ValueUnsafe();\n+      if (maybe_next.has_value()) {\n+        return Future<V>::MakeFinished(*maybe_next);\n\nReview comment:\n       `*std::move(maybe_next)`?\n\n##########\nFile path: cpp/src/arrow/util/async_iterator.h\n##########\n@@ -0,0 +1,295 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+#include <queue>\n+\n+#include \"arrow/util/functional.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+template <typename T>\n+using AsyncGenerator = std::function<Future<T>()>;\n+\n+/// Iterates through a generator of futures, visiting the result of each one and\n+/// returning a future that completes when all have been visited\n+template <typename T>\n+Future<> VisitAsyncGenerator(AsyncGenerator<T> generator,\n+                             std::function<Status(T)> visitor) {\n+  auto loop_body = [generator, visitor] {\n+    auto next = generator();\n+    return next.Then([visitor](const T& result) -> Result<ControlFlow<detail::Empty>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(detail::Empty());\n+      } else {\n+        auto visited = visitor(result);\n+        if (visited.ok()) {\n+          return Continue();\n+        } else {\n+          return visited;\n+        }\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T>\n+Future<std::vector<T>> CollectAsyncGenerator(AsyncGenerator<T> generator) {\n+  auto vec = std::make_shared<std::vector<T>>();\n+  auto loop_body = [generator, vec] {\n+    auto next = generator();\n+    return next.Then([vec](const T& result) -> Result<ControlFlow<std::vector<T>>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(*vec);\n+      } else {\n+        vec->push_back(result);\n+        return Continue();\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T, typename V>\n+class TransformingGenerator {\n+ public:\n+  explicit TransformingGenerator(AsyncGenerator<T> generator,\n+                                 Transformer<T, V> transformer)\n+      : finished_(), last_value_(), generator_(generator), transformer_(transformer) {}\n+\n+  // See comment on TransformingIterator::Pump\n+  Result<util::optional<V>> Pump() {\n+    if (!finished_ && last_value_.has_value()) {\n+      ARROW_ASSIGN_OR_RAISE(TransformFlow<V> next, transformer_(*last_value_));\n+      if (next.ReadyForNext()) {\n+        if (*last_value_ == IterationTraits<T>::End()) {\n+          finished_ = true;\n+        }\n+        last_value_.reset();\n+      }\n+      if (next.Finished()) {\n+        finished_ = true;\n+      }\n+      if (next.HasValue()) {\n+        return next.Value();\n+      }\n+    }\n+    if (finished_) {\n+      return IterationTraits<V>::End();\n+    }\n+    return util::nullopt;\n+  }\n+\n+  Future<V> operator()() {\n+    while (true) {\n+      auto maybe_next_result = Pump();\n+      if (!maybe_next_result.ok()) {\n+        return Future<V>::MakeFinished(maybe_next_result.status());\n+      }\n+      auto maybe_next = maybe_next_result.ValueUnsafe();\n+      if (maybe_next.has_value()) {\n+        return Future<V>::MakeFinished(*maybe_next);\n+      }\n+\n+      auto next_fut = generator_();\n+      // If finished already, process results immediately inside the loop to avoid stack\n+      // overflow\n+      if (next_fut.is_finished()) {\n+        auto next_result = next_fut.result();\n+        if (next_result.ok()) {\n+          last_value_ = *next_result;\n+        } else {\n+          return Future<V>::MakeFinished(next_result.status());\n+        }\n+        // Otherwise, if not finished immediately, add callback to process results\n+      } else {\n+        return next_fut.Then([this](const Result<T>& next_result) {\n+          if (next_result.ok()) {\n+            last_value_ = *next_result;\n+            return (*this)();\n+          } else {\n+            return Future<V>::MakeFinished(next_result.status());\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+ protected:\n+  bool finished_;\n+  util::optional<T> last_value_;\n+  AsyncGenerator<T> generator_;\n+  Transformer<T, V> transformer_;\n+};\n+\n+template <typename T>\n+static std::function<void(const Result<T>&)> MakeCallback(\n+    std::shared_ptr<bool> finished) {\n+  return [finished](const Result<T>& next_result) {\n+    if (!next_result.ok()) {\n+      *finished = true;\n+    } else {\n+      auto next = *next_result;\n+      *finished = (next == IterationTraits<T>::End());\n+    }\n+  };\n+}\n+\n+template <typename T>\n+AsyncGenerator<T> AddReadahead(AsyncGenerator<T> source_generator, int max_readahead) {\n+  // Using a shared_ptr instead of a lambda capture here because it's possible that\n+  // the inner mark_finished_if_done outlives the outer lambda\n+  auto finished = std::make_shared<bool>(false);\n+  auto mark_finished_if_done = [finished](const Result<T>& next_result) {\n+    if (!next_result.ok()) {\n+      *finished = true;\n+    } else {\n+      auto next = *next_result;\n\nReview comment:\n       `const auto&`\n\n##########\nFile path: cpp/src/arrow/util/async_iterator.h\n##########\n@@ -0,0 +1,295 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+#include <queue>\n+\n+#include \"arrow/util/functional.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+template <typename T>\n+using AsyncGenerator = std::function<Future<T>()>;\n+\n+/// Iterates through a generator of futures, visiting the result of each one and\n+/// returning a future that completes when all have been visited\n+template <typename T>\n+Future<> VisitAsyncGenerator(AsyncGenerator<T> generator,\n+                             std::function<Status(T)> visitor) {\n+  auto loop_body = [generator, visitor] {\n+    auto next = generator();\n+    return next.Then([visitor](const T& result) -> Result<ControlFlow<detail::Empty>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(detail::Empty());\n+      } else {\n+        auto visited = visitor(result);\n+        if (visited.ok()) {\n+          return Continue();\n+        } else {\n+          return visited;\n+        }\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T>\n+Future<std::vector<T>> CollectAsyncGenerator(AsyncGenerator<T> generator) {\n+  auto vec = std::make_shared<std::vector<T>>();\n+  auto loop_body = [generator, vec] {\n+    auto next = generator();\n+    return next.Then([vec](const T& result) -> Result<ControlFlow<std::vector<T>>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(*vec);\n+      } else {\n+        vec->push_back(result);\n+        return Continue();\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T, typename V>\n+class TransformingGenerator {\n+ public:\n+  explicit TransformingGenerator(AsyncGenerator<T> generator,\n+                                 Transformer<T, V> transformer)\n+      : finished_(), last_value_(), generator_(generator), transformer_(transformer) {}\n+\n+  // See comment on TransformingIterator::Pump\n+  Result<util::optional<V>> Pump() {\n+    if (!finished_ && last_value_.has_value()) {\n+      ARROW_ASSIGN_OR_RAISE(TransformFlow<V> next, transformer_(*last_value_));\n+      if (next.ReadyForNext()) {\n+        if (*last_value_ == IterationTraits<T>::End()) {\n+          finished_ = true;\n+        }\n+        last_value_.reset();\n+      }\n+      if (next.Finished()) {\n+        finished_ = true;\n+      }\n+      if (next.HasValue()) {\n+        return next.Value();\n+      }\n+    }\n+    if (finished_) {\n+      return IterationTraits<V>::End();\n+    }\n+    return util::nullopt;\n+  }\n+\n+  Future<V> operator()() {\n+    while (true) {\n+      auto maybe_next_result = Pump();\n+      if (!maybe_next_result.ok()) {\n+        return Future<V>::MakeFinished(maybe_next_result.status());\n+      }\n+      auto maybe_next = maybe_next_result.ValueUnsafe();\n+      if (maybe_next.has_value()) {\n+        return Future<V>::MakeFinished(*maybe_next);\n+      }\n+\n+      auto next_fut = generator_();\n+      // If finished already, process results immediately inside the loop to avoid stack\n+      // overflow\n+      if (next_fut.is_finished()) {\n+        auto next_result = next_fut.result();\n+        if (next_result.ok()) {\n+          last_value_ = *next_result;\n+        } else {\n+          return Future<V>::MakeFinished(next_result.status());\n+        }\n+        // Otherwise, if not finished immediately, add callback to process results\n+      } else {\n+        return next_fut.Then([this](const Result<T>& next_result) {\n+          if (next_result.ok()) {\n+            last_value_ = *next_result;\n+            return (*this)();\n+          } else {\n+            return Future<V>::MakeFinished(next_result.status());\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+ protected:\n+  bool finished_;\n+  util::optional<T> last_value_;\n+  AsyncGenerator<T> generator_;\n+  Transformer<T, V> transformer_;\n+};\n+\n+template <typename T>\n+static std::function<void(const Result<T>&)> MakeCallback(\n+    std::shared_ptr<bool> finished) {\n+  return [finished](const Result<T>& next_result) {\n+    if (!next_result.ok()) {\n+      *finished = true;\n+    } else {\n+      auto next = *next_result;\n+      *finished = (next == IterationTraits<T>::End());\n+    }\n+  };\n+}\n+\n+template <typename T>\n+AsyncGenerator<T> AddReadahead(AsyncGenerator<T> source_generator, int max_readahead) {\n+  // Using a shared_ptr instead of a lambda capture here because it's possible that\n+  // the inner mark_finished_if_done outlives the outer lambda\n+  auto finished = std::make_shared<bool>(false);\n+  auto mark_finished_if_done = [finished](const Result<T>& next_result) {\n+    if (!next_result.ok()) {\n+      *finished = true;\n+    } else {\n+      auto next = *next_result;\n+      *finished = (next == IterationTraits<T>::End());\n+    }\n+  };\n+\n+  std::queue<Future<T>> readahead_queue;\n+  return [=]() mutable -> Future<T> {\n+    if (readahead_queue.empty()) {\n+      // This is the first request, let's pump the underlying queue\n+      for (int i = 0; i < max_readahead; i++) {\n+        auto next = source_generator();\n+        next.AddCallback(mark_finished_if_done);\n+        readahead_queue.push(std::move(next));\n+      }\n+    }\n+    // Pop one and add one\n+    auto result = readahead_queue.front();\n+    readahead_queue.pop();\n+    if (*finished) {\n+      readahead_queue.push(Future<T>::MakeFinished(IterationTraits<T>::End()));\n+    } else {\n+      auto back_of_queue = source_generator();\n+      back_of_queue.AddCallback(mark_finished_if_done);\n+      readahead_queue.push(std::move(back_of_queue));\n+    }\n+    return result;\n+  };\n+}\n+\n+/// \\brief Transforms an async generator using a transformer function returning a new\n+/// AsyncGenerator\n+///\n+/// The transform function here behaves exactly the same as the transform function in\n+/// MakeTransformedIterator and you can safely use the same transform function to\n+/// transform both synchronous and asynchronous streams.\n+template <typename T, typename V>\n+AsyncGenerator<V> TransformAsyncGenerator(AsyncGenerator<T> generator,\n+                                          Transformer<T, V> transformer) {\n+  return TransformingGenerator<T, V>(generator, transformer);\n+}\n+\n+namespace detail {\n+\n+template <typename T>\n+struct BackgroundIteratorPromise : ReadaheadPromise {\n+  ~BackgroundIteratorPromise() override {}\n+\n+  explicit BackgroundIteratorPromise(Iterator<T>* it) : it_(it) {}\n+\n+  bool Call() override {\n+    auto next = it_->Next();\n+    auto finished = next == IterationTraits<T>::End();\n+    out_.MarkFinished(std::move(next));\n+    return finished;\n+  }\n+\n+  void End() override { out_.MarkFinished(IterationTraits<T>::End()); }\n+\n+  Iterator<T>* it_;\n+  Future<T> out_ = Future<T>::Make();\n+};\n+\n+}  // namespace detail\n+\n+/// \\brief Async generator that iterates on an underlying iterator in a\n+/// separate thread.\n+template <typename T>\n+class BackgroundIterator {\n\nReview comment:\n       It's a bit confusing that it's named `BackgroundIterator` even though it's not an iterator... should it be `BackgroundGenerator`?\n\n##########\nFile path: cpp/src/arrow/util/async_iterator.h\n##########\n@@ -0,0 +1,295 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+#include <queue>\n+\n+#include \"arrow/util/functional.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+template <typename T>\n+using AsyncGenerator = std::function<Future<T>()>;\n+\n+/// Iterates through a generator of futures, visiting the result of each one and\n+/// returning a future that completes when all have been visited\n+template <typename T>\n+Future<> VisitAsyncGenerator(AsyncGenerator<T> generator,\n+                             std::function<Status(T)> visitor) {\n+  auto loop_body = [generator, visitor] {\n+    auto next = generator();\n+    return next.Then([visitor](const T& result) -> Result<ControlFlow<detail::Empty>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(detail::Empty());\n+      } else {\n+        auto visited = visitor(result);\n+        if (visited.ok()) {\n+          return Continue();\n+        } else {\n+          return visited;\n+        }\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T>\n+Future<std::vector<T>> CollectAsyncGenerator(AsyncGenerator<T> generator) {\n+  auto vec = std::make_shared<std::vector<T>>();\n+  auto loop_body = [generator, vec] {\n+    auto next = generator();\n+    return next.Then([vec](const T& result) -> Result<ControlFlow<std::vector<T>>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(*vec);\n+      } else {\n+        vec->push_back(result);\n+        return Continue();\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T, typename V>\n+class TransformingGenerator {\n+ public:\n+  explicit TransformingGenerator(AsyncGenerator<T> generator,\n+                                 Transformer<T, V> transformer)\n+      : finished_(), last_value_(), generator_(generator), transformer_(transformer) {}\n+\n+  // See comment on TransformingIterator::Pump\n+  Result<util::optional<V>> Pump() {\n+    if (!finished_ && last_value_.has_value()) {\n+      ARROW_ASSIGN_OR_RAISE(TransformFlow<V> next, transformer_(*last_value_));\n+      if (next.ReadyForNext()) {\n+        if (*last_value_ == IterationTraits<T>::End()) {\n+          finished_ = true;\n+        }\n+        last_value_.reset();\n+      }\n+      if (next.Finished()) {\n+        finished_ = true;\n+      }\n+      if (next.HasValue()) {\n+        return next.Value();\n+      }\n+    }\n+    if (finished_) {\n+      return IterationTraits<V>::End();\n+    }\n+    return util::nullopt;\n+  }\n+\n+  Future<V> operator()() {\n+    while (true) {\n+      auto maybe_next_result = Pump();\n+      if (!maybe_next_result.ok()) {\n+        return Future<V>::MakeFinished(maybe_next_result.status());\n+      }\n+      auto maybe_next = maybe_next_result.ValueUnsafe();\n+      if (maybe_next.has_value()) {\n+        return Future<V>::MakeFinished(*maybe_next);\n+      }\n+\n+      auto next_fut = generator_();\n+      // If finished already, process results immediately inside the loop to avoid stack\n+      // overflow\n+      if (next_fut.is_finished()) {\n+        auto next_result = next_fut.result();\n+        if (next_result.ok()) {\n+          last_value_ = *next_result;\n+        } else {\n+          return Future<V>::MakeFinished(next_result.status());\n+        }\n+        // Otherwise, if not finished immediately, add callback to process results\n+      } else {\n+        return next_fut.Then([this](const Result<T>& next_result) {\n+          if (next_result.ok()) {\n+            last_value_ = *next_result;\n+            return (*this)();\n+          } else {\n+            return Future<V>::MakeFinished(next_result.status());\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+ protected:\n+  bool finished_;\n+  util::optional<T> last_value_;\n+  AsyncGenerator<T> generator_;\n+  Transformer<T, V> transformer_;\n+};\n+\n+template <typename T>\n+static std::function<void(const Result<T>&)> MakeCallback(\n+    std::shared_ptr<bool> finished) {\n+  return [finished](const Result<T>& next_result) {\n+    if (!next_result.ok()) {\n+      *finished = true;\n+    } else {\n+      auto next = *next_result;\n+      *finished = (next == IterationTraits<T>::End());\n+    }\n+  };\n+}\n+\n+template <typename T>\n+AsyncGenerator<T> AddReadahead(AsyncGenerator<T> source_generator, int max_readahead) {\n+  // Using a shared_ptr instead of a lambda capture here because it's possible that\n+  // the inner mark_finished_if_done outlives the outer lambda\n+  auto finished = std::make_shared<bool>(false);\n+  auto mark_finished_if_done = [finished](const Result<T>& next_result) {\n+    if (!next_result.ok()) {\n+      *finished = true;\n+    } else {\n+      auto next = *next_result;\n+      *finished = (next == IterationTraits<T>::End());\n+    }\n+  };\n+\n+  std::queue<Future<T>> readahead_queue;\n+  return [=]() mutable -> Future<T> {\n+    if (readahead_queue.empty()) {\n+      // This is the first request, let's pump the underlying queue\n+      for (int i = 0; i < max_readahead; i++) {\n+        auto next = source_generator();\n+        next.AddCallback(mark_finished_if_done);\n+        readahead_queue.push(std::move(next));\n+      }\n+    }\n+    // Pop one and add one\n+    auto result = readahead_queue.front();\n+    readahead_queue.pop();\n+    if (*finished) {\n+      readahead_queue.push(Future<T>::MakeFinished(IterationTraits<T>::End()));\n+    } else {\n+      auto back_of_queue = source_generator();\n+      back_of_queue.AddCallback(mark_finished_if_done);\n+      readahead_queue.push(std::move(back_of_queue));\n+    }\n+    return result;\n+  };\n+}\n+\n+/// \\brief Transforms an async generator using a transformer function returning a new\n+/// AsyncGenerator\n+///\n+/// The transform function here behaves exactly the same as the transform function in\n+/// MakeTransformedIterator and you can safely use the same transform function to\n+/// transform both synchronous and asynchronous streams.\n+template <typename T, typename V>\n+AsyncGenerator<V> TransformAsyncGenerator(AsyncGenerator<T> generator,\n+                                          Transformer<T, V> transformer) {\n+  return TransformingGenerator<T, V>(generator, transformer);\n+}\n+\n+namespace detail {\n+\n+template <typename T>\n+struct BackgroundIteratorPromise : ReadaheadPromise {\n+  ~BackgroundIteratorPromise() override {}\n+\n+  explicit BackgroundIteratorPromise(Iterator<T>* it) : it_(it) {}\n+\n+  bool Call() override {\n+    auto next = it_->Next();\n+    auto finished = next == IterationTraits<T>::End();\n+    out_.MarkFinished(std::move(next));\n+    return finished;\n+  }\n+\n+  void End() override { out_.MarkFinished(IterationTraits<T>::End()); }\n+\n+  Iterator<T>* it_;\n+  Future<T> out_ = Future<T>::Make();\n+};\n+\n+}  // namespace detail\n+\n+/// \\brief Async generator that iterates on an underlying iterator in a\n+/// separate thread.\n+template <typename T>\n+class BackgroundIterator {\n+  using PromiseType = typename detail::BackgroundIteratorPromise<T>;\n+\n+ public:\n+  explicit BackgroundIterator(Iterator<T> it, internal::Executor* executor)\n+      : it_(new Iterator<T>(std::move(it))),\n+        queue_(new detail::ReadaheadQueue(0)),\n+        executor_(executor),\n+        done_() {}\n+\n+  ~BackgroundIterator() {\n+    if (queue_) {\n+      // Make sure the queue doesn't call any promises after this object\n+      // is destroyed.\n+      queue_->EnsureShutdownOrDie();\n+    }\n+  }\n+\n+  ARROW_DEFAULT_MOVE_AND_ASSIGN(BackgroundIterator);\n+  ARROW_DISALLOW_COPY_AND_ASSIGN(BackgroundIterator);\n+\n+  Future<T> operator()() {\n+    if (done_) {\n+      return Future<T>::MakeFinished(IterationTraits<T>::End());\n+    }\n+    auto promise = std::unique_ptr<PromiseType>(new PromiseType{it_.get()});\n+    auto result = Future<T>(promise->out_);\n+    // TODO: Need a futuristic version of ARROW_RETURN_NOT_OK\n+    auto append_status = queue_->Append(\n+        static_cast<std::unique_ptr<detail::ReadaheadPromise>>(std::move(promise)));\n+    if (!append_status.ok()) {\n+      return Future<T>::MakeFinished(append_status);\n+    }\n+\n+    result.AddCallback([this](const Result<T>& result) {\n+      if (!result.ok() || result.ValueUnsafe() == IterationTraits<T>::End()) {\n+        done_ = true;\n+      }\n+    });\n+\n+    return executor_->Transfer(result);\n\nReview comment:\n       Unless I'm misreading this, it seems only the trivial callback above is spawned on the executor?\n\n##########\nFile path: cpp/src/arrow/util/async_iterator.h\n##########\n@@ -0,0 +1,295 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+#include <queue>\n+\n+#include \"arrow/util/functional.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+template <typename T>\n+using AsyncGenerator = std::function<Future<T>()>;\n+\n+/// Iterates through a generator of futures, visiting the result of each one and\n+/// returning a future that completes when all have been visited\n+template <typename T>\n+Future<> VisitAsyncGenerator(AsyncGenerator<T> generator,\n+                             std::function<Status(T)> visitor) {\n+  auto loop_body = [generator, visitor] {\n+    auto next = generator();\n+    return next.Then([visitor](const T& result) -> Result<ControlFlow<detail::Empty>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(detail::Empty());\n+      } else {\n+        auto visited = visitor(result);\n+        if (visited.ok()) {\n+          return Continue();\n+        } else {\n+          return visited;\n+        }\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T>\n+Future<std::vector<T>> CollectAsyncGenerator(AsyncGenerator<T> generator) {\n+  auto vec = std::make_shared<std::vector<T>>();\n+  auto loop_body = [generator, vec] {\n+    auto next = generator();\n+    return next.Then([vec](const T& result) -> Result<ControlFlow<std::vector<T>>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(*vec);\n+      } else {\n+        vec->push_back(result);\n+        return Continue();\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T, typename V>\n+class TransformingGenerator {\n+ public:\n+  explicit TransformingGenerator(AsyncGenerator<T> generator,\n+                                 Transformer<T, V> transformer)\n+      : finished_(), last_value_(), generator_(generator), transformer_(transformer) {}\n+\n+  // See comment on TransformingIterator::Pump\n+  Result<util::optional<V>> Pump() {\n+    if (!finished_ && last_value_.has_value()) {\n+      ARROW_ASSIGN_OR_RAISE(TransformFlow<V> next, transformer_(*last_value_));\n+      if (next.ReadyForNext()) {\n+        if (*last_value_ == IterationTraits<T>::End()) {\n+          finished_ = true;\n+        }\n+        last_value_.reset();\n+      }\n+      if (next.Finished()) {\n+        finished_ = true;\n+      }\n+      if (next.HasValue()) {\n+        return next.Value();\n+      }\n+    }\n+    if (finished_) {\n+      return IterationTraits<V>::End();\n+    }\n+    return util::nullopt;\n+  }\n+\n+  Future<V> operator()() {\n+    while (true) {\n+      auto maybe_next_result = Pump();\n+      if (!maybe_next_result.ok()) {\n+        return Future<V>::MakeFinished(maybe_next_result.status());\n+      }\n+      auto maybe_next = maybe_next_result.ValueUnsafe();\n+      if (maybe_next.has_value()) {\n+        return Future<V>::MakeFinished(*maybe_next);\n+      }\n+\n+      auto next_fut = generator_();\n+      // If finished already, process results immediately inside the loop to avoid stack\n+      // overflow\n+      if (next_fut.is_finished()) {\n+        auto next_result = next_fut.result();\n+        if (next_result.ok()) {\n+          last_value_ = *next_result;\n+        } else {\n+          return Future<V>::MakeFinished(next_result.status());\n+        }\n+        // Otherwise, if not finished immediately, add callback to process results\n+      } else {\n+        return next_fut.Then([this](const Result<T>& next_result) {\n+          if (next_result.ok()) {\n+            last_value_ = *next_result;\n+            return (*this)();\n+          } else {\n+            return Future<V>::MakeFinished(next_result.status());\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+ protected:\n+  bool finished_;\n+  util::optional<T> last_value_;\n+  AsyncGenerator<T> generator_;\n+  Transformer<T, V> transformer_;\n+};\n+\n+template <typename T>\n+static std::function<void(const Result<T>&)> MakeCallback(\n+    std::shared_ptr<bool> finished) {\n+  return [finished](const Result<T>& next_result) {\n+    if (!next_result.ok()) {\n+      *finished = true;\n+    } else {\n+      auto next = *next_result;\n+      *finished = (next == IterationTraits<T>::End());\n+    }\n+  };\n+}\n+\n+template <typename T>\n+AsyncGenerator<T> AddReadahead(AsyncGenerator<T> source_generator, int max_readahead) {\n+  // Using a shared_ptr instead of a lambda capture here because it's possible that\n+  // the inner mark_finished_if_done outlives the outer lambda\n+  auto finished = std::make_shared<bool>(false);\n+  auto mark_finished_if_done = [finished](const Result<T>& next_result) {\n+    if (!next_result.ok()) {\n+      *finished = true;\n+    } else {\n+      auto next = *next_result;\n+      *finished = (next == IterationTraits<T>::End());\n+    }\n+  };\n+\n+  std::queue<Future<T>> readahead_queue;\n+  return [=]() mutable -> Future<T> {\n+    if (readahead_queue.empty()) {\n+      // This is the first request, let's pump the underlying queue\n+      for (int i = 0; i < max_readahead; i++) {\n+        auto next = source_generator();\n+        next.AddCallback(mark_finished_if_done);\n+        readahead_queue.push(std::move(next));\n+      }\n+    }\n+    // Pop one and add one\n+    auto result = readahead_queue.front();\n+    readahead_queue.pop();\n+    if (*finished) {\n+      readahead_queue.push(Future<T>::MakeFinished(IterationTraits<T>::End()));\n+    } else {\n+      auto back_of_queue = source_generator();\n+      back_of_queue.AddCallback(mark_finished_if_done);\n+      readahead_queue.push(std::move(back_of_queue));\n+    }\n+    return result;\n+  };\n+}\n+\n+/// \\brief Transforms an async generator using a transformer function returning a new\n+/// AsyncGenerator\n+///\n+/// The transform function here behaves exactly the same as the transform function in\n+/// MakeTransformedIterator and you can safely use the same transform function to\n+/// transform both synchronous and asynchronous streams.\n+template <typename T, typename V>\n+AsyncGenerator<V> TransformAsyncGenerator(AsyncGenerator<T> generator,\n+                                          Transformer<T, V> transformer) {\n+  return TransformingGenerator<T, V>(generator, transformer);\n+}\n+\n+namespace detail {\n+\n+template <typename T>\n+struct BackgroundIteratorPromise : ReadaheadPromise {\n+  ~BackgroundIteratorPromise() override {}\n+\n+  explicit BackgroundIteratorPromise(Iterator<T>* it) : it_(it) {}\n+\n+  bool Call() override {\n+    auto next = it_->Next();\n+    auto finished = next == IterationTraits<T>::End();\n+    out_.MarkFinished(std::move(next));\n+    return finished;\n+  }\n+\n+  void End() override { out_.MarkFinished(IterationTraits<T>::End()); }\n+\n+  Iterator<T>* it_;\n+  Future<T> out_ = Future<T>::Make();\n+};\n+\n+}  // namespace detail\n+\n+/// \\brief Async generator that iterates on an underlying iterator in a\n+/// separate thread.\n\nReview comment:\n       \"in an executor\", rather?\r\n   \r\n   Can you document whether the underlying iterator may be called from several threads at once?\n\n##########\nFile path: cpp/src/arrow/util/async_iterator.h\n##########\n@@ -0,0 +1,295 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+#include <queue>\n+\n+#include \"arrow/util/functional.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+template <typename T>\n+using AsyncGenerator = std::function<Future<T>()>;\n+\n+/// Iterates through a generator of futures, visiting the result of each one and\n+/// returning a future that completes when all have been visited\n+template <typename T>\n+Future<> VisitAsyncGenerator(AsyncGenerator<T> generator,\n+                             std::function<Status(T)> visitor) {\n+  auto loop_body = [generator, visitor] {\n+    auto next = generator();\n+    return next.Then([visitor](const T& result) -> Result<ControlFlow<detail::Empty>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(detail::Empty());\n+      } else {\n+        auto visited = visitor(result);\n+        if (visited.ok()) {\n+          return Continue();\n+        } else {\n+          return visited;\n+        }\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T>\n+Future<std::vector<T>> CollectAsyncGenerator(AsyncGenerator<T> generator) {\n+  auto vec = std::make_shared<std::vector<T>>();\n+  auto loop_body = [generator, vec] {\n+    auto next = generator();\n+    return next.Then([vec](const T& result) -> Result<ControlFlow<std::vector<T>>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(*vec);\n+      } else {\n+        vec->push_back(result);\n+        return Continue();\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T, typename V>\n+class TransformingGenerator {\n+ public:\n+  explicit TransformingGenerator(AsyncGenerator<T> generator,\n+                                 Transformer<T, V> transformer)\n+      : finished_(), last_value_(), generator_(generator), transformer_(transformer) {}\n+\n+  // See comment on TransformingIterator::Pump\n+  Result<util::optional<V>> Pump() {\n+    if (!finished_ && last_value_.has_value()) {\n+      ARROW_ASSIGN_OR_RAISE(TransformFlow<V> next, transformer_(*last_value_));\n+      if (next.ReadyForNext()) {\n+        if (*last_value_ == IterationTraits<T>::End()) {\n+          finished_ = true;\n+        }\n+        last_value_.reset();\n+      }\n+      if (next.Finished()) {\n+        finished_ = true;\n+      }\n+      if (next.HasValue()) {\n+        return next.Value();\n+      }\n+    }\n+    if (finished_) {\n+      return IterationTraits<V>::End();\n+    }\n+    return util::nullopt;\n+  }\n+\n+  Future<V> operator()() {\n+    while (true) {\n+      auto maybe_next_result = Pump();\n+      if (!maybe_next_result.ok()) {\n+        return Future<V>::MakeFinished(maybe_next_result.status());\n+      }\n+      auto maybe_next = maybe_next_result.ValueUnsafe();\n+      if (maybe_next.has_value()) {\n+        return Future<V>::MakeFinished(*maybe_next);\n+      }\n+\n+      auto next_fut = generator_();\n+      // If finished already, process results immediately inside the loop to avoid stack\n+      // overflow\n+      if (next_fut.is_finished()) {\n+        auto next_result = next_fut.result();\n+        if (next_result.ok()) {\n+          last_value_ = *next_result;\n+        } else {\n+          return Future<V>::MakeFinished(next_result.status());\n+        }\n+        // Otherwise, if not finished immediately, add callback to process results\n+      } else {\n+        return next_fut.Then([this](const Result<T>& next_result) {\n+          if (next_result.ok()) {\n+            last_value_ = *next_result;\n+            return (*this)();\n+          } else {\n+            return Future<V>::MakeFinished(next_result.status());\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+ protected:\n+  bool finished_;\n+  util::optional<T> last_value_;\n+  AsyncGenerator<T> generator_;\n+  Transformer<T, V> transformer_;\n+};\n+\n+template <typename T>\n+static std::function<void(const Result<T>&)> MakeCallback(\n+    std::shared_ptr<bool> finished) {\n+  return [finished](const Result<T>& next_result) {\n+    if (!next_result.ok()) {\n+      *finished = true;\n+    } else {\n+      auto next = *next_result;\n+      *finished = (next == IterationTraits<T>::End());\n+    }\n+  };\n+}\n+\n+template <typename T>\n+AsyncGenerator<T> AddReadahead(AsyncGenerator<T> source_generator, int max_readahead) {\n+  // Using a shared_ptr instead of a lambda capture here because it's possible that\n+  // the inner mark_finished_if_done outlives the outer lambda\n+  auto finished = std::make_shared<bool>(false);\n+  auto mark_finished_if_done = [finished](const Result<T>& next_result) {\n+    if (!next_result.ok()) {\n+      *finished = true;\n+    } else {\n+      auto next = *next_result;\n+      *finished = (next == IterationTraits<T>::End());\n+    }\n+  };\n+\n+  std::queue<Future<T>> readahead_queue;\n+  return [=]() mutable -> Future<T> {\n\nReview comment:\n       Instead of having the closure state spread around as (copied) local variables, perhaps create a dedicated callable object?\n\n##########\nFile path: cpp/src/arrow/util/async_iterator.h\n##########\n@@ -0,0 +1,295 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+#include <queue>\n+\n+#include \"arrow/util/functional.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+template <typename T>\n+using AsyncGenerator = std::function<Future<T>()>;\n+\n+/// Iterates through a generator of futures, visiting the result of each one and\n+/// returning a future that completes when all have been visited\n+template <typename T>\n+Future<> VisitAsyncGenerator(AsyncGenerator<T> generator,\n+                             std::function<Status(T)> visitor) {\n+  auto loop_body = [generator, visitor] {\n+    auto next = generator();\n+    return next.Then([visitor](const T& result) -> Result<ControlFlow<detail::Empty>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(detail::Empty());\n+      } else {\n+        auto visited = visitor(result);\n+        if (visited.ok()) {\n+          return Continue();\n+        } else {\n+          return visited;\n+        }\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T>\n+Future<std::vector<T>> CollectAsyncGenerator(AsyncGenerator<T> generator) {\n+  auto vec = std::make_shared<std::vector<T>>();\n+  auto loop_body = [generator, vec] {\n+    auto next = generator();\n+    return next.Then([vec](const T& result) -> Result<ControlFlow<std::vector<T>>> {\n+      if (result == IterationTraits<T>::End()) {\n+        return Break(*vec);\n+      } else {\n+        vec->push_back(result);\n+        return Continue();\n+      }\n+    });\n+  };\n+  return Loop(loop_body);\n+}\n+\n+template <typename T, typename V>\n+class TransformingGenerator {\n+ public:\n+  explicit TransformingGenerator(AsyncGenerator<T> generator,\n+                                 Transformer<T, V> transformer)\n+      : finished_(), last_value_(), generator_(generator), transformer_(transformer) {}\n+\n+  // See comment on TransformingIterator::Pump\n+  Result<util::optional<V>> Pump() {\n+    if (!finished_ && last_value_.has_value()) {\n+      ARROW_ASSIGN_OR_RAISE(TransformFlow<V> next, transformer_(*last_value_));\n+      if (next.ReadyForNext()) {\n+        if (*last_value_ == IterationTraits<T>::End()) {\n+          finished_ = true;\n+        }\n+        last_value_.reset();\n+      }\n+      if (next.Finished()) {\n+        finished_ = true;\n+      }\n+      if (next.HasValue()) {\n+        return next.Value();\n+      }\n+    }\n+    if (finished_) {\n+      return IterationTraits<V>::End();\n+    }\n+    return util::nullopt;\n+  }\n+\n+  Future<V> operator()() {\n+    while (true) {\n+      auto maybe_next_result = Pump();\n+      if (!maybe_next_result.ok()) {\n+        return Future<V>::MakeFinished(maybe_next_result.status());\n+      }\n+      auto maybe_next = maybe_next_result.ValueUnsafe();\n+      if (maybe_next.has_value()) {\n+        return Future<V>::MakeFinished(*maybe_next);\n+      }\n+\n+      auto next_fut = generator_();\n+      // If finished already, process results immediately inside the loop to avoid stack\n+      // overflow\n+      if (next_fut.is_finished()) {\n+        auto next_result = next_fut.result();\n+        if (next_result.ok()) {\n+          last_value_ = *next_result;\n+        } else {\n+          return Future<V>::MakeFinished(next_result.status());\n+        }\n+        // Otherwise, if not finished immediately, add callback to process results\n+      } else {\n+        return next_fut.Then([this](const Result<T>& next_result) {\n+          if (next_result.ok()) {\n+            last_value_ = *next_result;\n+            return (*this)();\n+          } else {\n+            return Future<V>::MakeFinished(next_result.status());\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+ protected:\n+  bool finished_;\n+  util::optional<T> last_value_;\n+  AsyncGenerator<T> generator_;\n+  Transformer<T, V> transformer_;\n+};\n+\n+template <typename T>\n+static std::function<void(const Result<T>&)> MakeCallback(\n+    std::shared_ptr<bool> finished) {\n+  return [finished](const Result<T>& next_result) {\n+    if (!next_result.ok()) {\n+      *finished = true;\n+    } else {\n+      auto next = *next_result;\n+      *finished = (next == IterationTraits<T>::End());\n+    }\n+  };\n+}\n+\n+template <typename T>\n+AsyncGenerator<T> AddReadahead(AsyncGenerator<T> source_generator, int max_readahead) {\n+  // Using a shared_ptr instead of a lambda capture here because it's possible that\n+  // the inner mark_finished_if_done outlives the outer lambda\n+  auto finished = std::make_shared<bool>(false);\n+  auto mark_finished_if_done = [finished](const Result<T>& next_result) {\n+    if (!next_result.ok()) {\n+      *finished = true;\n+    } else {\n+      auto next = *next_result;\n+      *finished = (next == IterationTraits<T>::End());\n+    }\n+  };\n+\n+  std::queue<Future<T>> readahead_queue;\n+  return [=]() mutable -> Future<T> {\n+    if (readahead_queue.empty()) {\n+      // This is the first request, let's pump the underlying queue\n+      for (int i = 0; i < max_readahead; i++) {\n+        auto next = source_generator();\n+        next.AddCallback(mark_finished_if_done);\n+        readahead_queue.push(std::move(next));\n+      }\n+    }\n+    // Pop one and add one\n+    auto result = readahead_queue.front();\n+    readahead_queue.pop();\n+    if (*finished) {\n+      readahead_queue.push(Future<T>::MakeFinished(IterationTraits<T>::End()));\n+    } else {\n+      auto back_of_queue = source_generator();\n+      back_of_queue.AddCallback(mark_finished_if_done);\n\nReview comment:\n       Why use `AddCallback` while this can simply be done synchronously above? This will add overhead.\n\n##########\nFile path: cpp/src/arrow/util/task_group_test.cc\n##########\n@@ -244,6 +245,65 @@ void TestNoCopyTask(std::shared_ptr<TaskGroup> task_group) {\n   ASSERT_EQ(0, *counter);\n }\n \n+void TestFinishNotSticky(std::function<std::shared_ptr<TaskGroup>()> factory) {\n+  // If a task is added that runs very quickly it might decrement the task counter back\n+  // down to 0 and mark the completion future as complete before all tasks are added.\n+  // The \"finished future\" of the task group could get stuck to complete.\n+  const int NTASKS = 100;\n+  for (int i = 0; i < NTASKS; ++i) {\n+    auto task_group = factory();\n+    // Add a task and let it complete\n+    task_group->Append([] { return Status::OK(); });\n+    // Wait a little bit, if the task group was going to lock the finish hopefully it\n+    // would do so here while we wait\n+    SleepFor(1e-2);\n+\n+    // Add a new task that will still be running\n+    std::atomic<bool> ready(false);\n+    std::mutex m;\n+    std::condition_variable cv;\n+    task_group->Append([&m, &cv, &ready] {\n+      std::unique_lock<std::mutex> lk(m);\n+      cv.wait(lk, [&ready] { return ready.load(); });\n+      return Status::OK();\n+    });\n+\n+    // Ensure task group not finished already\n+    auto finished = task_group->FinishAsync();\n+    ASSERT_FALSE(finished.is_finished());\n+\n+    std::unique_lock<std::mutex> lk(m);\n+    ready = true;\n+    lk.unlock();\n+    cv.notify_one();\n+\n+    ASSERT_TRUE(finished.Wait(1));\n\nReview comment:\n       Should we check that `status()` here as well (and below)?\n\n##########\nFile path: cpp/src/arrow/csv/reader.cc\n##########\n@@ -837,20 +885,121 @@ class ThreadedTableReader : public BaseTableReader {\n   }\n \n  protected:\n-  ThreadPool* thread_pool_;\n+  Executor* thread_pool_;\n+  Iterator<std::shared_ptr<Buffer>> buffer_iterator_;\n+};\n+\n+class AsyncThreadedTableReader\n+    : public BaseTableReader,\n+      public std::enable_shared_from_this<AsyncThreadedTableReader> {\n+ public:\n+  using BaseTableReader::BaseTableReader;\n+\n+  AsyncThreadedTableReader(MemoryPool* pool, std::shared_ptr<io::InputStream> input,\n+                           const ReadOptions& read_options,\n+                           const ParseOptions& parse_options,\n+                           const ConvertOptions& convert_options, Executor* thread_pool)\n+      : BaseTableReader(pool, input, read_options, parse_options, convert_options),\n+        thread_pool_(thread_pool) {}\n+\n+  ~AsyncThreadedTableReader() override {\n+    if (task_group_) {\n+      // In case of error, make sure all pending tasks are finished before\n+      // we start destroying BaseTableReader members\n+      ARROW_UNUSED(task_group_->Finish());\n+    }\n+  }\n+\n+  Status Init() override {\n+    ARROW_ASSIGN_OR_RAISE(auto istream_it,\n+                          io::MakeInputStreamIterator(input_, read_options_.block_size));\n+\n+    ARROW_ASSIGN_OR_RAISE(auto bg_it,\n+                          MakeBackgroundIterator(std::move(istream_it), thread_pool_));\n+\n+    int32_t block_queue_size = thread_pool_->GetCapacity();\n+    auto rh_it = AddReadahead(bg_it, block_queue_size);\n+    buffer_generator_ = CSVBufferIterator::MakeAsync(std::move(rh_it));\n+    return Status::OK();\n+  }\n+\n+  Result<std::shared_ptr<Table>> Read() override { return ReadAsync().result(); }\n+\n+  Future<std::shared_ptr<Table>> ReadAsync() override {\n+    task_group_ = internal::TaskGroup::MakeThreaded(thread_pool_);\n+\n+    auto self = shared_from_this();\n+    return ProcessFirstBuffer().Then([self](const std::shared_ptr<Buffer> first_buffer) {\n+      auto block_generator = ThreadedBlockReader::MakeAsyncIterator(\n+          self->buffer_generator_, MakeChunker(self->parse_options_),\n+          std::move(first_buffer));\n+\n+      std::function<Status(util::optional<CSVBlock>)> block_visitor =\n+          [self](util::optional<CSVBlock> maybe_block) -> Status {\n+        DCHECK(!maybe_block->consume_bytes);\n\nReview comment:\n       So `maybe_block` always has a value...?\n\n##########\nFile path: cpp/src/arrow/util/task_group_test.cc\n##########\n@@ -292,5 +352,25 @@ TEST(ThreadedTaskGroup, StressFailingTaskGroupLifetime) {\n       [&] { return TaskGroup::MakeThreaded(thread_pool.get()); });\n }\n \n+TEST(ThreadedTaskGroup, FinishNotSticky) {\n+  std::shared_ptr<ThreadPool> thread_pool;\n+  ASSERT_OK_AND_ASSIGN(thread_pool, ThreadPool::Make(16));\n+\n+  TestFinishNotSticky([&] { return TaskGroup::MakeThreaded(thread_pool.get()); });\n+}\n+\n+TEST(ThreadedTaskGroup, FinishNeverStarted) {\n+  std::shared_ptr<ThreadPool> thread_pool;\n+  ASSERT_OK_AND_ASSIGN(thread_pool, ThreadPool::Make(4));\n+  TestFinishNeverStarted(TaskGroup::MakeThreaded(thread_pool.get()));\n+}\n+\n+TEST(ThreadedTaskGroup, FinishAlreadyCompleted) {\n+  std::shared_ptr<ThreadPool> thread_pool;\n+  ASSERT_OK_AND_ASSIGN(thread_pool, ThreadPool::Make(16));\n+\n+  TestFinishAlreadyCompleted([&] { return TaskGroup::MakeThreaded(thread_pool.get()); });\n+}\n\nReview comment:\n       Shouldn't you similarly call those tests for `SerialTaskGroup`?\n\n##########\nFile path: cpp/src/arrow/util/iterator_test.cc\n##########\n@@ -214,6 +255,270 @@ TEST(TestVectorIterator, RangeForLoop) {\n   ASSERT_EQ(ints_it, ints.end());\n }\n \n+template <typename T>\n+Transformer<T, T> MakeFirstN(int n) {\n+  int remaining = n;\n+  return [remaining](T next) mutable -> Result<TransformFlow<T>> {\n+    if (remaining > 0) {\n+      remaining--;\n+      return TransformYield(next);\n+    }\n+    return TransformFinish();\n+  };\n+}\n+\n+TEST(TestIteratorTransform, Truncating) {\n+  auto original = VectorIt({1, 2, 3});\n+  auto truncated = MakeTransformedIterator(std::move(original), MakeFirstN<TestInt>(2));\n+  AssertIteratorMatch({1, 2}, std::move(truncated));\n+}\n+\n+TEST(TestIteratorTransform, TestPointer) {\n+  auto original = VectorIt<std::shared_ptr<int>>(\n+      {std::make_shared<int>(1), std::make_shared<int>(2), std::make_shared<int>(3)});\n+  auto truncated =\n+      MakeTransformedIterator(std::move(original), MakeFirstN<std::shared_ptr<int>>(2));\n+  ASSERT_OK_AND_ASSIGN(auto result, truncated.ToVector());\n+  ASSERT_EQ(2, result.size());\n+}\n+\n+TEST(TestIteratorTransform, TruncatingShort) {\n+  // Tests the failsafe case where we never call Finish\n+  auto original = VectorIt({1});\n+  auto truncated = MakeTransformedIterator<TestInt, TestInt>(std::move(original),\n+                                                             MakeFirstN<TestInt>(2));\n+  AssertIteratorMatch({1}, std::move(truncated));\n+}\n+\n+TEST(TestAsyncUtil, Background) {\n+  std::vector<TestInt> expected = {1, 2, 3};\n+  auto background = BackgroundAsyncVectorIt(expected);\n+  auto future = CollectAsyncGenerator(background);\n+  ASSERT_FALSE(future.is_finished());\n+  future.Wait();\n+  ASSERT_TRUE(future.is_finished());\n+  ASSERT_EQ(expected, *future.result());\n+}\n+\n+struct SlowEmptyIterator {\n+  Result<TestInt> Next() {\n+    if (called_) {\n+      return Status::Invalid(\"Should not have been called twice\");\n+    }\n+    SleepFor(0.1);\n+    return IterationTraits<TestInt>::End();\n+  }\n+\n+ private:\n+  bool called_ = false;\n+};\n+\n+TEST(TestAsyncUtil, BackgroundRepeatEnd) {\n+  // Ensure that the background iterator properly fulfills the asyncgenerator contract\n+  // and can be called after it ends.\n+  auto iterator = Iterator<TestInt>(SlowEmptyIterator());\n+  ASSERT_OK_AND_ASSIGN(\n+      auto background_iter,\n+      MakeBackgroundIterator(std::move(iterator), internal::GetCpuThreadPool()));\n+\n+  auto one = background_iter();\n+  auto two = background_iter();\n+\n+  ASSERT_TRUE(one.Wait(0.5));\n+\n+  if (one.is_finished()) {\n+    ASSERT_EQ(IterationTraits<TestInt>::End(), *one.result());\n+  }\n+\n+  ASSERT_TRUE(two.Wait(0.5));\n+  ASSERT_TRUE(two.is_finished());\n+  if (two.is_finished()) {\n+    ASSERT_EQ(IterationTraits<TestInt>::End(), *two.result());\n+  }\n+}\n+\n+TEST(TestAsyncUtil, SynchronousFinish) {\n+  AsyncGenerator<TestInt> generator = []() {\n+    return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\n+  };\n+  Transformer<TestInt, TestInt> skip_all = [](TestInt value) { return TransformSkip(); };\n+  auto transformed = TransformAsyncGenerator(generator, skip_all);\n+  auto future = CollectAsyncGenerator(transformed);\n+  ASSERT_TRUE(future.is_finished());\n+  ASSERT_OK_AND_ASSIGN(auto actual, future.result());\n+  ASSERT_EQ(std::vector<TestInt>(), actual);\n+}\n+\n+TEST(TestAsyncUtil, CompleteBackgroundStressTest) {\n+  auto expected = RangeVector(100);\n+  std::vector<Future<std::vector<TestInt>>> futures;\n+  for (unsigned int i = 0; i < 100; i++) {\n+    auto background = BackgroundAsyncVectorIt(expected);\n+    futures.push_back(CollectAsyncGenerator(background));\n+  }\n+  auto combined = All(futures);\n+  combined.Wait(2);\n+  if (combined.is_finished()) {\n+    ASSERT_OK_AND_ASSIGN(auto completed_vectors, combined.result());\n+    for (auto&& vector : completed_vectors) {\n+      ASSERT_EQ(vector, expected);\n+    }\n+  } else {\n+    FAIL() << \"After 2 seconds all background iterators had not finished collecting\";\n+  }\n+}\n+\n+TEST(TestAsyncUtil, StackOverflow) {\n+  int counter = 0;\n+  AsyncGenerator<TestInt> generator = [&counter]() {\n+    if (counter < 1000000) {\n+      return Future<TestInt>::MakeFinished(counter++);\n+    } else {\n+      return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\n+    }\n+  };\n+  Transformer<TestInt, TestInt> discard =\n+      [](TestInt next) -> Result<TransformFlow<TestInt>> { return TransformSkip(); };\n+  auto transformed = TransformAsyncGenerator(generator, discard);\n+  auto collected_future = CollectAsyncGenerator(transformed);\n+  ASSERT_TRUE(collected_future.Wait(5));\n+  if (collected_future.is_finished()) {\n+    ASSERT_OK_AND_ASSIGN(auto collected, collected_future.result());\n+    ASSERT_EQ(0, collected.size());\n+  }\n+}\n+\n+TEST(TestAsyncUtil, Visit) {\n+  auto generator = AsyncVectorIt({1, 2, 3});\n+  unsigned int sum = 0;\n+  auto sum_future = VisitAsyncGenerator<TestInt>(generator, [&sum](TestInt item) {\n+    sum += item.value;\n+    return Status::OK();\n+  });\n+  // Should be superfluous\n+  sum_future.Wait();\n+  ASSERT_EQ(6, sum);\n+}\n+\n+TEST(TestAsyncUtil, Collect) {\n+  std::vector<TestInt> expected = {1, 2, 3};\n+  auto generator = AsyncVectorIt(expected);\n+  auto collected = CollectAsyncGenerator(generator);\n+  ASSERT_EQ(expected, *collected.result());\n+}\n+\n+template <typename T>\n+Transformer<T, T> MakeRepeatN(int repeat_count) {\n+  int current_repeat = 0;\n+  return [repeat_count, current_repeat](T next) mutable -> Result<TransformFlow<T>> {\n+    current_repeat++;\n+    bool ready_for_next = false;\n+    if (current_repeat == repeat_count) {\n+      current_repeat = 0;\n+      ready_for_next = true;\n+    }\n+    return TransformYield(next, ready_for_next);\n+  };\n+}\n+\n+TEST(TestIteratorTransform, Repeating) {\n+  auto original = VectorIt({1, 2, 3});\n+  auto repeated = MakeTransformedIterator<TestInt, TestInt>(std::move(original),\n+                                                            MakeRepeatN<TestInt>(2));\n+  AssertIteratorMatch({1, 1, 2, 2, 3, 3}, std::move(repeated));\n+}\n+\n+template <typename T>\n+Transformer<T, T> MakeFilter(std::function<bool(T&)> filter) {\n+  return [filter](T next) -> Result<TransformFlow<T>> {\n+    if (filter(next)) {\n+      return TransformYield(next);\n+    } else {\n+      return TransformSkip();\n+    }\n+  };\n+}\n+\n+template <typename T>\n+Transformer<T, T> MakeAbortOnSecond() {\n+  int counter = 0;\n+  return [counter](T next) mutable -> Result<TransformFlow<T>> {\n+    if (counter++ == 1) {\n+      return Status::Invalid(\"X\");\n+    }\n+    return TransformYield(next);\n+  };\n+}\n+\n+TEST(TestIteratorTransform, SkipSome) {\n+  // Exercises TransformSkip\n+  auto original = VectorIt({1, 2, 3});\n+  auto filter = MakeFilter<TestInt>([](TestInt& t) { return t.value != 2; });\n+  auto filtered = MakeTransformedIterator(std::move(original), filter);\n+  AssertIteratorMatch({1, 3}, std::move(filtered));\n+}\n+\n+TEST(TestIteratorTransform, SkipAll) {\n+  // Exercises TransformSkip\n+  auto original = VectorIt({1, 2, 3});\n+  auto filter = MakeFilter<TestInt>([](TestInt& t) { return false; });\n+  auto filtered = MakeTransformedIterator(std::move(original), filter);\n+  AssertIteratorMatch({}, std::move(filtered));\n+}\n+\n+TEST(TestIteratorTransform, Abort) {\n+  auto original = VectorIt({1, 2, 3});\n+  auto transformed =\n+      MakeTransformedIterator(std::move(original), MakeAbortOnSecond<TestInt>());\n+  ASSERT_OK(transformed.Next());\n+  ASSERT_RAISES(Invalid, transformed.Next());\n+}\n+\n+TEST(TestAsyncIteratorTransform, SkipSome) {\n+  auto original = AsyncVectorIt({1, 2, 3});\n+  auto filter = MakeFilter<TestInt>([](TestInt& t) { return t.value != 2; });\n+  auto filtered = TransformAsyncGenerator(std::move(original), filter);\n+  AssertAsyncGeneratorMatch({1, 3}, std::move(filtered));\n+}\n+\n+TEST(TestAsyncUtil, ReadaheadFailed) {\n+  auto source = []() -> Future<TestInt> {\n+    return Future<TestInt>::MakeFinished(Status::Invalid(\"X\"));\n+  };\n+  auto readahead = AddReadahead<TestInt>(source, 10);\n+  auto next = readahead();\n+  ASSERT_EQ(Status::Invalid(\"X\"), next.status());\n+}\n+\n+TEST(TestAsyncUtil, Readahead) {\n+  int num_delivered = 0;\n+  auto source = [&num_delivered]() {\n+    if (num_delivered < 5) {\n+      return Future<TestInt>::MakeFinished(num_delivered++);\n+    } else {\n+      return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\n+    }\n+  };\n+  auto readahead = AddReadahead<TestInt>(source, 10);\n+  // Should not pump until first item requested\n+  ASSERT_EQ(0, num_delivered);\n+\n+  auto first = readahead();\n+  // At this point the pumping should have happened\n+  ASSERT_EQ(5, num_delivered);\n+  ASSERT_EQ(0, first.result()->value);\n\nReview comment:\n       `ASSERT_OK_AND_EQ`?\n\n##########\nFile path: cpp/src/arrow/csv/reader.cc\n##########\n@@ -150,20 +154,21 @@ struct CSVBlock {\n   std::function<Status(int64_t)> consume_bytes;\n };\n \n+// This is an unfortunate side-effect of using optional<T> as the iterator in the\n+// CSVBlock iterator.  We need to be able to compare with\n+// IterationTraits<optional<T>>::End() and empty optionals will always compare true but\n+// the optional copmarator won't compile if the underlying type isn't comparable\n\nReview comment:\n       \"comparator\"\n\n##########\nFile path: cpp/src/arrow/csv/reader.cc\n##########\n@@ -220,14 +238,36 @@ class ThreadedBlockReader : public BlockReader {\n  public:\n   using BlockReader::BlockReader;\n \n-  Result<arrow::util::optional<CSVBlock>> Next() {\n+  static Iterator<util::optional<CSVBlock>> MakeIterator(\n+      Iterator<std::shared_ptr<Buffer>> buffer_iterator, std::unique_ptr<Chunker> chunker,\n+      std::shared_ptr<Buffer> first_buffer) {\n+    auto block_reader =\n+        std::make_shared<ThreadedBlockReader>(std::move(chunker), first_buffer);\n+    // Wrap shared pointer in callable\n+    Transformer<std::shared_ptr<Buffer>, util::optional<CSVBlock>> block_reader_fn =\n+        [block_reader](std::shared_ptr<Buffer> next) { return (*block_reader)(next); };\n+    return MakeTransformedIterator(std::move(buffer_iterator), block_reader_fn);\n+  }\n+\n+  static AsyncGenerator<util::optional<CSVBlock>> MakeAsyncIterator(\n+      AsyncGenerator<std::shared_ptr<Buffer>> buffer_generator,\n+      std::unique_ptr<Chunker> chunker, std::shared_ptr<Buffer> first_buffer) {\n+    auto block_reader =\n+        std::make_shared<ThreadedBlockReader>(std::move(chunker), first_buffer);\n+    // Wrap shared pointer in callable\n+    Transformer<std::shared_ptr<Buffer>, util::optional<CSVBlock>> block_reader_fn =\n+        [block_reader](std::shared_ptr<Buffer> next) { return (*block_reader)(next); };\n+    return TransformAsyncGenerator(buffer_generator, block_reader_fn);\n\nReview comment:\n       `std::move(buffer_generator)`?\n\n##########\nFile path: cpp/src/arrow/util/iterator_test.cc\n##########\n@@ -214,6 +255,270 @@ TEST(TestVectorIterator, RangeForLoop) {\n   ASSERT_EQ(ints_it, ints.end());\n }\n \n+template <typename T>\n+Transformer<T, T> MakeFirstN(int n) {\n+  int remaining = n;\n+  return [remaining](T next) mutable -> Result<TransformFlow<T>> {\n+    if (remaining > 0) {\n+      remaining--;\n+      return TransformYield(next);\n+    }\n+    return TransformFinish();\n+  };\n+}\n+\n+TEST(TestIteratorTransform, Truncating) {\n+  auto original = VectorIt({1, 2, 3});\n+  auto truncated = MakeTransformedIterator(std::move(original), MakeFirstN<TestInt>(2));\n+  AssertIteratorMatch({1, 2}, std::move(truncated));\n+}\n+\n+TEST(TestIteratorTransform, TestPointer) {\n+  auto original = VectorIt<std::shared_ptr<int>>(\n+      {std::make_shared<int>(1), std::make_shared<int>(2), std::make_shared<int>(3)});\n+  auto truncated =\n+      MakeTransformedIterator(std::move(original), MakeFirstN<std::shared_ptr<int>>(2));\n+  ASSERT_OK_AND_ASSIGN(auto result, truncated.ToVector());\n+  ASSERT_EQ(2, result.size());\n+}\n+\n+TEST(TestIteratorTransform, TruncatingShort) {\n+  // Tests the failsafe case where we never call Finish\n+  auto original = VectorIt({1});\n+  auto truncated = MakeTransformedIterator<TestInt, TestInt>(std::move(original),\n+                                                             MakeFirstN<TestInt>(2));\n+  AssertIteratorMatch({1}, std::move(truncated));\n+}\n+\n+TEST(TestAsyncUtil, Background) {\n+  std::vector<TestInt> expected = {1, 2, 3};\n+  auto background = BackgroundAsyncVectorIt(expected);\n+  auto future = CollectAsyncGenerator(background);\n+  ASSERT_FALSE(future.is_finished());\n+  future.Wait();\n+  ASSERT_TRUE(future.is_finished());\n+  ASSERT_EQ(expected, *future.result());\n+}\n+\n+struct SlowEmptyIterator {\n+  Result<TestInt> Next() {\n+    if (called_) {\n+      return Status::Invalid(\"Should not have been called twice\");\n+    }\n+    SleepFor(0.1);\n+    return IterationTraits<TestInt>::End();\n+  }\n+\n+ private:\n+  bool called_ = false;\n+};\n+\n+TEST(TestAsyncUtil, BackgroundRepeatEnd) {\n+  // Ensure that the background iterator properly fulfills the asyncgenerator contract\n+  // and can be called after it ends.\n+  auto iterator = Iterator<TestInt>(SlowEmptyIterator());\n+  ASSERT_OK_AND_ASSIGN(\n+      auto background_iter,\n+      MakeBackgroundIterator(std::move(iterator), internal::GetCpuThreadPool()));\n+\n+  auto one = background_iter();\n+  auto two = background_iter();\n+\n+  ASSERT_TRUE(one.Wait(0.5));\n+\n+  if (one.is_finished()) {\n+    ASSERT_EQ(IterationTraits<TestInt>::End(), *one.result());\n+  }\n+\n+  ASSERT_TRUE(two.Wait(0.5));\n+  ASSERT_TRUE(two.is_finished());\n+  if (two.is_finished()) {\n+    ASSERT_EQ(IterationTraits<TestInt>::End(), *two.result());\n+  }\n+}\n+\n+TEST(TestAsyncUtil, SynchronousFinish) {\n+  AsyncGenerator<TestInt> generator = []() {\n+    return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\n+  };\n+  Transformer<TestInt, TestInt> skip_all = [](TestInt value) { return TransformSkip(); };\n+  auto transformed = TransformAsyncGenerator(generator, skip_all);\n+  auto future = CollectAsyncGenerator(transformed);\n+  ASSERT_TRUE(future.is_finished());\n+  ASSERT_OK_AND_ASSIGN(auto actual, future.result());\n+  ASSERT_EQ(std::vector<TestInt>(), actual);\n+}\n+\n+TEST(TestAsyncUtil, CompleteBackgroundStressTest) {\n+  auto expected = RangeVector(100);\n+  std::vector<Future<std::vector<TestInt>>> futures;\n+  for (unsigned int i = 0; i < 100; i++) {\n+    auto background = BackgroundAsyncVectorIt(expected);\n+    futures.push_back(CollectAsyncGenerator(background));\n+  }\n+  auto combined = All(futures);\n+  combined.Wait(2);\n+  if (combined.is_finished()) {\n+    ASSERT_OK_AND_ASSIGN(auto completed_vectors, combined.result());\n+    for (auto&& vector : completed_vectors) {\n+      ASSERT_EQ(vector, expected);\n+    }\n+  } else {\n+    FAIL() << \"After 2 seconds all background iterators had not finished collecting\";\n+  }\n+}\n+\n+TEST(TestAsyncUtil, StackOverflow) {\n+  int counter = 0;\n+  AsyncGenerator<TestInt> generator = [&counter]() {\n+    if (counter < 1000000) {\n+      return Future<TestInt>::MakeFinished(counter++);\n+    } else {\n+      return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\n+    }\n+  };\n+  Transformer<TestInt, TestInt> discard =\n+      [](TestInt next) -> Result<TransformFlow<TestInt>> { return TransformSkip(); };\n+  auto transformed = TransformAsyncGenerator(generator, discard);\n+  auto collected_future = CollectAsyncGenerator(transformed);\n+  ASSERT_TRUE(collected_future.Wait(5));\n+  if (collected_future.is_finished()) {\n+    ASSERT_OK_AND_ASSIGN(auto collected, collected_future.result());\n+    ASSERT_EQ(0, collected.size());\n+  }\n+}\n+\n+TEST(TestAsyncUtil, Visit) {\n+  auto generator = AsyncVectorIt({1, 2, 3});\n+  unsigned int sum = 0;\n+  auto sum_future = VisitAsyncGenerator<TestInt>(generator, [&sum](TestInt item) {\n+    sum += item.value;\n+    return Status::OK();\n+  });\n+  // Should be superfluous\n+  sum_future.Wait();\n+  ASSERT_EQ(6, sum);\n+}\n+\n+TEST(TestAsyncUtil, Collect) {\n+  std::vector<TestInt> expected = {1, 2, 3};\n+  auto generator = AsyncVectorIt(expected);\n+  auto collected = CollectAsyncGenerator(generator);\n+  ASSERT_EQ(expected, *collected.result());\n\nReview comment:\n       `ASSERT_OK_AND_EQ`?\n\n##########\nFile path: cpp/src/arrow/csv/reader.cc\n##########\n@@ -177,14 +182,26 @@ class SerialBlockReader : public BlockReader {\n  public:\n   using BlockReader::BlockReader;\n \n-  Result<arrow::util::optional<CSVBlock>> Next() {\n+  static Iterator<util::optional<CSVBlock>> MakeIterator(\n+      Iterator<std::shared_ptr<Buffer>> buffer_iterator, std::unique_ptr<Chunker> chunker,\n+      std::shared_ptr<Buffer> first_buffer) {\n+    auto block_reader =\n+        std::make_shared<SerialBlockReader>(std::move(chunker), first_buffer);\n+    // Wrap shared pointer in callable\n+    Transformer<std::shared_ptr<Buffer>, util::optional<CSVBlock>> block_reader_fn =\n+        [block_reader](std::shared_ptr<Buffer> buf) {\n+          return (*block_reader)(std::move(buf));\n+        };\n+    return MakeTransformedIterator(std::move(buffer_iterator), block_reader_fn);\n+  }\n+\n+  Result<TransformFlow<util::optional<CSVBlock>>> operator()(\n\nReview comment:\n       Hmm... why are we still returning `util::optional` if we never yield a value-less result?\n\n##########\nFile path: cpp/src/arrow/util/iterator.cc\n##########\n@@ -119,14 +123,30 @@ class ReadaheadQueue::Impl : public std::enable_shared_from_this<ReadaheadQueue:\n   void DoWork() {\n     std::unique_lock<std::mutex> lock(mutex_);\n     while (!please_shutdown_) {\n-      while (static_cast<int64_t>(done_.size()) < max_readahead_ && todo_.size() > 0) {\n+      while (todo_.size() > 0 &&\n+             ((max_readahead_ <= 0) ||\n+              (static_cast<int64_t>(done_.size()) < max_readahead_))) {\n         auto promise = std::move(todo_.front());\n         todo_.pop_front();\n         lock.unlock();\n-        promise->Call();\n+        if (promise->Call()) {\n+          // If the call finished then we should purge the remaining TODO items, marking\n+          // them finished\n+          lock.lock();\n+          std::deque<std::unique_ptr<ReadaheadPromise>> to_clear(std::move(todo_));\n+          // While the async iterator doesn't use todo_ anymore after it hits a finish the\n+          // sync iterator might still due to timing so leave it valid\n+          todo_.clear();\n+          lock.unlock();\n+          for (auto&& promise : to_clear) {\n+            promise->End();\n+          }\n+        }\n         lock.lock();\n-        done_.push_back(std::move(promise));\n-        work_done_.notify_one();\n+        if (max_readahead_ > 0) {\n+          done_.push_back(std::move(promise));\n+          work_done_.notify_one();\n+        }\n\nReview comment:\n       This is frankly weird. It seems the logic here is conflating \"unbounded readahead\" and \"is an async generator\".\r\n   \r\n   More generally, the fact that two different control flows (sync vs async) seem to be handled in the same implementation make things very confusing and difficult to follow. Can you find a way to separate the two cases?\r\n   \n\n##########\nFile path: cpp/src/arrow/util/iterator_test.cc\n##########\n@@ -214,6 +255,270 @@ TEST(TestVectorIterator, RangeForLoop) {\n   ASSERT_EQ(ints_it, ints.end());\n }\n \n+template <typename T>\n+Transformer<T, T> MakeFirstN(int n) {\n+  int remaining = n;\n+  return [remaining](T next) mutable -> Result<TransformFlow<T>> {\n+    if (remaining > 0) {\n+      remaining--;\n+      return TransformYield(next);\n+    }\n+    return TransformFinish();\n+  };\n+}\n+\n+TEST(TestIteratorTransform, Truncating) {\n\nReview comment:\n       (same for async generator transform tests)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-26T17:04:45.135+0000",
                    "updated": "2021-01-26T17:04:45.135+0000",
                    "started": "2021-01-26T17:04:45.135+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "542257",
                    "issueId": "13333811"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 96000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@1431465b[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@62522a27[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5063f693[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@2393edaa[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1744f0d4[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@2a93220f[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@650b9ea0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@59c9d116[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@69bb48ab[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@5a8b8cc9[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@634ce7a6[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@741acbb8[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 96000,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Feb 16 14:45:46 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-02-16T14:45:46.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10183/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2020-10-05T22:34:31.000+0000",
        "updated": "2021-02-16T14:45:53.000+0000",
        "timeoriginalestimate": null,
        "description": "This method should take in an iterator of futures and a callback and\u00a0pull an item off the iterator, \"await\" it, run the callback on it, and then fetch the next item from the iterator.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "26h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 96000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/attachment/13013189",
                "id": "13013189",
                "filename": "arrow-continuation-flow.jpg",
                "author": {
                    "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                    "name": "westonpace",
                    "key": "westonpace",
                    "avatarUrls": {
                        "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                        "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                        "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                        "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                    },
                    "displayName": "Weston Pace",
                    "active": true,
                    "timeZone": "America/Los_Angeles"
                },
                "created": "2020-10-07T11:55:27.793+0000",
                "size": 78235,
                "mimeType": "image/jpeg",
                "content": "https://issues.apache.org/jira/secure/attachment/13013189/arrow-continuation-flow.jpg"
            }
        ],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Create a ForEach library function that runs on an iterator of futures",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/comment/17208626",
                    "id": "17208626",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "So it's spawning a dedicated thread pool? Is there a desired use case for this feature?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2020-10-06T10:01:25.839+0000",
                    "updated": "2020-10-06T10:01:25.839+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/comment/17209101",
                    "id": "17209101",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Not spawning a thread pool, it would take a thread pool as an argument.\u00a0 The current use case I'm looking at is the CSV reader.\r\n\r\nThe current implementation is:\r\n * One thread (outside the thread pool, let's call it the I/O thread) reads from an input stream, up to X blocks in advance, and places the blocks in a blocking queue.\r\n * Another thread (calling thread, may be a thread pool thread, let's call it the parse thread) takes blocks off of the blocking queue (which it sees as an iterator) and creates thread pool tasks for conversion.\u00a0 This step will block if I/O is slow.\r\n * The thread pool threads (conversion tasks) then do the conversion, possibly making new conversion tasks which are added to the thread pool.\r\n * Once the parsing thread is done reading the iterator it blocks until the conversion tasks have finished.\r\n\r\nThe goal is to change the parsing thread so it is no longer blocking, as it may be a thread pool thread, and if it is blocking it shouldn't tie up the thread.\u00a0 I can keep the dedicated I/O thread since it is outside the thread pool.\r\n\r\nThis changes the I/O thread from an iterator of Block to an iterator of Future<Block>.\r\n\r\nConverting the parse thread is a little trickier.\u00a0 It currently is...\r\n\r\n{{\u00a0 \u00a0 iterator = StartIterator();}}\r\n\r\n{{\u00a0 \u00a0 for each block in iterator:}}\r\n\r\n{{\u00a0 \u00a0 \u00a0 \u00a0\u00a0}}{{ParseBlockAndCreateConversionTasks();}}\r\n\r\n{{\u00a0 \u00a0 WaitForConversionTasks();}}\r\n\r\nThe \"for each\" part is a little trickier with a generator that returns promises.\u00a0 This task is aiming to replace that bit.\r\n\r\nNow that I think it all through like this I suppose the \"parallel for each\" and \"N threads\" wording is not needed.\u00a0 This is a natural point to allow for concurrency (e.g. allowing up to N parse threads).\u00a0 However, the original implementation had only the single parse thread so I don't need to introduce it here.\u00a0 I'll go ahead and strip that from the task and start with just a basic serial for each.\u00a0 Even with a serial for-each there is a need for a common library function that, given an iterator of futures, and a function, applies the function to each of the items in the iterator.\r\n\r\n\u00a0",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2020-10-06T19:47:13.533+0000",
                    "updated": "2020-10-06T19:47:13.533+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/comment/17209104",
                    "id": "17209104",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "This is also a bit of a mental investigation on my part to be sure this can be done without exploding the stack.\u00a0 Since this is essentially iterator.next().then(iterator.next().then(iterator.next().then(...\u00a0 My understanding is that it can, and there are numerous articles on continuations and avoiding stack busting while doing this kind of thing.\u00a0 I have yet to synthesize all that knowledge and put it into practice.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2020-10-06T19:50:33.217+0000",
                    "updated": "2020-10-06T19:50:33.217+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/comment/17209110",
                    "id": "17209110",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Just for the record, we already have a {{AsCompleted}} iterator. We could have a variant that takes an iterator of futures rather than a vector of futures.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2020-10-06T20:01:05.686+0000",
                    "updated": "2020-10-06T20:01:05.686+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/comment/17209498",
                    "id": "17209498",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "I had not quite come across that class so I appreciate the mention.\u00a0 It will not satisfy in this case though.\u00a0 There is a back pressure problem that is difficult to explain but will make more sense in code.\r\n\r\nMore significantly though, the AsCompletedIterator still does waits, which is what I'm trying to avoid.\u00a0 I'm attaching a diagram to this sub task that will hopefully provide a bit more explanation.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2020-10-07T11:55:12.125+0000",
                    "updated": "2020-10-07T11:55:12.125+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/comment/17265168",
                    "id": "17265168",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Latest round of benchmarks (5 iterations on each)\r\n       |\u00a0|2.0.0 (Mean)|2.0.0 (StdDev)|Async (Mean)|Async (StdDev)|Async (Tasks)|Threaded (Mean)|Threaded (StdDev)|Threaded (Tasks)|\r\n|gzip/cache|6.291222|0.095669|6.467804|0.035468|6229|6.262252|0.056097|4149|\r\n|gzip/none|9.292271|0.251346|9.494446|0.273585|6229|9.22652|0.254951|4149|\r\n|none/cache|1.226155|0.086003|1.245934|0.077262|6229|1.238495|0.073567|4149|\r\n|none/none|34.326746|0.392563|35.091284|0.833403|6222|36.270428|2.033464|4149|\r\n\r\ngzip means the source file was compressed with gzip and cache means the source file was cached in the OS cache.\u00a0 For cache=None the benchmark is high.\u00a0 We have to make a file copy to ensure we are reading from the disk and this copy time is included in the benchmark.\u00a0 However, this overhead is consistent.\r\n\r\nThe 2.0.0 numbers come from using the conda pyarrow (and thus the threaded table reader).\r\n\r\nResults are fairly noisy but I think there is some consistent minor degredation in the async case.\u00a0 It could be a result of there being a higher number of tasks, the high number of futures, using submit instead of spawn, or could just be noise.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2021-01-14T19:44:45.509+0000",
                    "updated": "2021-01-14T19:44:45.509+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/comment/17266471",
                    "id": "17266471",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Some good news.\u00a0 I figured out my CSV reading benchmark was flawed (had the wrong separator).\u00a0 New results...\r\n|\u00a0|2.0.0 (Mean)|2.0.0 (StdDev)|Async (Mean)|Async (StdDev)|\r\n|gzip/cache|6.62|0.12|6.70|0.16|\r\n|gzip/none|9.89|0.43|9.06|0.21|\r\n|none/cache|4.05|0.09|3.95|0.11|\r\n|none/none|34.57|1.15|32.25|1.22|\r\n\r\nI also realized at least one possible situation where the async reader could fall behind the threaded reader.\u00a0 If the I/O is running slower (e.g. zip case) then sometimes the parse task will find the I/O promise unfulfilled (finished parsing but next decompressed block not ready).\u00a0 In the threaded case the outer parsing thread will block here while in the async case a new task will get added to the pool to run when the I/O finishes.\u00a0 That task will get added in the pool *behind* all the conversion tasks.\u00a0 So then the parsing will be delayed and it is possible the readahead queue will fill up, delaying the I/O.\r\n\r\n\u00a0\r\n\r\nThe timing has to be just right so that parsing & I/O are similar in performance.\u00a0 The I/O has to be slow enough to sometimes not be ready but not so slow that the task pool completely drains between each block.\r\n\r\n\u00a0\r\n\r\nI've tested the gzip/cache case quite often and this is the only case where the async version consistently unperformed.\u00a0 I think the I/O in the */none cases are too slow and the I/O in the none/cache case is too fast.\r\n\r\n\u00a0\r\n\r\nA prioritized thread queue would allow working around this situation.\u00a0 The conversion tasks should be marked lower priority than the parsing tasks.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2021-01-16T01:47:32.354+0000",
                    "updated": "2021-01-16T01:47:32.354+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/comment/17272684",
                    "id": "17272684",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "[~apitrou] [~bkietz] I wanted to add a note about the parallelism of the AsyncGenerator.\u00a0 This is not so much a question as it is an update on my brain trying to wrap my head around all of this.\u00a0 I will confess that I have not yet fully internalized all of what can go on.\u00a0 For the purposes of discussion I will consider a chain (graph where each node has 1 or 2 edges and there are no cycles) of async generators, each node in the chain mutates the stream in some way.\u00a0 For example, in the CSV case there is the original Buffer generator (a background generator), the CSV block reader, the chunker, and then the \"parse & convert scheduler\" (a Visitor which terminates the chain).\u00a0 The \"fan-out\" in the CSV is still delegated to the task group so that parallelism need hasn't been fully explored, although it could remain a chain (I think).\r\n\r\nAn AsyncGenerator's Next() function should never have to be called by more than one thread at once in the way you might do with an iterator.\u00a0 Instead, the question comes down to whether you can call a generator's Next() function before the promise returned by the previous call has completed.\u00a0 It is similar and different.\u00a0 So it's not so much a question of \"thread safe\" as it is a question of \"reentrant\".\r\n\r\nAsyncGenerators come in both flavors.\u00a0 A decompressing node (or the CSV block reader and the CSV chunker) are all quite stateful and must finish processing a block before they can begin consuming the next.\u00a0 So you should not call Next() until the future returned is resolved.\u00a0 The parsing and converting on the other hand is free to run in parallel.\u00a0 In addition, any queuing stage (AddReadahead and BackgroundIterator) can be called in parallel, thus allowing for pipeline parallelism.\u00a0 Since everything is pull driven this \"parallel pull\" is driven from the AddReadahead nodes and could be driven from a \"visit\" or \"collect\" sink as well.\r\n\r\nSo just summarizing what we have today...\r\n\r\nSources:\r\nBackgroundGenerator - Reentrant, Does not pull\r\n\r\nIntermediate Nodes:\r\nTransformer - Not reentrant (by necessity of has_next), Does not pull\r\nAddReadahead - Reentrant, Pulls reentrantly\r\n\r\nSinks:\r\nVisit - Pulls serially (could be reentrantly in the future)\r\nCollect - Pulls serially (could be reentrantly in the future)\r\n\r\nToday we have...\r\n\r\nBackgroundGenerator -> AddReadahead -> Transformer -> Transformer -> Visit(1)\r\n\r\nIt would be an error for example to do...\r\n\r\nBackgroundGenerator -> AddReadahead -> Transformer -> Transformer -> Visit(N)\r\n\r\n...or...\r\n\r\nBackgroundGenerator -> AddReadahead -> Transformer -> Transformer -> AddReadahead -> Visit(1)\r\n\r\n...both of those would cause Transformer (which is not reentrant) to be pulled reentrantly.\u00a0 I am wondering if there is some merit in encoding these rules somehow into the types themselves so that something like that would fail to compile.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2021-01-27T08:43:33.617+0000",
                    "updated": "2021-01-27T08:43:33.617+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/comment/17272696",
                    "id": "17272696",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "As maybe more food for though one could consider a classic map-reduce style summation task.\u00a0 A buffer comes in with 1024 elements, it is split into 8 sum tasks of 128 and then reduced with 7 reduce tasks.\u00a0 This \"fan-out\" could be implemented as a fully reentrant pipeline...\r\n\r\nMapper (Just a flatMap, fits Transformer model, but should be able to be made reentrant, emits 8 times for each input)\r\n Summer (Takes in a buffer and computes the sum, fits transformer model, but should be reentrant)\r\n Reducer (Consumes two numbers and outputs the sum, would NOT fit transformer model (even with skip), curiously though it should also be reentrant)\r\n\r\nAll of these could be \"transformers\" but the existing transform model would make them non-reentrant.\u00a0 However, all of them \"should\" be able to be reentrant.\u00a0 I think this argues somewhat to gaps in the transformer model.\u00a0 I have an improved model in mind, but it is was not compatible with synchronous iterators so I abandoned it.\u00a0 I may have to revisit.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2021-01-27T09:00:27.838+0000",
                    "updated": "2021-01-27T09:01:20.419+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333811/comment/17285235",
                    "id": "17285235",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 9095\n[https://github.com/apache/arrow/pull/9095]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-02-16T14:45:46.335+0000",
                    "updated": "2021-02-16T14:45:46.335+0000"
                }
            ],
            "maxResults": 10,
            "total": 10,
            "startAt": 0
        },
        "customfield_12311820": "0|z0jfpk:",
        "customfield_12314139": null
    }
}