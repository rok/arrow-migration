{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13425500",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13425500",
    "key": "ARROW-15498",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351550",
                "id": "12351550",
                "name": "9.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-08-03"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12632388",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12632388",
                "type": {
                    "id": "10032",
                    "name": "Blocker",
                    "inward": "is blocked by",
                    "outward": "blocks",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10032"
                },
                "inwardIssue": {
                    "id": "13420467",
                    "key": "ARROW-15239",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420467",
                    "fields": {
                        "summary": "[C++][Compute] Introduce Bloom filters to hash join",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12632387",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12632387",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "inwardIssue": {
                    "id": "13376404",
                    "key": "ARROW-12633",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376404",
                    "fields": {
                        "summary": "[C++] Query engine umbrella issue",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=sakras",
            "name": "sakras",
            "key": "sakras",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Sasha Krassovsky",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=sakras",
            "name": "sakras",
            "key": "sakras",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Sasha Krassovsky",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=sakras",
            "name": "sakras",
            "key": "sakras",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Sasha Krassovsky",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 18600,
            "total": 18600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 18600,
            "total": 18600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15498/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 31,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13425500/worklog/717363",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #12289:\nURL: https://github.com/apache/arrow/pull/12289#issuecomment-1024738476\n\n\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-28T23:26:31.438+0000",
                    "updated": "2022-01-28T23:26:31.438+0000",
                    "started": "2022-01-28T23:26:31.437+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "717363",
                    "issueId": "13425500"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13425500/worklog/762440",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #12289:\nURL: https://github.com/apache/arrow/pull/12289#discussion_r858853024\n\n\n##########\ncpp/src/arrow/compute/exec/bloom_filter.cc:\n##########\n@@ -114,7 +114,7 @@ Status BlockedBloomFilter::CreateEmpty(int64_t num_rows_to_insert, MemoryPool* p\n }\n \n template <typename T>\n-void BlockedBloomFilter::InsertImp(int64_t num_rows, const T* hashes) {\n+NO_TSAN void BlockedBloomFilter::InsertImp(int64_t num_rows, const T* hashes) {\n\nReview Comment:\n   Is this still needed after we fixed other TSAN related issues?\n\n\n\n##########\ncpp/src/arrow/compute/exec/partition_util.h:\n##########\n@@ -59,14 +60,14 @@ class PartitionSort {\n   /// out_arr: [2, 5, 3, 5, 4, 7]\n   /// prtn_ranges: [0, 1, 5, 6]\n   template <class INPUT_PRTN_ID_FN, class OUTPUT_POS_FN>\n-  static void Eval(int num_rows, int num_prtns, uint16_t* prtn_ranges,\n+  static void Eval(int64_t num_rows, int num_prtns, uint16_t* prtn_ranges,\n\nReview Comment:\n   Why promote this to `int64_t` if we are going to assert it is less than `1 << 15`?\n\n\n\n##########\ncpp/src/arrow/compute/exec/bloom_filter_test.cc:\n##########\n@@ -32,39 +33,107 @@\n namespace arrow {\n namespace compute {\n \n-Status BuildBloomFilter(BloomFilterBuildStrategy strategy, int64_t hardware_flags,\n-                        MemoryPool* pool, int64_t num_rows,\n-                        std::function<void(int64_t, int, uint32_t*)> get_hash32_impl,\n-                        std::function<void(int64_t, int, uint64_t*)> get_hash64_impl,\n-                        BlockedBloomFilter* target) {\n-  constexpr int batch_size_max = 32 * 1024;\n-  int64_t num_batches = bit_util::CeilDiv(num_rows, batch_size_max);\n-\n-  auto builder = BloomFilterBuilder::Make(strategy);\n-\n-  std::vector<uint32_t> thread_local_hashes32;\n-  std::vector<uint64_t> thread_local_hashes64;\n-  thread_local_hashes32.resize(batch_size_max);\n-  thread_local_hashes64.resize(batch_size_max);\n-\n-  RETURN_NOT_OK(builder->Begin(/*num_threads=*/1, hardware_flags, pool, num_rows,\n-                               bit_util::CeilDiv(num_rows, batch_size_max), target));\n-\n-  for (int64_t i = 0; i < num_batches; ++i) {\n+constexpr int kBatchSizeMax = 32 * 1024;\n+Status BuildBloomFilter_Serial(\n+    std::unique_ptr<BloomFilterBuilder>& builder, int64_t num_rows, int64_t num_batches,\n+    std::function<void(int64_t, int, uint32_t*)> get_hash32_impl,\n+    std::function<void(int64_t, int, uint64_t*)> get_hash64_impl,\n+    BlockedBloomFilter* target) {\n+  std::vector<uint32_t> hashes32(kBatchSizeMax);\n+  std::vector<uint64_t> hashes64(kBatchSizeMax);\n+  for (int64_t i = 0; i < num_batches; i++) {\n     size_t thread_index = 0;\n     int batch_size = static_cast<int>(\n-        std::min(num_rows - i * batch_size_max, static_cast<int64_t>(batch_size_max)));\n+        std::min(num_rows - i * kBatchSizeMax, static_cast<int64_t>(kBatchSizeMax)));\n     if (target->NumHashBitsUsed() > 32) {\n-      uint64_t* hashes = thread_local_hashes64.data();\n-      get_hash64_impl(i * batch_size_max, batch_size, hashes);\n+      uint64_t* hashes = hashes64.data();\n+      get_hash64_impl(i * kBatchSizeMax, batch_size, hashes);\n       RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n     } else {\n-      uint32_t* hashes = thread_local_hashes32.data();\n-      get_hash32_impl(i * batch_size_max, batch_size, hashes);\n+      uint32_t* hashes = hashes32.data();\n+      get_hash32_impl(i * kBatchSizeMax, batch_size, hashes);\n       RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n     }\n   }\n+  return Status::OK();\n+}\n+\n+Status BuildBloomFilter_Parallel(\n+    std::unique_ptr<BloomFilterBuilder>& builder, size_t num_threads, int64_t num_rows,\n+    int64_t num_batches, std::function<void(int64_t, int, uint32_t*)> get_hash32_impl,\n+    std::function<void(int64_t, int, uint64_t*)> get_hash64_impl,\n+    BlockedBloomFilter* target) {\n+  std::mutex mutex;\n+  ThreadIndexer thread_indexer;\n+  std::unique_ptr<TaskScheduler> scheduler = TaskScheduler::Make();\n+  std::vector<std::vector<uint32_t>> thread_local_hashes32(num_threads);\n+  std::vector<std::vector<uint64_t>> thread_local_hashes64(num_threads);\n+  for (std::vector<uint32_t>& h : thread_local_hashes32) h.resize(kBatchSizeMax);\n+  for (std::vector<uint64_t>& h : thread_local_hashes64) h.resize(kBatchSizeMax);\n+\n+  std::condition_variable cv;\n+  std::unique_lock<std::mutex> lk(mutex, std::defer_lock);\n+  auto group = scheduler->RegisterTaskGroup(\n+      [&](size_t thread_index, int64_t task_id) -> Status {\n+        int batch_size = static_cast<int>(std::min(num_rows - task_id * kBatchSizeMax,\n+                                                   static_cast<int64_t>(kBatchSizeMax)));\n+        if (target->NumHashBitsUsed() > 32) {\n+          uint64_t* hashes = thread_local_hashes64[thread_index].data();\n+          get_hash64_impl(task_id * kBatchSizeMax, batch_size, hashes);\n+          RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n+        } else {\n+          uint32_t* hashes = thread_local_hashes32[thread_index].data();\n+          get_hash32_impl(task_id * kBatchSizeMax, batch_size, hashes);\n+          RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n+        }\n+        return Status::OK();\n+      },\n+      [&](size_t thread_index) -> Status {\n+        lk.unlock();\n+        cv.notify_one();\n+        return Status::OK();\n+      });\n+  scheduler->RegisterEnd();\n+  auto tp = arrow::internal::GetCpuThreadPool();\n+  RETURN_NOT_OK(scheduler->StartScheduling(\n+      0,\n+      [&](std::function<Status(size_t)> func) -> Status {\n+        return tp->Spawn([&, func] {\n+          size_t tid = thread_indexer();\n+          std::ignore = func(tid);\n\nReview Comment:\n   Why ignore it?  Return it if it isn't ok.\n\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join_node_test.cc:\n##########\n@@ -1900,5 +1903,150 @@ TEST(HashJoin, TrivialResidualFilter) {\n   }\n }\n \n+HashJoinNodeOptions GenerateHashJoinNodeOptions(Random64Bit& rng, int num_left_cols,\n+                                                int num_right_cols) {\n+  HashJoinNodeOptions opts;\n+  opts.join_type = static_cast<JoinType>(rng.from_range(0, 7));\n+  bool is_left_join = opts.join_type == JoinType::LEFT_SEMI ||\n+                      opts.join_type == JoinType::LEFT_ANTI ||\n+                      opts.join_type == JoinType::LEFT_OUTER;\n+  bool is_right_join = opts.join_type == JoinType::RIGHT_SEMI ||\n+                       opts.join_type == JoinType::RIGHT_ANTI ||\n+                       opts.join_type == JoinType::RIGHT_OUTER;\n+\n+  int num_keys = rng.from_range(1, std::min(num_left_cols, num_right_cols));\n+  for (int i = 0; i < num_left_cols; i++) {\n+    bool is_out = rng.from_range(0, 2) != 2;\n+    if (is_out && !is_right_join) opts.left_output.push_back(FieldRef(i));\n+  }\n+  for (int i = 0; i < num_right_cols; i++) {\n+    bool is_out = rng.from_range(0, 2) == 2;\n+    if (is_out && !is_left_join) opts.right_output.push_back(FieldRef(i));\n+  }\n+  // We need at least one output\n+  if (opts.right_output.empty() && opts.left_output.empty()) {\n+    if (is_left_join) {\n+      int col = rng.from_range(0, num_left_cols - 1);\n+      opts.left_output.push_back(FieldRef(col));\n+    } else if (is_right_join) {\n+      int col = rng.from_range(0, num_right_cols - 1);\n+      opts.right_output.push_back(FieldRef(col));\n+    } else {\n+      if (rng.from_range(0, 1) == 0) {\n+        int col = rng.from_range(0, num_left_cols - 1);\n+        opts.left_output.push_back(FieldRef(col));\n+      } else {\n+        int col = rng.from_range(0, num_right_cols - 1);\n+        opts.right_output.push_back(FieldRef(col));\n+      }\n+    }\n+  }\n+\n+  for (int i = 0; i < num_keys; i++) {\n+    int left = rng.from_range(0, num_left_cols - 1);\n+    int right = rng.from_range(0, num_right_cols - 1);\n+    bool is_or_eq = rng.from_range(0, 1) == 0;\n+    opts.left_keys.push_back(FieldRef(left));\n+    opts.right_keys.push_back(FieldRef(right));\n+    opts.key_cmp.push_back(is_or_eq ? JoinKeyCmp::IS : JoinKeyCmp::EQ);\n+  }\n+  return opts;\n+}\n+\n+void TestSingleChainOfHashJoins(Random64Bit& rng) {\n+  int num_joins = rng.from_range(2, 5);\n+  std::vector<HashJoinNodeOptions> opts;\n+  int num_left_cols = rng.from_range(1, 8);\n+  int num_right_cols = rng.from_range(1, 8);\n+  HashJoinNodeOptions first_opt =\n+      GenerateHashJoinNodeOptions(rng, num_left_cols, num_right_cols);\n+  opts.push_back(std::move(first_opt));\n+\n+  std::unordered_map<std::string, std::string> metadata_map;\n+  metadata_map[\"min\"] = \"0\";\n+  metadata_map[\"max\"] = \"10\";\n+  auto metadata = key_value_metadata(metadata_map);\n+  std::vector<std::shared_ptr<Field>> left_fields;\n+  for (int i = 0; i < num_left_cols; i++)\n+    left_fields.push_back(field(std::string(\"l\") + std::to_string(i), int32(), metadata));\n+  std::vector<std::shared_ptr<Field>> first_right_fields;\n+  for (int i = 0; i < num_right_cols; i++)\n+    first_right_fields.push_back(\n+        field(std::string(\"r_0_\") + std::to_string(i), int32(), metadata));\n+\n+  BatchesWithSchema input_left = MakeRandomBatches(schema(std::move(left_fields)));\n+  std::vector<BatchesWithSchema> input_right;\n+  input_right.push_back(MakeRandomBatches(schema(std::move(first_right_fields))));\n+\n+  for (int i = 1; i < num_joins; i++) {\n+    int num_right_cols = rng.from_range(1, 8);\n+    HashJoinNodeOptions opt =\n+        GenerateHashJoinNodeOptions(rng,\n+                                    static_cast<int>(opts[i - 1].left_output.size() +\n+                                                     opts[i - 1].right_output.size()),\n+                                    num_right_cols);\n+    opts.push_back(std::move(opt));\n+\n+    std::vector<std::shared_ptr<Field>> right_fields;\n+    for (int j = 0; j < num_right_cols; j++)\n+      right_fields.push_back(\n+          field(std::string(\"r_\") + std::to_string(i) + \"_\" + std::to_string(j), int32(),\n+                metadata));\n+    BatchesWithSchema input = MakeRandomBatches(schema(std::move(right_fields)));\n+    input_right.push_back(std::move(input));\n+  }\n+\n+  std::vector<ExecBatch> reference;\n+  for (bool bloom_filters : {false, true}) {\n+    bool parallel = true;\n\nReview Comment:\n   ```suggestion\r\n       constexpr bool kParallel = true;\r\n   ```\r\n   Is this variable for readability?  If so, making it a constant will make that obvious.  Or was there originally a for loop loop here and should it come back?\n\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join.cc:\n##########\n@@ -83,50 +85,75 @@ class HashJoinBasicImpl : public HashJoinImpl {\n   }\n \n   Status Init(ExecContext* ctx, JoinType join_type, bool use_sync_execution,\n-              size_t num_threads, HashJoinSchema* schema_mgr,\n+              size_t /*num_threads*/, HashJoinSchema* schema_mgr,\n               std::vector<JoinKeyCmp> key_cmp, Expression filter,\n               OutputBatchCallback output_batch_callback,\n               FinishedCallback finished_callback,\n-              TaskScheduler::ScheduleImpl schedule_task_callback) override {\n-    num_threads = std::max(num_threads, static_cast<size_t>(1));\n+              TaskScheduler::ScheduleImpl schedule_task_callback,\n+              HashJoinImpl* pushdown_target, std::vector<int> column_map) override {\n+    // TODO(ARROW-15732)\n+    // Each side of join might have an IO thread being called from.\n+    // As of right now, we ignore the `num_threads` argument, so later we will have to\n+    // readd `num_threads_ = num_threads;`\n+    num_threads_ = GetCpuThreadPoolCapacity() + io::GetIOThreadPoolCapacity() + 1;\n+    // num_threads_ = GetCpuThreadPoolCapacity() + 1;\n\nReview Comment:\n   ```suggestion\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join_benchmark.cc:\n##########\n@@ -126,6 +129,22 @@ class JoinBenchmark {\n \n     join_ = *HashJoinImpl::MakeBasic();\n \n+    HashJoinImpl* bloom_filter_pushdown_target = nullptr;\n+    std::vector<int> key_input_map;\n+\n+    bool bloom_filter_does_not_apply_to_join =\n\nReview Comment:\n   So is the idea here to measure the overhead cost of building the bloom filter?\n\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join_node.cc:\n##########\n@@ -571,24 +573,82 @@ class HashJoinNode : public ExecNode {\n     }\n   }\n \n-  Status StartProducing() override {\n-    START_SPAN(span_, std::string(kind_name()) + \":\" + label(),\n-               {{\"node.label\", label()},\n-                {\"node.detail\", ToString()},\n-                {\"node.kind\", kind_name()}});\n-    END_SPAN_ON_FUTURE_COMPLETION(span_, finished(), this);\n+  std::pair<HashJoinImpl*, std::vector<int>> GetPushdownTarget() {\n\nReview Comment:\n   Since we operate on these pairs everywhere why not create:\r\n   ```\r\n   struct BloomFilterTarget {\r\n     HashJoinImpl* join_impl;\r\n     std::vector<int> column_map;\r\n   };\r\n   ```\r\n   \r\n   It's also takes a bit of reading to figure out what the purpose of `column_map` is so this could be a place to briefly describe that.\n\n\n\n##########\ncpp/src/arrow/compute/exec/bloom_filter_test.cc:\n##########\n@@ -32,39 +33,107 @@\n namespace arrow {\n namespace compute {\n \n-Status BuildBloomFilter(BloomFilterBuildStrategy strategy, int64_t hardware_flags,\n-                        MemoryPool* pool, int64_t num_rows,\n-                        std::function<void(int64_t, int, uint32_t*)> get_hash32_impl,\n-                        std::function<void(int64_t, int, uint64_t*)> get_hash64_impl,\n-                        BlockedBloomFilter* target) {\n-  constexpr int batch_size_max = 32 * 1024;\n-  int64_t num_batches = bit_util::CeilDiv(num_rows, batch_size_max);\n-\n-  auto builder = BloomFilterBuilder::Make(strategy);\n-\n-  std::vector<uint32_t> thread_local_hashes32;\n-  std::vector<uint64_t> thread_local_hashes64;\n-  thread_local_hashes32.resize(batch_size_max);\n-  thread_local_hashes64.resize(batch_size_max);\n-\n-  RETURN_NOT_OK(builder->Begin(/*num_threads=*/1, hardware_flags, pool, num_rows,\n-                               bit_util::CeilDiv(num_rows, batch_size_max), target));\n-\n-  for (int64_t i = 0; i < num_batches; ++i) {\n+constexpr int kBatchSizeMax = 32 * 1024;\n+Status BuildBloomFilter_Serial(\n+    std::unique_ptr<BloomFilterBuilder>& builder, int64_t num_rows, int64_t num_batches,\n+    std::function<void(int64_t, int, uint32_t*)> get_hash32_impl,\n+    std::function<void(int64_t, int, uint64_t*)> get_hash64_impl,\n+    BlockedBloomFilter* target) {\n+  std::vector<uint32_t> hashes32(kBatchSizeMax);\n+  std::vector<uint64_t> hashes64(kBatchSizeMax);\n+  for (int64_t i = 0; i < num_batches; i++) {\n     size_t thread_index = 0;\n     int batch_size = static_cast<int>(\n-        std::min(num_rows - i * batch_size_max, static_cast<int64_t>(batch_size_max)));\n+        std::min(num_rows - i * kBatchSizeMax, static_cast<int64_t>(kBatchSizeMax)));\n     if (target->NumHashBitsUsed() > 32) {\n-      uint64_t* hashes = thread_local_hashes64.data();\n-      get_hash64_impl(i * batch_size_max, batch_size, hashes);\n+      uint64_t* hashes = hashes64.data();\n+      get_hash64_impl(i * kBatchSizeMax, batch_size, hashes);\n       RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n     } else {\n-      uint32_t* hashes = thread_local_hashes32.data();\n-      get_hash32_impl(i * batch_size_max, batch_size, hashes);\n+      uint32_t* hashes = hashes32.data();\n+      get_hash32_impl(i * kBatchSizeMax, batch_size, hashes);\n       RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n     }\n   }\n+  return Status::OK();\n+}\n+\n+Status BuildBloomFilter_Parallel(\n+    std::unique_ptr<BloomFilterBuilder>& builder, size_t num_threads, int64_t num_rows,\n+    int64_t num_batches, std::function<void(int64_t, int, uint32_t*)> get_hash32_impl,\n+    std::function<void(int64_t, int, uint64_t*)> get_hash64_impl,\n+    BlockedBloomFilter* target) {\n+  std::mutex mutex;\n+  ThreadIndexer thread_indexer;\n+  std::unique_ptr<TaskScheduler> scheduler = TaskScheduler::Make();\n+  std::vector<std::vector<uint32_t>> thread_local_hashes32(num_threads);\n+  std::vector<std::vector<uint64_t>> thread_local_hashes64(num_threads);\n+  for (std::vector<uint32_t>& h : thread_local_hashes32) h.resize(kBatchSizeMax);\n+  for (std::vector<uint64_t>& h : thread_local_hashes64) h.resize(kBatchSizeMax);\n+\n+  std::condition_variable cv;\n+  std::unique_lock<std::mutex> lk(mutex, std::defer_lock);\n+  auto group = scheduler->RegisterTaskGroup(\n+      [&](size_t thread_index, int64_t task_id) -> Status {\n+        int batch_size = static_cast<int>(std::min(num_rows - task_id * kBatchSizeMax,\n+                                                   static_cast<int64_t>(kBatchSizeMax)));\n+        if (target->NumHashBitsUsed() > 32) {\n+          uint64_t* hashes = thread_local_hashes64[thread_index].data();\n+          get_hash64_impl(task_id * kBatchSizeMax, batch_size, hashes);\n+          RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n+        } else {\n+          uint32_t* hashes = thread_local_hashes32[thread_index].data();\n+          get_hash32_impl(task_id * kBatchSizeMax, batch_size, hashes);\n+          RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n+        }\n+        return Status::OK();\n+      },\n+      [&](size_t thread_index) -> Status {\n+        lk.unlock();\n+        cv.notify_one();\n+        return Status::OK();\n+      });\n+  scheduler->RegisterEnd();\n+  auto tp = arrow::internal::GetCpuThreadPool();\n+  RETURN_NOT_OK(scheduler->StartScheduling(\n+      0,\n+      [&](std::function<Status(size_t)> func) -> Status {\n+        return tp->Spawn([&, func] {\n+          size_t tid = thread_indexer();\n+          std::ignore = func(tid);\n+        });\n+      },\n+      static_cast<int>(2 * num_threads), false));\n\nReview Comment:\n   Why 2x?\n\n\n\n##########\ncpp/src/arrow/compute/exec/bloom_filter_test.cc:\n##########\n@@ -32,39 +33,107 @@\n namespace arrow {\n namespace compute {\n \n-Status BuildBloomFilter(BloomFilterBuildStrategy strategy, int64_t hardware_flags,\n-                        MemoryPool* pool, int64_t num_rows,\n-                        std::function<void(int64_t, int, uint32_t*)> get_hash32_impl,\n-                        std::function<void(int64_t, int, uint64_t*)> get_hash64_impl,\n-                        BlockedBloomFilter* target) {\n-  constexpr int batch_size_max = 32 * 1024;\n-  int64_t num_batches = bit_util::CeilDiv(num_rows, batch_size_max);\n-\n-  auto builder = BloomFilterBuilder::Make(strategy);\n-\n-  std::vector<uint32_t> thread_local_hashes32;\n-  std::vector<uint64_t> thread_local_hashes64;\n-  thread_local_hashes32.resize(batch_size_max);\n-  thread_local_hashes64.resize(batch_size_max);\n-\n-  RETURN_NOT_OK(builder->Begin(/*num_threads=*/1, hardware_flags, pool, num_rows,\n-                               bit_util::CeilDiv(num_rows, batch_size_max), target));\n-\n-  for (int64_t i = 0; i < num_batches; ++i) {\n+constexpr int kBatchSizeMax = 32 * 1024;\n+Status BuildBloomFilter_Serial(\n+    std::unique_ptr<BloomFilterBuilder>& builder, int64_t num_rows, int64_t num_batches,\n+    std::function<void(int64_t, int, uint32_t*)> get_hash32_impl,\n+    std::function<void(int64_t, int, uint64_t*)> get_hash64_impl,\n+    BlockedBloomFilter* target) {\n+  std::vector<uint32_t> hashes32(kBatchSizeMax);\n+  std::vector<uint64_t> hashes64(kBatchSizeMax);\n+  for (int64_t i = 0; i < num_batches; i++) {\n     size_t thread_index = 0;\n     int batch_size = static_cast<int>(\n-        std::min(num_rows - i * batch_size_max, static_cast<int64_t>(batch_size_max)));\n+        std::min(num_rows - i * kBatchSizeMax, static_cast<int64_t>(kBatchSizeMax)));\n     if (target->NumHashBitsUsed() > 32) {\n-      uint64_t* hashes = thread_local_hashes64.data();\n-      get_hash64_impl(i * batch_size_max, batch_size, hashes);\n+      uint64_t* hashes = hashes64.data();\n+      get_hash64_impl(i * kBatchSizeMax, batch_size, hashes);\n       RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n     } else {\n-      uint32_t* hashes = thread_local_hashes32.data();\n-      get_hash32_impl(i * batch_size_max, batch_size, hashes);\n+      uint32_t* hashes = hashes32.data();\n+      get_hash32_impl(i * kBatchSizeMax, batch_size, hashes);\n       RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n     }\n   }\n+  return Status::OK();\n+}\n+\n+Status BuildBloomFilter_Parallel(\n+    std::unique_ptr<BloomFilterBuilder>& builder, size_t num_threads, int64_t num_rows,\n+    int64_t num_batches, std::function<void(int64_t, int, uint32_t*)> get_hash32_impl,\n+    std::function<void(int64_t, int, uint64_t*)> get_hash64_impl,\n+    BlockedBloomFilter* target) {\n+  std::mutex mutex;\n+  ThreadIndexer thread_indexer;\n+  std::unique_ptr<TaskScheduler> scheduler = TaskScheduler::Make();\n+  std::vector<std::vector<uint32_t>> thread_local_hashes32(num_threads);\n+  std::vector<std::vector<uint64_t>> thread_local_hashes64(num_threads);\n+  for (std::vector<uint32_t>& h : thread_local_hashes32) h.resize(kBatchSizeMax);\n+  for (std::vector<uint64_t>& h : thread_local_hashes64) h.resize(kBatchSizeMax);\n+\n+  std::condition_variable cv;\n+  std::unique_lock<std::mutex> lk(mutex, std::defer_lock);\n+  auto group = scheduler->RegisterTaskGroup(\n+      [&](size_t thread_index, int64_t task_id) -> Status {\n+        int batch_size = static_cast<int>(std::min(num_rows - task_id * kBatchSizeMax,\n+                                                   static_cast<int64_t>(kBatchSizeMax)));\n+        if (target->NumHashBitsUsed() > 32) {\n+          uint64_t* hashes = thread_local_hashes64[thread_index].data();\n+          get_hash64_impl(task_id * kBatchSizeMax, batch_size, hashes);\n+          RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n+        } else {\n+          uint32_t* hashes = thread_local_hashes32[thread_index].data();\n+          get_hash32_impl(task_id * kBatchSizeMax, batch_size, hashes);\n+          RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n+        }\n+        return Status::OK();\n+      },\n+      [&](size_t thread_index) -> Status {\n+        lk.unlock();\n\nReview Comment:\n   Locks are automatically unlocked when a mutex is waited on so this seems like it would trigger a double-unlock.  You should be obtaining the lock here, if anything.  Howver, you don't technically need to hold the lock to the mutex in order to notify a cv.\n\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join_node_test.cc:\n##########\n@@ -1900,5 +1903,150 @@ TEST(HashJoin, TrivialResidualFilter) {\n   }\n }\n \n+HashJoinNodeOptions GenerateHashJoinNodeOptions(Random64Bit& rng, int num_left_cols,\n+                                                int num_right_cols) {\n+  HashJoinNodeOptions opts;\n+  opts.join_type = static_cast<JoinType>(rng.from_range(0, 7));\n+  bool is_left_join = opts.join_type == JoinType::LEFT_SEMI ||\n+                      opts.join_type == JoinType::LEFT_ANTI ||\n+                      opts.join_type == JoinType::LEFT_OUTER;\n+  bool is_right_join = opts.join_type == JoinType::RIGHT_SEMI ||\n+                       opts.join_type == JoinType::RIGHT_ANTI ||\n+                       opts.join_type == JoinType::RIGHT_OUTER;\n+\n+  int num_keys = rng.from_range(1, std::min(num_left_cols, num_right_cols));\n+  for (int i = 0; i < num_left_cols; i++) {\n+    bool is_out = rng.from_range(0, 2) != 2;\n\nReview Comment:\n   Why a 2/3 chance here (as opposed to 1/2 or 1/3)\n\n\n\n##########\ncpp/src/arrow/compute/exec/util.h:\n##########\n@@ -92,7 +92,7 @@ class TempVectorStack {\n   Status Init(MemoryPool* pool, int64_t size) {\n     num_vectors_ = 0;\n     top_ = 0;\n-    buffer_size_ = size;\n+    buffer_size_ = PaddedAllocationSize(size) + kPadding + 2 * sizeof(uint64_t);\n\nReview Comment:\n   Why are we padding here?\n\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join.cc:\n##########\n@@ -83,50 +85,75 @@ class HashJoinBasicImpl : public HashJoinImpl {\n   }\n \n   Status Init(ExecContext* ctx, JoinType join_type, bool use_sync_execution,\n-              size_t num_threads, HashJoinSchema* schema_mgr,\n+              size_t /*num_threads*/, HashJoinSchema* schema_mgr,\n               std::vector<JoinKeyCmp> key_cmp, Expression filter,\n               OutputBatchCallback output_batch_callback,\n               FinishedCallback finished_callback,\n-              TaskScheduler::ScheduleImpl schedule_task_callback) override {\n-    num_threads = std::max(num_threads, static_cast<size_t>(1));\n+              TaskScheduler::ScheduleImpl schedule_task_callback,\n+              HashJoinImpl* pushdown_target, std::vector<int> column_map) override {\n+    // TODO(ARROW-15732)\n+    // Each side of join might have an IO thread being called from.\n+    // As of right now, we ignore the `num_threads` argument, so later we will have to\n+    // readd `num_threads_ = num_threads;`\n\nReview Comment:\n   ```suggestion\r\n       // read `num_threads_ = num_threads;`\r\n   ```\n\n\n\n##########\ncpp/src/arrow/CMakeLists.txt:\n##########\n@@ -393,7 +393,6 @@ if(ARROW_COMPUTE)\n        compute/exec/key_encode.cc\n        compute/exec/key_hash.cc\n        compute/exec/key_map.cc\n-       compute/exec/options.cc\n\nReview Comment:\n   If this file is no longer needed could you also remove the file itself from source control?\n\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join.cc:\n##########\n@@ -83,50 +85,75 @@ class HashJoinBasicImpl : public HashJoinImpl {\n   }\n \n   Status Init(ExecContext* ctx, JoinType join_type, bool use_sync_execution,\n-              size_t num_threads, HashJoinSchema* schema_mgr,\n+              size_t /*num_threads*/, HashJoinSchema* schema_mgr,\n               std::vector<JoinKeyCmp> key_cmp, Expression filter,\n               OutputBatchCallback output_batch_callback,\n               FinishedCallback finished_callback,\n-              TaskScheduler::ScheduleImpl schedule_task_callback) override {\n-    num_threads = std::max(num_threads, static_cast<size_t>(1));\n+              TaskScheduler::ScheduleImpl schedule_task_callback,\n+              HashJoinImpl* pushdown_target, std::vector<int> column_map) override {\n+    // TODO(ARROW-15732)\n+    // Each side of join might have an IO thread being called from.\n+    // As of right now, we ignore the `num_threads` argument, so later we will have to\n+    // readd `num_threads_ = num_threads;`\n+    num_threads_ = GetCpuThreadPoolCapacity() + io::GetIOThreadPoolCapacity() + 1;\n+    // num_threads_ = GetCpuThreadPoolCapacity() + 1;\n \n     START_SPAN(span_, \"HashJoinBasicImpl\",\n                {{\"detail\", filter.ToString()},\n                 {\"join.kind\", ToString(join_type)},\n-                {\"join.threads\", static_cast<uint32_t>(num_threads)}});\n+                {\"join.threads\", static_cast<uint32_t>(num_threads_)}});\n \n     ctx_ = ctx;\n     join_type_ = join_type;\n-    num_threads_ = num_threads;\n     schema_mgr_ = schema_mgr;\n     key_cmp_ = std::move(key_cmp);\n     filter_ = std::move(filter);\n     output_batch_callback_ = std::move(output_batch_callback);\n     finished_callback_ = std::move(finished_callback);\n-    // TODO(ARROW-15732)\n-    // Each side of join might have an IO thread being called from.\n     local_states_.resize(GetCpuThreadPoolCapacity() + io::GetIOThreadPoolCapacity() + 1);\n\nReview Comment:\n   ```suggestion\r\n       local_states_.resize(num_threads_);\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join_node_test.cc:\n##########\n@@ -1900,5 +1903,150 @@ TEST(HashJoin, TrivialResidualFilter) {\n   }\n }\n \n+HashJoinNodeOptions GenerateHashJoinNodeOptions(Random64Bit& rng, int num_left_cols,\n+                                                int num_right_cols) {\n+  HashJoinNodeOptions opts;\n+  opts.join_type = static_cast<JoinType>(rng.from_range(0, 7));\n+  bool is_left_join = opts.join_type == JoinType::LEFT_SEMI ||\n+                      opts.join_type == JoinType::LEFT_ANTI ||\n+                      opts.join_type == JoinType::LEFT_OUTER;\n+  bool is_right_join = opts.join_type == JoinType::RIGHT_SEMI ||\n+                       opts.join_type == JoinType::RIGHT_ANTI ||\n+                       opts.join_type == JoinType::RIGHT_OUTER;\n+\n+  int num_keys = rng.from_range(1, std::min(num_left_cols, num_right_cols));\n+  for (int i = 0; i < num_left_cols; i++) {\n+    bool is_out = rng.from_range(0, 2) != 2;\n+    if (is_out && !is_right_join) opts.left_output.push_back(FieldRef(i));\n+  }\n+  for (int i = 0; i < num_right_cols; i++) {\n+    bool is_out = rng.from_range(0, 2) == 2;\n+    if (is_out && !is_left_join) opts.right_output.push_back(FieldRef(i));\n+  }\n+  // We need at least one output\n+  if (opts.right_output.empty() && opts.left_output.empty()) {\n+    if (is_left_join) {\n+      int col = rng.from_range(0, num_left_cols - 1);\n+      opts.left_output.push_back(FieldRef(col));\n+    } else if (is_right_join) {\n+      int col = rng.from_range(0, num_right_cols - 1);\n+      opts.right_output.push_back(FieldRef(col));\n+    } else {\n+      if (rng.from_range(0, 1) == 0) {\n+        int col = rng.from_range(0, num_left_cols - 1);\n+        opts.left_output.push_back(FieldRef(col));\n+      } else {\n+        int col = rng.from_range(0, num_right_cols - 1);\n+        opts.right_output.push_back(FieldRef(col));\n+      }\n+    }\n+  }\n+\n+  for (int i = 0; i < num_keys; i++) {\n+    int left = rng.from_range(0, num_left_cols - 1);\n+    int right = rng.from_range(0, num_right_cols - 1);\n+    bool is_or_eq = rng.from_range(0, 1) == 0;\n+    opts.left_keys.push_back(FieldRef(left));\n+    opts.right_keys.push_back(FieldRef(right));\n+    opts.key_cmp.push_back(is_or_eq ? JoinKeyCmp::IS : JoinKeyCmp::EQ);\n+  }\n+  return opts;\n+}\n+\n+void TestSingleChainOfHashJoins(Random64Bit& rng) {\n+  int num_joins = rng.from_range(2, 5);\n+  std::vector<HashJoinNodeOptions> opts;\n+  int num_left_cols = rng.from_range(1, 8);\n+  int num_right_cols = rng.from_range(1, 8);\n+  HashJoinNodeOptions first_opt =\n+      GenerateHashJoinNodeOptions(rng, num_left_cols, num_right_cols);\n+  opts.push_back(std::move(first_opt));\n+\n+  std::unordered_map<std::string, std::string> metadata_map;\n+  metadata_map[\"min\"] = \"0\";\n+  metadata_map[\"max\"] = \"10\";\n+  auto metadata = key_value_metadata(metadata_map);\n+  std::vector<std::shared_ptr<Field>> left_fields;\n+  for (int i = 0; i < num_left_cols; i++)\n+    left_fields.push_back(field(std::string(\"l\") + std::to_string(i), int32(), metadata));\n+  std::vector<std::shared_ptr<Field>> first_right_fields;\n+  for (int i = 0; i < num_right_cols; i++)\n+    first_right_fields.push_back(\n+        field(std::string(\"r_0_\") + std::to_string(i), int32(), metadata));\n+\n+  BatchesWithSchema input_left = MakeRandomBatches(schema(std::move(left_fields)));\n+  std::vector<BatchesWithSchema> input_right;\n+  input_right.push_back(MakeRandomBatches(schema(std::move(first_right_fields))));\n+\n+  for (int i = 1; i < num_joins; i++) {\n+    int num_right_cols = rng.from_range(1, 8);\n+    HashJoinNodeOptions opt =\n+        GenerateHashJoinNodeOptions(rng,\n+                                    static_cast<int>(opts[i - 1].left_output.size() +\n+                                                     opts[i - 1].right_output.size()),\n+                                    num_right_cols);\n+    opts.push_back(std::move(opt));\n+\n+    std::vector<std::shared_ptr<Field>> right_fields;\n+    for (int j = 0; j < num_right_cols; j++)\n+      right_fields.push_back(\n+          field(std::string(\"r_\") + std::to_string(i) + \"_\" + std::to_string(j), int32(),\n+                metadata));\n+    BatchesWithSchema input = MakeRandomBatches(schema(std::move(right_fields)));\n+    input_right.push_back(std::move(input));\n+  }\n+\n+  std::vector<ExecBatch> reference;\n+  for (bool bloom_filters : {false, true}) {\n+    bool parallel = true;\n+    ARROW_SCOPED_TRACE(bloom_filters ? \"bloom filtered\" : \"unfiltered\");\n+    auto exec_ctx = arrow::internal::make_unique<ExecContext>(\n+        default_memory_pool(), parallel ? arrow::internal::GetCpuThreadPool() : nullptr);\n+    ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make(exec_ctx.get()));\n+\n+    ExecNode* left_source;\n+    ASSERT_OK_AND_ASSIGN(\n+        left_source,\n+        MakeExecNode(\"source\", plan.get(), {},\n+                     SourceNodeOptions{input_left.schema,\n+                                       input_left.gen(parallel, /*slow=*/false)}));\n+    std::vector<ExecNode*> joins(num_joins);\n+    for (int i = 0; i < num_joins; i++) {\n+      opts[i].disable_bloom_filter = !bloom_filters;\n+      ExecNode* right_source;\n+      ASSERT_OK_AND_ASSIGN(\n+          right_source,\n+          MakeExecNode(\"source\", plan.get(), {},\n+                       SourceNodeOptions{input_right[i].schema,\n+                                         input_right[i].gen(parallel, /*slow=*/false)}));\n+\n+      std::vector<ExecNode*> inputs;\n+      if (i == 0)\n+        inputs = {left_source, right_source};\n+      else\n+        inputs = {joins[i - 1], right_source};\n+      ASSERT_OK_AND_ASSIGN(joins[i],\n+                           MakeExecNode(\"hashjoin\", plan.get(), inputs, opts[i]));\n+    }\n+    AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+    ASSERT_OK_AND_ASSIGN(std::ignore, MakeExecNode(\"sink\", plan.get(), {joins.back()},\n+                                                   SinkNodeOptions{&sink_gen}));\n\nReview Comment:\n   ```suggestion\r\n       ASSERT_OK(MakeExecNode(\"sink\", plan.get(), {joins.back()},\r\n                                                      SinkNodeOptions{&sink_gen}));\r\n   ```\n\n\n\n",
                    "created": "2022-04-26T17:19:28.188+0000",
                    "updated": "2022-04-26T17:19:28.188+0000",
                    "started": "2022-04-26T17:19:28.188+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "762440",
                    "issueId": "13425500"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13425500/worklog/762493",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #12289:\nURL: https://github.com/apache/arrow/pull/12289#discussion_r859059537\n\n\n##########\ncpp/src/arrow/CMakeLists.txt:\n##########\n@@ -393,7 +393,6 @@ if(ARROW_COMPUTE)\n        compute/exec/key_encode.cc\n        compute/exec/key_hash.cc\n        compute/exec/key_map.cc\n-       compute/exec/options.cc\n\nReview Comment:\n   Oh I think I thought this was a rebase error. `compute/exec/options.cc` actually appears twice in the list, so I got rid of one of them. \n\n\n\n",
                    "created": "2022-04-26T19:12:57.904+0000",
                    "updated": "2022-04-26T19:12:57.904+0000",
                    "started": "2022-04-26T19:12:57.903+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "762493",
                    "issueId": "13425500"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13425500/worklog/762495",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #12289:\nURL: https://github.com/apache/arrow/pull/12289#discussion_r859062246\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join.cc:\n##########\n@@ -83,50 +85,75 @@ class HashJoinBasicImpl : public HashJoinImpl {\n   }\n \n   Status Init(ExecContext* ctx, JoinType join_type, bool use_sync_execution,\n-              size_t num_threads, HashJoinSchema* schema_mgr,\n+              size_t /*num_threads*/, HashJoinSchema* schema_mgr,\n               std::vector<JoinKeyCmp> key_cmp, Expression filter,\n               OutputBatchCallback output_batch_callback,\n               FinishedCallback finished_callback,\n-              TaskScheduler::ScheduleImpl schedule_task_callback) override {\n-    num_threads = std::max(num_threads, static_cast<size_t>(1));\n+              TaskScheduler::ScheduleImpl schedule_task_callback,\n+              HashJoinImpl* pushdown_target, std::vector<int> column_map) override {\n+    // TODO(ARROW-15732)\n+    // Each side of join might have an IO thread being called from.\n+    // As of right now, we ignore the `num_threads` argument, so later we will have to\n+    // readd `num_threads_ = num_threads;`\n\nReview Comment:\n   readd as in \"add again\". I can change it to \"re-add\"\n\n\n\n",
                    "created": "2022-04-26T19:16:48.388+0000",
                    "updated": "2022-04-26T19:16:48.388+0000",
                    "started": "2022-04-26T19:16:48.387+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "762495",
                    "issueId": "13425500"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13425500/worklog/762498",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #12289:\nURL: https://github.com/apache/arrow/pull/12289#discussion_r859063193\n\n\n##########\ncpp/src/arrow/compute/exec/partition_util.h:\n##########\n@@ -59,14 +60,14 @@ class PartitionSort {\n   /// out_arr: [2, 5, 3, 5, 4, 7]\n   /// prtn_ranges: [0, 1, 5, 6]\n   template <class INPUT_PRTN_ID_FN, class OUTPUT_POS_FN>\n-  static void Eval(int num_rows, int num_prtns, uint16_t* prtn_ranges,\n+  static void Eval(int64_t num_rows, int num_prtns, uint16_t* prtn_ranges,\n\nReview Comment:\n   I've just been changing everything to int64_t, I think stuff like offsets into buffers and buffer lengths are int64_t, so it made sense to me. \n\n\n\n",
                    "created": "2022-04-26T19:18:08.409+0000",
                    "updated": "2022-04-26T19:18:08.409+0000",
                    "started": "2022-04-26T19:18:08.408+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "762498",
                    "issueId": "13425500"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13425500/worklog/762499",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #12289:\nURL: https://github.com/apache/arrow/pull/12289#discussion_r859064822\n\n\n##########\ncpp/src/arrow/compute/exec/bloom_filter.cc:\n##########\n@@ -114,7 +114,7 @@ Status BlockedBloomFilter::CreateEmpty(int64_t num_rows_to_insert, MemoryPool* p\n }\n \n template <typename T>\n-void BlockedBloomFilter::InsertImp(int64_t num_rows, const T* hashes) {\n+NO_TSAN void BlockedBloomFilter::InsertImp(int64_t num_rows, const T* hashes) {\n\nReview Comment:\n   Yes, I had to make `blocks` atomic to make TSAN go away, which we don't want to do\n\n\n\n",
                    "created": "2022-04-26T19:20:23.767+0000",
                    "updated": "2022-04-26T19:20:23.767+0000",
                    "started": "2022-04-26T19:20:23.767+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "762499",
                    "issueId": "13425500"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13425500/worklog/762500",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #12289:\nURL: https://github.com/apache/arrow/pull/12289#discussion_r859065009\n\n\n##########\ncpp/src/arrow/compute/exec/bloom_filter_test.cc:\n##########\n@@ -32,39 +33,107 @@\n namespace arrow {\n namespace compute {\n \n-Status BuildBloomFilter(BloomFilterBuildStrategy strategy, int64_t hardware_flags,\n-                        MemoryPool* pool, int64_t num_rows,\n-                        std::function<void(int64_t, int, uint32_t*)> get_hash32_impl,\n-                        std::function<void(int64_t, int, uint64_t*)> get_hash64_impl,\n-                        BlockedBloomFilter* target) {\n-  constexpr int batch_size_max = 32 * 1024;\n-  int64_t num_batches = bit_util::CeilDiv(num_rows, batch_size_max);\n-\n-  auto builder = BloomFilterBuilder::Make(strategy);\n-\n-  std::vector<uint32_t> thread_local_hashes32;\n-  std::vector<uint64_t> thread_local_hashes64;\n-  thread_local_hashes32.resize(batch_size_max);\n-  thread_local_hashes64.resize(batch_size_max);\n-\n-  RETURN_NOT_OK(builder->Begin(/*num_threads=*/1, hardware_flags, pool, num_rows,\n-                               bit_util::CeilDiv(num_rows, batch_size_max), target));\n-\n-  for (int64_t i = 0; i < num_batches; ++i) {\n+constexpr int kBatchSizeMax = 32 * 1024;\n+Status BuildBloomFilter_Serial(\n+    std::unique_ptr<BloomFilterBuilder>& builder, int64_t num_rows, int64_t num_batches,\n+    std::function<void(int64_t, int, uint32_t*)> get_hash32_impl,\n+    std::function<void(int64_t, int, uint64_t*)> get_hash64_impl,\n+    BlockedBloomFilter* target) {\n+  std::vector<uint32_t> hashes32(kBatchSizeMax);\n+  std::vector<uint64_t> hashes64(kBatchSizeMax);\n+  for (int64_t i = 0; i < num_batches; i++) {\n     size_t thread_index = 0;\n     int batch_size = static_cast<int>(\n-        std::min(num_rows - i * batch_size_max, static_cast<int64_t>(batch_size_max)));\n+        std::min(num_rows - i * kBatchSizeMax, static_cast<int64_t>(kBatchSizeMax)));\n     if (target->NumHashBitsUsed() > 32) {\n-      uint64_t* hashes = thread_local_hashes64.data();\n-      get_hash64_impl(i * batch_size_max, batch_size, hashes);\n+      uint64_t* hashes = hashes64.data();\n+      get_hash64_impl(i * kBatchSizeMax, batch_size, hashes);\n       RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n     } else {\n-      uint32_t* hashes = thread_local_hashes32.data();\n-      get_hash32_impl(i * batch_size_max, batch_size, hashes);\n+      uint32_t* hashes = hashes32.data();\n+      get_hash32_impl(i * kBatchSizeMax, batch_size, hashes);\n       RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n     }\n   }\n+  return Status::OK();\n+}\n+\n+Status BuildBloomFilter_Parallel(\n+    std::unique_ptr<BloomFilterBuilder>& builder, size_t num_threads, int64_t num_rows,\n+    int64_t num_batches, std::function<void(int64_t, int, uint32_t*)> get_hash32_impl,\n+    std::function<void(int64_t, int, uint64_t*)> get_hash64_impl,\n+    BlockedBloomFilter* target) {\n+  std::mutex mutex;\n+  ThreadIndexer thread_indexer;\n+  std::unique_ptr<TaskScheduler> scheduler = TaskScheduler::Make();\n+  std::vector<std::vector<uint32_t>> thread_local_hashes32(num_threads);\n+  std::vector<std::vector<uint64_t>> thread_local_hashes64(num_threads);\n+  for (std::vector<uint32_t>& h : thread_local_hashes32) h.resize(kBatchSizeMax);\n+  for (std::vector<uint64_t>& h : thread_local_hashes64) h.resize(kBatchSizeMax);\n+\n+  std::condition_variable cv;\n+  std::unique_lock<std::mutex> lk(mutex, std::defer_lock);\n+  auto group = scheduler->RegisterTaskGroup(\n+      [&](size_t thread_index, int64_t task_id) -> Status {\n+        int batch_size = static_cast<int>(std::min(num_rows - task_id * kBatchSizeMax,\n+                                                   static_cast<int64_t>(kBatchSizeMax)));\n+        if (target->NumHashBitsUsed() > 32) {\n+          uint64_t* hashes = thread_local_hashes64[thread_index].data();\n+          get_hash64_impl(task_id * kBatchSizeMax, batch_size, hashes);\n+          RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n+        } else {\n+          uint32_t* hashes = thread_local_hashes32[thread_index].data();\n+          get_hash32_impl(task_id * kBatchSizeMax, batch_size, hashes);\n+          RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n+        }\n+        return Status::OK();\n+      },\n+      [&](size_t thread_index) -> Status {\n+        lk.unlock();\n+        cv.notify_one();\n+        return Status::OK();\n+      });\n+  scheduler->RegisterEnd();\n+  auto tp = arrow::internal::GetCpuThreadPool();\n+  RETURN_NOT_OK(scheduler->StartScheduling(\n+      0,\n+      [&](std::function<Status(size_t)> func) -> Status {\n+        return tp->Spawn([&, func] {\n+          size_t tid = thread_indexer();\n+          std::ignore = func(tid);\n+        });\n+      },\n+      static_cast<int>(2 * num_threads), false));\n\nReview Comment:\n   Not sure, it's 2x everywhere else. I can change it. \n\n\n\n",
                    "created": "2022-04-26T19:20:38.703+0000",
                    "updated": "2022-04-26T19:20:38.703+0000",
                    "started": "2022-04-26T19:20:38.703+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "762500",
                    "issueId": "13425500"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13425500/worklog/762503",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #12289:\nURL: https://github.com/apache/arrow/pull/12289#discussion_r859069622\n\n\n##########\ncpp/src/arrow/compute/exec/bloom_filter_test.cc:\n##########\n@@ -32,39 +33,107 @@\n namespace arrow {\n namespace compute {\n \n-Status BuildBloomFilter(BloomFilterBuildStrategy strategy, int64_t hardware_flags,\n-                        MemoryPool* pool, int64_t num_rows,\n-                        std::function<void(int64_t, int, uint32_t*)> get_hash32_impl,\n-                        std::function<void(int64_t, int, uint64_t*)> get_hash64_impl,\n-                        BlockedBloomFilter* target) {\n-  constexpr int batch_size_max = 32 * 1024;\n-  int64_t num_batches = bit_util::CeilDiv(num_rows, batch_size_max);\n-\n-  auto builder = BloomFilterBuilder::Make(strategy);\n-\n-  std::vector<uint32_t> thread_local_hashes32;\n-  std::vector<uint64_t> thread_local_hashes64;\n-  thread_local_hashes32.resize(batch_size_max);\n-  thread_local_hashes64.resize(batch_size_max);\n-\n-  RETURN_NOT_OK(builder->Begin(/*num_threads=*/1, hardware_flags, pool, num_rows,\n-                               bit_util::CeilDiv(num_rows, batch_size_max), target));\n-\n-  for (int64_t i = 0; i < num_batches; ++i) {\n+constexpr int kBatchSizeMax = 32 * 1024;\n+Status BuildBloomFilter_Serial(\n+    std::unique_ptr<BloomFilterBuilder>& builder, int64_t num_rows, int64_t num_batches,\n+    std::function<void(int64_t, int, uint32_t*)> get_hash32_impl,\n+    std::function<void(int64_t, int, uint64_t*)> get_hash64_impl,\n+    BlockedBloomFilter* target) {\n+  std::vector<uint32_t> hashes32(kBatchSizeMax);\n+  std::vector<uint64_t> hashes64(kBatchSizeMax);\n+  for (int64_t i = 0; i < num_batches; i++) {\n     size_t thread_index = 0;\n     int batch_size = static_cast<int>(\n-        std::min(num_rows - i * batch_size_max, static_cast<int64_t>(batch_size_max)));\n+        std::min(num_rows - i * kBatchSizeMax, static_cast<int64_t>(kBatchSizeMax)));\n     if (target->NumHashBitsUsed() > 32) {\n-      uint64_t* hashes = thread_local_hashes64.data();\n-      get_hash64_impl(i * batch_size_max, batch_size, hashes);\n+      uint64_t* hashes = hashes64.data();\n+      get_hash64_impl(i * kBatchSizeMax, batch_size, hashes);\n       RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n     } else {\n-      uint32_t* hashes = thread_local_hashes32.data();\n-      get_hash32_impl(i * batch_size_max, batch_size, hashes);\n+      uint32_t* hashes = hashes32.data();\n+      get_hash32_impl(i * kBatchSizeMax, batch_size, hashes);\n       RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n     }\n   }\n+  return Status::OK();\n+}\n+\n+Status BuildBloomFilter_Parallel(\n+    std::unique_ptr<BloomFilterBuilder>& builder, size_t num_threads, int64_t num_rows,\n+    int64_t num_batches, std::function<void(int64_t, int, uint32_t*)> get_hash32_impl,\n+    std::function<void(int64_t, int, uint64_t*)> get_hash64_impl,\n+    BlockedBloomFilter* target) {\n+  std::mutex mutex;\n+  ThreadIndexer thread_indexer;\n+  std::unique_ptr<TaskScheduler> scheduler = TaskScheduler::Make();\n+  std::vector<std::vector<uint32_t>> thread_local_hashes32(num_threads);\n+  std::vector<std::vector<uint64_t>> thread_local_hashes64(num_threads);\n+  for (std::vector<uint32_t>& h : thread_local_hashes32) h.resize(kBatchSizeMax);\n+  for (std::vector<uint64_t>& h : thread_local_hashes64) h.resize(kBatchSizeMax);\n+\n+  std::condition_variable cv;\n+  std::unique_lock<std::mutex> lk(mutex, std::defer_lock);\n+  auto group = scheduler->RegisterTaskGroup(\n+      [&](size_t thread_index, int64_t task_id) -> Status {\n+        int batch_size = static_cast<int>(std::min(num_rows - task_id * kBatchSizeMax,\n+                                                   static_cast<int64_t>(kBatchSizeMax)));\n+        if (target->NumHashBitsUsed() > 32) {\n+          uint64_t* hashes = thread_local_hashes64[thread_index].data();\n+          get_hash64_impl(task_id * kBatchSizeMax, batch_size, hashes);\n+          RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n+        } else {\n+          uint32_t* hashes = thread_local_hashes32[thread_index].data();\n+          get_hash32_impl(task_id * kBatchSizeMax, batch_size, hashes);\n+          RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n+        }\n+        return Status::OK();\n+      },\n+      [&](size_t thread_index) -> Status {\n+        lk.unlock();\n+        cv.notify_one();\n+        return Status::OK();\n+      });\n+  scheduler->RegisterEnd();\n+  auto tp = arrow::internal::GetCpuThreadPool();\n+  RETURN_NOT_OK(scheduler->StartScheduling(\n+      0,\n+      [&](std::function<Status(size_t)> func) -> Status {\n+        return tp->Spawn([&, func] {\n+          size_t tid = thread_indexer();\n+          std::ignore = func(tid);\n\nReview Comment:\n   The lambda expression needs to return void here. I can maybe DCHECK_OK it. \n\n\n\n",
                    "created": "2022-04-26T19:27:09.607+0000",
                    "updated": "2022-04-26T19:27:09.607+0000",
                    "started": "2022-04-26T19:27:09.606+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "762503",
                    "issueId": "13425500"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13425500/worklog/762506",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #12289:\nURL: https://github.com/apache/arrow/pull/12289#discussion_r859076718\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join_node_test.cc:\n##########\n@@ -1900,5 +1903,150 @@ TEST(HashJoin, TrivialResidualFilter) {\n   }\n }\n \n+HashJoinNodeOptions GenerateHashJoinNodeOptions(Random64Bit& rng, int num_left_cols,\n+                                                int num_right_cols) {\n+  HashJoinNodeOptions opts;\n+  opts.join_type = static_cast<JoinType>(rng.from_range(0, 7));\n+  bool is_left_join = opts.join_type == JoinType::LEFT_SEMI ||\n+                      opts.join_type == JoinType::LEFT_ANTI ||\n+                      opts.join_type == JoinType::LEFT_OUTER;\n+  bool is_right_join = opts.join_type == JoinType::RIGHT_SEMI ||\n+                       opts.join_type == JoinType::RIGHT_ANTI ||\n+                       opts.join_type == JoinType::RIGHT_OUTER;\n+\n+  int num_keys = rng.from_range(1, std::min(num_left_cols, num_right_cols));\n+  for (int i = 0; i < num_left_cols; i++) {\n+    bool is_out = rng.from_range(0, 2) != 2;\n\nReview Comment:\n   The higher the chance of a probe-side output, the higher the more columns we can use for Bloom filters. I guess it's pretty arbitrary, but I wanted it to be slightly higher. \n\n\n\n",
                    "created": "2022-04-26T19:32:45.201+0000",
                    "updated": "2022-04-26T19:32:45.201+0000",
                    "started": "2022-04-26T19:32:45.201+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "762506",
                    "issueId": "13425500"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13425500/worklog/762507",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #12289:\nURL: https://github.com/apache/arrow/pull/12289#discussion_r859078078\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join_node_test.cc:\n##########\n@@ -1900,5 +1903,150 @@ TEST(HashJoin, TrivialResidualFilter) {\n   }\n }\n \n+HashJoinNodeOptions GenerateHashJoinNodeOptions(Random64Bit& rng, int num_left_cols,\n+                                                int num_right_cols) {\n+  HashJoinNodeOptions opts;\n+  opts.join_type = static_cast<JoinType>(rng.from_range(0, 7));\n+  bool is_left_join = opts.join_type == JoinType::LEFT_SEMI ||\n+                      opts.join_type == JoinType::LEFT_ANTI ||\n+                      opts.join_type == JoinType::LEFT_OUTER;\n+  bool is_right_join = opts.join_type == JoinType::RIGHT_SEMI ||\n+                       opts.join_type == JoinType::RIGHT_ANTI ||\n+                       opts.join_type == JoinType::RIGHT_OUTER;\n+\n+  int num_keys = rng.from_range(1, std::min(num_left_cols, num_right_cols));\n+  for (int i = 0; i < num_left_cols; i++) {\n+    bool is_out = rng.from_range(0, 2) != 2;\n+    if (is_out && !is_right_join) opts.left_output.push_back(FieldRef(i));\n+  }\n+  for (int i = 0; i < num_right_cols; i++) {\n+    bool is_out = rng.from_range(0, 2) == 2;\n+    if (is_out && !is_left_join) opts.right_output.push_back(FieldRef(i));\n+  }\n+  // We need at least one output\n+  if (opts.right_output.empty() && opts.left_output.empty()) {\n+    if (is_left_join) {\n+      int col = rng.from_range(0, num_left_cols - 1);\n+      opts.left_output.push_back(FieldRef(col));\n+    } else if (is_right_join) {\n+      int col = rng.from_range(0, num_right_cols - 1);\n+      opts.right_output.push_back(FieldRef(col));\n+    } else {\n+      if (rng.from_range(0, 1) == 0) {\n+        int col = rng.from_range(0, num_left_cols - 1);\n+        opts.left_output.push_back(FieldRef(col));\n+      } else {\n+        int col = rng.from_range(0, num_right_cols - 1);\n+        opts.right_output.push_back(FieldRef(col));\n+      }\n+    }\n+  }\n+\n+  for (int i = 0; i < num_keys; i++) {\n+    int left = rng.from_range(0, num_left_cols - 1);\n+    int right = rng.from_range(0, num_right_cols - 1);\n+    bool is_or_eq = rng.from_range(0, 1) == 0;\n+    opts.left_keys.push_back(FieldRef(left));\n+    opts.right_keys.push_back(FieldRef(right));\n+    opts.key_cmp.push_back(is_or_eq ? JoinKeyCmp::IS : JoinKeyCmp::EQ);\n+  }\n+  return opts;\n+}\n+\n+void TestSingleChainOfHashJoins(Random64Bit& rng) {\n+  int num_joins = rng.from_range(2, 5);\n+  std::vector<HashJoinNodeOptions> opts;\n+  int num_left_cols = rng.from_range(1, 8);\n+  int num_right_cols = rng.from_range(1, 8);\n+  HashJoinNodeOptions first_opt =\n+      GenerateHashJoinNodeOptions(rng, num_left_cols, num_right_cols);\n+  opts.push_back(std::move(first_opt));\n+\n+  std::unordered_map<std::string, std::string> metadata_map;\n+  metadata_map[\"min\"] = \"0\";\n+  metadata_map[\"max\"] = \"10\";\n+  auto metadata = key_value_metadata(metadata_map);\n+  std::vector<std::shared_ptr<Field>> left_fields;\n+  for (int i = 0; i < num_left_cols; i++)\n+    left_fields.push_back(field(std::string(\"l\") + std::to_string(i), int32(), metadata));\n+  std::vector<std::shared_ptr<Field>> first_right_fields;\n+  for (int i = 0; i < num_right_cols; i++)\n+    first_right_fields.push_back(\n+        field(std::string(\"r_0_\") + std::to_string(i), int32(), metadata));\n+\n+  BatchesWithSchema input_left = MakeRandomBatches(schema(std::move(left_fields)));\n+  std::vector<BatchesWithSchema> input_right;\n+  input_right.push_back(MakeRandomBatches(schema(std::move(first_right_fields))));\n+\n+  for (int i = 1; i < num_joins; i++) {\n+    int num_right_cols = rng.from_range(1, 8);\n+    HashJoinNodeOptions opt =\n+        GenerateHashJoinNodeOptions(rng,\n+                                    static_cast<int>(opts[i - 1].left_output.size() +\n+                                                     opts[i - 1].right_output.size()),\n+                                    num_right_cols);\n+    opts.push_back(std::move(opt));\n+\n+    std::vector<std::shared_ptr<Field>> right_fields;\n+    for (int j = 0; j < num_right_cols; j++)\n+      right_fields.push_back(\n+          field(std::string(\"r_\") + std::to_string(i) + \"_\" + std::to_string(j), int32(),\n+                metadata));\n+    BatchesWithSchema input = MakeRandomBatches(schema(std::move(right_fields)));\n+    input_right.push_back(std::move(input));\n+  }\n+\n+  std::vector<ExecBatch> reference;\n+  for (bool bloom_filters : {false, true}) {\n+    bool parallel = true;\n\nReview Comment:\n   Don't really remember, but I've changed it to a constant. I might've just had it there for debugging. \n\n\n\n",
                    "created": "2022-04-26T19:34:35.319+0000",
                    "updated": "2022-04-26T19:34:35.319+0000",
                    "started": "2022-04-26T19:34:35.319+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "762507",
                    "issueId": "13425500"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13425500/worklog/762508",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #12289:\nURL: https://github.com/apache/arrow/pull/12289#discussion_r859086950\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join_node.cc:\n##########\n@@ -571,24 +573,82 @@ class HashJoinNode : public ExecNode {\n     }\n   }\n \n-  Status StartProducing() override {\n-    START_SPAN(span_, std::string(kind_name()) + \":\" + label(),\n-               {{\"node.label\", label()},\n-                {\"node.detail\", ToString()},\n-                {\"node.kind\", kind_name()}});\n-    END_SPAN_ON_FUTURE_COMPLETION(span_, finished(), this);\n+  std::pair<HashJoinImpl*, std::vector<int>> GetPushdownTarget() {\n\nReview Comment:\n   I only use the `pair` in one spot as far as I can tell. I just use it so that I can use `std::tie` on whoever calls `GetPushdownTarget`. I did add a big comment though\n\n\n\n",
                    "created": "2022-04-26T19:47:01.649+0000",
                    "updated": "2022-04-26T19:47:01.649+0000",
                    "started": "2022-04-26T19:47:01.649+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "762508",
                    "issueId": "13425500"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13425500/worklog/763194",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #12289:\nURL: https://github.com/apache/arrow/pull/12289#discussion_r860314520\n\n\n##########\ncpp/src/arrow/compute/exec/util.h:\n##########\n@@ -92,7 +92,7 @@ class TempVectorStack {\n   Status Init(MemoryPool* pool, int64_t size) {\n     num_vectors_ = 0;\n     top_ = 0;\n-    buffer_size_ = size;\n+    buffer_size_ = PaddedAllocationSize(size) + kPadding + 2 * sizeof(uint64_t);\n\nReview Comment:\n   It's weird if you `Init` the TempVectorStack with one size and then it segfaults if you try to `alloc` that much memory. That's because `alloc` bumps the stack by `PaddedAllocationSize(size) + 2 * sizeof(uint64_t)`   \n\n\n\n",
                    "created": "2022-04-27T23:21:56.604+0000",
                    "updated": "2022-04-27T23:21:56.604+0000",
                    "started": "2022-04-27T23:21:56.604+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "763194",
                    "issueId": "13425500"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13425500/worklog/763195",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #12289:\nURL: https://github.com/apache/arrow/pull/12289#discussion_r860314817\n\n\n##########\ncpp/src/arrow/compute/exec/bloom_filter_test.cc:\n##########\n@@ -32,39 +33,107 @@\n namespace arrow {\n namespace compute {\n \n-Status BuildBloomFilter(BloomFilterBuildStrategy strategy, int64_t hardware_flags,\n-                        MemoryPool* pool, int64_t num_rows,\n-                        std::function<void(int64_t, int, uint32_t*)> get_hash32_impl,\n-                        std::function<void(int64_t, int, uint64_t*)> get_hash64_impl,\n-                        BlockedBloomFilter* target) {\n-  constexpr int batch_size_max = 32 * 1024;\n-  int64_t num_batches = bit_util::CeilDiv(num_rows, batch_size_max);\n-\n-  auto builder = BloomFilterBuilder::Make(strategy);\n-\n-  std::vector<uint32_t> thread_local_hashes32;\n-  std::vector<uint64_t> thread_local_hashes64;\n-  thread_local_hashes32.resize(batch_size_max);\n-  thread_local_hashes64.resize(batch_size_max);\n-\n-  RETURN_NOT_OK(builder->Begin(/*num_threads=*/1, hardware_flags, pool, num_rows,\n-                               bit_util::CeilDiv(num_rows, batch_size_max), target));\n-\n-  for (int64_t i = 0; i < num_batches; ++i) {\n+constexpr int kBatchSizeMax = 32 * 1024;\n+Status BuildBloomFilter_Serial(\n+    std::unique_ptr<BloomFilterBuilder>& builder, int64_t num_rows, int64_t num_batches,\n+    std::function<void(int64_t, int, uint32_t*)> get_hash32_impl,\n+    std::function<void(int64_t, int, uint64_t*)> get_hash64_impl,\n+    BlockedBloomFilter* target) {\n+  std::vector<uint32_t> hashes32(kBatchSizeMax);\n+  std::vector<uint64_t> hashes64(kBatchSizeMax);\n+  for (int64_t i = 0; i < num_batches; i++) {\n     size_t thread_index = 0;\n     int batch_size = static_cast<int>(\n-        std::min(num_rows - i * batch_size_max, static_cast<int64_t>(batch_size_max)));\n+        std::min(num_rows - i * kBatchSizeMax, static_cast<int64_t>(kBatchSizeMax)));\n     if (target->NumHashBitsUsed() > 32) {\n-      uint64_t* hashes = thread_local_hashes64.data();\n-      get_hash64_impl(i * batch_size_max, batch_size, hashes);\n+      uint64_t* hashes = hashes64.data();\n+      get_hash64_impl(i * kBatchSizeMax, batch_size, hashes);\n       RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n     } else {\n-      uint32_t* hashes = thread_local_hashes32.data();\n-      get_hash32_impl(i * batch_size_max, batch_size, hashes);\n+      uint32_t* hashes = hashes32.data();\n+      get_hash32_impl(i * kBatchSizeMax, batch_size, hashes);\n       RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n     }\n   }\n+  return Status::OK();\n+}\n+\n+Status BuildBloomFilter_Parallel(\n+    std::unique_ptr<BloomFilterBuilder>& builder, size_t num_threads, int64_t num_rows,\n+    int64_t num_batches, std::function<void(int64_t, int, uint32_t*)> get_hash32_impl,\n+    std::function<void(int64_t, int, uint64_t*)> get_hash64_impl,\n+    BlockedBloomFilter* target) {\n+  std::mutex mutex;\n+  ThreadIndexer thread_indexer;\n+  std::unique_ptr<TaskScheduler> scheduler = TaskScheduler::Make();\n+  std::vector<std::vector<uint32_t>> thread_local_hashes32(num_threads);\n+  std::vector<std::vector<uint64_t>> thread_local_hashes64(num_threads);\n+  for (std::vector<uint32_t>& h : thread_local_hashes32) h.resize(kBatchSizeMax);\n+  for (std::vector<uint64_t>& h : thread_local_hashes64) h.resize(kBatchSizeMax);\n+\n+  std::condition_variable cv;\n+  std::unique_lock<std::mutex> lk(mutex, std::defer_lock);\n+  auto group = scheduler->RegisterTaskGroup(\n+      [&](size_t thread_index, int64_t task_id) -> Status {\n+        int batch_size = static_cast<int>(std::min(num_rows - task_id * kBatchSizeMax,\n+                                                   static_cast<int64_t>(kBatchSizeMax)));\n+        if (target->NumHashBitsUsed() > 32) {\n+          uint64_t* hashes = thread_local_hashes64[thread_index].data();\n+          get_hash64_impl(task_id * kBatchSizeMax, batch_size, hashes);\n+          RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n+        } else {\n+          uint32_t* hashes = thread_local_hashes32[thread_index].data();\n+          get_hash32_impl(task_id * kBatchSizeMax, batch_size, hashes);\n+          RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n+        }\n+        return Status::OK();\n+      },\n+      [&](size_t thread_index) -> Status {\n+        lk.unlock();\n\nReview Comment:\n   I think I fixed this now.\n\n\n\n",
                    "created": "2022-04-27T23:22:36.714+0000",
                    "updated": "2022-04-27T23:22:36.714+0000",
                    "started": "2022-04-27T23:22:36.714+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "763195",
                    "issueId": "13425500"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13425500/worklog/763196",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #12289:\nURL: https://github.com/apache/arrow/pull/12289#discussion_r860315583\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join_benchmark.cc:\n##########\n@@ -126,6 +129,22 @@ class JoinBenchmark {\n \n     join_ = *HashJoinImpl::MakeBasic();\n \n+    HashJoinImpl* bloom_filter_pushdown_target = nullptr;\n+    std::vector<int> key_input_map;\n+\n+    bool bloom_filter_does_not_apply_to_join =\n\nReview Comment:\n   Well we benchmark to see what kind of performance impact the Bloom filter has. \r\n   But since we currently only do early-elimination of rows, and only build on the build side, this disqualifies some types of joins, so we check that here.\n\n\n\n",
                    "created": "2022-04-27T23:24:42.159+0000",
                    "updated": "2022-04-27T23:24:42.159+0000",
                    "started": "2022-04-27T23:24:42.158+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "763196",
                    "issueId": "13425500"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13425500/worklog/768206",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #12289:\nURL: https://github.com/apache/arrow/pull/12289#discussion_r868481678\n\n\n##########\ncpp/src/arrow/compute/exec/bloom_filter_test.cc:\n##########\n@@ -32,39 +33,108 @@\n namespace arrow {\n namespace compute {\n \n-Status BuildBloomFilter(BloomFilterBuildStrategy strategy, int64_t hardware_flags,\n-                        MemoryPool* pool, int64_t num_rows,\n-                        std::function<void(int64_t, int, uint32_t*)> get_hash32_impl,\n-                        std::function<void(int64_t, int, uint64_t*)> get_hash64_impl,\n-                        BlockedBloomFilter* target) {\n-  constexpr int batch_size_max = 32 * 1024;\n-  int64_t num_batches = bit_util::CeilDiv(num_rows, batch_size_max);\n-\n-  auto builder = BloomFilterBuilder::Make(strategy);\n-\n-  std::vector<uint32_t> thread_local_hashes32;\n-  std::vector<uint64_t> thread_local_hashes64;\n-  thread_local_hashes32.resize(batch_size_max);\n-  thread_local_hashes64.resize(batch_size_max);\n-\n-  RETURN_NOT_OK(builder->Begin(/*num_threads=*/1, hardware_flags, pool, num_rows,\n-                               bit_util::CeilDiv(num_rows, batch_size_max), target));\n-\n-  for (int64_t i = 0; i < num_batches; ++i) {\n+constexpr int kBatchSizeMax = 32 * 1024;\n+Status BuildBloomFilter_Serial(\n+    std::unique_ptr<BloomFilterBuilder>& builder, int64_t num_rows, int64_t num_batches,\n+    std::function<void(int64_t, int, uint32_t*)> get_hash32_impl,\n+    std::function<void(int64_t, int, uint64_t*)> get_hash64_impl,\n+    BlockedBloomFilter* target) {\n+  std::vector<uint32_t> hashes32(kBatchSizeMax);\n+  std::vector<uint64_t> hashes64(kBatchSizeMax);\n+  for (int64_t i = 0; i < num_batches; i++) {\n     size_t thread_index = 0;\n     int batch_size = static_cast<int>(\n-        std::min(num_rows - i * batch_size_max, static_cast<int64_t>(batch_size_max)));\n+        std::min(num_rows - i * kBatchSizeMax, static_cast<int64_t>(kBatchSizeMax)));\n     if (target->NumHashBitsUsed() > 32) {\n-      uint64_t* hashes = thread_local_hashes64.data();\n-      get_hash64_impl(i * batch_size_max, batch_size, hashes);\n+      uint64_t* hashes = hashes64.data();\n+      get_hash64_impl(i * kBatchSizeMax, batch_size, hashes);\n       RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n     } else {\n-      uint32_t* hashes = thread_local_hashes32.data();\n-      get_hash32_impl(i * batch_size_max, batch_size, hashes);\n+      uint32_t* hashes = hashes32.data();\n+      get_hash32_impl(i * kBatchSizeMax, batch_size, hashes);\n       RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n     }\n   }\n+  return Status::OK();\n+}\n+\n+Status BuildBloomFilter_Parallel(\n+    std::unique_ptr<BloomFilterBuilder>& builder, size_t num_threads, int64_t num_rows,\n+    int64_t num_batches, std::function<void(int64_t, int, uint32_t*)> get_hash32_impl,\n+    std::function<void(int64_t, int, uint64_t*)> get_hash64_impl,\n+    BlockedBloomFilter* target) {\n+  ThreadIndexer thread_indexer;\n+  std::unique_ptr<TaskScheduler> scheduler = TaskScheduler::Make();\n+  std::vector<std::vector<uint32_t>> thread_local_hashes32(num_threads);\n+  std::vector<std::vector<uint64_t>> thread_local_hashes64(num_threads);\n+  for (std::vector<uint32_t>& h : thread_local_hashes32) h.resize(kBatchSizeMax);\n+  for (std::vector<uint64_t>& h : thread_local_hashes64) h.resize(kBatchSizeMax);\n+\n+  std::condition_variable cv;\n+  std::mutex mutex;\n+  auto group = scheduler->RegisterTaskGroup(\n+      [&](size_t thread_index, int64_t task_id) -> Status {\n+        int batch_size = static_cast<int>(std::min(num_rows - task_id * kBatchSizeMax,\n+                                                   static_cast<int64_t>(kBatchSizeMax)));\n+        if (target->NumHashBitsUsed() > 32) {\n+          uint64_t* hashes = thread_local_hashes64[thread_index].data();\n+          get_hash64_impl(task_id * kBatchSizeMax, batch_size, hashes);\n+          RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n+        } else {\n+          uint32_t* hashes = thread_local_hashes32[thread_index].data();\n+          get_hash32_impl(task_id * kBatchSizeMax, batch_size, hashes);\n+          RETURN_NOT_OK(builder->PushNextBatch(thread_index, batch_size, hashes));\n+        }\n+        return Status::OK();\n+      },\n+      [&](size_t thread_index) -> Status {\n+        {\n+          std::unique_lock<std::mutex> lk(mutex);\n+          cv.notify_all();\n+        }\n+        return Status::OK();\n+      });\n\nReview Comment:\n   ```suggestion\r\n         [&](size_t thread_index) -> Status {\r\n           std::unique_lock<std::mutex> lk(mutex);\r\n           cv.notify_all();\r\n           return Status::OK();\r\n         });\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join.cc:\n##########\n@@ -651,23 +777,44 @@ class HashJoinBasicImpl : public HashJoinImpl {\n     return Status::OK();\n   }\n \n+  Status BuildBloomFilter_on_finished(size_t thread_index) {\n+    if (cancelled_) return Status::Cancelled(\"Hash join cancelled\");\n+    ARROW_DCHECK(pushdown_target_);\n+    RETURN_NOT_OK(pushdown_target_->PushBloomFilter(\n+        thread_index, std::move(bloom_filter_), std::move(column_map_)));\n+    return BuildHashTable(thread_index);\n+  }\n+\n   Status BuildHashTable_on_finished(size_t thread_index) {\n     if (cancelled_) {\n       return Status::Cancelled(\"Hash join cancelled\");\n     }\n \n+    bool proceed;\n     {\n       std::lock_guard<std::mutex> lock(left_batches_mutex_);\n+      std::lock_guard<std::mutex> lock_finish(finished_mutex_);\n+      left_queue_bloom_finished_ =\n+          left_queue_bloom_finished_ || num_expected_bloom_filters_ == 0;\n+      proceed = !has_hash_table_ && left_queue_bloom_finished_;\n       has_hash_table_ = true;\n     }\n+    if (proceed) RETURN_NOT_OK(ProbeQueuedBatches(thread_index));\n \n     right_batches_.clear();\n\nReview Comment:\n   I wonder if this should be the first thing we do in this method.  In most cases I don't think it will really matter much but if we're running serially this means we're holding on to a bunch of memory while we probe the queued batches.\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -212,6 +212,13 @@ class ARROW_EXPORT ExecNode {\n   // A node with multiple outputs will also need to ensure it is applying backpressure if\n   // any of its outputs is asking to pause\n \n+  /// \\brief Steps performed immediately before StartProducing is called\n+  ///\n+  /// This hook performs any actions in between creation of ExecPlan and the call to\n+  /// StartProducing. An example could be Bloom filter pushdown. The order of ExecNodes\n+  /// that executes this method is undefined, but the calls are made synchronously.\n+  virtual Status PrepareToProduce() { return Status::OK(); }\n\nReview Comment:\n   ```suggestion\r\n     /// that executes this method is undefined, but the calls are made synchronously.\r\n     ///\r\n     /// At this point a node can rely on all inputs & outputs (and the input schemas)\r\n     /// being well defined.\r\n     virtual Status PrepareToProduce() { return Status::OK(); }\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -212,6 +212,13 @@ class ARROW_EXPORT ExecNode {\n   // A node with multiple outputs will also need to ensure it is applying backpressure if\n   // any of its outputs is asking to pause\n \n+  /// \\brief Steps performed immediately before StartProducing is called\n\nReview Comment:\n   ```suggestion\r\n     /// \\brief Perform any needed initialization\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join.cc:\n##########\n@@ -138,6 +162,30 @@ class HashJoinBasicImpl : public HashJoinImpl {\n     scheduler_->Abort(std::move(pos_abort_callback));\n   }\n \n+  Status PushBloomFilter(size_t thread_index, std::unique_ptr<BlockedBloomFilter> filter,\n\nReview Comment:\n   ```suggestion\r\n     // Called by a downstream node after they have constructed a bloom filter\r\n     // that this node can use to filter inputs.\r\n     Status PushBloomFilter(size_t thread_index, std::unique_ptr<BlockedBloomFilter> filter,\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join.cc:\n##########\n@@ -604,8 +654,84 @@ class HashJoinBasicImpl : public HashJoinImpl {\n     return Status::OK();\n   }\n \n+  Status ApplyBloomFiltersToBatch(size_t thread_index, ExecBatch& batch) {\n+    if (batch.length == 0) return Status::OK();\n+    int64_t bit_vector_bytes = bit_util::BytesForBits(batch.length);\n+    std::vector<uint8_t> selected(bit_vector_bytes);\n+    std::vector<uint32_t> hashes(batch.length);\n+    std::vector<uint8_t> bv(bit_vector_bytes);\n+\n+    RETURN_NOT_OK(InitLocalStateIfNeeded(thread_index));\n+    // Start with full selection for the current minibatch\n\nReview Comment:\n   ```suggestion\r\n       // Start with full selection for the current batch\r\n   ```\r\n   I'm pretty sure \"minibatch\" has a different meaning for when we split input up into size 1024 batches on the temp vector stack but I could be wrong.\n\n\n\n##########\ncpp/src/arrow/compute/exec/util.h:\n##########\n@@ -280,7 +282,7 @@ class AtomicCounter {\n   std::atomic<bool> complete_{false};\n };\n \n-class ThreadIndexer {\n+class ARROW_EXPORT ThreadIndexer {\n\nReview Comment:\n   Why is this getting exported?\n\n\n\n##########\ncpp/src/arrow/compute/exec/task_util.h:\n##########\n@@ -53,7 +53,7 @@ class AtomicWithPadding {\n //\n // Also allows for executing next pending tasks immediately using a caller thread.\n //\n-class TaskScheduler {\n+class ARROW_EXPORT TaskScheduler {\n\nReview Comment:\n   Why is this being exported?\n\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join_node_test.cc:\n##########\n@@ -1000,11 +1000,14 @@ TEST(HashJoin, Random) {\n   Random64Bit rng(42);\n #if defined(THREAD_SANITIZER) || defined(ARROW_VALGRIND)\n   const int num_tests = 15;\n+#elsif defined(ADDRESS_SANITIZER)\n\nReview Comment:\n   ```suggestion\r\n   #elif defined(ADDRESS_SANITIZER)\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/task_util.h:\n##########\n@@ -32,7 +32,7 @@ namespace compute {\n // whenever it is modified by a concurrent thread on a different CPU core.\n //\n template <typename T>\n-class AtomicWithPadding {\n+class ARROW_EXPORT AtomicWithPadding {\n\nReview Comment:\n   Why is this being exported?\n\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join.cc:\n##########\n@@ -809,22 +1009,40 @@ class HashJoinBasicImpl : public HashJoinImpl {\n                                       ScanHashTable_num_tasks());\n   }\n \n-  bool QueueBatchIfNeeded(int side, ExecBatch batch) {\n+  Result<bool> QueueBatchIfNeeded(size_t thread_index, int side, ExecBatch& batch) {\n     if (side == 0) {\n-      std::lock_guard<std::mutex> lock(left_batches_mutex_);\n-      if (has_hash_table_) {\n-        return false;\n+      // We don't want to do the filtering while holding the lock, since that can get\n+      // expensive.\n+      bool needs_filtering;\n+      {\n+        std::lock_guard<std::mutex> lock(left_batches_mutex_);\n+        bloom_filters_ready_ = bloom_filters_ready_ || num_expected_bloom_filters_ == 0;\n+        needs_filtering = bloom_filters_ready_ && num_expected_bloom_filters_ != 0;\n       }\n-      left_batches_.emplace_back(std::move(batch));\n-      return true;\n+      if (needs_filtering) RETURN_NOT_OK(ApplyBloomFiltersToBatch(thread_index, batch));\n\nReview Comment:\n   ```suggestion\r\n         if (needs_filtering)\r\n         {\r\n             RETURN_NOT_OK(ApplyBloomFiltersToBatch(thread_index, batch));\r\n             return false;\r\n         }\r\n   ```\n\n\n\n",
                    "created": "2022-05-09T21:50:53.763+0000",
                    "updated": "2022-05-09T21:50:53.763+0000",
                    "started": "2022-05-09T21:50:53.763+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "768206",
                    "issueId": "13425500"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13425500/worklog/768209",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #12289:\nURL: https://github.com/apache/arrow/pull/12289#discussion_r868526933\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join.cc:\n##########\n@@ -604,8 +654,84 @@ class HashJoinBasicImpl : public HashJoinImpl {\n     return Status::OK();\n   }\n \n+  Status ApplyBloomFiltersToBatch(size_t thread_index, ExecBatch& batch) {\n+    if (batch.length == 0) return Status::OK();\n+    int64_t bit_vector_bytes = bit_util::BytesForBits(batch.length);\n+    std::vector<uint8_t> selected(bit_vector_bytes);\n+    std::vector<uint32_t> hashes(batch.length);\n+    std::vector<uint8_t> bv(bit_vector_bytes);\n+\n+    RETURN_NOT_OK(InitLocalStateIfNeeded(thread_index));\n+    // Start with full selection for the current minibatch\n\nReview Comment:\n   Yes, you're right \n\n\n\n",
                    "created": "2022-05-09T22:17:46.034+0000",
                    "updated": "2022-05-09T22:17:46.034+0000",
                    "started": "2022-05-09T22:17:46.034+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "768209",
                    "issueId": "13425500"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13425500/worklog/768210",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #12289:\nURL: https://github.com/apache/arrow/pull/12289#discussion_r868529898\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join.cc:\n##########\n@@ -651,23 +777,44 @@ class HashJoinBasicImpl : public HashJoinImpl {\n     return Status::OK();\n   }\n \n+  Status BuildBloomFilter_on_finished(size_t thread_index) {\n+    if (cancelled_) return Status::Cancelled(\"Hash join cancelled\");\n+    ARROW_DCHECK(pushdown_target_);\n+    RETURN_NOT_OK(pushdown_target_->PushBloomFilter(\n+        thread_index, std::move(bloom_filter_), std::move(column_map_)));\n+    return BuildHashTable(thread_index);\n+  }\n+\n   Status BuildHashTable_on_finished(size_t thread_index) {\n     if (cancelled_) {\n       return Status::Cancelled(\"Hash join cancelled\");\n     }\n \n+    bool proceed;\n     {\n       std::lock_guard<std::mutex> lock(left_batches_mutex_);\n+      std::lock_guard<std::mutex> lock_finish(finished_mutex_);\n+      left_queue_bloom_finished_ =\n+          left_queue_bloom_finished_ || num_expected_bloom_filters_ == 0;\n+      proceed = !has_hash_table_ && left_queue_bloom_finished_;\n       has_hash_table_ = true;\n     }\n+    if (proceed) RETURN_NOT_OK(ProbeQueuedBatches(thread_index));\n \n     right_batches_.clear();\n\nReview Comment:\n   Seems harmless, I'll do that.\n\n\n\n",
                    "created": "2022-05-09T22:21:11.271+0000",
                    "updated": "2022-05-09T22:21:11.271+0000",
                    "started": "2022-05-09T22:21:11.271+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "768210",
                    "issueId": "13425500"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13425500/worklog/768211",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #12289:\nURL: https://github.com/apache/arrow/pull/12289#discussion_r868532412\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join.cc:\n##########\n@@ -809,22 +1009,40 @@ class HashJoinBasicImpl : public HashJoinImpl {\n                                       ScanHashTable_num_tasks());\n   }\n \n-  bool QueueBatchIfNeeded(int side, ExecBatch batch) {\n+  Result<bool> QueueBatchIfNeeded(size_t thread_index, int side, ExecBatch& batch) {\n     if (side == 0) {\n-      std::lock_guard<std::mutex> lock(left_batches_mutex_);\n-      if (has_hash_table_) {\n-        return false;\n+      // We don't want to do the filtering while holding the lock, since that can get\n+      // expensive.\n+      bool needs_filtering;\n+      {\n+        std::lock_guard<std::mutex> lock(left_batches_mutex_);\n+        bloom_filters_ready_ = bloom_filters_ready_ || num_expected_bloom_filters_ == 0;\n+        needs_filtering = bloom_filters_ready_ && num_expected_bloom_filters_ != 0;\n       }\n-      left_batches_.emplace_back(std::move(batch));\n-      return true;\n+      if (needs_filtering) RETURN_NOT_OK(ApplyBloomFiltersToBatch(thread_index, batch));\n\nReview Comment:\n   I don't think this is correct because we still want to enqueue the probe-side batch after we've filtered it.\n\n\n\n",
                    "created": "2022-05-09T22:24:01.954+0000",
                    "updated": "2022-05-09T22:24:01.954+0000",
                    "started": "2022-05-09T22:24:01.954+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "768211",
                    "issueId": "13425500"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13425500/worklog/768212",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #12289:\nURL: https://github.com/apache/arrow/pull/12289#discussion_r868536793\n\n\n##########\ncpp/src/arrow/compute/exec/util.h:\n##########\n@@ -280,7 +282,7 @@ class AtomicCounter {\n   std::atomic<bool> complete_{false};\n };\n \n-class ThreadIndexer {\n+class ARROW_EXPORT ThreadIndexer {\n\nReview Comment:\n   I probably had some error somewhere on Windows. I can probably remove these exports and see what breaks and re-add only the necessary ones.\n\n\n\n",
                    "created": "2022-05-09T22:29:22.189+0000",
                    "updated": "2022-05-09T22:29:22.189+0000",
                    "started": "2022-05-09T22:29:22.188+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "768212",
                    "issueId": "13425500"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13425500/worklog/768218",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #12289:\nURL: https://github.com/apache/arrow/pull/12289#discussion_r868582022\n\n\n##########\ncpp/src/arrow/compute/exec/util.h:\n##########\n@@ -280,7 +282,7 @@ class AtomicCounter {\n   std::atomic<bool> complete_{false};\n };\n \n-class ThreadIndexer {\n+class ARROW_EXPORT ThreadIndexer {\n\nReview Comment:\n   https://github.com/apache/arrow/runs/6360766271?check_suite_focus=true\n\n\n\n",
                    "created": "2022-05-09T23:21:53.277+0000",
                    "updated": "2022-05-09T23:21:53.277+0000",
                    "started": "2022-05-09T23:21:53.276+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "768218",
                    "issueId": "13425500"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 18600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@5cdb354f[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@206adcac[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3a01410d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@4cf8655d[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@497431b8[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@5d426815[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6dfb5399[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@622601f6[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@ab705fb[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@447bc678[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@73ab22f5[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@21d0b4c7[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 18600,
        "customfield_12312520": null,
        "customfield_12312521": "Wed May 18 04:02:05 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-05-18T04:02:05.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15498/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2022-01-28T23:24:04.000+0000",
        "updated": "2022-05-18T14:42:05.000+0000",
        "timeoriginalestimate": null,
        "description": "When there is a chain of hash joins, it's often worthwhile to create Bloom filters and push them to the earliest possible point in the chain of joins to minimize number of materialized rows.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "5h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 18600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Compute] Implement Bloom filter pushdown between hash joins ",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13425500/comment/17538561",
                    "id": "17538561",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Issue resolved by pull request 12289\n[https://github.com/apache/arrow/pull/12289]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-05-18T04:02:05.643+0000",
                    "updated": "2022-05-18T04:02:05.643+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0z2jc:",
        "customfield_12314139": null
    }
}