{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13111093",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093",
    "key": "ARROW-1699",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12350591",
                "id": "12350591",
                "description": "",
                "name": "7.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-02-03"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "analytics",
            "dataframe",
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12589303",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12589303",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "inwardIssue": {
                    "id": "13306872",
                    "key": "ARROW-8894",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13306872",
                    "fields": {
                        "summary": "[C++] C++ array kernels framework and execution buildout (umbrella issue)",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=alvinj15",
            "name": "alvinj15",
            "key": "JIRAUSER280323",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Alvin Chunga Mamani",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 23400,
            "total": 23400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 23400,
            "total": 23400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1699/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 39,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/worklog/690281",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "AlvinJ15 opened a new pull request #11853:\nURL: https://github.com/apache/arrow/pull/11853\n\n\n   ARROW-1699: [C++] forward, backward fill kernel functions\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-03T19:25:54.912+0000",
                    "updated": "2021-12-03T19:25:54.912+0000",
                    "started": "2021-12-03T19:25:54.912+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "690281",
                    "issueId": "13111093"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/worklog/690282",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #11853:\nURL: https://github.com/apache/arrow/pull/11853#issuecomment-985771524\n\n\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-03T19:26:07.963+0000",
                    "updated": "2021-12-03T19:26:07.963+0000",
                    "started": "2021-12-03T19:26:07.963+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "690282",
                    "issueId": "13111093"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/worklog/691282",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11853:\nURL: https://github.com/apache/arrow/pull/11853#discussion_r763225230\n\n\n\n##########\nFile path: cpp/src/arrow/compute/registry.cc\n##########\n@@ -175,6 +175,8 @@ static std::unique_ptr<FunctionRegistry> CreateBuiltInRegistry() {\n   RegisterVectorHash(registry.get());\n   RegisterVectorNested(registry.get());\n   RegisterVectorReplace(registry.get());\n+  RegisterVectorFillForwardNullValues(registry.get());\n+  RegisterVectorFillBackwardNullValues(registry.get());\n\nReview comment:\n       nit: just call these from RegisterVectorReplace instead of adding them here and below\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -444,6 +456,225 @@ struct ReplaceWithMaskFunctor {\n   }\n };\n \n+template <typename Type>\n+void fillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t incrementer) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values, 0, array, 0, array.length);\n+\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+  int64_t write_offset = incrementer == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + incrementer * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n+        for (int64_t i = 0; i != block.length; i++) {\n+          uint64_t write_value_offset = write_offset + incrementer * bitmap_offset;\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              array, current_value_offset, /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            current_value_offset = write_value_offset;\n+          }\n+          bitmap_offset += 1;\n+        }\n+      } else {\n+        auto in = *(array_scalars->GetScalar(current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_offset, *in,\n+                                        current_value_offset, block.length);\n+        bitmap_offset += block.length;\n+      }\n+      write_offset += block.length * incrementer;\n+    }\n+  }\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n\nReview comment:\n       Null arrays can never contain anything but null, so you can just no-op here.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -326,6 +326,12 @@ struct ReplaceWithMask<Type, enable_if_null<Type>> {\n     *output = array;\n     return Status::OK();\n   }\n+  static void CopyData(const DataType&, uint8_t* out, const int64_t out_offset,\n+                       const ArrayData& in, const int64_t in_offset,\n+                       const int64_t length) {}\n+\n+  static void CopyData(const DataType&, uint8_t* out, const int64_t out_offset,\n+                       const Scalar& in, const int64_t in_offset, const int64_t length) {}\n\nReview comment:\n       This should be unnecessary if the NullType case is just a no-op.\n\n##########\nFile path: cpp/src/arrow/util/bitmap_ops.cc\n##########\n@@ -84,15 +84,26 @@ int64_t CountSetBits(const uint8_t* data, int64_t bit_offset, int64_t length) {\n   return count;\n }\n \n-enum class TransferMode : bool { Copy, Invert };\n+enum class TransferMode : char { Copy, Invert, Revert };\n+\n+uint8_t revert_uint8(uint8_t num) {\n\nReview comment:\n       Ditto comment about function naming here.\n\n##########\nFile path: cpp/src/arrow/util/bitmap_ops.cc\n##########\n@@ -84,15 +84,26 @@ int64_t CountSetBits(const uint8_t* data, int64_t bit_offset, int64_t length) {\n   return count;\n }\n \n-enum class TransferMode : bool { Copy, Invert };\n+enum class TransferMode : char { Copy, Invert, Revert };\n+\n+uint8_t revert_uint8(uint8_t num) {\n+  num = ((num & 0xf0) >> 4) | ((num & 0x0f) << 4);\n+  num = ((num & 0xcc) >> 2) | ((num & 0x33) << 2);\n+  num = ((num & 0xaa) >> 1) | ((num & 0x55) << 1);\n+  return num;\n+}\n+\n+uint8_t get_reverted_block(uint8_t block_left, uint8_t block_right, uint8_t length) {\n+  return revert_uint8(block_left >> (length) | block_right << (8 - length));\n+}\n \n template <TransferMode mode>\n void TransferBitmap(const uint8_t* data, int64_t offset, int64_t length,\n\nReview comment:\n       Given that the bit-reverse mode has basically 0 in common with the other modes, maybe we can just keep it in an entirely separate function, i.e. use RevertBlockOffsets directly?\n\n##########\nFile path: cpp/src/arrow/util/bitmap_ops.cc\n##########\n@@ -84,15 +84,26 @@ int64_t CountSetBits(const uint8_t* data, int64_t bit_offset, int64_t length) {\n   return count;\n }\n \n-enum class TransferMode : bool { Copy, Invert };\n+enum class TransferMode : char { Copy, Invert, Revert };\n+\n+uint8_t revert_uint8(uint8_t num) {\n\nReview comment:\n       (This extends to e.g. variable names, parameter names, etc. above.)\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -444,6 +456,225 @@ struct ReplaceWithMaskFunctor {\n   }\n };\n \n+template <typename Type>\n+void fillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t incrementer) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values, 0, array, 0, array.length);\n+\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+  int64_t write_offset = incrementer == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + incrementer * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n+        for (int64_t i = 0; i != block.length; i++) {\n+          uint64_t write_value_offset = write_offset + incrementer * bitmap_offset;\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              array, current_value_offset, /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            current_value_offset = write_value_offset;\n+          }\n+          bitmap_offset += 1;\n+        }\n+      } else {\n+        auto in = *(array_scalars->GetScalar(current_value_offset));\n\nReview comment:\n       We can use the ArrayData overload of CopyData to avoid allocating a scalar in the first place.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -444,6 +456,225 @@ struct ReplaceWithMaskFunctor {\n   }\n };\n \n+template <typename Type>\n+void fillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t incrementer) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values, 0, array, 0, array.length);\n+\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+  int64_t write_offset = incrementer == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + incrementer * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n+        for (int64_t i = 0; i != block.length; i++) {\n+          uint64_t write_value_offset = write_offset + incrementer * bitmap_offset;\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              array, current_value_offset, /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            current_value_offset = write_value_offset;\n+          }\n+          bitmap_offset += 1;\n+        }\n+      } else {\n+        auto in = *(array_scalars->GetScalar(current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_offset, *in,\n+                                        current_value_offset, block.length);\n+        bitmap_offset += block.length;\n+      }\n+      write_offset += block.length * incrementer;\n+    }\n+  }\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t current_value_offset = 0;\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    bool has_fill_value = false;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+\n+    std::vector<std::pair<uint64_t, uint64_t>> offsets_reverted;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reverted_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reverted.push_back(std::make_pair(offset0, offset1 - offset0));\n+          current_value_offset = array_value_index;\n+          has_fill_value = true;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value) {\n+            const offset_type offset0 = offsets[current_value_offset];\n+            const offset_type offset1 = offsets[current_value_offset + 1];\n+            offsets_reverted.push_back(std::make_pair(offset0, offset1 - offset0));\n+          } else {\n+            offsets_reverted.push_back(std::make_pair(-1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reverted.begin(); it != offsets_reverted.end(); ++it) {\n+        if (it->first == -1U && it->second == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data + it->first, it->second));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reverted.rbegin(); it != offsets_reverted.rend(); ++it) {\n+        if (it->first == -1U && it->second == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data + it->first, it->second));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNull {\n+  static Status ExecForwardFillNull(KernelContext* ctx, const ArrayData& array,\n+                                    ArrayData* output) {\n+    if (array.MayHaveNulls()) {\n+      int8_t direction = 1;\n+      return FillNullExecutor<Type>::ExecFillNull(ctx, array, array.buffers[0]->data(),\n+                                                  output, direction);\n+    } else {\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status ExecBackwardFillNull(KernelContext* ctx, const ArrayData& array,\n+                                     ArrayData* output) {\n+    if (array.MayHaveNulls()) {\n+      int8_t direction = -1;\n+      auto memory_pool = ctx->memory_pool();\n+      auto reverted_bitmap = arrow::internal::CopyBitmap(\n+          memory_pool, array.buffers[0]->data(), array.offset, array.length);\n+      arrow::internal::RevertBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                                    reverted_bitmap.ValueOrDie()->mutable_data(),\n+                                    output->offset);\n\nReview comment:\n       Why not use the overload of RevertBitmap that returns a buffer?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -444,6 +456,225 @@ struct ReplaceWithMaskFunctor {\n   }\n };\n \n+template <typename Type>\n+void fillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t incrementer) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values, 0, array, 0, array.length);\n+\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+  int64_t write_offset = incrementer == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + incrementer * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n+        for (int64_t i = 0; i != block.length; i++) {\n+          uint64_t write_value_offset = write_offset + incrementer * bitmap_offset;\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              array, current_value_offset, /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            current_value_offset = write_value_offset;\n+          }\n+          bitmap_offset += 1;\n+        }\n+      } else {\n+        auto in = *(array_scalars->GetScalar(current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_offset, *in,\n+                                        current_value_offset, block.length);\n+        bitmap_offset += block.length;\n+      }\n+      write_offset += block.length * incrementer;\n+    }\n+  }\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t current_value_offset = 0;\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    bool has_fill_value = false;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+\n+    std::vector<std::pair<uint64_t, uint64_t>> offsets_reverted;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reverted_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reverted.push_back(std::make_pair(offset0, offset1 - offset0));\n+          current_value_offset = array_value_index;\n+          has_fill_value = true;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value) {\n+            const offset_type offset0 = offsets[current_value_offset];\n+            const offset_type offset1 = offsets[current_value_offset + 1];\n+            offsets_reverted.push_back(std::make_pair(offset0, offset1 - offset0));\n+          } else {\n+            offsets_reverted.push_back(std::make_pair(-1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reverted.begin(); it != offsets_reverted.end(); ++it) {\n+        if (it->first == -1U && it->second == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data + it->first, it->second));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reverted.rbegin(); it != offsets_reverted.rend(); ++it) {\n+        if (it->first == -1U && it->second == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data + it->first, it->second));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNull {\n+  static Status ExecForwardFillNull(KernelContext* ctx, const ArrayData& array,\n+                                    ArrayData* output) {\n+    if (array.MayHaveNulls()) {\n+      int8_t direction = 1;\n+      return FillNullExecutor<Type>::ExecFillNull(ctx, array, array.buffers[0]->data(),\n+                                                  output, direction);\n+    } else {\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status ExecBackwardFillNull(KernelContext* ctx, const ArrayData& array,\n+                                     ArrayData* output) {\n+    if (array.MayHaveNulls()) {\n+      int8_t direction = -1;\n+      auto memory_pool = ctx->memory_pool();\n+      auto reverted_bitmap = arrow::internal::CopyBitmap(\n+          memory_pool, array.buffers[0]->data(), array.offset, array.length);\n+      arrow::internal::RevertBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                                    reverted_bitmap.ValueOrDie()->mutable_data(),\n+                                    output->offset);\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, reverted_bitmap.ValueOrDie()->data(), output, direction);\n+    } else {\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ArrayData& array = *batch[0].array();\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+\n+    return FillNull<Type>::ExecForwardFillNull(ctx, array, output);\n\nReview comment:\n       Since everything is templated anyways, why not just inline FillNull into FillForwardFunctor/FillBackwardFunctor?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -500,6 +731,104 @@ void RegisterVectorReplace(FunctionRegistry* registry) {\n \n   // TODO(ARROW-9431): \"replace_with_indices\"\n }\n+\n+const FunctionDoc fill_forward_null_doc(\n+    \"Replace null values using forward mode\",\n+    (\"Given an array, propagate last valid observation forward to next valid\\n\"\n+     \"or nothing if all previous values are null. \"),\n+    {\"values\"});\n+\n+void RegisterVectorFillForwardNullValues(FunctionRegistry* registry) {\n\nReview comment:\n       We could consolidate these two registration functions:\r\n   \r\n   ```cpp\r\n   {\r\n     auto func = std::make_shared(...);\r\n     RegisterVectorFill<FillForwardFunctor>(func.get());\r\n     registry->AddFunction(std::move(func));\r\n   }\r\n   {\r\n     auto func = std::make_shared(...);\r\n     RegisterVectorFill<FillBackwardFunctor>(func.get());\r\n     registry->AddFunction(std::move(func));\r\n   }\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -410,6 +416,12 @@ struct ReplaceWithMask<Type, enable_if_base_binary<Type>> {\n     output->type = array.type;\n     return Status::OK();\n   }\n+  static void CopyData(const DataType&, uint8_t* out, const int64_t out_offset,\n+                       const ArrayData& in, const int64_t in_offset,\n+                       const int64_t length) {}\n+\n+  static void CopyData(const DataType&, uint8_t* out, const int64_t out_offset,\n+                       const Scalar& in, const int64_t in_offset, const int64_t length) {}\n\nReview comment:\n       Why are these needed? It seems this template shouldn't get instantiated below.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -444,6 +456,225 @@ struct ReplaceWithMaskFunctor {\n   }\n };\n \n+template <typename Type>\n+void fillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t incrementer) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values, 0, array, 0, array.length);\n+\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+  int64_t write_offset = incrementer == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + incrementer * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n+        for (int64_t i = 0; i != block.length; i++) {\n+          uint64_t write_value_offset = write_offset + incrementer * bitmap_offset;\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              array, current_value_offset, /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            current_value_offset = write_value_offset;\n+          }\n+          bitmap_offset += 1;\n+        }\n+      } else {\n+        auto in = *(array_scalars->GetScalar(current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_offset, *in,\n+                                        current_value_offset, block.length);\n+        bitmap_offset += block.length;\n+      }\n+      write_offset += block.length * incrementer;\n+    }\n+  }\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t current_value_offset = 0;\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    bool has_fill_value = false;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+\n+    std::vector<std::pair<uint64_t, uint64_t>> offsets_reverted;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n\nReview comment:\n       Instead of passing through the array twice/allocating an intermediate, why not append to the builder directly? We can also use VisitArrayValuesInline to get access to string_views instead of having to manipulate offsets manually.\n\n##########\nFile path: cpp/src/arrow/util/bitmap_ops.cc\n##########\n@@ -84,15 +84,26 @@ int64_t CountSetBits(const uint8_t* data, int64_t bit_offset, int64_t length) {\n   return count;\n }\n \n-enum class TransferMode : bool { Copy, Invert };\n+enum class TransferMode : char { Copy, Invert, Revert };\n+\n+uint8_t revert_uint8(uint8_t num) {\n+  num = ((num & 0xf0) >> 4) | ((num & 0x0f) << 4);\n+  num = ((num & 0xcc) >> 2) | ((num & 0x33) << 2);\n+  num = ((num & 0xaa) >> 1) | ((num & 0x55) << 1);\n+  return num;\n+}\n+\n+uint8_t get_reverted_block(uint8_t block_left, uint8_t block_right, uint8_t length) {\n\nReview comment:\n       Could a comment be added here to describe what this does/is it possible to name this in a way that is more clear about its function?\n\n##########\nFile path: cpp/src/arrow/util/bitmap_ops.h\n##########\n@@ -81,6 +81,40 @@ ARROW_EXPORT\n Result<std::shared_ptr<Buffer>> InvertBitmap(MemoryPool* pool, const uint8_t* bitmap,\n                                              int64_t offset, int64_t length);\n \n+/// Revert a bit range of an existing bitmap into an existing bitmap\n+///\n+/// \\param[in] bitmap source data\n+/// \\param[in] offset bit offset into the source data\n+/// \\param[in] length number of bits to revert\n+/// \\param[in] dest_offset bit offset into the destination\n+/// \\param[out] dest the destination buffer, must have at least space for\n+/// (offset + length) bits\n+ARROW_EXPORT\n+void RevertBitmap(const uint8_t* bitmap, int64_t offset, int64_t length, uint8_t* dest,\n+                  int64_t dest_offset);\n+\n+/// Revert a bit range of an existing bitmap\n+///\n+/// \\param[in] pool memory pool to allocate memory from\n+/// \\param[in] bitmap source data\n+/// \\param[in] offset bit offset into the source data\n+/// \\param[in] length number of bits to revert\n+///\n+/// \\return Status message\n+ARROW_EXPORT\n+Result<std::shared_ptr<Buffer>> RevertBitmap(MemoryPool* pool, const uint8_t* bitmap,\n+                                             int64_t offset, int64_t length);\n+\n+/// Revert a bit range of an existing bitmap into an existing bitmap\n+///\n+/// \\param[in] bitmap source data\n+/// \\param[in] offset bit offset into the source data\n+/// \\param[in] length number of bits to revert\n+/// \\param[in] dest_offset bit offset into the destination\n+/// \\param[out] dest the destination buffer, must have at least space for\n+/// (offset + length) bits\n+void RevertBlockOffsets(const uint8_t* data, int64_t offset, int64_t length,\n\nReview comment:\n       Does this need to be exposed publically? It seems redundant with ReverseBitmap.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -444,6 +456,225 @@ struct ReplaceWithMaskFunctor {\n   }\n };\n \n+template <typename Type>\n+void fillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t incrementer) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values, 0, array, 0, array.length);\n+\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+  int64_t write_offset = incrementer == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + incrementer * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n+        for (int64_t i = 0; i != block.length; i++) {\n+          uint64_t write_value_offset = write_offset + incrementer * bitmap_offset;\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              array, current_value_offset, /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            current_value_offset = write_value_offset;\n+          }\n+          bitmap_offset += 1;\n+        }\n+      } else {\n+        auto in = *(array_scalars->GetScalar(current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_offset, *in,\n+                                        current_value_offset, block.length);\n+        bitmap_offset += block.length;\n+      }\n+      write_offset += block.length * incrementer;\n+    }\n+  }\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    auto array_scalars = arrow::MakeArray(array.Copy());\n\nReview comment:\n       This is unused.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -444,6 +456,225 @@ struct ReplaceWithMaskFunctor {\n   }\n };\n \n+template <typename Type>\n+void fillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t incrementer) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values, 0, array, 0, array.length);\n\nReview comment:\n       When we have constants as parameters, try to prefix them with a comment indicating the parameter name: `/*out_offset=*/0`, `/*in_offset=*/0`\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -444,6 +456,225 @@ struct ReplaceWithMaskFunctor {\n   }\n };\n \n+template <typename Type>\n+void fillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t incrementer) {\n\nReview comment:\n       nit: incrementer -> direction?\n\n##########\nFile path: cpp/src/arrow/util/bitmap_ops.cc\n##########\n@@ -84,15 +84,26 @@ int64_t CountSetBits(const uint8_t* data, int64_t bit_offset, int64_t length) {\n   return count;\n }\n \n-enum class TransferMode : bool { Copy, Invert };\n+enum class TransferMode : char { Copy, Invert, Revert };\n+\n+uint8_t revert_uint8(uint8_t num) {\n\nReview comment:\n       Also, in general, instead of \"revert\", can we call it \"reverse\" or possibly \"flip\"?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace_test.cc\n##########\n@@ -798,5 +812,284 @@ TYPED_TEST(TestReplaceBinary, ReplaceWithMaskRandom) {\n   }\n }\n \n+template <typename T>\n+class TestFillNullForwardNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullForwardDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullForwardBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBackwardNumeric : public TestReplaceKernel<T> {\n\nReview comment:\n       Why have separate classes for forward/backward?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -444,6 +456,225 @@ struct ReplaceWithMaskFunctor {\n   }\n };\n \n+template <typename Type>\n+void fillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n\nReview comment:\n       Note: in general, function/method/class names should use UpperCamelCase naming according to our [style guide](https://arrow.apache.org/docs/developers/cpp/development.html#code-style-linting-and-ci).\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-06T18:34:13.326+0000",
                    "updated": "2021-12-06T18:34:13.326+0000",
                    "started": "2021-12-06T18:34:13.325+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "691282",
                    "issueId": "13111093"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/worklog/692278",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "AlvinJ15 commented on a change in pull request #11853:\nURL: https://github.com/apache/arrow/pull/11853#discussion_r764616914\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -444,6 +456,225 @@ struct ReplaceWithMaskFunctor {\n   }\n };\n \n+template <typename Type>\n+void fillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t incrementer) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values, 0, array, 0, array.length);\n+\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+  int64_t write_offset = incrementer == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + incrementer * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n+        for (int64_t i = 0; i != block.length; i++) {\n+          uint64_t write_value_offset = write_offset + incrementer * bitmap_offset;\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              array, current_value_offset, /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            current_value_offset = write_value_offset;\n+          }\n+          bitmap_offset += 1;\n+        }\n+      } else {\n+        auto in = *(array_scalars->GetScalar(current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_offset, *in,\n+                                        current_value_offset, block.length);\n+        bitmap_offset += block.length;\n+      }\n+      write_offset += block.length * incrementer;\n+    }\n+  }\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n\nReview comment:\n       This is for boolean arrays:\r\n   ```\r\n   template <typename Type>\r\n   struct FillNullExecutor<Type, enable_if_boolean<Type>> {\r\n     static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\r\n                                const uint8_t* reversed_bitmap, ArrayData* output,\r\n                                uint8_t direction) {\r\n       FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction);\r\n       return Status::OK();\r\n     }\r\n   };\r\n   ```\r\n   For null arrays the function does nothing and return the original array.\r\n   ```\r\n   template <typename Type>\r\n   struct FillNullExecutor<Type, enable_if_null<Type>> {\r\n     static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\r\n                                const uint8_t* reversed_bitmap, ArrayData* output,\r\n                                uint8_t direction) {\r\n       *output = array;\r\n       return Status::OK();\r\n     }\r\n   };\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-08T07:46:20.430+0000",
                    "updated": "2021-12-08T07:46:20.430+0000",
                    "started": "2021-12-08T07:46:20.430+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "692278",
                    "issueId": "13111093"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/worklog/692282",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "AlvinJ15 commented on a change in pull request #11853:\nURL: https://github.com/apache/arrow/pull/11853#discussion_r764620164\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -500,6 +731,104 @@ void RegisterVectorReplace(FunctionRegistry* registry) {\n \n   // TODO(ARROW-9431): \"replace_with_indices\"\n }\n+\n+const FunctionDoc fill_forward_null_doc(\n+    \"Replace null values using forward mode\",\n+    (\"Given an array, propagate last valid observation forward to next valid\\n\"\n+     \"or nothing if all previous values are null. \"),\n+    {\"values\"});\n+\n+void RegisterVectorFillForwardNullValues(FunctionRegistry* registry) {\n\nReview comment:\n       Now I remove both `RegisterVectorFill*NullValues` and put them into ReplaceVector.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-08T07:52:15.260+0000",
                    "updated": "2021-12-08T07:52:15.260+0000",
                    "started": "2021-12-08T07:52:15.259+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "692282",
                    "issueId": "13111093"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/worklog/692283",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "AlvinJ15 commented on a change in pull request #11853:\nURL: https://github.com/apache/arrow/pull/11853#discussion_r764620164\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -500,6 +731,104 @@ void RegisterVectorReplace(FunctionRegistry* registry) {\n \n   // TODO(ARROW-9431): \"replace_with_indices\"\n }\n+\n+const FunctionDoc fill_forward_null_doc(\n+    \"Replace null values using forward mode\",\n+    (\"Given an array, propagate last valid observation forward to next valid\\n\"\n+     \"or nothing if all previous values are null. \"),\n+    {\"values\"});\n+\n+void RegisterVectorFillForwardNullValues(FunctionRegistry* registry) {\n\nReview comment:\n       Now I removed both `RegisterVectorFill*NullValues` and put them into ReplaceVector.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-08T07:52:30.931+0000",
                    "updated": "2021-12-08T07:52:30.931+0000",
                    "started": "2021-12-08T07:52:30.931+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "692283",
                    "issueId": "13111093"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/worklog/692543",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11853:\nURL: https://github.com/apache/arrow/pull/11853#discussion_r764851344\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -444,6 +456,225 @@ struct ReplaceWithMaskFunctor {\n   }\n };\n \n+template <typename Type>\n+void fillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t incrementer) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values, 0, array, 0, array.length);\n+\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+  int64_t write_offset = incrementer == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + incrementer * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n+        for (int64_t i = 0; i != block.length; i++) {\n+          uint64_t write_value_offset = write_offset + incrementer * bitmap_offset;\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              array, current_value_offset, /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            current_value_offset = write_value_offset;\n+          }\n+          bitmap_offset += 1;\n+        }\n+      } else {\n+        auto in = *(array_scalars->GetScalar(current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_offset, *in,\n+                                        current_value_offset, block.length);\n+        bitmap_offset += block.length;\n+      }\n+      write_offset += block.length * incrementer;\n+    }\n+  }\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n\nReview comment:\n       Ah whoops, right. Sorry for the confusion.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-08T13:11:44.149+0000",
                    "updated": "2021-12-08T13:11:44.149+0000",
                    "started": "2021-12-08T13:11:44.149+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "692543",
                    "issueId": "13111093"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/worklog/692991",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "AlvinJ15 commented on pull request #11853:\nURL: https://github.com/apache/arrow/pull/11853#issuecomment-989538380\n\n\n   @lidavidm  all comments were solved\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-09T05:55:30.892+0000",
                    "updated": "2021-12-09T05:55:30.892+0000",
                    "started": "2021-12-09T05:55:30.892+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "692991",
                    "issueId": "13111093"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/worklog/693246",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11853:\nURL: https://github.com/apache/arrow/pull/11853#discussion_r765779187\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,231 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n\nReview comment:\n       Please add a comment noting that this is for fixed-size types only.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,231 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/0, array, /*in_offset=*/0, array.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + direction * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n+        for (int64_t i = 0; i != block.length; i++) {\n+          uint64_t write_value_offset = write_offset + direction * bitmap_offset;\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              array, current_value_offset, /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            current_value_offset = write_value_offset;\n+          }\n+          bitmap_offset += 1;\n+        }\n+      } else {\n+        auto in = *(array_scalars->GetScalar(current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_offset, *in,\n+                                        current_value_offset, block.length);\n+        bitmap_offset += block.length;\n+      }\n+      write_offset += block.length * direction;\n+    }\n+  }\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t current_value_offset = 0;\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    bool has_fill_value = false;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+\n+    std::vector<std::pair<uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(std::make_pair(offset0, offset1 - offset0));\n+          current_value_offset = array_value_index;\n+          has_fill_value = true;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value) {\n+            const offset_type offset0 = offsets[current_value_offset];\n+            const offset_type offset1 = offsets[current_value_offset + 1];\n+            offsets_reversed.push_back(std::make_pair(offset0, offset1 - offset0));\n+          } else {\n+            offsets_reversed.push_back(std::make_pair(-1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (it->first == -1U && it->second == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data + it->first, it->second));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (it->first == -1U && it->second == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data + it->first, it->second));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ArrayData& array = *batch[0].array();\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+\n+    if (array.MayHaveNulls()) {\n+      int8_t direction = 1;\n+      return FillNullExecutor<Type>::ExecFillNull(ctx, array, array.buffers[0]->data(),\n+                                                  output, direction);\n+    } else {\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id)}, OutputType(FirstType));\n+  }\n+};\n+\n+template <typename Type>\n+struct FillBackwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ArrayData& array = *batch[0].array();\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+\n+    if (array.MayHaveNulls()) {\n+      int8_t direction = -1;\n+      auto reversed_bitmap = arrow::internal::ReverseBitmap(\n+          ctx->memory_pool(), array.buffers[0]->data(), array.offset, array.length);\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, reversed_bitmap.ValueOrDie()->data(), output, direction);\n\nReview comment:\n       Use ARROW_ASSIGN_OR_RAISE, not ValueOrDie.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,231 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/0, array, /*in_offset=*/0, array.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + direction * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n\nReview comment:\n       nit: this can just be one if-else if-else instead of a nested if-else\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,231 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/0, array, /*in_offset=*/0, array.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n\nReview comment:\n       We can just use OptionalBitBlockCounter.\n\n##########\nFile path: cpp/src/arrow/util/bitmap_ops.cc\n##########\n@@ -177,6 +240,21 @@ Result<std::shared_ptr<Buffer>> InvertBitmap(MemoryPool* pool, const uint8_t* da\n   return TransferBitmap<TransferMode::Invert>(pool, data, offset, length);\n }\n \n+Result<std::shared_ptr<Buffer>> ReverseBitmap(MemoryPool* pool, const uint8_t* data,\n+                                              int64_t offset, int64_t length) {\n+  ARROW_ASSIGN_OR_RAISE(auto buffer, AllocateEmptyBitmap(length, pool));\n+  uint8_t* dest = buffer->mutable_data();\n+\n+  ReverseBlockOffsets(data, offset, length, /*start_offset=*/0, dest);\n+\n+  int64_t num_bytes = bit_util::BytesForBits(length);\n+  int64_t bits_to_zero = num_bytes * 8 - length;\n+  for (int64_t i = length; i < length + bits_to_zero; ++i) {\n+    bit_util::ClearBit(dest, i);\n+  }\n\nReview comment:\n       AllocateEmptyBitmap already zero-initializes the buffer.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,231 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/0, array, /*in_offset=*/0, array.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + direction * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n+        for (int64_t i = 0; i != block.length; i++) {\n+          uint64_t write_value_offset = write_offset + direction * bitmap_offset;\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              array, current_value_offset, /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            current_value_offset = write_value_offset;\n+          }\n+          bitmap_offset += 1;\n+        }\n+      } else {\n+        auto in = *(array_scalars->GetScalar(current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_offset, *in,\n+                                        current_value_offset, block.length);\n+        bitmap_offset += block.length;\n+      }\n+      write_offset += block.length * direction;\n+    }\n+  }\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t current_value_offset = 0;\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    bool has_fill_value = false;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+\n+    std::vector<std::pair<uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(std::make_pair(offset0, offset1 - offset0));\n+          current_value_offset = array_value_index;\n+          has_fill_value = true;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value) {\n+            const offset_type offset0 = offsets[current_value_offset];\n+            const offset_type offset1 = offsets[current_value_offset + 1];\n+            offsets_reversed.push_back(std::make_pair(offset0, offset1 - offset0));\n+          } else {\n+            offsets_reversed.push_back(std::make_pair(-1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (it->first == -1U && it->second == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data + it->first, it->second));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (it->first == -1U && it->second == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data + it->first, it->second));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ArrayData& array = *batch[0].array();\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+\n+    if (array.MayHaveNulls()) {\n+      int8_t direction = 1;\n+      return FillNullExecutor<Type>::ExecFillNull(ctx, array, array.buffers[0]->data(),\n+                                                  output, direction);\n+    } else {\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id)}, OutputType(FirstType));\n+  }\n+};\n+\n+template <typename Type>\n+struct FillBackwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ArrayData& array = *batch[0].array();\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+\n+    if (array.MayHaveNulls()) {\n+      int8_t direction = -1;\n+      auto reversed_bitmap = arrow::internal::ReverseBitmap(\n+          ctx->memory_pool(), array.buffers[0]->data(), array.offset, array.length);\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, reversed_bitmap.ValueOrDie()->data(), output, direction);\n\nReview comment:\n       ```suggestion\r\n         ARROW_ASSIGN_OR_RAISE(auto reversed_bitmap, arrow::internal::ReverseBitmap(\r\n             ctx->memory_pool(), array.buffers[0]->data(), array.offset, array.length));\r\n         return FillNullExecutor<Type>::ExecFillNull(\r\n             ctx, array, reversed_bitmap->data(), output, direction);\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,231 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/0, array, /*in_offset=*/0, array.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + direction * (block.length - 1);\n\nReview comment:\n       has_fill_value = true?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace_test.cc\n##########\n@@ -798,5 +812,284 @@ TYPED_TEST(TestReplaceBinary, ReplaceWithMaskRandom) {\n   }\n }\n \n+template <typename T>\n+class TestFillNullForwardNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullForwardDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullForwardBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBackwardNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBackwardDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBackwardBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+TYPED_TEST_SUITE(TestFillNullForwardNumeric, NumericBasedTypes);\n+TYPED_TEST_SUITE(TestFillNullForwardDecimal, DecimalArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullForwardBinary, BaseBinaryArrowTypes);\n+\n+TYPED_TEST_SUITE(TestFillNullBackwardNumeric, NumericBasedTypes);\n+TYPED_TEST_SUITE(TestFillNullBackwardDecimal, DecimalArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullBackwardBinary, BaseBinaryArrowTypes);\n+\n+TYPED_TEST(TestFillNullForwardNumeric, FillNullValuesForward) {\n\nReview comment:\n       Also, we should test ChunkedArray inputs.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace_test.cc\n##########\n@@ -798,5 +812,284 @@ TYPED_TEST(TestReplaceBinary, ReplaceWithMaskRandom) {\n   }\n }\n \n+template <typename T>\n+class TestFillNullForwardNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullForwardDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullForwardBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBackwardNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBackwardDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBackwardBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+TYPED_TEST_SUITE(TestFillNullForwardNumeric, NumericBasedTypes);\n+TYPED_TEST_SUITE(TestFillNullForwardDecimal, DecimalArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullForwardBinary, BaseBinaryArrowTypes);\n+\n+TYPED_TEST_SUITE(TestFillNullBackwardNumeric, NumericBasedTypes);\n+TYPED_TEST_SUITE(TestFillNullBackwardDecimal, DecimalArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullBackwardBinary, BaseBinaryArrowTypes);\n+\n+TYPED_TEST(TestFillNullForwardNumeric, FillNullValuesForward) {\n\nReview comment:\n       Can we also add tests where the input array is sliced?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -444,6 +456,225 @@ struct ReplaceWithMaskFunctor {\n   }\n };\n \n+template <typename Type>\n+void fillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t incrementer) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values, 0, array, 0, array.length);\n+\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+  int64_t write_offset = incrementer == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + incrementer * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n+        for (int64_t i = 0; i != block.length; i++) {\n+          uint64_t write_value_offset = write_offset + incrementer * bitmap_offset;\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              array, current_value_offset, /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            current_value_offset = write_value_offset;\n+          }\n+          bitmap_offset += 1;\n+        }\n+      } else {\n+        auto in = *(array_scalars->GetScalar(current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_offset, *in,\n+                                        current_value_offset, block.length);\n+        bitmap_offset += block.length;\n+      }\n+      write_offset += block.length * incrementer;\n+    }\n+  }\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t current_value_offset = 0;\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    bool has_fill_value = false;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+\n+    std::vector<std::pair<uint64_t, uint64_t>> offsets_reverted;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n\nReview comment:\n       Ah wait, we can't use VisitArrayValuesInline. But I don't think we need to pass through the array twice or allocate an intermediate here.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace_test.cc\n##########\n@@ -798,5 +812,284 @@ TYPED_TEST(TestReplaceBinary, ReplaceWithMaskRandom) {\n   }\n }\n \n+template <typename T>\n+class TestFillNullForwardNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullForwardDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullForwardBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBackwardNumeric : public TestReplaceKernel<T> {\n\nReview comment:\n       Reminder here.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace_test.cc\n##########\n@@ -798,5 +812,284 @@ TYPED_TEST(TestReplaceBinary, ReplaceWithMaskRandom) {\n   }\n }\n \n+template <typename T>\n+class TestFillNullForwardNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullForwardDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullForwardBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBackwardNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBackwardDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBackwardBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+TYPED_TEST_SUITE(TestFillNullForwardNumeric, NumericBasedTypes);\n+TYPED_TEST_SUITE(TestFillNullForwardDecimal, DecimalArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullForwardBinary, BaseBinaryArrowTypes);\n+\n+TYPED_TEST_SUITE(TestFillNullBackwardNumeric, NumericBasedTypes);\n+TYPED_TEST_SUITE(TestFillNullBackwardDecimal, DecimalArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullBackwardBinary, BaseBinaryArrowTypes);\n+\n+TYPED_TEST(TestFillNullForwardNumeric, FillNullValuesForward) {\n\nReview comment:\n       Can we add tests with all-valid values?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -444,6 +456,225 @@ struct ReplaceWithMaskFunctor {\n   }\n };\n \n+template <typename Type>\n+void fillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t incrementer) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values, 0, array, 0, array.length);\n+\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+  int64_t write_offset = incrementer == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + incrementer * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n+        for (int64_t i = 0; i != block.length; i++) {\n+          uint64_t write_value_offset = write_offset + incrementer * bitmap_offset;\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              array, current_value_offset, /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            current_value_offset = write_value_offset;\n+          }\n+          bitmap_offset += 1;\n+        }\n+      } else {\n+        auto in = *(array_scalars->GetScalar(current_value_offset));\n\nReview comment:\n       Reminder here. I don't think we need to allocate an extra scalar.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,231 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/0, array, /*in_offset=*/0, array.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + direction * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n+        for (int64_t i = 0; i != block.length; i++) {\n+          uint64_t write_value_offset = write_offset + direction * bitmap_offset;\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              array, current_value_offset, /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            current_value_offset = write_value_offset;\n+          }\n+          bitmap_offset += 1;\n+        }\n+      } else {\n+        auto in = *(array_scalars->GetScalar(current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_offset, *in,\n+                                        current_value_offset, block.length);\n+        bitmap_offset += block.length;\n+      }\n+      write_offset += block.length * direction;\n+    }\n+  }\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t current_value_offset = 0;\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    bool has_fill_value = false;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+\n+    std::vector<std::pair<uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(std::make_pair(offset0, offset1 - offset0));\n+          current_value_offset = array_value_index;\n+          has_fill_value = true;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value) {\n+            const offset_type offset0 = offsets[current_value_offset];\n+            const offset_type offset1 = offsets[current_value_offset + 1];\n+            offsets_reversed.push_back(std::make_pair(offset0, offset1 - offset0));\n+          } else {\n+            offsets_reversed.push_back(std::make_pair(-1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (it->first == -1U && it->second == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data + it->first, it->second));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (it->first == -1U && it->second == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data + it->first, it->second));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ArrayData& array = *batch[0].array();\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+\n+    if (array.MayHaveNulls()) {\n+      int8_t direction = 1;\n+      return FillNullExecutor<Type>::ExecFillNull(ctx, array, array.buffers[0]->data(),\n+                                                  output, direction);\n+    } else {\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id)}, OutputType(FirstType));\n+  }\n+};\n+\n+template <typename Type>\n+struct FillBackwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ArrayData& array = *batch[0].array();\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+\n+    if (array.MayHaveNulls()) {\n+      int8_t direction = -1;\n+      auto reversed_bitmap = arrow::internal::ReverseBitmap(\n+          ctx->memory_pool(), array.buffers[0]->data(), array.offset, array.length);\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, reversed_bitmap.ValueOrDie()->data(), output, direction);\n+    } else {\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id)}, OutputType(FirstType));\n+  }\n+};\n+}  // namespace\n+\n+template <template <class> class Functor,\n+class FixedType = FixedSizeBinaryType>\n\nReview comment:\n       Why is FixedType templated?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,231 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/0, array, /*in_offset=*/0, array.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + direction * (block.length - 1);\n\nReview comment:\n       And this should update bitmap_offset. (Or really, it should be updated at the bottom along with write_offset.)\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,231 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/0, array, /*in_offset=*/0, array.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n\nReview comment:\n       Or really, just BitBlockCounter, we should never get here if null_bitmap == nullptr.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,231 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n\nReview comment:\n       GetParameters -> GetSignature?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,231 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/0, array, /*in_offset=*/0, array.length);\n\nReview comment:\n       out_offset should be output->offset and in_offset should be array.offset.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,231 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/0, array, /*in_offset=*/0, array.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n\nReview comment:\n       This loop condition could be simplified if we tracked bitmap_offset instead, no?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,231 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/0, array, /*in_offset=*/0, array.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + direction * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n+        for (int64_t i = 0; i != block.length; i++) {\n+          uint64_t write_value_offset = write_offset + direction * bitmap_offset;\n\nReview comment:\n       Shouldn't this be `write_offset + direction * i`?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,231 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/0, array, /*in_offset=*/0, array.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + direction * (block.length - 1);\n\nReview comment:\n       We should also have a unit test that covers this case.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-09T13:43:37.395+0000",
                    "updated": "2021-12-09T13:43:37.395+0000",
                    "started": "2021-12-09T13:43:37.394+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "693246",
                    "issueId": "13111093"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/worklog/693400",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on pull request #11853:\nURL: https://github.com/apache/arrow/pull/11853#issuecomment-990036247\n\n\n   Small naming suggestion: maybe we could use \"fill_null_forward\" instead of \"fill_forward_null\" to align it more with the existing \"fill_null\"\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-09T16:56:27.813+0000",
                    "updated": "2021-12-09T16:56:27.813+0000",
                    "started": "2021-12-09T16:56:27.812+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "693400",
                    "issueId": "13111093"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/worklog/695066",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #11853:\nURL: https://github.com/apache/arrow/pull/11853#issuecomment-992498224\n\n\n   For the failures with chunked arrays, the kernel needs these options set:\r\n   \r\n   ```diff\r\n   diff --git a/cpp/src/arrow/compute/kernels/vector_replace.cc b/cpp/src/arrow/compute/kernels/vector_replace.cc\r\n   index d85965cfd..8ee4bbfe1 100644\r\n   --- a/cpp/src/arrow/compute/kernels/vector_replace.cc\r\n   +++ b/cpp/src/arrow/compute/kernels/vector_replace.cc\r\n   @@ -799,6 +799,8 @@ void RegisterVectorFunction(FunctionRegistry* registry,\r\n        kernel.mem_allocation = MemAllocation::type::PREALLOCATE;\r\n        kernel.signature = Functor<FixedType>::GetSignature(get_id.id);\r\n        kernel.exec = std::move(exec);\r\n   +    kernel.can_execute_chunkwise = false;\r\n   +    kernel.output_chunked = false;\r\n        DCHECK_OK(func->AddKernel(std::move(kernel)));\r\n      };\r\n      auto add_primitive_kernel = [&](detail::GetTypeId get_id) {\r\n   diff --git a/cpp/src/arrow/compute/kernels/vector_replace_test.cc b/cpp/src/arrow/compute/kernels/vector_replace_test.cc\r\n   index 742facf19..48a0b40f5 100644\r\n   --- a/cpp/src/arrow/compute/kernels/vector_replace_test.cc\r\n   +++ b/cpp/src/arrow/compute/kernels/vector_replace_test.cc\r\n   @@ -110,7 +110,7 @@ class TestReplaceKernel : public ::testing::Test {\r\n                                      const std::shared_ptr<ChunkedArray> array,\r\n                                      const std::shared_ptr<ChunkedArray>& expected) {\r\n        ASSERT_OK_AND_ASSIGN(auto actual, func(Datum(*array), nullptr));\r\n   -    AssertChunkedEqual(*expected, *actual.chunked_array());\r\n   +    AssertChunkedEquivalent(*expected, *actual.chunked_array());\r\n      }\r\n   ```\r\n   \r\n   The test still fails, but I'll leave that for further debugging. \r\n   \r\n   Basically, with a chunked array input, by default, the compute infrastructure will split up the inputs and feed the kernel one chunk at a time, instead of the entire chunked array. In that case, it expects the kernel to output Array, not ChunkedArray, as it will assemble the final ChunkedArray itself. Also, in that case, it expects the kernel to keep track of its own state (in KernelState in KernelContext). Setting these options tells the compute infrastructure not to do this splitting and not to expect an Array output.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-13T13:55:16.238+0000",
                    "updated": "2021-12-13T13:55:16.238+0000",
                    "started": "2021-12-13T13:55:16.238+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "695066",
                    "issueId": "13111093"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/worklog/695068",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #11853:\nURL: https://github.com/apache/arrow/pull/11853#issuecomment-992499323\n\n\n   Also note that I would expect this:\r\n   \r\n   ```diff\r\n   @@ -1255,7 +1255,7 @@ TYPED_TEST(TestFillNullNumeric, FillForwardChunkedArray) {\r\n      this->AssertFillNullChunkedArray(\r\n          FillForwardNull,\r\n          this->chunked_array({\"[1,2,3,null,null,4]\", \"[5, null, null]\", \"[null, 7, null]\"}),\r\n   -      this->chunked_array({\"[1,2,3,3,3,4]\", \"[5, 5, 5]\", \"[null, 7, 7]\"}));\r\n   +      this->chunked_array({\"[1,2,3,3,3,4]\", \"[5, 5, 5]\", \"[5, 7, 7]\"}));\r\n    }\r\n    }  // namespace compute\r\n    }  // namespace arrow\r\n   ```\r\n   \r\n   i.e. the ChunkedArray should behave as one large array, not an array of independent arrays.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-13T13:56:32.275+0000",
                    "updated": "2021-12-13T13:56:32.275+0000",
                    "started": "2021-12-13T13:56:32.275+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "695068",
                    "issueId": "13111093"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/worklog/697260",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11853:\nURL: https://github.com/apache/arrow/pull/11853#discussion_r770531035\n\n\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.cc\n##########\n@@ -220,6 +220,14 @@ Result<Datum> ReplaceWithMask(const Datum& values, const Datum& mask,\n   return CallFunction(\"replace_with_mask\", {values, mask, replacements}, ctx);\n }\n \n+Result<Datum> FillForwardNull(const Datum& values, ExecContext* ctx) {\n\nReview comment:\n       We should also change the wrapper names if we change the function name.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -489,17 +926,57 @@ void RegisterVectorReplace(FunctionRegistry* registry) {\n   }\n   add_primitive_kernel(null());\n   add_primitive_kernel(boolean());\n-  add_kernel(Type::FIXED_SIZE_BINARY, ReplaceWithMaskFunctor<FixedSizeBinaryType>::Exec);\n-  add_kernel(Type::DECIMAL128, ReplaceWithMaskFunctor<FixedSizeBinaryType>::Exec);\n-  add_kernel(Type::DECIMAL256, ReplaceWithMaskFunctor<FixedSizeBinaryType>::Exec);\n+  add_kernel(Type::FIXED_SIZE_BINARY, Functor<FixedType>::Exec);\n+  add_kernel(Type::DECIMAL128, Functor<FixedType>::Exec);\n+  add_kernel(Type::DECIMAL256, Functor<FixedType>::Exec);\n   for (const auto& ty : BaseBinaryTypes()) {\n-    add_kernel(ty->id(), GenerateTypeAgnosticVarBinaryBase<ReplaceWithMaskFunctor>(*ty));\n+    add_kernel(ty->id(), GenerateTypeAgnosticVarBinaryBase<Functor>(*ty));\n   }\n   // TODO: list types\n   DCHECK_OK(registry->AddFunction(std::move(func)));\n \n   // TODO(ARROW-9431): \"replace_with_indices\"\n }\n+\n+const FunctionDoc replace_with_mask_doc(\n+    \"Replace items selected with a mask\",\n+    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n+     \"along with replacement values (either scalar or array),\\n\"\n+     \"each element of the array for which the corresponding mask element is\\n\"\n+     \"true will be replaced by the next value from the replacements,\\n\"\n+     \"or with null if the mask is null.\\n\"\n+     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n+    {\"values\", \"mask\", \"replacements\"});\n+\n+const FunctionDoc fill_null_forward_doc(\n+    \"Replace null values using forward mode\",\n+    (\"Given an array, propagate last valid observation forward to next valid\\n\"\n+     \"or nothing if all previous values are null. \"),\n+    {\"values\"});\n+\n+const FunctionDoc fill_null_backward_doc(\n+    \"Replace null values using forward mode\",\n\nReview comment:\n       Backward mode?\r\n   \r\n   Also perhaps something like \"Carry non-null values backward to fill null slots\" might be clearer.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,460 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData current_value_array, bool* has_current_value,\n+                             int64_t* current_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/output->offset, array, /*in_offset=*/0,\n+                                  array.length);\n+\n+  *has_current_value = false;\n+  auto array_scalars = arrow::MakeArray(current_value_array.Copy());\n+  bool has_fill_value = *current_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   array.length);\n+\n+  while (bitmap_offset < array.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *current_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      current_value_array = array;\n+      *has_current_value = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      if (block.popcount) {\n+        uint64_t write_value_offset = block_start_offset;\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              current_value_array, *current_value_offset,\n+                                              /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            *current_value_offset = write_value_offset;\n+            current_value_array = array;\n+            *has_current_value = true;\n+          }\n+        }\n+      } else if (has_fill_value) {\n+        uint64_t write_value_offset =\n+            block_start_offset + (direction == 1 ? 0 : (-block.length + 1));\n+        auto in = *(array_scalars->GetScalar(*current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset, *in,\n\nReview comment:\n       I still don't think it's worth allocating a scalar over just calling `CopyData` in a loop. As long as it gets inlined it will be fine.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,460 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData current_value_array, bool* has_current_value,\n+                             int64_t* current_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/output->offset, array, /*in_offset=*/0,\n+                                  array.length);\n+\n+  *has_current_value = false;\n+  auto array_scalars = arrow::MakeArray(current_value_array.Copy());\n+  bool has_fill_value = *current_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   array.length);\n+\n+  while (bitmap_offset < array.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *current_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      current_value_array = array;\n+      *has_current_value = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      if (block.popcount) {\n+        uint64_t write_value_offset = block_start_offset;\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              current_value_array, *current_value_offset,\n+                                              /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            *current_value_offset = write_value_offset;\n+            current_value_array = array;\n+            *has_current_value = true;\n+          }\n+        }\n+      } else if (has_fill_value) {\n+        uint64_t write_value_offset =\n+            block_start_offset + (direction == 1 ? 0 : (-block.length + 1));\n+        auto in = *(array_scalars->GetScalar(*current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset, *in,\n+                                        *current_value_offset, block.length);\n+        bit_util::SetBitsTo(out_bitmap, write_value_offset, block.length, true);\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const uint8_t* data_prev = current_value_array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = current_value_array.GetValues<offset_type>(1);\n+\n+    *has_current_value = false;\n+    bool has_fill_value = *current_value_offset != -1;\n+    std::vector<std::tuple<bool, uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+          *current_value_offset = array_value_index;\n+          *has_current_value = true;\n+          has_fill_value = true;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value) {\n+            if (*has_current_value) {\n+              const offset_type offset0 = offsets[*current_value_offset];\n+              const offset_type offset1 = offsets[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*current_value_offset];\n+              const offset_type offset1 = offsets_prev[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/0, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/0, -1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+    return write_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    return -1;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        bool has_current_value = false;\n+        int64_t has_current_offset = -1;\n+        return FillForwardArray(ctx, array_input, out, array_input, &has_current_value,\n+                                &has_current_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                 ArrayData current_value_array, bool* has_current_value,\n+                                 int64_t* current_value_offset) {\n+    ArrayData* output = out->array().get();\n+    if (!output->buffers[0]) {\n+      ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    }\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, array.buffers[0]->data(), output, direction, current_value_array,\n+          has_current_value, current_value_offset);\n+    } else {\n+      *current_value_offset = FillNullExecutor<Type>::LastElementOffset(array, direction);\n\nReview comment:\n       I don't see why this is templated, it should be independent of the type.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -444,6 +456,225 @@ struct ReplaceWithMaskFunctor {\n   }\n };\n \n+template <typename Type>\n+void fillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t incrementer) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values, 0, array, 0, array.length);\n+\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+  int64_t write_offset = incrementer == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + incrementer * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n+        for (int64_t i = 0; i != block.length; i++) {\n+          uint64_t write_value_offset = write_offset + incrementer * bitmap_offset;\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              array, current_value_offset, /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            current_value_offset = write_value_offset;\n+          }\n+          bitmap_offset += 1;\n+        }\n+      } else {\n+        auto in = *(array_scalars->GetScalar(current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_offset, *in,\n+                                        current_value_offset, block.length);\n+        bitmap_offset += block.length;\n+      }\n+      write_offset += block.length * incrementer;\n+    }\n+  }\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t current_value_offset = 0;\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    bool has_fill_value = false;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+\n+    std::vector<std::pair<uint64_t, uint64_t>> offsets_reverted;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n\nReview comment:\n       Ah, we would have to specialize for forward/backward fill to do this.\r\n   \r\n   BTW @AlvinJ15 if I get something wrong or you have an explanation for why something is the way it is, please let me know!\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,231 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/0, array, /*in_offset=*/0, array.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + direction * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n+        for (int64_t i = 0; i != block.length; i++) {\n+          uint64_t write_value_offset = write_offset + direction * bitmap_offset;\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              array, current_value_offset, /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            current_value_offset = write_value_offset;\n+          }\n+          bitmap_offset += 1;\n+        }\n+      } else {\n+        auto in = *(array_scalars->GetScalar(current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_offset, *in,\n+                                        current_value_offset, block.length);\n+        bitmap_offset += block.length;\n+      }\n+      write_offset += block.length * direction;\n+    }\n+  }\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t current_value_offset = 0;\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    bool has_fill_value = false;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+\n+    std::vector<std::pair<uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(std::make_pair(offset0, offset1 - offset0));\n+          current_value_offset = array_value_index;\n+          has_fill_value = true;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value) {\n+            const offset_type offset0 = offsets[current_value_offset];\n+            const offset_type offset1 = offsets[current_value_offset + 1];\n+            offsets_reversed.push_back(std::make_pair(offset0, offset1 - offset0));\n+          } else {\n+            offsets_reversed.push_back(std::make_pair(-1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (it->first == -1U && it->second == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data + it->first, it->second));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (it->first == -1U && it->second == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data + it->first, it->second));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ArrayData& array = *batch[0].array();\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+\n+    if (array.MayHaveNulls()) {\n+      int8_t direction = 1;\n+      return FillNullExecutor<Type>::ExecFillNull(ctx, array, array.buffers[0]->data(),\n+                                                  output, direction);\n+    } else {\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id)}, OutputType(FirstType));\n+  }\n+};\n+\n+template <typename Type>\n+struct FillBackwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ArrayData& array = *batch[0].array();\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+\n+    if (array.MayHaveNulls()) {\n+      int8_t direction = -1;\n+      auto reversed_bitmap = arrow::internal::ReverseBitmap(\n+          ctx->memory_pool(), array.buffers[0]->data(), array.offset, array.length);\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, reversed_bitmap.ValueOrDie()->data(), output, direction);\n+    } else {\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id)}, OutputType(FirstType));\n+  }\n+};\n+}  // namespace\n+\n+template <template <class> class Functor,\n+class FixedType = FixedSizeBinaryType>\n\nReview comment:\n       Ping here.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,460 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData current_value_array, bool* has_current_value,\n+                             int64_t* current_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/output->offset, array, /*in_offset=*/0,\n+                                  array.length);\n+\n+  *has_current_value = false;\n+  auto array_scalars = arrow::MakeArray(current_value_array.Copy());\n+  bool has_fill_value = *current_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   array.length);\n+\n+  while (bitmap_offset < array.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *current_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      current_value_array = array;\n+      *has_current_value = true;\n\nReview comment:\n       Instead of updating `has_current_value` on every iteration, why not update it at the end of the function?\r\n   \r\n   Why are we copying `has_current_value` to a local variable but not `current_value_offset`? I would either copy both or copy neither and expect the compiler to optimize both.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace_test.cc\n##########\n@@ -798,5 +828,688 @@ TYPED_TEST(TestReplaceBinary, ReplaceWithMaskRandom) {\n   }\n }\n \n+template <typename T>\n+class TestFillNullNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+TYPED_TEST_SUITE(TestFillNullNumeric, NumericBasedTypes);\n+TYPED_TEST_SUITE(TestFillNullDecimal, DecimalArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullBinary, BaseBinaryArrowTypes);\n\nReview comment:\n       Can we also add a test for NullType?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,460 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData current_value_array, bool* has_current_value,\n+                             int64_t* current_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/output->offset, array, /*in_offset=*/0,\n+                                  array.length);\n+\n+  *has_current_value = false;\n+  auto array_scalars = arrow::MakeArray(current_value_array.Copy());\n+  bool has_fill_value = *current_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   array.length);\n+\n+  while (bitmap_offset < array.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *current_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      current_value_array = array;\n+      *has_current_value = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      if (block.popcount) {\n+        uint64_t write_value_offset = block_start_offset;\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              current_value_array, *current_value_offset,\n+                                              /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            *current_value_offset = write_value_offset;\n+            current_value_array = array;\n+            *has_current_value = true;\n+          }\n+        }\n+      } else if (has_fill_value) {\n+        uint64_t write_value_offset =\n+            block_start_offset + (direction == 1 ? 0 : (-block.length + 1));\n+        auto in = *(array_scalars->GetScalar(*current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset, *in,\n+                                        *current_value_offset, block.length);\n+        bit_util::SetBitsTo(out_bitmap, write_value_offset, block.length, true);\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const uint8_t* data_prev = current_value_array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = current_value_array.GetValues<offset_type>(1);\n+\n+    *has_current_value = false;\n+    bool has_fill_value = *current_value_offset != -1;\n+    std::vector<std::tuple<bool, uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+          *current_value_offset = array_value_index;\n+          *has_current_value = true;\n+          has_fill_value = true;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value) {\n+            if (*has_current_value) {\n+              const offset_type offset0 = offsets[*current_value_offset];\n+              const offset_type offset1 = offsets[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*current_value_offset];\n+              const offset_type offset1 = offsets_prev[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/0, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/0, -1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+    return write_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    return -1;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        bool has_current_value = false;\n+        int64_t has_current_offset = -1;\n+        return FillForwardArray(ctx, array_input, out, array_input, &has_current_value,\n+                                &has_current_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                 ArrayData current_value_array, bool* has_current_value,\n+                                 int64_t* current_value_offset) {\n+    ArrayData* output = out->array().get();\n+    if (!output->buffers[0]) {\n\nReview comment:\n       Why not just set the kernel to preallocate the bitmap below? (You would have to have separate registration functions for these kernels instead of combining it with the replace_with_mask registration.)\r\n   \r\n   ```\r\n   kernel.null_handling = NullHandling::type::COMPUTED_PREALLOCATE;\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,460 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData current_value_array, bool* has_current_value,\n\nReview comment:\n       1) Pass this by const reference and in the function, keep a `ArrayData* source_array` that can be updated\r\n   2) array_scalars isn't being properly updated below, though again I think we should just not use array_scalars\r\n   3) This would be clearer if it was named `previous_chunk` and `current_chunk` or something\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,460 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData current_value_array, bool* has_current_value,\n+                             int64_t* current_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/output->offset, array, /*in_offset=*/0,\n+                                  array.length);\n+\n+  *has_current_value = false;\n+  auto array_scalars = arrow::MakeArray(current_value_array.Copy());\n+  bool has_fill_value = *current_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   array.length);\n+\n+  while (bitmap_offset < array.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *current_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      current_value_array = array;\n+      *has_current_value = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      if (block.popcount) {\n+        uint64_t write_value_offset = block_start_offset;\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              current_value_array, *current_value_offset,\n+                                              /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            *current_value_offset = write_value_offset;\n+            current_value_array = array;\n+            *has_current_value = true;\n+          }\n+        }\n+      } else if (has_fill_value) {\n+        uint64_t write_value_offset =\n+            block_start_offset + (direction == 1 ? 0 : (-block.length + 1));\n+        auto in = *(array_scalars->GetScalar(*current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset, *in,\n+                                        *current_value_offset, block.length);\n+        bit_util::SetBitsTo(out_bitmap, write_value_offset, block.length, true);\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const uint8_t* data_prev = current_value_array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = current_value_array.GetValues<offset_type>(1);\n+\n+    *has_current_value = false;\n+    bool has_fill_value = *current_value_offset != -1;\n+    std::vector<std::tuple<bool, uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+          *current_value_offset = array_value_index;\n+          *has_current_value = true;\n+          has_fill_value = true;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value) {\n+            if (*has_current_value) {\n+              const offset_type offset0 = offsets[*current_value_offset];\n+              const offset_type offset1 = offsets[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*current_value_offset];\n+              const offset_type offset1 = offsets_prev[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/0, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/0, -1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+    return write_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    return -1;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        bool has_current_value = false;\n+        int64_t has_current_offset = -1;\n+        return FillForwardArray(ctx, array_input, out, array_input, &has_current_value,\n+                                &has_current_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                 ArrayData current_value_array, bool* has_current_value,\n+                                 int64_t* current_value_offset) {\n+    ArrayData* output = out->array().get();\n+    if (!output->buffers[0]) {\n+      ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    }\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, array.buffers[0]->data(), output, direction, current_value_array,\n+          has_current_value, current_value_offset);\n+    } else {\n+      *current_value_offset = FillNullExecutor<Type>::LastElementOffset(array, direction);\n+      if (array.length > 0) {\n+        *has_current_value = true;\n\nReview comment:\n       Is this true? What if the chunk is all null?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,460 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData current_value_array, bool* has_current_value,\n+                             int64_t* current_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/output->offset, array, /*in_offset=*/0,\n+                                  array.length);\n+\n+  *has_current_value = false;\n+  auto array_scalars = arrow::MakeArray(current_value_array.Copy());\n+  bool has_fill_value = *current_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   array.length);\n+\n+  while (bitmap_offset < array.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *current_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      current_value_array = array;\n+      *has_current_value = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      if (block.popcount) {\n+        uint64_t write_value_offset = block_start_offset;\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              current_value_array, *current_value_offset,\n+                                              /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            *current_value_offset = write_value_offset;\n+            current_value_array = array;\n+            *has_current_value = true;\n+          }\n+        }\n+      } else if (has_fill_value) {\n+        uint64_t write_value_offset =\n+            block_start_offset + (direction == 1 ? 0 : (-block.length + 1));\n+        auto in = *(array_scalars->GetScalar(*current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset, *in,\n+                                        *current_value_offset, block.length);\n+        bit_util::SetBitsTo(out_bitmap, write_value_offset, block.length, true);\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const uint8_t* data_prev = current_value_array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = current_value_array.GetValues<offset_type>(1);\n+\n+    *has_current_value = false;\n+    bool has_fill_value = *current_value_offset != -1;\n+    std::vector<std::tuple<bool, uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+          *current_value_offset = array_value_index;\n+          *has_current_value = true;\n+          has_fill_value = true;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value) {\n+            if (*has_current_value) {\n+              const offset_type offset0 = offsets[*current_value_offset];\n+              const offset_type offset1 = offsets[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*current_value_offset];\n+              const offset_type offset1 = offsets_prev[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/0, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/0, -1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+    return write_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    return -1;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        bool has_current_value = false;\n+        int64_t has_current_offset = -1;\n+        return FillForwardArray(ctx, array_input, out, array_input, &has_current_value,\n+                                &has_current_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                 ArrayData current_value_array, bool* has_current_value,\n+                                 int64_t* current_value_offset) {\n+    ArrayData* output = out->array().get();\n+    if (!output->buffers[0]) {\n+      ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    }\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, array.buffers[0]->data(), output, direction, current_value_array,\n+          has_current_value, current_value_offset);\n+    } else {\n+      *current_value_offset = FillNullExecutor<Type>::LastElementOffset(array, direction);\n+      if (array.length > 0) {\n+        *has_current_value = true;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillForwardChunkedArray(KernelContext* ctx,\n+                                        const std::shared_ptr<ChunkedArray>& values,\n+                                        Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(*ToResult(values));\n\nReview comment:\n       Why are we calling `ToResult`?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,460 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData current_value_array, bool* has_current_value,\n+                             int64_t* current_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/output->offset, array, /*in_offset=*/0,\n+                                  array.length);\n+\n+  *has_current_value = false;\n+  auto array_scalars = arrow::MakeArray(current_value_array.Copy());\n+  bool has_fill_value = *current_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   array.length);\n+\n+  while (bitmap_offset < array.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *current_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      current_value_array = array;\n+      *has_current_value = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      if (block.popcount) {\n+        uint64_t write_value_offset = block_start_offset;\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              current_value_array, *current_value_offset,\n+                                              /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            *current_value_offset = write_value_offset;\n+            current_value_array = array;\n+            *has_current_value = true;\n+          }\n+        }\n+      } else if (has_fill_value) {\n+        uint64_t write_value_offset =\n+            block_start_offset + (direction == 1 ? 0 : (-block.length + 1));\n+        auto in = *(array_scalars->GetScalar(*current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset, *in,\n+                                        *current_value_offset, block.length);\n+        bit_util::SetBitsTo(out_bitmap, write_value_offset, block.length, true);\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const uint8_t* data_prev = current_value_array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = current_value_array.GetValues<offset_type>(1);\n+\n+    *has_current_value = false;\n+    bool has_fill_value = *current_value_offset != -1;\n+    std::vector<std::tuple<bool, uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+          *current_value_offset = array_value_index;\n+          *has_current_value = true;\n+          has_fill_value = true;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value) {\n+            if (*has_current_value) {\n+              const offset_type offset0 = offsets[*current_value_offset];\n+              const offset_type offset1 = offsets[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*current_value_offset];\n+              const offset_type offset1 = offsets_prev[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/0, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/0, -1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+    return write_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    return -1;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        bool has_current_value = false;\n+        int64_t has_current_offset = -1;\n+        return FillForwardArray(ctx, array_input, out, array_input, &has_current_value,\n+                                &has_current_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                 ArrayData current_value_array, bool* has_current_value,\n+                                 int64_t* current_value_offset) {\n+    ArrayData* output = out->array().get();\n+    if (!output->buffers[0]) {\n+      ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    }\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, array.buffers[0]->data(), output, direction, current_value_array,\n+          has_current_value, current_value_offset);\n+    } else {\n+      *current_value_offset = FillNullExecutor<Type>::LastElementOffset(array, direction);\n+      if (array.length > 0) {\n+        *has_current_value = true;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillForwardChunkedArray(KernelContext* ctx,\n+                                        const std::shared_ptr<ChunkedArray>& values,\n+                                        Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(*ToResult(values));\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(*ToResult(values));\n+      return Status::OK();\n+    }\n+    std::vector<std::shared_ptr<Array>> new_chunks;\n+\n+    if (values->length() > 0) {\n+      ArrayData array_with_current = *values->chunk(/*first_chunk=*/0)->data();\n+      bool has_current_value = false;\n+      int64_t has_current_offset = -1;\n+      for (const auto& chunk : values->chunks()) {\n+        auto buffer_size = chunk->length() * bit_width(values->type()->id());\n+        ARROW_ASSIGN_OR_RAISE(auto data, AllocateBuffer(buffer_size, ctx->memory_pool()));\n+\n+        std::unique_ptr<ArrayBuilder> builder;\n+        RETURN_NOT_OK(MakeBuilder(ctx->memory_pool(), values->type(), &builder));\n+        RETURN_NOT_OK(builder->Reserve(chunk->length()));\n+        ARROW_ASSIGN_OR_RAISE(auto array_output, builder->Finish());\n+\n+        ARROW_ASSIGN_OR_RAISE(array_output->data()->buffers[1],\n+                              ctx->Allocate(buffer_size / 8));\n+\n+        array_output->data()->length = values->length();\n+        auto array_out = Datum(*array_output);\n+        DCHECK_OK(FillForwardArray(ctx, *chunk->data(), &array_out, array_with_current,\n+                                   &has_current_value, &has_current_offset));\n+        if (has_current_value) {\n+          array_with_current = *chunk->data();\n+        }\n+        if (array_out.length() > 0) {\n+          new_chunks.push_back(array_out.make_array());\n+        }\n+      }\n+    }\n+\n+    *out = Datum(*ToResult(values));\n\nReview comment:\n       Why are we assigning to `out` twice here?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,460 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData current_value_array, bool* has_current_value,\n+                             int64_t* current_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/output->offset, array, /*in_offset=*/0,\n+                                  array.length);\n+\n+  *has_current_value = false;\n+  auto array_scalars = arrow::MakeArray(current_value_array.Copy());\n+  bool has_fill_value = *current_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   array.length);\n+\n+  while (bitmap_offset < array.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *current_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      current_value_array = array;\n+      *has_current_value = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      if (block.popcount) {\n+        uint64_t write_value_offset = block_start_offset;\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              current_value_array, *current_value_offset,\n+                                              /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            *current_value_offset = write_value_offset;\n+            current_value_array = array;\n+            *has_current_value = true;\n+          }\n+        }\n+      } else if (has_fill_value) {\n+        uint64_t write_value_offset =\n+            block_start_offset + (direction == 1 ? 0 : (-block.length + 1));\n+        auto in = *(array_scalars->GetScalar(*current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset, *in,\n+                                        *current_value_offset, block.length);\n+        bit_util::SetBitsTo(out_bitmap, write_value_offset, block.length, true);\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const uint8_t* data_prev = current_value_array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = current_value_array.GetValues<offset_type>(1);\n+\n+    *has_current_value = false;\n+    bool has_fill_value = *current_value_offset != -1;\n+    std::vector<std::tuple<bool, uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+          *current_value_offset = array_value_index;\n+          *has_current_value = true;\n+          has_fill_value = true;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value) {\n+            if (*has_current_value) {\n+              const offset_type offset0 = offsets[*current_value_offset];\n+              const offset_type offset1 = offsets[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*current_value_offset];\n+              const offset_type offset1 = offsets_prev[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/0, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/0, -1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+    return write_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    return -1;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        bool has_current_value = false;\n+        int64_t has_current_offset = -1;\n+        return FillForwardArray(ctx, array_input, out, array_input, &has_current_value,\n+                                &has_current_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                 ArrayData current_value_array, bool* has_current_value,\n+                                 int64_t* current_value_offset) {\n+    ArrayData* output = out->array().get();\n+    if (!output->buffers[0]) {\n+      ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    }\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, array.buffers[0]->data(), output, direction, current_value_array,\n+          has_current_value, current_value_offset);\n+    } else {\n+      *current_value_offset = FillNullExecutor<Type>::LastElementOffset(array, direction);\n+      if (array.length > 0) {\n+        *has_current_value = true;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillForwardChunkedArray(KernelContext* ctx,\n+                                        const std::shared_ptr<ChunkedArray>& values,\n+                                        Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(*ToResult(values));\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(*ToResult(values));\n+      return Status::OK();\n+    }\n+    std::vector<std::shared_ptr<Array>> new_chunks;\n+\n+    if (values->length() > 0) {\n+      ArrayData array_with_current = *values->chunk(/*first_chunk=*/0)->data();\n+      bool has_current_value = false;\n+      int64_t has_current_offset = -1;\n+      for (const auto& chunk : values->chunks()) {\n+        auto buffer_size = chunk->length() * bit_width(values->type()->id());\n+        ARROW_ASSIGN_OR_RAISE(auto data, AllocateBuffer(buffer_size, ctx->memory_pool()));\n\nReview comment:\n       This seems unused.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,460 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData current_value_array, bool* has_current_value,\n+                             int64_t* current_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/output->offset, array, /*in_offset=*/0,\n+                                  array.length);\n+\n+  *has_current_value = false;\n+  auto array_scalars = arrow::MakeArray(current_value_array.Copy());\n+  bool has_fill_value = *current_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   array.length);\n+\n+  while (bitmap_offset < array.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *current_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      current_value_array = array;\n+      *has_current_value = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      if (block.popcount) {\n+        uint64_t write_value_offset = block_start_offset;\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              current_value_array, *current_value_offset,\n+                                              /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            *current_value_offset = write_value_offset;\n+            current_value_array = array;\n+            *has_current_value = true;\n+          }\n+        }\n+      } else if (has_fill_value) {\n+        uint64_t write_value_offset =\n+            block_start_offset + (direction == 1 ? 0 : (-block.length + 1));\n+        auto in = *(array_scalars->GetScalar(*current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset, *in,\n+                                        *current_value_offset, block.length);\n+        bit_util::SetBitsTo(out_bitmap, write_value_offset, block.length, true);\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const uint8_t* data_prev = current_value_array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = current_value_array.GetValues<offset_type>(1);\n+\n+    *has_current_value = false;\n+    bool has_fill_value = *current_value_offset != -1;\n+    std::vector<std::tuple<bool, uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+          *current_value_offset = array_value_index;\n+          *has_current_value = true;\n+          has_fill_value = true;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value) {\n+            if (*has_current_value) {\n+              const offset_type offset0 = offsets[*current_value_offset];\n+              const offset_type offset1 = offsets[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*current_value_offset];\n+              const offset_type offset1 = offsets_prev[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/0, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/0, -1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+    return write_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    return -1;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        bool has_current_value = false;\n+        int64_t has_current_offset = -1;\n+        return FillForwardArray(ctx, array_input, out, array_input, &has_current_value,\n+                                &has_current_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                 ArrayData current_value_array, bool* has_current_value,\n+                                 int64_t* current_value_offset) {\n+    ArrayData* output = out->array().get();\n+    if (!output->buffers[0]) {\n+      ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    }\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, array.buffers[0]->data(), output, direction, current_value_array,\n+          has_current_value, current_value_offset);\n+    } else {\n+      *current_value_offset = FillNullExecutor<Type>::LastElementOffset(array, direction);\n+      if (array.length > 0) {\n+        *has_current_value = true;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillForwardChunkedArray(KernelContext* ctx,\n+                                        const std::shared_ptr<ChunkedArray>& values,\n+                                        Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(*ToResult(values));\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(*ToResult(values));\n+      return Status::OK();\n+    }\n+    std::vector<std::shared_ptr<Array>> new_chunks;\n+\n+    if (values->length() > 0) {\n+      ArrayData array_with_current = *values->chunk(/*first_chunk=*/0)->data();\n+      bool has_current_value = false;\n+      int64_t has_current_offset = -1;\n+      for (const auto& chunk : values->chunks()) {\n+        auto buffer_size = chunk->length() * bit_width(values->type()->id());\n+        ARROW_ASSIGN_OR_RAISE(auto data, AllocateBuffer(buffer_size, ctx->memory_pool()));\n+\n+        std::unique_ptr<ArrayBuilder> builder;\n+        RETURN_NOT_OK(MakeBuilder(ctx->memory_pool(), values->type(), &builder));\n+        RETURN_NOT_OK(builder->Reserve(chunk->length()));\n+        ARROW_ASSIGN_OR_RAISE(auto array_output, builder->Finish());\n+\n+        ARROW_ASSIGN_OR_RAISE(array_output->data()->buffers[1],\n+                              ctx->Allocate(buffer_size / 8));\n\nReview comment:\n       Also for future reference, there should be `ctx->AllocateBitmap`.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,460 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData current_value_array, bool* has_current_value,\n+                             int64_t* current_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/output->offset, array, /*in_offset=*/0,\n+                                  array.length);\n+\n+  *has_current_value = false;\n+  auto array_scalars = arrow::MakeArray(current_value_array.Copy());\n+  bool has_fill_value = *current_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   array.length);\n+\n+  while (bitmap_offset < array.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *current_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      current_value_array = array;\n+      *has_current_value = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      if (block.popcount) {\n+        uint64_t write_value_offset = block_start_offset;\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              current_value_array, *current_value_offset,\n+                                              /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            *current_value_offset = write_value_offset;\n+            current_value_array = array;\n+            *has_current_value = true;\n+          }\n+        }\n+      } else if (has_fill_value) {\n+        uint64_t write_value_offset =\n+            block_start_offset + (direction == 1 ? 0 : (-block.length + 1));\n+        auto in = *(array_scalars->GetScalar(*current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset, *in,\n+                                        *current_value_offset, block.length);\n+        bit_util::SetBitsTo(out_bitmap, write_value_offset, block.length, true);\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const uint8_t* data_prev = current_value_array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = current_value_array.GetValues<offset_type>(1);\n+\n+    *has_current_value = false;\n+    bool has_fill_value = *current_value_offset != -1;\n+    std::vector<std::tuple<bool, uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+          *current_value_offset = array_value_index;\n+          *has_current_value = true;\n+          has_fill_value = true;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value) {\n+            if (*has_current_value) {\n+              const offset_type offset0 = offsets[*current_value_offset];\n+              const offset_type offset1 = offsets[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*current_value_offset];\n+              const offset_type offset1 = offsets_prev[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/0, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/0, -1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+    return write_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    return -1;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        bool has_current_value = false;\n+        int64_t has_current_offset = -1;\n+        return FillForwardArray(ctx, array_input, out, array_input, &has_current_value,\n+                                &has_current_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                 ArrayData current_value_array, bool* has_current_value,\n+                                 int64_t* current_value_offset) {\n+    ArrayData* output = out->array().get();\n+    if (!output->buffers[0]) {\n+      ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    }\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, array.buffers[0]->data(), output, direction, current_value_array,\n+          has_current_value, current_value_offset);\n+    } else {\n+      *current_value_offset = FillNullExecutor<Type>::LastElementOffset(array, direction);\n+      if (array.length > 0) {\n+        *has_current_value = true;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillForwardChunkedArray(KernelContext* ctx,\n+                                        const std::shared_ptr<ChunkedArray>& values,\n+                                        Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(*ToResult(values));\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(*ToResult(values));\n+      return Status::OK();\n+    }\n+    std::vector<std::shared_ptr<Array>> new_chunks;\n+\n+    if (values->length() > 0) {\n+      ArrayData array_with_current = *values->chunk(/*first_chunk=*/0)->data();\n+      bool has_current_value = false;\n+      int64_t has_current_offset = -1;\n+      for (const auto& chunk : values->chunks()) {\n+        auto buffer_size = chunk->length() * bit_width(values->type()->id());\n+        ARROW_ASSIGN_OR_RAISE(auto data, AllocateBuffer(buffer_size, ctx->memory_pool()));\n+\n+        std::unique_ptr<ArrayBuilder> builder;\n+        RETURN_NOT_OK(MakeBuilder(ctx->memory_pool(), values->type(), &builder));\n+        RETURN_NOT_OK(builder->Reserve(chunk->length()));\n+        ARROW_ASSIGN_OR_RAISE(auto array_output, builder->Finish());\n+\n+        ARROW_ASSIGN_OR_RAISE(array_output->data()->buffers[1],\n+                              ctx->Allocate(buffer_size / 8));\n+\n+        array_output->data()->length = values->length();\n+        auto array_out = Datum(*array_output);\n\nReview comment:\n       Instead of this, we can adjust `FillNullInDirectionImpl` to do the allocation (since it knows exactly how big the buffers need to be) and then we can specify that these kernels do not preallocate any data. (Again, we will have to separate the registration for these kernels from the registration for ReplaceWithMask.)\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace_test.cc\n##########\n@@ -798,5 +828,688 @@ TYPED_TEST(TestReplaceBinary, ReplaceWithMaskRandom) {\n   }\n }\n \n+template <typename T>\n+class TestFillNullNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+TYPED_TEST_SUITE(TestFillNullNumeric, NumericBasedTypes);\n+TYPED_TEST_SUITE(TestFillNullDecimal, DecimalArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullBinary, BaseBinaryArrowTypes);\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[]\"), this->array(\"[]\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[null, null, null, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[null, null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[null, null, 4, 4, 5, 5]\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1,4,null]\"),\n+                            this->array(\"[1,4,4]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 6]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 6]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"30.00\"])\"),\n+                            this->array(R\"([null, null, null, \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, \"30.00\", null])\"),\n+                            this->array(R\"([null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([null, null, \"30.00\",null, \"5.00\", null])\"),\n+      this->array(R\"([null, null, \"30.00\", \"30.00\", \"5.00\", \"5.00\"])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([\"10.00\",\"30.00\",null])\"),\n+                            this->array(R\"([\"10.00\",\"30.00\",\"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"10.00\", \"30.00\", null, null, null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"30.00\", \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"5.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, \"ccc\"])\"),\n+                            this->array(R\"([null, null, null, \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, \"ccc\", null])\"),\n+                            this->array(R\"([null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, \"ccc\",null, \"xyz\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\", \"xyz\", \"xyz\"])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([\"aaa\",\"ccc\",null])\"),\n+                            this->array(R\"([\"aaa\",\"ccc\",\"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, null, null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"ccc\", \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"qwert\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"xyz\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", null])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[]\"), this->array(\"[]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, 4, null, null, null]\"),\n+                            this->array(\"[4, 4,null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[4, 4, 4, 5, 5, null]\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null]\"),\n+                            this->array(\"[1, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,null, null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 , 5, 5, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 6]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 6, 6, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, \"40.00\", null, null, null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\",null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"40.00\"])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\"])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([null, null, \"40.00\",null, \"50.00\", null])\"),\n+      this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"50.00\", \"50.00\", null])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([\"10.00\", \"40.00\", null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"10.00\", \"40.00\", null, null, null, null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" , \"50.00\", \"50.00\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"50.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"50.00\", \"50.00\", \"50.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"6.00\", \"6.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, \"afd\", null, null, null])\"),\n+                            this->array(R\"([\"afd\", \"afd\",null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, \"afd\"])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\"])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, \"afd\",null, \"qwe\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"qwe\", \"qwe\", null])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([\"tyu\", \"afd\", null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"tyu\", \"afd\", null, null, null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" , \"qwe\", \"qwe\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"oiutyu\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"oiutyu\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"qwe\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"qwe\", \"qwe\", \"qwe\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", null])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"oiutyu\", \"oiutyu\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+}\n+\n+// For Test Blocks\n+TYPED_TEST(TestFillNullNumeric, FillNullForwardLargeInput) {\n+  using CType = typename TypeTraits<TypeParam>::CType;\n+  random::RandomArrayGenerator rand(/*seed=*/1000);\n+  int64_t len_null = 500;\n+  int64_t len_random = 1000;\n+  std::shared_ptr<Array> array_random =\n+      rand.Numeric<TypeParam>(len_random, /*min=*/0, /*max=*/200, /*nulls=*/0);\n+\n+  if (array_random) {\n\nReview comment:\n       Why the check here?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace_test.cc\n##########\n@@ -798,5 +828,688 @@ TYPED_TEST(TestReplaceBinary, ReplaceWithMaskRandom) {\n   }\n }\n \n+template <typename T>\n+class TestFillNullNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+TYPED_TEST_SUITE(TestFillNullNumeric, NumericBasedTypes);\n+TYPED_TEST_SUITE(TestFillNullDecimal, DecimalArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullBinary, BaseBinaryArrowTypes);\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[]\"), this->array(\"[]\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[null, null, null, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[null, null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[null, null, 4, 4, 5, 5]\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1,4,null]\"),\n+                            this->array(\"[1,4,4]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 6]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 6]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"30.00\"])\"),\n+                            this->array(R\"([null, null, null, \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, \"30.00\", null])\"),\n+                            this->array(R\"([null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([null, null, \"30.00\",null, \"5.00\", null])\"),\n+      this->array(R\"([null, null, \"30.00\", \"30.00\", \"5.00\", \"5.00\"])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([\"10.00\",\"30.00\",null])\"),\n+                            this->array(R\"([\"10.00\",\"30.00\",\"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"10.00\", \"30.00\", null, null, null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"30.00\", \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"5.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, \"ccc\"])\"),\n+                            this->array(R\"([null, null, null, \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, \"ccc\", null])\"),\n+                            this->array(R\"([null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, \"ccc\",null, \"xyz\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\", \"xyz\", \"xyz\"])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([\"aaa\",\"ccc\",null])\"),\n+                            this->array(R\"([\"aaa\",\"ccc\",\"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, null, null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"ccc\", \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"qwert\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"xyz\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", null])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[]\"), this->array(\"[]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, 4, null, null, null]\"),\n+                            this->array(\"[4, 4,null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[4, 4, 4, 5, 5, null]\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null]\"),\n+                            this->array(\"[1, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,null, null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 , 5, 5, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 6]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 6, 6, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, \"40.00\", null, null, null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\",null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"40.00\"])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\"])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([null, null, \"40.00\",null, \"50.00\", null])\"),\n+      this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"50.00\", \"50.00\", null])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([\"10.00\", \"40.00\", null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"10.00\", \"40.00\", null, null, null, null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" , \"50.00\", \"50.00\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"50.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"50.00\", \"50.00\", \"50.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"6.00\", \"6.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, \"afd\", null, null, null])\"),\n+                            this->array(R\"([\"afd\", \"afd\",null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, \"afd\"])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\"])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, \"afd\",null, \"qwe\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"qwe\", \"qwe\", null])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([\"tyu\", \"afd\", null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"tyu\", \"afd\", null, null, null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" , \"qwe\", \"qwe\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"oiutyu\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"oiutyu\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"qwe\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"qwe\", \"qwe\", \"qwe\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", null])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"oiutyu\", \"oiutyu\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+}\n+\n+// For Test Blocks\n+TYPED_TEST(TestFillNullNumeric, FillNullForwardLargeInput) {\n+  using CType = typename TypeTraits<TypeParam>::CType;\n+  random::RandomArrayGenerator rand(/*seed=*/1000);\n+  int64_t len_null = 500;\n+  int64_t len_random = 1000;\n+  std::shared_ptr<Array> array_random =\n+      rand.Numeric<TypeParam>(len_random, /*min=*/0, /*max=*/200, /*nulls=*/0);\n+\n+  if (array_random) {\n+    auto x_ptr = array_random->data()->template GetValues<CType>(1);\n+    ASSERT_OK_AND_ASSIGN(auto array_null,\n+                         MakeArrayOfNull(array_random->type(), len_null));\n+    auto array_null_filled =\n+        ConstantArrayGenerator::Numeric<TypeParam>(len_null, x_ptr[len_random - 1]);\n+    {\n+      ASSERT_OK_AND_ASSIGN(auto value_array,\n+                           Concatenate({array_random, array_null, array_random}));\n+      ASSERT_OK_AND_ASSIGN(auto result_array,\n+                           Concatenate({array_random, array_null_filled, array_random}));\n+      this->AssertFillNullArray(FillForwardNull, value_array, result_array);\n+    }\n+  }\n+}\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullBackwardLargeInput) {\n+  using CType = typename TypeTraits<TypeParam>::CType;\n+  random::RandomArrayGenerator rand(/*seed=*/1000);\n+  int64_t len_null = 500;\n+  int64_t len_random = 1000;\n+  std::shared_ptr<Array> array_random =\n+      rand.Numeric<TypeParam>(len_random, /*min=*/0, /*max=*/200, /*null_count=*/0);\n+\n+  if (array_random) {\n+    auto x_ptr = array_random->data()->template GetValues<CType>(1);\n+    ASSERT_OK_AND_ASSIGN(auto array_null,\n+                         MakeArrayOfNull(array_random->type(), len_null));\n+\n+    auto array_null_filled =\n+        ConstantArrayGenerator::Numeric<TypeParam>(len_null, x_ptr[0]);\n+    {\n+      ASSERT_OK_AND_ASSIGN(auto value_array,\n+                           Concatenate({array_random, array_null, array_random}));\n+      ASSERT_OK_AND_ASSIGN(auto result_array,\n+                           Concatenate({array_random, array_null_filled, array_random}));\n+      this->AssertFillNullArray(FillBackwardNull, value_array, result_array);\n+    }\n+  }\n+}\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullForwardSliced) {\n+  using CType = typename TypeTraits<TypeParam>::CType;\n+  random::RandomArrayGenerator rand(/*seed=*/666);\n+  int64_t len_random = 64;\n+  int64_t len_null = 64;\n+  int64_t slices = 15;\n+  std::vector<std::shared_ptr<Array>> vector_values;\n+  std::vector<std::shared_ptr<Array>> vector_filled;\n+  for (int i = 0; i < slices; i++) {\n+    std::shared_ptr<Array> array_random =\n+        rand.Numeric<TypeParam>(len_random, /*min=*/5, /*max=*/200, /*null_count=*/0);\n+    if (array_random) {\n+      auto x_ptr = array_random->data()->template GetValues<CType>(1);\n+      ASSERT_OK_AND_ASSIGN(auto array_null,\n+                           MakeArrayOfNull(array_random->type(), len_null));\n+      vector_values.push_back(array_random);\n+      vector_values.push_back(array_null);\n+      auto array_null_filled =\n+          ConstantArrayGenerator::Numeric<TypeParam>(len_null, x_ptr[len_random - 1]);\n+      vector_filled.push_back(array_random);\n+      vector_filled.push_back(array_null_filled);\n+    }\n+  }\n+\n+  if (vector_values.size() && vector_filled.size()) {\n+    ASSERT_OK_AND_ASSIGN(auto value_array, Concatenate(vector_values));\n+    ASSERT_OK_AND_ASSIGN(auto result_array, Concatenate(vector_filled));\n+\n+    this->AssertFillNullArray(FillForwardNull, value_array, result_array);\n+    uint8_t slice_length = len_null + len_random;\n+    for (int64_t slice = 0; slice < slices; slice++) {\n+      auto sliced_array = value_array->Slice(slice * slice_length, slice_length);\n+      auto sliced_array_expected =\n+          result_array->Slice(slice * slice_length, slice_length);\n+      this->AssertFillNullArray(FillForwardNull, sliced_array, sliced_array_expected);\n+    }\n+  }\n+}\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullBackwardSliced) {\n\nReview comment:\n       For testing slicing, I think it's OK to hardcode some cases.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace_test.cc\n##########\n@@ -798,5 +828,688 @@ TYPED_TEST(TestReplaceBinary, ReplaceWithMaskRandom) {\n   }\n }\n \n+template <typename T>\n+class TestFillNullNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+TYPED_TEST_SUITE(TestFillNullNumeric, NumericBasedTypes);\n+TYPED_TEST_SUITE(TestFillNullDecimal, DecimalArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullBinary, BaseBinaryArrowTypes);\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[]\"), this->array(\"[]\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[null, null, null, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[null, null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[null, null, 4, 4, 5, 5]\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1,4,null]\"),\n+                            this->array(\"[1,4,4]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 6]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 6]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"30.00\"])\"),\n+                            this->array(R\"([null, null, null, \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, \"30.00\", null])\"),\n+                            this->array(R\"([null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([null, null, \"30.00\",null, \"5.00\", null])\"),\n+      this->array(R\"([null, null, \"30.00\", \"30.00\", \"5.00\", \"5.00\"])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([\"10.00\",\"30.00\",null])\"),\n+                            this->array(R\"([\"10.00\",\"30.00\",\"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"10.00\", \"30.00\", null, null, null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"30.00\", \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"5.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, \"ccc\"])\"),\n+                            this->array(R\"([null, null, null, \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, \"ccc\", null])\"),\n+                            this->array(R\"([null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, \"ccc\",null, \"xyz\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\", \"xyz\", \"xyz\"])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([\"aaa\",\"ccc\",null])\"),\n+                            this->array(R\"([\"aaa\",\"ccc\",\"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, null, null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"ccc\", \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"qwert\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"xyz\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", null])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[]\"), this->array(\"[]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, 4, null, null, null]\"),\n+                            this->array(\"[4, 4,null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[4, 4, 4, 5, 5, null]\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null]\"),\n+                            this->array(\"[1, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,null, null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 , 5, 5, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 6]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 6, 6, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, \"40.00\", null, null, null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\",null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"40.00\"])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\"])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([null, null, \"40.00\",null, \"50.00\", null])\"),\n+      this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"50.00\", \"50.00\", null])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([\"10.00\", \"40.00\", null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"10.00\", \"40.00\", null, null, null, null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" , \"50.00\", \"50.00\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"50.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"50.00\", \"50.00\", \"50.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"6.00\", \"6.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, \"afd\", null, null, null])\"),\n+                            this->array(R\"([\"afd\", \"afd\",null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, \"afd\"])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\"])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, \"afd\",null, \"qwe\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"qwe\", \"qwe\", null])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([\"tyu\", \"afd\", null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"tyu\", \"afd\", null, null, null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" , \"qwe\", \"qwe\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"oiutyu\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"oiutyu\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"qwe\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"qwe\", \"qwe\", \"qwe\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", null])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"oiutyu\", \"oiutyu\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+}\n+\n+// For Test Blocks\n+TYPED_TEST(TestFillNullNumeric, FillNullForwardLargeInput) {\n+  using CType = typename TypeTraits<TypeParam>::CType;\n+  random::RandomArrayGenerator rand(/*seed=*/1000);\n+  int64_t len_null = 500;\n+  int64_t len_random = 1000;\n+  std::shared_ptr<Array> array_random =\n+      rand.Numeric<TypeParam>(len_random, /*min=*/0, /*max=*/200, /*nulls=*/0);\n+\n+  if (array_random) {\n\nReview comment:\n       Ditto below.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-16T14:23:42.674+0000",
                    "updated": "2021-12-16T14:23:42.674+0000",
                    "started": "2021-12-16T14:23:42.673+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "697260",
                    "issueId": "13111093"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/worklog/697901",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11853:\nURL: https://github.com/apache/arrow/pull/11853#discussion_r771393052\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace_test.cc\n##########\n@@ -25,6 +25,8 @@\n #include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/key_value_metadata.h\"\n #include \"arrow/util/make_unique.h\"\n+#include <arrow/array/concatenate.h>\n+#include <arrow/testing/generator.h>\n\nReview comment:\n       nit: use `#include \"\"` for consistency/use `\"\"` when including Arrow headers inside the codebase\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,409 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData last_valid_value_chunk,\n\nReview comment:\n       Can we pass this by const reference?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,409 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      last_valid_value_chunk = current_chunk;\n\nReview comment:\n       We should declare something like this above:\r\n   \r\n   ```cpp\r\n   const ArrayData* source_chunk = &last_valid_value_chunk;\r\n   ```\r\n   \r\n   then here we can just assign to the pointer.\r\n   \r\n   All together, something like this will let you avoid copying the ArrayData around (which is still somewhat expensive since it contains shared_ptrs):\r\n   \r\n   ```diff\r\n   diff --git a/cpp/src/arrow/compute/kernels/vector_replace.cc b/cpp/src/arrow/compute/kernels/vector_replace.cc\r\n   index 6651e4859..92846fc25 100644\r\n   --- a/cpp/src/arrow/compute/kernels/vector_replace.cc\r\n   +++ b/cpp/src/arrow/compute/kernels/vector_replace.cc\r\n   @@ -452,9 +452,9 @@ struct ReplaceWithMaskFunctor {\r\n    \r\n    // This is for fixed-size types only\r\n    template <typename Type>\r\n   -void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_bitmap,\r\n   +void FillNullInDirectionImpl(const ArrayData& current_chunk, const uint8_t* null_bitmap,\r\n                                 ArrayData* output, int8_t direction,\r\n   -                             ArrayData last_valid_value_chunk,\r\n   +                             const ArrayData& last_valid_value_chunk,\r\n                                 int64_t* last_valid_value_offset) {\r\n      uint8_t* out_bitmap = output->buffers[0]->mutable_data();\r\n      uint8_t* out_values = output->buffers[1]->mutable_data();\r\n   @@ -464,6 +464,7 @@ void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_\r\n                                      /*out_offset=*/output->offset, current_chunk,\r\n                                      /*in_offset=*/0, current_chunk.length);\r\n    \r\n   +  const ArrayData* source_chunk = &last_valid_value_chunk;\r\n      bool has_fill_value = *last_valid_value_offset != -1;\r\n      int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\r\n      int64_t bitmap_offset = 0;\r\n   @@ -477,7 +478,7 @@ void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_\r\n          *last_valid_value_offset =\r\n              write_offset + direction * (block.length - 1 + bitmap_offset);\r\n          has_fill_value = true;\r\n   -      last_valid_value_chunk = current_chunk;\r\n   +      source_chunk = &current_chunk;\r\n        } else {\r\n          uint64_t block_start_offset = write_offset + direction * bitmap_offset;\r\n          uint64_t write_value_offset = block_start_offset;\r\n   @@ -485,8 +486,8 @@ void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_\r\n            auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\r\n            if (!current_bit) {\r\n              if (has_fill_value) {\r\n   -            ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\r\n   -                                            write_value_offset, last_valid_value_chunk,\r\n   +            ReplaceWithMask<Type>::CopyData(*source_chunk->type, out_values,\r\n   +                                            write_value_offset, *source_chunk,\r\n                                                *last_valid_value_offset,\r\n                                                /*length=*/1);\r\n                bit_util::SetBitTo(out_bitmap, write_value_offset, true);\r\n   @@ -494,7 +495,7 @@ void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_\r\n            } else {\r\n              has_fill_value = true;\r\n              *last_valid_value_offset = write_value_offset;\r\n   -          last_valid_value_chunk = current_chunk;\r\n   +          source_chunk = &current_chunk;\r\n            }\r\n          }\r\n        }\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,409 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      last_valid_value_chunk = current_chunk;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+        auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+        if (!current_bit) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                            write_value_offset, last_valid_value_chunk,\n+                                            *last_valid_value_offset,\n+                                            /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        } else {\n+          has_fill_value = true;\n+          *last_valid_value_offset = write_value_offset;\n+          last_valid_value_chunk = current_chunk;\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n+\n+static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+  int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+  return write_offset;\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    std::vector<std::tuple<bool, uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/0, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/0, -1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullForwardArray(ctx, array_input, out, array_input,\n+                                    &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                     ArrayData last_valid_value_chunk,\n+                                     int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    /*if (!output->buffers[0]) {\n+      ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    }*/\n\nReview comment:\n       nit: don't leave behind commented code\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,409 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      last_valid_value_chunk = current_chunk;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+        auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+        if (!current_bit) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                            write_value_offset, last_valid_value_chunk,\n+                                            *last_valid_value_offset,\n+                                            /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        } else {\n+          has_fill_value = true;\n+          *last_valid_value_offset = write_value_offset;\n+          last_valid_value_chunk = current_chunk;\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n+\n+static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+  int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+  return write_offset;\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    std::vector<std::tuple<bool, uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/0, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/0, -1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullForwardArray(ctx, array_input, out, array_input,\n+                                    &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                     ArrayData last_valid_value_chunk,\n+                                     int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    /*if (!output->buffers[0]) {\n+      ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    }*/\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, array.buffers[0]->data(), output, direction, last_valid_value_chunk,\n+          last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = LastElementOffset(array, direction);\n\nReview comment:\n       I'm not sure this is worth factoring out into a separate function instead of just inlining it here and below.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,409 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      last_valid_value_chunk = current_chunk;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+        auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+        if (!current_bit) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                            write_value_offset, last_valid_value_chunk,\n+                                            *last_valid_value_offset,\n+                                            /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        } else {\n+          has_fill_value = true;\n+          *last_valid_value_offset = write_value_offset;\n+          last_valid_value_chunk = current_chunk;\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n+\n+static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+  int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+  return write_offset;\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    std::vector<std::tuple<bool, uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/0, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/0, -1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullForwardArray(ctx, array_input, out, array_input,\n+                                    &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                     ArrayData last_valid_value_chunk,\n+                                     int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    /*if (!output->buffers[0]) {\n+      ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    }*/\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, array.buffers[0]->data(), output, direction, last_valid_value_chunk,\n+          last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = LastElementOffset(array, direction);\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullForwardChunkedArray(KernelContext* ctx,\n+                                            const std::shared_ptr<ChunkedArray>& values,\n+                                            Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    std::vector<std::shared_ptr<Array>> new_chunks;\n+\n+    if (values->length() > 0) {\n+      ArrayData array_with_current = *values->chunk(/*first_chunk=*/0)->data();\n+      int64_t last_valid_value_offset = -1;\n+      for (const auto& chunk : values->chunks()) {\n+        auto buffer_size = chunk->length() * bit_width(values->type()->id()) / 8;\n+\n+        std::unique_ptr<ArrayBuilder> builder;\n+        RETURN_NOT_OK(MakeBuilder(ctx->memory_pool(), values->type(), &builder));\n+        RETURN_NOT_OK(builder->Reserve(chunk->length()));\n+        ARROW_ASSIGN_OR_RAISE(auto array_output, builder->Finish());\n+        ARROW_ASSIGN_OR_RAISE(array_output->data()->buffers[1],\n+                              ctx->Allocate(buffer_size));\n+        ARROW_ASSIGN_OR_RAISE(array_output->data()->buffers[0],\n+                              ctx->AllocateBitmap(chunk->length()));\n\nReview comment:\n       Instead of doing this, can we push the allocation into the kernel implementation itself?\r\n   \r\n   It would have to be something like\r\n   ```cpp\r\n   auto* output = out->mutable_array();\r\n   auto bit_width = checked_cast<const FixedWidthType&>(*output.type).bit_width();\r\n   auto data_bytes = bit_util::BytesForBits(bit_width * chunk->length);\r\n   ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(chunk->length));\r\n   ARROW_ASSIGN_OR_RAISE(output->buffers[1], ctx->Allocate(data_bytes));\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace_test.cc\n##########\n@@ -798,5 +828,688 @@ TYPED_TEST(TestReplaceBinary, ReplaceWithMaskRandom) {\n   }\n }\n \n+template <typename T>\n+class TestFillNullNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+TYPED_TEST_SUITE(TestFillNullNumeric, NumericBasedTypes);\n+TYPED_TEST_SUITE(TestFillNullDecimal, DecimalArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullBinary, BaseBinaryArrowTypes);\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[]\"), this->array(\"[]\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[null, null, null, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[null, null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[null, null, 4, 4, 5, 5]\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1,4,null]\"),\n+                            this->array(\"[1,4,4]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 6]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 6]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"30.00\"])\"),\n+                            this->array(R\"([null, null, null, \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, \"30.00\", null])\"),\n+                            this->array(R\"([null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([null, null, \"30.00\",null, \"5.00\", null])\"),\n+      this->array(R\"([null, null, \"30.00\", \"30.00\", \"5.00\", \"5.00\"])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([\"10.00\",\"30.00\",null])\"),\n+                            this->array(R\"([\"10.00\",\"30.00\",\"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"10.00\", \"30.00\", null, null, null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"30.00\", \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"5.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, \"ccc\"])\"),\n+                            this->array(R\"([null, null, null, \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, \"ccc\", null])\"),\n+                            this->array(R\"([null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, \"ccc\",null, \"xyz\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\", \"xyz\", \"xyz\"])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([\"aaa\",\"ccc\",null])\"),\n+                            this->array(R\"([\"aaa\",\"ccc\",\"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, null, null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"ccc\", \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"qwert\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"xyz\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", null])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[]\"), this->array(\"[]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, 4, null, null, null]\"),\n+                            this->array(\"[4, 4,null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[4, 4, 4, 5, 5, null]\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null]\"),\n+                            this->array(\"[1, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,null, null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 , 5, 5, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 6]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 6, 6, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, \"40.00\", null, null, null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\",null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"40.00\"])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\"])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([null, null, \"40.00\",null, \"50.00\", null])\"),\n+      this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"50.00\", \"50.00\", null])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([\"10.00\", \"40.00\", null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"10.00\", \"40.00\", null, null, null, null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" , \"50.00\", \"50.00\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"50.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"50.00\", \"50.00\", \"50.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"6.00\", \"6.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, \"afd\", null, null, null])\"),\n+                            this->array(R\"([\"afd\", \"afd\",null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, \"afd\"])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\"])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, \"afd\",null, \"qwe\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"qwe\", \"qwe\", null])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([\"tyu\", \"afd\", null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"tyu\", \"afd\", null, null, null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" , \"qwe\", \"qwe\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"oiutyu\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"oiutyu\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"qwe\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"qwe\", \"qwe\", \"qwe\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", null])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"oiutyu\", \"oiutyu\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+}\n+\n+// For Test Blocks\n+TYPED_TEST(TestFillNullNumeric, FillNullForwardLargeInput) {\n+  using CType = typename TypeTraits<TypeParam>::CType;\n+  random::RandomArrayGenerator rand(/*seed=*/1000);\n+  int64_t len_null = 500;\n+  int64_t len_random = 1000;\n+  std::shared_ptr<Array> array_random =\n+      rand.Numeric<TypeParam>(len_random, /*min=*/0, /*max=*/200, /*nulls=*/0);\n+\n+  if (array_random) {\n\nReview comment:\n       Ping here.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,409 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      last_valid_value_chunk = current_chunk;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+        auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+        if (!current_bit) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                            write_value_offset, last_valid_value_chunk,\n+                                            *last_valid_value_offset,\n+                                            /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        } else {\n+          has_fill_value = true;\n+          *last_valid_value_offset = write_value_offset;\n+          last_valid_value_chunk = current_chunk;\n+        }\n+      }\n+    }\n\nReview comment:\n       Note that if block.popcount is 0, it may still be worth duplicating this loop and removing the bitmap check and `has_fill_value` check. I was just saying that it is not worth allocating a Scalar for that case.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,409 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      last_valid_value_chunk = current_chunk;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+        auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+        if (!current_bit) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                            write_value_offset, last_valid_value_chunk,\n+                                            *last_valid_value_offset,\n+                                            /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        } else {\n+          has_fill_value = true;\n+          *last_valid_value_offset = write_value_offset;\n+          last_valid_value_chunk = current_chunk;\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n+\n+static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+  int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+  return write_offset;\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+\n\nReview comment:\n       nit: why the blank line here?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,409 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      last_valid_value_chunk = current_chunk;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+        auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+        if (!current_bit) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                            write_value_offset, last_valid_value_chunk,\n+                                            *last_valid_value_offset,\n+                                            /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        } else {\n+          has_fill_value = true;\n+          *last_valid_value_offset = write_value_offset;\n+          last_valid_value_chunk = current_chunk;\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n+\n+static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+  int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+  return write_offset;\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    std::vector<std::tuple<bool, uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/0, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/0, -1U, -1U));\n\nReview comment:\n       If we're going to use negative numbers, then just make the offsets `int64_t`. Arrow generally uses signed offsets/lengths anyways.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,409 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      last_valid_value_chunk = current_chunk;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+        auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+        if (!current_bit) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                            write_value_offset, last_valid_value_chunk,\n+                                            *last_valid_value_offset,\n+                                            /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        } else {\n+          has_fill_value = true;\n+          *last_valid_value_offset = write_value_offset;\n+          last_valid_value_chunk = current_chunk;\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n+\n+static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+  int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+  return write_offset;\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    std::vector<std::tuple<bool, uint64_t, uint64_t>> offsets_reversed;\n\nReview comment:\n       Can we leave a comment about what the tuple members mean?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,409 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      last_valid_value_chunk = current_chunk;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+        auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+        if (!current_bit) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                            write_value_offset, last_valid_value_chunk,\n+                                            *last_valid_value_offset,\n+                                            /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        } else {\n+          has_fill_value = true;\n+          *last_valid_value_offset = write_value_offset;\n+          last_valid_value_chunk = current_chunk;\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n+\n+static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+  int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+  return write_offset;\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    std::vector<std::tuple<bool, uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n\nReview comment:\n       ```suggestion\r\n                 std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,409 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_bitmap,\n\nReview comment:\n       ```suggestion\r\n   void FillNullInDirectionImpl(const ArrayData& current_chunk, const uint8_t* null_bitmap,\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,409 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      last_valid_value_chunk = current_chunk;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+        auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+        if (!current_bit) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                            write_value_offset, last_valid_value_chunk,\n+                                            *last_valid_value_offset,\n+                                            /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        } else {\n+          has_fill_value = true;\n+          *last_valid_value_offset = write_value_offset;\n+          last_valid_value_chunk = current_chunk;\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n+\n+static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+  int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+  return write_offset;\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n\nReview comment:\n       again, please pass as `const ArrayData&`\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,409 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData last_valid_value_chunk,\n\nReview comment:\n       ```suggestion\r\n                                const ArrayData& last_valid_value_chunk,\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,409 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      last_valid_value_chunk = current_chunk;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+        auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+        if (!current_bit) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                            write_value_offset, last_valid_value_chunk,\n+                                            *last_valid_value_offset,\n+                                            /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        } else {\n+          has_fill_value = true;\n+          *last_valid_value_offset = write_value_offset;\n+          last_valid_value_chunk = current_chunk;\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n+\n+static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+  int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+  return write_offset;\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    std::vector<std::tuple<bool, uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/0, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/0, -1U, -1U));\n\nReview comment:\n       ```suggestion\r\n               offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/false, -1U, -1U));\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,409 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      last_valid_value_chunk = current_chunk;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+        auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+        if (!current_bit) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                            write_value_offset, last_valid_value_chunk,\n+                                            *last_valid_value_offset,\n+                                            /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        } else {\n+          has_fill_value = true;\n+          *last_valid_value_offset = write_value_offset;\n+          last_valid_value_chunk = current_chunk;\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n+\n+static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+  int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+  return write_offset;\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    std::vector<std::tuple<bool, uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/0, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/0, -1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullForwardArray(ctx, array_input, out, array_input,\n+                                    &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                     ArrayData last_valid_value_chunk,\n+                                     int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    /*if (!output->buffers[0]) {\n+      ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    }*/\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, array.buffers[0]->data(), output, direction, last_valid_value_chunk,\n+          last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = LastElementOffset(array, direction);\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullForwardChunkedArray(KernelContext* ctx,\n+                                            const std::shared_ptr<ChunkedArray>& values,\n+                                            Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    std::vector<std::shared_ptr<Array>> new_chunks;\n+\n+    if (values->length() > 0) {\n+      ArrayData array_with_current = *values->chunk(/*first_chunk=*/0)->data();\n+      int64_t last_valid_value_offset = -1;\n+      for (const auto& chunk : values->chunks()) {\n+        auto buffer_size = chunk->length() * bit_width(values->type()->id()) / 8;\n+\n+        std::unique_ptr<ArrayBuilder> builder;\n+        RETURN_NOT_OK(MakeBuilder(ctx->memory_pool(), values->type(), &builder));\n+        RETURN_NOT_OK(builder->Reserve(chunk->length()));\n+        ARROW_ASSIGN_OR_RAISE(auto array_output, builder->Finish());\n+        ARROW_ASSIGN_OR_RAISE(array_output->data()->buffers[1],\n+                              ctx->Allocate(buffer_size));\n+        ARROW_ASSIGN_OR_RAISE(array_output->data()->buffers[0],\n+                              ctx->AllocateBitmap(chunk->length()));\n\nReview comment:\n       The reason why I prefer not to do this here is because in the case of strings, it is redundant with what the kernel itself does.\r\n   \r\n   As mentioned previously, the kernel registration below will have to be adjusted:\r\n   ```\r\n   kernel.mem_allocation = MemAllocation::type::COMPUTED_NO_PREALLOCATE;\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace_test.cc\n##########\n@@ -798,5 +828,688 @@ TYPED_TEST(TestReplaceBinary, ReplaceWithMaskRandom) {\n   }\n }\n \n+template <typename T>\n+class TestFillNullNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+TYPED_TEST_SUITE(TestFillNullNumeric, NumericBasedTypes);\n+TYPED_TEST_SUITE(TestFillNullDecimal, DecimalArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullBinary, BaseBinaryArrowTypes);\n\nReview comment:\n       Ping here.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,409 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      last_valid_value_chunk = current_chunk;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+        auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+        if (!current_bit) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                            write_value_offset, last_valid_value_chunk,\n+                                            *last_valid_value_offset,\n+                                            /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        } else {\n+          has_fill_value = true;\n+          *last_valid_value_offset = write_value_offset;\n+          last_valid_value_chunk = current_chunk;\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n+\n+static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+  int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+  return write_offset;\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    std::vector<std::tuple<bool, uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/0, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/0, -1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullForwardArray(ctx, array_input, out, array_input,\n+                                    &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                     ArrayData last_valid_value_chunk,\n+                                     int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    /*if (!output->buffers[0]) {\n+      ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    }*/\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, array.buffers[0]->data(), output, direction, last_valid_value_chunk,\n+          last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = LastElementOffset(array, direction);\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullForwardChunkedArray(KernelContext* ctx,\n+                                            const std::shared_ptr<ChunkedArray>& values,\n+                                            Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    std::vector<std::shared_ptr<Array>> new_chunks;\n+\n+    if (values->length() > 0) {\n+      ArrayData array_with_current = *values->chunk(/*first_chunk=*/0)->data();\n+      int64_t last_valid_value_offset = -1;\n+      for (const auto& chunk : values->chunks()) {\n+        auto buffer_size = chunk->length() * bit_width(values->type()->id()) / 8;\n+\n+        std::unique_ptr<ArrayBuilder> builder;\n+        RETURN_NOT_OK(MakeBuilder(ctx->memory_pool(), values->type(), &builder));\n+        RETURN_NOT_OK(builder->Reserve(chunk->length()));\n+        ARROW_ASSIGN_OR_RAISE(auto array_output, builder->Finish());\n+        ARROW_ASSIGN_OR_RAISE(array_output->data()->buffers[1],\n+                              ctx->Allocate(buffer_size));\n+        ARROW_ASSIGN_OR_RAISE(array_output->data()->buffers[0],\n+                              ctx->AllocateBitmap(chunk->length()));\n\nReview comment:\n       Alternatively, you can try a check like the following right here:\r\n   \r\n   ```cpp\r\n   if (is_fixed_width(out->type()->id())) {\r\n      // ...snippet from above\r\n   }\r\n   // otherwise, the kernel implementation itself will allocate\r\n   ```\r\n   \r\n   But we shouldn't need a builder just to allocate the output.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-17T13:59:50.007+0000",
                    "updated": "2021-12-17T13:59:50.007+0000",
                    "started": "2021-12-17T13:59:50.007+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "697901",
                    "issueId": "13111093"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/worklog/701724",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "AlvinJ15 commented on pull request #11853:\nURL: https://github.com/apache/arrow/pull/11853#issuecomment-1002310526\n\n\n   @lidavidm I resolved all comments. The AppVeyor  gave me errors on pipeline, how Can I solve that error?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-28T22:46:49.285+0000",
                    "updated": "2021-12-28T22:46:49.285+0000",
                    "started": "2021-12-28T22:46:49.285+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "701724",
                    "issueId": "13111093"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/worklog/701725",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #11853:\nURL: https://github.com/apache/arrow/pull/11853#issuecomment-1002311169\n\n\n   It's not related to this PR. We can ignore it.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-28T22:49:42.375+0000",
                    "updated": "2021-12-28T22:49:42.375+0000",
                    "started": "2021-12-28T22:49:42.374+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "701725",
                    "issueId": "13111093"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/worklog/701928",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11853:\nURL: https://github.com/apache/arrow/pull/11853#discussion_r776355791\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,414 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n+\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+  bool use_current_chunk = false;\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      use_current_chunk = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      if (block.popcount) {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(\n+                  *current_chunk.type, out_values, write_value_offset,\n+                  use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                  *last_valid_value_offset,\n+                  /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            use_current_chunk = true;\n+            *last_valid_value_offset = write_value_offset;\n+          }\n+        }\n+      } else {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(\n+                *current_chunk.type, out_values, write_value_offset,\n+                use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                *last_valid_value_offset,\n+                /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& current_chunk,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(current_chunk.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(current_chunk.length));\n+    RETURN_NOT_OK(builder.ReserveData(current_chunk.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : current_chunk.length - 1;\n+    const uint8_t* data = current_chunk.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = current_chunk.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    /*tuple for store: <use current_chunk(true) or last_valid_chunk(false),\n+     * start offset of the current value, end offset for the current value>*/\n+    std::vector<std::tuple<bool, int64_t, int64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, output->offset, current_chunk.length,\n+        current_chunk.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/false, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/false, -1, -1));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = current_chunk.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullForwardArray(ctx, array_input, out, array_input,\n+                                    &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                     const ArrayData& last_valid_value_chunk,\n+                                     int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto null_bitmap,\n+          arrow::internal::CopyBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                      array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(ctx, array, null_bitmap->data(), output,\n+                                                  direction, last_valid_value_chunk,\n+                                                  last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = direction != 1 ? 0 : array.length - 1;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullForwardChunkedArray(KernelContext* ctx,\n+                                            const std::shared_ptr<ChunkedArray>& values,\n+                                            Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+\n+    ArrayVector new_chunks;\n+    if (values->length() > 0) {\n+      ArrayData array_with_current = *values->chunk(/*first_chunk=*/0)->data();\n+      int64_t last_valid_value_offset = -1;\n+\n+      for (const auto& chunk : values->chunks()) {\n+        if (is_fixed_width(out->type()->id())) {\n+          auto* output = out->mutable_array();\n+          auto bit_width = checked_cast<const FixedWidthType&>(*output->type).bit_width();\n+          auto data_bytes = bit_util::BytesForBits(bit_width * chunk->length());\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(chunk->length()));\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[1], ctx->Allocate(data_bytes));\n+        }\n+        DCHECK_OK(FillNullForwardArray(ctx, *chunk->data(), out, array_with_current,\n+                                       &last_valid_value_offset));\n+        if (chunk->null_count() != chunk->length()) {\n+          array_with_current = *chunk->data();\n+        }\n+        new_chunks.push_back(MakeArray(out->make_array()->data()->Copy()));\n+      }\n+    }\n+\n+    auto output = std::make_shared<ChunkedArray>(std::move(new_chunks), values->type());\n+    *out = Datum(output);\n+    return Status::OK();\n+  }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make({InputType::Array(get_id.id)}, OutputType(FirstType));\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullBackwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullBackwardArray(ctx, array_input, out, array_input,\n+                                     &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullBackwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullBackwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                      const ArrayData& last_valid_value_chunk,\n+                                      int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = -1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto reversed_bitmap,\n+          arrow::internal::ReverseBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                         array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, reversed_bitmap->data(), output, direction, last_valid_value_chunk,\n+          last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = direction != 1 ? 0 : array.length - 1;\n\nReview comment:\n       Why the ternary? The direction is always -1, right?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace_test.cc\n##########\n@@ -793,5 +851,772 @@ TYPED_TEST(TestReplaceBinary, ReplaceWithMaskRandom) {\n   }\n }\n \n+template <typename T>\n+class TestFillNullNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+template <typename T>\n+class TestFillNullNullType : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+TYPED_TEST_SUITE(TestFillNullNumeric, NumericBasedTypes);\n+TYPED_TEST_SUITE(TestFillNullDecimal, DecimalArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullBinary, BaseBinaryArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullNullType, ::testing::Types<NullType>);\n\nReview comment:\n       Note: you can just declare `class TestFillNullType : public TestReplaceKernel<NullType>` and then use `TEST_F(TestFillNullType, ...)` - it'll save you a bit of mucking about.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,414 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n+\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+  bool use_current_chunk = false;\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      use_current_chunk = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      if (block.popcount) {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(\n+                  *current_chunk.type, out_values, write_value_offset,\n+                  use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                  *last_valid_value_offset,\n+                  /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            use_current_chunk = true;\n+            *last_valid_value_offset = write_value_offset;\n+          }\n+        }\n+      } else {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(\n+                *current_chunk.type, out_values, write_value_offset,\n+                use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                *last_valid_value_offset,\n+                /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& current_chunk,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(current_chunk.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(current_chunk.length));\n+    RETURN_NOT_OK(builder.ReserveData(current_chunk.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : current_chunk.length - 1;\n+    const uint8_t* data = current_chunk.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = current_chunk.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    /*tuple for store: <use current_chunk(true) or last_valid_chunk(false),\n+     * start offset of the current value, end offset for the current value>*/\n+    std::vector<std::tuple<bool, int64_t, int64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, output->offset, current_chunk.length,\n+        current_chunk.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/false, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/false, -1, -1));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = current_chunk.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullForwardArray(ctx, array_input, out, array_input,\n+                                    &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n\nReview comment:\n       ```suggestion\r\n       return Status::NotImplemented(\r\n           \"Unsupported type for fill_null_forward: \",\r\n           batch[0].ToString());\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace_test.cc\n##########\n@@ -798,5 +828,688 @@ TYPED_TEST(TestReplaceBinary, ReplaceWithMaskRandom) {\n   }\n }\n \n+template <typename T>\n+class TestFillNullNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+TYPED_TEST_SUITE(TestFillNullNumeric, NumericBasedTypes);\n+TYPED_TEST_SUITE(TestFillNullDecimal, DecimalArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullBinary, BaseBinaryArrowTypes);\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[]\"), this->array(\"[]\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[null, null, null, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[null, null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[null, null, 4, 4, 5, 5]\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1,4,null]\"),\n+                            this->array(\"[1,4,4]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 6]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 6]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"30.00\"])\"),\n+                            this->array(R\"([null, null, null, \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, \"30.00\", null])\"),\n+                            this->array(R\"([null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([null, null, \"30.00\",null, \"5.00\", null])\"),\n+      this->array(R\"([null, null, \"30.00\", \"30.00\", \"5.00\", \"5.00\"])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([\"10.00\",\"30.00\",null])\"),\n+                            this->array(R\"([\"10.00\",\"30.00\",\"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"10.00\", \"30.00\", null, null, null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"30.00\", \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"5.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, \"ccc\"])\"),\n+                            this->array(R\"([null, null, null, \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, \"ccc\", null])\"),\n+                            this->array(R\"([null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, \"ccc\",null, \"xyz\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\", \"xyz\", \"xyz\"])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([\"aaa\",\"ccc\",null])\"),\n+                            this->array(R\"([\"aaa\",\"ccc\",\"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, null, null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"ccc\", \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"qwert\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"xyz\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", null])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[]\"), this->array(\"[]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, 4, null, null, null]\"),\n+                            this->array(\"[4, 4,null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[4, 4, 4, 5, 5, null]\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null]\"),\n+                            this->array(\"[1, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,null, null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 , 5, 5, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 6]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 6, 6, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, \"40.00\", null, null, null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\",null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"40.00\"])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\"])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([null, null, \"40.00\",null, \"50.00\", null])\"),\n+      this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"50.00\", \"50.00\", null])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([\"10.00\", \"40.00\", null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"10.00\", \"40.00\", null, null, null, null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" , \"50.00\", \"50.00\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"50.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"50.00\", \"50.00\", \"50.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"6.00\", \"6.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, \"afd\", null, null, null])\"),\n+                            this->array(R\"([\"afd\", \"afd\",null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, \"afd\"])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\"])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, \"afd\",null, \"qwe\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"qwe\", \"qwe\", null])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([\"tyu\", \"afd\", null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"tyu\", \"afd\", null, null, null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" , \"qwe\", \"qwe\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"oiutyu\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"oiutyu\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"qwe\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"qwe\", \"qwe\", \"qwe\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", null])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"oiutyu\", \"oiutyu\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+}\n+\n+// For Test Blocks\n+TYPED_TEST(TestFillNullNumeric, FillNullForwardLargeInput) {\n+  using CType = typename TypeTraits<TypeParam>::CType;\n+  random::RandomArrayGenerator rand(/*seed=*/1000);\n+  int64_t len_null = 500;\n+  int64_t len_random = 1000;\n+  std::shared_ptr<Array> array_random =\n+      rand.Numeric<TypeParam>(len_random, /*min=*/0, /*max=*/200, /*nulls=*/0);\n+\n+  if (array_random) {\n\nReview comment:\n       Just a reminder here. \n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,414 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n+\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+  bool use_current_chunk = false;\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      use_current_chunk = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      if (block.popcount) {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(\n+                  *current_chunk.type, out_values, write_value_offset,\n+                  use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                  *last_valid_value_offset,\n+                  /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            use_current_chunk = true;\n+            *last_valid_value_offset = write_value_offset;\n+          }\n+        }\n+      } else {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(\n+                *current_chunk.type, out_values, write_value_offset,\n+                use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                *last_valid_value_offset,\n+                /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& current_chunk,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(current_chunk.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(current_chunk.length));\n+    RETURN_NOT_OK(builder.ReserveData(current_chunk.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : current_chunk.length - 1;\n+    const uint8_t* data = current_chunk.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = current_chunk.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    /*tuple for store: <use current_chunk(true) or last_valid_chunk(false),\n+     * start offset of the current value, end offset for the current value>*/\n+    std::vector<std::tuple<bool, int64_t, int64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, output->offset, current_chunk.length,\n+        current_chunk.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/false, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/false, -1, -1));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = current_chunk.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullForwardArray(ctx, array_input, out, array_input,\n+                                    &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                     const ArrayData& last_valid_value_chunk,\n+                                     int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto null_bitmap,\n+          arrow::internal::CopyBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                      array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(ctx, array, null_bitmap->data(), output,\n+                                                  direction, last_valid_value_chunk,\n+                                                  last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = direction != 1 ? 0 : array.length - 1;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullForwardChunkedArray(KernelContext* ctx,\n+                                            const std::shared_ptr<ChunkedArray>& values,\n+                                            Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+\n+    ArrayVector new_chunks;\n+    if (values->length() > 0) {\n+      ArrayData array_with_current = *values->chunk(/*first_chunk=*/0)->data();\n+      int64_t last_valid_value_offset = -1;\n+\n+      for (const auto& chunk : values->chunks()) {\n+        if (is_fixed_width(out->type()->id())) {\n+          auto* output = out->mutable_array();\n+          auto bit_width = checked_cast<const FixedWidthType&>(*output->type).bit_width();\n+          auto data_bytes = bit_util::BytesForBits(bit_width * chunk->length());\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(chunk->length()));\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[1], ctx->Allocate(data_bytes));\n+        }\n+        DCHECK_OK(FillNullForwardArray(ctx, *chunk->data(), out, array_with_current,\n+                                       &last_valid_value_offset));\n+        if (chunk->null_count() != chunk->length()) {\n+          array_with_current = *chunk->data();\n+        }\n+        new_chunks.push_back(MakeArray(out->make_array()->data()->Copy()));\n+      }\n+    }\n+\n+    auto output = std::make_shared<ChunkedArray>(std::move(new_chunks), values->type());\n+    *out = Datum(output);\n+    return Status::OK();\n+  }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make({InputType::Array(get_id.id)}, OutputType(FirstType));\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullBackwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullBackwardArray(ctx, array_input, out, array_input,\n+                                     &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullBackwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullBackwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                      const ArrayData& last_valid_value_chunk,\n+                                      int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = -1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto reversed_bitmap,\n+          arrow::internal::ReverseBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                         array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, reversed_bitmap->data(), output, direction, last_valid_value_chunk,\n+          last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = direction != 1 ? 0 : array.length - 1;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullBackwardChunkedArray(KernelContext* ctx,\n+                                             const std::shared_ptr<ChunkedArray>& values,\n+                                             Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    std::vector<std::shared_ptr<Array>> new_chunks;\n+\n+    if (values->length() > 0) {\n+      auto chunks_length = values->chunks().size();\n+      ArrayData array_with_current =\n\nReview comment:\n       Can we use `ArrayData*` to avoid a copy?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,414 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n+\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+  bool use_current_chunk = false;\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      use_current_chunk = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      if (block.popcount) {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(\n+                  *current_chunk.type, out_values, write_value_offset,\n+                  use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                  *last_valid_value_offset,\n+                  /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            use_current_chunk = true;\n+            *last_valid_value_offset = write_value_offset;\n+          }\n+        }\n+      } else {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(\n+                *current_chunk.type, out_values, write_value_offset,\n+                use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                *last_valid_value_offset,\n+                /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& current_chunk,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(current_chunk.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(current_chunk.length));\n+    RETURN_NOT_OK(builder.ReserveData(current_chunk.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : current_chunk.length - 1;\n+    const uint8_t* data = current_chunk.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = current_chunk.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    /*tuple for store: <use current_chunk(true) or last_valid_chunk(false),\n+     * start offset of the current value, end offset for the current value>*/\n+    std::vector<std::tuple<bool, int64_t, int64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, output->offset, current_chunk.length,\n+        current_chunk.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/false, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/false, -1, -1));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = current_chunk.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullForwardArray(ctx, array_input, out, array_input,\n+                                    &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                     const ArrayData& last_valid_value_chunk,\n+                                     int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto null_bitmap,\n+          arrow::internal::CopyBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                      array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(ctx, array, null_bitmap->data(), output,\n+                                                  direction, last_valid_value_chunk,\n+                                                  last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = direction != 1 ? 0 : array.length - 1;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullForwardChunkedArray(KernelContext* ctx,\n+                                            const std::shared_ptr<ChunkedArray>& values,\n+                                            Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+\n+    ArrayVector new_chunks;\n+    if (values->length() > 0) {\n+      ArrayData array_with_current = *values->chunk(/*first_chunk=*/0)->data();\n+      int64_t last_valid_value_offset = -1;\n+\n+      for (const auto& chunk : values->chunks()) {\n+        if (is_fixed_width(out->type()->id())) {\n+          auto* output = out->mutable_array();\n+          auto bit_width = checked_cast<const FixedWidthType&>(*output->type).bit_width();\n+          auto data_bytes = bit_util::BytesForBits(bit_width * chunk->length());\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(chunk->length()));\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[1], ctx->Allocate(data_bytes));\n+        }\n+        DCHECK_OK(FillNullForwardArray(ctx, *chunk->data(), out, array_with_current,\n+                                       &last_valid_value_offset));\n+        if (chunk->null_count() != chunk->length()) {\n+          array_with_current = *chunk->data();\n+        }\n+        new_chunks.push_back(MakeArray(out->make_array()->data()->Copy()));\n+      }\n+    }\n+\n+    auto output = std::make_shared<ChunkedArray>(std::move(new_chunks), values->type());\n+    *out = Datum(output);\n+    return Status::OK();\n+  }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make({InputType::Array(get_id.id)}, OutputType(FirstType));\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullBackwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullBackwardArray(ctx, array_input, out, array_input,\n+                                     &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullBackwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n\nReview comment:\n       ```suggestion\r\n       return Status::NotImplemented(\r\n           \"Unsupported type for fill_null_backward operation: \",\r\n           batch[0].ToString());\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,414 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n+\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+  bool use_current_chunk = false;\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      use_current_chunk = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      if (block.popcount) {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(\n+                  *current_chunk.type, out_values, write_value_offset,\n+                  use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                  *last_valid_value_offset,\n+                  /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            use_current_chunk = true;\n+            *last_valid_value_offset = write_value_offset;\n+          }\n+        }\n+      } else {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(\n+                *current_chunk.type, out_values, write_value_offset,\n+                use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                *last_valid_value_offset,\n+                /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& current_chunk,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(current_chunk.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(current_chunk.length));\n+    RETURN_NOT_OK(builder.ReserveData(current_chunk.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : current_chunk.length - 1;\n+    const uint8_t* data = current_chunk.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = current_chunk.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    /*tuple for store: <use current_chunk(true) or last_valid_chunk(false),\n+     * start offset of the current value, end offset for the current value>*/\n+    std::vector<std::tuple<bool, int64_t, int64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, output->offset, current_chunk.length,\n+        current_chunk.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n\nReview comment:\n       nit: why not make this just one if-else if-else?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,414 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n+\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+  bool use_current_chunk = false;\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      use_current_chunk = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      if (block.popcount) {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(\n+                  *current_chunk.type, out_values, write_value_offset,\n+                  use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                  *last_valid_value_offset,\n+                  /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            use_current_chunk = true;\n+            *last_valid_value_offset = write_value_offset;\n+          }\n+        }\n+      } else {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(\n+                *current_chunk.type, out_values, write_value_offset,\n+                use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                *last_valid_value_offset,\n+                /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& current_chunk,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(current_chunk.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(current_chunk.length));\n+    RETURN_NOT_OK(builder.ReserveData(current_chunk.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : current_chunk.length - 1;\n+    const uint8_t* data = current_chunk.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = current_chunk.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    /*tuple for store: <use current_chunk(true) or last_valid_chunk(false),\n+     * start offset of the current value, end offset for the current value>*/\n+    std::vector<std::tuple<bool, int64_t, int64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, output->offset, current_chunk.length,\n+        current_chunk.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/false, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/false, -1, -1));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = current_chunk.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullForwardArray(ctx, array_input, out, array_input,\n+                                    &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                     const ArrayData& last_valid_value_chunk,\n+                                     int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto null_bitmap,\n+          arrow::internal::CopyBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                      array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(ctx, array, null_bitmap->data(), output,\n+                                                  direction, last_valid_value_chunk,\n+                                                  last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = direction != 1 ? 0 : array.length - 1;\n\nReview comment:\n       The direction is always 1.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,414 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n+\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+  bool use_current_chunk = false;\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      use_current_chunk = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      if (block.popcount) {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(\n+                  *current_chunk.type, out_values, write_value_offset,\n+                  use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                  *last_valid_value_offset,\n+                  /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            use_current_chunk = true;\n+            *last_valid_value_offset = write_value_offset;\n+          }\n+        }\n+      } else {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(\n+                *current_chunk.type, out_values, write_value_offset,\n+                use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                *last_valid_value_offset,\n+                /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& current_chunk,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(current_chunk.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(current_chunk.length));\n+    RETURN_NOT_OK(builder.ReserveData(current_chunk.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : current_chunk.length - 1;\n+    const uint8_t* data = current_chunk.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = current_chunk.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    /*tuple for store: <use current_chunk(true) or last_valid_chunk(false),\n+     * start offset of the current value, end offset for the current value>*/\n+    std::vector<std::tuple<bool, int64_t, int64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, output->offset, current_chunk.length,\n+        current_chunk.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/false, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/false, -1, -1));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = current_chunk.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullForwardArray(ctx, array_input, out, array_input,\n+                                    &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                     const ArrayData& last_valid_value_chunk,\n+                                     int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto null_bitmap,\n+          arrow::internal::CopyBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                      array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(ctx, array, null_bitmap->data(), output,\n+                                                  direction, last_valid_value_chunk,\n+                                                  last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = direction != 1 ? 0 : array.length - 1;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullForwardChunkedArray(KernelContext* ctx,\n+                                            const std::shared_ptr<ChunkedArray>& values,\n+                                            Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+\n+    ArrayVector new_chunks;\n+    if (values->length() > 0) {\n+      ArrayData array_with_current = *values->chunk(/*first_chunk=*/0)->data();\n+      int64_t last_valid_value_offset = -1;\n+\n+      for (const auto& chunk : values->chunks()) {\n+        if (is_fixed_width(out->type()->id())) {\n+          auto* output = out->mutable_array();\n+          auto bit_width = checked_cast<const FixedWidthType&>(*output->type).bit_width();\n+          auto data_bytes = bit_util::BytesForBits(bit_width * chunk->length());\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(chunk->length()));\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[1], ctx->Allocate(data_bytes));\n+        }\n+        DCHECK_OK(FillNullForwardArray(ctx, *chunk->data(), out, array_with_current,\n+                                       &last_valid_value_offset));\n+        if (chunk->null_count() != chunk->length()) {\n+          array_with_current = *chunk->data();\n+        }\n+        new_chunks.push_back(MakeArray(out->make_array()->data()->Copy()));\n+      }\n+    }\n+\n+    auto output = std::make_shared<ChunkedArray>(std::move(new_chunks), values->type());\n+    *out = Datum(output);\n+    return Status::OK();\n+  }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make({InputType::Array(get_id.id)}, OutputType(FirstType));\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullBackwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullBackwardArray(ctx, array_input, out, array_input,\n+                                     &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullBackwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullBackwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n\nReview comment:\n       Use `const ArrayData&` or `ArrayData*`.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,414 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n+\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+  bool use_current_chunk = false;\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      use_current_chunk = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      if (block.popcount) {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(\n+                  *current_chunk.type, out_values, write_value_offset,\n+                  use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                  *last_valid_value_offset,\n+                  /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            use_current_chunk = true;\n+            *last_valid_value_offset = write_value_offset;\n+          }\n+        }\n+      } else {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(\n+                *current_chunk.type, out_values, write_value_offset,\n+                use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                *last_valid_value_offset,\n+                /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& current_chunk,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(current_chunk.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(current_chunk.length));\n+    RETURN_NOT_OK(builder.ReserveData(current_chunk.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : current_chunk.length - 1;\n+    const uint8_t* data = current_chunk.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = current_chunk.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    /*tuple for store: <use current_chunk(true) or last_valid_chunk(false),\n+     * start offset of the current value, end offset for the current value>*/\n+    std::vector<std::tuple<bool, int64_t, int64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, output->offset, current_chunk.length,\n+        current_chunk.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/false, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/false, -1, -1));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = current_chunk.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullForwardArray(ctx, array_input, out, array_input,\n+                                    &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                     const ArrayData& last_valid_value_chunk,\n+                                     int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto null_bitmap,\n+          arrow::internal::CopyBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                      array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(ctx, array, null_bitmap->data(), output,\n+                                                  direction, last_valid_value_chunk,\n+                                                  last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = direction != 1 ? 0 : array.length - 1;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullForwardChunkedArray(KernelContext* ctx,\n+                                            const std::shared_ptr<ChunkedArray>& values,\n+                                            Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+\n+    ArrayVector new_chunks;\n+    if (values->length() > 0) {\n+      ArrayData array_with_current = *values->chunk(/*first_chunk=*/0)->data();\n+      int64_t last_valid_value_offset = -1;\n+\n+      for (const auto& chunk : values->chunks()) {\n+        if (is_fixed_width(out->type()->id())) {\n+          auto* output = out->mutable_array();\n+          auto bit_width = checked_cast<const FixedWidthType&>(*output->type).bit_width();\n+          auto data_bytes = bit_util::BytesForBits(bit_width * chunk->length());\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(chunk->length()));\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[1], ctx->Allocate(data_bytes));\n+        }\n+        DCHECK_OK(FillNullForwardArray(ctx, *chunk->data(), out, array_with_current,\n+                                       &last_valid_value_offset));\n+        if (chunk->null_count() != chunk->length()) {\n+          array_with_current = *chunk->data();\n+        }\n+        new_chunks.push_back(MakeArray(out->make_array()->data()->Copy()));\n+      }\n+    }\n+\n+    auto output = std::make_shared<ChunkedArray>(std::move(new_chunks), values->type());\n+    *out = Datum(output);\n+    return Status::OK();\n+  }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make({InputType::Array(get_id.id)}, OutputType(FirstType));\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullBackwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullBackwardArray(ctx, array_input, out, array_input,\n+                                     &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullBackwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullBackwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                      const ArrayData& last_valid_value_chunk,\n+                                      int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = -1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto reversed_bitmap,\n+          arrow::internal::ReverseBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                         array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, reversed_bitmap->data(), output, direction, last_valid_value_chunk,\n+          last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = direction != 1 ? 0 : array.length - 1;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullBackwardChunkedArray(KernelContext* ctx,\n+                                             const std::shared_ptr<ChunkedArray>& values,\n+                                             Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    std::vector<std::shared_ptr<Array>> new_chunks;\n+\n+    if (values->length() > 0) {\n+      auto chunks_length = values->chunks().size();\n+      ArrayData array_with_current =\n+          *values->chunk(/*first_chunk=*/chunks_length - 1)->data();\n+      int64_t last_valid_value_offset = -1;\n+      auto chunks = values->chunks();\n+      for (int i = chunks_length - 1; i >= 0; --i) {\n+        const auto& chunk = chunks[i];\n+        auto buffer_size = chunk->length() * bit_width(values->type()->id()) / 8;\n+\n+        std::unique_ptr<ArrayBuilder> builder;\n+        RETURN_NOT_OK(MakeBuilder(ctx->memory_pool(), values->type(), &builder));\n+        RETURN_NOT_OK(builder->Reserve(chunk->length()));\n+        ARROW_ASSIGN_OR_RAISE(auto array_output, builder->Finish());\n+        ARROW_ASSIGN_OR_RAISE(array_output->data()->buffers[1],\n+                              ctx->Allocate(buffer_size));\n\nReview comment:\n       Also, why are we doing this for all types when we know binary-like types will allocate their own buffer?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace_test.cc\n##########\n@@ -793,5 +851,772 @@ TYPED_TEST(TestReplaceBinary, ReplaceWithMaskRandom) {\n   }\n }\n \n+template <typename T>\n+class TestFillNullNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+template <typename T>\n+class TestFillNullNullType : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+TYPED_TEST_SUITE(TestFillNullNumeric, NumericBasedTypes);\n+TYPED_TEST_SUITE(TestFillNullDecimal, DecimalArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullBinary, BaseBinaryArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullNullType, ::testing::Types<NullType>);\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[]\"), this->array(\"[]\"));\n+\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[null, null, null, 4]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[null, 4, 4]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[null, null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[null, null, 4, 4, 5, 5]\"));\n+\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[1,4,null]\"),\n+                            this->array(\"[1,4,4]\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 6]\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 6]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(R\"([null, null, null, \"30.00\"])\"),\n+                            this->array(R\"([null, null, null, \"30.00\"])\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([null, \"30.00\", null])\"),\n+                            this->array(R\"([null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(R\"([null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(R\"([null, null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward, this->array(R\"([null, null, \"30.00\",null, \"5.00\", null])\"),\n+      this->array(R\"([null, null, \"30.00\", \"30.00\", \"5.00\", \"5.00\"])\"));\n+\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([\"10.00\",\"30.00\",null])\"),\n+                            this->array(R\"([\"10.00\",\"30.00\",\"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward, this->array(R\"([\"10.00\", \"30.00\", null, null, null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"30.00\", \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward, this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"5.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward,\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([null, null, null, \"ccc\"])\"),\n+                            this->array(R\"([null, null, null, \"ccc\"])\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([null, \"ccc\", null])\"),\n+                            this->array(R\"([null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(R\"([null, null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(R\"([null, null, \"ccc\",null, \"xyz\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\", \"xyz\", \"xyz\"])\"));\n+\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([\"aaa\",\"ccc\",null])\"),\n+                            this->array(R\"([\"aaa\",\"ccc\",\"ccc\"])\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, null, null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"ccc\", \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"qwert\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"xyz\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", null])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward,\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[]\"), this->array(\"[]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[null, 4, null, null, null]\"),\n+                            this->array(\"[4, 4,null, null, null]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[4, 4, null]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[4, 4, 4, 5, 5, null]\"));\n+\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[1, 4, null]\"),\n+                            this->array(\"[1, 4, null]\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,null, null, null, null]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 , 5, 5, null, null]\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 6]\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 6, 6, null]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([null, \"40.00\", null, null, null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\",null, null, null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([null, null, null, \"40.00\"])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\"])\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([null, null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward, this->array(R\"([null, null, \"40.00\",null, \"50.00\", null])\"),\n+      this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"50.00\", \"50.00\", null])\"));\n+\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([\"10.00\", \"40.00\", null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([\"10.00\", \"40.00\", null, null, null, null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward, this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" , \"50.00\", \"50.00\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"50.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"50.00\", \"50.00\", \"50.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"6.00\", \"6.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([null, \"afd\", null, null, null])\"),\n+                            this->array(R\"([\"afd\", \"afd\",null, null, null])\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([null, null, null, \"afd\"])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\"])\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([null, null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([null, null, \"afd\",null, \"qwe\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"qwe\", \"qwe\", null])\"));\n+\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([\"tyu\", \"afd\", null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([\"tyu\", \"afd\", null, null, null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" , \"qwe\", \"qwe\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"oiutyu\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"oiutyu\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward, this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"qwe\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"qwe\", \"qwe\", \"qwe\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", null])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"oiutyu\", \"oiutyu\", null])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+}\n+\n+// For Test Blocks\n+TYPED_TEST(TestFillNullNumeric, FillNullForwardLargeInput) {\n+  using CType = typename TypeTraits<TypeParam>::CType;\n+  random::RandomArrayGenerator rand(/*seed=*/1000);\n+  int64_t len_null = 500;\n+  int64_t len_random = 1000;\n+  std::shared_ptr<Array> array_random =\n+      rand.Numeric<TypeParam>(len_random, /*min=*/0, /*max=*/200, /*nulls=*/0);\n+\n+  if (array_random) {\n+    auto x_ptr = array_random->data()->template GetValues<CType>(1);\n+    ASSERT_OK_AND_ASSIGN(auto array_null,\n+                         MakeArrayOfNull(array_random->type(), len_null));\n+    auto array_null_filled =\n+        ConstantArrayGenerator::Numeric<TypeParam>(len_null, x_ptr[len_random - 1]);\n+    {\n+      ASSERT_OK_AND_ASSIGN(auto value_array,\n+                           Concatenate({array_random, array_null, array_random}));\n+      ASSERT_OK_AND_ASSIGN(auto result_array,\n+                           Concatenate({array_random, array_null_filled, array_random}));\n+      this->AssertFillNullArray(FillNullForward, value_array, result_array);\n+    }\n+  }\n+}\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullBackwardLargeInput) {\n+  using CType = typename TypeTraits<TypeParam>::CType;\n+  random::RandomArrayGenerator rand(/*seed=*/1000);\n+  int64_t len_null = 500;\n+  int64_t len_random = 1000;\n+  std::shared_ptr<Array> array_random =\n+      rand.Numeric<TypeParam>(len_random, /*min=*/0, /*max=*/200, /*null_count=*/0);\n+\n+  if (array_random) {\n\nReview comment:\n       Why the check here?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,414 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n+\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+  bool use_current_chunk = false;\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      use_current_chunk = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      if (block.popcount) {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(\n+                  *current_chunk.type, out_values, write_value_offset,\n+                  use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                  *last_valid_value_offset,\n+                  /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            use_current_chunk = true;\n+            *last_valid_value_offset = write_value_offset;\n+          }\n+        }\n+      } else {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(\n+                *current_chunk.type, out_values, write_value_offset,\n+                use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                *last_valid_value_offset,\n+                /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& current_chunk,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(current_chunk.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(current_chunk.length));\n+    RETURN_NOT_OK(builder.ReserveData(current_chunk.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : current_chunk.length - 1;\n+    const uint8_t* data = current_chunk.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = current_chunk.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    /*tuple for store: <use current_chunk(true) or last_valid_chunk(false),\n+     * start offset of the current value, end offset for the current value>*/\n+    std::vector<std::tuple<bool, int64_t, int64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, output->offset, current_chunk.length,\n+        current_chunk.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/false, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/false, -1, -1));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = current_chunk.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullForwardArray(ctx, array_input, out, array_input,\n+                                    &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                     const ArrayData& last_valid_value_chunk,\n+                                     int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto null_bitmap,\n+          arrow::internal::CopyBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                      array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(ctx, array, null_bitmap->data(), output,\n+                                                  direction, last_valid_value_chunk,\n+                                                  last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = direction != 1 ? 0 : array.length - 1;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullForwardChunkedArray(KernelContext* ctx,\n+                                            const std::shared_ptr<ChunkedArray>& values,\n+                                            Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+\n+    ArrayVector new_chunks;\n+    if (values->length() > 0) {\n+      ArrayData array_with_current = *values->chunk(/*first_chunk=*/0)->data();\n+      int64_t last_valid_value_offset = -1;\n+\n+      for (const auto& chunk : values->chunks()) {\n+        if (is_fixed_width(out->type()->id())) {\n+          auto* output = out->mutable_array();\n+          auto bit_width = checked_cast<const FixedWidthType&>(*output->type).bit_width();\n+          auto data_bytes = bit_util::BytesForBits(bit_width * chunk->length());\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(chunk->length()));\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[1], ctx->Allocate(data_bytes));\n+        }\n+        DCHECK_OK(FillNullForwardArray(ctx, *chunk->data(), out, array_with_current,\n+                                       &last_valid_value_offset));\n+        if (chunk->null_count() != chunk->length()) {\n+          array_with_current = *chunk->data();\n+        }\n+        new_chunks.push_back(MakeArray(out->make_array()->data()->Copy()));\n+      }\n+    }\n+\n+    auto output = std::make_shared<ChunkedArray>(std::move(new_chunks), values->type());\n+    *out = Datum(output);\n+    return Status::OK();\n+  }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make({InputType::Array(get_id.id)}, OutputType(FirstType));\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullBackwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullBackwardArray(ctx, array_input, out, array_input,\n+                                     &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullBackwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullBackwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                      const ArrayData& last_valid_value_chunk,\n+                                      int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = -1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto reversed_bitmap,\n+          arrow::internal::ReverseBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                         array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, reversed_bitmap->data(), output, direction, last_valid_value_chunk,\n+          last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = direction != 1 ? 0 : array.length - 1;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullBackwardChunkedArray(KernelContext* ctx,\n+                                             const std::shared_ptr<ChunkedArray>& values,\n+                                             Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    std::vector<std::shared_ptr<Array>> new_chunks;\n+\n+    if (values->length() > 0) {\n+      auto chunks_length = values->chunks().size();\n+      ArrayData array_with_current =\n+          *values->chunk(/*first_chunk=*/chunks_length - 1)->data();\n+      int64_t last_valid_value_offset = -1;\n+      auto chunks = values->chunks();\n+      for (int i = chunks_length - 1; i >= 0; --i) {\n+        const auto& chunk = chunks[i];\n+        auto buffer_size = chunk->length() * bit_width(values->type()->id()) / 8;\n+\n+        std::unique_ptr<ArrayBuilder> builder;\n+        RETURN_NOT_OK(MakeBuilder(ctx->memory_pool(), values->type(), &builder));\n+        RETURN_NOT_OK(builder->Reserve(chunk->length()));\n+        ARROW_ASSIGN_OR_RAISE(auto array_output, builder->Finish());\n+        ARROW_ASSIGN_OR_RAISE(array_output->data()->buffers[1],\n+                              ctx->Allocate(buffer_size));\n\nReview comment:\n       Why use a builder when we already calculated a buffer size?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,414 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n+\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+  bool use_current_chunk = false;\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      use_current_chunk = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      if (block.popcount) {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(\n+                  *current_chunk.type, out_values, write_value_offset,\n+                  use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                  *last_valid_value_offset,\n+                  /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            use_current_chunk = true;\n+            *last_valid_value_offset = write_value_offset;\n+          }\n+        }\n+      } else {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(\n+                *current_chunk.type, out_values, write_value_offset,\n+                use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                *last_valid_value_offset,\n+                /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& current_chunk,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(current_chunk.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(current_chunk.length));\n+    RETURN_NOT_OK(builder.ReserveData(current_chunk.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : current_chunk.length - 1;\n+    const uint8_t* data = current_chunk.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = current_chunk.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    /*tuple for store: <use current_chunk(true) or last_valid_chunk(false),\n+     * start offset of the current value, end offset for the current value>*/\n+    std::vector<std::tuple<bool, int64_t, int64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, output->offset, current_chunk.length,\n+        current_chunk.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/false, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/false, -1, -1));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = current_chunk.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullForwardArray(ctx, array_input, out, array_input,\n+                                    &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                     const ArrayData& last_valid_value_chunk,\n+                                     int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto null_bitmap,\n+          arrow::internal::CopyBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                      array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(ctx, array, null_bitmap->data(), output,\n+                                                  direction, last_valid_value_chunk,\n+                                                  last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = direction != 1 ? 0 : array.length - 1;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullForwardChunkedArray(KernelContext* ctx,\n+                                            const std::shared_ptr<ChunkedArray>& values,\n+                                            Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+\n+    ArrayVector new_chunks;\n+    if (values->length() > 0) {\n+      ArrayData array_with_current = *values->chunk(/*first_chunk=*/0)->data();\n+      int64_t last_valid_value_offset = -1;\n+\n+      for (const auto& chunk : values->chunks()) {\n+        if (is_fixed_width(out->type()->id())) {\n+          auto* output = out->mutable_array();\n+          auto bit_width = checked_cast<const FixedWidthType&>(*output->type).bit_width();\n+          auto data_bytes = bit_util::BytesForBits(bit_width * chunk->length());\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(chunk->length()));\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[1], ctx->Allocate(data_bytes));\n+        }\n+        DCHECK_OK(FillNullForwardArray(ctx, *chunk->data(), out, array_with_current,\n+                                       &last_valid_value_offset));\n+        if (chunk->null_count() != chunk->length()) {\n+          array_with_current = *chunk->data();\n+        }\n+        new_chunks.push_back(MakeArray(out->make_array()->data()->Copy()));\n+      }\n+    }\n+\n+    auto output = std::make_shared<ChunkedArray>(std::move(new_chunks), values->type());\n+    *out = Datum(output);\n+    return Status::OK();\n+  }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make({InputType::Array(get_id.id)}, OutputType(FirstType));\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullBackwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullBackwardArray(ctx, array_input, out, array_input,\n+                                     &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullBackwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullBackwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                      const ArrayData& last_valid_value_chunk,\n+                                      int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = -1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto reversed_bitmap,\n+          arrow::internal::ReverseBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                         array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, reversed_bitmap->data(), output, direction, last_valid_value_chunk,\n+          last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = direction != 1 ? 0 : array.length - 1;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullBackwardChunkedArray(KernelContext* ctx,\n+                                             const std::shared_ptr<ChunkedArray>& values,\n+                                             Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    std::vector<std::shared_ptr<Array>> new_chunks;\n+\n+    if (values->length() > 0) {\n+      auto chunks_length = values->chunks().size();\n+      ArrayData array_with_current =\n+          *values->chunk(/*first_chunk=*/chunks_length - 1)->data();\n+      int64_t last_valid_value_offset = -1;\n+      auto chunks = values->chunks();\n+      for (int i = chunks_length - 1; i >= 0; --i) {\n+        const auto& chunk = chunks[i];\n+        auto buffer_size = chunk->length() * bit_width(values->type()->id()) / 8;\n+\n+        std::unique_ptr<ArrayBuilder> builder;\n+        RETURN_NOT_OK(MakeBuilder(ctx->memory_pool(), values->type(), &builder));\n+        RETURN_NOT_OK(builder->Reserve(chunk->length()));\n+        ARROW_ASSIGN_OR_RAISE(auto array_output, builder->Finish());\n+        ARROW_ASSIGN_OR_RAISE(array_output->data()->buffers[1],\n+                              ctx->Allocate(buffer_size));\n\nReview comment:\n       Please note, you can directly create an ArrayData. You don't have to use a builder.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-29T14:48:59.288+0000",
                    "updated": "2021-12-29T14:48:59.288+0000",
                    "started": "2021-12-29T14:48:59.287+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "701928",
                    "issueId": "13111093"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/worklog/702960",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11853:\nURL: https://github.com/apache/arrow/pull/11853#discussion_r777509436\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -489,17 +872,57 @@ void RegisterVectorReplace(FunctionRegistry* registry) {\n   }\n   add_primitive_kernel(null());\n   add_primitive_kernel(boolean());\n-  add_kernel(Type::FIXED_SIZE_BINARY, ReplaceWithMaskFunctor<FixedSizeBinaryType>::Exec);\n-  add_kernel(Type::DECIMAL128, ReplaceWithMaskFunctor<FixedSizeBinaryType>::Exec);\n-  add_kernel(Type::DECIMAL256, ReplaceWithMaskFunctor<FixedSizeBinaryType>::Exec);\n+  add_kernel(Type::FIXED_SIZE_BINARY, Functor<FixedSizeBinaryType>::Exec);\n+  add_kernel(Type::DECIMAL128, Functor<FixedSizeBinaryType>::Exec);\n+  add_kernel(Type::DECIMAL256, Functor<FixedSizeBinaryType>::Exec);\n   for (const auto& ty : BaseBinaryTypes()) {\n-    add_kernel(ty->id(), GenerateTypeAgnosticVarBinaryBase<ReplaceWithMaskFunctor>(*ty));\n+    add_kernel(ty->id(), GenerateTypeAgnosticVarBinaryBase<Functor>(*ty));\n   }\n   // TODO: list types\n   DCHECK_OK(registry->AddFunction(std::move(func)));\n \n   // TODO(ARROW-9431): \"replace_with_indices\"\n }\n+\n+const FunctionDoc replace_with_mask_doc(\n+    \"Replace items selected with a mask\",\n+    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n+     \"along with replacement values (either scalar or array),\\n\"\n+     \"each element of the array for which the corresponding mask element is\\n\"\n+     \"true will be replaced by the next value from the replacements,\\n\"\n+     \"or with null if the mask is null.\\n\"\n+     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n+    {\"values\", \"mask\", \"replacements\"});\n+\n+const FunctionDoc fill_null_forward_doc(\n+    \"Carry non-null values forward to fill null slots\",\n+    (\"Given an array, propagate last valid observation forward to next valid\\n\"\n+     \"or nothing if all previous values are null. \"),\n\nReview comment:\n       nit: remove the trailing space (here and below).\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,406 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n+\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+  bool use_current_chunk = false;\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      use_current_chunk = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      if (block.popcount) {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(\n+                  *current_chunk.type, out_values, write_value_offset,\n+                  use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                  *last_valid_value_offset,\n+                  /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            use_current_chunk = true;\n+            *last_valid_value_offset = write_value_offset;\n+          }\n+        }\n+      } else {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(\n+                *current_chunk.type, out_values, write_value_offset,\n+                use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                *last_valid_value_offset,\n+                /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& current_chunk,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(current_chunk.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(current_chunk.length));\n+    RETURN_NOT_OK(builder.ReserveData(current_chunk.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : current_chunk.length - 1;\n+    const uint8_t* data = current_chunk.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = current_chunk.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    /*tuple for store: <use current_chunk(true) or last_valid_chunk(false),\n+     * start offset of the current value, end offset for the current value>*/\n+    std::vector<std::tuple<bool, int64_t, int64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, output->offset, current_chunk.length,\n+        current_chunk.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/false, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/false, -1, -1));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = current_chunk.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullForwardArray(ctx, array_input, out, array_input,\n+                                    &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\"Unsupported type for fill_null_forward: \",\n+                                  batch[0].ToString());\n+  }\n+\n+  static Status FillNullForwardArray(KernelContext* ctx, const ArrayData& array,\n+                                     Datum* out, const ArrayData& last_valid_value_chunk,\n+                                     int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto null_bitmap,\n+          arrow::internal::CopyBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                      array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(ctx, array, null_bitmap->data(), output,\n+                                                  direction, last_valid_value_chunk,\n+                                                  last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = array.length - 1;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullForwardChunkedArray(KernelContext* ctx,\n+                                            const std::shared_ptr<ChunkedArray>& values,\n+                                            Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+\n+    ArrayVector new_chunks;\n+    if (values->length() > 0) {\n+      ArrayData* array_with_current = &*values->chunk(/*first_chunk=*/0)->data();\n+      int64_t last_valid_value_offset = -1;\n+\n+      for (const auto& chunk : values->chunks()) {\n+        if (is_fixed_width(out->type()->id())) {\n+          auto* output = out->mutable_array();\n+          auto bit_width = checked_cast<const FixedWidthType&>(*output->type).bit_width();\n+          auto data_bytes = bit_util::BytesForBits(bit_width * chunk->length());\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(chunk->length()));\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[1], ctx->Allocate(data_bytes));\n+        }\n+        DCHECK_OK(FillNullForwardArray(ctx, *chunk->data(), out, *array_with_current,\n\nReview comment:\n       DCHECK_OK will crash the program if an error occurs, instead of returning it to the caller.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,406 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n+\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+  bool use_current_chunk = false;\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      use_current_chunk = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      if (block.popcount) {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(\n+                  *current_chunk.type, out_values, write_value_offset,\n+                  use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                  *last_valid_value_offset,\n+                  /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            use_current_chunk = true;\n+            *last_valid_value_offset = write_value_offset;\n+          }\n+        }\n+      } else {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(\n+                *current_chunk.type, out_values, write_value_offset,\n+                use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                *last_valid_value_offset,\n+                /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& current_chunk,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(current_chunk.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(current_chunk.length));\n+    RETURN_NOT_OK(builder.ReserveData(current_chunk.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : current_chunk.length - 1;\n+    const uint8_t* data = current_chunk.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = current_chunk.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    /*tuple for store: <use current_chunk(true) or last_valid_chunk(false),\n+     * start offset of the current value, end offset for the current value>*/\n+    std::vector<std::tuple<bool, int64_t, int64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, output->offset, current_chunk.length,\n+        current_chunk.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/false, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/false, -1, -1));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = current_chunk.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullForwardArray(ctx, array_input, out, array_input,\n+                                    &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\"Unsupported type for fill_null_forward: \",\n+                                  batch[0].ToString());\n+  }\n+\n+  static Status FillNullForwardArray(KernelContext* ctx, const ArrayData& array,\n+                                     Datum* out, const ArrayData& last_valid_value_chunk,\n+                                     int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto null_bitmap,\n+          arrow::internal::CopyBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                      array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(ctx, array, null_bitmap->data(), output,\n+                                                  direction, last_valid_value_chunk,\n+                                                  last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = array.length - 1;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullForwardChunkedArray(KernelContext* ctx,\n+                                            const std::shared_ptr<ChunkedArray>& values,\n+                                            Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+\n+    ArrayVector new_chunks;\n+    if (values->length() > 0) {\n+      ArrayData* array_with_current = &*values->chunk(/*first_chunk=*/0)->data();\n+      int64_t last_valid_value_offset = -1;\n+\n+      for (const auto& chunk : values->chunks()) {\n+        if (is_fixed_width(out->type()->id())) {\n+          auto* output = out->mutable_array();\n+          auto bit_width = checked_cast<const FixedWidthType&>(*output->type).bit_width();\n+          auto data_bytes = bit_util::BytesForBits(bit_width * chunk->length());\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(chunk->length()));\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[1], ctx->Allocate(data_bytes));\n+        }\n+        DCHECK_OK(FillNullForwardArray(ctx, *chunk->data(), out, *array_with_current,\n\nReview comment:\n       We use it below for kernel registration because we expect that to never fail, but we do expect kernels themselves to fail normally.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,414 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n+\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+  bool use_current_chunk = false;\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      use_current_chunk = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      if (block.popcount) {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(\n+                  *current_chunk.type, out_values, write_value_offset,\n+                  use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                  *last_valid_value_offset,\n+                  /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            use_current_chunk = true;\n+            *last_valid_value_offset = write_value_offset;\n+          }\n+        }\n+      } else {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(\n+                *current_chunk.type, out_values, write_value_offset,\n+                use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                *last_valid_value_offset,\n+                /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& current_chunk,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(current_chunk.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(current_chunk.length));\n+    RETURN_NOT_OK(builder.ReserveData(current_chunk.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : current_chunk.length - 1;\n+    const uint8_t* data = current_chunk.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = current_chunk.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    /*tuple for store: <use current_chunk(true) or last_valid_chunk(false),\n+     * start offset of the current value, end offset for the current value>*/\n+    std::vector<std::tuple<bool, int64_t, int64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, output->offset, current_chunk.length,\n+        current_chunk.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n\nReview comment:\n       Ping here.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,406 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n+\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+  bool use_current_chunk = false;\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      use_current_chunk = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      if (block.popcount) {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(\n+                  *current_chunk.type, out_values, write_value_offset,\n+                  use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                  *last_valid_value_offset,\n+                  /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            use_current_chunk = true;\n+            *last_valid_value_offset = write_value_offset;\n+          }\n+        }\n+      } else {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(\n+                *current_chunk.type, out_values, write_value_offset,\n+                use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                *last_valid_value_offset,\n+                /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& current_chunk,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(current_chunk.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(current_chunk.length));\n+    RETURN_NOT_OK(builder.ReserveData(current_chunk.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : current_chunk.length - 1;\n+    const uint8_t* data = current_chunk.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = current_chunk.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    /*tuple for store: <use current_chunk(true) or last_valid_chunk(false),\n+     * start offset of the current value, end offset for the current value>*/\n+    std::vector<std::tuple<bool, int64_t, int64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, output->offset, current_chunk.length,\n+        current_chunk.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/false, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/false, -1, -1));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = current_chunk.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullForwardArray(ctx, array_input, out, array_input,\n+                                    &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\"Unsupported type for fill_null_forward: \",\n+                                  batch[0].ToString());\n+  }\n+\n+  static Status FillNullForwardArray(KernelContext* ctx, const ArrayData& array,\n+                                     Datum* out, const ArrayData& last_valid_value_chunk,\n+                                     int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto null_bitmap,\n+          arrow::internal::CopyBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                      array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(ctx, array, null_bitmap->data(), output,\n+                                                  direction, last_valid_value_chunk,\n+                                                  last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = array.length - 1;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullForwardChunkedArray(KernelContext* ctx,\n+                                            const std::shared_ptr<ChunkedArray>& values,\n+                                            Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+\n+    ArrayVector new_chunks;\n+    if (values->length() > 0) {\n+      ArrayData* array_with_current = &*values->chunk(/*first_chunk=*/0)->data();\n+      int64_t last_valid_value_offset = -1;\n+\n+      for (const auto& chunk : values->chunks()) {\n+        if (is_fixed_width(out->type()->id())) {\n+          auto* output = out->mutable_array();\n+          auto bit_width = checked_cast<const FixedWidthType&>(*output->type).bit_width();\n+          auto data_bytes = bit_util::BytesForBits(bit_width * chunk->length());\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(chunk->length()));\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[1], ctx->Allocate(data_bytes));\n+        }\n+        DCHECK_OK(FillNullForwardArray(ctx, *chunk->data(), out, *array_with_current,\n\nReview comment:\n       Do not use DCHECK_OK for this. Use RETURN_NOT_OK.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,406 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n+\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+  bool use_current_chunk = false;\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      use_current_chunk = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      if (block.popcount) {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(\n+                  *current_chunk.type, out_values, write_value_offset,\n+                  use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                  *last_valid_value_offset,\n+                  /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            use_current_chunk = true;\n+            *last_valid_value_offset = write_value_offset;\n+          }\n+        }\n+      } else {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(\n+                *current_chunk.type, out_values, write_value_offset,\n+                use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                *last_valid_value_offset,\n+                /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& current_chunk,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(current_chunk.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(current_chunk.length));\n+    RETURN_NOT_OK(builder.ReserveData(current_chunk.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : current_chunk.length - 1;\n+    const uint8_t* data = current_chunk.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = current_chunk.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    /*tuple for store: <use current_chunk(true) or last_valid_chunk(false),\n+     * start offset of the current value, end offset for the current value>*/\n+    std::vector<std::tuple<bool, int64_t, int64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, output->offset, current_chunk.length,\n+        current_chunk.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/false, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/false, -1, -1));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = current_chunk.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullForwardArray(ctx, array_input, out, array_input,\n+                                    &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\"Unsupported type for fill_null_forward: \",\n+                                  batch[0].ToString());\n+  }\n+\n+  static Status FillNullForwardArray(KernelContext* ctx, const ArrayData& array,\n+                                     Datum* out, const ArrayData& last_valid_value_chunk,\n+                                     int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto null_bitmap,\n+          arrow::internal::CopyBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                      array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(ctx, array, null_bitmap->data(), output,\n+                                                  direction, last_valid_value_chunk,\n+                                                  last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = array.length - 1;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullForwardChunkedArray(KernelContext* ctx,\n+                                            const std::shared_ptr<ChunkedArray>& values,\n+                                            Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+\n+    ArrayVector new_chunks;\n+    if (values->length() > 0) {\n+      ArrayData* array_with_current = &*values->chunk(/*first_chunk=*/0)->data();\n+      int64_t last_valid_value_offset = -1;\n+\n+      for (const auto& chunk : values->chunks()) {\n+        if (is_fixed_width(out->type()->id())) {\n+          auto* output = out->mutable_array();\n+          auto bit_width = checked_cast<const FixedWidthType&>(*output->type).bit_width();\n+          auto data_bytes = bit_util::BytesForBits(bit_width * chunk->length());\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(chunk->length()));\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[1], ctx->Allocate(data_bytes));\n+        }\n+        DCHECK_OK(FillNullForwardArray(ctx, *chunk->data(), out, *array_with_current,\n+                                       &last_valid_value_offset));\n+        if (chunk->null_count() != chunk->length()) {\n+          array_with_current = &*chunk->data();\n+        }\n+        new_chunks.push_back(MakeArray(out->make_array()->data()->Copy()));\n+      }\n+    }\n+\n+    auto output = std::make_shared<ChunkedArray>(std::move(new_chunks), values->type());\n+    *out = Datum(output);\n+    return Status::OK();\n+  }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make({InputType::Array(get_id.id)}, OutputType(FirstType));\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullBackwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullBackwardArray(ctx, array_input, out, array_input,\n+                                     &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullBackwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\"Unsupported type for fill_null_backward operation: \",\n+                                  batch[0].ToString());\n+  }\n+\n+  static Status FillNullBackwardArray(KernelContext* ctx, const ArrayData& array,\n+                                      Datum* out, const ArrayData& last_valid_value_chunk,\n+                                      int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = -1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto reversed_bitmap,\n+          arrow::internal::ReverseBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                         array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, reversed_bitmap->data(), output, direction, last_valid_value_chunk,\n+          last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = 0;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullBackwardChunkedArray(KernelContext* ctx,\n+                                             const std::shared_ptr<ChunkedArray>& values,\n+                                             Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    std::vector<std::shared_ptr<Array>> new_chunks;\n+\n+    if (values->length() > 0) {\n+      auto chunks_length = values->chunks().size();\n+      ArrayData* array_with_current =\n+          &(*values->chunk(/*first_chunk=*/chunks_length - 1)->data());\n+      int64_t last_valid_value_offset = -1;\n+      auto chunks = values->chunks();\n+      for (int i = chunks_length - 1; i >= 0; --i) {\n+        const auto& chunk = chunks[i];\n+        if (is_fixed_width(out->type()->id())) {\n+          auto* output = out->mutable_array();\n+          auto bit_width = checked_cast<const FixedWidthType&>(*output->type).bit_width();\n+          auto data_bytes = bit_util::BytesForBits(bit_width * chunk->length());\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(chunk->length()));\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[1], ctx->Allocate(data_bytes));\n+        }\n+        DCHECK_OK(FillNullBackwardArray(ctx, *chunk->data(), out, *array_with_current,\n+                                        &last_valid_value_offset));\n+        if (chunk->null_count() != chunk->length()) {\n+          array_with_current = &*chunk->data();\n+        }\n+        new_chunks.push_back(MakeArray(out->make_array()->data()->Copy()));\n+      }\n+    }\n+\n+    reverse(new_chunks.begin(), new_chunks.end());\n\nReview comment:\n       nit: explicitly use `std::reverse`?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace_test.cc\n##########\n@@ -798,5 +828,688 @@ TYPED_TEST(TestReplaceBinary, ReplaceWithMaskRandom) {\n   }\n }\n \n+template <typename T>\n+class TestFillNullNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+TYPED_TEST_SUITE(TestFillNullNumeric, NumericBasedTypes);\n+TYPED_TEST_SUITE(TestFillNullDecimal, DecimalArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullBinary, BaseBinaryArrowTypes);\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[]\"), this->array(\"[]\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[null, null, null, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[null, null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[null, null, 4, 4, 5, 5]\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1,4,null]\"),\n+                            this->array(\"[1,4,4]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 6]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 6]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"30.00\"])\"),\n+                            this->array(R\"([null, null, null, \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, \"30.00\", null])\"),\n+                            this->array(R\"([null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([null, null, \"30.00\",null, \"5.00\", null])\"),\n+      this->array(R\"([null, null, \"30.00\", \"30.00\", \"5.00\", \"5.00\"])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([\"10.00\",\"30.00\",null])\"),\n+                            this->array(R\"([\"10.00\",\"30.00\",\"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"10.00\", \"30.00\", null, null, null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"30.00\", \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"5.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, \"ccc\"])\"),\n+                            this->array(R\"([null, null, null, \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, \"ccc\", null])\"),\n+                            this->array(R\"([null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, \"ccc\",null, \"xyz\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\", \"xyz\", \"xyz\"])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([\"aaa\",\"ccc\",null])\"),\n+                            this->array(R\"([\"aaa\",\"ccc\",\"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, null, null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"ccc\", \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"qwert\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"xyz\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", null])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[]\"), this->array(\"[]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, 4, null, null, null]\"),\n+                            this->array(\"[4, 4,null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[4, 4, 4, 5, 5, null]\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null]\"),\n+                            this->array(\"[1, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,null, null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 , 5, 5, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 6]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 6, 6, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, \"40.00\", null, null, null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\",null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"40.00\"])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\"])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([null, null, \"40.00\",null, \"50.00\", null])\"),\n+      this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"50.00\", \"50.00\", null])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([\"10.00\", \"40.00\", null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"10.00\", \"40.00\", null, null, null, null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" , \"50.00\", \"50.00\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"50.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"50.00\", \"50.00\", \"50.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"6.00\", \"6.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, \"afd\", null, null, null])\"),\n+                            this->array(R\"([\"afd\", \"afd\",null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, \"afd\"])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\"])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, \"afd\",null, \"qwe\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"qwe\", \"qwe\", null])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([\"tyu\", \"afd\", null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"tyu\", \"afd\", null, null, null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" , \"qwe\", \"qwe\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"oiutyu\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"oiutyu\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"qwe\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"qwe\", \"qwe\", \"qwe\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", null])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"oiutyu\", \"oiutyu\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+}\n+\n+// For Test Blocks\n+TYPED_TEST(TestFillNullNumeric, FillNullForwardLargeInput) {\n+  using CType = typename TypeTraits<TypeParam>::CType;\n+  random::RandomArrayGenerator rand(/*seed=*/1000);\n+  int64_t len_null = 500;\n+  int64_t len_random = 1000;\n+  std::shared_ptr<Array> array_random =\n+      rand.Numeric<TypeParam>(len_random, /*min=*/0, /*max=*/200, /*nulls=*/0);\n+\n+  if (array_random) {\n\nReview comment:\n       @AlvinJ15: what is the reason for this check? If there is one, please let me know - I'm just wondering why it's here.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,406 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n+\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+  bool use_current_chunk = false;\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      use_current_chunk = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      if (block.popcount) {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(\n+                  *current_chunk.type, out_values, write_value_offset,\n+                  use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                  *last_valid_value_offset,\n+                  /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            use_current_chunk = true;\n+            *last_valid_value_offset = write_value_offset;\n+          }\n+        }\n+      } else {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(\n+                *current_chunk.type, out_values, write_value_offset,\n+                use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                *last_valid_value_offset,\n+                /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& current_chunk,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(current_chunk.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(current_chunk.length));\n+    RETURN_NOT_OK(builder.ReserveData(current_chunk.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : current_chunk.length - 1;\n+    const uint8_t* data = current_chunk.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = current_chunk.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    /*tuple for store: <use current_chunk(true) or last_valid_chunk(false),\n+     * start offset of the current value, end offset for the current value>*/\n+    std::vector<std::tuple<bool, int64_t, int64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, output->offset, current_chunk.length,\n+        current_chunk.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/false, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/false, -1, -1));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = current_chunk.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullForwardArray(ctx, array_input, out, array_input,\n+                                    &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\"Unsupported type for fill_null_forward: \",\n+                                  batch[0].ToString());\n+  }\n+\n+  static Status FillNullForwardArray(KernelContext* ctx, const ArrayData& array,\n+                                     Datum* out, const ArrayData& last_valid_value_chunk,\n+                                     int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto null_bitmap,\n+          arrow::internal::CopyBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                      array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(ctx, array, null_bitmap->data(), output,\n+                                                  direction, last_valid_value_chunk,\n+                                                  last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = array.length - 1;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullForwardChunkedArray(KernelContext* ctx,\n+                                            const std::shared_ptr<ChunkedArray>& values,\n+                                            Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+\n+    ArrayVector new_chunks;\n+    if (values->length() > 0) {\n+      ArrayData* array_with_current = &*values->chunk(/*first_chunk=*/0)->data();\n+      int64_t last_valid_value_offset = -1;\n+\n+      for (const auto& chunk : values->chunks()) {\n+        if (is_fixed_width(out->type()->id())) {\n+          auto* output = out->mutable_array();\n+          auto bit_width = checked_cast<const FixedWidthType&>(*output->type).bit_width();\n+          auto data_bytes = bit_util::BytesForBits(bit_width * chunk->length());\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(chunk->length()));\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[1], ctx->Allocate(data_bytes));\n+        }\n+        DCHECK_OK(FillNullForwardArray(ctx, *chunk->data(), out, *array_with_current,\n+                                       &last_valid_value_offset));\n+        if (chunk->null_count() != chunk->length()) {\n+          array_with_current = &*chunk->data();\n+        }\n+        new_chunks.push_back(MakeArray(out->make_array()->data()->Copy()));\n+      }\n+    }\n+\n+    auto output = std::make_shared<ChunkedArray>(std::move(new_chunks), values->type());\n+    *out = Datum(output);\n+    return Status::OK();\n+  }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make({InputType::Array(get_id.id)}, OutputType(FirstType));\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullBackwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullBackwardArray(ctx, array_input, out, array_input,\n+                                     &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullBackwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\"Unsupported type for fill_null_backward operation: \",\n+                                  batch[0].ToString());\n+  }\n+\n+  static Status FillNullBackwardArray(KernelContext* ctx, const ArrayData& array,\n+                                      Datum* out, const ArrayData& last_valid_value_chunk,\n+                                      int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = -1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto reversed_bitmap,\n+          arrow::internal::ReverseBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                         array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, reversed_bitmap->data(), output, direction, last_valid_value_chunk,\n+          last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = 0;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullBackwardChunkedArray(KernelContext* ctx,\n+                                             const std::shared_ptr<ChunkedArray>& values,\n+                                             Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    std::vector<std::shared_ptr<Array>> new_chunks;\n+\n+    if (values->length() > 0) {\n+      auto chunks_length = values->chunks().size();\n+      ArrayData* array_with_current =\n+          &(*values->chunk(/*first_chunk=*/chunks_length - 1)->data());\n+      int64_t last_valid_value_offset = -1;\n+      auto chunks = values->chunks();\n+      for (int i = chunks_length - 1; i >= 0; --i) {\n+        const auto& chunk = chunks[i];\n+        if (is_fixed_width(out->type()->id())) {\n+          auto* output = out->mutable_array();\n+          auto bit_width = checked_cast<const FixedWidthType&>(*output->type).bit_width();\n+          auto data_bytes = bit_util::BytesForBits(bit_width * chunk->length());\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(chunk->length()));\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[1], ctx->Allocate(data_bytes));\n+        }\n+        DCHECK_OK(FillNullBackwardArray(ctx, *chunk->data(), out, *array_with_current,\n\nReview comment:\n       Ditto here.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-03T14:37:39.336+0000",
                    "updated": "2022-01-03T14:37:39.336+0000",
                    "started": "2022-01-03T14:37:39.336+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "702960",
                    "issueId": "13111093"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/worklog/702986",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "AlvinJ15 commented on a change in pull request #11853:\nURL: https://github.com/apache/arrow/pull/11853#discussion_r765437081\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -444,6 +456,225 @@ struct ReplaceWithMaskFunctor {\n   }\n };\n \n+template <typename Type>\n+void fillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t incrementer) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values, 0, array, 0, array.length);\n+\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+  int64_t write_offset = incrementer == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + incrementer * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n+        for (int64_t i = 0; i != block.length; i++) {\n+          uint64_t write_value_offset = write_offset + incrementer * bitmap_offset;\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              array, current_value_offset, /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            current_value_offset = write_value_offset;\n+          }\n+          bitmap_offset += 1;\n+        }\n+      } else {\n+        auto in = *(array_scalars->GetScalar(current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_offset, *in,\n+                                        current_value_offset, block.length);\n+        bitmap_offset += block.length;\n+      }\n+      write_offset += block.length * incrementer;\n+    }\n+  }\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t current_value_offset = 0;\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    bool has_fill_value = false;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+\n+    std::vector<std::pair<uint64_t, uint64_t>> offsets_reverted;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n\nReview comment:\n       This is because for the backward pass, I need to append to the builder but in reverse order, so first I add all offsets and append to the builder using a reverse iterator. And I use VisitNullBitmapInline instead of VisitArrayValuesInline because for backward I need to save values in another vector and iterate in reverse, then I think is best just save the offset as integers instead the entire values before append to the builder.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,231 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/0, array, /*in_offset=*/0, array.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n\nReview comment:\n       The null_bitmap == nullptr is been evaluated when call this function using the array.MayHaveNulls()\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,409 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      last_valid_value_chunk = current_chunk;\n\nReview comment:\n       I created a flag for use the current_chunk or the last_valid_value_chunk, instead of reassign the pointers.\r\n   `use_current_chunk ? current_chunk : last_valid_value_chunk,`\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace_test.cc\n##########\n@@ -793,5 +851,772 @@ TYPED_TEST(TestReplaceBinary, ReplaceWithMaskRandom) {\n   }\n }\n \n+template <typename T>\n+class TestFillNullNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+template <typename T>\n+class TestFillNullNullType : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+TYPED_TEST_SUITE(TestFillNullNumeric, NumericBasedTypes);\n+TYPED_TEST_SUITE(TestFillNullDecimal, DecimalArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullBinary, BaseBinaryArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullNullType, ::testing::Types<NullType>);\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[]\"), this->array(\"[]\"));\n+\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[null, null, null, 4]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[null, 4, 4]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[null, null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[null, null, 4, 4, 5, 5]\"));\n+\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[1,4,null]\"),\n+                            this->array(\"[1,4,4]\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 6]\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 6]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(R\"([null, null, null, \"30.00\"])\"),\n+                            this->array(R\"([null, null, null, \"30.00\"])\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([null, \"30.00\", null])\"),\n+                            this->array(R\"([null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(R\"([null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(R\"([null, null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward, this->array(R\"([null, null, \"30.00\",null, \"5.00\", null])\"),\n+      this->array(R\"([null, null, \"30.00\", \"30.00\", \"5.00\", \"5.00\"])\"));\n+\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([\"10.00\",\"30.00\",null])\"),\n+                            this->array(R\"([\"10.00\",\"30.00\",\"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward, this->array(R\"([\"10.00\", \"30.00\", null, null, null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"30.00\", \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward, this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"5.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward,\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([null, null, null, \"ccc\"])\"),\n+                            this->array(R\"([null, null, null, \"ccc\"])\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([null, \"ccc\", null])\"),\n+                            this->array(R\"([null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(R\"([null, null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(R\"([null, null, \"ccc\",null, \"xyz\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\", \"xyz\", \"xyz\"])\"));\n+\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([\"aaa\",\"ccc\",null])\"),\n+                            this->array(R\"([\"aaa\",\"ccc\",\"ccc\"])\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, null, null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"ccc\", \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"qwert\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"xyz\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", null])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward,\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[]\"), this->array(\"[]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[null, 4, null, null, null]\"),\n+                            this->array(\"[4, 4,null, null, null]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[4, 4, null]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[4, 4, 4, 5, 5, null]\"));\n+\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[1, 4, null]\"),\n+                            this->array(\"[1, 4, null]\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,null, null, null, null]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 , 5, 5, null, null]\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 6]\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 6, 6, null]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([null, \"40.00\", null, null, null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\",null, null, null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([null, null, null, \"40.00\"])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\"])\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([null, null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward, this->array(R\"([null, null, \"40.00\",null, \"50.00\", null])\"),\n+      this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"50.00\", \"50.00\", null])\"));\n+\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([\"10.00\", \"40.00\", null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([\"10.00\", \"40.00\", null, null, null, null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward, this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" , \"50.00\", \"50.00\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"50.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"50.00\", \"50.00\", \"50.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"6.00\", \"6.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([null, \"afd\", null, null, null])\"),\n+                            this->array(R\"([\"afd\", \"afd\",null, null, null])\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([null, null, null, \"afd\"])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\"])\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([null, null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([null, null, \"afd\",null, \"qwe\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"qwe\", \"qwe\", null])\"));\n+\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([\"tyu\", \"afd\", null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([\"tyu\", \"afd\", null, null, null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" , \"qwe\", \"qwe\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"oiutyu\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"oiutyu\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward, this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"qwe\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"qwe\", \"qwe\", \"qwe\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", null])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"oiutyu\", \"oiutyu\", null])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+}\n+\n+// For Test Blocks\n+TYPED_TEST(TestFillNullNumeric, FillNullForwardLargeInput) {\n+  using CType = typename TypeTraits<TypeParam>::CType;\n+  random::RandomArrayGenerator rand(/*seed=*/1000);\n+  int64_t len_null = 500;\n+  int64_t len_random = 1000;\n+  std::shared_ptr<Array> array_random =\n+      rand.Numeric<TypeParam>(len_random, /*min=*/0, /*max=*/200, /*nulls=*/0);\n+\n+  if (array_random) {\n+    auto x_ptr = array_random->data()->template GetValues<CType>(1);\n+    ASSERT_OK_AND_ASSIGN(auto array_null,\n+                         MakeArrayOfNull(array_random->type(), len_null));\n+    auto array_null_filled =\n+        ConstantArrayGenerator::Numeric<TypeParam>(len_null, x_ptr[len_random - 1]);\n+    {\n+      ASSERT_OK_AND_ASSIGN(auto value_array,\n+                           Concatenate({array_random, array_null, array_random}));\n+      ASSERT_OK_AND_ASSIGN(auto result_array,\n+                           Concatenate({array_random, array_null_filled, array_random}));\n+      this->AssertFillNullArray(FillNullForward, value_array, result_array);\n+    }\n+  }\n+}\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullBackwardLargeInput) {\n+  using CType = typename TypeTraits<TypeParam>::CType;\n+  random::RandomArrayGenerator rand(/*seed=*/1000);\n+  int64_t len_null = 500;\n+  int64_t len_random = 1000;\n+  std::shared_ptr<Array> array_random =\n+      rand.Numeric<TypeParam>(len_random, /*min=*/0, /*max=*/200, /*null_count=*/0);\n+\n+  if (array_random) {\n\nReview comment:\n       For Date Types which are part of the `NumericBasedTypes`, there's not exist a Random implementation, and it return an nullptr array_random\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -444,6 +456,225 @@ struct ReplaceWithMaskFunctor {\n   }\n };\n \n+template <typename Type>\n+void fillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t incrementer) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values, 0, array, 0, array.length);\n+\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+  int64_t write_offset = incrementer == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + incrementer * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n+        for (int64_t i = 0; i != block.length; i++) {\n+          uint64_t write_value_offset = write_offset + incrementer * bitmap_offset;\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              array, current_value_offset, /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            current_value_offset = write_value_offset;\n+          }\n+          bitmap_offset += 1;\n+        }\n+      } else {\n+        auto in = *(array_scalars->GetScalar(current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_offset, *in,\n+                                        current_value_offset, block.length);\n+        bitmap_offset += block.length;\n+      }\n+      write_offset += block.length * incrementer;\n+    }\n+  }\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t current_value_offset = 0;\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    bool has_fill_value = false;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+\n+    std::vector<std::pair<uint64_t, uint64_t>> offsets_reverted;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n\nReview comment:\n       I just allocate the offsets not the values, because there is no method for VisitArrayValuesInline/VisitNullBitmapInline in reverse order\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -444,6 +456,225 @@ struct ReplaceWithMaskFunctor {\n   }\n };\n \n+template <typename Type>\n+void fillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t incrementer) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values, 0, array, 0, array.length);\n+\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+  int64_t write_offset = incrementer == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + incrementer * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n+        for (int64_t i = 0; i != block.length; i++) {\n+          uint64_t write_value_offset = write_offset + incrementer * bitmap_offset;\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              array, current_value_offset, /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            current_value_offset = write_value_offset;\n+          }\n+          bitmap_offset += 1;\n+        }\n+      } else {\n+        auto in = *(array_scalars->GetScalar(current_value_offset));\n\nReview comment:\n       ```\r\n           ReplaceWithMask<Type>::CopyData(*array.type, out_values, block_start_offset, *in,\r\n                                           current_value_offset, block.length);\r\n           bit_util::SetBitsTo(out_bitmap, block_start_offset, block.length, true);\r\n   ```\r\n   ```\r\n     static void CopyData(const DataType&, uint8_t* out, const int64_t out_offset,\r\n                          const Scalar& in, const int64_t in_offset, const int64_t length) {\r\n       T* begin = reinterpret_cast<T*>(out + (out_offset * sizeof(T)));\r\n       T* end = begin + length;\r\n       std::fill(begin, end, UnboxScalar<Type>::Unbox(in));\r\n     }\r\n   ```\r\n   This is for fill the entire block with the same value, otherwise I need to copy with a for loop using the offsets to the entire block.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,231 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/0, array, /*in_offset=*/0, array.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + direction * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n+        for (int64_t i = 0; i != block.length; i++) {\n+          uint64_t write_value_offset = write_offset + direction * bitmap_offset;\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              array, current_value_offset, /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            current_value_offset = write_value_offset;\n+          }\n+          bitmap_offset += 1;\n+        }\n+      } else {\n+        auto in = *(array_scalars->GetScalar(current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_offset, *in,\n+                                        current_value_offset, block.length);\n+        bitmap_offset += block.length;\n+      }\n+      write_offset += block.length * direction;\n+    }\n+  }\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t current_value_offset = 0;\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    bool has_fill_value = false;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+\n+    std::vector<std::pair<uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(std::make_pair(offset0, offset1 - offset0));\n+          current_value_offset = array_value_index;\n+          has_fill_value = true;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value) {\n+            const offset_type offset0 = offsets[current_value_offset];\n+            const offset_type offset1 = offsets[current_value_offset + 1];\n+            offsets_reversed.push_back(std::make_pair(offset0, offset1 - offset0));\n+          } else {\n+            offsets_reversed.push_back(std::make_pair(-1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (it->first == -1U && it->second == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data + it->first, it->second));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (it->first == -1U && it->second == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data + it->first, it->second));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ArrayData& array = *batch[0].array();\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+\n+    if (array.MayHaveNulls()) {\n+      int8_t direction = 1;\n+      return FillNullExecutor<Type>::ExecFillNull(ctx, array, array.buffers[0]->data(),\n+                                                  output, direction);\n+    } else {\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id)}, OutputType(FirstType));\n+  }\n+};\n+\n+template <typename Type>\n+struct FillBackwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ArrayData& array = *batch[0].array();\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+\n+    if (array.MayHaveNulls()) {\n+      int8_t direction = -1;\n+      auto reversed_bitmap = arrow::internal::ReverseBitmap(\n+          ctx->memory_pool(), array.buffers[0]->data(), array.offset, array.length);\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, reversed_bitmap.ValueOrDie()->data(), output, direction);\n+    } else {\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id)}, OutputType(FirstType));\n+  }\n+};\n+}  // namespace\n+\n+template <template <class> class Functor,\n+class FixedType = FixedSizeBinaryType>\n\nReview comment:\n       deleted.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,460 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData current_value_array, bool* has_current_value,\n+                             int64_t* current_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/output->offset, array, /*in_offset=*/0,\n+                                  array.length);\n+\n+  *has_current_value = false;\n+  auto array_scalars = arrow::MakeArray(current_value_array.Copy());\n+  bool has_fill_value = *current_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   array.length);\n+\n+  while (bitmap_offset < array.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *current_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      current_value_array = array;\n+      *has_current_value = true;\n\nReview comment:\n       `has_current_value` is a flag for tell if the current chunk has a nonNull last value, and the offset of this value is stored in `current_value_offset` for be used with the current chunk for future chunks fills.\r\n   Removed the copy on local variables and just assign new values.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -444,6 +456,225 @@ struct ReplaceWithMaskFunctor {\n   }\n };\n \n+template <typename Type>\n+void fillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t incrementer) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values, 0, array, 0, array.length);\n+\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+  int64_t write_offset = incrementer == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + incrementer * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n+        for (int64_t i = 0; i != block.length; i++) {\n+          uint64_t write_value_offset = write_offset + incrementer * bitmap_offset;\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              array, current_value_offset, /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            current_value_offset = write_value_offset;\n+          }\n+          bitmap_offset += 1;\n+        }\n+      } else {\n+        auto in = *(array_scalars->GetScalar(current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_offset, *in,\n+                                        current_value_offset, block.length);\n+        bitmap_offset += block.length;\n+      }\n+      write_offset += block.length * incrementer;\n+    }\n+  }\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    fillNullInDirectionImpl<Type>(array, reverted_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reverted_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t current_value_offset = 0;\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    bool has_fill_value = false;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+\n+    std::vector<std::pair<uint64_t, uint64_t>> offsets_reverted;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n\nReview comment:\n       @lidavidm  For the backward, due the null_bitmap is in reversed order, when I append to the builder, all values are append in reverse order, so I need to reverse all values. So instead of add the values in a vector and reverse it, I'll think is best to add just the offsets values in a vector then reverse(vector of integers instead vector data), and then use the builder for append the values using the offsets.\r\n   I don't have any solution for specialize this method, because there not exist a preppend-like method for builder.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -444,6 +456,225 @@ struct ReplaceWithMaskFunctor {\n   }\n };\n \n+template <typename Type>\n+void fillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t incrementer) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values, 0, array, 0, array.length);\n+\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n+\n+  int64_t write_offset = incrementer == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + incrementer * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n+        for (int64_t i = 0; i != block.length; i++) {\n+          uint64_t write_value_offset = write_offset + incrementer * bitmap_offset;\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              array, current_value_offset, /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            current_value_offset = write_value_offset;\n+          }\n+          bitmap_offset += 1;\n+        }\n+      } else {\n+        auto in = *(array_scalars->GetScalar(current_value_offset));\n\nReview comment:\n       In the normal case when the null_bitmap block has 0 and 1, it use the CopyData with buffers, but in this case the entire block is full 0 so I use the second CopyData which need a Scalar for fill the entire block with the same value.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,231 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/0, array, /*in_offset=*/0, array.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  auto array_scalars = arrow::MakeArray(array.Copy());\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+  int64_t current_value_offset = 0;\n+  bool has_fill_value = false;\n+  arrow::internal::OptionalBinaryBitBlockCounter counter(\n+      null_bitmap, array.offset, null_bitmap, array.offset, array.length);\n+\n+  while (write_offset < array.length && write_offset >= 0) {\n+    BitBlockCount block = counter.NextAndBlock();\n+    if (block.AllSet()) {\n+      current_value_offset = write_offset + direction * (block.length - 1);\n+    } else {\n+      if (block.popcount) {\n+        for (int64_t i = 0; i != block.length; i++) {\n+          uint64_t write_value_offset = write_offset + direction * bitmap_offset;\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              array, current_value_offset, /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            current_value_offset = write_value_offset;\n+          }\n+          bitmap_offset += 1;\n+        }\n+      } else {\n+        auto in = *(array_scalars->GetScalar(current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_offset, *in,\n+                                        current_value_offset, block.length);\n+        bitmap_offset += block.length;\n+      }\n+      write_offset += block.length * direction;\n+    }\n+  }\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t current_value_offset = 0;\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    bool has_fill_value = false;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+\n+    std::vector<std::pair<uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(std::make_pair(offset0, offset1 - offset0));\n+          current_value_offset = array_value_index;\n+          has_fill_value = true;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value) {\n+            const offset_type offset0 = offsets[current_value_offset];\n+            const offset_type offset1 = offsets[current_value_offset + 1];\n+            offsets_reversed.push_back(std::make_pair(offset0, offset1 - offset0));\n+          } else {\n+            offsets_reversed.push_back(std::make_pair(-1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (it->first == -1U && it->second == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data + it->first, it->second));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (it->first == -1U && it->second == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data + it->first, it->second));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             uint8_t direction) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ArrayData& array = *batch[0].array();\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+\n+    if (array.MayHaveNulls()) {\n+      int8_t direction = 1;\n+      return FillNullExecutor<Type>::ExecFillNull(ctx, array, array.buffers[0]->data(),\n+                                                  output, direction);\n+    } else {\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id)}, OutputType(FirstType));\n+  }\n+};\n+\n+template <typename Type>\n+struct FillBackwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ArrayData& array = *batch[0].array();\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+\n+    if (array.MayHaveNulls()) {\n+      int8_t direction = -1;\n+      auto reversed_bitmap = arrow::internal::ReverseBitmap(\n+          ctx->memory_pool(), array.buffers[0]->data(), array.offset, array.length);\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, reversed_bitmap.ValueOrDie()->data(), output, direction);\n+    } else {\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static std::shared_ptr<KernelSignature> GetParameters(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id)}, OutputType(FirstType));\n+  }\n+};\n+}  // namespace\n+\n+template <template <class> class Functor,\n+class FixedType = FixedSizeBinaryType>\n\nReview comment:\n       Following the ReplaceWithMask implementation \r\n   ```\r\n     add_primitive_kernel(null());\r\n     add_primitive_kernel(boolean());\r\n     add_kernel(Type::FIXED_SIZE_BINARY, ReplaceWithMaskFunctor<FixedSizeBinaryType>::Exec);\r\n     add_kernel(Type::DECIMAL128, ReplaceWithMaskFunctor<FixedSizeBinaryType>::Exec);\r\n     add_kernel(Type::DECIMAL256, ReplaceWithMaskFunctor<FixedSizeBinaryType>::Exec);\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace_test.cc\n##########\n@@ -798,5 +828,688 @@ TYPED_TEST(TestReplaceBinary, ReplaceWithMaskRandom) {\n   }\n }\n \n+template <typename T>\n+class TestFillNullNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+TYPED_TEST_SUITE(TestFillNullNumeric, NumericBasedTypes);\n+TYPED_TEST_SUITE(TestFillNullDecimal, DecimalArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullBinary, BaseBinaryArrowTypes);\n\nReview comment:\n       added at bottom of `vector_replace_test.cc`\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,460 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData current_value_array, bool* has_current_value,\n+                             int64_t* current_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/output->offset, array, /*in_offset=*/0,\n+                                  array.length);\n+\n+  *has_current_value = false;\n+  auto array_scalars = arrow::MakeArray(current_value_array.Copy());\n+  bool has_fill_value = *current_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   array.length);\n+\n+  while (bitmap_offset < array.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *current_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      current_value_array = array;\n+      *has_current_value = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      if (block.popcount) {\n+        uint64_t write_value_offset = block_start_offset;\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              current_value_array, *current_value_offset,\n+                                              /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            *current_value_offset = write_value_offset;\n+            current_value_array = array;\n+            *has_current_value = true;\n+          }\n+        }\n+      } else if (has_fill_value) {\n+        uint64_t write_value_offset =\n+            block_start_offset + (direction == 1 ? 0 : (-block.length + 1));\n+        auto in = *(array_scalars->GetScalar(*current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset, *in,\n\nReview comment:\n       Added a for loop, instead copyData with scalar and fill\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,460 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData current_value_array, bool* has_current_value,\n+                             int64_t* current_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/output->offset, array, /*in_offset=*/0,\n+                                  array.length);\n+\n+  *has_current_value = false;\n+  auto array_scalars = arrow::MakeArray(current_value_array.Copy());\n+  bool has_fill_value = *current_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   array.length);\n+\n+  while (bitmap_offset < array.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *current_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      current_value_array = array;\n+      *has_current_value = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      if (block.popcount) {\n+        uint64_t write_value_offset = block_start_offset;\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              current_value_array, *current_value_offset,\n+                                              /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            *current_value_offset = write_value_offset;\n+            current_value_array = array;\n+            *has_current_value = true;\n+          }\n+        }\n+      } else if (has_fill_value) {\n+        uint64_t write_value_offset =\n+            block_start_offset + (direction == 1 ? 0 : (-block.length + 1));\n+        auto in = *(array_scalars->GetScalar(*current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset, *in,\n+                                        *current_value_offset, block.length);\n+        bit_util::SetBitsTo(out_bitmap, write_value_offset, block.length, true);\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const uint8_t* data_prev = current_value_array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = current_value_array.GetValues<offset_type>(1);\n+\n+    *has_current_value = false;\n+    bool has_fill_value = *current_value_offset != -1;\n+    std::vector<std::tuple<bool, uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+          *current_value_offset = array_value_index;\n+          *has_current_value = true;\n+          has_fill_value = true;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value) {\n+            if (*has_current_value) {\n+              const offset_type offset0 = offsets[*current_value_offset];\n+              const offset_type offset1 = offsets[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*current_value_offset];\n+              const offset_type offset1 = offsets_prev[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/0, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/0, -1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+    return write_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    return -1;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        bool has_current_value = false;\n+        int64_t has_current_offset = -1;\n+        return FillForwardArray(ctx, array_input, out, array_input, &has_current_value,\n+                                &has_current_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                 ArrayData current_value_array, bool* has_current_value,\n+                                 int64_t* current_value_offset) {\n+    ArrayData* output = out->array().get();\n+    if (!output->buffers[0]) {\n+      ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    }\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, array.buffers[0]->data(), output, direction, current_value_array,\n+          has_current_value, current_value_offset);\n+    } else {\n+      *current_value_offset = FillNullExecutor<Type>::LastElementOffset(array, direction);\n+      if (array.length > 0) {\n+        *has_current_value = true;\n\nReview comment:\n       condition fixed.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,460 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData current_value_array, bool* has_current_value,\n+                             int64_t* current_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/output->offset, array, /*in_offset=*/0,\n+                                  array.length);\n+\n+  *has_current_value = false;\n+  auto array_scalars = arrow::MakeArray(current_value_array.Copy());\n+  bool has_fill_value = *current_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   array.length);\n+\n+  while (bitmap_offset < array.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *current_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      current_value_array = array;\n+      *has_current_value = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      if (block.popcount) {\n+        uint64_t write_value_offset = block_start_offset;\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              current_value_array, *current_value_offset,\n+                                              /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            *current_value_offset = write_value_offset;\n+            current_value_array = array;\n+            *has_current_value = true;\n+          }\n+        }\n+      } else if (has_fill_value) {\n+        uint64_t write_value_offset =\n+            block_start_offset + (direction == 1 ? 0 : (-block.length + 1));\n+        auto in = *(array_scalars->GetScalar(*current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset, *in,\n+                                        *current_value_offset, block.length);\n+        bit_util::SetBitsTo(out_bitmap, write_value_offset, block.length, true);\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const uint8_t* data_prev = current_value_array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = current_value_array.GetValues<offset_type>(1);\n+\n+    *has_current_value = false;\n+    bool has_fill_value = *current_value_offset != -1;\n+    std::vector<std::tuple<bool, uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+          *current_value_offset = array_value_index;\n+          *has_current_value = true;\n+          has_fill_value = true;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value) {\n+            if (*has_current_value) {\n+              const offset_type offset0 = offsets[*current_value_offset];\n+              const offset_type offset1 = offsets[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*current_value_offset];\n+              const offset_type offset1 = offsets_prev[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/0, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/0, -1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+    return write_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    return -1;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        bool has_current_value = false;\n+        int64_t has_current_offset = -1;\n+        return FillForwardArray(ctx, array_input, out, array_input, &has_current_value,\n+                                &has_current_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                 ArrayData current_value_array, bool* has_current_value,\n+                                 int64_t* current_value_offset) {\n+    ArrayData* output = out->array().get();\n+    if (!output->buffers[0]) {\n\nReview comment:\n       Code removed.\r\n   The allocation was for the ChunkedArrays, because the `Datum out` was created for every chunk.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,460 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData current_value_array, bool* has_current_value,\n+                             int64_t* current_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/output->offset, array, /*in_offset=*/0,\n+                                  array.length);\n+\n+  *has_current_value = false;\n+  auto array_scalars = arrow::MakeArray(current_value_array.Copy());\n+  bool has_fill_value = *current_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   array.length);\n+\n+  while (bitmap_offset < array.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *current_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      current_value_array = array;\n+      *has_current_value = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      if (block.popcount) {\n+        uint64_t write_value_offset = block_start_offset;\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              current_value_array, *current_value_offset,\n+                                              /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            *current_value_offset = write_value_offset;\n+            current_value_array = array;\n+            *has_current_value = true;\n+          }\n+        }\n+      } else if (has_fill_value) {\n+        uint64_t write_value_offset =\n+            block_start_offset + (direction == 1 ? 0 : (-block.length + 1));\n+        auto in = *(array_scalars->GetScalar(*current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset, *in,\n+                                        *current_value_offset, block.length);\n+        bit_util::SetBitsTo(out_bitmap, write_value_offset, block.length, true);\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const uint8_t* data_prev = current_value_array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = current_value_array.GetValues<offset_type>(1);\n+\n+    *has_current_value = false;\n+    bool has_fill_value = *current_value_offset != -1;\n+    std::vector<std::tuple<bool, uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+          *current_value_offset = array_value_index;\n+          *has_current_value = true;\n+          has_fill_value = true;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value) {\n+            if (*has_current_value) {\n+              const offset_type offset0 = offsets[*current_value_offset];\n+              const offset_type offset1 = offsets[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*current_value_offset];\n+              const offset_type offset1 = offsets_prev[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/0, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/0, -1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+    return write_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    return -1;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        bool has_current_value = false;\n+        int64_t has_current_offset = -1;\n+        return FillForwardArray(ctx, array_input, out, array_input, &has_current_value,\n+                                &has_current_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                 ArrayData current_value_array, bool* has_current_value,\n+                                 int64_t* current_value_offset) {\n+    ArrayData* output = out->array().get();\n+    if (!output->buffers[0]) {\n+      ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    }\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, array.buffers[0]->data(), output, direction, current_value_array,\n+          has_current_value, current_value_offset);\n+    } else {\n+      *current_value_offset = FillNullExecutor<Type>::LastElementOffset(array, direction);\n+      if (array.length > 0) {\n+        *has_current_value = true;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillForwardChunkedArray(KernelContext* ctx,\n+                                        const std::shared_ptr<ChunkedArray>& values,\n+                                        Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(*ToResult(values));\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(*ToResult(values));\n+      return Status::OK();\n+    }\n+    std::vector<std::shared_ptr<Array>> new_chunks;\n+\n+    if (values->length() > 0) {\n+      ArrayData array_with_current = *values->chunk(/*first_chunk=*/0)->data();\n+      bool has_current_value = false;\n+      int64_t has_current_offset = -1;\n+      for (const auto& chunk : values->chunks()) {\n+        auto buffer_size = chunk->length() * bit_width(values->type()->id());\n+        ARROW_ASSIGN_OR_RAISE(auto data, AllocateBuffer(buffer_size, ctx->memory_pool()));\n+\n+        std::unique_ptr<ArrayBuilder> builder;\n+        RETURN_NOT_OK(MakeBuilder(ctx->memory_pool(), values->type(), &builder));\n+        RETURN_NOT_OK(builder->Reserve(chunk->length()));\n+        ARROW_ASSIGN_OR_RAISE(auto array_output, builder->Finish());\n+\n+        ARROW_ASSIGN_OR_RAISE(array_output->data()->buffers[1],\n+                              ctx->Allocate(buffer_size / 8));\n\nReview comment:\n       Is the same Allocate(x/8) with AllocateBitmap(x)?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace_test.cc\n##########\n@@ -798,5 +828,688 @@ TYPED_TEST(TestReplaceBinary, ReplaceWithMaskRandom) {\n   }\n }\n \n+template <typename T>\n+class TestFillNullNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+TYPED_TEST_SUITE(TestFillNullNumeric, NumericBasedTypes);\n+TYPED_TEST_SUITE(TestFillNullDecimal, DecimalArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullBinary, BaseBinaryArrowTypes);\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[]\"), this->array(\"[]\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[null, null, null, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[null, null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[null, null, 4, 4, 5, 5]\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1,4,null]\"),\n+                            this->array(\"[1,4,4]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 6]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 6]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"30.00\"])\"),\n+                            this->array(R\"([null, null, null, \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, \"30.00\", null])\"),\n+                            this->array(R\"([null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([null, null, \"30.00\",null, \"5.00\", null])\"),\n+      this->array(R\"([null, null, \"30.00\", \"30.00\", \"5.00\", \"5.00\"])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([\"10.00\",\"30.00\",null])\"),\n+                            this->array(R\"([\"10.00\",\"30.00\",\"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"10.00\", \"30.00\", null, null, null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"30.00\", \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"5.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, \"ccc\"])\"),\n+                            this->array(R\"([null, null, null, \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, \"ccc\", null])\"),\n+                            this->array(R\"([null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, \"ccc\",null, \"xyz\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\", \"xyz\", \"xyz\"])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([\"aaa\",\"ccc\",null])\"),\n+                            this->array(R\"([\"aaa\",\"ccc\",\"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, null, null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"ccc\", \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"qwert\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"xyz\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", null])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[]\"), this->array(\"[]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, 4, null, null, null]\"),\n+                            this->array(\"[4, 4,null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[4, 4, 4, 5, 5, null]\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null]\"),\n+                            this->array(\"[1, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,null, null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 , 5, 5, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 6]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 6, 6, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, \"40.00\", null, null, null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\",null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"40.00\"])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\"])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([null, null, \"40.00\",null, \"50.00\", null])\"),\n+      this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"50.00\", \"50.00\", null])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([\"10.00\", \"40.00\", null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"10.00\", \"40.00\", null, null, null, null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" , \"50.00\", \"50.00\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"50.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"50.00\", \"50.00\", \"50.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"6.00\", \"6.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, \"afd\", null, null, null])\"),\n+                            this->array(R\"([\"afd\", \"afd\",null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, \"afd\"])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\"])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, \"afd\",null, \"qwe\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"qwe\", \"qwe\", null])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([\"tyu\", \"afd\", null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"tyu\", \"afd\", null, null, null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" , \"qwe\", \"qwe\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"oiutyu\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"oiutyu\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"qwe\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"qwe\", \"qwe\", \"qwe\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", null])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"oiutyu\", \"oiutyu\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+}\n+\n+// For Test Blocks\n+TYPED_TEST(TestFillNullNumeric, FillNullForwardLargeInput) {\n+  using CType = typename TypeTraits<TypeParam>::CType;\n+  random::RandomArrayGenerator rand(/*seed=*/1000);\n+  int64_t len_null = 500;\n+  int64_t len_random = 1000;\n+  std::shared_ptr<Array> array_random =\n+      rand.Numeric<TypeParam>(len_random, /*min=*/0, /*max=*/200, /*nulls=*/0);\n+\n+  if (array_random) {\n+    auto x_ptr = array_random->data()->template GetValues<CType>(1);\n+    ASSERT_OK_AND_ASSIGN(auto array_null,\n+                         MakeArrayOfNull(array_random->type(), len_null));\n+    auto array_null_filled =\n+        ConstantArrayGenerator::Numeric<TypeParam>(len_null, x_ptr[len_random - 1]);\n+    {\n+      ASSERT_OK_AND_ASSIGN(auto value_array,\n+                           Concatenate({array_random, array_null, array_random}));\n+      ASSERT_OK_AND_ASSIGN(auto result_array,\n+                           Concatenate({array_random, array_null_filled, array_random}));\n+      this->AssertFillNullArray(FillForwardNull, value_array, result_array);\n+    }\n+  }\n+}\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullBackwardLargeInput) {\n+  using CType = typename TypeTraits<TypeParam>::CType;\n+  random::RandomArrayGenerator rand(/*seed=*/1000);\n+  int64_t len_null = 500;\n+  int64_t len_random = 1000;\n+  std::shared_ptr<Array> array_random =\n+      rand.Numeric<TypeParam>(len_random, /*min=*/0, /*max=*/200, /*null_count=*/0);\n+\n+  if (array_random) {\n+    auto x_ptr = array_random->data()->template GetValues<CType>(1);\n+    ASSERT_OK_AND_ASSIGN(auto array_null,\n+                         MakeArrayOfNull(array_random->type(), len_null));\n+\n+    auto array_null_filled =\n+        ConstantArrayGenerator::Numeric<TypeParam>(len_null, x_ptr[0]);\n+    {\n+      ASSERT_OK_AND_ASSIGN(auto value_array,\n+                           Concatenate({array_random, array_null, array_random}));\n+      ASSERT_OK_AND_ASSIGN(auto result_array,\n+                           Concatenate({array_random, array_null_filled, array_random}));\n+      this->AssertFillNullArray(FillBackwardNull, value_array, result_array);\n+    }\n+  }\n+}\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullForwardSliced) {\n+  using CType = typename TypeTraits<TypeParam>::CType;\n+  random::RandomArrayGenerator rand(/*seed=*/666);\n+  int64_t len_random = 64;\n+  int64_t len_null = 64;\n+  int64_t slices = 15;\n+  std::vector<std::shared_ptr<Array>> vector_values;\n+  std::vector<std::shared_ptr<Array>> vector_filled;\n+  for (int i = 0; i < slices; i++) {\n+    std::shared_ptr<Array> array_random =\n+        rand.Numeric<TypeParam>(len_random, /*min=*/5, /*max=*/200, /*null_count=*/0);\n+    if (array_random) {\n+      auto x_ptr = array_random->data()->template GetValues<CType>(1);\n+      ASSERT_OK_AND_ASSIGN(auto array_null,\n+                           MakeArrayOfNull(array_random->type(), len_null));\n+      vector_values.push_back(array_random);\n+      vector_values.push_back(array_null);\n+      auto array_null_filled =\n+          ConstantArrayGenerator::Numeric<TypeParam>(len_null, x_ptr[len_random - 1]);\n+      vector_filled.push_back(array_random);\n+      vector_filled.push_back(array_null_filled);\n+    }\n+  }\n+\n+  if (vector_values.size() && vector_filled.size()) {\n+    ASSERT_OK_AND_ASSIGN(auto value_array, Concatenate(vector_values));\n+    ASSERT_OK_AND_ASSIGN(auto result_array, Concatenate(vector_filled));\n+\n+    this->AssertFillNullArray(FillForwardNull, value_array, result_array);\n+    uint8_t slice_length = len_null + len_random;\n+    for (int64_t slice = 0; slice < slices; slice++) {\n+      auto sliced_array = value_array->Slice(slice * slice_length, slice_length);\n+      auto sliced_array_expected =\n+          result_array->Slice(slice * slice_length, slice_length);\n+      this->AssertFillNullArray(FillForwardNull, sliced_array, sliced_array_expected);\n+    }\n+  }\n+}\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullBackwardSliced) {\n\nReview comment:\n       @lidavidm  I added some test cases, could you check it again? I assumed every slice is a new Array  and apply the forward/backward fill\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,460 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& array, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData current_value_array, bool* has_current_value,\n+                             int64_t* current_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                              out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*array.type, out_values,\n+                                  /*out_offset=*/output->offset, array, /*in_offset=*/0,\n+                                  array.length);\n+\n+  *has_current_value = false;\n+  auto array_scalars = arrow::MakeArray(current_value_array.Copy());\n+  bool has_fill_value = *current_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   array.length);\n+\n+  while (bitmap_offset < array.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *current_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      current_value_array = array;\n+      *has_current_value = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      if (block.popcount) {\n+        uint64_t write_value_offset = block_start_offset;\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset,\n+                                              current_value_array, *current_value_offset,\n+                                              /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            *current_value_offset = write_value_offset;\n+            current_value_array = array;\n+            *has_current_value = true;\n+          }\n+        }\n+      } else if (has_fill_value) {\n+        uint64_t write_value_offset =\n+            block_start_offset + (direction == 1 ? 0 : (-block.length + 1));\n+        auto in = *(array_scalars->GetScalar(*current_value_offset));\n+        ReplaceWithMask<Type>::CopyData(*array.type, out_values, write_value_offset, *in,\n+                                        *current_value_offset, block.length);\n+        bit_util::SetBitsTo(out_bitmap, write_value_offset, block.length, true);\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  current_value_array, has_current_value,\n+                                  current_value_offset);\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction == 1 ? 0 : array.length - 1;\n+    auto current_value_offset = write_offset + direction * (array.length - 1);\n+    return current_value_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const uint8_t* data_prev = current_value_array.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = current_value_array.GetValues<offset_type>(1);\n+\n+    *has_current_value = false;\n+    bool has_fill_value = *current_value_offset != -1;\n+    std::vector<std::tuple<bool, uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+          *current_value_offset = array_value_index;\n+          *has_current_value = true;\n+          has_fill_value = true;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value) {\n+            if (*has_current_value) {\n+              const offset_type offset0 = offsets[*current_value_offset];\n+              const offset_type offset1 = offsets[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*current_value_offset];\n+              const offset_type offset1 = offsets_prev[*current_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/0, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/0, -1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+    return write_offset;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData current_value_array,\n+                             bool* has_current_value, int64_t* current_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+\n+  static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+    return -1;\n+  }\n+};\n+\n+template <typename Type>\n+struct FillForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        bool has_current_value = false;\n+        int64_t has_current_offset = -1;\n+        return FillForwardArray(ctx, array_input, out, array_input, &has_current_value,\n+                                &has_current_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                 ArrayData current_value_array, bool* has_current_value,\n+                                 int64_t* current_value_offset) {\n+    ArrayData* output = out->array().get();\n+    if (!output->buffers[0]) {\n+      ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    }\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, array.buffers[0]->data(), output, direction, current_value_array,\n+          has_current_value, current_value_offset);\n+    } else {\n+      *current_value_offset = FillNullExecutor<Type>::LastElementOffset(array, direction);\n+      if (array.length > 0) {\n+        *has_current_value = true;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillForwardChunkedArray(KernelContext* ctx,\n+                                        const std::shared_ptr<ChunkedArray>& values,\n+                                        Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(*ToResult(values));\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(*ToResult(values));\n+      return Status::OK();\n+    }\n+    std::vector<std::shared_ptr<Array>> new_chunks;\n+\n+    if (values->length() > 0) {\n+      ArrayData array_with_current = *values->chunk(/*first_chunk=*/0)->data();\n+      bool has_current_value = false;\n+      int64_t has_current_offset = -1;\n+      for (const auto& chunk : values->chunks()) {\n+        auto buffer_size = chunk->length() * bit_width(values->type()->id());\n+        ARROW_ASSIGN_OR_RAISE(auto data, AllocateBuffer(buffer_size, ctx->memory_pool()));\n+\n+        std::unique_ptr<ArrayBuilder> builder;\n+        RETURN_NOT_OK(MakeBuilder(ctx->memory_pool(), values->type(), &builder));\n+        RETURN_NOT_OK(builder->Reserve(chunk->length()));\n+        ARROW_ASSIGN_OR_RAISE(auto array_output, builder->Finish());\n+\n+        ARROW_ASSIGN_OR_RAISE(array_output->data()->buffers[1],\n+                              ctx->Allocate(buffer_size / 8));\n+\n+        array_output->data()->length = values->length();\n+        auto array_out = Datum(*array_output);\n\nReview comment:\n       removed this part. \n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace_test.cc\n##########\n@@ -798,5 +828,688 @@ TYPED_TEST(TestReplaceBinary, ReplaceWithMaskRandom) {\n   }\n }\n \n+template <typename T>\n+class TestFillNullNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+TYPED_TEST_SUITE(TestFillNullNumeric, NumericBasedTypes);\n+TYPED_TEST_SUITE(TestFillNullDecimal, DecimalArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullBinary, BaseBinaryArrowTypes);\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[]\"), this->array(\"[]\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[null, null, null, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[null, null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[null, null, 4, 4, 5, 5]\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1,4,null]\"),\n+                            this->array(\"[1,4,4]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 6]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 6]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"30.00\"])\"),\n+                            this->array(R\"([null, null, null, \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, \"30.00\", null])\"),\n+                            this->array(R\"([null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([null, null, \"30.00\",null, \"5.00\", null])\"),\n+      this->array(R\"([null, null, \"30.00\", \"30.00\", \"5.00\", \"5.00\"])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([\"10.00\",\"30.00\",null])\"),\n+                            this->array(R\"([\"10.00\",\"30.00\",\"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"10.00\", \"30.00\", null, null, null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"30.00\", \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"5.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, \"ccc\"])\"),\n+                            this->array(R\"([null, null, null, \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, \"ccc\", null])\"),\n+                            this->array(R\"([null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, \"ccc\",null, \"xyz\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\", \"xyz\", \"xyz\"])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([\"aaa\",\"ccc\",null])\"),\n+                            this->array(R\"([\"aaa\",\"ccc\",\"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, null, null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"ccc\", \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"qwert\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"xyz\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", null])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[]\"), this->array(\"[]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, 4, null, null, null]\"),\n+                            this->array(\"[4, 4,null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[4, 4, 4, 5, 5, null]\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null]\"),\n+                            this->array(\"[1, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,null, null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 , 5, 5, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 6]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 6, 6, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, \"40.00\", null, null, null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\",null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"40.00\"])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\"])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([null, null, \"40.00\",null, \"50.00\", null])\"),\n+      this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"50.00\", \"50.00\", null])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([\"10.00\", \"40.00\", null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"10.00\", \"40.00\", null, null, null, null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" , \"50.00\", \"50.00\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"50.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"50.00\", \"50.00\", \"50.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"6.00\", \"6.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, \"afd\", null, null, null])\"),\n+                            this->array(R\"([\"afd\", \"afd\",null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, \"afd\"])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\"])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, \"afd\",null, \"qwe\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"qwe\", \"qwe\", null])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([\"tyu\", \"afd\", null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"tyu\", \"afd\", null, null, null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" , \"qwe\", \"qwe\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"oiutyu\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"oiutyu\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"qwe\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"qwe\", \"qwe\", \"qwe\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", null])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"oiutyu\", \"oiutyu\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+}\n+\n+// For Test Blocks\n+TYPED_TEST(TestFillNullNumeric, FillNullForwardLargeInput) {\n+  using CType = typename TypeTraits<TypeParam>::CType;\n+  random::RandomArrayGenerator rand(/*seed=*/1000);\n+  int64_t len_null = 500;\n+  int64_t len_random = 1000;\n+  std::shared_ptr<Array> array_random =\n+      rand.Numeric<TypeParam>(len_random, /*min=*/0, /*max=*/200, /*nulls=*/0);\n+\n+  if (array_random) {\n\nReview comment:\n       For Date Types, there's not exist a Random implementation, and it return an `nullptr` array_random\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,414 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n+\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+  bool use_current_chunk = false;\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      use_current_chunk = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      if (block.popcount) {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(\n+                  *current_chunk.type, out_values, write_value_offset,\n+                  use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                  *last_valid_value_offset,\n+                  /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            use_current_chunk = true;\n+            *last_valid_value_offset = write_value_offset;\n+          }\n+        }\n+      } else {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(\n+                *current_chunk.type, out_values, write_value_offset,\n+                use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                *last_valid_value_offset,\n+                /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& current_chunk,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(current_chunk.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(current_chunk.length));\n+    RETURN_NOT_OK(builder.ReserveData(current_chunk.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : current_chunk.length - 1;\n+    const uint8_t* data = current_chunk.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = current_chunk.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    /*tuple for store: <use current_chunk(true) or last_valid_chunk(false),\n+     * start offset of the current value, end offset for the current value>*/\n+    std::vector<std::tuple<bool, int64_t, int64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, output->offset, current_chunk.length,\n+        current_chunk.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n\nReview comment:\n       with an if-else if-else, the if and else block they would not repeat the same code?. I put this because if there exist a non-null value for fill(from the current or the previous chunk) it will fill the value or not, and both conditions are independents.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,409 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      last_valid_value_chunk = current_chunk;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+        auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+        if (!current_bit) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                            write_value_offset, last_valid_value_chunk,\n+                                            *last_valid_value_offset,\n+                                            /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        } else {\n+          has_fill_value = true;\n+          *last_valid_value_offset = write_value_offset;\n+          last_valid_value_chunk = current_chunk;\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n+\n+static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+  int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+  return write_offset;\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    std::vector<std::tuple<bool, uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/0, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/0, -1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullForwardArray(ctx, array_input, out, array_input,\n+                                    &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                     ArrayData last_valid_value_chunk,\n+                                     int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    /*if (!output->buffers[0]) {\n+      ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    }*/\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, array.buffers[0]->data(), output, direction, last_valid_value_chunk,\n+          last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = LastElementOffset(array, direction);\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullForwardChunkedArray(KernelContext* ctx,\n+                                            const std::shared_ptr<ChunkedArray>& values,\n+                                            Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    std::vector<std::shared_ptr<Array>> new_chunks;\n+\n+    if (values->length() > 0) {\n+      ArrayData array_with_current = *values->chunk(/*first_chunk=*/0)->data();\n+      int64_t last_valid_value_offset = -1;\n+      for (const auto& chunk : values->chunks()) {\n+        auto buffer_size = chunk->length() * bit_width(values->type()->id()) / 8;\n+\n+        std::unique_ptr<ArrayBuilder> builder;\n+        RETURN_NOT_OK(MakeBuilder(ctx->memory_pool(), values->type(), &builder));\n+        RETURN_NOT_OK(builder->Reserve(chunk->length()));\n+        ARROW_ASSIGN_OR_RAISE(auto array_output, builder->Finish());\n+        ARROW_ASSIGN_OR_RAISE(array_output->data()->buffers[1],\n+                              ctx->Allocate(buffer_size));\n+        ARROW_ASSIGN_OR_RAISE(array_output->data()->buffers[0],\n+                              ctx->AllocateBitmap(chunk->length()));\n\nReview comment:\n       @lidavidm I refactored this, using the code above and Copy for the result of every chunked array, there was no need to edit kernels different than replace_with_mask, and all tests passed, Can you check it again?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,409 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id){\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      last_valid_value_chunk = current_chunk;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+        auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+        if (!current_bit) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                            write_value_offset, last_valid_value_chunk,\n+                                            *last_valid_value_offset,\n+                                            /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        } else {\n+          has_fill_value = true;\n+          *last_valid_value_offset = write_value_offset;\n+          last_valid_value_chunk = current_chunk;\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n+\n+static int64_t LastElementOffset(const ArrayData& array, int8_t direction) {\n+  int64_t write_offset = direction != 1 ? 0 : array.length - 1;\n+  return write_offset;\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : array.length - 1;\n+    const uint8_t* data = array.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = array.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    std::vector<std::tuple<bool, uint64_t, uint64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, array.offset, array.length, array.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/1, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/0, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/0, -1U, -1U));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1U && std::get<2>(*it) == -1U) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, ArrayData last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullForwardArray(ctx, array_input, out, array_input,\n+                                    &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                     ArrayData last_valid_value_chunk,\n+                                     int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    /*if (!output->buffers[0]) {\n+      ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    }*/\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, array.buffers[0]->data(), output, direction, last_valid_value_chunk,\n+          last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = LastElementOffset(array, direction);\n\nReview comment:\n       I decided to remove the function `LastElementOffset(array, direction);`, because it was only used two times.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,414 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n+\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+  bool use_current_chunk = false;\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      use_current_chunk = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      if (block.popcount) {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(\n+                  *current_chunk.type, out_values, write_value_offset,\n+                  use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                  *last_valid_value_offset,\n+                  /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            use_current_chunk = true;\n+            *last_valid_value_offset = write_value_offset;\n+          }\n+        }\n+      } else {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(\n+                *current_chunk.type, out_values, write_value_offset,\n+                use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                *last_valid_value_offset,\n+                /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& current_chunk,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(current_chunk.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(current_chunk.length));\n+    RETURN_NOT_OK(builder.ReserveData(current_chunk.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : current_chunk.length - 1;\n+    const uint8_t* data = current_chunk.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = current_chunk.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    /*tuple for store: <use current_chunk(true) or last_valid_chunk(false),\n+     * start offset of the current value, end offset for the current value>*/\n+    std::vector<std::tuple<bool, int64_t, int64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, output->offset, current_chunk.length,\n+        current_chunk.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/false, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/false, -1, -1));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = current_chunk.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullForwardArray(ctx, array_input, out, array_input,\n+                                    &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                     const ArrayData& last_valid_value_chunk,\n+                                     int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto null_bitmap,\n+          arrow::internal::CopyBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                      array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(ctx, array, null_bitmap->data(), output,\n+                                                  direction, last_valid_value_chunk,\n+                                                  last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = direction != 1 ? 0 : array.length - 1;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullForwardChunkedArray(KernelContext* ctx,\n+                                            const std::shared_ptr<ChunkedArray>& values,\n+                                            Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+\n+    ArrayVector new_chunks;\n+    if (values->length() > 0) {\n+      ArrayData array_with_current = *values->chunk(/*first_chunk=*/0)->data();\n+      int64_t last_valid_value_offset = -1;\n+\n+      for (const auto& chunk : values->chunks()) {\n+        if (is_fixed_width(out->type()->id())) {\n+          auto* output = out->mutable_array();\n+          auto bit_width = checked_cast<const FixedWidthType&>(*output->type).bit_width();\n+          auto data_bytes = bit_util::BytesForBits(bit_width * chunk->length());\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(chunk->length()));\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[1], ctx->Allocate(data_bytes));\n+        }\n+        DCHECK_OK(FillNullForwardArray(ctx, *chunk->data(), out, array_with_current,\n+                                       &last_valid_value_offset));\n+        if (chunk->null_count() != chunk->length()) {\n+          array_with_current = *chunk->data();\n+        }\n+        new_chunks.push_back(MakeArray(out->make_array()->data()->Copy()));\n+      }\n+    }\n+\n+    auto output = std::make_shared<ChunkedArray>(std::move(new_chunks), values->type());\n+    *out = Datum(output);\n+    return Status::OK();\n+  }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make({InputType::Array(get_id.id)}, OutputType(FirstType));\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullBackwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullBackwardArray(ctx, array_input, out, array_input,\n+                                     &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullBackwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullBackwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                      const ArrayData& last_valid_value_chunk,\n+                                      int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = -1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto reversed_bitmap,\n+          arrow::internal::ReverseBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                         array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, reversed_bitmap->data(), output, direction, last_valid_value_chunk,\n+          last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = direction != 1 ? 0 : array.length - 1;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullBackwardChunkedArray(KernelContext* ctx,\n+                                             const std::shared_ptr<ChunkedArray>& values,\n+                                             Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    std::vector<std::shared_ptr<Array>> new_chunks;\n+\n+    if (values->length() > 0) {\n+      auto chunks_length = values->chunks().size();\n+      ArrayData array_with_current =\n+          *values->chunk(/*first_chunk=*/chunks_length - 1)->data();\n+      int64_t last_valid_value_offset = -1;\n+      auto chunks = values->chunks();\n+      for (int i = chunks_length - 1; i >= 0; --i) {\n+        const auto& chunk = chunks[i];\n+        auto buffer_size = chunk->length() * bit_width(values->type()->id()) / 8;\n+\n+        std::unique_ptr<ArrayBuilder> builder;\n+        RETURN_NOT_OK(MakeBuilder(ctx->memory_pool(), values->type(), &builder));\n+        RETURN_NOT_OK(builder->Reserve(chunk->length()));\n+        ARROW_ASSIGN_OR_RAISE(auto array_output, builder->Finish());\n+        ARROW_ASSIGN_OR_RAISE(array_output->data()->buffers[1],\n+                              ctx->Allocate(buffer_size));\n\nReview comment:\n       Fixed. I forgot to use the same implementation as `Forward`. Now both have the same implementation.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace_test.cc\n##########\n@@ -798,5 +828,688 @@ TYPED_TEST(TestReplaceBinary, ReplaceWithMaskRandom) {\n   }\n }\n \n+template <typename T>\n+class TestFillNullNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+TYPED_TEST_SUITE(TestFillNullNumeric, NumericBasedTypes);\n+TYPED_TEST_SUITE(TestFillNullDecimal, DecimalArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullBinary, BaseBinaryArrowTypes);\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[]\"), this->array(\"[]\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[null, null, null, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[null, null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[null, null, 4, 4, 5, 5]\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1,4,null]\"),\n+                            this->array(\"[1,4,4]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 6]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 6]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"30.00\"])\"),\n+                            this->array(R\"([null, null, null, \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, \"30.00\", null])\"),\n+                            this->array(R\"([null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([null, null, \"30.00\",null, \"5.00\", null])\"),\n+      this->array(R\"([null, null, \"30.00\", \"30.00\", \"5.00\", \"5.00\"])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([\"10.00\",\"30.00\",null])\"),\n+                            this->array(R\"([\"10.00\",\"30.00\",\"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"10.00\", \"30.00\", null, null, null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"30.00\", \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"5.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, null, \"ccc\"])\"),\n+                            this->array(R\"([null, null, null, \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, \"ccc\", null])\"),\n+                            this->array(R\"([null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([null, null, \"ccc\",null, \"xyz\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\", \"xyz\", \"xyz\"])\"));\n+\n+  this->AssertFillNullArray(FillForwardNull, this->array(R\"([\"aaa\",\"ccc\",null])\"),\n+                            this->array(R\"([\"aaa\",\"ccc\",\"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, null, null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"ccc\", \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillForwardNull,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"qwert\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"xyz\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", null])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+  this->AssertFillNullArray(\n+      FillForwardNull,\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[]\"), this->array(\"[]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, 4, null, null, null]\"),\n+                            this->array(\"[4, 4,null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[4, 4, 4, 5, 5, null]\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null]\"),\n+                            this->array(\"[1, 4, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,null, null, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 , 5, 5, null, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 6]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 6, 6, null]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, \"40.00\", null, null, null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\",null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"40.00\"])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\"])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([null, null, \"40.00\",null, \"50.00\", null])\"),\n+      this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"50.00\", \"50.00\", null])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([\"10.00\", \"40.00\", null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"10.00\", \"40.00\", null, null, null, null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" , \"50.00\", \"50.00\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"50.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"50.00\", \"50.00\", \"50.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"6.00\", \"6.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, \"afd\", null, null, null])\"),\n+                            this->array(R\"([\"afd\", \"afd\",null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, null, \"afd\"])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\"])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([null, null, \"afd\",null, \"qwe\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"qwe\", \"qwe\", null])\"));\n+\n+  this->AssertFillNullArray(FillBackwardNull, this->array(R\"([\"tyu\", \"afd\", null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"tyu\", \"afd\", null, null, null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(FillBackwardNull,\n+                            this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" , \"qwe\", \"qwe\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"oiutyu\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"oiutyu\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull, this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"qwe\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"qwe\", \"qwe\", \"qwe\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", null])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"oiutyu\", \"oiutyu\", null])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+  this->AssertFillNullArray(\n+      FillBackwardNull,\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+}\n+\n+// For Test Blocks\n+TYPED_TEST(TestFillNullNumeric, FillNullForwardLargeInput) {\n+  using CType = typename TypeTraits<TypeParam>::CType;\n+  random::RandomArrayGenerator rand(/*seed=*/1000);\n+  int64_t len_null = 500;\n+  int64_t len_random = 1000;\n+  std::shared_ptr<Array> array_random =\n+      rand.Numeric<TypeParam>(len_random, /*min=*/0, /*max=*/200, /*nulls=*/0);\n+\n+  if (array_random) {\n\nReview comment:\n       > Just a reminder here.\r\n   For Date Types which are part of the NumericBasedTypes, there's not exist a Random implementation, and it return an nullptr array_random\r\n   \n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -442,23 +442,414 @@ struct ReplaceWithMaskFunctor {\n     }\n     return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n   }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make(\n+        {InputType::Array(get_id.id), InputType(boolean()), InputType(get_id.id)},\n+        OutputType(FirstType));\n+  }\n };\n \n-}  // namespace\n+// This is for fixed-size types only\n+template <typename Type>\n+void FillNullInDirectionImpl(const ArrayData& current_chunk, const uint8_t* null_bitmap,\n+                             ArrayData* output, int8_t direction,\n+                             const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+  uint8_t* out_bitmap = output->buffers[0]->mutable_data();\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  arrow::internal::CopyBitmap(current_chunk.buffers[0]->data(), current_chunk.offset,\n+                              current_chunk.length, out_bitmap, output->offset);\n+  ReplaceWithMask<Type>::CopyData(*current_chunk.type, out_values,\n+                                  /*out_offset=*/output->offset, current_chunk,\n+                                  /*in_offset=*/0, current_chunk.length);\n+\n+  bool has_fill_value = *last_valid_value_offset != -1;\n+  int64_t write_offset = direction == 1 ? 0 : current_chunk.length - 1;\n+  int64_t bitmap_offset = 0;\n+\n+  arrow::internal::OptionalBitBlockCounter counter(null_bitmap, output->offset,\n+                                                   current_chunk.length);\n+  bool use_current_chunk = false;\n+  while (bitmap_offset < current_chunk.length) {\n+    BitBlockCount block = counter.NextBlock();\n+    if (block.AllSet()) {\n+      *last_valid_value_offset =\n+          write_offset + direction * (block.length - 1 + bitmap_offset);\n+      has_fill_value = true;\n+      use_current_chunk = true;\n+    } else {\n+      uint64_t block_start_offset = write_offset + direction * bitmap_offset;\n+      uint64_t write_value_offset = block_start_offset;\n+      if (block.popcount) {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          auto current_bit = bit_util::GetBit(null_bitmap, bitmap_offset + i);\n+          if (!current_bit) {\n+            if (has_fill_value) {\n+              ReplaceWithMask<Type>::CopyData(\n+                  *current_chunk.type, out_values, write_value_offset,\n+                  use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                  *last_valid_value_offset,\n+                  /*length=*/1);\n+              bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+            }\n+          } else {\n+            has_fill_value = true;\n+            use_current_chunk = true;\n+            *last_valid_value_offset = write_value_offset;\n+          }\n+        }\n+      } else {\n+        for (int64_t i = 0; i < block.length; i++, write_value_offset += direction) {\n+          if (has_fill_value) {\n+            ReplaceWithMask<Type>::CopyData(\n+                *current_chunk.type, out_values, write_value_offset,\n+                use_current_chunk ? current_chunk : last_valid_value_chunk,\n+                *last_valid_value_offset,\n+                /*length=*/1);\n+            bit_util::SetBitTo(out_bitmap, write_value_offset, true);\n+          }\n+        }\n+      }\n+    }\n+    bitmap_offset += block.length;\n+  }\n+  output->null_count = -1;\n+  output->GetNullCount();\n+}\n \n-const FunctionDoc replace_with_mask_doc(\n-    \"Replace items selected with a mask\",\n-    (\"Given an array and a boolean mask (either scalar or of equal length),\\n\"\n-     \"along with replacement values (either scalar or array),\\n\"\n-     \"each element of the array for which the corresponding mask element is\\n\"\n-     \"true will be replaced by the next value from the replacements,\\n\"\n-     \"or with null if the mask is null.\\n\"\n-     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n-    {\"values\", \"mask\", \"replacements\"});\n+template <typename Type, typename Enable = void>\n+struct FillNullExecutor {};\n \n-void RegisterVectorReplace(FunctionRegistry* registry) {\n-  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n-                                               &replace_with_mask_doc);\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_boolean<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<\n+    Type, enable_if_t<is_number_type<Type>::value ||\n+                      std::is_same<Type, MonthDayNanoIntervalType>::value>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_fixed_size_binary<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    FillNullInDirectionImpl<Type>(array, reversed_bitmap, output, direction,\n+                                  last_valid_value_chunk, last_valid_value_offset);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& current_chunk,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    BuilderType builder(current_chunk.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(current_chunk.length));\n+    RETURN_NOT_OK(builder.ReserveData(current_chunk.buffers[2]->size()));\n+    int64_t array_value_index = direction == 1 ? 0 : current_chunk.length - 1;\n+    const uint8_t* data = current_chunk.buffers[2]->data();\n+    const uint8_t* data_prev = last_valid_value_chunk.buffers[2]->data();\n+    const offset_type* offsets = current_chunk.GetValues<offset_type>(1);\n+    const offset_type* offsets_prev = last_valid_value_chunk.GetValues<offset_type>(1);\n+\n+    bool has_fill_value_last_chunk = *last_valid_value_offset != -1;\n+    bool has_fill_value_current_chunk = false;\n+    /*tuple for store: <use current_chunk(true) or last_valid_chunk(false),\n+     * start offset of the current value, end offset for the current value>*/\n+    std::vector<std::tuple<bool, int64_t, int64_t>> offsets_reversed;\n+    RETURN_NOT_OK(VisitNullBitmapInline<>(\n+        reversed_bitmap, output->offset, current_chunk.length,\n+        current_chunk.GetNullCount(),\n+        [&]() {\n+          const offset_type offset0 = offsets[array_value_index];\n+          const offset_type offset1 = offsets[array_value_index + 1];\n+          offsets_reversed.push_back(\n+              std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+          *last_valid_value_offset = array_value_index;\n+          has_fill_value_current_chunk = true;\n+          has_fill_value_last_chunk = false;\n+          array_value_index += direction;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          if (has_fill_value_current_chunk || has_fill_value_last_chunk) {\n+            if (!has_fill_value_last_chunk) {\n+              const offset_type offset0 = offsets[*last_valid_value_offset];\n+              const offset_type offset1 = offsets[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/true, offset0, offset1 - offset0));\n+            } else {\n+              const offset_type offset0 = offsets_prev[*last_valid_value_offset];\n+              const offset_type offset1 = offsets_prev[*last_valid_value_offset + 1];\n+              offsets_reversed.push_back(\n+                  std::make_tuple(/*current_chunk=*/false, offset0, offset1 - offset0));\n+            }\n+          } else {\n+            offsets_reversed.push_back(std::make_tuple(/*current_chunk=*/false, -1, -1));\n+          }\n+          array_value_index += direction;\n+          return Status::OK();\n+        }));\n+\n+    if (direction == 1) {\n+      for (auto it = offsets_reversed.begin(); it != offsets_reversed.end(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    } else {\n+      for (auto it = offsets_reversed.rbegin(); it != offsets_reversed.rend(); ++it) {\n+        if (std::get<1>(*it) == -1 && std::get<2>(*it) == -1) {\n+          RETURN_NOT_OK(builder.AppendNull());\n+        } else if (std::get<0>(*it)) {\n+          RETURN_NOT_OK(builder.Append(data + std::get<1>(*it), std::get<2>(*it)));\n+        } else {\n+          RETURN_NOT_OK(builder.Append(data_prev + std::get<1>(*it), std::get<2>(*it)));\n+        }\n+      }\n+    }\n+\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = current_chunk.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullExecutor<Type, enable_if_null<Type>> {\n+  static Status ExecFillNull(KernelContext* ctx, const ArrayData& array,\n+                             const uint8_t* reversed_bitmap, ArrayData* output,\n+                             int8_t direction, const ArrayData& last_valid_value_chunk,\n+                             int64_t* last_valid_value_offset) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullForwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullForwardArray(ctx, array_input, out, array_input,\n+                                    &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullForwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullForwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                     const ArrayData& last_valid_value_chunk,\n+                                     int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = 1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto null_bitmap,\n+          arrow::internal::CopyBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                      array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(ctx, array, null_bitmap->data(), output,\n+                                                  direction, last_valid_value_chunk,\n+                                                  last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = direction != 1 ? 0 : array.length - 1;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullForwardChunkedArray(KernelContext* ctx,\n+                                            const std::shared_ptr<ChunkedArray>& values,\n+                                            Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+\n+    ArrayVector new_chunks;\n+    if (values->length() > 0) {\n+      ArrayData array_with_current = *values->chunk(/*first_chunk=*/0)->data();\n+      int64_t last_valid_value_offset = -1;\n+\n+      for (const auto& chunk : values->chunks()) {\n+        if (is_fixed_width(out->type()->id())) {\n+          auto* output = out->mutable_array();\n+          auto bit_width = checked_cast<const FixedWidthType&>(*output->type).bit_width();\n+          auto data_bytes = bit_util::BytesForBits(bit_width * chunk->length());\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(chunk->length()));\n+          ARROW_ASSIGN_OR_RAISE(output->buffers[1], ctx->Allocate(data_bytes));\n+        }\n+        DCHECK_OK(FillNullForwardArray(ctx, *chunk->data(), out, array_with_current,\n+                                       &last_valid_value_offset));\n+        if (chunk->null_count() != chunk->length()) {\n+          array_with_current = *chunk->data();\n+        }\n+        new_chunks.push_back(MakeArray(out->make_array()->data()->Copy()));\n+      }\n+    }\n+\n+    auto output = std::make_shared<ChunkedArray>(std::move(new_chunks), values->type());\n+    *out = Datum(output);\n+    return Status::OK();\n+  }\n+\n+  static std::shared_ptr<KernelSignature> GetSignature(detail::GetTypeId get_id) {\n+    return KernelSignature::Make({InputType::Array(get_id.id)}, OutputType(FirstType));\n+  }\n+};\n+\n+template <typename Type>\n+struct FillNullBackwardFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    switch (batch[0].kind()) {\n+      case Datum::ARRAY: {\n+        auto array_input = *batch[0].array();\n+        int64_t last_valid_value_offset = -1;\n+        return FillNullBackwardArray(ctx, array_input, out, array_input,\n+                                     &last_valid_value_offset);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        return FillNullBackwardChunkedArray(ctx, batch[0].chunked_array(), out);\n+      }\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for drop_null operation: \"\n+        \"values=\",\n+        batch[0].ToString());\n+  }\n+\n+  static Status FillNullBackwardArray(KernelContext* ctx, ArrayData& array, Datum* out,\n+                                      const ArrayData& last_valid_value_chunk,\n+                                      int64_t* last_valid_value_offset) {\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+    int8_t direction = -1;\n+\n+    if (array.MayHaveNulls()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto reversed_bitmap,\n+          arrow::internal::ReverseBitmap(ctx->memory_pool(), array.buffers[0]->data(),\n+                                         array.offset, array.length));\n+      return FillNullExecutor<Type>::ExecFillNull(\n+          ctx, array, reversed_bitmap->data(), output, direction, last_valid_value_chunk,\n+          last_valid_value_offset);\n+    } else {\n+      if (array.length > 0) {\n+        *last_valid_value_offset = direction != 1 ? 0 : array.length - 1;\n+      }\n+      *output = array;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status FillNullBackwardChunkedArray(KernelContext* ctx,\n+                                             const std::shared_ptr<ChunkedArray>& values,\n+                                             Datum* out) {\n+    if (values->null_count() == 0) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    if (values->null_count() == values->length()) {\n+      *out = Datum(values);\n+      return Status::OK();\n+    }\n+    std::vector<std::shared_ptr<Array>> new_chunks;\n+\n+    if (values->length() > 0) {\n+      auto chunks_length = values->chunks().size();\n+      ArrayData array_with_current =\n\nReview comment:\n       Could you check it again and see if I did in the correct way\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-03T15:29:31.486+0000",
                    "updated": "2022-01-03T15:29:31.486+0000",
                    "started": "2022-01-03T15:29:31.486+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "702986",
                    "issueId": "13111093"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/worklog/702987",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11853:\nURL: https://github.com/apache/arrow/pull/11853#discussion_r777545990\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace_test.cc\n##########\n@@ -793,5 +851,772 @@ TYPED_TEST(TestReplaceBinary, ReplaceWithMaskRandom) {\n   }\n }\n \n+template <typename T>\n+class TestFillNullNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+template <typename T>\n+class TestFillNullBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+template <typename T>\n+class TestFillNullNullType : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+TYPED_TEST_SUITE(TestFillNullNumeric, NumericBasedTypes);\n+TYPED_TEST_SUITE(TestFillNullDecimal, DecimalArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullBinary, BaseBinaryArrowTypes);\n+TYPED_TEST_SUITE(TestFillNullNullType, ::testing::Types<NullType>);\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[]\"), this->array(\"[]\"));\n+\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[null, null, null, 4]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[null, 4, 4]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[null, null, null, 4, 4]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[null, null, 4, 4, 5, 5]\"));\n+\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[1,4,null]\"),\n+                            this->array(\"[1,4,4]\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 6]\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 6]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"),\n+                            this->array(\"[1, 4 ,4, 5, 5, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(R\"([null, null, null, \"30.00\"])\"),\n+                            this->array(R\"([null, null, null, \"30.00\"])\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([null, \"30.00\", null])\"),\n+                            this->array(R\"([null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(R\"([null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(R\"([null, null, null, \"30.00\", null])\"),\n+                            this->array(R\"([null, null, null, \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward, this->array(R\"([null, null, \"30.00\",null, \"5.00\", null])\"),\n+      this->array(R\"([null, null, \"30.00\", \"30.00\", \"5.00\", \"5.00\"])\"));\n+\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([\"10.00\",\"30.00\",null])\"),\n+                            this->array(R\"([\"10.00\",\"30.00\",\"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward, this->array(R\"([\"10.00\", \"30.00\", null, null, null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"30.00\", \"30.00\", \"30.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward, this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, null, \"5.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"5.00\", \"5.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward,\n+      this->array(R\"([\"10.00\", \"30.00\", null, \"5.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward,\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"30.00\" ,\"30.00\", \"5.00\", \"5.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesForward) {\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([null, null, null, \"ccc\"])\"),\n+                            this->array(R\"([null, null, null, \"ccc\"])\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([null, \"ccc\", null])\"),\n+                            this->array(R\"([null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(R\"([null, null, null, \"ccc\", null])\"),\n+                            this->array(R\"([null, null, null, \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(R\"([null, null, \"ccc\",null, \"xyz\", null])\"),\n+                            this->array(R\"([null, null, \"ccc\", \"ccc\", \"xyz\", \"xyz\"])\"));\n+\n+  this->AssertFillNullArray(FillNullForward, this->array(R\"([\"aaa\",\"ccc\",null])\"),\n+                            this->array(R\"([\"aaa\",\"ccc\",\"ccc\"])\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, null, null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"ccc\", \"ccc\", \"ccc\"])\"));\n+  this->AssertFillNullArray(FillNullForward,\n+                            this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null])\"),\n+                            this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"qwert\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, null, \"xyz\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"xyz\", \"xyz\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", null])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"qwert\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward, this->array(R\"([\"aaa\", \"ccc\", null, \"xyz\", null, \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullForward,\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"),\n+      this->array(R\"([\"aaa\", \"ccc\" ,\"ccc\", \"xyz\", \"xyz\", \"qwert\", \"uy\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[]\"), this->array(\"[]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[null, null, null, null]\"),\n+                            this->array(\"[null, null, null, null]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[null, 4, null, null, null]\"),\n+                            this->array(\"[4, 4,null, null, null]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[null, null, null, 4]\"),\n+                            this->array(\"[4, 4, 4, 4]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[null, 4, null]\"),\n+                            this->array(\"[4, 4, null]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[null, null, null, 4, null]\"),\n+                            this->array(\"[4, 4, 4, 4, null]\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(\"[null, null, 4,null, 5, null]\"),\n+                            this->array(\"[4, 4, 4, 5, 5, null]\"));\n+\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[1, 4, null]\"),\n+                            this->array(\"[1, 4, null]\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(\"[1, 4, null, null, null, null]\"),\n+                            this->array(\"[1, 4 ,null, null, null, null]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[1, 4, null, 5, null, null]\"),\n+                            this->array(\"[1, 4 , 5, 5, null, null]\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(\"[1, 4, null, 5, null, null, 6]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 6]\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(\"[1, 4, null, 5, null, null, 5]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 5, 5, 5]\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(\"[1, 4, null, 5, null, 6, null]\"),\n+                            this->array(\"[1, 4 ,5 , 5, 6, 6, null]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[1, 4, null, 5, null, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"),\n+                            this->array(\"[1, 4 ,5, 5, 6, 6, 7]\"));\n+}\n+\n+TYPED_TEST(TestFillNullDecimal, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([null, \"40.00\", null, null, null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\",null, null, null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([null, null, null, \"40.00\"])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\"])\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([null, null, null, \"40.00\", null])\"),\n+                            this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward, this->array(R\"([null, null, \"40.00\",null, \"50.00\", null])\"),\n+      this->array(R\"([\"40.00\", \"40.00\", \"40.00\", \"50.00\", \"50.00\", null])\"));\n+\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([\"10.00\", \"40.00\", null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\", null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([\"10.00\", \"40.00\", null, null, null, null])\"),\n+                            this->array(R\"([\"10.00\", \"40.00\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward, this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" , \"50.00\", \"50.00\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"6.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"6.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, null, \"50.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"50.00\", \"50.00\", \"50.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", null])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\" , \"50.00\", \"6.00\", \"6.00\", null])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"10.00\", \"40.00\", null, \"50.00\", null, \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"),\n+      this->array(R\"([\"10.00\", \"40.00\" ,\"50.00\", \"50.00\", \"6.00\", \"6.00\", \"7.00\"])\"));\n+}\n+\n+TYPED_TEST(TestFillNullBinary, FillNullValuesBackward) {\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([])\"), this->array(R\"([])\"));\n+\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([null, null, null, null])\"),\n+                            this->array(R\"([null, null, null, null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([null, \"afd\", null, null, null])\"),\n+                            this->array(R\"([\"afd\", \"afd\",null, null, null])\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([null, null, null, \"afd\"])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\"])\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([null, null, null, \"afd\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([null, null, \"afd\",null, \"qwe\", null])\"),\n+                            this->array(R\"([\"afd\", \"afd\", \"afd\", \"qwe\", \"qwe\", null])\"));\n+\n+  this->AssertFillNullArray(FillNullBackward, this->array(R\"([\"tyu\", \"afd\", null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\", null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([\"tyu\", \"afd\", null, null, null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" ,null, null, null, null])\"));\n+  this->AssertFillNullArray(FillNullBackward,\n+                            this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null])\"),\n+                            this->array(R\"([\"tyu\", \"afd\" , \"qwe\", \"qwe\", null, null])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"oiutyu\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"oiutyu\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward, this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, null, \"qwe\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"qwe\", \"qwe\", \"qwe\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", null])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\" , \"qwe\", \"oiutyu\", \"oiutyu\", null])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"tyu\", \"afd\", null, \"qwe\", null, \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+  this->AssertFillNullArray(\n+      FillNullBackward,\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"),\n+      this->array(R\"([\"tyu\", \"afd\" ,\"qwe\", \"qwe\", \"oiutyu\", \"oiutyu\", \"aaaagggbbb\"])\"));\n+}\n+\n+// For Test Blocks\n+TYPED_TEST(TestFillNullNumeric, FillNullForwardLargeInput) {\n+  using CType = typename TypeTraits<TypeParam>::CType;\n+  random::RandomArrayGenerator rand(/*seed=*/1000);\n+  int64_t len_null = 500;\n+  int64_t len_random = 1000;\n+  std::shared_ptr<Array> array_random =\n+      rand.Numeric<TypeParam>(len_random, /*min=*/0, /*max=*/200, /*nulls=*/0);\n+\n+  if (array_random) {\n+    auto x_ptr = array_random->data()->template GetValues<CType>(1);\n+    ASSERT_OK_AND_ASSIGN(auto array_null,\n+                         MakeArrayOfNull(array_random->type(), len_null));\n+    auto array_null_filled =\n+        ConstantArrayGenerator::Numeric<TypeParam>(len_null, x_ptr[len_random - 1]);\n+    {\n+      ASSERT_OK_AND_ASSIGN(auto value_array,\n+                           Concatenate({array_random, array_null, array_random}));\n+      ASSERT_OK_AND_ASSIGN(auto result_array,\n+                           Concatenate({array_random, array_null_filled, array_random}));\n+      this->AssertFillNullArray(FillNullForward, value_array, result_array);\n+    }\n+  }\n+}\n+\n+TYPED_TEST(TestFillNullNumeric, FillNullBackwardLargeInput) {\n+  using CType = typename TypeTraits<TypeParam>::CType;\n+  random::RandomArrayGenerator rand(/*seed=*/1000);\n+  int64_t len_null = 500;\n+  int64_t len_random = 1000;\n+  std::shared_ptr<Array> array_random =\n+      rand.Numeric<TypeParam>(len_random, /*min=*/0, /*max=*/200, /*null_count=*/0);\n+\n+  if (array_random) {\n\nReview comment:\n       Do you mind using `ArrayOf` instead then? It should handle all types: https://github.com/apache/arrow/blob/c6143a2396058dcc31506050238dc0f932aae9ba/cpp/src/arrow/testing/random.h#L380\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-03T15:32:18.030+0000",
                    "updated": "2022-01-03T15:32:18.030+0000",
                    "started": "2022-01-03T15:32:18.030+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "702987",
                    "issueId": "13111093"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 23400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@338f25aa[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@611dbc1[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3290e6c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@bee121b[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@c40bb31[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@4bc2e73a[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@d3ca40[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@7bd66e8b[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7246dbf3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@2e6109b6[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@30fe47f0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@7814d552[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 23400,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Jan 05 14:30:58 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-01-05T14:30:58.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1699/watchers",
            "watchCount": 5,
            "isWatching": false
        },
        "created": "2017-10-20T20:47:11.000+0000",
        "updated": "2022-01-06T12:51:17.000+0000",
        "timeoriginalestimate": null,
        "description": "Like ffill / bfill in pandas (with limit)",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "6.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 23400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Forward, backward fill kernel functions",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/comment/17116055",
                    "id": "17116055",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "These are VECTOR functions",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-05-25T14:11:34.602+0000",
                    "updated": "2020-05-25T14:11:34.602+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/comment/17392873",
                    "id": "17392873",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "[~niranda] ",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-08-04T08:46:32.962+0000",
                    "updated": "2021-08-04T08:46:32.962+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/comment/17444946",
                    "id": "17444946",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alvinj15",
                        "name": "alvinj15",
                        "key": "JIRAUSER280323",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Alvin Chunga Mamani",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "in development",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alvinj15",
                        "name": "alvinj15",
                        "key": "JIRAUSER280323",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Alvin Chunga Mamani",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2021-11-17T06:05:31.011+0000",
                    "updated": "2021-11-17T06:05:31.011+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111093/comment/17469352",
                    "id": "17469352",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 11853\n[https://github.com/apache/arrow/pull/11853]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2022-01-05T14:30:58.934+0000",
                    "updated": "2022-01-05T14:30:58.934+0000"
                }
            ],
            "maxResults": 4,
            "total": 4,
            "startAt": 0
        },
        "customfield_12311820": "0|i3ljc7:",
        "customfield_12314139": null
    }
}