{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13363668",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13363668",
    "key": "ARROW-11930",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349983",
                "id": "12349983",
                "description": "",
                "name": "5.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-07-28"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "compute",
            "dataset",
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12610350",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12610350",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "inwardIssue": {
                    "id": "13306872",
                    "key": "ARROW-8894",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13306872",
                    "fields": {
                        "summary": "[C++] C++ array kernels framework and execution buildout (umbrella issue)",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12615167",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12615167",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "inwardIssue": {
                    "id": "13376404",
                    "key": "ARROW-12633",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376404",
                    "fields": {
                        "summary": "[C++] Query engine umbrella issue",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 43800,
            "total": 43800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 43800,
            "total": 43800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11930/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 73,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13363668/worklog/601949",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz opened a new pull request #10397:\nURL: https://github.com/apache/arrow/pull/10397\n\n\n   So far this involved a lot of refactoring of Expressions to be compatible with ExecBatches. The next step is to add a ScanNode wrapping a ScannerBuilder\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-25T21:06:04.024+0000",
                    "updated": "2021-05-25T21:06:04.024+0000",
                    "started": "2021-05-25T21:06:04.024+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "601949",
                    "issueId": "13363668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13363668/worklog/601950",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10397:\nURL: https://github.com/apache/arrow/pull/10397#issuecomment-848264046\n\n\n   https://issues.apache.org/jira/browse/ARROW-11930\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-25T21:06:28.109+0000",
                    "updated": "2021-05-25T21:06:28.109+0000",
                    "started": "2021-05-25T21:06:28.109+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "601950",
                    "issueId": "13363668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13363668/worklog/603195",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10397:\nURL: https://github.com/apache/arrow/pull/10397#discussion_r640799446\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/exec_plan.cc\n##########\n@@ -170,48 +165,409 @@ Status ExecPlan::Validate() { return ToDerived(this)->Validate(); }\n \n Status ExecPlan::StartProducing() { return ToDerived(this)->StartProducing(); }\n \n-ExecNode::ExecNode(ExecPlan* plan, std::string label,\n-                   std::vector<BatchDescr> input_descrs,\n+ExecNode::ExecNode(ExecPlan* plan, std::string label, NodeVector inputs,\n                    std::vector<std::string> input_labels, BatchDescr output_descr,\n                    int num_outputs)\n     : plan_(plan),\n       label_(std::move(label)),\n-      input_descrs_(std::move(input_descrs)),\n+      inputs_(std::move(inputs)),\n       input_labels_(std::move(input_labels)),\n       output_descr_(std::move(output_descr)),\n-      num_outputs_(num_outputs) {}\n+      num_outputs_(num_outputs) {\n+  for (auto input : inputs_) {\n+    input->outputs_.push_back(this);\n+  }\n+}\n \n Status ExecNode::Validate() const {\n-  if (inputs_.size() != input_descrs_.size()) {\n+  if (inputs_.size() != input_labels_.size()) {\n     return Status::Invalid(\"Invalid number of inputs for '\", label(), \"' (expected \",\n-                           num_inputs(), \", actual \", inputs_.size(), \")\");\n+                           num_inputs(), \", actual \", input_labels_.size(), \")\");\n   }\n \n   if (static_cast<int>(outputs_.size()) != num_outputs_) {\n     return Status::Invalid(\"Invalid number of outputs for '\", label(), \"' (expected \",\n                            num_outputs(), \", actual \", outputs_.size(), \")\");\n   }\n \n-  DCHECK_EQ(input_descrs_.size(), input_labels_.size());\n-\n   for (auto out : outputs_) {\n     auto input_index = GetNodeIndex(out->inputs(), this);\n     if (!input_index) {\n       return Status::Invalid(\"Node '\", label(), \"' outputs to node '\", out->label(),\n                              \"' but is not listed as an input.\");\n     }\n+  }\n \n-    const auto& in_descr = out->input_descrs_[*input_index];\n-    if (in_descr != output_descr_) {\n-      return Status::Invalid(\n-          \"Node '\", label(), \"' (bound to input \", input_labels_[*input_index],\n-          \") produces batches with type '\", ValueDescr::ToString(output_descr_),\n-          \"' inconsistent with consumer '\", out->label(), \"' which accepts '\",\n-          ValueDescr::ToString(in_descr), \"'\");\n+  return Status::OK();\n+}\n+\n+struct SourceNode : ExecNode {\n+  SourceNode(ExecPlan* plan, std::string label, ExecNode::BatchDescr output_descr,\n+             AsyncGenerator<util::optional<ExecBatch>> generator)\n+      : ExecNode(plan, std::move(label), {}, {}, std::move(output_descr),\n+                 /*num_outputs=*/1),\n+        generator_(std::move(generator)) {}\n+\n+  const char* kind_name() override { return \"SourceNode\"; }\n+\n+  static void NoInputs() { DCHECK(false) << \"no inputs; this should never be called\"; }\n+  void InputReceived(ExecNode*, int, ExecBatch) override { NoInputs(); }\n+  void ErrorReceived(ExecNode*, Status) override { NoInputs(); }\n+  void InputFinished(ExecNode*, int) override { NoInputs(); }\n+\n+  Status StartProducing() override {\n+    if (finished_) {\n+      return Status::Invalid(\"Restarted SourceNode '\", label(), \"'\");\n     }\n+\n+    auto gen = std::move(generator_);\n+\n+    /// XXX should we wait on this future anywhere? In StopProducing() maybe?\n+    auto done_fut =\n+        Loop([gen, this] {\n+          std::unique_lock<std::mutex> lock(mutex_);\n+          int seq = next_batch_index_++;\n+          if (finished_) {\n+            return Future<ControlFlow<int>>::MakeFinished(Break(seq));\n+          }\n+          lock.unlock();\n+\n+          return gen().Then(\n+              [=](const util::optional<ExecBatch>& batch) -> ControlFlow<int> {\n+                std::unique_lock<std::mutex> lock(mutex_);\n+                if (!batch || finished_) {\n+                  finished_ = true;\n+                  return Break(seq);\n+                }\n+                lock.unlock();\n+\n+                outputs_[0]->InputReceived(this, seq, *batch);\n+                return Continue();\n+              },\n+              [=](const Status& error) -> ControlFlow<int> {\n+                std::unique_lock<std::mutex> lock(mutex_);\n+                if (!finished_) {\n+                  finished_ = true;\n+                  lock.unlock();\n+                  // unless we were already finished, push the error to our output\n+                  // XXX is this correct? Is it reasonable for a consumer to ignore errors\n+                  // from a finished producer?\n\nReview comment:\n       Given that stopping a producer doesn't necessarily immediately terminate everything, the consumer needs to be prepared to get and handle/ignore an error anyways.\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression.cc\n##########\n@@ -510,7 +475,67 @@ Result<Expression> Expression::Bind(const Schema& in_schema,\n   return Bind(ValueDescr::Array(struct_(in_schema.fields())), exec_context);\n }\n \n-Result<Datum> ExecuteScalarExpression(const Expression& expr, const Datum& input,\n+Result<ExecBatch> MakeExecBatch(const Schema& full_schema, const Datum& partial) {\n+  ExecBatch out;\n+\n+  if (partial.kind() == Datum::RECORD_BATCH) {\n+    const auto& partial_batch = *partial.record_batch();\n+    out.length = partial_batch.num_rows();\n+\n+    for (const auto& field : full_schema.fields()) {\n+      ARROW_ASSIGN_OR_RAISE(auto column,\n+                            FieldRef(field->name()).GetOneOrNone(partial_batch));\n\nReview comment:\n       On the other hand, this will still be quadratic.\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression.h\n##########\n@@ -64,8 +64,11 @@ class ARROW_EXPORT Expression {\n   /// Bind this expression to the given input type, looking up Kernels and field types.\n   /// Some expression simplification may be performed and implicit casts will be inserted.\n   /// Any state necessary for execution will be initialized and returned.\n-  Result<Expression> Bind(ValueDescr in, compute::ExecContext* = NULLPTR) const;\n-  Result<Expression> Bind(const Schema& in_schema, compute::ExecContext* = NULLPTR) const;\n+  Result<Expression> Bind(ValueDescr in, ExecContext* = NULLPTR) const;\n+  Result<Expression> Bind(const Schema& in_schema, ExecContext* = NULLPTR) const;\n+\n+  Result<Expression> BindFlattened(ValueDescr in, ExecContext* = NULLPTR) const;\n\nReview comment:\n       Are these implemented?\n\n##########\nFile path: cpp/src/arrow/compute/exec/exec_plan.cc\n##########\n@@ -170,48 +165,409 @@ Status ExecPlan::Validate() { return ToDerived(this)->Validate(); }\n \n Status ExecPlan::StartProducing() { return ToDerived(this)->StartProducing(); }\n \n-ExecNode::ExecNode(ExecPlan* plan, std::string label,\n-                   std::vector<BatchDescr> input_descrs,\n+ExecNode::ExecNode(ExecPlan* plan, std::string label, NodeVector inputs,\n                    std::vector<std::string> input_labels, BatchDescr output_descr,\n                    int num_outputs)\n     : plan_(plan),\n       label_(std::move(label)),\n-      input_descrs_(std::move(input_descrs)),\n+      inputs_(std::move(inputs)),\n       input_labels_(std::move(input_labels)),\n       output_descr_(std::move(output_descr)),\n-      num_outputs_(num_outputs) {}\n+      num_outputs_(num_outputs) {\n+  for (auto input : inputs_) {\n+    input->outputs_.push_back(this);\n+  }\n+}\n \n Status ExecNode::Validate() const {\n-  if (inputs_.size() != input_descrs_.size()) {\n+  if (inputs_.size() != input_labels_.size()) {\n     return Status::Invalid(\"Invalid number of inputs for '\", label(), \"' (expected \",\n-                           num_inputs(), \", actual \", inputs_.size(), \")\");\n+                           num_inputs(), \", actual \", input_labels_.size(), \")\");\n   }\n \n   if (static_cast<int>(outputs_.size()) != num_outputs_) {\n     return Status::Invalid(\"Invalid number of outputs for '\", label(), \"' (expected \",\n                            num_outputs(), \", actual \", outputs_.size(), \")\");\n   }\n \n-  DCHECK_EQ(input_descrs_.size(), input_labels_.size());\n-\n   for (auto out : outputs_) {\n     auto input_index = GetNodeIndex(out->inputs(), this);\n     if (!input_index) {\n       return Status::Invalid(\"Node '\", label(), \"' outputs to node '\", out->label(),\n                              \"' but is not listed as an input.\");\n     }\n+  }\n \n-    const auto& in_descr = out->input_descrs_[*input_index];\n-    if (in_descr != output_descr_) {\n-      return Status::Invalid(\n-          \"Node '\", label(), \"' (bound to input \", input_labels_[*input_index],\n-          \") produces batches with type '\", ValueDescr::ToString(output_descr_),\n-          \"' inconsistent with consumer '\", out->label(), \"' which accepts '\",\n-          ValueDescr::ToString(in_descr), \"'\");\n+  return Status::OK();\n+}\n+\n+struct SourceNode : ExecNode {\n+  SourceNode(ExecPlan* plan, std::string label, ExecNode::BatchDescr output_descr,\n+             AsyncGenerator<util::optional<ExecBatch>> generator)\n+      : ExecNode(plan, std::move(label), {}, {}, std::move(output_descr),\n+                 /*num_outputs=*/1),\n+        generator_(std::move(generator)) {}\n+\n+  const char* kind_name() override { return \"SourceNode\"; }\n+\n+  static void NoInputs() { DCHECK(false) << \"no inputs; this should never be called\"; }\n+  void InputReceived(ExecNode*, int, ExecBatch) override { NoInputs(); }\n+  void ErrorReceived(ExecNode*, Status) override { NoInputs(); }\n+  void InputFinished(ExecNode*, int) override { NoInputs(); }\n+\n+  Status StartProducing() override {\n+    if (finished_) {\n+      return Status::Invalid(\"Restarted SourceNode '\", label(), \"'\");\n     }\n+\n+    auto gen = std::move(generator_);\n+\n+    /// XXX should we wait on this future anywhere? In StopProducing() maybe?\n+    auto done_fut =\n+        Loop([gen, this] {\n+          std::unique_lock<std::mutex> lock(mutex_);\n+          int seq = next_batch_index_++;\n+          if (finished_) {\n+            return Future<ControlFlow<int>>::MakeFinished(Break(seq));\n+          }\n+          lock.unlock();\n+\n+          return gen().Then(\n+              [=](const util::optional<ExecBatch>& batch) -> ControlFlow<int> {\n+                std::unique_lock<std::mutex> lock(mutex_);\n+                if (!batch || finished_) {\n+                  finished_ = true;\n+                  return Break(seq);\n+                }\n+                lock.unlock();\n+\n+                outputs_[0]->InputReceived(this, seq, *batch);\n+                return Continue();\n+              },\n+              [=](const Status& error) -> ControlFlow<int> {\n+                std::unique_lock<std::mutex> lock(mutex_);\n+                if (!finished_) {\n+                  finished_ = true;\n+                  lock.unlock();\n+                  // unless we were already finished, push the error to our output\n+                  // XXX is this correct? Is it reasonable for a consumer to ignore errors\n+                  // from a finished producer?\n+                  outputs_[0]->ErrorReceived(this, error);\n+                }\n+                return Break(seq);\n+              });\n+        }).Then([&](int seq) {\n+          /// XXX this is probably redundant: do we always call InputFinished after\n+          /// ErrorReceived or will ErrorRecieved be sufficient?\n+          outputs_[0]->InputFinished(this, seq);\n+        });\n+\n+    return Status::OK();\n   }\n \n-  return Status::OK();\n+  void PauseProducing(ExecNode* output) override {}\n+\n+  void ResumeProducing(ExecNode* output) override {}\n+\n+  void StopProducing(ExecNode* output) override {\n+    DCHECK_EQ(output, outputs_[0]);\n+    std::unique_lock<std::mutex> lock(mutex_);\n+    finished_ = true;\n+  }\n+\n+  void StopProducing() override { StopProducing(outputs_[0]); }\n+\n+ private:\n+  std::mutex mutex_;\n+  bool finished_{false};\n+  int next_batch_index_{0};\n+  AsyncGenerator<util::optional<ExecBatch>> generator_;\n+};\n+\n+ExecNode* MakeSourceNode(ExecPlan* plan, std::string label,\n+                         ExecNode::BatchDescr output_descr,\n+                         AsyncGenerator<util::optional<ExecBatch>> generator) {\n+  return plan->EmplaceNode<SourceNode>(plan, std::move(label), std::move(output_descr),\n+                                       std::move(generator));\n+}\n+\n+struct FilterNode : ExecNode {\n+  FilterNode(ExecNode* input, std::string label, Expression filter)\n+      : ExecNode(input->plan(), std::move(label), {input}, {\"target\"},\n+                 /*output_descr=*/{input->output_descr()},\n+                 /*num_outputs=*/1),\n+        filter_(std::move(filter)) {}\n+\n+  const char* kind_name() override { return \"FilterNode\"; }\n+\n+  Result<ExecBatch> DoFilter(const ExecBatch& target) {\n+    ARROW_ASSIGN_OR_RAISE(Expression simplified_filter,\n+                          SimplifyWithGuarantee(filter_, target.guarantee));\n+\n+    // XXX get a non-default exec context\n+    ARROW_ASSIGN_OR_RAISE(Datum mask, ExecuteScalarExpression(simplified_filter, target));\n+\n+    if (mask.is_scalar()) {\n+      const auto& mask_scalar = mask.scalar_as<BooleanScalar>();\n+      if (mask_scalar.is_valid && mask_scalar.value) {\n+        return target;\n+      }\n+\n+      return target.Slice(0, 0);\n+    }\n+\n+    auto values = target.values;\n+    for (auto& value : values) {\n+      if (value.is_scalar()) continue;\n+      ARROW_ASSIGN_OR_RAISE(value, Filter(value, mask, FilterOptions::Defaults()));\n+    }\n+    return ExecBatch::Make(std::move(values));\n+  }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+\n+    auto maybe_filtered = DoFilter(std::move(batch));\n+    if (!maybe_filtered.ok()) {\n+      outputs_[0]->ErrorReceived(this, maybe_filtered.status());\n+      inputs_[0]->StopProducing(this);\n+      return;\n+    }\n+\n+    maybe_filtered->guarantee = batch.guarantee;\n+    outputs_[0]->InputReceived(this, seq, maybe_filtered.MoveValueUnsafe());\n+  }\n+\n+  void ErrorReceived(ExecNode* input, Status error) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->ErrorReceived(this, std::move(error));\n+    inputs_[0]->StopProducing(this);\n+  }\n+\n+  void InputFinished(ExecNode* input, int seq) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->InputFinished(this, seq);\n+    inputs_[0]->StopProducing(this);\n+  }\n+\n+  Status StartProducing() override {\n+    // XXX validate inputs_[0]->output_descr() against filter_\n+    return Status::OK();\n+  }\n+\n+  void PauseProducing(ExecNode* output) override {}\n+\n+  void ResumeProducing(ExecNode* output) override {}\n+\n+  void StopProducing(ExecNode* output) override {\n+    DCHECK_EQ(output, outputs_[0]);\n+    inputs_[0]->StopProducing(this);\n+  }\n+\n+  void StopProducing() override { StopProducing(outputs_[0]); }\n+\n+ private:\n+  Expression filter_;\n+};\n+\n+ExecNode* MakeFilterNode(ExecNode* input, std::string label, Expression filter) {\n+  return input->plan()->EmplaceNode<FilterNode>(input, std::move(label),\n+                                                std::move(filter));\n+}\n+\n+struct ProjectNode : ExecNode {\n+  ProjectNode(ExecNode* input, std::string label, std::vector<Expression> exprs)\n+      : ExecNode(input->plan(), std::move(label), {input}, {\"target\"},\n+                 /*output_descr=*/{input->output_descr()},\n+                 /*num_outputs=*/1),\n+        exprs_(std::move(exprs)) {}\n+\n+  const char* kind_name() override { return \"ProjectNode\"; }\n+\n+  Result<ExecBatch> DoProject(const ExecBatch& target) {\n+    // XXX get a non-default exec context\n+    std::vector<Datum> values{exprs_.size()};\n+    for (size_t i = 0; i < exprs_.size(); ++i) {\n+      ARROW_ASSIGN_OR_RAISE(Expression simplified_expr,\n+                            SimplifyWithGuarantee(exprs_[i], target.guarantee));\n+\n+      ARROW_ASSIGN_OR_RAISE(values[i], ExecuteScalarExpression(simplified_expr, target));\n+    }\n+    return ExecBatch::Make(std::move(values));\n+  }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+\n+    auto maybe_projected = DoProject(std::move(batch));\n+    if (!maybe_projected.ok()) {\n+      outputs_[0]->ErrorReceived(this, maybe_projected.status());\n+      inputs_[0]->StopProducing(this);\n+      return;\n+    }\n+\n+    maybe_projected->guarantee = batch.guarantee;\n+    outputs_[0]->InputReceived(this, seq, maybe_projected.MoveValueUnsafe());\n+  }\n+\n+  void ErrorReceived(ExecNode* input, Status error) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->ErrorReceived(this, std::move(error));\n+    inputs_[0]->StopProducing(this);\n+  }\n+\n+  void InputFinished(ExecNode* input, int seq) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->InputFinished(this, seq);\n+    inputs_[0]->StopProducing(this);\n+  }\n+\n+  Status StartProducing() override {\n+    // XXX validate inputs_[0]->output_descr() against filter_\n+    return Status::OK();\n+  }\n+\n+  void PauseProducing(ExecNode* output) override {}\n+\n+  void ResumeProducing(ExecNode* output) override {}\n+\n+  void StopProducing(ExecNode* output) override {\n+    DCHECK_EQ(output, outputs_[0]);\n+    inputs_[0]->StopProducing(this);\n+  }\n+\n+  void StopProducing() override { StopProducing(outputs_[0]); }\n+\n+ private:\n+  std::vector<Expression> exprs_;\n+};\n+\n+ExecNode* MakeProjectNode(ExecNode* input, std::string label,\n+                          std::vector<Expression> exprs) {\n+  return input->plan()->EmplaceNode<ProjectNode>(input, std::move(label),\n+                                                 std::move(exprs));\n+}\n+\n+struct SinkNode : ExecNode {\n+  SinkNode(ExecNode* input, std::string label,\n+           AsyncGenerator<util::optional<ExecBatch>>* generator)\n+      : ExecNode(input->plan(), std::move(label), {input}, {\"collected\"}, {},\n+                 /*num_outputs=*/0),\n+        producer_(MakeProducer(generator)) {}\n+\n+  static PushGenerator<util::optional<ExecBatch>>::Producer MakeProducer(\n+      AsyncGenerator<util::optional<ExecBatch>>* out_gen) {\n+    PushGenerator<util::optional<ExecBatch>> gen;\n+    auto out = gen.producer();\n+    *out_gen = std::move(gen);\n+    return out;\n+  }\n+\n+  const char* kind_name() override { return \"SinkNode\"; }\n+\n+  Status StartProducing() override { return Status::OK(); }\n+\n+  // sink nodes have no outputs from which to feel backpressure\n+  static void NoOutputs() { DCHECK(false) << \"no outputs; this should never be called\"; }\n+  void ResumeProducing(ExecNode* output) override { NoOutputs(); }\n+  void PauseProducing(ExecNode* output) override { NoOutputs(); }\n+  void StopProducing(ExecNode* output) override { NoOutputs(); }\n+\n+  void StopProducing() override {\n+    std::unique_lock<std::mutex> lock(mutex_);\n+    StopProducingUnlocked();\n+  }\n+\n+  void InputReceived(ExecNode* input, int seq_num, ExecBatch exec_batch) override {\n+    std::unique_lock<std::mutex> lock(mutex_);\n+    if (stopped_) return;\n+\n+    // TODO would be nice to factor this out in a ReorderQueue\n+    if (seq_num <= static_cast<int>(received_batches_.size())) {\n+      received_batches_.resize(seq_num + 1);\n+      emitted_.resize(seq_num + 1, false);\n+    }\n+    received_batches_[seq_num] = std::move(exec_batch);\n+    ++num_received_;\n+\n+    if (seq_num != num_emitted_) {\n+      // Cannot emit yet as there is a hole at `num_emitted_`\n+      DCHECK_GT(seq_num, num_emitted_);\n+      return;\n+    }\n+\n+    if (num_received_ == emit_stop_) {\n+      StopProducingUnlocked();\n+    }\n+\n+    // Emit batches in order as far as possible\n+    // First collect these batches, then unlock before producing.\n+    const auto seq_start = seq_num;\n+    while (seq_num < static_cast<int>(emitted_.size()) && !emitted_[seq_num]) {\n+      emitted_[seq_num] = true;\n+      ++seq_num;\n+    }\n+    DCHECK_GT(seq_num, seq_start);\n+    // By moving the values now, we make sure another thread won't emit the same values\n+    // below\n+    std::vector<ExecBatch> to_emit(\n+        std::make_move_iterator(received_batches_.begin() + seq_start),\n+        std::make_move_iterator(received_batches_.begin() + seq_num));\n+\n+    lock.unlock();\n+    for (auto&& batch : to_emit) {\n+      producer_.Push(std::move(batch));\n+    }\n+    lock.lock();\n+\n+    DCHECK_EQ(seq_start, num_emitted_);  // num_emitted_ wasn't bumped in the meantime\n+    num_emitted_ = seq_num;\n\nReview comment:\n       Why not just put this inside the lock? Also, if one thread were to run everything up to here, unlock the lock, and get unscheduled before the assignment, a subsequent call could feasibly update num_emitted_ before the first thread gets scheduled again.\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression.cc\n##########\n@@ -492,9 +448,18 @@ Result<Expression> Expression::Bind(ValueDescr in,\n   if (literal()) return *this;\n \n   if (auto ref = field_ref()) {\n-    ARROW_ASSIGN_OR_RAISE(auto field, ref->GetOneOrNone(*in.type));\n-    auto descr = field ? ValueDescr{field->type(), in.shape} : ValueDescr::Scalar(null());\n-    return Expression{Parameter{*ref, std::move(descr)}};\n+    if (ref->IsNested()) {\n+      return Status::NotImplemented(\"nested field references\");\n+    }\n+\n+    ARROW_ASSIGN_OR_RAISE(auto path, ref->FindOne(*in.type));\n\nReview comment:\n       Is the change to using indices meant to be an optimization (for the wide schema case)?\r\n   \r\n   This will still be quadratic but at least binding happens only once.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-27T17:51:40.581+0000",
                    "updated": "2021-05-27T17:51:40.581+0000",
                    "started": "2021-05-27T17:51:40.581+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "603195",
                    "issueId": "13363668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13363668/worklog/603220",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10397:\nURL: https://github.com/apache/arrow/pull/10397#discussion_r640897501\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression.cc\n##########\n@@ -492,9 +448,18 @@ Result<Expression> Expression::Bind(ValueDescr in,\n   if (literal()) return *this;\n \n   if (auto ref = field_ref()) {\n-    ARROW_ASSIGN_OR_RAISE(auto field, ref->GetOneOrNone(*in.type));\n-    auto descr = field ? ValueDescr{field->type(), in.shape} : ValueDescr::Scalar(null());\n-    return Expression{Parameter{*ref, std::move(descr)}};\n+    if (ref->IsNested()) {\n+      return Status::NotImplemented(\"nested field references\");\n+    }\n+\n+    ARROW_ASSIGN_OR_RAISE(auto path, ref->FindOne(*in.type));\n\nReview comment:\n       Extracting indices is necessitated by working with ExecBatches, which don't have named fields (so by-name lookup can't work). What quadratic behavior do you see?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-27T19:11:15.432+0000",
                    "updated": "2021-05-27T19:11:15.432+0000",
                    "started": "2021-05-27T19:11:15.432+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "603220",
                    "issueId": "13363668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13363668/worklog/603221",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10397:\nURL: https://github.com/apache/arrow/pull/10397#discussion_r640897940\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression.h\n##########\n@@ -64,8 +64,11 @@ class ARROW_EXPORT Expression {\n   /// Bind this expression to the given input type, looking up Kernels and field types.\n   /// Some expression simplification may be performed and implicit casts will be inserted.\n   /// Any state necessary for execution will be initialized and returned.\n-  Result<Expression> Bind(ValueDescr in, compute::ExecContext* = NULLPTR) const;\n-  Result<Expression> Bind(const Schema& in_schema, compute::ExecContext* = NULLPTR) const;\n+  Result<Expression> Bind(ValueDescr in, ExecContext* = NULLPTR) const;\n+  Result<Expression> Bind(const Schema& in_schema, ExecContext* = NULLPTR) const;\n+\n+  Result<Expression> BindFlattened(ValueDescr in, ExecContext* = NULLPTR) const;\n\nReview comment:\n       No, this should be removed.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-27T19:12:00.014+0000",
                    "updated": "2021-05-27T19:12:00.014+0000",
                    "started": "2021-05-27T19:12:00.014+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "603221",
                    "issueId": "13363668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13363668/worklog/603223",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10397:\nURL: https://github.com/apache/arrow/pull/10397#discussion_r640899835\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression.cc\n##########\n@@ -492,9 +448,18 @@ Result<Expression> Expression::Bind(ValueDescr in,\n   if (literal()) return *this;\n \n   if (auto ref = field_ref()) {\n-    ARROW_ASSIGN_OR_RAISE(auto field, ref->GetOneOrNone(*in.type));\n-    auto descr = field ? ValueDescr{field->type(), in.shape} : ValueDescr::Scalar(null());\n-    return Expression{Parameter{*ref, std::move(descr)}};\n+    if (ref->IsNested()) {\n+      return Status::NotImplemented(\"nested field references\");\n+    }\n+\n+    ARROW_ASSIGN_OR_RAISE(auto path, ref->FindOne(*in.type));\n\nReview comment:\n       Ah, I see: FindOne is currently linear in the number of fields. That could/should be fixed\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-27T19:15:06.825+0000",
                    "updated": "2021-05-27T19:15:06.825+0000",
                    "started": "2021-05-27T19:15:06.824+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "603223",
                    "issueId": "13363668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13363668/worklog/603224",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10397:\nURL: https://github.com/apache/arrow/pull/10397#discussion_r640905731\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression.cc\n##########\n@@ -492,9 +448,18 @@ Result<Expression> Expression::Bind(ValueDescr in,\n   if (literal()) return *this;\n \n   if (auto ref = field_ref()) {\n-    ARROW_ASSIGN_OR_RAISE(auto field, ref->GetOneOrNone(*in.type));\n-    auto descr = field ? ValueDescr{field->type(), in.shape} : ValueDescr::Scalar(null());\n-    return Expression{Parameter{*ref, std::move(descr)}};\n+    if (ref->IsNested()) {\n+      return Status::NotImplemented(\"nested field references\");\n+    }\n+\n+    ARROW_ASSIGN_OR_RAISE(auto path, ref->FindOne(*in.type));\n\nReview comment:\n       Yeah, when I was digging into the wide-dataframe performance regression, it boiled almost entirely down to us doing a linear field lookup for every field, for every batch (ARROW-11469)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-27T19:25:03.325+0000",
                    "updated": "2021-05-27T19:25:03.325+0000",
                    "started": "2021-05-27T19:25:03.325+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "603224",
                    "issueId": "13363668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13363668/worklog/603225",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10397:\nURL: https://github.com/apache/arrow/pull/10397#discussion_r640907832\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/exec_plan.cc\n##########\n@@ -170,48 +165,409 @@ Status ExecPlan::Validate() { return ToDerived(this)->Validate(); }\n \n Status ExecPlan::StartProducing() { return ToDerived(this)->StartProducing(); }\n \n-ExecNode::ExecNode(ExecPlan* plan, std::string label,\n-                   std::vector<BatchDescr> input_descrs,\n+ExecNode::ExecNode(ExecPlan* plan, std::string label, NodeVector inputs,\n                    std::vector<std::string> input_labels, BatchDescr output_descr,\n                    int num_outputs)\n     : plan_(plan),\n       label_(std::move(label)),\n-      input_descrs_(std::move(input_descrs)),\n+      inputs_(std::move(inputs)),\n       input_labels_(std::move(input_labels)),\n       output_descr_(std::move(output_descr)),\n-      num_outputs_(num_outputs) {}\n+      num_outputs_(num_outputs) {\n+  for (auto input : inputs_) {\n+    input->outputs_.push_back(this);\n+  }\n+}\n \n Status ExecNode::Validate() const {\n-  if (inputs_.size() != input_descrs_.size()) {\n+  if (inputs_.size() != input_labels_.size()) {\n     return Status::Invalid(\"Invalid number of inputs for '\", label(), \"' (expected \",\n-                           num_inputs(), \", actual \", inputs_.size(), \")\");\n+                           num_inputs(), \", actual \", input_labels_.size(), \")\");\n   }\n \n   if (static_cast<int>(outputs_.size()) != num_outputs_) {\n     return Status::Invalid(\"Invalid number of outputs for '\", label(), \"' (expected \",\n                            num_outputs(), \", actual \", outputs_.size(), \")\");\n   }\n \n-  DCHECK_EQ(input_descrs_.size(), input_labels_.size());\n-\n   for (auto out : outputs_) {\n     auto input_index = GetNodeIndex(out->inputs(), this);\n     if (!input_index) {\n       return Status::Invalid(\"Node '\", label(), \"' outputs to node '\", out->label(),\n                              \"' but is not listed as an input.\");\n     }\n+  }\n \n-    const auto& in_descr = out->input_descrs_[*input_index];\n-    if (in_descr != output_descr_) {\n-      return Status::Invalid(\n-          \"Node '\", label(), \"' (bound to input \", input_labels_[*input_index],\n-          \") produces batches with type '\", ValueDescr::ToString(output_descr_),\n-          \"' inconsistent with consumer '\", out->label(), \"' which accepts '\",\n-          ValueDescr::ToString(in_descr), \"'\");\n+  return Status::OK();\n+}\n+\n+struct SourceNode : ExecNode {\n+  SourceNode(ExecPlan* plan, std::string label, ExecNode::BatchDescr output_descr,\n+             AsyncGenerator<util::optional<ExecBatch>> generator)\n+      : ExecNode(plan, std::move(label), {}, {}, std::move(output_descr),\n+                 /*num_outputs=*/1),\n+        generator_(std::move(generator)) {}\n+\n+  const char* kind_name() override { return \"SourceNode\"; }\n+\n+  static void NoInputs() { DCHECK(false) << \"no inputs; this should never be called\"; }\n+  void InputReceived(ExecNode*, int, ExecBatch) override { NoInputs(); }\n+  void ErrorReceived(ExecNode*, Status) override { NoInputs(); }\n+  void InputFinished(ExecNode*, int) override { NoInputs(); }\n+\n+  Status StartProducing() override {\n+    if (finished_) {\n+      return Status::Invalid(\"Restarted SourceNode '\", label(), \"'\");\n     }\n+\n+    auto gen = std::move(generator_);\n+\n+    /// XXX should we wait on this future anywhere? In StopProducing() maybe?\n+    auto done_fut =\n+        Loop([gen, this] {\n+          std::unique_lock<std::mutex> lock(mutex_);\n+          int seq = next_batch_index_++;\n+          if (finished_) {\n+            return Future<ControlFlow<int>>::MakeFinished(Break(seq));\n+          }\n+          lock.unlock();\n+\n+          return gen().Then(\n+              [=](const util::optional<ExecBatch>& batch) -> ControlFlow<int> {\n+                std::unique_lock<std::mutex> lock(mutex_);\n+                if (!batch || finished_) {\n+                  finished_ = true;\n+                  return Break(seq);\n+                }\n+                lock.unlock();\n+\n+                outputs_[0]->InputReceived(this, seq, *batch);\n+                return Continue();\n+              },\n+              [=](const Status& error) -> ControlFlow<int> {\n+                std::unique_lock<std::mutex> lock(mutex_);\n+                if (!finished_) {\n+                  finished_ = true;\n+                  lock.unlock();\n+                  // unless we were already finished, push the error to our output\n+                  // XXX is this correct? Is it reasonable for a consumer to ignore errors\n+                  // from a finished producer?\n\nReview comment:\n       I'd agree that handling/ignoring trailing batches is necessary; the producer may take a while to stop. However I wonder if it's reasonable to do the same for trailing errors. For example: let's say we have a plan where a LimitNode is taking the first 99 rows from EmitsErrorAfterHundredthRowNode. There's a race condition here (also depends on chunking) because the LimitNode will sometimes receive the trailing error before it can stop the producer and sometimes  will succeed in stopping its producer before it gets around to raising an error. I'm not sure what the correct answer here is, but I lean toward: if any node emits any error, that always puts all subsequent nodes into an error state too (unless explicitly intercepted). The above example seems like a problem we need to fix in EmitsErrorAfterHundredthRowNode rather than requiring all consumers to ignore post-stop errors\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-27T19:28:38.175+0000",
                    "updated": "2021-05-27T19:28:38.175+0000",
                    "started": "2021-05-27T19:28:38.175+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "603225",
                    "issueId": "13363668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13363668/worklog/603226",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10397:\nURL: https://github.com/apache/arrow/pull/10397#discussion_r640908529\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/exec_plan.cc\n##########\n@@ -170,48 +165,409 @@ Status ExecPlan::Validate() { return ToDerived(this)->Validate(); }\n \n Status ExecPlan::StartProducing() { return ToDerived(this)->StartProducing(); }\n \n-ExecNode::ExecNode(ExecPlan* plan, std::string label,\n-                   std::vector<BatchDescr> input_descrs,\n+ExecNode::ExecNode(ExecPlan* plan, std::string label, NodeVector inputs,\n                    std::vector<std::string> input_labels, BatchDescr output_descr,\n                    int num_outputs)\n     : plan_(plan),\n       label_(std::move(label)),\n-      input_descrs_(std::move(input_descrs)),\n+      inputs_(std::move(inputs)),\n       input_labels_(std::move(input_labels)),\n       output_descr_(std::move(output_descr)),\n-      num_outputs_(num_outputs) {}\n+      num_outputs_(num_outputs) {\n+  for (auto input : inputs_) {\n+    input->outputs_.push_back(this);\n+  }\n+}\n \n Status ExecNode::Validate() const {\n-  if (inputs_.size() != input_descrs_.size()) {\n+  if (inputs_.size() != input_labels_.size()) {\n     return Status::Invalid(\"Invalid number of inputs for '\", label(), \"' (expected \",\n-                           num_inputs(), \", actual \", inputs_.size(), \")\");\n+                           num_inputs(), \", actual \", input_labels_.size(), \")\");\n   }\n \n   if (static_cast<int>(outputs_.size()) != num_outputs_) {\n     return Status::Invalid(\"Invalid number of outputs for '\", label(), \"' (expected \",\n                            num_outputs(), \", actual \", outputs_.size(), \")\");\n   }\n \n-  DCHECK_EQ(input_descrs_.size(), input_labels_.size());\n-\n   for (auto out : outputs_) {\n     auto input_index = GetNodeIndex(out->inputs(), this);\n     if (!input_index) {\n       return Status::Invalid(\"Node '\", label(), \"' outputs to node '\", out->label(),\n                              \"' but is not listed as an input.\");\n     }\n+  }\n \n-    const auto& in_descr = out->input_descrs_[*input_index];\n-    if (in_descr != output_descr_) {\n-      return Status::Invalid(\n-          \"Node '\", label(), \"' (bound to input \", input_labels_[*input_index],\n-          \") produces batches with type '\", ValueDescr::ToString(output_descr_),\n-          \"' inconsistent with consumer '\", out->label(), \"' which accepts '\",\n-          ValueDescr::ToString(in_descr), \"'\");\n+  return Status::OK();\n+}\n+\n+struct SourceNode : ExecNode {\n+  SourceNode(ExecPlan* plan, std::string label, ExecNode::BatchDescr output_descr,\n+             AsyncGenerator<util::optional<ExecBatch>> generator)\n+      : ExecNode(plan, std::move(label), {}, {}, std::move(output_descr),\n+                 /*num_outputs=*/1),\n+        generator_(std::move(generator)) {}\n+\n+  const char* kind_name() override { return \"SourceNode\"; }\n+\n+  static void NoInputs() { DCHECK(false) << \"no inputs; this should never be called\"; }\n+  void InputReceived(ExecNode*, int, ExecBatch) override { NoInputs(); }\n+  void ErrorReceived(ExecNode*, Status) override { NoInputs(); }\n+  void InputFinished(ExecNode*, int) override { NoInputs(); }\n+\n+  Status StartProducing() override {\n+    if (finished_) {\n+      return Status::Invalid(\"Restarted SourceNode '\", label(), \"'\");\n     }\n+\n+    auto gen = std::move(generator_);\n+\n+    /// XXX should we wait on this future anywhere? In StopProducing() maybe?\n+    auto done_fut =\n+        Loop([gen, this] {\n+          std::unique_lock<std::mutex> lock(mutex_);\n+          int seq = next_batch_index_++;\n+          if (finished_) {\n+            return Future<ControlFlow<int>>::MakeFinished(Break(seq));\n+          }\n+          lock.unlock();\n+\n+          return gen().Then(\n+              [=](const util::optional<ExecBatch>& batch) -> ControlFlow<int> {\n+                std::unique_lock<std::mutex> lock(mutex_);\n+                if (!batch || finished_) {\n+                  finished_ = true;\n+                  return Break(seq);\n+                }\n+                lock.unlock();\n+\n+                outputs_[0]->InputReceived(this, seq, *batch);\n+                return Continue();\n+              },\n+              [=](const Status& error) -> ControlFlow<int> {\n+                std::unique_lock<std::mutex> lock(mutex_);\n+                if (!finished_) {\n+                  finished_ = true;\n+                  lock.unlock();\n+                  // unless we were already finished, push the error to our output\n+                  // XXX is this correct? Is it reasonable for a consumer to ignore errors\n+                  // from a finished producer?\n+                  outputs_[0]->ErrorReceived(this, error);\n+                }\n+                return Break(seq);\n+              });\n+        }).Then([&](int seq) {\n+          /// XXX this is probably redundant: do we always call InputFinished after\n+          /// ErrorReceived or will ErrorRecieved be sufficient?\n+          outputs_[0]->InputFinished(this, seq);\n+        });\n+\n+    return Status::OK();\n   }\n \n-  return Status::OK();\n+  void PauseProducing(ExecNode* output) override {}\n+\n+  void ResumeProducing(ExecNode* output) override {}\n+\n+  void StopProducing(ExecNode* output) override {\n+    DCHECK_EQ(output, outputs_[0]);\n+    std::unique_lock<std::mutex> lock(mutex_);\n+    finished_ = true;\n+  }\n+\n+  void StopProducing() override { StopProducing(outputs_[0]); }\n+\n+ private:\n+  std::mutex mutex_;\n+  bool finished_{false};\n+  int next_batch_index_{0};\n+  AsyncGenerator<util::optional<ExecBatch>> generator_;\n+};\n+\n+ExecNode* MakeSourceNode(ExecPlan* plan, std::string label,\n+                         ExecNode::BatchDescr output_descr,\n+                         AsyncGenerator<util::optional<ExecBatch>> generator) {\n+  return plan->EmplaceNode<SourceNode>(plan, std::move(label), std::move(output_descr),\n+                                       std::move(generator));\n+}\n+\n+struct FilterNode : ExecNode {\n+  FilterNode(ExecNode* input, std::string label, Expression filter)\n+      : ExecNode(input->plan(), std::move(label), {input}, {\"target\"},\n+                 /*output_descr=*/{input->output_descr()},\n+                 /*num_outputs=*/1),\n+        filter_(std::move(filter)) {}\n+\n+  const char* kind_name() override { return \"FilterNode\"; }\n+\n+  Result<ExecBatch> DoFilter(const ExecBatch& target) {\n+    ARROW_ASSIGN_OR_RAISE(Expression simplified_filter,\n+                          SimplifyWithGuarantee(filter_, target.guarantee));\n+\n+    // XXX get a non-default exec context\n+    ARROW_ASSIGN_OR_RAISE(Datum mask, ExecuteScalarExpression(simplified_filter, target));\n+\n+    if (mask.is_scalar()) {\n+      const auto& mask_scalar = mask.scalar_as<BooleanScalar>();\n+      if (mask_scalar.is_valid && mask_scalar.value) {\n+        return target;\n+      }\n+\n+      return target.Slice(0, 0);\n+    }\n+\n+    auto values = target.values;\n+    for (auto& value : values) {\n+      if (value.is_scalar()) continue;\n+      ARROW_ASSIGN_OR_RAISE(value, Filter(value, mask, FilterOptions::Defaults()));\n+    }\n+    return ExecBatch::Make(std::move(values));\n+  }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+\n+    auto maybe_filtered = DoFilter(std::move(batch));\n+    if (!maybe_filtered.ok()) {\n+      outputs_[0]->ErrorReceived(this, maybe_filtered.status());\n+      inputs_[0]->StopProducing(this);\n+      return;\n+    }\n+\n+    maybe_filtered->guarantee = batch.guarantee;\n+    outputs_[0]->InputReceived(this, seq, maybe_filtered.MoveValueUnsafe());\n+  }\n+\n+  void ErrorReceived(ExecNode* input, Status error) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->ErrorReceived(this, std::move(error));\n+    inputs_[0]->StopProducing(this);\n+  }\n+\n+  void InputFinished(ExecNode* input, int seq) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->InputFinished(this, seq);\n+    inputs_[0]->StopProducing(this);\n+  }\n+\n+  Status StartProducing() override {\n+    // XXX validate inputs_[0]->output_descr() against filter_\n+    return Status::OK();\n+  }\n+\n+  void PauseProducing(ExecNode* output) override {}\n+\n+  void ResumeProducing(ExecNode* output) override {}\n+\n+  void StopProducing(ExecNode* output) override {\n+    DCHECK_EQ(output, outputs_[0]);\n+    inputs_[0]->StopProducing(this);\n+  }\n+\n+  void StopProducing() override { StopProducing(outputs_[0]); }\n+\n+ private:\n+  Expression filter_;\n+};\n+\n+ExecNode* MakeFilterNode(ExecNode* input, std::string label, Expression filter) {\n+  return input->plan()->EmplaceNode<FilterNode>(input, std::move(label),\n+                                                std::move(filter));\n+}\n+\n+struct ProjectNode : ExecNode {\n+  ProjectNode(ExecNode* input, std::string label, std::vector<Expression> exprs)\n+      : ExecNode(input->plan(), std::move(label), {input}, {\"target\"},\n+                 /*output_descr=*/{input->output_descr()},\n+                 /*num_outputs=*/1),\n+        exprs_(std::move(exprs)) {}\n+\n+  const char* kind_name() override { return \"ProjectNode\"; }\n+\n+  Result<ExecBatch> DoProject(const ExecBatch& target) {\n+    // XXX get a non-default exec context\n+    std::vector<Datum> values{exprs_.size()};\n+    for (size_t i = 0; i < exprs_.size(); ++i) {\n+      ARROW_ASSIGN_OR_RAISE(Expression simplified_expr,\n+                            SimplifyWithGuarantee(exprs_[i], target.guarantee));\n+\n+      ARROW_ASSIGN_OR_RAISE(values[i], ExecuteScalarExpression(simplified_expr, target));\n+    }\n+    return ExecBatch::Make(std::move(values));\n+  }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+\n+    auto maybe_projected = DoProject(std::move(batch));\n+    if (!maybe_projected.ok()) {\n+      outputs_[0]->ErrorReceived(this, maybe_projected.status());\n+      inputs_[0]->StopProducing(this);\n+      return;\n+    }\n+\n+    maybe_projected->guarantee = batch.guarantee;\n+    outputs_[0]->InputReceived(this, seq, maybe_projected.MoveValueUnsafe());\n+  }\n+\n+  void ErrorReceived(ExecNode* input, Status error) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->ErrorReceived(this, std::move(error));\n+    inputs_[0]->StopProducing(this);\n+  }\n+\n+  void InputFinished(ExecNode* input, int seq) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->InputFinished(this, seq);\n+    inputs_[0]->StopProducing(this);\n+  }\n+\n+  Status StartProducing() override {\n+    // XXX validate inputs_[0]->output_descr() against filter_\n+    return Status::OK();\n+  }\n+\n+  void PauseProducing(ExecNode* output) override {}\n+\n+  void ResumeProducing(ExecNode* output) override {}\n+\n+  void StopProducing(ExecNode* output) override {\n+    DCHECK_EQ(output, outputs_[0]);\n+    inputs_[0]->StopProducing(this);\n+  }\n+\n+  void StopProducing() override { StopProducing(outputs_[0]); }\n+\n+ private:\n+  std::vector<Expression> exprs_;\n+};\n+\n+ExecNode* MakeProjectNode(ExecNode* input, std::string label,\n+                          std::vector<Expression> exprs) {\n+  return input->plan()->EmplaceNode<ProjectNode>(input, std::move(label),\n+                                                 std::move(exprs));\n+}\n+\n+struct SinkNode : ExecNode {\n+  SinkNode(ExecNode* input, std::string label,\n+           AsyncGenerator<util::optional<ExecBatch>>* generator)\n+      : ExecNode(input->plan(), std::move(label), {input}, {\"collected\"}, {},\n+                 /*num_outputs=*/0),\n+        producer_(MakeProducer(generator)) {}\n+\n+  static PushGenerator<util::optional<ExecBatch>>::Producer MakeProducer(\n+      AsyncGenerator<util::optional<ExecBatch>>* out_gen) {\n+    PushGenerator<util::optional<ExecBatch>> gen;\n+    auto out = gen.producer();\n+    *out_gen = std::move(gen);\n+    return out;\n+  }\n+\n+  const char* kind_name() override { return \"SinkNode\"; }\n+\n+  Status StartProducing() override { return Status::OK(); }\n+\n+  // sink nodes have no outputs from which to feel backpressure\n+  static void NoOutputs() { DCHECK(false) << \"no outputs; this should never be called\"; }\n+  void ResumeProducing(ExecNode* output) override { NoOutputs(); }\n+  void PauseProducing(ExecNode* output) override { NoOutputs(); }\n+  void StopProducing(ExecNode* output) override { NoOutputs(); }\n+\n+  void StopProducing() override {\n+    std::unique_lock<std::mutex> lock(mutex_);\n+    StopProducingUnlocked();\n+  }\n+\n+  void InputReceived(ExecNode* input, int seq_num, ExecBatch exec_batch) override {\n+    std::unique_lock<std::mutex> lock(mutex_);\n+    if (stopped_) return;\n+\n+    // TODO would be nice to factor this out in a ReorderQueue\n+    if (seq_num <= static_cast<int>(received_batches_.size())) {\n+      received_batches_.resize(seq_num + 1);\n+      emitted_.resize(seq_num + 1, false);\n+    }\n+    received_batches_[seq_num] = std::move(exec_batch);\n+    ++num_received_;\n+\n+    if (seq_num != num_emitted_) {\n+      // Cannot emit yet as there is a hole at `num_emitted_`\n+      DCHECK_GT(seq_num, num_emitted_);\n+      return;\n+    }\n+\n+    if (num_received_ == emit_stop_) {\n+      StopProducingUnlocked();\n+    }\n+\n+    // Emit batches in order as far as possible\n+    // First collect these batches, then unlock before producing.\n+    const auto seq_start = seq_num;\n+    while (seq_num < static_cast<int>(emitted_.size()) && !emitted_[seq_num]) {\n+      emitted_[seq_num] = true;\n+      ++seq_num;\n+    }\n+    DCHECK_GT(seq_num, seq_start);\n+    // By moving the values now, we make sure another thread won't emit the same values\n+    // below\n+    std::vector<ExecBatch> to_emit(\n+        std::make_move_iterator(received_batches_.begin() + seq_start),\n+        std::make_move_iterator(received_batches_.begin() + seq_num));\n+\n+    lock.unlock();\n+    for (auto&& batch : to_emit) {\n+      producer_.Push(std::move(batch));\n+    }\n+    lock.lock();\n+\n+    DCHECK_EQ(seq_start, num_emitted_);  // num_emitted_ wasn't bumped in the meantime\n+    num_emitted_ = seq_num;\n\nReview comment:\n       I'll rewrite this using SequencingGenerator\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-27T19:29:51.475+0000",
                    "updated": "2021-05-27T19:29:51.475+0000",
                    "started": "2021-05-27T19:29:51.475+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "603226",
                    "issueId": "13363668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13363668/worklog/603228",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10397:\nURL: https://github.com/apache/arrow/pull/10397#discussion_r640912315\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/exec_plan.cc\n##########\n@@ -170,48 +165,409 @@ Status ExecPlan::Validate() { return ToDerived(this)->Validate(); }\n \n Status ExecPlan::StartProducing() { return ToDerived(this)->StartProducing(); }\n \n-ExecNode::ExecNode(ExecPlan* plan, std::string label,\n-                   std::vector<BatchDescr> input_descrs,\n+ExecNode::ExecNode(ExecPlan* plan, std::string label, NodeVector inputs,\n                    std::vector<std::string> input_labels, BatchDescr output_descr,\n                    int num_outputs)\n     : plan_(plan),\n       label_(std::move(label)),\n-      input_descrs_(std::move(input_descrs)),\n+      inputs_(std::move(inputs)),\n       input_labels_(std::move(input_labels)),\n       output_descr_(std::move(output_descr)),\n-      num_outputs_(num_outputs) {}\n+      num_outputs_(num_outputs) {\n+  for (auto input : inputs_) {\n+    input->outputs_.push_back(this);\n+  }\n+}\n \n Status ExecNode::Validate() const {\n-  if (inputs_.size() != input_descrs_.size()) {\n+  if (inputs_.size() != input_labels_.size()) {\n     return Status::Invalid(\"Invalid number of inputs for '\", label(), \"' (expected \",\n-                           num_inputs(), \", actual \", inputs_.size(), \")\");\n+                           num_inputs(), \", actual \", input_labels_.size(), \")\");\n   }\n \n   if (static_cast<int>(outputs_.size()) != num_outputs_) {\n     return Status::Invalid(\"Invalid number of outputs for '\", label(), \"' (expected \",\n                            num_outputs(), \", actual \", outputs_.size(), \")\");\n   }\n \n-  DCHECK_EQ(input_descrs_.size(), input_labels_.size());\n-\n   for (auto out : outputs_) {\n     auto input_index = GetNodeIndex(out->inputs(), this);\n     if (!input_index) {\n       return Status::Invalid(\"Node '\", label(), \"' outputs to node '\", out->label(),\n                              \"' but is not listed as an input.\");\n     }\n+  }\n \n-    const auto& in_descr = out->input_descrs_[*input_index];\n-    if (in_descr != output_descr_) {\n-      return Status::Invalid(\n-          \"Node '\", label(), \"' (bound to input \", input_labels_[*input_index],\n-          \") produces batches with type '\", ValueDescr::ToString(output_descr_),\n-          \"' inconsistent with consumer '\", out->label(), \"' which accepts '\",\n-          ValueDescr::ToString(in_descr), \"'\");\n+  return Status::OK();\n+}\n+\n+struct SourceNode : ExecNode {\n+  SourceNode(ExecPlan* plan, std::string label, ExecNode::BatchDescr output_descr,\n+             AsyncGenerator<util::optional<ExecBatch>> generator)\n+      : ExecNode(plan, std::move(label), {}, {}, std::move(output_descr),\n+                 /*num_outputs=*/1),\n+        generator_(std::move(generator)) {}\n+\n+  const char* kind_name() override { return \"SourceNode\"; }\n+\n+  static void NoInputs() { DCHECK(false) << \"no inputs; this should never be called\"; }\n+  void InputReceived(ExecNode*, int, ExecBatch) override { NoInputs(); }\n+  void ErrorReceived(ExecNode*, Status) override { NoInputs(); }\n+  void InputFinished(ExecNode*, int) override { NoInputs(); }\n+\n+  Status StartProducing() override {\n+    if (finished_) {\n+      return Status::Invalid(\"Restarted SourceNode '\", label(), \"'\");\n     }\n+\n+    auto gen = std::move(generator_);\n+\n+    /// XXX should we wait on this future anywhere? In StopProducing() maybe?\n+    auto done_fut =\n+        Loop([gen, this] {\n+          std::unique_lock<std::mutex> lock(mutex_);\n+          int seq = next_batch_index_++;\n+          if (finished_) {\n+            return Future<ControlFlow<int>>::MakeFinished(Break(seq));\n+          }\n+          lock.unlock();\n+\n+          return gen().Then(\n+              [=](const util::optional<ExecBatch>& batch) -> ControlFlow<int> {\n+                std::unique_lock<std::mutex> lock(mutex_);\n+                if (!batch || finished_) {\n+                  finished_ = true;\n+                  return Break(seq);\n+                }\n+                lock.unlock();\n+\n+                outputs_[0]->InputReceived(this, seq, *batch);\n+                return Continue();\n+              },\n+              [=](const Status& error) -> ControlFlow<int> {\n+                std::unique_lock<std::mutex> lock(mutex_);\n+                if (!finished_) {\n+                  finished_ = true;\n+                  lock.unlock();\n+                  // unless we were already finished, push the error to our output\n+                  // XXX is this correct? Is it reasonable for a consumer to ignore errors\n+                  // from a finished producer?\n\nReview comment:\n       Ah, I see. I think I have the same inclination then; except for maybe a sink node that's already gotten all its results, in which case subsequent errors are probably irrelevant, propagating errors even when otherwise 'finished' makes sense.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-27T19:36:04.248+0000",
                    "updated": "2021-05-27T19:36:04.248+0000",
                    "started": "2021-05-27T19:36:04.248+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "603228",
                    "issueId": "13363668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13363668/worklog/603232",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10397:\nURL: https://github.com/apache/arrow/pull/10397#discussion_r640917034\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression.cc\n##########\n@@ -492,9 +448,18 @@ Result<Expression> Expression::Bind(ValueDescr in,\n   if (literal()) return *this;\n \n   if (auto ref = field_ref()) {\n-    ARROW_ASSIGN_OR_RAISE(auto field, ref->GetOneOrNone(*in.type));\n-    auto descr = field ? ValueDescr{field->type(), in.shape} : ValueDescr::Scalar(null());\n-    return Expression{Parameter{*ref, std::move(descr)}};\n+    if (ref->IsNested()) {\n+      return Status::NotImplemented(\"nested field references\");\n+    }\n+\n+    ARROW_ASSIGN_OR_RAISE(auto path, ref->FindOne(*in.type));\n\nReview comment:\n       For now, I've added a hot path for Schema since that already has a hash table from name -> index\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-27T19:44:28.385+0000",
                    "updated": "2021-05-27T19:44:28.385+0000",
                    "started": "2021-05-27T19:44:28.385+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "603232",
                    "issueId": "13363668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13363668/worklog/604750",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10397:\nURL: https://github.com/apache/arrow/pull/10397#discussion_r643353334\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/exec_plan.h\n##########\n@@ -225,22 +212,43 @@ class ARROW_EXPORT ExecNode {\n   virtual void StopProducing() = 0;\n \n  protected:\n-  ExecNode(ExecPlan* plan, std::string label, std::vector<BatchDescr> input_descrs,\n+  ExecNode(ExecPlan*, std::string label, NodeVector inputs,\n\nReview comment:\n       Nit: Seems odd to have no name for `ExecPlan` but then have a name for everything else.\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression.cc\n##########\n@@ -61,13 +61,22 @@ Expression call(std::string function, std::vector<Expression> arguments,\n   call.function_name = std::move(function);\n   call.arguments = std::move(arguments);\n   call.options = std::move(options);\n+\n+  call.hash = std::hash<std::string>{}(call.function_name);\n+  for (const auto& arg : call.arguments) {\n+    call.hash ^= arg.hash();\n+  }\n   return Expression(std::move(call));\n }\n \n const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n \n+const Expression::Parameter* Expression::parameter() const {\n\nReview comment:\n       Checking my knowledge.  A parameter is an index + an expected type?\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression.cc\n##########\n@@ -613,6 +639,22 @@ std::vector<FieldRef> FieldsInExpression(const Expression& expr) {\n   return fields;\n }\n \n+std::vector<int> ParametersInExpression(const Expression& expr) {\n\nReview comment:\n       It seems this could return duplicate indices (e.g. in something like `x < 5 && x > 0`).  Is that a problem?\n\n##########\nFile path: cpp/src/arrow/dataset/dataset_internal.h\n##########\n@@ -204,5 +204,35 @@ arrow::Result<std::shared_ptr<T>> GetFragmentScanOptions(\n   return internal::checked_pointer_cast<T>(source);\n }\n \n+class FragmentDataset : public Dataset {\n\nReview comment:\n       Should this be a base type of `InMemoryDataset`?\n\n##########\nFile path: cpp/src/arrow/compute/exec/test_util.cc\n##########\n@@ -124,277 +130,42 @@ struct DummyNode : ExecNode {\n   bool started_ = false;\n };\n \n-struct RecordBatchReaderNode : ExecNode {\n-  RecordBatchReaderNode(ExecPlan* plan, std::string label,\n-                        std::shared_ptr<RecordBatchReader> reader, Executor* io_executor)\n-      : ExecNode(plan, std::move(label), {}, {},\n-                 DescrFromSchemaColumns(*reader->schema()), /*num_outputs=*/1),\n-        schema_(reader->schema()),\n-        reader_(std::move(reader)),\n-        io_executor_(io_executor) {}\n-\n-  RecordBatchReaderNode(ExecPlan* plan, std::string label, std::shared_ptr<Schema> schema,\n-                        RecordBatchGenerator generator, Executor* io_executor)\n-      : ExecNode(plan, std::move(label), {}, {}, DescrFromSchemaColumns(*schema),\n-                 /*num_outputs=*/1),\n-        schema_(std::move(schema)),\n-        generator_(std::move(generator)),\n-        io_executor_(io_executor) {}\n-\n-  const char* kind_name() override { return \"RecordBatchReader\"; }\n-\n-  void InputReceived(ExecNode* input, int seq_num, compute::ExecBatch batch) override {}\n-\n-  void ErrorReceived(ExecNode* input, Status error) override {}\n-\n-  void InputFinished(ExecNode* input, int seq_stop) override {}\n-\n-  Status StartProducing() override {\n-    next_batch_index_ = 0;\n-    if (!generator_) {\n-      auto it = MakeIteratorFromReader(reader_);\n-      ARROW_ASSIGN_OR_RAISE(generator_,\n-                            MakeBackgroundGenerator(std::move(it), io_executor_));\n-    }\n-    GenerateOne(std::unique_lock<std::mutex>{mutex_});\n-    return Status::OK();\n-  }\n-\n-  void PauseProducing(ExecNode* output) override {}\n-\n-  void ResumeProducing(ExecNode* output) override {}\n-\n-  void StopProducing(ExecNode* output) override {\n-    ASSERT_EQ(output, outputs_[0]);\n-    std::unique_lock<std::mutex> lock(mutex_);\n-    generator_ = nullptr;  // null function\n-  }\n-\n-  void StopProducing() override { StopProducing(outputs_[0]); }\n-\n- private:\n-  void GenerateOne(std::unique_lock<std::mutex>&& lock) {\n-    if (!generator_) {\n-      // Stopped\n-      return;\n-    }\n-    auto plan = this->plan()->shared_from_this();\n-    auto fut = generator_();\n-    const auto batch_index = next_batch_index_++;\n-\n-    lock.unlock();\n-    // TODO we want to transfer always here\n-    io_executor_->Transfer(std::move(fut))\n-        .AddCallback(\n-            [plan, batch_index, this](const Result<std::shared_ptr<RecordBatch>>& res) {\n-              std::unique_lock<std::mutex> lock(mutex_);\n-              if (!res.ok()) {\n-                for (auto out : outputs_) {\n-                  out->ErrorReceived(this, res.status());\n-                }\n-                return;\n-              }\n-              const auto& batch = *res;\n-              if (IsIterationEnd(batch)) {\n-                lock.unlock();\n-                for (auto out : outputs_) {\n-                  out->InputFinished(this, batch_index);\n-                }\n-              } else {\n-                lock.unlock();\n-                for (auto out : outputs_) {\n-                  out->InputReceived(this, batch_index, compute::ExecBatch(*batch));\n-                }\n-                lock.lock();\n-                GenerateOne(std::move(lock));\n-              }\n-            });\n-  }\n-\n-  std::mutex mutex_;\n-  const std::shared_ptr<Schema> schema_;\n-  const std::shared_ptr<RecordBatchReader> reader_;\n-  RecordBatchGenerator generator_;\n-  int next_batch_index_;\n-\n-  Executor* const io_executor_;\n-};\n-\n-struct RecordBatchCollectNodeImpl : public RecordBatchCollectNode {\n-  RecordBatchCollectNodeImpl(ExecPlan* plan, std::string label,\n-                             std::shared_ptr<Schema> schema)\n-      : RecordBatchCollectNode(plan, std::move(label), {DescrFromSchemaColumns(*schema)},\n-                               {\"batches_to_collect\"}, {}, 0),\n-        schema_(std::move(schema)) {}\n-\n-  RecordBatchGenerator generator() override { return generator_; }\n-\n-  const char* kind_name() override { return \"RecordBatchReader\"; }\n-\n-  Status StartProducing() override {\n-    num_received_ = 0;\n-    num_emitted_ = 0;\n-    emit_stop_ = -1;\n-    stopped_ = false;\n-    producer_.emplace(generator_.producer());\n-    return Status::OK();\n-  }\n-\n-  // sink nodes have no outputs from which to feel backpressure\n-  void ResumeProducing(ExecNode* output) override {\n-    FAIL() << \"no outputs; this should never be called\";\n-  }\n-  void PauseProducing(ExecNode* output) override {\n-    FAIL() << \"no outputs; this should never be called\";\n-  }\n-  void StopProducing(ExecNode* output) override {\n-    FAIL() << \"no outputs; this should never be called\";\n-  }\n-\n-  void StopProducing() override {\n-    std::unique_lock<std::mutex> lock(mutex_);\n-    StopProducingUnlocked();\n-  }\n-\n-  void InputReceived(ExecNode* input, int seq_num,\n-                     compute::ExecBatch exec_batch) override {\n-    std::unique_lock<std::mutex> lock(mutex_);\n-    if (stopped_) {\n-      return;\n-    }\n-    auto maybe_batch = MakeBatch(std::move(exec_batch));\n-    if (!maybe_batch.ok()) {\n-      lock.unlock();\n-      producer_->Push(std::move(maybe_batch));\n-      return;\n-    }\n-\n-    // TODO would be nice to factor this out in a ReorderQueue\n-    auto batch = *std::move(maybe_batch);\n-    if (seq_num <= static_cast<int>(received_batches_.size())) {\n-      received_batches_.resize(seq_num + 1, nullptr);\n-    }\n-    DCHECK_EQ(received_batches_[seq_num], nullptr);\n-    received_batches_[seq_num] = std::move(batch);\n-    ++num_received_;\n-\n-    if (seq_num != num_emitted_) {\n-      // Cannot emit yet as there is a hole at `num_emitted_`\n-      DCHECK_GT(seq_num, num_emitted_);\n-      DCHECK_EQ(received_batches_[num_emitted_], nullptr);\n-      return;\n-    }\n-    if (num_received_ == emit_stop_) {\n-      StopProducingUnlocked();\n-    }\n-\n-    // Emit batches in order as far as possible\n-    // First collect these batches, then unlock before producing.\n-    const auto seq_start = seq_num;\n-    while (seq_num < static_cast<int>(received_batches_.size()) &&\n-           received_batches_[seq_num] != nullptr) {\n-      ++seq_num;\n-    }\n-    DCHECK_GT(seq_num, seq_start);\n-    // By moving the values now, we make sure another thread won't emit the same values\n-    // below\n-    RecordBatchVector to_emit(\n-        std::make_move_iterator(received_batches_.begin() + seq_start),\n-        std::make_move_iterator(received_batches_.begin() + seq_num));\n-\n-    lock.unlock();\n-    for (auto&& batch : to_emit) {\n-      producer_->Push(std::move(batch));\n-    }\n-    lock.lock();\n-\n-    DCHECK_EQ(seq_start, num_emitted_);  // num_emitted_ wasn't bumped in the meantime\n-    num_emitted_ = seq_num;\n-  }\n-\n-  void ErrorReceived(ExecNode* input, Status error) override {\n-    // XXX do we care about properly sequencing the error?\n-    producer_->Push(std::move(error));\n-    std::unique_lock<std::mutex> lock(mutex_);\n-    StopProducingUnlocked();\n-  }\n-\n-  void InputFinished(ExecNode* input, int seq_stop) override {\n-    std::unique_lock<std::mutex> lock(mutex_);\n-    DCHECK_GE(seq_stop, static_cast<int>(received_batches_.size()));\n-    received_batches_.reserve(seq_stop);\n-    emit_stop_ = seq_stop;\n-    if (emit_stop_ == num_received_) {\n-      DCHECK_EQ(emit_stop_, num_emitted_);\n-      StopProducingUnlocked();\n-    }\n-  }\n-\n- private:\n-  void StopProducingUnlocked() {\n-    if (!stopped_) {\n-      stopped_ = true;\n-      producer_->Close();\n-      inputs_[0]->StopProducing(this);\n-    }\n-  }\n-\n-  // TODO factor this out as ExecBatch::ToRecordBatch()?\n-  Result<std::shared_ptr<RecordBatch>> MakeBatch(compute::ExecBatch&& exec_batch) {\n-    ArrayDataVector columns;\n-    columns.reserve(exec_batch.values.size());\n-    for (auto&& value : exec_batch.values) {\n-      if (!value.is_array()) {\n-        return Status::TypeError(\"Expected array input\");\n-      }\n-      columns.push_back(std::move(value).array());\n-    }\n-    return RecordBatch::Make(schema_, exec_batch.length, std::move(columns));\n-  }\n-\n-  const std::shared_ptr<Schema> schema_;\n-\n-  std::mutex mutex_;\n-  RecordBatchVector received_batches_;\n-  int num_received_;\n-  int num_emitted_;\n-  int emit_stop_;\n-  bool stopped_;\n-\n-  PushGenerator<std::shared_ptr<RecordBatch>> generator_;\n-  util::optional<PushGenerator<std::shared_ptr<RecordBatch>>::Producer> producer_;\n-};\n+AsyncGenerator<util::optional<ExecBatch>> Wrap(RecordBatchGenerator gen,\n+                                               ::arrow::internal::Executor* io_executor) {\n+  return MakeMappedGenerator(\n+      MakeTransferredGenerator(std::move(gen), io_executor),\n+      [](const std::shared_ptr<RecordBatch>& batch) -> util::optional<ExecBatch> {\n+        return ExecBatch(*batch);\n+      });\n+}\n \n }  // namespace\n \n ExecNode* MakeRecordBatchReaderNode(ExecPlan* plan, std::string label,\n-                                    std::shared_ptr<RecordBatchReader> reader,\n-                                    Executor* io_executor) {\n-  return plan->EmplaceNode<RecordBatchReaderNode>(plan, std::move(label),\n-                                                  std::move(reader), io_executor);\n+                                    const std::shared_ptr<Schema>& schema,\n+                                    RecordBatchGenerator generator,\n+                                    ::arrow::internal::Executor* io_executor) {\n+  return MakeSourceNode(plan, std::move(label), DescrFromSchemaColumns(*schema),\n+                        Wrap(std::move(generator), io_executor));\n }\n \n ExecNode* MakeRecordBatchReaderNode(ExecPlan* plan, std::string label,\n-                                    std::shared_ptr<Schema> schema,\n-                                    RecordBatchGenerator generator,\n-                                    ::arrow::internal::Executor* io_executor) {\n-  return plan->EmplaceNode<RecordBatchReaderNode>(\n-      plan, std::move(label), std::move(schema), std::move(generator), io_executor);\n+                                    const std::shared_ptr<RecordBatchReader>& reader,\n+                                    Executor* io_executor) {\n+  auto gen =\n+      MakeBackgroundGenerator(MakeIteratorFromReader(reader), io_executor).ValueOrDie();\n\nReview comment:\n       Same question, why `io_executor`?\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression.cc\n##########\n@@ -510,7 +475,67 @@ Result<Expression> Expression::Bind(const Schema& in_schema,\n   return Bind(ValueDescr::Array(struct_(in_schema.fields())), exec_context);\n }\n \n-Result<Datum> ExecuteScalarExpression(const Expression& expr, const Datum& input,\n+Result<ExecBatch> MakeExecBatch(const Schema& full_schema, const Datum& partial) {\n+  ExecBatch out;\n+\n+  if (partial.kind() == Datum::RECORD_BATCH) {\n+    const auto& partial_batch = *partial.record_batch();\n+    out.length = partial_batch.num_rows();\n+\n+    for (const auto& field : full_schema.fields()) {\n+      ARROW_ASSIGN_OR_RAISE(auto column,\n+                            FieldRef(field->name()).GetOneOrNone(partial_batch));\n+\n+      if (column) {\n+        if (!column->type()->Equals(field->type())) {\n+          // Referenced field was present but didn't have the expected type.\n+          // This *should* be handled by readers, and will just be an error in the future.\n+          ARROW_ASSIGN_OR_RAISE(\n+              auto converted,\n+              compute::Cast(column, field->type(), compute::CastOptions::Safe()));\n+          column = converted.make_array();\n+        }\n+        out.values.emplace_back(std::move(column));\n+      } else {\n+        out.values.emplace_back(MakeNullScalar(field->type()));\n+      }\n+    }\n+    return out;\n+  }\n+\n+  // wasteful but useful for testing:\n+  if (partial.type()->id() == Type::STRUCT) {\n+    if (partial.is_array()) {\n+      ARROW_ASSIGN_OR_RAISE(auto partial_batch,\n+                            RecordBatch::FromStructArray(partial.make_array()));\n+\n+      return MakeExecBatch(full_schema, partial_batch);\n+    }\n+\n+    if (partial.is_scalar()) {\n+      ARROW_ASSIGN_OR_RAISE(auto partial_array,\n+                            MakeArrayFromScalar(*partial.scalar(), 1));\n+      ARROW_ASSIGN_OR_RAISE(auto out, MakeExecBatch(full_schema, partial_array));\n+\n+      for (Datum& value : out.values) {\n+        if (value.is_scalar()) continue;\n+        ARROW_ASSIGN_OR_RAISE(value, value.make_array()->GetScalar(0));\n+      }\n\nReview comment:\n       I'm not sure what is going on here (though that is likely my own problem).  If the value is a scalar record batch you want to end up with one each value being a scalar.  Can you not just grab the first item from each column of `partial_array`?  Why do you need to go back in and patch things up?\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression.cc\n##########\n@@ -510,7 +475,67 @@ Result<Expression> Expression::Bind(const Schema& in_schema,\n   return Bind(ValueDescr::Array(struct_(in_schema.fields())), exec_context);\n }\n \n-Result<Datum> ExecuteScalarExpression(const Expression& expr, const Datum& input,\n+Result<ExecBatch> MakeExecBatch(const Schema& full_schema, const Datum& partial) {\n+  ExecBatch out;\n+\n+  if (partial.kind() == Datum::RECORD_BATCH) {\n+    const auto& partial_batch = *partial.record_batch();\n+    out.length = partial_batch.num_rows();\n+\n+    for (const auto& field : full_schema.fields()) {\n+      ARROW_ASSIGN_OR_RAISE(auto column,\n+                            FieldRef(field->name()).GetOneOrNone(partial_batch));\n\nReview comment:\n       Will this fail if the column names are not unique?\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -258,43 +258,27 @@ class MappingGenerator {\n /// Note: Errors returned from the `map` function will be propagated\n ///\n /// If the source generator is async-reentrant then this generator will be also\n-template <typename T, typename V>\n-AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n-                                      std::function<Result<V>(const T&)> map) {\n-  std::function<Future<V>(const T&)> future_map = [map](const T& val) -> Future<V> {\n-    return Future<V>::MakeFinished(map(val));\n-  };\n-  return MappingGenerator<T, V>(std::move(source_generator), std::move(future_map));\n-}\n-template <typename T, typename V>\n-AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n-                                      std::function<V(const T&)> map) {\n-  std::function<Future<V>(const T&)> maybe_future_map = [map](const T& val) -> Future<V> {\n-    return Future<V>::MakeFinished(map(val));\n-  };\n-  return MappingGenerator<T, V>(std::move(source_generator), std::move(maybe_future_map));\n-}\n-template <typename T, typename V>\n-AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator,\n-                                      std::function<Future<V>(const T&)> map) {\n-  return MappingGenerator<T, V>(std::move(source_generator), std::move(map));\n-}\n-\n-template <typename V, typename T, typename MapFunc>\n-AsyncGenerator<V> MakeMappedGenerator(AsyncGenerator<T> source_generator, MapFunc map) {\n+template <typename T, typename MapFn,\n\nReview comment:\n       Thanks for figuring this out!\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression.h\n##########\n@@ -207,11 +218,22 @@ Result<Expression> SimplifyWithGuarantee(Expression,\n \n // Execution\n \n-/// Execute a scalar expression against the provided state and input Datum. This\n+/// Ensure that a RecordBatch (which may have missing or incorrectly ordered columns)\n\nReview comment:\n       This reads like an explanatory NB more than a description of what the function does.  Maybe...\r\n   \r\n   ```\r\n   Converts a RecordBatch to an ExecBatch\r\n   \r\n   Arrays will be reordered according to schema ordering.  Missing fields will be replaced with null scalars.  This is necessary when executing expressions since we look up fields by index.\r\n   ```\r\n   \r\n   Also, it feels a bit like a catch-22, though this is more of an observation than a complaint.  \"We need to change expressions to use indices so they will work on exec batches.\" and \"We need to convert record batches to exec batches because expressions work on indices.\"\r\n   \r\n   Maybe just remove the `This is necessary...` statement.  By this point the user is already making an exec batch so presumably they have a reason for it.\n\n##########\nFile path: cpp/src/arrow/compute/exec/exec_plan.h\n##########\n@@ -225,22 +212,43 @@ class ARROW_EXPORT ExecNode {\n   virtual void StopProducing() = 0;\n \n  protected:\n-  ExecNode(ExecPlan* plan, std::string label, std::vector<BatchDescr> input_descrs,\n+  ExecNode(ExecPlan*, std::string label, NodeVector inputs,\n            std::vector<std::string> input_labels, BatchDescr output_descr,\n            int num_outputs);\n \n   ExecPlan* plan_;\n-\n   std::string label_;\n \n-  std::vector<BatchDescr> input_descrs_;\n-  std::vector<std::string> input_labels_;\n   NodeVector inputs_;\n+  std::vector<std::string> input_labels_;\n \n   BatchDescr output_descr_;\n   int num_outputs_;\n   NodeVector outputs_;\n };\n \n+/// \\brief Adapt an AsyncGenerator<ExecBatch> as a source node\n+ARROW_EXPORT\n+ExecNode* MakeSourceNode(ExecPlan*, std::string label, ExecNode::BatchDescr output_descr,\n+                         AsyncGenerator<util::optional<ExecBatch>>);\n+\n+/// \\brief Add a sink node which forwards to an AsyncGenerator<ExecBatch>\n+ARROW_EXPORT\n+AsyncGenerator<util::optional<ExecBatch>> MakeSinkNode(ExecNode* input,\n+                                                       std::string label);\n+\n+/// \\brief Make a node which excludes some rows from batches passed through it\n+///\n+/// filter Expression must be bound; no field references will be looked up by name\n+ARROW_EXPORT\n+ExecNode* MakeFilterNode(ExecNode* input, std::string label, Expression filter);\n+\n+/// \\brief Make a node which executes expressions on input batches, producing new batches.\n+///\n+/// Expressions must be bound; no field references will be looked up by name\n+ARROW_EXPORT\n+ExecNode* MakeProjectNode(ExecNode* input, std::string label,\n\nReview comment:\n       I maybe understand from the meaning of `Project` what is going on here but if someone were not as familiar with the domain they might not.  It's not clear that the output will have one output column per expression.  From the description this sounds like it might be more of a generic \"map\" operation that maps input batch to output batch.\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression_test.cc\n##########\n@@ -165,6 +165,56 @@ TEST(ExpressionUtils, StripOrderPreservingCasts) {\n   Expect(cast(field_ref(\"i32\"), uint64()), no_change);\n }\n \n+TEST(ExpressionUtils, MakeExecBatch) {\n+  auto Expect = [](std::shared_ptr<RecordBatch> partial_batch) {\n+    SCOPED_TRACE(partial_batch->ToString());\n+    ASSERT_OK_AND_ASSIGN(auto batch, MakeExecBatch(*kBoringSchema, partial_batch));\n+\n+    ASSERT_EQ(batch.num_values(), kBoringSchema->num_fields());\n+    for (int i = 0; i < kBoringSchema->num_fields(); ++i) {\n+      const auto& field = *kBoringSchema->field(i);\n+\n+      SCOPED_TRACE(\"Field#\" + std::to_string(i) + \" \" + field.ToString());\n+\n+      EXPECT_TRUE(batch[i].type()->Equals(field.type()))\n+          << \"Incorrect type \" << batch[i].type()->ToString();\n+\n+      ASSERT_OK_AND_ASSIGN(auto col, FieldRef(field.name()).GetOneOrNone(*partial_batch));\n\nReview comment:\n       Why not `partial_batch->GetFieldByName(field.name())`?\n\n##########\nFile path: cpp/src/arrow/util/iterator.h\n##########\n@@ -66,6 +66,12 @@ bool IsIterationEnd(const T& val) {\n   return IterationTraits<T>::IsEnd(val);\n }\n \n+template <typename T>\n+bool IsIterationEnd(const Result<T>& maybe_val) {\n\nReview comment:\n       Where is this used?\n\n##########\nFile path: cpp/src/arrow/compute/exec/test_util.cc\n##########\n@@ -124,277 +130,42 @@ struct DummyNode : ExecNode {\n   bool started_ = false;\n };\n \n-struct RecordBatchReaderNode : ExecNode {\n-  RecordBatchReaderNode(ExecPlan* plan, std::string label,\n-                        std::shared_ptr<RecordBatchReader> reader, Executor* io_executor)\n-      : ExecNode(plan, std::move(label), {}, {},\n-                 DescrFromSchemaColumns(*reader->schema()), /*num_outputs=*/1),\n-        schema_(reader->schema()),\n-        reader_(std::move(reader)),\n-        io_executor_(io_executor) {}\n-\n-  RecordBatchReaderNode(ExecPlan* plan, std::string label, std::shared_ptr<Schema> schema,\n-                        RecordBatchGenerator generator, Executor* io_executor)\n-      : ExecNode(plan, std::move(label), {}, {}, DescrFromSchemaColumns(*schema),\n-                 /*num_outputs=*/1),\n-        schema_(std::move(schema)),\n-        generator_(std::move(generator)),\n-        io_executor_(io_executor) {}\n-\n-  const char* kind_name() override { return \"RecordBatchReader\"; }\n-\n-  void InputReceived(ExecNode* input, int seq_num, compute::ExecBatch batch) override {}\n-\n-  void ErrorReceived(ExecNode* input, Status error) override {}\n-\n-  void InputFinished(ExecNode* input, int seq_stop) override {}\n-\n-  Status StartProducing() override {\n-    next_batch_index_ = 0;\n-    if (!generator_) {\n-      auto it = MakeIteratorFromReader(reader_);\n-      ARROW_ASSIGN_OR_RAISE(generator_,\n-                            MakeBackgroundGenerator(std::move(it), io_executor_));\n-    }\n-    GenerateOne(std::unique_lock<std::mutex>{mutex_});\n-    return Status::OK();\n-  }\n-\n-  void PauseProducing(ExecNode* output) override {}\n-\n-  void ResumeProducing(ExecNode* output) override {}\n-\n-  void StopProducing(ExecNode* output) override {\n-    ASSERT_EQ(output, outputs_[0]);\n-    std::unique_lock<std::mutex> lock(mutex_);\n-    generator_ = nullptr;  // null function\n-  }\n-\n-  void StopProducing() override { StopProducing(outputs_[0]); }\n-\n- private:\n-  void GenerateOne(std::unique_lock<std::mutex>&& lock) {\n-    if (!generator_) {\n-      // Stopped\n-      return;\n-    }\n-    auto plan = this->plan()->shared_from_this();\n-    auto fut = generator_();\n-    const auto batch_index = next_batch_index_++;\n-\n-    lock.unlock();\n-    // TODO we want to transfer always here\n-    io_executor_->Transfer(std::move(fut))\n-        .AddCallback(\n-            [plan, batch_index, this](const Result<std::shared_ptr<RecordBatch>>& res) {\n-              std::unique_lock<std::mutex> lock(mutex_);\n-              if (!res.ok()) {\n-                for (auto out : outputs_) {\n-                  out->ErrorReceived(this, res.status());\n-                }\n-                return;\n-              }\n-              const auto& batch = *res;\n-              if (IsIterationEnd(batch)) {\n-                lock.unlock();\n-                for (auto out : outputs_) {\n-                  out->InputFinished(this, batch_index);\n-                }\n-              } else {\n-                lock.unlock();\n-                for (auto out : outputs_) {\n-                  out->InputReceived(this, batch_index, compute::ExecBatch(*batch));\n-                }\n-                lock.lock();\n-                GenerateOne(std::move(lock));\n-              }\n-            });\n-  }\n-\n-  std::mutex mutex_;\n-  const std::shared_ptr<Schema> schema_;\n-  const std::shared_ptr<RecordBatchReader> reader_;\n-  RecordBatchGenerator generator_;\n-  int next_batch_index_;\n-\n-  Executor* const io_executor_;\n-};\n-\n-struct RecordBatchCollectNodeImpl : public RecordBatchCollectNode {\n-  RecordBatchCollectNodeImpl(ExecPlan* plan, std::string label,\n-                             std::shared_ptr<Schema> schema)\n-      : RecordBatchCollectNode(plan, std::move(label), {DescrFromSchemaColumns(*schema)},\n-                               {\"batches_to_collect\"}, {}, 0),\n-        schema_(std::move(schema)) {}\n-\n-  RecordBatchGenerator generator() override { return generator_; }\n-\n-  const char* kind_name() override { return \"RecordBatchReader\"; }\n-\n-  Status StartProducing() override {\n-    num_received_ = 0;\n-    num_emitted_ = 0;\n-    emit_stop_ = -1;\n-    stopped_ = false;\n-    producer_.emplace(generator_.producer());\n-    return Status::OK();\n-  }\n-\n-  // sink nodes have no outputs from which to feel backpressure\n-  void ResumeProducing(ExecNode* output) override {\n-    FAIL() << \"no outputs; this should never be called\";\n-  }\n-  void PauseProducing(ExecNode* output) override {\n-    FAIL() << \"no outputs; this should never be called\";\n-  }\n-  void StopProducing(ExecNode* output) override {\n-    FAIL() << \"no outputs; this should never be called\";\n-  }\n-\n-  void StopProducing() override {\n-    std::unique_lock<std::mutex> lock(mutex_);\n-    StopProducingUnlocked();\n-  }\n-\n-  void InputReceived(ExecNode* input, int seq_num,\n-                     compute::ExecBatch exec_batch) override {\n-    std::unique_lock<std::mutex> lock(mutex_);\n-    if (stopped_) {\n-      return;\n-    }\n-    auto maybe_batch = MakeBatch(std::move(exec_batch));\n-    if (!maybe_batch.ok()) {\n-      lock.unlock();\n-      producer_->Push(std::move(maybe_batch));\n-      return;\n-    }\n-\n-    // TODO would be nice to factor this out in a ReorderQueue\n-    auto batch = *std::move(maybe_batch);\n-    if (seq_num <= static_cast<int>(received_batches_.size())) {\n-      received_batches_.resize(seq_num + 1, nullptr);\n-    }\n-    DCHECK_EQ(received_batches_[seq_num], nullptr);\n-    received_batches_[seq_num] = std::move(batch);\n-    ++num_received_;\n-\n-    if (seq_num != num_emitted_) {\n-      // Cannot emit yet as there is a hole at `num_emitted_`\n-      DCHECK_GT(seq_num, num_emitted_);\n-      DCHECK_EQ(received_batches_[num_emitted_], nullptr);\n-      return;\n-    }\n-    if (num_received_ == emit_stop_) {\n-      StopProducingUnlocked();\n-    }\n-\n-    // Emit batches in order as far as possible\n-    // First collect these batches, then unlock before producing.\n-    const auto seq_start = seq_num;\n-    while (seq_num < static_cast<int>(received_batches_.size()) &&\n-           received_batches_[seq_num] != nullptr) {\n-      ++seq_num;\n-    }\n-    DCHECK_GT(seq_num, seq_start);\n-    // By moving the values now, we make sure another thread won't emit the same values\n-    // below\n-    RecordBatchVector to_emit(\n-        std::make_move_iterator(received_batches_.begin() + seq_start),\n-        std::make_move_iterator(received_batches_.begin() + seq_num));\n-\n-    lock.unlock();\n-    for (auto&& batch : to_emit) {\n-      producer_->Push(std::move(batch));\n-    }\n-    lock.lock();\n-\n-    DCHECK_EQ(seq_start, num_emitted_);  // num_emitted_ wasn't bumped in the meantime\n-    num_emitted_ = seq_num;\n-  }\n-\n-  void ErrorReceived(ExecNode* input, Status error) override {\n-    // XXX do we care about properly sequencing the error?\n-    producer_->Push(std::move(error));\n-    std::unique_lock<std::mutex> lock(mutex_);\n-    StopProducingUnlocked();\n-  }\n-\n-  void InputFinished(ExecNode* input, int seq_stop) override {\n-    std::unique_lock<std::mutex> lock(mutex_);\n-    DCHECK_GE(seq_stop, static_cast<int>(received_batches_.size()));\n-    received_batches_.reserve(seq_stop);\n-    emit_stop_ = seq_stop;\n-    if (emit_stop_ == num_received_) {\n-      DCHECK_EQ(emit_stop_, num_emitted_);\n-      StopProducingUnlocked();\n-    }\n-  }\n-\n- private:\n-  void StopProducingUnlocked() {\n-    if (!stopped_) {\n-      stopped_ = true;\n-      producer_->Close();\n-      inputs_[0]->StopProducing(this);\n-    }\n-  }\n-\n-  // TODO factor this out as ExecBatch::ToRecordBatch()?\n-  Result<std::shared_ptr<RecordBatch>> MakeBatch(compute::ExecBatch&& exec_batch) {\n-    ArrayDataVector columns;\n-    columns.reserve(exec_batch.values.size());\n-    for (auto&& value : exec_batch.values) {\n-      if (!value.is_array()) {\n-        return Status::TypeError(\"Expected array input\");\n-      }\n-      columns.push_back(std::move(value).array());\n-    }\n-    return RecordBatch::Make(schema_, exec_batch.length, std::move(columns));\n-  }\n-\n-  const std::shared_ptr<Schema> schema_;\n-\n-  std::mutex mutex_;\n-  RecordBatchVector received_batches_;\n-  int num_received_;\n-  int num_emitted_;\n-  int emit_stop_;\n-  bool stopped_;\n-\n-  PushGenerator<std::shared_ptr<RecordBatch>> generator_;\n-  util::optional<PushGenerator<std::shared_ptr<RecordBatch>>::Producer> producer_;\n-};\n+AsyncGenerator<util::optional<ExecBatch>> Wrap(RecordBatchGenerator gen,\n+                                               ::arrow::internal::Executor* io_executor) {\n+  return MakeMappedGenerator(\n+      MakeTransferredGenerator(std::move(gen), io_executor),\n\nReview comment:\n       Why are you transferring onto the `io_executor` here?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-01T19:57:04.363+0000",
                    "updated": "2021-06-01T19:57:04.363+0000",
                    "started": "2021-06-01T19:57:04.363+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "604750",
                    "issueId": "13363668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13363668/worklog/604754",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10397:\nURL: https://github.com/apache/arrow/pull/10397#discussion_r643447166\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/exec_plan.h\n##########\n@@ -225,22 +212,43 @@ class ARROW_EXPORT ExecNode {\n   virtual void StopProducing() = 0;\n \n  protected:\n-  ExecNode(ExecPlan* plan, std::string label, std::vector<BatchDescr> input_descrs,\n+  ExecNode(ExecPlan*, std::string label, NodeVector inputs,\n            std::vector<std::string> input_labels, BatchDescr output_descr,\n            int num_outputs);\n \n   ExecPlan* plan_;\n-\n   std::string label_;\n \n-  std::vector<BatchDescr> input_descrs_;\n-  std::vector<std::string> input_labels_;\n   NodeVector inputs_;\n+  std::vector<std::string> input_labels_;\n \n   BatchDescr output_descr_;\n   int num_outputs_;\n   NodeVector outputs_;\n };\n \n+/// \\brief Adapt an AsyncGenerator<ExecBatch> as a source node\n+ARROW_EXPORT\n+ExecNode* MakeSourceNode(ExecPlan*, std::string label, ExecNode::BatchDescr output_descr,\n+                         AsyncGenerator<util::optional<ExecBatch>>);\n+\n+/// \\brief Add a sink node which forwards to an AsyncGenerator<ExecBatch>\n+ARROW_EXPORT\n+AsyncGenerator<util::optional<ExecBatch>> MakeSinkNode(ExecNode* input,\n+                                                       std::string label);\n+\n+/// \\brief Make a node which excludes some rows from batches passed through it\n+///\n+/// filter Expression must be bound; no field references will be looked up by name\n+ARROW_EXPORT\n+ExecNode* MakeFilterNode(ExecNode* input, std::string label, Expression filter);\n+\n+/// \\brief Make a node which executes expressions on input batches, producing new batches.\n+///\n+/// Expressions must be bound; no field references will be looked up by name\n+ARROW_EXPORT\n+ExecNode* MakeProjectNode(ExecNode* input, std::string label,\n\nReview comment:\n       I'll add clarification\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-01T20:11:28.295+0000",
                    "updated": "2021-06-01T20:11:28.295+0000",
                    "started": "2021-06-01T20:11:28.295+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "604754",
                    "issueId": "13363668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13363668/worklog/604755",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10397:\nURL: https://github.com/apache/arrow/pull/10397#discussion_r643447263\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression.cc\n##########\n@@ -510,7 +475,67 @@ Result<Expression> Expression::Bind(const Schema& in_schema,\n   return Bind(ValueDescr::Array(struct_(in_schema.fields())), exec_context);\n }\n \n-Result<Datum> ExecuteScalarExpression(const Expression& expr, const Datum& input,\n+Result<ExecBatch> MakeExecBatch(const Schema& full_schema, const Datum& partial) {\n+  ExecBatch out;\n+\n+  if (partial.kind() == Datum::RECORD_BATCH) {\n+    const auto& partial_batch = *partial.record_batch();\n+    out.length = partial_batch.num_rows();\n+\n+    for (const auto& field : full_schema.fields()) {\n+      ARROW_ASSIGN_OR_RAISE(auto column,\n+                            FieldRef(field->name()).GetOneOrNone(partial_batch));\n\nReview comment:\n       It will\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-01T20:11:41.601+0000",
                    "updated": "2021-06-01T20:11:41.601+0000",
                    "started": "2021-06-01T20:11:41.601+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "604755",
                    "issueId": "13363668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13363668/worklog/604756",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10397:\nURL: https://github.com/apache/arrow/pull/10397#discussion_r643447263\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression.cc\n##########\n@@ -510,7 +475,67 @@ Result<Expression> Expression::Bind(const Schema& in_schema,\n   return Bind(ValueDescr::Array(struct_(in_schema.fields())), exec_context);\n }\n \n-Result<Datum> ExecuteScalarExpression(const Expression& expr, const Datum& input,\n+Result<ExecBatch> MakeExecBatch(const Schema& full_schema, const Datum& partial) {\n+  ExecBatch out;\n+\n+  if (partial.kind() == Datum::RECORD_BATCH) {\n+    const auto& partial_batch = *partial.record_batch();\n+    out.length = partial_batch.num_rows();\n+\n+    for (const auto& field : full_schema.fields()) {\n+      ARROW_ASSIGN_OR_RAISE(auto column,\n+                            FieldRef(field->name()).GetOneOrNone(partial_batch));\n\nReview comment:\n       It will raise Status::Invalid\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-01T20:11:55.945+0000",
                    "updated": "2021-06-01T20:11:55.945+0000",
                    "started": "2021-06-01T20:11:55.945+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "604756",
                    "issueId": "13363668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13363668/worklog/604758",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10397:\nURL: https://github.com/apache/arrow/pull/10397#discussion_r643448100\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression.h\n##########\n@@ -207,11 +218,22 @@ Result<Expression> SimplifyWithGuarantee(Expression,\n \n // Execution\n \n-/// Execute a scalar expression against the provided state and input Datum. This\n+/// Ensure that a RecordBatch (which may have missing or incorrectly ordered columns)\n\nReview comment:\n       will do, thanks\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-01T20:13:14.318+0000",
                    "updated": "2021-06-01T20:13:14.318+0000",
                    "started": "2021-06-01T20:13:14.318+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "604758",
                    "issueId": "13363668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13363668/worklog/604846",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10397:\nURL: https://github.com/apache/arrow/pull/10397#discussion_r643575745\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/dataset_internal.h\n##########\n@@ -204,5 +204,35 @@ arrow::Result<std::shared_ptr<T>> GetFragmentScanOptions(\n   return internal::checked_pointer_cast<T>(source);\n }\n \n+class FragmentDataset : public Dataset {\n\nReview comment:\n       Whether or not the component fragments are in memory is up to the fragments, so I don't think it's appropriate to inherit that here\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T00:47:15.900+0000",
                    "updated": "2021-06-02T00:47:15.900+0000",
                    "started": "2021-06-02T00:47:15.900+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "604846",
                    "issueId": "13363668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13363668/worklog/604847",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10397:\nURL: https://github.com/apache/arrow/pull/10397#discussion_r643576195\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression_test.cc\n##########\n@@ -165,6 +165,56 @@ TEST(ExpressionUtils, StripOrderPreservingCasts) {\n   Expect(cast(field_ref(\"i32\"), uint64()), no_change);\n }\n \n+TEST(ExpressionUtils, MakeExecBatch) {\n+  auto Expect = [](std::shared_ptr<RecordBatch> partial_batch) {\n+    SCOPED_TRACE(partial_batch->ToString());\n+    ASSERT_OK_AND_ASSIGN(auto batch, MakeExecBatch(*kBoringSchema, partial_batch));\n+\n+    ASSERT_EQ(batch.num_values(), kBoringSchema->num_fields());\n+    for (int i = 0; i < kBoringSchema->num_fields(); ++i) {\n+      const auto& field = *kBoringSchema->field(i);\n+\n+      SCOPED_TRACE(\"Field#\" + std::to_string(i) + \" \" + field.ToString());\n+\n+      EXPECT_TRUE(batch[i].type()->Equals(field.type()))\n+          << \"Incorrect type \" << batch[i].type()->ToString();\n+\n+      ASSERT_OK_AND_ASSIGN(auto col, FieldRef(field.name()).GetOneOrNone(*partial_batch));\n\nReview comment:\n       GetOneOrNone raises a descriptive error if duplicate field names are found, whereas GetFieldByName will just return null IIRC\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T00:48:43.607+0000",
                    "updated": "2021-06-02T00:48:43.607+0000",
                    "started": "2021-06-02T00:48:43.607+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "604847",
                    "issueId": "13363668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13363668/worklog/604850",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10397:\nURL: https://github.com/apache/arrow/pull/10397#discussion_r643577382\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression.cc\n##########\n@@ -510,7 +475,67 @@ Result<Expression> Expression::Bind(const Schema& in_schema,\n   return Bind(ValueDescr::Array(struct_(in_schema.fields())), exec_context);\n }\n \n-Result<Datum> ExecuteScalarExpression(const Expression& expr, const Datum& input,\n+Result<ExecBatch> MakeExecBatch(const Schema& full_schema, const Datum& partial) {\n+  ExecBatch out;\n+\n+  if (partial.kind() == Datum::RECORD_BATCH) {\n+    const auto& partial_batch = *partial.record_batch();\n+    out.length = partial_batch.num_rows();\n+\n+    for (const auto& field : full_schema.fields()) {\n+      ARROW_ASSIGN_OR_RAISE(auto column,\n+                            FieldRef(field->name()).GetOneOrNone(partial_batch));\n+\n+      if (column) {\n+        if (!column->type()->Equals(field->type())) {\n+          // Referenced field was present but didn't have the expected type.\n+          // This *should* be handled by readers, and will just be an error in the future.\n+          ARROW_ASSIGN_OR_RAISE(\n+              auto converted,\n+              compute::Cast(column, field->type(), compute::CastOptions::Safe()));\n+          column = converted.make_array();\n+        }\n+        out.values.emplace_back(std::move(column));\n+      } else {\n+        out.values.emplace_back(MakeNullScalar(field->type()));\n+      }\n+    }\n+    return out;\n+  }\n+\n+  // wasteful but useful for testing:\n+  if (partial.type()->id() == Type::STRUCT) {\n+    if (partial.is_array()) {\n+      ARROW_ASSIGN_OR_RAISE(auto partial_batch,\n+                            RecordBatch::FromStructArray(partial.make_array()));\n+\n+      return MakeExecBatch(full_schema, partial_batch);\n+    }\n+\n+    if (partial.is_scalar()) {\n+      ARROW_ASSIGN_OR_RAISE(auto partial_array,\n+                            MakeArrayFromScalar(*partial.scalar(), 1));\n+      ARROW_ASSIGN_OR_RAISE(auto out, MakeExecBatch(full_schema, partial_array));\n+\n+      for (Datum& value : out.values) {\n+        if (value.is_scalar()) continue;\n+        ARROW_ASSIGN_OR_RAISE(value, value.make_array()->GetScalar(0));\n+      }\n\nReview comment:\n       This was as compact as I could write this case; if you see a way to compress/simplify it then I'll take it but the scalar/array cases are really just for testing purposes\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T00:52:42.490+0000",
                    "updated": "2021-06-02T00:52:42.490+0000",
                    "started": "2021-06-02T00:52:42.489+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "604850",
                    "issueId": "13363668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13363668/worklog/604852",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10397:\nURL: https://github.com/apache/arrow/pull/10397#discussion_r643578392\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression.cc\n##########\n@@ -61,13 +61,22 @@ Expression call(std::string function, std::vector<Expression> arguments,\n   call.function_name = std::move(function);\n   call.arguments = std::move(arguments);\n   call.options = std::move(options);\n+\n+  call.hash = std::hash<std::string>{}(call.function_name);\n+  for (const auto& arg : call.arguments) {\n+    call.hash ^= arg.hash();\n+  }\n   return Expression(std::move(call));\n }\n \n const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n \n+const Expression::Parameter* Expression::parameter() const {\n\nReview comment:\n       a Parameter is a {field_ref, type, index} (with the last two properties only available after `Bind`). During simplification against guarantees (which are unbound), parameters must be compared by their field_refs\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T00:56:11.021+0000",
                    "updated": "2021-06-02T00:56:11.021+0000",
                    "started": "2021-06-02T00:56:11.020+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "604852",
                    "issueId": "13363668"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 43800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@67b2458c[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2de9360a[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@db2134a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@698f2d90[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@670b6e26[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@52586348[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4fed120a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@5f1e55ca[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@63d87a51[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@728b0741[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@55d12658[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@78cc892d[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 43800,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Jul 01 12:15:41 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-07-01T12:15:41.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11930/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2021-03-10T22:53:56.000+0000",
        "updated": "2021-07-01T12:15:46.000+0000",
        "timeoriginalestimate": null,
        "description": "Per discussion on https://docs.google.com/document/d/1AyTdLU-RxA-Gsb9EsYnrQrmqPMOYMfPlWwxRi1Is1tQ\r\n\r\nOnce Datasets can be streamed from efficiently (ARROW-7001), they can be wrapped in ScanNodes which push scanned batches into an ExecNode graph.\r\n\r\nFiltering and Projection should then be handled by subsequent nodes in that graph.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "12h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 43800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Dataset][Compute] Refactor Dataset scans to use an ExecNode graph",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13363668/comment/17372721",
                    "id": "17372721",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 10397\n[https://github.com/apache/arrow/pull/10397]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-07-01T12:15:41.872+0000",
                    "updated": "2021-07-01T12:15:41.872+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0oivk:",
        "customfield_12314139": null
    }
}