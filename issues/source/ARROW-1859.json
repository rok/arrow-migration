{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13120776",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13120776",
    "key": "ARROW-1859",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12341352",
                "id": "12341352",
                "name": "0.8.0",
                "archived": false,
                "released": true,
                "releaseDate": "2017-12-18"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": null,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=kou",
            "name": "kou",
            "key": "kou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=kou&avatarId=30762",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kou&avatarId=30762",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kou&avatarId=30762",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kou&avatarId=30762"
            },
            "displayName": "Kouhei Sutou",
            "active": true,
            "timeZone": "Asia/Tokyo"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12332430",
                "id": "12332430",
                "name": "GLib"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": null,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=kou",
            "name": "kou",
            "key": "kou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=kou&avatarId=30762",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kou&avatarId=30762",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kou&avatarId=30762",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kou&avatarId=30762"
            },
            "displayName": "Kouhei Sutou",
            "active": true,
            "timeZone": "Asia/Tokyo"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=kou",
            "name": "kou",
            "key": "kou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=kou&avatarId=30762",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kou&avatarId=30762",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kou&avatarId=30762",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kou&avatarId=30762"
            },
            "displayName": "Kouhei Sutou",
            "active": true,
            "timeZone": "Asia/Tokyo"
        },
        "aggregateprogress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1859/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 0,
            "worklogs": []
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": null,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@37cca18a[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2e6879ee[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@39f7cabe[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@543d7367[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@562a8461[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@123ee023[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@159b7ae0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@2a02957f[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@280915d2[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@4dd3d708[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@351f828[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@3dc63c50[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": null,
        "customfield_12312520": null,
        "customfield_12312521": "Sun Nov 26 19:17:37 UTC 2017",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2017-11-26T19:17:36.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1859/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2017-11-26T13:50:15.000+0000",
        "updated": "2017-11-26T19:17:37.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {},
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[GLib] Add GArrowDictionaryDataType",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13120776/comment/16266008",
                    "id": "16266008",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "kou opened a new pull request #1361: ARROW-1859: [GLib] Add GArrowDictionaryDataType\nURL: https://github.com/apache/arrow/pull/1361\n \n \n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-26T13:51:12.358+0000",
                    "updated": "2017-11-26T13:51:12.358+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13120776/comment/16266145",
                    "id": "16266145",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 1361\n[https://github.com/apache/arrow/pull/1361]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2017-11-26T19:17:36.308+0000",
                    "updated": "2017-11-26T19:17:36.308+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13120776/comment/16266146",
                    "id": "16266146",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm closed pull request #1361: ARROW-1859: [GLib] Add GArrowDictionaryDataType\nURL: https://github.com/apache/arrow/pull/1361\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/c_glib/arrow-glib/Makefile.am b/c_glib/arrow-glib/Makefile.am\nindex e8073115d..39222a548 100644\n--- a/c_glib/arrow-glib/Makefile.am\n+++ b/c_glib/arrow-glib/Makefile.am\n@@ -45,10 +45,12 @@ libarrow_glib_la_headers =\t\t\t\\\n \tarray.h\t\t\t\t\t\\\n \tarray-builder.h\t\t\t\t\\\n \tarrow-glib.h\t\t\t\t\\\n+\tbasic-array.h\t\t\t\t\\\n \tbasic-data-type.h\t\t\t\\\n \tbuffer.h\t\t\t\t\\\n \tchunked-array.h\t\t\t\t\\\n \tcolumn.h\t\t\t\t\\\n+\tcomposite-array.h\t\t\t\\\n \tcomposite-data-type.h\t\t\t\\\n \tdata-type.h\t\t\t\t\\\n \terror.h\t\t\t\t\t\\\n@@ -86,12 +88,13 @@ libarrow_glib_la_generated_sources =\t\t\\\n \t$(libarrow_glib_la_generated_headers)\n \n libarrow_glib_la_sources =\t\t\t\\\n-\tarray.cpp\t\t\t\t\\\n \tarray-builder.cpp\t\t\t\\\n+\tbasic-array.cpp\t\t\t\t\\\n \tbasic-data-type.cpp\t\t\t\\\n \tbuffer.cpp\t\t\t\t\\\n \tchunked-array.cpp\t\t\t\\\n \tcolumn.cpp\t\t\t\t\\\n+\tcomposite-array.cpp\t\t\t\\\n \tcomposite-data-type.cpp\t\t\t\\\n \terror.cpp\t\t\t\t\\\n \tfield.cpp\t\t\t\t\\\n@@ -125,6 +128,7 @@ libarrow_glib_la_cpp_headers =\t\t\t\\\n \tarray.hpp\t\t\t\t\\\n \tarray-builder.hpp\t\t\t\\\n \tarrow-glib.hpp\t\t\t\t\\\n+\tbasic-array.hpp\t\t\t\t\\\n \tbasic-data-type.hpp\t\t\t\\\n \tbuffer.hpp\t\t\t\t\\\n \tchunked-array.hpp\t\t\t\\\ndiff --git a/c_glib/arrow-glib/array.h b/c_glib/arrow-glib/array.h\nindex e988a8aae..9a845597d 100644\n--- a/c_glib/arrow-glib/array.h\n+++ b/c_glib/arrow-glib/array.h\n@@ -19,1226 +19,5 @@\n \n #pragma once\n \n-#include <arrow-glib/buffer.h>\n-#include <arrow-glib/compute.h>\n-#include <arrow-glib/data-type.h>\n-\n-G_BEGIN_DECLS\n-\n-#define GARROW_TYPE_ARRAY \\\n-  (garrow_array_get_type())\n-#define GARROW_ARRAY(obj) \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj), GARROW_TYPE_ARRAY, GArrowArray))\n-#define GARROW_ARRAY_CLASS(klass) \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass), GARROW_TYPE_ARRAY, GArrowArrayClass))\n-#define GARROW_IS_ARRAY(obj) \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GARROW_TYPE_ARRAY))\n-#define GARROW_IS_ARRAY_CLASS(klass) \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass), GARROW_TYPE_ARRAY))\n-#define GARROW_ARRAY_GET_CLASS(obj) \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj), GARROW_TYPE_ARRAY, GArrowArrayClass))\n-\n-typedef struct _GArrowArray         GArrowArray;\n-typedef struct _GArrowArrayClass    GArrowArrayClass;\n-\n-/**\n- * GArrowArray:\n- *\n- * It wraps `arrow::Array`.\n- */\n-struct _GArrowArray\n-{\n-  /*< private >*/\n-  GObject parent_instance;\n-};\n-\n-struct _GArrowArrayClass\n-{\n-  GObjectClass parent_class;\n-};\n-\n-GType          garrow_array_get_type    (void) G_GNUC_CONST;\n-\n-gboolean       garrow_array_equal       (GArrowArray *array,\n-                                         GArrowArray *other_array);\n-gboolean       garrow_array_equal_approx(GArrowArray *array,\n-                                         GArrowArray *other_array);\n-gboolean       garrow_array_equal_range (GArrowArray *array,\n-                                         gint64 start_index,\n-                                         GArrowArray *other_array,\n-                                         gint64 other_start_index,\n-                                         gint64 end_index);\n-\n-gboolean       garrow_array_is_null     (GArrowArray *array,\n-                                         gint64 i);\n-gboolean       garrow_array_is_valid    (GArrowArray *array,\n-                                         gint64 i);\n-gint64         garrow_array_get_length  (GArrowArray *array);\n-gint64         garrow_array_get_offset  (GArrowArray *array);\n-gint64         garrow_array_get_n_nulls (GArrowArray *array);\n-GArrowBuffer  *garrow_array_get_null_bitmap(GArrowArray *array);\n-GArrowDataType *garrow_array_get_value_data_type(GArrowArray *array);\n-GArrowType     garrow_array_get_value_type(GArrowArray *array);\n-GArrowArray   *garrow_array_slice       (GArrowArray *array,\n-                                         gint64 offset,\n-                                         gint64 length);\n-gchar         *garrow_array_to_string   (GArrowArray *array,\n-                                         GError **error);\n-\n-GArrowArray   *garrow_array_cast        (GArrowArray *array,\n-                                         GArrowDataType *target_data_type,\n-                                         GArrowCastOptions *options,\n-                                         GError **error);\n-\n-#define GARROW_TYPE_NULL_ARRAY                  \\\n-  (garrow_null_array_get_type())\n-#define GARROW_NULL_ARRAY(obj)                          \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n-                              GARROW_TYPE_NULL_ARRAY,   \\\n-                              GArrowNullArray))\n-#define GARROW_NULL_ARRAY_CLASS(klass)                  \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n-                           GARROW_TYPE_NULL_ARRAY,      \\\n-                           GArrowNullArrayClass))\n-#define GARROW_IS_NULL_ARRAY(obj)                       \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                    \\\n-                              GARROW_TYPE_NULL_ARRAY))\n-#define GARROW_IS_NULL_ARRAY_CLASS(klass)               \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n-                           GARROW_TYPE_NULL_ARRAY))\n-#define GARROW_NULL_ARRAY_GET_CLASS(obj)                \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n-                             GARROW_TYPE_NULL_ARRAY,    \\\n-                             GArrowNullArrayClass))\n-\n-typedef struct _GArrowNullArray         GArrowNullArray;\n-typedef struct _GArrowNullArrayClass    GArrowNullArrayClass;\n-\n-/**\n- * GArrowNullArray:\n- *\n- * It wraps `arrow::NullArray`.\n- */\n-struct _GArrowNullArray\n-{\n-  /*< private >*/\n-  GArrowArray parent_instance;\n-};\n-\n-struct _GArrowNullArrayClass\n-{\n-  GArrowArrayClass parent_class;\n-};\n-\n-GType garrow_null_array_get_type(void) G_GNUC_CONST;\n-\n-GArrowNullArray *garrow_null_array_new(gint64 length);\n-\n-\n-#define GARROW_TYPE_PRIMITIVE_ARRAY             \\\n-  (garrow_primitive_array_get_type())\n-#define GARROW_PRIMITIVE_ARRAY(obj)                             \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                            \\\n-                              GARROW_TYPE_PRIMITIVE_ARRAY,      \\\n-                              GArrowPrimitiveArray))\n-#define GARROW_PRIMITIVE_ARRAY_CLASS(klass)             \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n-                           GARROW_TYPE_PRIMITIVE_ARRAY, \\\n-                           GArrowPrimitiveArrayClass))\n-#define GARROW_IS_PRIMITIVE_ARRAY(obj)                          \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n-                              GARROW_TYPE_PRIMITIVE_ARRAY))\n-#define GARROW_IS_PRIMITIVE_ARRAY_CLASS(klass)                  \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                             \\\n-                           GARROW_TYPE_PRIMITIVE_ARRAY))\n-#define GARROW_PRIMITIVE_ARRAY_GET_CLASS(obj)                   \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                             \\\n-                             GARROW_TYPE_PRIMITIVE_ARRAY,       \\\n-                             GArrowPrimitiveArrayClass))\n-\n-typedef struct _GArrowPrimitiveArray         GArrowPrimitiveArray;\n-typedef struct _GArrowPrimitiveArrayClass    GArrowPrimitiveArrayClass;\n-\n-/**\n- * GArrowPrimitiveArray:\n- *\n- * It wraps `arrow::PrimitiveArray`.\n- */\n-struct _GArrowPrimitiveArray\n-{\n-  /*< private >*/\n-  GArrowArray parent_instance;\n-};\n-\n-struct _GArrowPrimitiveArrayClass\n-{\n-  GArrowArrayClass parent_class;\n-};\n-\n-GType garrow_primitive_array_get_type(void) G_GNUC_CONST;\n-\n-GArrowBuffer *garrow_primitive_array_get_buffer(GArrowPrimitiveArray *array);\n-\n-\n-#define GARROW_TYPE_BOOLEAN_ARRAY               \\\n-  (garrow_boolean_array_get_type())\n-#define GARROW_BOOLEAN_ARRAY(obj)                               \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                            \\\n-                              GARROW_TYPE_BOOLEAN_ARRAY,        \\\n-                              GArrowBooleanArray))\n-#define GARROW_BOOLEAN_ARRAY_CLASS(klass)               \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n-                           GARROW_TYPE_BOOLEAN_ARRAY,   \\\n-                           GArrowBooleanArrayClass))\n-#define GARROW_IS_BOOLEAN_ARRAY(obj)                            \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n-                              GARROW_TYPE_BOOLEAN_ARRAY))\n-#define GARROW_IS_BOOLEAN_ARRAY_CLASS(klass)            \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n-                           GARROW_TYPE_BOOLEAN_ARRAY))\n-#define GARROW_BOOLEAN_ARRAY_GET_CLASS(obj)             \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n-                             GARROW_TYPE_BOOLEAN_ARRAY, \\\n-                             GArrowBooleanArrayClass))\n-\n-typedef struct _GArrowBooleanArray         GArrowBooleanArray;\n-typedef struct _GArrowBooleanArrayClass    GArrowBooleanArrayClass;\n-\n-/**\n- * GArrowBooleanArray:\n- *\n- * It wraps `arrow::BooleanArray`.\n- */\n-struct _GArrowBooleanArray\n-{\n-  /*< private >*/\n-  GArrowPrimitiveArray parent_instance;\n-};\n-\n-struct _GArrowBooleanArrayClass\n-{\n-  GArrowPrimitiveArrayClass parent_class;\n-};\n-\n-GType          garrow_boolean_array_get_type  (void) G_GNUC_CONST;\n-\n-GArrowBooleanArray *garrow_boolean_array_new(gint64 length,\n-                                             GArrowBuffer *data,\n-                                             GArrowBuffer *null_bitmap,\n-                                             gint64 n_nulls);\n-\n-gboolean       garrow_boolean_array_get_value (GArrowBooleanArray *array,\n-                                               gint64 i);\n-gboolean      *garrow_boolean_array_get_values(GArrowBooleanArray *array,\n-                                               gint64 *length);\n-\n-\n-#define GARROW_TYPE_INT8_ARRAY                  \\\n-  (garrow_int8_array_get_type())\n-#define GARROW_INT8_ARRAY(obj)                          \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n-                              GARROW_TYPE_INT8_ARRAY,   \\\n-                              GArrowInt8Array))\n-#define GARROW_INT8_ARRAY_CLASS(klass)                  \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n-                           GARROW_TYPE_INT8_ARRAY,      \\\n-                           GArrowInt8ArrayClass))\n-#define GARROW_IS_INT8_ARRAY(obj)                       \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                    \\\n-                              GARROW_TYPE_INT8_ARRAY))\n-#define GARROW_IS_INT8_ARRAY_CLASS(klass)               \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n-                           GARROW_TYPE_INT8_ARRAY))\n-#define GARROW_INT8_ARRAY_GET_CLASS(obj)                \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n-                             GARROW_TYPE_INT8_ARRAY,    \\\n-                             GArrowInt8ArrayClass))\n-\n-typedef struct _GArrowInt8Array         GArrowInt8Array;\n-typedef struct _GArrowInt8ArrayClass    GArrowInt8ArrayClass;\n-\n-/**\n- * GArrowInt8Array:\n- *\n- * It wraps `arrow::Int8Array`.\n- */\n-struct _GArrowInt8Array\n-{\n-  /*< private >*/\n-  GArrowPrimitiveArray parent_instance;\n-};\n-\n-struct _GArrowInt8ArrayClass\n-{\n-  GArrowPrimitiveArrayClass parent_class;\n-};\n-\n-GType garrow_int8_array_get_type(void) G_GNUC_CONST;\n-\n-GArrowInt8Array *garrow_int8_array_new(gint64 length,\n-                                       GArrowBuffer *data,\n-                                       GArrowBuffer *null_bitmap,\n-                                       gint64 n_nulls);\n-\n-gint8 garrow_int8_array_get_value(GArrowInt8Array *array,\n-                                  gint64 i);\n-const gint8 *garrow_int8_array_get_values(GArrowInt8Array *array,\n-                                          gint64 *length);\n-\n-\n-#define GARROW_TYPE_UINT8_ARRAY                 \\\n-  (garrow_uint8_array_get_type())\n-#define GARROW_UINT8_ARRAY(obj)                         \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n-                              GARROW_TYPE_UINT8_ARRAY,  \\\n-                              GArrowUInt8Array))\n-#define GARROW_UINT8_ARRAY_CLASS(klass)                 \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n-                           GARROW_TYPE_UINT8_ARRAY,     \\\n-                           GArrowUInt8ArrayClass))\n-#define GARROW_IS_UINT8_ARRAY(obj)                      \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                    \\\n-                              GARROW_TYPE_UINT8_ARRAY))\n-#define GARROW_IS_UINT8_ARRAY_CLASS(klass)              \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n-                           GARROW_TYPE_UINT8_ARRAY))\n-#define GARROW_UINT8_ARRAY_GET_CLASS(obj)               \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n-                             GARROW_TYPE_UINT8_ARRAY,   \\\n-                             GArrowUInt8ArrayClass))\n-\n-typedef struct _GArrowUInt8Array         GArrowUInt8Array;\n-typedef struct _GArrowUInt8ArrayClass    GArrowUInt8ArrayClass;\n-\n-/**\n- * GArrowUInt8Array:\n- *\n- * It wraps `arrow::UInt8Array`.\n- */\n-struct _GArrowUInt8Array\n-{\n-  /*< private >*/\n-  GArrowPrimitiveArray parent_instance;\n-};\n-\n-struct _GArrowUInt8ArrayClass\n-{\n-  GArrowPrimitiveArrayClass parent_class;\n-};\n-\n-GType garrow_uint8_array_get_type(void) G_GNUC_CONST;\n-\n-GArrowUInt8Array *garrow_uint8_array_new(gint64 length,\n-                                         GArrowBuffer *data,\n-                                         GArrowBuffer *null_bitmap,\n-                                         gint64 n_nulls);\n-\n-guint8 garrow_uint8_array_get_value(GArrowUInt8Array *array,\n-                                    gint64 i);\n-const guint8 *garrow_uint8_array_get_values(GArrowUInt8Array *array,\n-                                            gint64 *length);\n-\n-\n-#define GARROW_TYPE_INT16_ARRAY                  \\\n-  (garrow_int16_array_get_type())\n-#define GARROW_INT16_ARRAY(obj)                         \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n-                              GARROW_TYPE_INT16_ARRAY,  \\\n-                              GArrowInt16Array))\n-#define GARROW_INT16_ARRAY_CLASS(klass)                 \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n-                           GARROW_TYPE_INT16_ARRAY,     \\\n-                           GArrowInt16ArrayClass))\n-#define GARROW_IS_INT16_ARRAY(obj)                      \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                    \\\n-                              GARROW_TYPE_INT16_ARRAY))\n-#define GARROW_IS_INT16_ARRAY_CLASS(klass)              \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n-                           GARROW_TYPE_INT16_ARRAY))\n-#define GARROW_INT16_ARRAY_GET_CLASS(obj)               \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n-                             GARROW_TYPE_INT16_ARRAY,   \\\n-                             GArrowInt16ArrayClass))\n-\n-typedef struct _GArrowInt16Array         GArrowInt16Array;\n-typedef struct _GArrowInt16ArrayClass    GArrowInt16ArrayClass;\n-\n-/**\n- * GArrowInt16Array:\n- *\n- * It wraps `arrow::Int16Array`.\n- */\n-struct _GArrowInt16Array\n-{\n-  /*< private >*/\n-  GArrowPrimitiveArray parent_instance;\n-};\n-\n-struct _GArrowInt16ArrayClass\n-{\n-  GArrowPrimitiveArrayClass parent_class;\n-};\n-\n-GType garrow_int16_array_get_type(void) G_GNUC_CONST;\n-\n-GArrowInt16Array *garrow_int16_array_new(gint64 length,\n-                                         GArrowBuffer *data,\n-                                         GArrowBuffer *null_bitmap,\n-                                         gint64 n_nulls);\n-\n-gint16 garrow_int16_array_get_value(GArrowInt16Array *array,\n-                                    gint64 i);\n-const gint16 *garrow_int16_array_get_values(GArrowInt16Array *array,\n-                                            gint64 *length);\n-\n-\n-#define GARROW_TYPE_UINT16_ARRAY                 \\\n-  (garrow_uint16_array_get_type())\n-#define GARROW_UINT16_ARRAY(obj)                        \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n-                              GARROW_TYPE_UINT16_ARRAY, \\\n-                              GArrowUInt16Array))\n-#define GARROW_UINT16_ARRAY_CLASS(klass)                \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n-                           GARROW_TYPE_UINT16_ARRAY,    \\\n-                           GArrowUInt16ArrayClass))\n-#define GARROW_IS_UINT16_ARRAY(obj)                             \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n-                              GARROW_TYPE_UINT16_ARRAY))\n-#define GARROW_IS_UINT16_ARRAY_CLASS(klass)             \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n-                           GARROW_TYPE_UINT16_ARRAY))\n-#define GARROW_UINT16_ARRAY_GET_CLASS(obj)              \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n-                             GARROW_TYPE_UINT16_ARRAY,  \\\n-                             GArrowUInt16ArrayClass))\n-\n-typedef struct _GArrowUInt16Array         GArrowUInt16Array;\n-typedef struct _GArrowUInt16ArrayClass    GArrowUInt16ArrayClass;\n-\n-/**\n- * GArrowUInt16Array:\n- *\n- * It wraps `arrow::UInt16Array`.\n- */\n-struct _GArrowUInt16Array\n-{\n-  /*< private >*/\n-  GArrowPrimitiveArray parent_instance;\n-};\n-\n-struct _GArrowUInt16ArrayClass\n-{\n-  GArrowPrimitiveArrayClass parent_class;\n-};\n-\n-GType garrow_uint16_array_get_type(void) G_GNUC_CONST;\n-\n-GArrowUInt16Array *garrow_uint16_array_new(gint64 length,\n-                                           GArrowBuffer *data,\n-                                           GArrowBuffer *null_bitmap,\n-                                           gint64 n_nulls);\n-\n-guint16 garrow_uint16_array_get_value(GArrowUInt16Array *array,\n-                                      gint64 i);\n-const guint16 *garrow_uint16_array_get_values(GArrowUInt16Array *array,\n-                                              gint64 *length);\n-\n-\n-#define GARROW_TYPE_INT32_ARRAY                 \\\n-  (garrow_int32_array_get_type())\n-#define GARROW_INT32_ARRAY(obj)                         \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n-                              GARROW_TYPE_INT32_ARRAY,  \\\n-                              GArrowInt32Array))\n-#define GARROW_INT32_ARRAY_CLASS(klass)                 \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n-                           GARROW_TYPE_INT32_ARRAY,     \\\n-                           GArrowInt32ArrayClass))\n-#define GARROW_IS_INT32_ARRAY(obj)                      \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                    \\\n-                              GARROW_TYPE_INT32_ARRAY))\n-#define GARROW_IS_INT32_ARRAY_CLASS(klass)              \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n-                           GARROW_TYPE_INT32_ARRAY))\n-#define GARROW_INT32_ARRAY_GET_CLASS(obj)               \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n-                             GARROW_TYPE_INT32_ARRAY,   \\\n-                             GArrowInt32ArrayClass))\n-\n-typedef struct _GArrowInt32Array         GArrowInt32Array;\n-typedef struct _GArrowInt32ArrayClass    GArrowInt32ArrayClass;\n-\n-/**\n- * GArrowInt32Array:\n- *\n- * It wraps `arrow::Int32Array`.\n- */\n-struct _GArrowInt32Array\n-{\n-  /*< private >*/\n-  GArrowPrimitiveArray parent_instance;\n-};\n-\n-struct _GArrowInt32ArrayClass\n-{\n-  GArrowPrimitiveArrayClass parent_class;\n-};\n-\n-GType garrow_int32_array_get_type(void) G_GNUC_CONST;\n-\n-GArrowInt32Array *garrow_int32_array_new(gint64 length,\n-                                         GArrowBuffer *data,\n-                                         GArrowBuffer *null_bitmap,\n-                                         gint64 n_nulls);\n-\n-gint32 garrow_int32_array_get_value(GArrowInt32Array *array,\n-                                    gint64 i);\n-const gint32 *garrow_int32_array_get_values(GArrowInt32Array *array,\n-                                            gint64 *length);\n-\n-\n-#define GARROW_TYPE_UINT32_ARRAY                \\\n-  (garrow_uint32_array_get_type())\n-#define GARROW_UINT32_ARRAY(obj)                        \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n-                              GARROW_TYPE_UINT32_ARRAY, \\\n-                              GArrowUInt32Array))\n-#define GARROW_UINT32_ARRAY_CLASS(klass)                \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n-                           GARROW_TYPE_UINT32_ARRAY,    \\\n-                           GArrowUInt32ArrayClass))\n-#define GARROW_IS_UINT32_ARRAY(obj)                             \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n-                              GARROW_TYPE_UINT32_ARRAY))\n-#define GARROW_IS_UINT32_ARRAY_CLASS(klass)             \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n-                           GARROW_TYPE_UINT32_ARRAY))\n-#define GARROW_UINT32_ARRAY_GET_CLASS(obj)              \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n-                             GARROW_TYPE_UINT32_ARRAY,  \\\n-                             GArrowUInt32ArrayClass))\n-\n-typedef struct _GArrowUInt32Array         GArrowUInt32Array;\n-typedef struct _GArrowUInt32ArrayClass    GArrowUInt32ArrayClass;\n-\n-/**\n- * GArrowUInt32Array:\n- *\n- * It wraps `arrow::UInt32Array`.\n- */\n-struct _GArrowUInt32Array\n-{\n-  /*< private >*/\n-  GArrowPrimitiveArray parent_instance;\n-};\n-\n-struct _GArrowUInt32ArrayClass\n-{\n-  GArrowPrimitiveArrayClass parent_class;\n-};\n-\n-GType garrow_uint32_array_get_type(void) G_GNUC_CONST;\n-\n-GArrowUInt32Array *garrow_uint32_array_new(gint64 length,\n-                                           GArrowBuffer *data,\n-                                           GArrowBuffer *null_bitmap,\n-                                           gint64 n_nulls);\n-\n-guint32 garrow_uint32_array_get_value(GArrowUInt32Array *array,\n-                                      gint64 i);\n-const guint32 *garrow_uint32_array_get_values(GArrowUInt32Array *array,\n-                                              gint64 *length);\n-\n-\n-#define GARROW_TYPE_INT64_ARRAY                 \\\n-  (garrow_int64_array_get_type())\n-#define GARROW_INT64_ARRAY(obj)                         \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n-                              GARROW_TYPE_INT64_ARRAY,  \\\n-                              GArrowInt64Array))\n-#define GARROW_INT64_ARRAY_CLASS(klass)                 \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n-                           GARROW_TYPE_INT64_ARRAY,     \\\n-                           GArrowInt64ArrayClass))\n-#define GARROW_IS_INT64_ARRAY(obj)                      \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                    \\\n-                              GARROW_TYPE_INT64_ARRAY))\n-#define GARROW_IS_INT64_ARRAY_CLASS(klass)              \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n-                           GARROW_TYPE_INT64_ARRAY))\n-#define GARROW_INT64_ARRAY_GET_CLASS(obj)               \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n-                             GARROW_TYPE_INT64_ARRAY,   \\\n-                             GArrowInt64ArrayClass))\n-\n-typedef struct _GArrowInt64Array         GArrowInt64Array;\n-typedef struct _GArrowInt64ArrayClass    GArrowInt64ArrayClass;\n-\n-/**\n- * GArrowInt64Array:\n- *\n- * It wraps `arrow::Int64Array`.\n- */\n-struct _GArrowInt64Array\n-{\n-  /*< private >*/\n-  GArrowPrimitiveArray parent_instance;\n-};\n-\n-struct _GArrowInt64ArrayClass\n-{\n-  GArrowPrimitiveArrayClass parent_class;\n-};\n-\n-GType garrow_int64_array_get_type(void) G_GNUC_CONST;\n-\n-GArrowInt64Array *garrow_int64_array_new(gint64 length,\n-                                         GArrowBuffer *data,\n-                                         GArrowBuffer *null_bitmap,\n-                                         gint64 n_nulls);\n-\n-gint64 garrow_int64_array_get_value(GArrowInt64Array *array,\n-                                    gint64 i);\n-const gint64 *garrow_int64_array_get_values(GArrowInt64Array *array,\n-                                            gint64 *length);\n-\n-\n-#define GARROW_TYPE_UINT64_ARRAY                \\\n-  (garrow_uint64_array_get_type())\n-#define GARROW_UINT64_ARRAY(obj)                        \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n-                              GARROW_TYPE_UINT64_ARRAY, \\\n-                              GArrowUInt64Array))\n-#define GARROW_UINT64_ARRAY_CLASS(klass)                \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n-                           GARROW_TYPE_UINT64_ARRAY,    \\\n-                           GArrowUInt64ArrayClass))\n-#define GARROW_IS_UINT64_ARRAY(obj)                             \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n-                              GARROW_TYPE_UINT64_ARRAY))\n-#define GARROW_IS_UINT64_ARRAY_CLASS(klass)             \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n-                           GARROW_TYPE_UINT64_ARRAY))\n-#define GARROW_UINT64_ARRAY_GET_CLASS(obj)              \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n-                             GARROW_TYPE_UINT64_ARRAY,  \\\n-                             GArrowUInt64ArrayClass))\n-\n-typedef struct _GArrowUInt64Array         GArrowUInt64Array;\n-typedef struct _GArrowUInt64ArrayClass    GArrowUInt64ArrayClass;\n-\n-/**\n- * GArrowUInt64Array:\n- *\n- * It wraps `arrow::UInt64Array`.\n- */\n-struct _GArrowUInt64Array\n-{\n-  /*< private >*/\n-  GArrowPrimitiveArray parent_instance;\n-};\n-\n-struct _GArrowUInt64ArrayClass\n-{\n-  GArrowPrimitiveArrayClass parent_class;\n-};\n-\n-GType garrow_uint64_array_get_type(void) G_GNUC_CONST;\n-\n-GArrowUInt64Array *garrow_uint64_array_new(gint64 length,\n-                                           GArrowBuffer *data,\n-                                           GArrowBuffer *null_bitmap,\n-                                           gint64 n_nulls);\n-\n-guint64 garrow_uint64_array_get_value(GArrowUInt64Array *array,\n-                                      gint64 i);\n-const guint64 *garrow_uint64_array_get_values(GArrowUInt64Array *array,\n-                                              gint64 *length);\n-\n-\n-#define GARROW_TYPE_FLOAT_ARRAY                 \\\n-  (garrow_float_array_get_type())\n-#define GARROW_FLOAT_ARRAY(obj)                         \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n-                              GARROW_TYPE_FLOAT_ARRAY,  \\\n-                              GArrowFloatArray))\n-#define GARROW_FLOAT_ARRAY_CLASS(klass)                 \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n-                           GARROW_TYPE_FLOAT_ARRAY,     \\\n-                           GArrowFloatArrayClass))\n-#define GARROW_IS_FLOAT_ARRAY(obj)                      \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                    \\\n-                              GARROW_TYPE_FLOAT_ARRAY))\n-#define GARROW_IS_FLOAT_ARRAY_CLASS(klass)              \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n-                           GARROW_TYPE_FLOAT_ARRAY))\n-#define GARROW_FLOAT_ARRAY_GET_CLASS(obj)               \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n-                             GARROW_TYPE_FLOAT_ARRAY,   \\\n-                             GArrowFloatArrayClass))\n-\n-typedef struct _GArrowFloatArray         GArrowFloatArray;\n-typedef struct _GArrowFloatArrayClass    GArrowFloatArrayClass;\n-\n-/**\n- * GArrowFloatArray:\n- *\n- * It wraps `arrow::FloatArray`.\n- */\n-struct _GArrowFloatArray\n-{\n-  /*< private >*/\n-  GArrowPrimitiveArray parent_instance;\n-};\n-\n-struct _GArrowFloatArrayClass\n-{\n-  GArrowPrimitiveArrayClass parent_class;\n-};\n-\n-GType garrow_float_array_get_type(void) G_GNUC_CONST;\n-\n-GArrowFloatArray *garrow_float_array_new(gint64 length,\n-                                         GArrowBuffer *data,\n-                                         GArrowBuffer *null_bitmap,\n-                                         gint64 n_nulls);\n-\n-gfloat garrow_float_array_get_value(GArrowFloatArray *array,\n-                                    gint64 i);\n-const gfloat *garrow_float_array_get_values(GArrowFloatArray *array,\n-                                            gint64 *length);\n-\n-\n-#define GARROW_TYPE_DOUBLE_ARRAY                \\\n-  (garrow_double_array_get_type())\n-#define GARROW_DOUBLE_ARRAY(obj)                        \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n-                              GARROW_TYPE_DOUBLE_ARRAY, \\\n-                              GArrowDoubleArray))\n-#define GARROW_DOUBLE_ARRAY_CLASS(klass)                \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n-                           GARROW_TYPE_DOUBLE_ARRAY,    \\\n-                           GArrowDoubleArrayClass))\n-#define GARROW_IS_DOUBLE_ARRAY(obj)                             \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n-                              GARROW_TYPE_DOUBLE_ARRAY))\n-#define GARROW_IS_DOUBLE_ARRAY_CLASS(klass)             \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n-                           GARROW_TYPE_DOUBLE_ARRAY))\n-#define GARROW_DOUBLE_ARRAY_GET_CLASS(obj)              \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n-                             GARROW_TYPE_DOUBLE_ARRAY,  \\\n-                             GArrowDoubleArrayClass))\n-\n-typedef struct _GArrowDoubleArray         GArrowDoubleArray;\n-typedef struct _GArrowDoubleArrayClass    GArrowDoubleArrayClass;\n-\n-/**\n- * GArrowDoubleArray:\n- *\n- * It wraps `arrow::DoubleArray`.\n- */\n-struct _GArrowDoubleArray\n-{\n-  /*< private >*/\n-  GArrowPrimitiveArray parent_instance;\n-};\n-\n-struct _GArrowDoubleArrayClass\n-{\n-  GArrowPrimitiveArrayClass parent_class;\n-};\n-\n-GType garrow_double_array_get_type(void) G_GNUC_CONST;\n-\n-GArrowDoubleArray *garrow_double_array_new(gint64 length,\n-                                           GArrowBuffer *data,\n-                                           GArrowBuffer *null_bitmap,\n-                                           gint64 n_nulls);\n-\n-gdouble garrow_double_array_get_value(GArrowDoubleArray *array,\n-                                      gint64 i);\n-const gdouble *garrow_double_array_get_values(GArrowDoubleArray *array,\n-                                              gint64 *length);\n-\n-\n-#define GARROW_TYPE_BINARY_ARRAY                \\\n-  (garrow_binary_array_get_type())\n-#define GARROW_BINARY_ARRAY(obj)                        \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n-                              GARROW_TYPE_BINARY_ARRAY, \\\n-                              GArrowBinaryArray))\n-#define GARROW_BINARY_ARRAY_CLASS(klass)                \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n-                           GARROW_TYPE_BINARY_ARRAY,    \\\n-                           GArrowBinaryArrayClass))\n-#define GARROW_IS_BINARY_ARRAY(obj)                             \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n-                              GARROW_TYPE_BINARY_ARRAY))\n-#define GARROW_IS_BINARY_ARRAY_CLASS(klass)             \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n-                           GARROW_TYPE_BINARY_ARRAY))\n-#define GARROW_BINARY_ARRAY_GET_CLASS(obj)              \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n-                             GARROW_TYPE_BINARY_ARRAY,  \\\n-                             GArrowBinaryArrayClass))\n-\n-typedef struct _GArrowBinaryArray         GArrowBinaryArray;\n-typedef struct _GArrowBinaryArrayClass    GArrowBinaryArrayClass;\n-\n-/**\n- * GArrowBinaryArray:\n- *\n- * It wraps `arrow::BinaryArray`.\n- */\n-struct _GArrowBinaryArray\n-{\n-  /*< private >*/\n-  GArrowArray parent_instance;\n-};\n-\n-struct _GArrowBinaryArrayClass\n-{\n-  GArrowArrayClass parent_class;\n-};\n-\n-GType garrow_binary_array_get_type(void) G_GNUC_CONST;\n-\n-GArrowBinaryArray *garrow_binary_array_new(gint64 length,\n-                                           GArrowBuffer *value_offsets,\n-                                           GArrowBuffer *data,\n-                                           GArrowBuffer *null_bitmap,\n-                                           gint64 n_nulls);\n-\n-GBytes *garrow_binary_array_get_value(GArrowBinaryArray *array,\n-                                      gint64 i);\n-GArrowBuffer *garrow_binary_array_get_buffer(GArrowBinaryArray *array);\n-GArrowBuffer *garrow_binary_array_get_offsets_buffer(GArrowBinaryArray *array);\n-\n-#define GARROW_TYPE_STRING_ARRAY                \\\n-  (garrow_string_array_get_type())\n-#define GARROW_STRING_ARRAY(obj)                        \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n-                              GARROW_TYPE_STRING_ARRAY, \\\n-                              GArrowStringArray))\n-#define GARROW_STRING_ARRAY_CLASS(klass)                \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n-                           GARROW_TYPE_STRING_ARRAY,    \\\n-                           GArrowStringArrayClass))\n-#define GARROW_IS_STRING_ARRAY(obj)                             \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n-                              GARROW_TYPE_STRING_ARRAY))\n-#define GARROW_IS_STRING_ARRAY_CLASS(klass)             \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n-                           GARROW_TYPE_STRING_ARRAY))\n-#define GARROW_STRING_ARRAY_GET_CLASS(obj)              \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n-                             GARROW_TYPE_STRING_ARRAY,  \\\n-                             GArrowStringArrayClass))\n-\n-typedef struct _GArrowStringArray         GArrowStringArray;\n-typedef struct _GArrowStringArrayClass    GArrowStringArrayClass;\n-\n-/**\n- * GArrowStringArray:\n- *\n- * It wraps `arrow::StringArray`.\n- */\n-struct _GArrowStringArray\n-{\n-  /*< private >*/\n-  GArrowBinaryArray parent_instance;\n-};\n-\n-struct _GArrowStringArrayClass\n-{\n-  GArrowBinaryArrayClass parent_class;\n-};\n-\n-GType garrow_string_array_get_type(void) G_GNUC_CONST;\n-\n-GArrowStringArray *garrow_string_array_new(gint64 length,\n-                                           GArrowBuffer *value_offsets,\n-                                           GArrowBuffer *data,\n-                                           GArrowBuffer *null_bitmap,\n-                                           gint64 n_nulls);\n-\n-gchar *garrow_string_array_get_string(GArrowStringArray *array,\n-                                      gint64 i);\n-\n-\n-#define GARROW_TYPE_DATE32_ARRAY                \\\n-  (garrow_date32_array_get_type())\n-#define GARROW_DATE32_ARRAY(obj)                        \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n-                              GARROW_TYPE_DATE32_ARRAY, \\\n-                              GArrowDate32Array))\n-#define GARROW_DATE32_ARRAY_CLASS(klass)                \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n-                           GARROW_TYPE_DATE32_ARRAY,    \\\n-                           GArrowDate32ArrayClass))\n-#define GARROW_IS_DATE32_ARRAY(obj)                             \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n-                              GARROW_TYPE_DATE32_ARRAY))\n-#define GARROW_IS_DATE32_ARRAY_CLASS(klass)             \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n-                           GARROW_TYPE_DATE32_ARRAY))\n-#define GARROW_DATE32_ARRAY_GET_CLASS(obj)              \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n-                             GARROW_TYPE_DATE32_ARRAY,  \\\n-                             GArrowDate32ArrayClass))\n-\n-typedef struct _GArrowDate32Array         GArrowDate32Array;\n-typedef struct _GArrowDate32ArrayClass    GArrowDate32ArrayClass;\n-\n-/**\n- * GArrowDate32Array:\n- *\n- * It wraps `arrow::Date32Array`.\n- */\n-struct _GArrowDate32Array\n-{\n-  /*< private >*/\n-  GArrowPrimitiveArray parent_instance;\n-};\n-\n-struct _GArrowDate32ArrayClass\n-{\n-  GArrowPrimitiveArrayClass parent_class;\n-};\n-\n-GType garrow_date32_array_get_type(void) G_GNUC_CONST;\n-\n-GArrowDate32Array *garrow_date32_array_new(gint64 length,\n-                                           GArrowBuffer *data,\n-                                           GArrowBuffer *null_bitmap,\n-                                           gint64 n_nulls);\n-\n-gint32 garrow_date32_array_get_value(GArrowDate32Array *array,\n-                                     gint64 i);\n-const gint32 *garrow_date32_array_get_values(GArrowDate32Array *array,\n-                                             gint64 *length);\n-\n-\n-#define GARROW_TYPE_DATE64_ARRAY                \\\n-  (garrow_date64_array_get_type())\n-#define GARROW_DATE64_ARRAY(obj)                        \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n-                              GARROW_TYPE_DATE64_ARRAY, \\\n-                              GArrowDate64Array))\n-#define GARROW_DATE64_ARRAY_CLASS(klass)                \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n-                           GARROW_TYPE_DATE64_ARRAY,    \\\n-                           GArrowDate64ArrayClass))\n-#define GARROW_IS_DATE64_ARRAY(obj)                             \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n-                              GARROW_TYPE_DATE64_ARRAY))\n-#define GARROW_IS_DATE64_ARRAY_CLASS(klass)             \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n-                           GARROW_TYPE_DATE64_ARRAY))\n-#define GARROW_DATE64_ARRAY_GET_CLASS(obj)              \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n-                             GARROW_TYPE_DATE64_ARRAY,  \\\n-                             GArrowDate64ArrayClass))\n-\n-typedef struct _GArrowDate64Array         GArrowDate64Array;\n-typedef struct _GArrowDate64ArrayClass    GArrowDate64ArrayClass;\n-\n-/**\n- * GArrowDate64Array:\n- *\n- * It wraps `arrow::Date64Array`.\n- */\n-struct _GArrowDate64Array\n-{\n-  /*< private >*/\n-  GArrowPrimitiveArray parent_instance;\n-};\n-\n-struct _GArrowDate64ArrayClass\n-{\n-  GArrowPrimitiveArrayClass parent_class;\n-};\n-\n-GType garrow_date64_array_get_type(void) G_GNUC_CONST;\n-\n-GArrowDate64Array *garrow_date64_array_new(gint64 length,\n-                                           GArrowBuffer *data,\n-                                           GArrowBuffer *null_bitmap,\n-                                           gint64 n_nulls);\n-\n-gint64 garrow_date64_array_get_value(GArrowDate64Array *array,\n-                                     gint64 i);\n-const gint64 *garrow_date64_array_get_values(GArrowDate64Array *array,\n-                                             gint64 *length);\n-\n-\n-#define GARROW_TYPE_TIMESTAMP_ARRAY             \\\n-  (garrow_timestamp_array_get_type())\n-#define GARROW_TIMESTAMP_ARRAY(obj)                             \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                            \\\n-                              GARROW_TYPE_TIMESTAMP_ARRAY,      \\\n-                              GArrowTimestampArray))\n-#define GARROW_TIMESTAMP_ARRAY_CLASS(klass)             \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n-                           GARROW_TYPE_TIMESTAMP_ARRAY, \\\n-                           GArrowTimestampArrayClass))\n-#define GARROW_IS_TIMESTAMP_ARRAY(obj)                          \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n-                              GARROW_TYPE_TIMESTAMP_ARRAY))\n-#define GARROW_IS_TIMESTAMP_ARRAY_CLASS(klass)                  \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                             \\\n-                           GARROW_TYPE_TIMESTAMP_ARRAY))\n-#define GARROW_TIMESTAMP_ARRAY_GET_CLASS(obj)                   \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                             \\\n-                             GARROW_TYPE_TIMESTAMP_ARRAY,       \\\n-                             GArrowTimestampArrayClass))\n-\n-typedef struct _GArrowTimestampArray         GArrowTimestampArray;\n-typedef struct _GArrowTimestampArrayClass    GArrowTimestampArrayClass;\n-\n-/**\n- * GArrowTimestampArray:\n- *\n- * It wraps `arrow::TimestampArray`.\n- */\n-struct _GArrowTimestampArray\n-{\n-  /*< private >*/\n-  GArrowPrimitiveArray parent_instance;\n-};\n-\n-struct _GArrowTimestampArrayClass\n-{\n-  GArrowPrimitiveArrayClass parent_class;\n-};\n-\n-GType garrow_timestamp_array_get_type(void) G_GNUC_CONST;\n-\n-GArrowTimestampArray *garrow_timestamp_array_new(GArrowTimestampDataType *data_type,\n-                                                 gint64 length,\n-                                                 GArrowBuffer *data,\n-                                                 GArrowBuffer *null_bitmap,\n-                                                 gint64 n_nulls);\n-\n-gint64 garrow_timestamp_array_get_value(GArrowTimestampArray *array,\n-                                        gint64 i);\n-const gint64 *garrow_timestamp_array_get_values(GArrowTimestampArray *array,\n-                                                gint64 *length);\n-\n-\n-#define GARROW_TYPE_TIME32_ARRAY                \\\n-  (garrow_time32_array_get_type())\n-#define GARROW_TIME32_ARRAY(obj)                        \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n-                              GARROW_TYPE_TIME32_ARRAY, \\\n-                              GArrowTime32Array))\n-#define GARROW_TIME32_ARRAY_CLASS(klass)                \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n-                           GARROW_TYPE_TIME32_ARRAY,    \\\n-                           GArrowTime32ArrayClass))\n-#define GARROW_IS_TIME32_ARRAY(obj)                             \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n-                              GARROW_TYPE_TIME32_ARRAY))\n-#define GARROW_IS_TIME32_ARRAY_CLASS(klass)             \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n-                           GARROW_TYPE_TIME32_ARRAY))\n-#define GARROW_TIME32_ARRAY_GET_CLASS(obj)              \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n-                             GARROW_TYPE_TIME32_ARRAY,  \\\n-                             GArrowTime32ArrayClass))\n-\n-typedef struct _GArrowTime32Array         GArrowTime32Array;\n-typedef struct _GArrowTime32ArrayClass    GArrowTime32ArrayClass;\n-\n-/**\n- * GArrowTime32Array:\n- *\n- * It wraps `arrow::Time32Array`.\n- */\n-struct _GArrowTime32Array\n-{\n-  /*< private >*/\n-  GArrowPrimitiveArray parent_instance;\n-};\n-\n-struct _GArrowTime32ArrayClass\n-{\n-  GArrowPrimitiveArrayClass parent_class;\n-};\n-\n-GType garrow_time32_array_get_type(void) G_GNUC_CONST;\n-\n-GArrowTime32Array *garrow_time32_array_new(GArrowTime32DataType *data_type,\n-                                           gint64 length,\n-                                           GArrowBuffer *data,\n-                                           GArrowBuffer *null_bitmap,\n-                                           gint64 n_nulls);\n-\n-gint32 garrow_time32_array_get_value(GArrowTime32Array *array,\n-                                     gint64 i);\n-const gint32 *garrow_time32_array_get_values(GArrowTime32Array *array,\n-                                             gint64 *length);\n-\n-\n-#define GARROW_TYPE_TIME64_ARRAY                \\\n-  (garrow_time64_array_get_type())\n-#define GARROW_TIME64_ARRAY(obj)                        \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n-                              GARROW_TYPE_TIME64_ARRAY, \\\n-                              GArrowTime64Array))\n-#define GARROW_TIME64_ARRAY_CLASS(klass)                \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n-                           GARROW_TYPE_TIME64_ARRAY,    \\\n-                           GArrowTime64ArrayClass))\n-#define GARROW_IS_TIME64_ARRAY(obj)                             \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n-                              GARROW_TYPE_TIME64_ARRAY))\n-#define GARROW_IS_TIME64_ARRAY_CLASS(klass)             \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n-                           GARROW_TYPE_TIME64_ARRAY))\n-#define GARROW_TIME64_ARRAY_GET_CLASS(obj)              \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n-                             GARROW_TYPE_TIME64_ARRAY,  \\\n-                             GArrowTime64ArrayClass))\n-\n-typedef struct _GArrowTime64Array         GArrowTime64Array;\n-typedef struct _GArrowTime64ArrayClass    GArrowTime64ArrayClass;\n-\n-/**\n- * GArrowTime64Array:\n- *\n- * It wraps `arrow::Time64Array`.\n- */\n-struct _GArrowTime64Array\n-{\n-  /*< private >*/\n-  GArrowPrimitiveArray parent_instance;\n-};\n-\n-struct _GArrowTime64ArrayClass\n-{\n-  GArrowPrimitiveArrayClass parent_class;\n-};\n-\n-GType garrow_time64_array_get_type(void) G_GNUC_CONST;\n-\n-GArrowTime64Array *garrow_time64_array_new(GArrowTime64DataType *data_type,\n-                                           gint64 length,\n-                                           GArrowBuffer *data,\n-                                           GArrowBuffer *null_bitmap,\n-                                           gint64 n_nulls);\n-\n-gint64 garrow_time64_array_get_value(GArrowTime64Array *array,\n-                                     gint64 i);\n-const gint64 *garrow_time64_array_get_values(GArrowTime64Array *array,\n-                                             gint64 *length);\n-\n-\n-#define GARROW_TYPE_LIST_ARRAY                  \\\n-  (garrow_list_array_get_type())\n-#define GARROW_LIST_ARRAY(obj)                          \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n-                              GARROW_TYPE_LIST_ARRAY,   \\\n-                              GArrowListArray))\n-#define GARROW_LIST_ARRAY_CLASS(klass)                  \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n-                           GARROW_TYPE_LIST_ARRAY,      \\\n-                           GArrowListArrayClass))\n-#define GARROW_IS_LIST_ARRAY(obj)                       \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                    \\\n-                              GARROW_TYPE_LIST_ARRAY))\n-#define GARROW_IS_LIST_ARRAY_CLASS(klass)               \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n-                           GARROW_TYPE_LIST_ARRAY))\n-#define GARROW_LIST_ARRAY_GET_CLASS(obj)                \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n-                             GARROW_TYPE_LIST_ARRAY,    \\\n-                             GArrowListArrayClass))\n-\n-typedef struct _GArrowListArray         GArrowListArray;\n-typedef struct _GArrowListArrayClass    GArrowListArrayClass;\n-\n-/**\n- * GArrowListArray:\n- *\n- * It wraps `arrow::ListArray`.\n- */\n-struct _GArrowListArray\n-{\n-  /*< private >*/\n-  GArrowArray parent_instance;\n-};\n-\n-struct _GArrowListArrayClass\n-{\n-  GArrowArrayClass parent_class;\n-};\n-\n-GType garrow_list_array_get_type(void) G_GNUC_CONST;\n-\n-GArrowListArray *garrow_list_array_new(gint64 length,\n-                                       GArrowBuffer *value_offsets,\n-                                       GArrowArray *values,\n-                                       GArrowBuffer *null_bitmap,\n-                                       gint64 n_nulls);\n-\n-GArrowDataType *garrow_list_array_get_value_type(GArrowListArray *array);\n-GArrowArray *garrow_list_array_get_value(GArrowListArray *array,\n-                                         gint64 i);\n-\n-\n-#define GARROW_TYPE_STRUCT_ARRAY                \\\n-  (garrow_struct_array_get_type())\n-#define GARROW_STRUCT_ARRAY(obj)                        \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n-                              GARROW_TYPE_STRUCT_ARRAY, \\\n-                              GArrowStructArray))\n-#define GARROW_STRUCT_ARRAY_CLASS(klass)                \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n-                           GARROW_TYPE_STRUCT_ARRAY,    \\\n-                           GArrowStructArrayClass))\n-#define GARROW_IS_STRUCT_ARRAY(obj)                             \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n-                              GARROW_TYPE_STRUCT_ARRAY))\n-#define GARROW_IS_STRUCT_ARRAY_CLASS(klass)             \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n-                           GARROW_TYPE_STRUCT_ARRAY))\n-#define GARROW_STRUCT_ARRAY_GET_CLASS(obj)              \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n-                             GARROW_TYPE_STRUCT_ARRAY,  \\\n-                             GArrowStructArrayClass))\n-\n-typedef struct _GArrowStructArray         GArrowStructArray;\n-typedef struct _GArrowStructArrayClass    GArrowStructArrayClass;\n-\n-/**\n- * GArrowStructArray:\n- *\n- * It wraps `arrow::StructArray`.\n- */\n-struct _GArrowStructArray\n-{\n-  /*< private >*/\n-  GArrowArray parent_instance;\n-};\n-\n-struct _GArrowStructArrayClass\n-{\n-  GArrowArrayClass parent_class;\n-};\n-\n-GType garrow_struct_array_get_type(void) G_GNUC_CONST;\n-\n-GArrowStructArray *garrow_struct_array_new(GArrowDataType *data_type,\n-                                           gint64 length,\n-                                           GList *children,\n-                                           GArrowBuffer *null_bitmap,\n-                                           gint64 n_nulls);\n-\n-GArrowArray *garrow_struct_array_get_field(GArrowStructArray *array,\n-                                           gint i);\n-GList *garrow_struct_array_get_fields(GArrowStructArray *array);\n-\n-G_END_DECLS\n+#include <arrow-glib/basic-array.h>\n+#include <arrow-glib/composite-array.h>\ndiff --git a/c_glib/arrow-glib/array.hpp b/c_glib/arrow-glib/array.hpp\nindex d2dff22c4..e575c4253 100644\n--- a/c_glib/arrow-glib/array.hpp\n+++ b/c_glib/arrow-glib/array.hpp\n@@ -19,9 +19,5 @@\n \n #pragma once\n \n-#include <arrow/api.h>\n-\n-#include <arrow-glib/array.h>\n-\n-GArrowArray *garrow_array_new_raw(std::shared_ptr<arrow::Array> *arrow_array);\n-std::shared_ptr<arrow::Array> garrow_array_get_raw(GArrowArray *array);\n+#include <arrow-glib/basic-array.hpp>\n+#include <arrow-glib/composite-array.h>\ndiff --git a/c_glib/arrow-glib/array.cpp b/c_glib/arrow-glib/basic-array.cpp\nsimilarity index 90%\nrename from c_glib/arrow-glib/array.cpp\nrename to c_glib/arrow-glib/basic-array.cpp\nindex 4945ca3cf..0698a0409 100644\n--- a/c_glib/arrow-glib/array.cpp\n+++ b/c_glib/arrow-glib/basic-array.cpp\n@@ -24,7 +24,7 @@\n #include <arrow-glib/array.hpp>\n #include <arrow-glib/buffer.hpp>\n #include <arrow-glib/compute.hpp>\n-#include <arrow-glib/data-type.hpp>\n+#include <arrow-glib/basic-data-type.hpp>\n #include <arrow-glib/error.hpp>\n #include <arrow-glib/type.hpp>\n \n@@ -86,9 +86,9 @@ garrow_primitive_array_new(GArrowDataType *data_type,\n G_BEGIN_DECLS\n \n /**\n- * SECTION: array\n- * @section_id: array-classes\n- * @title: Array classes\n+ * SECTION: basic-array\n+ * @section_id: basic-array-classes\n+ * @title: Basic array classes\n  * @include: arrow-glib/arrow-glib.h\n  *\n  * #GArrowArray is a base class for all array classes such as\n@@ -194,15 +194,6 @@ G_BEGIN_DECLS\n  * nanoseconds since midnight in 64-bit signed integer array. It can\n  * store zero or more time data. If you don't have Arrow format data,\n  * you need to use #GArrowTime64ArrayBuilder to create a new array.\n- *\n- * #GArrowListArray is a class for list array. It can store zero or\n- * more list data. If you don't have Arrow format data, you need to\n- * use #GArrowListArrayBuilder to create a new array.\n- *\n- * #GArrowStructArray is a class for struct array. It can store zero\n- * or more structs. One struct has zero or more fields. If you don't\n- * have Arrow format data, you need to use #GArrowStructArrayBuilder\n- * to create a new array.\n  */\n \n typedef struct GArrowArrayPrivate_ {\n@@ -2028,195 +2019,6 @@ garrow_time64_array_get_values(GArrowTime64Array *array,\n   return reinterpret_cast<const gint64 *>(values);\n }\n \n-\n-G_DEFINE_TYPE(GArrowListArray,               \\\n-              garrow_list_array,             \\\n-              GARROW_TYPE_ARRAY)\n-\n-static void\n-garrow_list_array_init(GArrowListArray *object)\n-{\n-}\n-\n-static void\n-garrow_list_array_class_init(GArrowListArrayClass *klass)\n-{\n-}\n-\n-/**\n- * garrow_list_array_new:\n- * @length: The number of elements.\n- * @value_offsets: The offsets of @values in Arrow format.\n- * @values: The values as #GArrowArray.\n- * @null_bitmap: (nullable): The bitmap that shows null elements. The\n- *   N-th element is null when the N-th bit is 0, not null otherwise.\n- *   If the array has no null elements, the bitmap must be %NULL and\n- *   @n_nulls is 0.\n- * @n_nulls: The number of null elements. If -1 is specified, the\n- *   number of nulls are computed from @null_bitmap.\n- *\n- * Returns: A newly created #GArrowListArray.\n- *\n- * Since: 0.4.0\n- */\n-GArrowListArray *\n-garrow_list_array_new(gint64 length,\n-                      GArrowBuffer *value_offsets,\n-                      GArrowArray *values,\n-                      GArrowBuffer *null_bitmap,\n-                      gint64 n_nulls)\n-{\n-  const auto arrow_value_offsets = garrow_buffer_get_raw(value_offsets);\n-  const auto arrow_values = garrow_array_get_raw(values);\n-  const auto arrow_bitmap = garrow_buffer_get_raw(null_bitmap);\n-  auto arrow_data_type = arrow::list(arrow_values->type());\n-  auto arrow_list_array =\n-    std::make_shared<arrow::ListArray>(arrow_data_type,\n-                                       length,\n-                                       arrow_value_offsets,\n-                                       arrow_values,\n-                                       arrow_bitmap,\n-                                       n_nulls);\n-  auto arrow_array =\n-    std::static_pointer_cast<arrow::Array>(arrow_list_array);\n-  return GARROW_LIST_ARRAY(garrow_array_new_raw(&arrow_array));\n-}\n-\n-/**\n- * garrow_list_array_get_value_type:\n- * @array: A #GArrowListArray.\n- *\n- * Returns: (transfer full): The data type of value in each list.\n- */\n-GArrowDataType *\n-garrow_list_array_get_value_type(GArrowListArray *array)\n-{\n-  auto arrow_array = garrow_array_get_raw(GARROW_ARRAY(array));\n-  auto arrow_list_array =\n-    static_cast<arrow::ListArray *>(arrow_array.get());\n-  auto arrow_value_type = arrow_list_array->value_type();\n-  return garrow_data_type_new_raw(&arrow_value_type);\n-}\n-\n-/**\n- * garrow_list_array_get_value:\n- * @array: A #GArrowListArray.\n- * @i: The index of the target value.\n- *\n- * Returns: (transfer full): The i-th list.\n- */\n-GArrowArray *\n-garrow_list_array_get_value(GArrowListArray *array,\n-                            gint64 i)\n-{\n-  auto arrow_array = garrow_array_get_raw(GARROW_ARRAY(array));\n-  auto arrow_list_array =\n-    static_cast<arrow::ListArray *>(arrow_array.get());\n-  auto arrow_list =\n-    arrow_list_array->values()->Slice(arrow_list_array->value_offset(i),\n-                                      arrow_list_array->value_length(i));\n-  return garrow_array_new_raw(&arrow_list);\n-}\n-\n-\n-G_DEFINE_TYPE(GArrowStructArray,               \\\n-              garrow_struct_array,             \\\n-              GARROW_TYPE_ARRAY)\n-\n-static void\n-garrow_struct_array_init(GArrowStructArray *object)\n-{\n-}\n-\n-static void\n-garrow_struct_array_class_init(GArrowStructArrayClass *klass)\n-{\n-}\n-\n-/**\n- * garrow_struct_array_new:\n- * @data_type: The data type of the struct.\n- * @length: The number of elements.\n- * @children: (element-type GArrowArray): The arrays for each field\n- *   as #GList of #GArrowArray.\n- * @null_bitmap: (nullable): The bitmap that shows null elements. The\n- *   N-th element is null when the N-th bit is 0, not null otherwise.\n- *   If the array has no null elements, the bitmap must be %NULL and\n- *   @n_nulls is 0.\n- * @n_nulls: The number of null elements. If -1 is specified, the\n- *   number of nulls are computed from @null_bitmap.\n- *\n- * Returns: A newly created #GArrowStructArray.\n- *\n- * Since: 0.4.0\n- */\n-GArrowStructArray *\n-garrow_struct_array_new(GArrowDataType *data_type,\n-                        gint64 length,\n-                        GList *children,\n-                        GArrowBuffer *null_bitmap,\n-                        gint64 n_nulls)\n-{\n-  const auto arrow_data_type = garrow_data_type_get_raw(data_type);\n-  std::vector<std::shared_ptr<arrow::Array>> arrow_children;\n-  for (GList *node = children; node; node = node->next) {\n-    GArrowArray *child = GARROW_ARRAY(node->data);\n-    arrow_children.push_back(garrow_array_get_raw(child));\n-  }\n-  const auto arrow_bitmap = garrow_buffer_get_raw(null_bitmap);\n-  auto arrow_struct_array =\n-    std::make_shared<arrow::StructArray>(arrow_data_type,\n-                                         length,\n-                                         arrow_children,\n-                                         arrow_bitmap,\n-                                         n_nulls);\n-  auto arrow_array =\n-    std::static_pointer_cast<arrow::Array>(arrow_struct_array);\n-  return GARROW_STRUCT_ARRAY(garrow_array_new_raw(&arrow_array));\n-}\n-\n-/**\n- * garrow_struct_array_get_field\n- * @array: A #GArrowStructArray.\n- * @i: The index of the field in the struct.\n- *\n- * Returns: (transfer full): The i-th field.\n- */\n-GArrowArray *\n-garrow_struct_array_get_field(GArrowStructArray *array,\n-                              gint i)\n-{\n-  auto arrow_array = garrow_array_get_raw(GARROW_ARRAY(array));\n-  auto arrow_struct_array =\n-    static_cast<arrow::StructArray *>(arrow_array.get());\n-  auto arrow_field = arrow_struct_array->field(i);\n-  return garrow_array_new_raw(&arrow_field);\n-}\n-\n-/**\n- * garrow_struct_array_get_fields\n- * @array: A #GArrowStructArray.\n- *\n- * Returns: (element-type GArrowArray) (transfer full):\n- *   The fields in the struct.\n- */\n-GList *\n-garrow_struct_array_get_fields(GArrowStructArray *array)\n-{\n-  const auto arrow_array = garrow_array_get_raw(GARROW_ARRAY(array));\n-  const auto arrow_struct_array =\n-    static_cast<const arrow::StructArray *>(arrow_array.get());\n-\n-  GList *fields = NULL;\n-  for (int i = 0; i < arrow_struct_array->num_fields(); ++i) {\n-    auto arrow_field = arrow_struct_array->field(i);\n-    GArrowArray *field = garrow_array_new_raw(&arrow_field);\n-    fields = g_list_prepend(fields, field);\n-  }\n-\n-  return g_list_reverse(fields);\n-}\n-\n G_END_DECLS\n \n GArrowArray *\ndiff --git a/c_glib/arrow-glib/basic-array.h b/c_glib/arrow-glib/basic-array.h\nnew file mode 100644\nindex 000000000..c01a04f07\n--- /dev/null\n+++ b/c_glib/arrow-glib/basic-array.h\n@@ -0,0 +1,1115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#pragma once\n+\n+#include <arrow-glib/buffer.h>\n+#include <arrow-glib/compute.h>\n+#include <arrow-glib/basic-data-type.h>\n+\n+G_BEGIN_DECLS\n+\n+#define GARROW_TYPE_ARRAY (garrow_array_get_type())\n+G_DECLARE_DERIVABLE_TYPE(GArrowArray,\n+                         garrow_array,\n+                         GARROW,\n+                         ARRAY,\n+                         GObject)\n+struct _GArrowArrayClass\n+{\n+  GObjectClass parent_class;\n+};\n+\n+gboolean       garrow_array_equal       (GArrowArray *array,\n+                                         GArrowArray *other_array);\n+gboolean       garrow_array_equal_approx(GArrowArray *array,\n+                                         GArrowArray *other_array);\n+gboolean       garrow_array_equal_range (GArrowArray *array,\n+                                         gint64 start_index,\n+                                         GArrowArray *other_array,\n+                                         gint64 other_start_index,\n+                                         gint64 end_index);\n+\n+gboolean       garrow_array_is_null     (GArrowArray *array,\n+                                         gint64 i);\n+gboolean       garrow_array_is_valid    (GArrowArray *array,\n+                                         gint64 i);\n+gint64         garrow_array_get_length  (GArrowArray *array);\n+gint64         garrow_array_get_offset  (GArrowArray *array);\n+gint64         garrow_array_get_n_nulls (GArrowArray *array);\n+GArrowBuffer  *garrow_array_get_null_bitmap(GArrowArray *array);\n+GArrowDataType *garrow_array_get_value_data_type(GArrowArray *array);\n+GArrowType     garrow_array_get_value_type(GArrowArray *array);\n+GArrowArray   *garrow_array_slice       (GArrowArray *array,\n+                                         gint64 offset,\n+                                         gint64 length);\n+gchar         *garrow_array_to_string   (GArrowArray *array,\n+                                         GError **error);\n+\n+GArrowArray   *garrow_array_cast        (GArrowArray *array,\n+                                         GArrowDataType *target_data_type,\n+                                         GArrowCastOptions *options,\n+                                         GError **error);\n+\n+#define GARROW_TYPE_NULL_ARRAY                  \\\n+  (garrow_null_array_get_type())\n+#define GARROW_NULL_ARRAY(obj)                          \\\n+  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n+                              GARROW_TYPE_NULL_ARRAY,   \\\n+                              GArrowNullArray))\n+#define GARROW_NULL_ARRAY_CLASS(klass)                  \\\n+  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n+                           GARROW_TYPE_NULL_ARRAY,      \\\n+                           GArrowNullArrayClass))\n+#define GARROW_IS_NULL_ARRAY(obj)                       \\\n+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                    \\\n+                              GARROW_TYPE_NULL_ARRAY))\n+#define GARROW_IS_NULL_ARRAY_CLASS(klass)               \\\n+  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n+                           GARROW_TYPE_NULL_ARRAY))\n+#define GARROW_NULL_ARRAY_GET_CLASS(obj)                \\\n+  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n+                             GARROW_TYPE_NULL_ARRAY,    \\\n+                             GArrowNullArrayClass))\n+\n+typedef struct _GArrowNullArray         GArrowNullArray;\n+typedef struct _GArrowNullArrayClass    GArrowNullArrayClass;\n+\n+/**\n+ * GArrowNullArray:\n+ *\n+ * It wraps `arrow::NullArray`.\n+ */\n+struct _GArrowNullArray\n+{\n+  /*< private >*/\n+  GArrowArray parent_instance;\n+};\n+\n+struct _GArrowNullArrayClass\n+{\n+  GArrowArrayClass parent_class;\n+};\n+\n+GType garrow_null_array_get_type(void) G_GNUC_CONST;\n+\n+GArrowNullArray *garrow_null_array_new(gint64 length);\n+\n+\n+#define GARROW_TYPE_PRIMITIVE_ARRAY             \\\n+  (garrow_primitive_array_get_type())\n+#define GARROW_PRIMITIVE_ARRAY(obj)                             \\\n+  (G_TYPE_CHECK_INSTANCE_CAST((obj),                            \\\n+                              GARROW_TYPE_PRIMITIVE_ARRAY,      \\\n+                              GArrowPrimitiveArray))\n+#define GARROW_PRIMITIVE_ARRAY_CLASS(klass)             \\\n+  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n+                           GARROW_TYPE_PRIMITIVE_ARRAY, \\\n+                           GArrowPrimitiveArrayClass))\n+#define GARROW_IS_PRIMITIVE_ARRAY(obj)                          \\\n+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n+                              GARROW_TYPE_PRIMITIVE_ARRAY))\n+#define GARROW_IS_PRIMITIVE_ARRAY_CLASS(klass)                  \\\n+  (G_TYPE_CHECK_CLASS_TYPE((klass),                             \\\n+                           GARROW_TYPE_PRIMITIVE_ARRAY))\n+#define GARROW_PRIMITIVE_ARRAY_GET_CLASS(obj)                   \\\n+  (G_TYPE_INSTANCE_GET_CLASS((obj),                             \\\n+                             GARROW_TYPE_PRIMITIVE_ARRAY,       \\\n+                             GArrowPrimitiveArrayClass))\n+\n+typedef struct _GArrowPrimitiveArray         GArrowPrimitiveArray;\n+typedef struct _GArrowPrimitiveArrayClass    GArrowPrimitiveArrayClass;\n+\n+/**\n+ * GArrowPrimitiveArray:\n+ *\n+ * It wraps `arrow::PrimitiveArray`.\n+ */\n+struct _GArrowPrimitiveArray\n+{\n+  /*< private >*/\n+  GArrowArray parent_instance;\n+};\n+\n+struct _GArrowPrimitiveArrayClass\n+{\n+  GArrowArrayClass parent_class;\n+};\n+\n+GType garrow_primitive_array_get_type(void) G_GNUC_CONST;\n+\n+GArrowBuffer *garrow_primitive_array_get_buffer(GArrowPrimitiveArray *array);\n+\n+\n+#define GARROW_TYPE_BOOLEAN_ARRAY               \\\n+  (garrow_boolean_array_get_type())\n+#define GARROW_BOOLEAN_ARRAY(obj)                               \\\n+  (G_TYPE_CHECK_INSTANCE_CAST((obj),                            \\\n+                              GARROW_TYPE_BOOLEAN_ARRAY,        \\\n+                              GArrowBooleanArray))\n+#define GARROW_BOOLEAN_ARRAY_CLASS(klass)               \\\n+  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n+                           GARROW_TYPE_BOOLEAN_ARRAY,   \\\n+                           GArrowBooleanArrayClass))\n+#define GARROW_IS_BOOLEAN_ARRAY(obj)                            \\\n+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n+                              GARROW_TYPE_BOOLEAN_ARRAY))\n+#define GARROW_IS_BOOLEAN_ARRAY_CLASS(klass)            \\\n+  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n+                           GARROW_TYPE_BOOLEAN_ARRAY))\n+#define GARROW_BOOLEAN_ARRAY_GET_CLASS(obj)             \\\n+  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n+                             GARROW_TYPE_BOOLEAN_ARRAY, \\\n+                             GArrowBooleanArrayClass))\n+\n+typedef struct _GArrowBooleanArray         GArrowBooleanArray;\n+typedef struct _GArrowBooleanArrayClass    GArrowBooleanArrayClass;\n+\n+/**\n+ * GArrowBooleanArray:\n+ *\n+ * It wraps `arrow::BooleanArray`.\n+ */\n+struct _GArrowBooleanArray\n+{\n+  /*< private >*/\n+  GArrowPrimitiveArray parent_instance;\n+};\n+\n+struct _GArrowBooleanArrayClass\n+{\n+  GArrowPrimitiveArrayClass parent_class;\n+};\n+\n+GType          garrow_boolean_array_get_type  (void) G_GNUC_CONST;\n+\n+GArrowBooleanArray *garrow_boolean_array_new(gint64 length,\n+                                             GArrowBuffer *data,\n+                                             GArrowBuffer *null_bitmap,\n+                                             gint64 n_nulls);\n+\n+gboolean       garrow_boolean_array_get_value (GArrowBooleanArray *array,\n+                                               gint64 i);\n+gboolean      *garrow_boolean_array_get_values(GArrowBooleanArray *array,\n+                                               gint64 *length);\n+\n+\n+#define GARROW_TYPE_INT8_ARRAY                  \\\n+  (garrow_int8_array_get_type())\n+#define GARROW_INT8_ARRAY(obj)                          \\\n+  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n+                              GARROW_TYPE_INT8_ARRAY,   \\\n+                              GArrowInt8Array))\n+#define GARROW_INT8_ARRAY_CLASS(klass)                  \\\n+  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n+                           GARROW_TYPE_INT8_ARRAY,      \\\n+                           GArrowInt8ArrayClass))\n+#define GARROW_IS_INT8_ARRAY(obj)                       \\\n+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                    \\\n+                              GARROW_TYPE_INT8_ARRAY))\n+#define GARROW_IS_INT8_ARRAY_CLASS(klass)               \\\n+  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n+                           GARROW_TYPE_INT8_ARRAY))\n+#define GARROW_INT8_ARRAY_GET_CLASS(obj)                \\\n+  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n+                             GARROW_TYPE_INT8_ARRAY,    \\\n+                             GArrowInt8ArrayClass))\n+\n+typedef struct _GArrowInt8Array         GArrowInt8Array;\n+typedef struct _GArrowInt8ArrayClass    GArrowInt8ArrayClass;\n+\n+/**\n+ * GArrowInt8Array:\n+ *\n+ * It wraps `arrow::Int8Array`.\n+ */\n+struct _GArrowInt8Array\n+{\n+  /*< private >*/\n+  GArrowPrimitiveArray parent_instance;\n+};\n+\n+struct _GArrowInt8ArrayClass\n+{\n+  GArrowPrimitiveArrayClass parent_class;\n+};\n+\n+GType garrow_int8_array_get_type(void) G_GNUC_CONST;\n+\n+GArrowInt8Array *garrow_int8_array_new(gint64 length,\n+                                       GArrowBuffer *data,\n+                                       GArrowBuffer *null_bitmap,\n+                                       gint64 n_nulls);\n+\n+gint8 garrow_int8_array_get_value(GArrowInt8Array *array,\n+                                  gint64 i);\n+const gint8 *garrow_int8_array_get_values(GArrowInt8Array *array,\n+                                          gint64 *length);\n+\n+\n+#define GARROW_TYPE_UINT8_ARRAY                 \\\n+  (garrow_uint8_array_get_type())\n+#define GARROW_UINT8_ARRAY(obj)                         \\\n+  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n+                              GARROW_TYPE_UINT8_ARRAY,  \\\n+                              GArrowUInt8Array))\n+#define GARROW_UINT8_ARRAY_CLASS(klass)                 \\\n+  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n+                           GARROW_TYPE_UINT8_ARRAY,     \\\n+                           GArrowUInt8ArrayClass))\n+#define GARROW_IS_UINT8_ARRAY(obj)                      \\\n+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                    \\\n+                              GARROW_TYPE_UINT8_ARRAY))\n+#define GARROW_IS_UINT8_ARRAY_CLASS(klass)              \\\n+  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n+                           GARROW_TYPE_UINT8_ARRAY))\n+#define GARROW_UINT8_ARRAY_GET_CLASS(obj)               \\\n+  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n+                             GARROW_TYPE_UINT8_ARRAY,   \\\n+                             GArrowUInt8ArrayClass))\n+\n+typedef struct _GArrowUInt8Array         GArrowUInt8Array;\n+typedef struct _GArrowUInt8ArrayClass    GArrowUInt8ArrayClass;\n+\n+/**\n+ * GArrowUInt8Array:\n+ *\n+ * It wraps `arrow::UInt8Array`.\n+ */\n+struct _GArrowUInt8Array\n+{\n+  /*< private >*/\n+  GArrowPrimitiveArray parent_instance;\n+};\n+\n+struct _GArrowUInt8ArrayClass\n+{\n+  GArrowPrimitiveArrayClass parent_class;\n+};\n+\n+GType garrow_uint8_array_get_type(void) G_GNUC_CONST;\n+\n+GArrowUInt8Array *garrow_uint8_array_new(gint64 length,\n+                                         GArrowBuffer *data,\n+                                         GArrowBuffer *null_bitmap,\n+                                         gint64 n_nulls);\n+\n+guint8 garrow_uint8_array_get_value(GArrowUInt8Array *array,\n+                                    gint64 i);\n+const guint8 *garrow_uint8_array_get_values(GArrowUInt8Array *array,\n+                                            gint64 *length);\n+\n+\n+#define GARROW_TYPE_INT16_ARRAY                  \\\n+  (garrow_int16_array_get_type())\n+#define GARROW_INT16_ARRAY(obj)                         \\\n+  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n+                              GARROW_TYPE_INT16_ARRAY,  \\\n+                              GArrowInt16Array))\n+#define GARROW_INT16_ARRAY_CLASS(klass)                 \\\n+  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n+                           GARROW_TYPE_INT16_ARRAY,     \\\n+                           GArrowInt16ArrayClass))\n+#define GARROW_IS_INT16_ARRAY(obj)                      \\\n+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                    \\\n+                              GARROW_TYPE_INT16_ARRAY))\n+#define GARROW_IS_INT16_ARRAY_CLASS(klass)              \\\n+  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n+                           GARROW_TYPE_INT16_ARRAY))\n+#define GARROW_INT16_ARRAY_GET_CLASS(obj)               \\\n+  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n+                             GARROW_TYPE_INT16_ARRAY,   \\\n+                             GArrowInt16ArrayClass))\n+\n+typedef struct _GArrowInt16Array         GArrowInt16Array;\n+typedef struct _GArrowInt16ArrayClass    GArrowInt16ArrayClass;\n+\n+/**\n+ * GArrowInt16Array:\n+ *\n+ * It wraps `arrow::Int16Array`.\n+ */\n+struct _GArrowInt16Array\n+{\n+  /*< private >*/\n+  GArrowPrimitiveArray parent_instance;\n+};\n+\n+struct _GArrowInt16ArrayClass\n+{\n+  GArrowPrimitiveArrayClass parent_class;\n+};\n+\n+GType garrow_int16_array_get_type(void) G_GNUC_CONST;\n+\n+GArrowInt16Array *garrow_int16_array_new(gint64 length,\n+                                         GArrowBuffer *data,\n+                                         GArrowBuffer *null_bitmap,\n+                                         gint64 n_nulls);\n+\n+gint16 garrow_int16_array_get_value(GArrowInt16Array *array,\n+                                    gint64 i);\n+const gint16 *garrow_int16_array_get_values(GArrowInt16Array *array,\n+                                            gint64 *length);\n+\n+\n+#define GARROW_TYPE_UINT16_ARRAY                 \\\n+  (garrow_uint16_array_get_type())\n+#define GARROW_UINT16_ARRAY(obj)                        \\\n+  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n+                              GARROW_TYPE_UINT16_ARRAY, \\\n+                              GArrowUInt16Array))\n+#define GARROW_UINT16_ARRAY_CLASS(klass)                \\\n+  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n+                           GARROW_TYPE_UINT16_ARRAY,    \\\n+                           GArrowUInt16ArrayClass))\n+#define GARROW_IS_UINT16_ARRAY(obj)                             \\\n+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n+                              GARROW_TYPE_UINT16_ARRAY))\n+#define GARROW_IS_UINT16_ARRAY_CLASS(klass)             \\\n+  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n+                           GARROW_TYPE_UINT16_ARRAY))\n+#define GARROW_UINT16_ARRAY_GET_CLASS(obj)              \\\n+  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n+                             GARROW_TYPE_UINT16_ARRAY,  \\\n+                             GArrowUInt16ArrayClass))\n+\n+typedef struct _GArrowUInt16Array         GArrowUInt16Array;\n+typedef struct _GArrowUInt16ArrayClass    GArrowUInt16ArrayClass;\n+\n+/**\n+ * GArrowUInt16Array:\n+ *\n+ * It wraps `arrow::UInt16Array`.\n+ */\n+struct _GArrowUInt16Array\n+{\n+  /*< private >*/\n+  GArrowPrimitiveArray parent_instance;\n+};\n+\n+struct _GArrowUInt16ArrayClass\n+{\n+  GArrowPrimitiveArrayClass parent_class;\n+};\n+\n+GType garrow_uint16_array_get_type(void) G_GNUC_CONST;\n+\n+GArrowUInt16Array *garrow_uint16_array_new(gint64 length,\n+                                           GArrowBuffer *data,\n+                                           GArrowBuffer *null_bitmap,\n+                                           gint64 n_nulls);\n+\n+guint16 garrow_uint16_array_get_value(GArrowUInt16Array *array,\n+                                      gint64 i);\n+const guint16 *garrow_uint16_array_get_values(GArrowUInt16Array *array,\n+                                              gint64 *length);\n+\n+\n+#define GARROW_TYPE_INT32_ARRAY                 \\\n+  (garrow_int32_array_get_type())\n+#define GARROW_INT32_ARRAY(obj)                         \\\n+  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n+                              GARROW_TYPE_INT32_ARRAY,  \\\n+                              GArrowInt32Array))\n+#define GARROW_INT32_ARRAY_CLASS(klass)                 \\\n+  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n+                           GARROW_TYPE_INT32_ARRAY,     \\\n+                           GArrowInt32ArrayClass))\n+#define GARROW_IS_INT32_ARRAY(obj)                      \\\n+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                    \\\n+                              GARROW_TYPE_INT32_ARRAY))\n+#define GARROW_IS_INT32_ARRAY_CLASS(klass)              \\\n+  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n+                           GARROW_TYPE_INT32_ARRAY))\n+#define GARROW_INT32_ARRAY_GET_CLASS(obj)               \\\n+  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n+                             GARROW_TYPE_INT32_ARRAY,   \\\n+                             GArrowInt32ArrayClass))\n+\n+typedef struct _GArrowInt32Array         GArrowInt32Array;\n+typedef struct _GArrowInt32ArrayClass    GArrowInt32ArrayClass;\n+\n+/**\n+ * GArrowInt32Array:\n+ *\n+ * It wraps `arrow::Int32Array`.\n+ */\n+struct _GArrowInt32Array\n+{\n+  /*< private >*/\n+  GArrowPrimitiveArray parent_instance;\n+};\n+\n+struct _GArrowInt32ArrayClass\n+{\n+  GArrowPrimitiveArrayClass parent_class;\n+};\n+\n+GType garrow_int32_array_get_type(void) G_GNUC_CONST;\n+\n+GArrowInt32Array *garrow_int32_array_new(gint64 length,\n+                                         GArrowBuffer *data,\n+                                         GArrowBuffer *null_bitmap,\n+                                         gint64 n_nulls);\n+\n+gint32 garrow_int32_array_get_value(GArrowInt32Array *array,\n+                                    gint64 i);\n+const gint32 *garrow_int32_array_get_values(GArrowInt32Array *array,\n+                                            gint64 *length);\n+\n+\n+#define GARROW_TYPE_UINT32_ARRAY                \\\n+  (garrow_uint32_array_get_type())\n+#define GARROW_UINT32_ARRAY(obj)                        \\\n+  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n+                              GARROW_TYPE_UINT32_ARRAY, \\\n+                              GArrowUInt32Array))\n+#define GARROW_UINT32_ARRAY_CLASS(klass)                \\\n+  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n+                           GARROW_TYPE_UINT32_ARRAY,    \\\n+                           GArrowUInt32ArrayClass))\n+#define GARROW_IS_UINT32_ARRAY(obj)                             \\\n+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n+                              GARROW_TYPE_UINT32_ARRAY))\n+#define GARROW_IS_UINT32_ARRAY_CLASS(klass)             \\\n+  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n+                           GARROW_TYPE_UINT32_ARRAY))\n+#define GARROW_UINT32_ARRAY_GET_CLASS(obj)              \\\n+  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n+                             GARROW_TYPE_UINT32_ARRAY,  \\\n+                             GArrowUInt32ArrayClass))\n+\n+typedef struct _GArrowUInt32Array         GArrowUInt32Array;\n+typedef struct _GArrowUInt32ArrayClass    GArrowUInt32ArrayClass;\n+\n+/**\n+ * GArrowUInt32Array:\n+ *\n+ * It wraps `arrow::UInt32Array`.\n+ */\n+struct _GArrowUInt32Array\n+{\n+  /*< private >*/\n+  GArrowPrimitiveArray parent_instance;\n+};\n+\n+struct _GArrowUInt32ArrayClass\n+{\n+  GArrowPrimitiveArrayClass parent_class;\n+};\n+\n+GType garrow_uint32_array_get_type(void) G_GNUC_CONST;\n+\n+GArrowUInt32Array *garrow_uint32_array_new(gint64 length,\n+                                           GArrowBuffer *data,\n+                                           GArrowBuffer *null_bitmap,\n+                                           gint64 n_nulls);\n+\n+guint32 garrow_uint32_array_get_value(GArrowUInt32Array *array,\n+                                      gint64 i);\n+const guint32 *garrow_uint32_array_get_values(GArrowUInt32Array *array,\n+                                              gint64 *length);\n+\n+\n+#define GARROW_TYPE_INT64_ARRAY                 \\\n+  (garrow_int64_array_get_type())\n+#define GARROW_INT64_ARRAY(obj)                         \\\n+  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n+                              GARROW_TYPE_INT64_ARRAY,  \\\n+                              GArrowInt64Array))\n+#define GARROW_INT64_ARRAY_CLASS(klass)                 \\\n+  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n+                           GARROW_TYPE_INT64_ARRAY,     \\\n+                           GArrowInt64ArrayClass))\n+#define GARROW_IS_INT64_ARRAY(obj)                      \\\n+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                    \\\n+                              GARROW_TYPE_INT64_ARRAY))\n+#define GARROW_IS_INT64_ARRAY_CLASS(klass)              \\\n+  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n+                           GARROW_TYPE_INT64_ARRAY))\n+#define GARROW_INT64_ARRAY_GET_CLASS(obj)               \\\n+  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n+                             GARROW_TYPE_INT64_ARRAY,   \\\n+                             GArrowInt64ArrayClass))\n+\n+typedef struct _GArrowInt64Array         GArrowInt64Array;\n+typedef struct _GArrowInt64ArrayClass    GArrowInt64ArrayClass;\n+\n+/**\n+ * GArrowInt64Array:\n+ *\n+ * It wraps `arrow::Int64Array`.\n+ */\n+struct _GArrowInt64Array\n+{\n+  /*< private >*/\n+  GArrowPrimitiveArray parent_instance;\n+};\n+\n+struct _GArrowInt64ArrayClass\n+{\n+  GArrowPrimitiveArrayClass parent_class;\n+};\n+\n+GType garrow_int64_array_get_type(void) G_GNUC_CONST;\n+\n+GArrowInt64Array *garrow_int64_array_new(gint64 length,\n+                                         GArrowBuffer *data,\n+                                         GArrowBuffer *null_bitmap,\n+                                         gint64 n_nulls);\n+\n+gint64 garrow_int64_array_get_value(GArrowInt64Array *array,\n+                                    gint64 i);\n+const gint64 *garrow_int64_array_get_values(GArrowInt64Array *array,\n+                                            gint64 *length);\n+\n+\n+#define GARROW_TYPE_UINT64_ARRAY                \\\n+  (garrow_uint64_array_get_type())\n+#define GARROW_UINT64_ARRAY(obj)                        \\\n+  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n+                              GARROW_TYPE_UINT64_ARRAY, \\\n+                              GArrowUInt64Array))\n+#define GARROW_UINT64_ARRAY_CLASS(klass)                \\\n+  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n+                           GARROW_TYPE_UINT64_ARRAY,    \\\n+                           GArrowUInt64ArrayClass))\n+#define GARROW_IS_UINT64_ARRAY(obj)                             \\\n+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n+                              GARROW_TYPE_UINT64_ARRAY))\n+#define GARROW_IS_UINT64_ARRAY_CLASS(klass)             \\\n+  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n+                           GARROW_TYPE_UINT64_ARRAY))\n+#define GARROW_UINT64_ARRAY_GET_CLASS(obj)              \\\n+  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n+                             GARROW_TYPE_UINT64_ARRAY,  \\\n+                             GArrowUInt64ArrayClass))\n+\n+typedef struct _GArrowUInt64Array         GArrowUInt64Array;\n+typedef struct _GArrowUInt64ArrayClass    GArrowUInt64ArrayClass;\n+\n+/**\n+ * GArrowUInt64Array:\n+ *\n+ * It wraps `arrow::UInt64Array`.\n+ */\n+struct _GArrowUInt64Array\n+{\n+  /*< private >*/\n+  GArrowPrimitiveArray parent_instance;\n+};\n+\n+struct _GArrowUInt64ArrayClass\n+{\n+  GArrowPrimitiveArrayClass parent_class;\n+};\n+\n+GType garrow_uint64_array_get_type(void) G_GNUC_CONST;\n+\n+GArrowUInt64Array *garrow_uint64_array_new(gint64 length,\n+                                           GArrowBuffer *data,\n+                                           GArrowBuffer *null_bitmap,\n+                                           gint64 n_nulls);\n+\n+guint64 garrow_uint64_array_get_value(GArrowUInt64Array *array,\n+                                      gint64 i);\n+const guint64 *garrow_uint64_array_get_values(GArrowUInt64Array *array,\n+                                              gint64 *length);\n+\n+\n+#define GARROW_TYPE_FLOAT_ARRAY                 \\\n+  (garrow_float_array_get_type())\n+#define GARROW_FLOAT_ARRAY(obj)                         \\\n+  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n+                              GARROW_TYPE_FLOAT_ARRAY,  \\\n+                              GArrowFloatArray))\n+#define GARROW_FLOAT_ARRAY_CLASS(klass)                 \\\n+  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n+                           GARROW_TYPE_FLOAT_ARRAY,     \\\n+                           GArrowFloatArrayClass))\n+#define GARROW_IS_FLOAT_ARRAY(obj)                      \\\n+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                    \\\n+                              GARROW_TYPE_FLOAT_ARRAY))\n+#define GARROW_IS_FLOAT_ARRAY_CLASS(klass)              \\\n+  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n+                           GARROW_TYPE_FLOAT_ARRAY))\n+#define GARROW_FLOAT_ARRAY_GET_CLASS(obj)               \\\n+  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n+                             GARROW_TYPE_FLOAT_ARRAY,   \\\n+                             GArrowFloatArrayClass))\n+\n+typedef struct _GArrowFloatArray         GArrowFloatArray;\n+typedef struct _GArrowFloatArrayClass    GArrowFloatArrayClass;\n+\n+/**\n+ * GArrowFloatArray:\n+ *\n+ * It wraps `arrow::FloatArray`.\n+ */\n+struct _GArrowFloatArray\n+{\n+  /*< private >*/\n+  GArrowPrimitiveArray parent_instance;\n+};\n+\n+struct _GArrowFloatArrayClass\n+{\n+  GArrowPrimitiveArrayClass parent_class;\n+};\n+\n+GType garrow_float_array_get_type(void) G_GNUC_CONST;\n+\n+GArrowFloatArray *garrow_float_array_new(gint64 length,\n+                                         GArrowBuffer *data,\n+                                         GArrowBuffer *null_bitmap,\n+                                         gint64 n_nulls);\n+\n+gfloat garrow_float_array_get_value(GArrowFloatArray *array,\n+                                    gint64 i);\n+const gfloat *garrow_float_array_get_values(GArrowFloatArray *array,\n+                                            gint64 *length);\n+\n+\n+#define GARROW_TYPE_DOUBLE_ARRAY                \\\n+  (garrow_double_array_get_type())\n+#define GARROW_DOUBLE_ARRAY(obj)                        \\\n+  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n+                              GARROW_TYPE_DOUBLE_ARRAY, \\\n+                              GArrowDoubleArray))\n+#define GARROW_DOUBLE_ARRAY_CLASS(klass)                \\\n+  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n+                           GARROW_TYPE_DOUBLE_ARRAY,    \\\n+                           GArrowDoubleArrayClass))\n+#define GARROW_IS_DOUBLE_ARRAY(obj)                             \\\n+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n+                              GARROW_TYPE_DOUBLE_ARRAY))\n+#define GARROW_IS_DOUBLE_ARRAY_CLASS(klass)             \\\n+  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n+                           GARROW_TYPE_DOUBLE_ARRAY))\n+#define GARROW_DOUBLE_ARRAY_GET_CLASS(obj)              \\\n+  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n+                             GARROW_TYPE_DOUBLE_ARRAY,  \\\n+                             GArrowDoubleArrayClass))\n+\n+typedef struct _GArrowDoubleArray         GArrowDoubleArray;\n+typedef struct _GArrowDoubleArrayClass    GArrowDoubleArrayClass;\n+\n+/**\n+ * GArrowDoubleArray:\n+ *\n+ * It wraps `arrow::DoubleArray`.\n+ */\n+struct _GArrowDoubleArray\n+{\n+  /*< private >*/\n+  GArrowPrimitiveArray parent_instance;\n+};\n+\n+struct _GArrowDoubleArrayClass\n+{\n+  GArrowPrimitiveArrayClass parent_class;\n+};\n+\n+GType garrow_double_array_get_type(void) G_GNUC_CONST;\n+\n+GArrowDoubleArray *garrow_double_array_new(gint64 length,\n+                                           GArrowBuffer *data,\n+                                           GArrowBuffer *null_bitmap,\n+                                           gint64 n_nulls);\n+\n+gdouble garrow_double_array_get_value(GArrowDoubleArray *array,\n+                                      gint64 i);\n+const gdouble *garrow_double_array_get_values(GArrowDoubleArray *array,\n+                                              gint64 *length);\n+\n+\n+#define GARROW_TYPE_BINARY_ARRAY                \\\n+  (garrow_binary_array_get_type())\n+#define GARROW_BINARY_ARRAY(obj)                        \\\n+  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n+                              GARROW_TYPE_BINARY_ARRAY, \\\n+                              GArrowBinaryArray))\n+#define GARROW_BINARY_ARRAY_CLASS(klass)                \\\n+  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n+                           GARROW_TYPE_BINARY_ARRAY,    \\\n+                           GArrowBinaryArrayClass))\n+#define GARROW_IS_BINARY_ARRAY(obj)                             \\\n+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n+                              GARROW_TYPE_BINARY_ARRAY))\n+#define GARROW_IS_BINARY_ARRAY_CLASS(klass)             \\\n+  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n+                           GARROW_TYPE_BINARY_ARRAY))\n+#define GARROW_BINARY_ARRAY_GET_CLASS(obj)              \\\n+  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n+                             GARROW_TYPE_BINARY_ARRAY,  \\\n+                             GArrowBinaryArrayClass))\n+\n+typedef struct _GArrowBinaryArray         GArrowBinaryArray;\n+typedef struct _GArrowBinaryArrayClass    GArrowBinaryArrayClass;\n+\n+/**\n+ * GArrowBinaryArray:\n+ *\n+ * It wraps `arrow::BinaryArray`.\n+ */\n+struct _GArrowBinaryArray\n+{\n+  /*< private >*/\n+  GArrowArray parent_instance;\n+};\n+\n+struct _GArrowBinaryArrayClass\n+{\n+  GArrowArrayClass parent_class;\n+};\n+\n+GType garrow_binary_array_get_type(void) G_GNUC_CONST;\n+\n+GArrowBinaryArray *garrow_binary_array_new(gint64 length,\n+                                           GArrowBuffer *value_offsets,\n+                                           GArrowBuffer *data,\n+                                           GArrowBuffer *null_bitmap,\n+                                           gint64 n_nulls);\n+\n+GBytes *garrow_binary_array_get_value(GArrowBinaryArray *array,\n+                                      gint64 i);\n+GArrowBuffer *garrow_binary_array_get_buffer(GArrowBinaryArray *array);\n+GArrowBuffer *garrow_binary_array_get_offsets_buffer(GArrowBinaryArray *array);\n+\n+#define GARROW_TYPE_STRING_ARRAY                \\\n+  (garrow_string_array_get_type())\n+#define GARROW_STRING_ARRAY(obj)                        \\\n+  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n+                              GARROW_TYPE_STRING_ARRAY, \\\n+                              GArrowStringArray))\n+#define GARROW_STRING_ARRAY_CLASS(klass)                \\\n+  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n+                           GARROW_TYPE_STRING_ARRAY,    \\\n+                           GArrowStringArrayClass))\n+#define GARROW_IS_STRING_ARRAY(obj)                             \\\n+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n+                              GARROW_TYPE_STRING_ARRAY))\n+#define GARROW_IS_STRING_ARRAY_CLASS(klass)             \\\n+  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n+                           GARROW_TYPE_STRING_ARRAY))\n+#define GARROW_STRING_ARRAY_GET_CLASS(obj)              \\\n+  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n+                             GARROW_TYPE_STRING_ARRAY,  \\\n+                             GArrowStringArrayClass))\n+\n+typedef struct _GArrowStringArray         GArrowStringArray;\n+typedef struct _GArrowStringArrayClass    GArrowStringArrayClass;\n+\n+/**\n+ * GArrowStringArray:\n+ *\n+ * It wraps `arrow::StringArray`.\n+ */\n+struct _GArrowStringArray\n+{\n+  /*< private >*/\n+  GArrowBinaryArray parent_instance;\n+};\n+\n+struct _GArrowStringArrayClass\n+{\n+  GArrowBinaryArrayClass parent_class;\n+};\n+\n+GType garrow_string_array_get_type(void) G_GNUC_CONST;\n+\n+GArrowStringArray *garrow_string_array_new(gint64 length,\n+                                           GArrowBuffer *value_offsets,\n+                                           GArrowBuffer *data,\n+                                           GArrowBuffer *null_bitmap,\n+                                           gint64 n_nulls);\n+\n+gchar *garrow_string_array_get_string(GArrowStringArray *array,\n+                                      gint64 i);\n+\n+\n+#define GARROW_TYPE_DATE32_ARRAY                \\\n+  (garrow_date32_array_get_type())\n+#define GARROW_DATE32_ARRAY(obj)                        \\\n+  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n+                              GARROW_TYPE_DATE32_ARRAY, \\\n+                              GArrowDate32Array))\n+#define GARROW_DATE32_ARRAY_CLASS(klass)                \\\n+  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n+                           GARROW_TYPE_DATE32_ARRAY,    \\\n+                           GArrowDate32ArrayClass))\n+#define GARROW_IS_DATE32_ARRAY(obj)                             \\\n+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n+                              GARROW_TYPE_DATE32_ARRAY))\n+#define GARROW_IS_DATE32_ARRAY_CLASS(klass)             \\\n+  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n+                           GARROW_TYPE_DATE32_ARRAY))\n+#define GARROW_DATE32_ARRAY_GET_CLASS(obj)              \\\n+  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n+                             GARROW_TYPE_DATE32_ARRAY,  \\\n+                             GArrowDate32ArrayClass))\n+\n+typedef struct _GArrowDate32Array         GArrowDate32Array;\n+typedef struct _GArrowDate32ArrayClass    GArrowDate32ArrayClass;\n+\n+/**\n+ * GArrowDate32Array:\n+ *\n+ * It wraps `arrow::Date32Array`.\n+ */\n+struct _GArrowDate32Array\n+{\n+  /*< private >*/\n+  GArrowPrimitiveArray parent_instance;\n+};\n+\n+struct _GArrowDate32ArrayClass\n+{\n+  GArrowPrimitiveArrayClass parent_class;\n+};\n+\n+GType garrow_date32_array_get_type(void) G_GNUC_CONST;\n+\n+GArrowDate32Array *garrow_date32_array_new(gint64 length,\n+                                           GArrowBuffer *data,\n+                                           GArrowBuffer *null_bitmap,\n+                                           gint64 n_nulls);\n+\n+gint32 garrow_date32_array_get_value(GArrowDate32Array *array,\n+                                     gint64 i);\n+const gint32 *garrow_date32_array_get_values(GArrowDate32Array *array,\n+                                             gint64 *length);\n+\n+\n+#define GARROW_TYPE_DATE64_ARRAY                \\\n+  (garrow_date64_array_get_type())\n+#define GARROW_DATE64_ARRAY(obj)                        \\\n+  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n+                              GARROW_TYPE_DATE64_ARRAY, \\\n+                              GArrowDate64Array))\n+#define GARROW_DATE64_ARRAY_CLASS(klass)                \\\n+  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n+                           GARROW_TYPE_DATE64_ARRAY,    \\\n+                           GArrowDate64ArrayClass))\n+#define GARROW_IS_DATE64_ARRAY(obj)                             \\\n+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n+                              GARROW_TYPE_DATE64_ARRAY))\n+#define GARROW_IS_DATE64_ARRAY_CLASS(klass)             \\\n+  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n+                           GARROW_TYPE_DATE64_ARRAY))\n+#define GARROW_DATE64_ARRAY_GET_CLASS(obj)              \\\n+  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n+                             GARROW_TYPE_DATE64_ARRAY,  \\\n+                             GArrowDate64ArrayClass))\n+\n+typedef struct _GArrowDate64Array         GArrowDate64Array;\n+typedef struct _GArrowDate64ArrayClass    GArrowDate64ArrayClass;\n+\n+/**\n+ * GArrowDate64Array:\n+ *\n+ * It wraps `arrow::Date64Array`.\n+ */\n+struct _GArrowDate64Array\n+{\n+  /*< private >*/\n+  GArrowPrimitiveArray parent_instance;\n+};\n+\n+struct _GArrowDate64ArrayClass\n+{\n+  GArrowPrimitiveArrayClass parent_class;\n+};\n+\n+GType garrow_date64_array_get_type(void) G_GNUC_CONST;\n+\n+GArrowDate64Array *garrow_date64_array_new(gint64 length,\n+                                           GArrowBuffer *data,\n+                                           GArrowBuffer *null_bitmap,\n+                                           gint64 n_nulls);\n+\n+gint64 garrow_date64_array_get_value(GArrowDate64Array *array,\n+                                     gint64 i);\n+const gint64 *garrow_date64_array_get_values(GArrowDate64Array *array,\n+                                             gint64 *length);\n+\n+\n+#define GARROW_TYPE_TIMESTAMP_ARRAY             \\\n+  (garrow_timestamp_array_get_type())\n+#define GARROW_TIMESTAMP_ARRAY(obj)                             \\\n+  (G_TYPE_CHECK_INSTANCE_CAST((obj),                            \\\n+                              GARROW_TYPE_TIMESTAMP_ARRAY,      \\\n+                              GArrowTimestampArray))\n+#define GARROW_TIMESTAMP_ARRAY_CLASS(klass)             \\\n+  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n+                           GARROW_TYPE_TIMESTAMP_ARRAY, \\\n+                           GArrowTimestampArrayClass))\n+#define GARROW_IS_TIMESTAMP_ARRAY(obj)                          \\\n+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n+                              GARROW_TYPE_TIMESTAMP_ARRAY))\n+#define GARROW_IS_TIMESTAMP_ARRAY_CLASS(klass)                  \\\n+  (G_TYPE_CHECK_CLASS_TYPE((klass),                             \\\n+                           GARROW_TYPE_TIMESTAMP_ARRAY))\n+#define GARROW_TIMESTAMP_ARRAY_GET_CLASS(obj)                   \\\n+  (G_TYPE_INSTANCE_GET_CLASS((obj),                             \\\n+                             GARROW_TYPE_TIMESTAMP_ARRAY,       \\\n+                             GArrowTimestampArrayClass))\n+\n+typedef struct _GArrowTimestampArray         GArrowTimestampArray;\n+typedef struct _GArrowTimestampArrayClass    GArrowTimestampArrayClass;\n+\n+/**\n+ * GArrowTimestampArray:\n+ *\n+ * It wraps `arrow::TimestampArray`.\n+ */\n+struct _GArrowTimestampArray\n+{\n+  /*< private >*/\n+  GArrowPrimitiveArray parent_instance;\n+};\n+\n+struct _GArrowTimestampArrayClass\n+{\n+  GArrowPrimitiveArrayClass parent_class;\n+};\n+\n+GType garrow_timestamp_array_get_type(void) G_GNUC_CONST;\n+\n+GArrowTimestampArray *garrow_timestamp_array_new(GArrowTimestampDataType *data_type,\n+                                                 gint64 length,\n+                                                 GArrowBuffer *data,\n+                                                 GArrowBuffer *null_bitmap,\n+                                                 gint64 n_nulls);\n+\n+gint64 garrow_timestamp_array_get_value(GArrowTimestampArray *array,\n+                                        gint64 i);\n+const gint64 *garrow_timestamp_array_get_values(GArrowTimestampArray *array,\n+                                                gint64 *length);\n+\n+\n+#define GARROW_TYPE_TIME32_ARRAY                \\\n+  (garrow_time32_array_get_type())\n+#define GARROW_TIME32_ARRAY(obj)                        \\\n+  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n+                              GARROW_TYPE_TIME32_ARRAY, \\\n+                              GArrowTime32Array))\n+#define GARROW_TIME32_ARRAY_CLASS(klass)                \\\n+  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n+                           GARROW_TYPE_TIME32_ARRAY,    \\\n+                           GArrowTime32ArrayClass))\n+#define GARROW_IS_TIME32_ARRAY(obj)                             \\\n+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n+                              GARROW_TYPE_TIME32_ARRAY))\n+#define GARROW_IS_TIME32_ARRAY_CLASS(klass)             \\\n+  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n+                           GARROW_TYPE_TIME32_ARRAY))\n+#define GARROW_TIME32_ARRAY_GET_CLASS(obj)              \\\n+  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n+                             GARROW_TYPE_TIME32_ARRAY,  \\\n+                             GArrowTime32ArrayClass))\n+\n+typedef struct _GArrowTime32Array         GArrowTime32Array;\n+typedef struct _GArrowTime32ArrayClass    GArrowTime32ArrayClass;\n+\n+/**\n+ * GArrowTime32Array:\n+ *\n+ * It wraps `arrow::Time32Array`.\n+ */\n+struct _GArrowTime32Array\n+{\n+  /*< private >*/\n+  GArrowPrimitiveArray parent_instance;\n+};\n+\n+struct _GArrowTime32ArrayClass\n+{\n+  GArrowPrimitiveArrayClass parent_class;\n+};\n+\n+GType garrow_time32_array_get_type(void) G_GNUC_CONST;\n+\n+GArrowTime32Array *garrow_time32_array_new(GArrowTime32DataType *data_type,\n+                                           gint64 length,\n+                                           GArrowBuffer *data,\n+                                           GArrowBuffer *null_bitmap,\n+                                           gint64 n_nulls);\n+\n+gint32 garrow_time32_array_get_value(GArrowTime32Array *array,\n+                                     gint64 i);\n+const gint32 *garrow_time32_array_get_values(GArrowTime32Array *array,\n+                                             gint64 *length);\n+\n+\n+#define GARROW_TYPE_TIME64_ARRAY                \\\n+  (garrow_time64_array_get_type())\n+#define GARROW_TIME64_ARRAY(obj)                        \\\n+  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n+                              GARROW_TYPE_TIME64_ARRAY, \\\n+                              GArrowTime64Array))\n+#define GARROW_TIME64_ARRAY_CLASS(klass)                \\\n+  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n+                           GARROW_TYPE_TIME64_ARRAY,    \\\n+                           GArrowTime64ArrayClass))\n+#define GARROW_IS_TIME64_ARRAY(obj)                             \\\n+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n+                              GARROW_TYPE_TIME64_ARRAY))\n+#define GARROW_IS_TIME64_ARRAY_CLASS(klass)             \\\n+  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n+                           GARROW_TYPE_TIME64_ARRAY))\n+#define GARROW_TIME64_ARRAY_GET_CLASS(obj)              \\\n+  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n+                             GARROW_TYPE_TIME64_ARRAY,  \\\n+                             GArrowTime64ArrayClass))\n+\n+typedef struct _GArrowTime64Array         GArrowTime64Array;\n+typedef struct _GArrowTime64ArrayClass    GArrowTime64ArrayClass;\n+\n+/**\n+ * GArrowTime64Array:\n+ *\n+ * It wraps `arrow::Time64Array`.\n+ */\n+struct _GArrowTime64Array\n+{\n+  /*< private >*/\n+  GArrowPrimitiveArray parent_instance;\n+};\n+\n+struct _GArrowTime64ArrayClass\n+{\n+  GArrowPrimitiveArrayClass parent_class;\n+};\n+\n+GType garrow_time64_array_get_type(void) G_GNUC_CONST;\n+\n+GArrowTime64Array *garrow_time64_array_new(GArrowTime64DataType *data_type,\n+                                           gint64 length,\n+                                           GArrowBuffer *data,\n+                                           GArrowBuffer *null_bitmap,\n+                                           gint64 n_nulls);\n+\n+gint64 garrow_time64_array_get_value(GArrowTime64Array *array,\n+                                     gint64 i);\n+const gint64 *garrow_time64_array_get_values(GArrowTime64Array *array,\n+                                             gint64 *length);\n+\n+G_END_DECLS\ndiff --git a/c_glib/arrow-glib/basic-array.hpp b/c_glib/arrow-glib/basic-array.hpp\nnew file mode 100644\nindex 000000000..52b94a51f\n--- /dev/null\n+++ b/c_glib/arrow-glib/basic-array.hpp\n@@ -0,0 +1,27 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#pragma once\n+\n+#include <arrow/api.h>\n+\n+#include <arrow-glib/basic-array.h>\n+\n+GArrowArray *garrow_array_new_raw(std::shared_ptr<arrow::Array> *arrow_array);\n+std::shared_ptr<arrow::Array> garrow_array_get_raw(GArrowArray *array);\ndiff --git a/c_glib/arrow-glib/basic-data-type.cpp b/c_glib/arrow-glib/basic-data-type.cpp\nindex 62f8a7e4d..dcafe06d6 100644\n--- a/c_glib/arrow-glib/basic-data-type.cpp\n+++ b/c_glib/arrow-glib/basic-data-type.cpp\n@@ -220,6 +220,37 @@ garrow_data_type_get_id(GArrowDataType *data_type)\n }\n \n \n+G_DEFINE_ABSTRACT_TYPE(GArrowFixedWidthDataType,                 \\\n+                       garrow_fixed_width_data_type,             \\\n+                       GARROW_TYPE_DATA_TYPE)\n+\n+static void\n+garrow_fixed_width_data_type_init(GArrowFixedWidthDataType *object)\n+{\n+}\n+\n+static void\n+garrow_fixed_width_data_type_class_init(GArrowFixedWidthDataTypeClass *klass)\n+{\n+}\n+\n+/**\n+ * garrow_fixed_width_data_type_get_id:\n+ * @data_type: A #GArrowFixedWidthDataType.\n+ *\n+ * Returns: The number of bits for one data.\n+ */\n+gint\n+garrow_fixed_width_data_type_get_bit_width(GArrowFixedWidthDataType *data_type)\n+{\n+  const auto arrow_data_type =\n+    garrow_data_type_get_raw(GARROW_DATA_TYPE(data_type));\n+  const auto arrow_fixed_width_type =\n+    std::static_pointer_cast<arrow::FixedWidthType>(arrow_data_type);\n+  return arrow_fixed_width_type->bit_width();\n+}\n+\n+\n G_DEFINE_TYPE(GArrowNullDataType,                \\\n               garrow_null_data_type,             \\\n               GARROW_TYPE_DATA_TYPE)\n@@ -254,7 +285,7 @@ garrow_null_data_type_new(void)\n \n G_DEFINE_TYPE(GArrowBooleanDataType,                \\\n               garrow_boolean_data_type,             \\\n-              GARROW_TYPE_DATA_TYPE)\n+              GARROW_TYPE_FIXED_WIDTH_DATA_TYPE)\n \n static void\n garrow_boolean_data_type_init(GArrowBooleanDataType *object)\n@@ -1015,12 +1046,15 @@ garrow_data_type_new_raw(std::shared_ptr<arrow::DataType> *arrow_data_type)\n   case arrow::Type::type::STRUCT:\n     type = GARROW_TYPE_STRUCT_DATA_TYPE;\n     break;\n+  case arrow::Type::type::DICTIONARY:\n+    type = GARROW_TYPE_DICTIONARY_DATA_TYPE;\n+    break;\n   default:\n     type = GARROW_TYPE_DATA_TYPE;\n     break;\n   }\n   data_type = GARROW_DATA_TYPE(g_object_new(type,\n-                                            \"data_type\", arrow_data_type,\n+                                            \"data-type\", arrow_data_type,\n                                             NULL));\n   return data_type;\n }\ndiff --git a/c_glib/arrow-glib/basic-data-type.h b/c_glib/arrow-glib/basic-data-type.h\nindex d3d52c612..bc0192f1b 100644\n--- a/c_glib/arrow-glib/basic-data-type.h\n+++ b/c_glib/arrow-glib/basic-data-type.h\n@@ -19,57 +19,45 @@\n \n #pragma once\n \n+#include <arrow-glib/gobject-type.h>\n #include <arrow-glib/type.h>\n \n G_BEGIN_DECLS\n \n-#define GARROW_TYPE_DATA_TYPE                   \\\n-  (garrow_data_type_get_type())\n-#define GARROW_DATA_TYPE(obj)                           \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n-                              GARROW_TYPE_DATA_TYPE,    \\\n-                              GArrowDataType))\n-#define GARROW_DATA_TYPE_CLASS(klass)                   \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n-                           GARROW_TYPE_DATA_TYPE,       \\\n-                           GArrowDataTypeClass))\n-#define GARROW_IS_DATA_TYPE(obj)                        \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                    \\\n-                              GARROW_TYPE_DATA_TYPE))\n-#define GARROW_IS_DATA_TYPE_CLASS(klass)                \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n-                           GARROW_TYPE_DATA_TYPE))\n-#define GARROW_DATA_TYPE_GET_CLASS(obj)                 \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n-                             GARROW_TYPE_DATA_TYPE,     \\\n-                             GArrowDataTypeClass))\n-\n-typedef struct _GArrowDataType         GArrowDataType;\n-typedef struct _GArrowDataTypeClass    GArrowDataTypeClass;\n-\n-/**\n- * GArrowDataType:\n- *\n- * It wraps `arrow::DataType`.\n- */\n-struct _GArrowDataType\n-{\n-  /*< private >*/\n-  GObject parent_instance;\n-};\n-\n+#define GARROW_TYPE_DATA_TYPE (garrow_data_type_get_type())\n+G_DECLARE_DERIVABLE_TYPE(GArrowDataType,\n+                         garrow_data_type,\n+                         GARROW,\n+                         DATA_TYPE,\n+                         GObject)\n struct _GArrowDataTypeClass\n {\n   GObjectClass parent_class;\n };\n \n-GType      garrow_data_type_get_type  (void) G_GNUC_CONST;\n gboolean   garrow_data_type_equal     (GArrowDataType *data_type,\n                                        GArrowDataType *other_data_type);\n gchar     *garrow_data_type_to_string (GArrowDataType *data_type);\n GArrowType garrow_data_type_get_id    (GArrowDataType *data_type);\n \n \n+#define GARROW_TYPE_FIXED_WIDTH_DATA_TYPE (garrow_fixed_width_data_type_get_type())\n+G_DECLARE_DERIVABLE_TYPE(GArrowFixedWidthDataType,\n+                         garrow_fixed_width_data_type,\n+                         GARROW,\n+                         FIXED_WIDTH_DATA_TYPE,\n+                         GArrowDataType)\n+struct _GArrowFixedWidthDataTypeClass\n+{\n+  GArrowDataTypeClass parent_class;\n+};\n+\n+gint garrow_fixed_width_data_type_get_bit_width(GArrowFixedWidthDataType *data_type);\n+/* TODO:\n+GList *garrow_fixed_width_data_type_get_buffer_layout(GArrowFixedWidthDataType *data_type);\n+*/\n+\n+\n #define GARROW_TYPE_NULL_DATA_TYPE              \\\n   (garrow_null_data_type_get_type())\n #define GARROW_NULL_DATA_TYPE(obj)                              \\\n@@ -114,47 +102,17 @@ GType               garrow_null_data_type_get_type (void) G_GNUC_CONST;\n GArrowNullDataType *garrow_null_data_type_new      (void);\n \n \n-#define GARROW_TYPE_BOOLEAN_DATA_TYPE           \\\n-  (garrow_boolean_data_type_get_type())\n-#define GARROW_BOOLEAN_DATA_TYPE(obj)                           \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),                            \\\n-                              GARROW_TYPE_BOOLEAN_DATA_TYPE,    \\\n-                              GArrowBooleanDataType))\n-#define GARROW_BOOLEAN_DATA_TYPE_CLASS(klass)                   \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),                             \\\n-                           GARROW_TYPE_BOOLEAN_DATA_TYPE,       \\\n-                           GArrowBooleanDataTypeClass))\n-#define GARROW_IS_BOOLEAN_DATA_TYPE(obj)                        \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n-                              GARROW_TYPE_BOOLEAN_DATA_TYPE))\n-#define GARROW_IS_BOOLEAN_DATA_TYPE_CLASS(klass)                \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),                             \\\n-                           GARROW_TYPE_BOOLEAN_DATA_TYPE))\n-#define GARROW_BOOLEAN_DATA_TYPE_GET_CLASS(obj)                 \\\n-  (G_TYPE_INSTANCE_GET_CLASS((obj),                             \\\n-                             GARROW_TYPE_BOOLEAN_DATA_TYPE,     \\\n-                             GArrowBooleanDataTypeClass))\n-\n-typedef struct _GArrowBooleanDataType         GArrowBooleanDataType;\n-typedef struct _GArrowBooleanDataTypeClass    GArrowBooleanDataTypeClass;\n-\n-/**\n- * GArrowBooleanDataType:\n- *\n- * It wraps `arrow::BooleanType`.\n- */\n-struct _GArrowBooleanDataType\n-{\n-  /*< private >*/\n-  GArrowDataType parent_instance;\n-};\n-\n+#define GARROW_TYPE_BOOLEAN_DATA_TYPE (garrow_boolean_data_type_get_type())\n+G_DECLARE_DERIVABLE_TYPE(GArrowBooleanDataType,\n+                         garrow_boolean_data_type,\n+                         GARROW,\n+                         BOOLEAN_DATA_TYPE,\n+                         GArrowFixedWidthDataType)\n struct _GArrowBooleanDataTypeClass\n {\n-  GArrowDataTypeClass parent_class;\n+  GArrowFixedWidthDataTypeClass parent_class;\n };\n \n-GType                  garrow_boolean_data_type_get_type (void) G_GNUC_CONST;\n GArrowBooleanDataType *garrow_boolean_data_type_new      (void);\n \n \ndiff --git a/c_glib/arrow-glib/composite-array.cpp b/c_glib/arrow-glib/composite-array.cpp\nnew file mode 100644\nindex 000000000..445103d37\n--- /dev/null\n+++ b/c_glib/arrow-glib/composite-array.cpp\n@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#ifdef HAVE_CONFIG_H\n+#  include <config.h>\n+#endif\n+\n+#include <arrow-glib/array.hpp>\n+#include <arrow-glib/buffer.hpp>\n+#include <arrow-glib/compute.hpp>\n+#include <arrow-glib/data-type.hpp>\n+#include <arrow-glib/error.hpp>\n+#include <arrow-glib/type.hpp>\n+\n+G_BEGIN_DECLS\n+\n+/**\n+ * SECTION: composite-array\n+ * @section_id: composite-array-classes\n+ * @title: Composite array classes\n+ * @include: arrow-glib/arrow-glib.h\n+ *\n+ * #GArrowListArray is a class for list array. It can store zero or\n+ * more list data. If you don't have Arrow format data, you need to\n+ * use #GArrowListArrayBuilder to create a new array.\n+ *\n+ * #GArrowStructArray is a class for struct array. It can store zero\n+ * or more structs. One struct has zero or more fields. If you don't\n+ * have Arrow format data, you need to use #GArrowStructArrayBuilder\n+ * to create a new array.\n+ */\n+\n+G_DEFINE_TYPE(GArrowListArray,               \\\n+              garrow_list_array,             \\\n+              GARROW_TYPE_ARRAY)\n+\n+static void\n+garrow_list_array_init(GArrowListArray *object)\n+{\n+}\n+\n+static void\n+garrow_list_array_class_init(GArrowListArrayClass *klass)\n+{\n+}\n+\n+/**\n+ * garrow_list_array_new:\n+ * @length: The number of elements.\n+ * @value_offsets: The offsets of @values in Arrow format.\n+ * @values: The values as #GArrowArray.\n+ * @null_bitmap: (nullable): The bitmap that shows null elements. The\n+ *   N-th element is null when the N-th bit is 0, not null otherwise.\n+ *   If the array has no null elements, the bitmap must be %NULL and\n+ *   @n_nulls is 0.\n+ * @n_nulls: The number of null elements. If -1 is specified, the\n+ *   number of nulls are computed from @null_bitmap.\n+ *\n+ * Returns: A newly created #GArrowListArray.\n+ *\n+ * Since: 0.4.0\n+ */\n+GArrowListArray *\n+garrow_list_array_new(gint64 length,\n+                      GArrowBuffer *value_offsets,\n+                      GArrowArray *values,\n+                      GArrowBuffer *null_bitmap,\n+                      gint64 n_nulls)\n+{\n+  const auto arrow_value_offsets = garrow_buffer_get_raw(value_offsets);\n+  const auto arrow_values = garrow_array_get_raw(values);\n+  const auto arrow_bitmap = garrow_buffer_get_raw(null_bitmap);\n+  auto arrow_data_type = arrow::list(arrow_values->type());\n+  auto arrow_list_array =\n+    std::make_shared<arrow::ListArray>(arrow_data_type,\n+                                       length,\n+                                       arrow_value_offsets,\n+                                       arrow_values,\n+                                       arrow_bitmap,\n+                                       n_nulls);\n+  auto arrow_array =\n+    std::static_pointer_cast<arrow::Array>(arrow_list_array);\n+  return GARROW_LIST_ARRAY(garrow_array_new_raw(&arrow_array));\n+}\n+\n+/**\n+ * garrow_list_array_get_value_type:\n+ * @array: A #GArrowListArray.\n+ *\n+ * Returns: (transfer full): The data type of value in each list.\n+ */\n+GArrowDataType *\n+garrow_list_array_get_value_type(GArrowListArray *array)\n+{\n+  auto arrow_array = garrow_array_get_raw(GARROW_ARRAY(array));\n+  auto arrow_list_array =\n+    static_cast<arrow::ListArray *>(arrow_array.get());\n+  auto arrow_value_type = arrow_list_array->value_type();\n+  return garrow_data_type_new_raw(&arrow_value_type);\n+}\n+\n+/**\n+ * garrow_list_array_get_value:\n+ * @array: A #GArrowListArray.\n+ * @i: The index of the target value.\n+ *\n+ * Returns: (transfer full): The i-th list.\n+ */\n+GArrowArray *\n+garrow_list_array_get_value(GArrowListArray *array,\n+                            gint64 i)\n+{\n+  auto arrow_array = garrow_array_get_raw(GARROW_ARRAY(array));\n+  auto arrow_list_array =\n+    static_cast<arrow::ListArray *>(arrow_array.get());\n+  auto arrow_list =\n+    arrow_list_array->values()->Slice(arrow_list_array->value_offset(i),\n+                                      arrow_list_array->value_length(i));\n+  return garrow_array_new_raw(&arrow_list);\n+}\n+\n+\n+G_DEFINE_TYPE(GArrowStructArray,               \\\n+              garrow_struct_array,             \\\n+              GARROW_TYPE_ARRAY)\n+\n+static void\n+garrow_struct_array_init(GArrowStructArray *object)\n+{\n+}\n+\n+static void\n+garrow_struct_array_class_init(GArrowStructArrayClass *klass)\n+{\n+}\n+\n+/**\n+ * garrow_struct_array_new:\n+ * @data_type: The data type of the struct.\n+ * @length: The number of elements.\n+ * @children: (element-type GArrowArray): The arrays for each field\n+ *   as #GList of #GArrowArray.\n+ * @null_bitmap: (nullable): The bitmap that shows null elements. The\n+ *   N-th element is null when the N-th bit is 0, not null otherwise.\n+ *   If the array has no null elements, the bitmap must be %NULL and\n+ *   @n_nulls is 0.\n+ * @n_nulls: The number of null elements. If -1 is specified, the\n+ *   number of nulls are computed from @null_bitmap.\n+ *\n+ * Returns: A newly created #GArrowStructArray.\n+ *\n+ * Since: 0.4.0\n+ */\n+GArrowStructArray *\n+garrow_struct_array_new(GArrowDataType *data_type,\n+                        gint64 length,\n+                        GList *children,\n+                        GArrowBuffer *null_bitmap,\n+                        gint64 n_nulls)\n+{\n+  const auto arrow_data_type = garrow_data_type_get_raw(data_type);\n+  std::vector<std::shared_ptr<arrow::Array>> arrow_children;\n+  for (GList *node = children; node; node = node->next) {\n+    GArrowArray *child = GARROW_ARRAY(node->data);\n+    arrow_children.push_back(garrow_array_get_raw(child));\n+  }\n+  const auto arrow_bitmap = garrow_buffer_get_raw(null_bitmap);\n+  auto arrow_struct_array =\n+    std::make_shared<arrow::StructArray>(arrow_data_type,\n+                                         length,\n+                                         arrow_children,\n+                                         arrow_bitmap,\n+                                         n_nulls);\n+  auto arrow_array =\n+    std::static_pointer_cast<arrow::Array>(arrow_struct_array);\n+  return GARROW_STRUCT_ARRAY(garrow_array_new_raw(&arrow_array));\n+}\n+\n+/**\n+ * garrow_struct_array_get_field\n+ * @array: A #GArrowStructArray.\n+ * @i: The index of the field in the struct.\n+ *\n+ * Returns: (transfer full): The i-th field.\n+ */\n+GArrowArray *\n+garrow_struct_array_get_field(GArrowStructArray *array,\n+                              gint i)\n+{\n+  auto arrow_array = garrow_array_get_raw(GARROW_ARRAY(array));\n+  auto arrow_struct_array =\n+    static_cast<arrow::StructArray *>(arrow_array.get());\n+  auto arrow_field = arrow_struct_array->field(i);\n+  return garrow_array_new_raw(&arrow_field);\n+}\n+\n+/**\n+ * garrow_struct_array_get_fields\n+ * @array: A #GArrowStructArray.\n+ *\n+ * Returns: (element-type GArrowArray) (transfer full):\n+ *   The fields in the struct.\n+ */\n+GList *\n+garrow_struct_array_get_fields(GArrowStructArray *array)\n+{\n+  const auto arrow_array = garrow_array_get_raw(GARROW_ARRAY(array));\n+  const auto arrow_struct_array =\n+    static_cast<const arrow::StructArray *>(arrow_array.get());\n+\n+  GList *fields = NULL;\n+  for (int i = 0; i < arrow_struct_array->num_fields(); ++i) {\n+    auto arrow_field = arrow_struct_array->field(i);\n+    GArrowArray *field = garrow_array_new_raw(&arrow_field);\n+    fields = g_list_prepend(fields, field);\n+  }\n+\n+  return g_list_reverse(fields);\n+}\n+\n+G_END_DECLS\ndiff --git a/c_glib/arrow-glib/composite-array.h b/c_glib/arrow-glib/composite-array.h\nnew file mode 100644\nindex 000000000..ebf955498\n--- /dev/null\n+++ b/c_glib/arrow-glib/composite-array.h\n@@ -0,0 +1,132 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#pragma once\n+\n+#include <arrow-glib/basic-array.h>\n+#include <arrow-glib/data-type.h>\n+\n+G_BEGIN_DECLS\n+\n+#define GARROW_TYPE_LIST_ARRAY                  \\\n+  (garrow_list_array_get_type())\n+#define GARROW_LIST_ARRAY(obj)                          \\\n+  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n+                              GARROW_TYPE_LIST_ARRAY,   \\\n+                              GArrowListArray))\n+#define GARROW_LIST_ARRAY_CLASS(klass)                  \\\n+  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n+                           GARROW_TYPE_LIST_ARRAY,      \\\n+                           GArrowListArrayClass))\n+#define GARROW_IS_LIST_ARRAY(obj)                       \\\n+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                    \\\n+                              GARROW_TYPE_LIST_ARRAY))\n+#define GARROW_IS_LIST_ARRAY_CLASS(klass)               \\\n+  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n+                           GARROW_TYPE_LIST_ARRAY))\n+#define GARROW_LIST_ARRAY_GET_CLASS(obj)                \\\n+  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n+                             GARROW_TYPE_LIST_ARRAY,    \\\n+                             GArrowListArrayClass))\n+\n+typedef struct _GArrowListArray         GArrowListArray;\n+typedef struct _GArrowListArrayClass    GArrowListArrayClass;\n+\n+/**\n+ * GArrowListArray:\n+ *\n+ * It wraps `arrow::ListArray`.\n+ */\n+struct _GArrowListArray\n+{\n+  /*< private >*/\n+  GArrowArray parent_instance;\n+};\n+\n+struct _GArrowListArrayClass\n+{\n+  GArrowArrayClass parent_class;\n+};\n+\n+GType garrow_list_array_get_type(void) G_GNUC_CONST;\n+\n+GArrowListArray *garrow_list_array_new(gint64 length,\n+                                       GArrowBuffer *value_offsets,\n+                                       GArrowArray *values,\n+                                       GArrowBuffer *null_bitmap,\n+                                       gint64 n_nulls);\n+\n+GArrowDataType *garrow_list_array_get_value_type(GArrowListArray *array);\n+GArrowArray *garrow_list_array_get_value(GArrowListArray *array,\n+                                         gint64 i);\n+\n+\n+#define GARROW_TYPE_STRUCT_ARRAY                \\\n+  (garrow_struct_array_get_type())\n+#define GARROW_STRUCT_ARRAY(obj)                        \\\n+  (G_TYPE_CHECK_INSTANCE_CAST((obj),                    \\\n+                              GARROW_TYPE_STRUCT_ARRAY, \\\n+                              GArrowStructArray))\n+#define GARROW_STRUCT_ARRAY_CLASS(klass)                \\\n+  (G_TYPE_CHECK_CLASS_CAST((klass),                     \\\n+                           GARROW_TYPE_STRUCT_ARRAY,    \\\n+                           GArrowStructArrayClass))\n+#define GARROW_IS_STRUCT_ARRAY(obj)                             \\\n+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),                            \\\n+                              GARROW_TYPE_STRUCT_ARRAY))\n+#define GARROW_IS_STRUCT_ARRAY_CLASS(klass)             \\\n+  (G_TYPE_CHECK_CLASS_TYPE((klass),                     \\\n+                           GARROW_TYPE_STRUCT_ARRAY))\n+#define GARROW_STRUCT_ARRAY_GET_CLASS(obj)              \\\n+  (G_TYPE_INSTANCE_GET_CLASS((obj),                     \\\n+                             GARROW_TYPE_STRUCT_ARRAY,  \\\n+                             GArrowStructArrayClass))\n+\n+typedef struct _GArrowStructArray         GArrowStructArray;\n+typedef struct _GArrowStructArrayClass    GArrowStructArrayClass;\n+\n+/**\n+ * GArrowStructArray:\n+ *\n+ * It wraps `arrow::StructArray`.\n+ */\n+struct _GArrowStructArray\n+{\n+  /*< private >*/\n+  GArrowArray parent_instance;\n+};\n+\n+struct _GArrowStructArrayClass\n+{\n+  GArrowArrayClass parent_class;\n+};\n+\n+GType garrow_struct_array_get_type(void) G_GNUC_CONST;\n+\n+GArrowStructArray *garrow_struct_array_new(GArrowDataType *data_type,\n+                                           gint64 length,\n+                                           GList *children,\n+                                           GArrowBuffer *null_bitmap,\n+                                           gint64 n_nulls);\n+\n+GArrowArray *garrow_struct_array_get_field(GArrowStructArray *array,\n+                                           gint i);\n+GList *garrow_struct_array_get_fields(GArrowStructArray *array);\n+\n+G_END_DECLS\ndiff --git a/c_glib/arrow-glib/composite-data-type.cpp b/c_glib/arrow-glib/composite-data-type.cpp\nindex ce3d78ca0..7ce8a978e 100644\n--- a/c_glib/arrow-glib/composite-data-type.cpp\n+++ b/c_glib/arrow-glib/composite-data-type.cpp\n@@ -21,6 +21,7 @@\n #  include <config.h>\n #endif\n \n+#include <arrow-glib/basic-array.hpp>\n #include <arrow-glib/data-type.hpp>\n #include <arrow-glib/enums.h>\n #include <arrow-glib/error.hpp>\n@@ -38,6 +39,8 @@ G_BEGIN_DECLS\n  * #GArrowListDataType is a class for list data type.\n  *\n  * #GArrowStructDataType is a class for struct data type.\n+ *\n+ * #GArrowDictionaryDataType is a class for dictionary data type.\n  */\n \n G_DEFINE_TYPE(GArrowListDataType,                \\\n@@ -133,4 +136,87 @@ garrow_struct_data_type_new(GList *fields)\n   return data_type;\n }\n \n+\n+G_DEFINE_TYPE(GArrowDictionaryDataType,                \\\n+              garrow_dictionary_data_type,             \\\n+              GARROW_TYPE_FIXED_WIDTH_DATA_TYPE)\n+\n+static void\n+garrow_dictionary_data_type_init(GArrowDictionaryDataType *object)\n+{\n+}\n+\n+static void\n+garrow_dictionary_data_type_class_init(GArrowDictionaryDataTypeClass *klass)\n+{\n+}\n+\n+/**\n+ * garrow_dictionary_data_type_new:\n+ * @index_data_type: The data type of index.\n+ * @dictionary: The dictionary.\n+ * @ordered: Whether dictionary contents are ordered or not.\n+ *\n+ * Returns: The newly created dictionary data type.\n+ */\n+GArrowDictionaryDataType *\n+garrow_dictionary_data_type_new(GArrowDataType *index_data_type,\n+                                GArrowArray *dictionary,\n+                                gboolean ordered)\n+{\n+  auto arrow_index_data_type = garrow_data_type_get_raw(index_data_type);\n+  auto arrow_dictionary = garrow_array_get_raw(dictionary);\n+  auto arrow_data_type = arrow::dictionary(arrow_index_data_type,\n+                                           arrow_dictionary,\n+                                           ordered);\n+  return GARROW_DICTIONARY_DATA_TYPE(garrow_data_type_new_raw(&arrow_data_type));\n+}\n+\n+/**\n+ * garrow_dictionary_data_type_get_index_data_type:\n+ * @data_type: The #GArrowDictionaryDataType.\n+ *\n+ * Returns: (transfer full): The #GArrowDataType of index.\n+ */\n+GArrowDataType *\n+garrow_dictionary_data_type_get_index_data_type(GArrowDictionaryDataType *data_type)\n+{\n+  auto arrow_data_type = garrow_data_type_get_raw(GARROW_DATA_TYPE(data_type));\n+  auto arrow_dictionary_data_type =\n+    std::static_pointer_cast<arrow::DictionaryType>(arrow_data_type);\n+  auto arrow_index_data_type = arrow_dictionary_data_type->index_type();\n+  return garrow_data_type_new_raw(&arrow_index_data_type);\n+}\n+\n+/**\n+ * garrow_dictionary_data_type_get_dictionary:\n+ * @data_type: The #GArrowDictionaryDataType.\n+ *\n+ * Returns: (transfer full): The dictionary as #GArrowArray.\n+ */\n+GArrowArray *\n+garrow_dictionary_data_type_get_dictionary(GArrowDictionaryDataType *data_type)\n+{\n+  auto arrow_data_type = garrow_data_type_get_raw(GARROW_DATA_TYPE(data_type));\n+  auto arrow_dictionary_data_type =\n+    std::static_pointer_cast<arrow::DictionaryType>(arrow_data_type);\n+  auto arrow_dictionary = arrow_dictionary_data_type->dictionary();\n+  return garrow_array_new_raw(&arrow_dictionary);\n+}\n+\n+/**\n+ * garrow_dictionary_data_type_is_ordered:\n+ * @data_type: The #GArrowDictionaryDataType.\n+ *\n+ * Returns: Whether dictionary contents are ordered or not.\n+ */\n+gboolean\n+garrow_dictionary_data_type_is_ordered(GArrowDictionaryDataType *data_type)\n+{\n+  auto arrow_data_type = garrow_data_type_get_raw(GARROW_DATA_TYPE(data_type));\n+  auto arrow_dictionary_data_type =\n+    std::static_pointer_cast<arrow::DictionaryType>(arrow_data_type);\n+  return arrow_dictionary_data_type->ordered();\n+}\n+\n G_END_DECLS\ndiff --git a/c_glib/arrow-glib/composite-data-type.h b/c_glib/arrow-glib/composite-data-type.h\nindex 9dac5bd84..11b83014f 100644\n--- a/c_glib/arrow-glib/composite-data-type.h\n+++ b/c_glib/arrow-glib/composite-data-type.h\n@@ -19,6 +19,7 @@\n \n #pragma once\n \n+#include <arrow-glib/basic-array.h>\n #include <arrow-glib/basic-data-type.h>\n #include <arrow-glib/field.h>\n \n@@ -112,4 +113,28 @@ struct _GArrowStructDataTypeClass\n GType                 garrow_struct_data_type_get_type (void) G_GNUC_CONST;\n GArrowStructDataType *garrow_struct_data_type_new      (GList *fields);\n \n+\n+#define GARROW_TYPE_DICTIONARY_DATA_TYPE (garrow_dictionary_data_type_get_type())\n+G_DECLARE_DERIVABLE_TYPE(GArrowDictionaryDataType,\n+                         garrow_dictionary_data_type,\n+                         GARROW,\n+                         DICTIONARY_DATA_TYPE,\n+                         GArrowFixedWidthDataType)\n+struct _GArrowDictionaryDataTypeClass\n+{\n+  GArrowFixedWidthDataTypeClass parent_class;\n+};\n+\n+GArrowDictionaryDataType *\n+garrow_dictionary_data_type_new(GArrowDataType *index_data_type,\n+                                GArrowArray *dictionary,\n+                                gboolean ordered);\n+GArrowDataType *\n+garrow_dictionary_data_type_get_index_data_type(GArrowDictionaryDataType *data_type);\n+GArrowArray *\n+garrow_dictionary_data_type_get_dictionary(GArrowDictionaryDataType *data_type);\n+gboolean\n+garrow_dictionary_data_type_is_ordered(GArrowDictionaryDataType *data_type);\n+\n+\n G_END_DECLS\ndiff --git a/c_glib/arrow-glib/meson.build b/c_glib/arrow-glib/meson.build\nindex aeec4172d..25968e69c 100644\n--- a/c_glib/arrow-glib/meson.build\n+++ b/c_glib/arrow-glib/meson.build\n@@ -18,12 +18,13 @@\n # under the License.\n \n sources = files(\n-  'array.cpp',\n   'array-builder.cpp',\n+  'basic-array.cpp',\n   'basic-data-type.cpp',\n   'buffer.cpp',\n   'chunked-array.cpp',\n   'column.cpp',\n+  'composite-array.cpp',\n   'composite-data-type.cpp',\n   'error.cpp',\n   'field.cpp',\n@@ -59,10 +60,12 @@ c_headers = files(\n   'array.h',\n   'array-builder.h',\n   'arrow-glib.h',\n+  'basic-array.h',\n   'basic-data-type.h',\n   'buffer.h',\n   'chunked-array.h',\n   'column.h',\n+  'composite-array.h',\n   'composite-data-type.h',\n   'data-type.h',\n   'error.h',\n@@ -102,6 +105,7 @@ cpp_headers = files(\n   'array.hpp',\n   'array-builder.hpp',\n   'arrow-glib.hpp',\n+  'basic-array.hpp',\n   'basic-data-type.hpp',\n   'buffer.hpp',\n   'chunked-array.hpp',\ndiff --git a/c_glib/doc/reference/arrow-glib-docs.xml b/c_glib/doc/reference/arrow-glib-docs.xml\nindex e267ea2f9..51e7b2a6a 100644\n--- a/c_glib/doc/reference/arrow-glib-docs.xml\n+++ b/c_glib/doc/reference/arrow-glib-docs.xml\n@@ -40,7 +40,8 @@\n     <title>Data</title>\n     <chapter id=\"array\">\n       <title>Array</title>\n-      <xi:include href=\"xml/array.xml\"/>\n+      <xi:include href=\"xml/basic-array.xml\"/>\n+      <xi:include href=\"xml/composite-array.xml\"/>\n     </chapter>\n     <chapter id=\"array-builder\">\n       <title>Array builder</title>\ndiff --git a/c_glib/test/test-dictionary-data-type.rb b/c_glib/test/test-dictionary-data-type.rb\nnew file mode 100644\nindex 000000000..5530a0415\n--- /dev/null\n+++ b/c_glib/test/test-dictionary-data-type.rb\n@@ -0,0 +1,56 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+class TestDictionaryDataType < Test::Unit::TestCase\n+  include Helper::Buildable\n+\n+  def setup\n+    @index_data_type = Arrow::Int32DataType.new\n+    @dictionary = build_string_array([\"C\", \"C++\", \"Ruby\"])\n+    @ordered = true\n+    @data_type = Arrow::DictionaryDataType.new(@index_data_type,\n+                                               @dictionary,\n+                                               @ordered)\n+  end\n+\n+  def test_type\n+    assert_equal(Arrow::Type::DICTIONARY, @data_type.id)\n+  end\n+\n+  def test_to_s\n+    assert_equal(\"dictionary<values=string, indices=int32, ordered=1>\",\n+                 @data_type.to_s)\n+  end\n+\n+  def test_bit_width\n+    assert_equal(32, @data_type.bit_width)\n+  end\n+\n+  def test_index_data_type\n+    assert_equal(@index_data_type, @data_type.index_data_type)\n+  end\n+\n+  def test_dictionary\n+    assert_equal(@dictionary, @data_type.dictionary)\n+  end\n+\n+  def test_ordered?\n+    assert do\n+      @data_type.ordered?\n+    end\n+  end\n+end\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-26T19:17:37.665+0000",
                    "updated": "2017-11-26T19:17:37.665+0000"
                }
            ],
            "maxResults": 3,
            "total": 3,
            "startAt": 0
        },
        "customfield_12311820": "0|i3n6xr:",
        "customfield_12314139": null
    }
}