{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13403973",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13403973",
    "key": "ARROW-14161",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12352360",
                "id": "12352360",
                "description": "",
                "name": "11.0.0",
                "archived": false,
                "released": false
            }
        ],
        "resolution": null,
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
            "name": "Minor",
            "id": "4"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=willjones127",
            "name": "willjones127",
            "key": "willjones127",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34058",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34058",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34058",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34058"
            },
            "displayName": "Will Jones",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/3",
            "description": "This issue is being actively worked on at the moment by the assignee.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/inprogress.png",
            "name": "In Progress",
            "id": "3",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/4",
                "id": 4,
                "key": "indeterminate",
                "colorName": "yellow",
                "name": "In Progress"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            },
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12332532",
                "id": "12332532",
                "name": "Documentation"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=rvernica",
            "name": "rvernica",
            "key": "rvernica",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=rvernica&avatarId=47392",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=rvernica&avatarId=47392",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=rvernica&avatarId=47392",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=rvernica&avatarId=47392"
            },
            "displayName": "Rares Vernica",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=rvernica",
            "name": "rvernica",
            "key": "rvernica",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=rvernica&avatarId=47392",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=rvernica&avatarId=47392",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=rvernica&avatarId=47392",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=rvernica&avatarId=47392"
            },
            "displayName": "Rares Vernica",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 16800,
            "total": 16800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 16800,
            "total": 16800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-14161/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 28,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13403973/worklog/805386",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wjones127 opened a new pull request, #14018:\nURL: https://github.com/apache/arrow/pull/14018\n\n   Also improving a few APIs along the way.\n\n\n",
                    "created": "2022-08-31T22:36:49.085+0000",
                    "updated": "2022-08-31T22:36:49.085+0000",
                    "started": "2022-08-31T22:36:49.085+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "805386",
                    "issueId": "13403973"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13403973/worklog/805387",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #14018:\nURL: https://github.com/apache/arrow/pull/14018#issuecomment-1233493508\n\n   https://issues.apache.org/jira/browse/ARROW-14161\n\n\n",
                    "created": "2022-08-31T22:37:17.017+0000",
                    "updated": "2022-08-31T22:37:17.017+0000",
                    "started": "2022-08-31T22:37:17.016+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "805387",
                    "issueId": "13403973"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13403973/worklog/805388",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wjones127 commented on code in PR #14018:\nURL: https://github.com/apache/arrow/pull/14018#discussion_r960079278\n\n\n##########\ncpp/src/parquet/properties.h:\n##########\n@@ -607,7 +622,7 @@ static constexpr bool kArrowDefaultUseThreads = false;\n // Default number of rows to read when using ::arrow::RecordBatchReader\n static constexpr int64_t kArrowDefaultBatchSize = 64 * 1024;\n \n-/// EXPERIMENTAL: Properties for configuring FileReader behavior.\n+/// Properties for configuring FileReader behavior.\n\nReview Comment:\n   TODO: discuss whether we want to remove this experimental.\n\n\n\n",
                    "created": "2022-08-31T22:38:36.602+0000",
                    "updated": "2022-08-31T22:38:36.602+0000",
                    "started": "2022-08-31T22:38:36.602+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "805388",
                    "issueId": "13403973"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13403973/worklog/808866",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wjones127 commented on PR #14018:\nURL: https://github.com/apache/arrow/pull/14018#issuecomment-1247263436\n\n   @github-actions crossbow submit preview-docs\n\n\n",
                    "created": "2022-09-14T20:23:54.440+0000",
                    "updated": "2022-09-14T20:23:54.440+0000",
                    "started": "2022-09-14T20:23:54.439+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "808866",
                    "issueId": "13403973"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13403973/worklog/808874",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #14018:\nURL: https://github.com/apache/arrow/pull/14018#issuecomment-1247289338\n\n   Revision: 4fb82ec494dc4d8ee21a03ce2be8b5fdee945dd1\n   \n   Submitted crossbow builds: [ursacomputing/crossbow @ actions-560c6c80dc](https://github.com/ursacomputing/crossbow/branches/all?query=actions-560c6c80dc)\n   \n   |Task|Status|\n   |----|------|\n   |preview-docs|[![Github Actions](https://github.com/ursacomputing/crossbow/workflows/Crossbow/badge.svg?branch=actions-560c6c80dc-github-preview-docs)](https://github.com/ursacomputing/crossbow/actions?query=branch:actions-560c6c80dc-github-preview-docs)|\n\n\n",
                    "created": "2022-09-14T20:51:31.333+0000",
                    "updated": "2022-09-14T20:51:31.333+0000",
                    "started": "2022-09-14T20:51:31.333+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "808874",
                    "issueId": "13403973"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13403973/worklog/812186",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wjones127 commented on PR #14018:\nURL: https://github.com/apache/arrow/pull/14018#issuecomment-1258403006\n\n   @ksuarez1423 would you be interested in reviewing this?\n\n\n",
                    "created": "2022-09-26T17:51:54.865+0000",
                    "updated": "2022-09-26T17:51:54.865+0000",
                    "started": "2022-09-26T17:51:54.864+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812186",
                    "issueId": "13403973"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13403973/worklog/812571",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ksuarez1423 commented on code in PR #14018:\nURL: https://github.com/apache/arrow/pull/14018#discussion_r981398668\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,298 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data for an entire\n+file or row group into an :class:`::arrow::Table`.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n+offered for ease of use and type-safety.  It is of course also useful\n+when data must be streamed as files are read and written\n+incrementally.\n+\n+Please note that the performance of the :class:`StreamReader` and\n+:class:`StreamWriter` classes will not be as good due to the type\n+checking and the fact that column values are processed one at a time.\n+\n+FileReader\n+----------\n+\n+The Parquet :class:`arrow::FileReader` requires a\n+:class:`::arrow::io::RandomAccessFile` instance representing the input\n+file.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 9-10,14\n+   :dedent: 2\n+\n+Finer-grained options are available through the\n+:class:`arrow::FileReaderBuilder` helper class, and the :class:`ReaderProperties`\n+and :class:`ArrowReaderProperties` classes.\n+\n+For reading as a stream of batches, use the :func:`arrow::FileReader::GetRecordBatchReader`.\n+It will use the batch size set in :class:`ArrowReaderProperties`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 25\n+   :dedent: 2\n+\n+Performance and Memory Efficiency\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+For remote filesystems, use read coalescing to reduce number of API calls:\n+\n+.. code-block:: cpp\n+\n+   auto reader_properties = parquet::ReaderProperties(pool);\n+   reader_properties.enable_buffered_stream();\n+   reader_properties.set_buffer_size(4096 * 4); // This is default value\n+\n+The defaults are generally tuned towards good performance, but parallel column\n+decoding is off by default. Enable it in the constructor of :class:`ArrowReaderProperties`:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties(/*use_threads=*/true);\n+\n+If memory efficiency is more important than performance, then:\n+\n+#. Do not turn on read coalescing (pre-buffering).\n+#. Read data in batches.\n+#. Turn off ``use_buffered_stream``.\n+\n+In addition, if you know certain columns contain many repeated values, you can\n+read them as dictionary encoded columns. This is enabled with the ``set_read_dictionary``\n+setting on :class:`ArrowReaderProperties`. If the files were written with Arrow\n+C++ and the ``store_schema`` was activated, then the original Arrow schema will\n+be automatically read and will override this setting.\n+\n+StreamReader\n+------------\n+\n+The :class:`StreamReader` allows for Parquet files to be read using\n+standard C++ input operators which ensures type-safety.\n+\n+Please note that types must match the schema exactly i.e. if the\n+schema field is an unsigned 16-bit integer then you must supply a\n+uint16_t type.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to read field by supplying the incorrect type.\n+\n+* Attempt to read beyond end of row.\n+\n+* Attempt to read beyond end of file.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_reader.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::ReadableFile> infile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         infile,\n+         arrow::io::ReadableFile::Open(\"test.parquet\"));\n+\n+      parquet::StreamReader os{parquet::ParquetFileReader::Open(infile)};\n+\n+      std::string article;\n+      float price;\n+      uint32_t quantity;\n+\n+      while ( !os.eof() )\n+      {\n+         os >> article >> price >> quantity >> parquet::EndRow;\n+         // ...\n+      }\n+   }\n+\n+Writing Parquet files\n+=====================\n+\n+WriteTable\n+----------\n+\n+The :func:`arrow::WriteTable` function writes an entire\n+:class:`::arrow::Table` to an output file.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 8-9\n+   :dedent: 2\n+\n+.. warning::\n+\n+   Column compression is off by default in C++. See below for how to choose a\n\nReview Comment:\n   It is unclear where below is without reviewing the page's table of contents ",
                    "created": "2022-09-27T15:52:08.230+0000",
                    "updated": "2022-09-27T15:52:08.230+0000",
                    "started": "2022-09-27T15:52:08.230+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812571",
                    "issueId": "13403973"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13403973/worklog/812663",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wjones127 commented on code in PR #14018:\nURL: https://github.com/apache/arrow/pull/14018#discussion_r981737422\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,298 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data for an entire\n+file or row group into an :class:`::arrow::Table`.\n\nReview Comment:\n   I'll delete the leading `::`. We are in the `parquet` namespace here, not `arrow`, and I think it would be confusing to include both, so I'll keep the `arrow::` prefixes.\n\n\n\n",
                    "created": "2022-09-27T21:38:35.473+0000",
                    "updated": "2022-09-27T21:38:35.473+0000",
                    "started": "2022-09-27T21:38:35.473+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812663",
                    "issueId": "13403973"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13403973/worklog/812664",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wjones127 commented on code in PR #14018:\nURL: https://github.com/apache/arrow/pull/14018#discussion_r981739196\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,298 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data for an entire\n+file or row group into an :class:`::arrow::Table`.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n+offered for ease of use and type-safety.  It is of course also useful\n+when data must be streamed as files are read and written\n+incrementally.\n+\n+Please note that the performance of the :class:`StreamReader` and\n+:class:`StreamWriter` classes will not be as good due to the type\n+checking and the fact that column values are processed one at a time.\n+\n+FileReader\n+----------\n+\n+The Parquet :class:`arrow::FileReader` requires a\n+:class:`::arrow::io::RandomAccessFile` instance representing the input\n+file.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 9-10,14\n+   :dedent: 2\n+\n+Finer-grained options are available through the\n\nReview Comment:\n   Well this is a user guide, not a tutorial, so I think the linearity expectation isn't as strong. Each snippet is meant to be a (mostly) standalone example.\n\n\n\n",
                    "created": "2022-09-27T21:41:20.983+0000",
                    "updated": "2022-09-27T21:41:20.983+0000",
                    "started": "2022-09-27T21:41:20.983+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812664",
                    "issueId": "13403973"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13403973/worklog/812665",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wjones127 commented on code in PR #14018:\nURL: https://github.com/apache/arrow/pull/14018#discussion_r981739792\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,298 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data for an entire\n+file or row group into an :class:`::arrow::Table`.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n\nReview Comment:\n   value by value, IIUC. I didn't touch this part of this docs since this part of the interface isn't that important.\n\n\n\n",
                    "created": "2022-09-27T21:42:11.722+0000",
                    "updated": "2022-09-27T21:42:11.722+0000",
                    "started": "2022-09-27T21:42:11.722+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812665",
                    "issueId": "13403973"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13403973/worklog/812666",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wjones127 commented on code in PR #14018:\nURL: https://github.com/apache/arrow/pull/14018#discussion_r981742612\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,298 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data for an entire\n+file or row group into an :class:`::arrow::Table`.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n+offered for ease of use and type-safety.  It is of course also useful\n+when data must be streamed as files are read and written\n+incrementally.\n+\n+Please note that the performance of the :class:`StreamReader` and\n+:class:`StreamWriter` classes will not be as good due to the type\n+checking and the fact that column values are processed one at a time.\n+\n+FileReader\n+----------\n+\n+The Parquet :class:`arrow::FileReader` requires a\n+:class:`::arrow::io::RandomAccessFile` instance representing the input\n+file.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 9-10,14\n+   :dedent: 2\n+\n+Finer-grained options are available through the\n+:class:`arrow::FileReaderBuilder` helper class, and the :class:`ReaderProperties`\n+and :class:`ArrowReaderProperties` classes.\n+\n+For reading as a stream of batches, use the :func:`arrow::FileReader::GetRecordBatchReader`.\n+It will use the batch size set in :class:`ArrowReaderProperties`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 25\n+   :dedent: 2\n+\n+Performance and Memory Efficiency\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+For remote filesystems, use read coalescing to reduce number of API calls:\n+\n+.. code-block:: cpp\n+\n+   auto reader_properties = parquet::ReaderProperties(pool);\n+   reader_properties.enable_buffered_stream();\n+   reader_properties.set_buffer_size(4096 * 4); // This is default value\n+\n+The defaults are generally tuned towards good performance, but parallel column\n+decoding is off by default. Enable it in the constructor of :class:`ArrowReaderProperties`:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties(/*use_threads=*/true);\n+\n+If memory efficiency is more important than performance, then:\n+\n+#. Do not turn on read coalescing (pre-buffering).\n\nReview Comment:\n   Well these are two distinct pieces of advice:\n   If you are using a remote filesystem: turn **on** prebuffering\n   If you care about reducing memory usage: turn **off** prebuffering\n\n\n\n",
                    "created": "2022-09-27T21:46:32.120+0000",
                    "updated": "2022-09-27T21:46:32.120+0000",
                    "started": "2022-09-27T21:46:32.120+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812666",
                    "issueId": "13403973"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13403973/worklog/812667",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wjones127 commented on code in PR #14018:\nURL: https://github.com/apache/arrow/pull/14018#discussion_r981745107\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,298 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data for an entire\n+file or row group into an :class:`::arrow::Table`.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n+offered for ease of use and type-safety.  It is of course also useful\n+when data must be streamed as files are read and written\n+incrementally.\n+\n+Please note that the performance of the :class:`StreamReader` and\n+:class:`StreamWriter` classes will not be as good due to the type\n+checking and the fact that column values are processed one at a time.\n+\n+FileReader\n+----------\n+\n+The Parquet :class:`arrow::FileReader` requires a\n+:class:`::arrow::io::RandomAccessFile` instance representing the input\n+file.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 9-10,14\n+   :dedent: 2\n+\n+Finer-grained options are available through the\n+:class:`arrow::FileReaderBuilder` helper class, and the :class:`ReaderProperties`\n+and :class:`ArrowReaderProperties` classes.\n+\n+For reading as a stream of batches, use the :func:`arrow::FileReader::GetRecordBatchReader`.\n+It will use the batch size set in :class:`ArrowReaderProperties`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 25\n+   :dedent: 2\n+\n+Performance and Memory Efficiency\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+For remote filesystems, use read coalescing to reduce number of API calls:\n+\n+.. code-block:: cpp\n+\n+   auto reader_properties = parquet::ReaderProperties(pool);\n+   reader_properties.enable_buffered_stream();\n+   reader_properties.set_buffer_size(4096 * 4); // This is default value\n+\n+The defaults are generally tuned towards good performance, but parallel column\n+decoding is off by default. Enable it in the constructor of :class:`ArrowReaderProperties`:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties(/*use_threads=*/true);\n+\n+If memory efficiency is more important than performance, then:\n+\n+#. Do not turn on read coalescing (pre-buffering).\n+#. Read data in batches.\n+#. Turn off ``use_buffered_stream``.\n+\n+In addition, if you know certain columns contain many repeated values, you can\n+read them as dictionary encoded columns. This is enabled with the ``set_read_dictionary``\n\nReview Comment:\n   Good question. I'll add a link to the glossary reference for now.\n   \n   But I don't see any mention of dictionary encoded columns in the user guide yet. I'll create a Jira to revamp the Arrays section, and make sure to include encoded columns.\n\n\n\n",
                    "created": "2022-09-27T21:49:57.003+0000",
                    "updated": "2022-09-27T21:49:57.003+0000",
                    "started": "2022-09-27T21:49:57.003+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812667",
                    "issueId": "13403973"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13403973/worklog/812685",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wjones127 commented on code in PR #14018:\nURL: https://github.com/apache/arrow/pull/14018#discussion_r981797920\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,298 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data for an entire\n+file or row group into an :class:`::arrow::Table`.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n+offered for ease of use and type-safety.  It is of course also useful\n+when data must be streamed as files are read and written\n+incrementally.\n+\n+Please note that the performance of the :class:`StreamReader` and\n+:class:`StreamWriter` classes will not be as good due to the type\n+checking and the fact that column values are processed one at a time.\n+\n+FileReader\n+----------\n+\n+The Parquet :class:`arrow::FileReader` requires a\n+:class:`::arrow::io::RandomAccessFile` instance representing the input\n+file.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 9-10,14\n+   :dedent: 2\n+\n+Finer-grained options are available through the\n+:class:`arrow::FileReaderBuilder` helper class, and the :class:`ReaderProperties`\n+and :class:`ArrowReaderProperties` classes.\n+\n+For reading as a stream of batches, use the :func:`arrow::FileReader::GetRecordBatchReader`.\n+It will use the batch size set in :class:`ArrowReaderProperties`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 25\n+   :dedent: 2\n+\n+Performance and Memory Efficiency\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+For remote filesystems, use read coalescing to reduce number of API calls:\n+\n+.. code-block:: cpp\n+\n+   auto reader_properties = parquet::ReaderProperties(pool);\n+   reader_properties.enable_buffered_stream();\n+   reader_properties.set_buffer_size(4096 * 4); // This is default value\n+\n+The defaults are generally tuned towards good performance, but parallel column\n+decoding is off by default. Enable it in the constructor of :class:`ArrowReaderProperties`:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties(/*use_threads=*/true);\n+\n+If memory efficiency is more important than performance, then:\n+\n+#. Do not turn on read coalescing (pre-buffering).\n+#. Read data in batches.\n+#. Turn off ``use_buffered_stream``.\n+\n+In addition, if you know certain columns contain many repeated values, you can\n+read them as dictionary encoded columns. This is enabled with the ``set_read_dictionary``\n+setting on :class:`ArrowReaderProperties`. If the files were written with Arrow\n+C++ and the ``store_schema`` was activated, then the original Arrow schema will\n+be automatically read and will override this setting.\n+\n+StreamReader\n+------------\n+\n+The :class:`StreamReader` allows for Parquet files to be read using\n+standard C++ input operators which ensures type-safety.\n+\n+Please note that types must match the schema exactly i.e. if the\n+schema field is an unsigned 16-bit integer then you must supply a\n+uint16_t type.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to read field by supplying the incorrect type.\n+\n+* Attempt to read beyond end of row.\n+\n+* Attempt to read beyond end of file.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_reader.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::ReadableFile> infile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         infile,\n+         arrow::io::ReadableFile::Open(\"test.parquet\"));\n+\n+      parquet::StreamReader os{parquet::ParquetFileReader::Open(infile)};\n+\n+      std::string article;\n+      float price;\n+      uint32_t quantity;\n+\n+      while ( !os.eof() )\n+      {\n+         os >> article >> price >> quantity >> parquet::EndRow;\n+         // ...\n+      }\n+   }\n+\n+Writing Parquet files\n+=====================\n+\n+WriteTable\n+----------\n+\n+The :func:`arrow::WriteTable` function writes an entire\n+:class:`::arrow::Table` to an output file.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 8-9\n+   :dedent: 2\n+\n+.. warning::\n+\n+   Column compression is off by default in C++. See below for how to choose a\n+   compression codec in the writer properties.\n+\n+To write out data batch-by-batch, use :class:`arrow::FileWriter`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 12-13,20,24\n+   :dedent: 2\n+\n+.. seealso::\n+\n+   For reading multi-file datasets or pushing down filters to prune row groups,\n+   see :ref:`Tabular Datasets<cpp-dataset>`.\n+\n+StreamWriter\n+------------\n+\n+The :class:`StreamWriter` allows for Parquet files to be written using\n+standard C++ output operators.  This type-safe approach also ensures\n+that rows are written without omitting fields and allows for new row\n+groups to be created automatically (after certain volume of data) or\n+explicitly by using the :type:`EndRowGroup` stream modifier.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to write a field using an incorrect type.\n+\n+* Attempt to write too many fields in a row.\n+\n+* Attempt to skip a required field.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_writer.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::FileOutputStream> outfile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         outfile,\n+         arrow::io::FileOutputStream::Open(\"test.parquet\"));\n+\n+      parquet::WriterProperties::Builder builder;\n+      std::shared_ptr<parquet::schema::GroupNode> schema;\n+\n+      // Set up builder with required compression type etc.\n+      // Define schema.\n+      // ...\n+\n+      parquet::StreamWriter os{\n+         parquet::ParquetFileWriter::Open(outfile, schema, builder.build())};\n+\n+      // Loop over some data structure which provides the required\n+      // fields to be written and write each row.\n+      for (const auto& a : getArticles())\n+      {\n+         os << a.name() << a.price() << a.quantity() << parquet::EndRow;\n+      }\n+   }\n+\n+Writer properties\n\nReview Comment:\n   Yeah I added the reader properties into the existing writer examples. I showcased setting compression to snappy and turning on saving the Arrow schema, which we recommend pretty much everyone does.\n\n\n\n",
                    "created": "2022-09-27T23:04:52.191+0000",
                    "updated": "2022-09-27T23:04:52.191+0000",
                    "started": "2022-09-27T23:04:52.191+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812685",
                    "issueId": "13403973"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13403973/worklog/813068",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ksuarez1423 commented on code in PR #14018:\nURL: https://github.com/apache/arrow/pull/14018#discussion_r982681341\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,298 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data for an entire\n+file or row group into an :class:`::arrow::Table`.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n+offered for ease of use and type-safety.  It is of course also useful\n+when data must be streamed as files are read and written\n+incrementally.\n+\n+Please note that the performance of the :class:`StreamReader` and\n+:class:`StreamWriter` classes will not be as good due to the type\n+checking and the fact that column values are processed one at a time.\n+\n+FileReader\n+----------\n+\n+The Parquet :class:`arrow::FileReader` requires a\n+:class:`::arrow::io::RandomAccessFile` instance representing the input\n+file.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 9-10,14\n+   :dedent: 2\n+\n+Finer-grained options are available through the\n\nReview Comment:\n   The linearity expectation isn't as strong, but I wasn't quite able to realize each snippet was standalone without a fresh header. \n\n\n\n",
                    "created": "2022-09-28T17:26:09.341+0000",
                    "updated": "2022-09-28T17:26:09.341+0000",
                    "started": "2022-09-28T17:26:09.340+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "813068",
                    "issueId": "13403973"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13403973/worklog/813069",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ksuarez1423 commented on code in PR #14018:\nURL: https://github.com/apache/arrow/pull/14018#discussion_r982683335\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,298 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data for an entire\n+file or row group into an :class:`::arrow::Table`.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n+offered for ease of use and type-safety.  It is of course also useful\n+when data must be streamed as files are read and written\n+incrementally.\n+\n+Please note that the performance of the :class:`StreamReader` and\n+:class:`StreamWriter` classes will not be as good due to the type\n+checking and the fact that column values are processed one at a time.\n+\n+FileReader\n+----------\n+\n+The Parquet :class:`arrow::FileReader` requires a\n+:class:`::arrow::io::RandomAccessFile` instance representing the input\n+file.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 9-10,14\n+   :dedent: 2\n+\n+Finer-grained options are available through the\n+:class:`arrow::FileReaderBuilder` helper class, and the :class:`ReaderProperties`\n+and :class:`ArrowReaderProperties` classes.\n+\n+For reading as a stream of batches, use the :func:`arrow::FileReader::GetRecordBatchReader`.\n+It will use the batch size set in :class:`ArrowReaderProperties`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 25\n+   :dedent: 2\n+\n+Performance and Memory Efficiency\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+For remote filesystems, use read coalescing to reduce number of API calls:\n+\n+.. code-block:: cpp\n+\n+   auto reader_properties = parquet::ReaderProperties(pool);\n+   reader_properties.enable_buffered_stream();\n+   reader_properties.set_buffer_size(4096 * 4); // This is default value\n+\n+The defaults are generally tuned towards good performance, but parallel column\n+decoding is off by default. Enable it in the constructor of :class:`ArrowReaderProperties`:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties(/*use_threads=*/true);\n+\n+If memory efficiency is more important than performance, then:\n+\n+#. Do not turn on read coalescing (pre-buffering).\n\nReview Comment:\n   No, I meant the \"(pre-buffering)\", the literal text; that you could drop the bit in parentheses if you wanted, if you added it to the previous \"read coalescing\" introduction.\n\n\n\n",
                    "created": "2022-09-28T17:28:14.422+0000",
                    "updated": "2022-09-28T17:28:14.422+0000",
                    "started": "2022-09-28T17:28:14.421+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "813069",
                    "issueId": "13403973"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13403973/worklog/816141",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #14018:\nURL: https://github.com/apache/arrow/pull/14018#discussion_r993399368\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,302 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data into Arrow Tables and Record\n+Batches.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n+offered for ease of use and type-safety.  It is of course also useful\n+when data must be streamed as files are read and written\n+incrementally.\n+\n+Please note that the performance of the :class:`StreamReader` and\n+:class:`StreamWriter` classes will not be as good due to the type\n+checking and the fact that column values are processed one at a time.\n+\n+FileReader\n+----------\n+\n+To read Parquet data into Arrow structures, use :class:`arrow::FileReader`.\n+To construct, it requires a :class:`::arrow::io::RandomAccessFile` instance \n+representing the input file. To read the whole file at once, \n+use :func:`arrow::FileReader::ReadTable`:\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 9-10,14\n+   :dedent: 2\n+\n+Finer-grained options are available through the\n+:class:`arrow::FileReaderBuilder` helper class, which accepts the :class:`ReaderProperties`\n+and :class:`ArrowReaderProperties` classes.\n+\n+For reading as a stream of batches, use the :func:`arrow::FileReader::GetRecordBatchReader`\n+method to retrieve a :class:`arrow::RecordBatchReader`. It will use the batch \n+size set in :class:`ArrowReaderProperties`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 25\n+   :dedent: 2\n+\n+.. seealso::\n+\n+   For reading multi-file datasets or pushing down filters to prune row groups,\n+   see :ref:`Tabular Datasets<cpp-dataset>`.\n+\n+Performance and Memory Efficiency\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+For remote filesystems, use read coalescing (pre-buffering) to reduce number of API calls:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties();\n+   reader_properties.set_prebuffer(true);\n+\n+The defaults are generally tuned towards good performance, but parallel column\n+decoding is off by default. Enable it in the constructor of :class:`ArrowReaderProperties`:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties(/*use_threads=*/true);\n+\n+If memory efficiency is more important than performance, then:\n+\n+#. Do *not* turn on read coalescing (pre-buffering) in :class:`parquet::ArrowReaderProperties`.\n+#. Read data in batches using :func:`arrow::FileReader::GetRecordBatchReader`.\n+#. Turn on ``enable_buffered_stream`` in :class:`parquet::ReaderProperties`.\n+\n+In addition, if you know certain columns contain many repeated values, you can\n+read them as :term:`dictionary encoded<dictionary-encoding>` columns. This is \n+enabled with the ``set_read_dictionary`` setting on :class:`ArrowReaderProperties`. \n+If the files were written with Arrow C++ and the ``store_schema`` was activated,\n+then the original Arrow schema will be automatically read and will override this\n+setting.\n+\n+StreamReader\n+------------\n+\n+The :class:`StreamReader` allows for Parquet files to be read using\n+standard C++ input operators which ensures type-safety.\n+\n+Please note that types must match the schema exactly i.e. if the\n+schema field is an unsigned 16-bit integer then you must supply a\n+uint16_t type.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to read field by supplying the incorrect type.\n+\n+* Attempt to read beyond end of row.\n+\n+* Attempt to read beyond end of file.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_reader.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::ReadableFile> infile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         infile,\n+         arrow::io::ReadableFile::Open(\"test.parquet\"));\n+\n+      parquet::StreamReader os{parquet::ParquetFileReader::Open(infile)};\n+\n+      std::string article;\n+      float price;\n+      uint32_t quantity;\n+\n+      while ( !os.eof() )\n+      {\n+         os >> article >> price >> quantity >> parquet::EndRow;\n+         // ...\n+      }\n+   }\n+\n+Writing Parquet files\n+=====================\n+\n+WriteTable\n+----------\n+\n+The :func:`arrow::WriteTable` function writes an entire\n+:class:`::arrow::Table` to an output file.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 19-21\n+   :dedent: 2\n+\n+.. warning::\n+\n+   Column compression is off by default in C++. See :ref:`below <parquet-writer-properties>` \n+   for how to choose a compression codec in the writer properties.\n+\n+To write out data batch-by-batch, use :class:`arrow::FileWriter`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 23-25,32,36\n+   :dedent: 2\n+\n+StreamWriter\n+------------\n+\n+The :class:`StreamWriter` allows for Parquet files to be written using\n+standard C++ output operators.  This type-safe approach also ensures\n+that rows are written without omitting fields and allows for new row\n+groups to be created automatically (after certain volume of data) or\n+explicitly by using the :type:`EndRowGroup` stream modifier.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to write a field using an incorrect type.\n+\n+* Attempt to write too many fields in a row.\n+\n+* Attempt to skip a required field.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_writer.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::FileOutputStream> outfile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         outfile,\n+         arrow::io::FileOutputStream::Open(\"test.parquet\"));\n+\n+      parquet::WriterProperties::Builder builder;\n+      std::shared_ptr<parquet::schema::GroupNode> schema;\n+\n+      // Set up builder with required compression type etc.\n+      // Define schema.\n+      // ...\n+\n+      parquet::StreamWriter os{\n+         parquet::ParquetFileWriter::Open(outfile, schema, builder.build())};\n+\n+      // Loop over some data structure which provides the required\n+      // fields to be written and write each row.\n+      for (const auto& a : getArticles())\n+      {\n+         os << a.name() << a.price() << a.quantity() << parquet::EndRow;\n+      }\n+   }\n+\n+.. _parquet-writer-properties:\n+\n+Writer properties\n+-----------------\n+\n+To configure how Parquet files are written, use the :class:`WriterProperties::Builder`:\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+   #include \"arrow/util/type_fwd.h\"\n+\n+   using parquet::WriterProperties;\n+   using parquet::ParquetVersion;\n+   using parquet::ParquetDataPageVersion;\n+   using arrow::Compression;\n+\n+   std::shared_ptr<WriterProperties> props = WriterProperties::Builder()\n+      .max_row_group_length(64 * 1024)\n+      .created_by(\"My Application\")\n+      .version(ParquetVersion::PARQUET_2_6)\n+      .data_page_version(ParquetDataPageVersion::V2)\n+      .compression(Compression::SNAPPY)\n+      .build();\n+\n+The ``max_row_group_length`` sets an upper bound that takes precedent over the\n+``chunk_size`` passed in the write methods.\n+\n+You can set the version of Parquet to write with ``version``, which determines\n+which logical types are available. In addition, you can set the data page version\n+with ``data_page_version``. It's V1 by default; setting to V2 will allow more\n+optimal compression (skipping compressing pages where there isn't a space \n+benefit), but not all readers support this data page version.\n+\n+Compression is off by default, but to get the most out of Parquet, you should \n+also choose a compression codec. You can choose one for the whole file or \n+choose one for individual columns. If you choose a mix, the file-level option\n+will apply to columns that don't have a specific compression codec. See \n+:class:`::arrow::Compression` for options.\n+\n+Column data encodings can likewise be applied at the file-level or at the \n+column level. By default, the writer will attempt to dictionary encode all \n\nReview Comment:\n   Perhaps\r\n   ```suggestion\r\n   column level. By default, the writer will attempt to dictionary-encode all \r\n   ```\n\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,302 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data into Arrow Tables and Record\n+Batches.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n+offered for ease of use and type-safety.  It is of course also useful\n+when data must be streamed as files are read and written\n+incrementally.\n+\n+Please note that the performance of the :class:`StreamReader` and\n+:class:`StreamWriter` classes will not be as good due to the type\n+checking and the fact that column values are processed one at a time.\n+\n+FileReader\n+----------\n+\n+To read Parquet data into Arrow structures, use :class:`arrow::FileReader`.\n+To construct, it requires a :class:`::arrow::io::RandomAccessFile` instance \n+representing the input file. To read the whole file at once, \n+use :func:`arrow::FileReader::ReadTable`:\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 9-10,14\n+   :dedent: 2\n+\n+Finer-grained options are available through the\n+:class:`arrow::FileReaderBuilder` helper class, which accepts the :class:`ReaderProperties`\n+and :class:`ArrowReaderProperties` classes.\n+\n+For reading as a stream of batches, use the :func:`arrow::FileReader::GetRecordBatchReader`\n+method to retrieve a :class:`arrow::RecordBatchReader`. It will use the batch \n+size set in :class:`ArrowReaderProperties`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 25\n+   :dedent: 2\n+\n+.. seealso::\n+\n+   For reading multi-file datasets or pushing down filters to prune row groups,\n+   see :ref:`Tabular Datasets<cpp-dataset>`.\n+\n+Performance and Memory Efficiency\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+For remote filesystems, use read coalescing (pre-buffering) to reduce number of API calls:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties();\n+   reader_properties.set_prebuffer(true);\n+\n+The defaults are generally tuned towards good performance, but parallel column\n+decoding is off by default. Enable it in the constructor of :class:`ArrowReaderProperties`:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties(/*use_threads=*/true);\n+\n+If memory efficiency is more important than performance, then:\n+\n+#. Do *not* turn on read coalescing (pre-buffering) in :class:`parquet::ArrowReaderProperties`.\n+#. Read data in batches using :func:`arrow::FileReader::GetRecordBatchReader`.\n+#. Turn on ``enable_buffered_stream`` in :class:`parquet::ReaderProperties`.\n+\n+In addition, if you know certain columns contain many repeated values, you can\n+read them as :term:`dictionary encoded<dictionary-encoding>` columns. This is \n+enabled with the ``set_read_dictionary`` setting on :class:`ArrowReaderProperties`. \n+If the files were written with Arrow C++ and the ``store_schema`` was activated,\n+then the original Arrow schema will be automatically read and will override this\n+setting.\n+\n+StreamReader\n+------------\n+\n+The :class:`StreamReader` allows for Parquet files to be read using\n+standard C++ input operators which ensures type-safety.\n+\n+Please note that types must match the schema exactly i.e. if the\n+schema field is an unsigned 16-bit integer then you must supply a\n+uint16_t type.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to read field by supplying the incorrect type.\n+\n+* Attempt to read beyond end of row.\n+\n+* Attempt to read beyond end of file.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_reader.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::ReadableFile> infile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         infile,\n+         arrow::io::ReadableFile::Open(\"test.parquet\"));\n+\n+      parquet::StreamReader os{parquet::ParquetFileReader::Open(infile)};\n+\n+      std::string article;\n+      float price;\n+      uint32_t quantity;\n+\n+      while ( !os.eof() )\n+      {\n+         os >> article >> price >> quantity >> parquet::EndRow;\n+         // ...\n+      }\n+   }\n+\n+Writing Parquet files\n+=====================\n+\n+WriteTable\n+----------\n+\n+The :func:`arrow::WriteTable` function writes an entire\n+:class:`::arrow::Table` to an output file.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 19-21\n+   :dedent: 2\n+\n+.. warning::\n+\n+   Column compression is off by default in C++. See :ref:`below <parquet-writer-properties>` \n+   for how to choose a compression codec in the writer properties.\n+\n+To write out data batch-by-batch, use :class:`arrow::FileWriter`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 23-25,32,36\n+   :dedent: 2\n+\n+StreamWriter\n+------------\n+\n+The :class:`StreamWriter` allows for Parquet files to be written using\n+standard C++ output operators.  This type-safe approach also ensures\n+that rows are written without omitting fields and allows for new row\n+groups to be created automatically (after certain volume of data) or\n+explicitly by using the :type:`EndRowGroup` stream modifier.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to write a field using an incorrect type.\n+\n+* Attempt to write too many fields in a row.\n+\n+* Attempt to skip a required field.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_writer.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::FileOutputStream> outfile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         outfile,\n+         arrow::io::FileOutputStream::Open(\"test.parquet\"));\n+\n+      parquet::WriterProperties::Builder builder;\n+      std::shared_ptr<parquet::schema::GroupNode> schema;\n+\n+      // Set up builder with required compression type etc.\n+      // Define schema.\n+      // ...\n+\n+      parquet::StreamWriter os{\n+         parquet::ParquetFileWriter::Open(outfile, schema, builder.build())};\n+\n+      // Loop over some data structure which provides the required\n+      // fields to be written and write each row.\n+      for (const auto& a : getArticles())\n+      {\n+         os << a.name() << a.price() << a.quantity() << parquet::EndRow;\n+      }\n+   }\n+\n+.. _parquet-writer-properties:\n+\n+Writer properties\n+-----------------\n+\n+To configure how Parquet files are written, use the :class:`WriterProperties::Builder`:\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+   #include \"arrow/util/type_fwd.h\"\n+\n+   using parquet::WriterProperties;\n+   using parquet::ParquetVersion;\n+   using parquet::ParquetDataPageVersion;\n+   using arrow::Compression;\n+\n+   std::shared_ptr<WriterProperties> props = WriterProperties::Builder()\n+      .max_row_group_length(64 * 1024)\n+      .created_by(\"My Application\")\n+      .version(ParquetVersion::PARQUET_2_6)\n+      .data_page_version(ParquetDataPageVersion::V2)\n+      .compression(Compression::SNAPPY)\n+      .build();\n+\n+The ``max_row_group_length`` sets an upper bound that takes precedent over the\n\nReview Comment:\n   An upper bound of what? The number of rows, or the number of bytes?\n\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,302 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data into Arrow Tables and Record\n+Batches.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n+offered for ease of use and type-safety.  It is of course also useful\n+when data must be streamed as files are read and written\n+incrementally.\n+\n+Please note that the performance of the :class:`StreamReader` and\n+:class:`StreamWriter` classes will not be as good due to the type\n+checking and the fact that column values are processed one at a time.\n+\n+FileReader\n+----------\n+\n+To read Parquet data into Arrow structures, use :class:`arrow::FileReader`.\n+To construct, it requires a :class:`::arrow::io::RandomAccessFile` instance \n+representing the input file. To read the whole file at once, \n+use :func:`arrow::FileReader::ReadTable`:\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 9-10,14\n+   :dedent: 2\n+\n+Finer-grained options are available through the\n+:class:`arrow::FileReaderBuilder` helper class, which accepts the :class:`ReaderProperties`\n+and :class:`ArrowReaderProperties` classes.\n+\n+For reading as a stream of batches, use the :func:`arrow::FileReader::GetRecordBatchReader`\n+method to retrieve a :class:`arrow::RecordBatchReader`. It will use the batch \n+size set in :class:`ArrowReaderProperties`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 25\n+   :dedent: 2\n+\n+.. seealso::\n+\n+   For reading multi-file datasets or pushing down filters to prune row groups,\n+   see :ref:`Tabular Datasets<cpp-dataset>`.\n+\n+Performance and Memory Efficiency\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+For remote filesystems, use read coalescing (pre-buffering) to reduce number of API calls:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties();\n+   reader_properties.set_prebuffer(true);\n+\n+The defaults are generally tuned towards good performance, but parallel column\n+decoding is off by default. Enable it in the constructor of :class:`ArrowReaderProperties`:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties(/*use_threads=*/true);\n+\n+If memory efficiency is more important than performance, then:\n+\n+#. Do *not* turn on read coalescing (pre-buffering) in :class:`parquet::ArrowReaderProperties`.\n+#. Read data in batches using :func:`arrow::FileReader::GetRecordBatchReader`.\n+#. Turn on ``enable_buffered_stream`` in :class:`parquet::ReaderProperties`.\n+\n+In addition, if you know certain columns contain many repeated values, you can\n+read them as :term:`dictionary encoded<dictionary-encoding>` columns. This is \n+enabled with the ``set_read_dictionary`` setting on :class:`ArrowReaderProperties`. \n+If the files were written with Arrow C++ and the ``store_schema`` was activated,\n+then the original Arrow schema will be automatically read and will override this\n+setting.\n+\n+StreamReader\n+------------\n+\n+The :class:`StreamReader` allows for Parquet files to be read using\n+standard C++ input operators which ensures type-safety.\n+\n+Please note that types must match the schema exactly i.e. if the\n+schema field is an unsigned 16-bit integer then you must supply a\n+uint16_t type.\n\nReview Comment:\n   ```suggestion\r\n   ``uint16_t`` type.\r\n   ```\n\n\n\n##########\ncpp/src/arrow/dataset/file_parquet_test.cc:\n##########\n@@ -112,8 +112,9 @@ class ParquetFormatHelper {\n       const std::shared_ptr<ArrowWriterProperties>& arrow_properties =\n           default_arrow_writer_properties()) {\n     std::unique_ptr<parquet::arrow::FileWriter> writer;\n-    RETURN_NOT_OK(parquet::arrow::FileWriter::Open(\n-        *reader->schema(), pool, sink, properties, arrow_properties, &writer));\n+    EXPECT_OK_AND_ASSIGN(writer,\n\nReview Comment:\n   Since this is returning a Status, should instead use `ARROW_ASSIGN_OR_RAISE` here.\n\n\n\n##########\ncpp/src/parquet/arrow/reader.h:\n##########\n@@ -180,6 +184,33 @@ class PARQUET_EXPORT FileReader {\n   virtual ::arrow::Status GetRecordBatchReader(\n       const std::vector<int>& row_group_indices, const std::vector<int>& column_indices,\n       std::unique_ptr<::arrow::RecordBatchReader>* out) = 0;\n+  ::arrow::Status GetRecordBatchReader(const std::vector<int>& row_group_indices,\n+                                       const std::vector<int>& column_indices,\n+                                       std::shared_ptr<::arrow::RecordBatchReader>* out);\n+\n+  /// \\brief Return a RecordBatchReader of row groups selected from\n+  /// row_group_indices, whose columns are selected by column_indices.\n+  ///\n+  /// \\param row_group_indices indices of which row groups to include.\n+  /// \\param column_indices indices of columns to include.\n+  ///\n+  /// \\since 10.0.0\n+  ::arrow::Result<std::shared_ptr<::arrow::RecordBatchReader>> GetRecordBatchReader(\n\nReview Comment:\n   Can we also deprecate the variants taking a pointer-out parameter above?\n\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,302 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data into Arrow Tables and Record\n+Batches.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n+offered for ease of use and type-safety.  It is of course also useful\n+when data must be streamed as files are read and written\n+incrementally.\n+\n+Please note that the performance of the :class:`StreamReader` and\n+:class:`StreamWriter` classes will not be as good due to the type\n+checking and the fact that column values are processed one at a time.\n+\n+FileReader\n+----------\n+\n+To read Parquet data into Arrow structures, use :class:`arrow::FileReader`.\n+To construct, it requires a :class:`::arrow::io::RandomAccessFile` instance \n+representing the input file. To read the whole file at once, \n+use :func:`arrow::FileReader::ReadTable`:\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 9-10,14\n+   :dedent: 2\n+\n+Finer-grained options are available through the\n+:class:`arrow::FileReaderBuilder` helper class, which accepts the :class:`ReaderProperties`\n+and :class:`ArrowReaderProperties` classes.\n+\n+For reading as a stream of batches, use the :func:`arrow::FileReader::GetRecordBatchReader`\n+method to retrieve a :class:`arrow::RecordBatchReader`. It will use the batch \n+size set in :class:`ArrowReaderProperties`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 25\n+   :dedent: 2\n+\n+.. seealso::\n+\n+   For reading multi-file datasets or pushing down filters to prune row groups,\n+   see :ref:`Tabular Datasets<cpp-dataset>`.\n+\n+Performance and Memory Efficiency\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+For remote filesystems, use read coalescing (pre-buffering) to reduce number of API calls:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties();\n+   reader_properties.set_prebuffer(true);\n+\n+The defaults are generally tuned towards good performance, but parallel column\n+decoding is off by default. Enable it in the constructor of :class:`ArrowReaderProperties`:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties(/*use_threads=*/true);\n+\n+If memory efficiency is more important than performance, then:\n+\n+#. Do *not* turn on read coalescing (pre-buffering) in :class:`parquet::ArrowReaderProperties`.\n+#. Read data in batches using :func:`arrow::FileReader::GetRecordBatchReader`.\n+#. Turn on ``enable_buffered_stream`` in :class:`parquet::ReaderProperties`.\n+\n+In addition, if you know certain columns contain many repeated values, you can\n+read them as :term:`dictionary encoded<dictionary-encoding>` columns. This is \n+enabled with the ``set_read_dictionary`` setting on :class:`ArrowReaderProperties`. \n+If the files were written with Arrow C++ and the ``store_schema`` was activated,\n+then the original Arrow schema will be automatically read and will override this\n+setting.\n+\n+StreamReader\n+------------\n+\n+The :class:`StreamReader` allows for Parquet files to be read using\n+standard C++ input operators which ensures type-safety.\n+\n+Please note that types must match the schema exactly i.e. if the\n+schema field is an unsigned 16-bit integer then you must supply a\n+uint16_t type.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to read field by supplying the incorrect type.\n+\n+* Attempt to read beyond end of row.\n+\n+* Attempt to read beyond end of file.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_reader.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::ReadableFile> infile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         infile,\n+         arrow::io::ReadableFile::Open(\"test.parquet\"));\n+\n+      parquet::StreamReader os{parquet::ParquetFileReader::Open(infile)};\n+\n+      std::string article;\n+      float price;\n+      uint32_t quantity;\n+\n+      while ( !os.eof() )\n+      {\n+         os >> article >> price >> quantity >> parquet::EndRow;\n+         // ...\n+      }\n+   }\n+\n+Writing Parquet files\n+=====================\n+\n+WriteTable\n+----------\n+\n+The :func:`arrow::WriteTable` function writes an entire\n+:class:`::arrow::Table` to an output file.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 19-21\n+   :dedent: 2\n+\n+.. warning::\n+\n+   Column compression is off by default in C++. See :ref:`below <parquet-writer-properties>` \n+   for how to choose a compression codec in the writer properties.\n+\n+To write out data batch-by-batch, use :class:`arrow::FileWriter`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 23-25,32,36\n+   :dedent: 2\n+\n+StreamWriter\n+------------\n+\n+The :class:`StreamWriter` allows for Parquet files to be written using\n+standard C++ output operators.  This type-safe approach also ensures\n+that rows are written without omitting fields and allows for new row\n+groups to be created automatically (after certain volume of data) or\n+explicitly by using the :type:`EndRowGroup` stream modifier.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to write a field using an incorrect type.\n+\n+* Attempt to write too many fields in a row.\n+\n+* Attempt to skip a required field.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_writer.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::FileOutputStream> outfile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         outfile,\n+         arrow::io::FileOutputStream::Open(\"test.parquet\"));\n+\n+      parquet::WriterProperties::Builder builder;\n+      std::shared_ptr<parquet::schema::GroupNode> schema;\n+\n+      // Set up builder with required compression type etc.\n+      // Define schema.\n+      // ...\n+\n+      parquet::StreamWriter os{\n+         parquet::ParquetFileWriter::Open(outfile, schema, builder.build())};\n+\n+      // Loop over some data structure which provides the required\n+      // fields to be written and write each row.\n+      for (const auto& a : getArticles())\n+      {\n+         os << a.name() << a.price() << a.quantity() << parquet::EndRow;\n+      }\n+   }\n+\n+.. _parquet-writer-properties:\n+\n+Writer properties\n+-----------------\n+\n+To configure how Parquet files are written, use the :class:`WriterProperties::Builder`:\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+   #include \"arrow/util/type_fwd.h\"\n+\n+   using parquet::WriterProperties;\n+   using parquet::ParquetVersion;\n+   using parquet::ParquetDataPageVersion;\n+   using arrow::Compression;\n+\n+   std::shared_ptr<WriterProperties> props = WriterProperties::Builder()\n+      .max_row_group_length(64 * 1024)\n+      .created_by(\"My Application\")\n+      .version(ParquetVersion::PARQUET_2_6)\n+      .data_page_version(ParquetDataPageVersion::V2)\n+      .compression(Compression::SNAPPY)\n+      .build();\n+\n+The ``max_row_group_length`` sets an upper bound that takes precedent over the\n+``chunk_size`` passed in the write methods.\n+\n+You can set the version of Parquet to write with ``version``, which determines\n+which logical types are available. In addition, you can set the data page version\n+with ``data_page_version``. It's V1 by default; setting to V2 will allow more\n+optimal compression (skipping compressing pages where there isn't a space \n+benefit), but not all readers support this data page version.\n+\n+Compression is off by default, but to get the most out of Parquet, you should \n+also choose a compression codec. You can choose one for the whole file or \n+choose one for individual columns. If you choose a mix, the file-level option\n+will apply to columns that don't have a specific compression codec. See \n+:class:`::arrow::Compression` for options.\n+\n+Column data encodings can likewise be applied at the file-level or at the \n+column level. By default, the writer will attempt to dictionary encode all \n+supported columns, unless the dictionary grows too large. This behavior can\n+be changed at file-level or at the column level with ``disable_dictionary()``.\n+When not using dictionary encoding, it will fallback to the encoding set for \n+the column or the overall file; by default ``Encoding::PLAIN``, but this can\n+be changed with ``encoding()``.\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+   #include \"arrow/util/type_fwd.h\"\n+\n+   using parquet::WriterProperties;\n+   using arrow::Compression;\n+   using parquet::Encoding;\n+\n+   std::shared_ptr<WriterProperties> props = WriterProperties::Builder()\n+     .compression(Compression::SNAPPY)        // Fallback\n+     ->compression(\"colA\", Compression::ZSTD) // Only applies to colA\n+     ->encoding(Encoding::BIT_PACKED)         // Fallback\n+     ->encoding(\"colB\", Encoding::RLE)        // Only applies to colB\n+     ->disable_dictionary(\"colB\")             // Always use RLE, never dictionary\n+     ->disable_statistics(\"colB\")             // Stats won't be written for colB\n\nReview Comment:\n   Is it useful to show how not to write statistics?\n\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,302 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data into Arrow Tables and Record\n+Batches.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n+offered for ease of use and type-safety.  It is of course also useful\n+when data must be streamed as files are read and written\n+incrementally.\n+\n+Please note that the performance of the :class:`StreamReader` and\n+:class:`StreamWriter` classes will not be as good due to the type\n+checking and the fact that column values are processed one at a time.\n+\n+FileReader\n+----------\n+\n+To read Parquet data into Arrow structures, use :class:`arrow::FileReader`.\n+To construct, it requires a :class:`::arrow::io::RandomAccessFile` instance \n+representing the input file. To read the whole file at once, \n+use :func:`arrow::FileReader::ReadTable`:\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 9-10,14\n+   :dedent: 2\n+\n+Finer-grained options are available through the\n+:class:`arrow::FileReaderBuilder` helper class, which accepts the :class:`ReaderProperties`\n+and :class:`ArrowReaderProperties` classes.\n+\n+For reading as a stream of batches, use the :func:`arrow::FileReader::GetRecordBatchReader`\n+method to retrieve a :class:`arrow::RecordBatchReader`. It will use the batch \n+size set in :class:`ArrowReaderProperties`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 25\n+   :dedent: 2\n+\n+.. seealso::\n+\n+   For reading multi-file datasets or pushing down filters to prune row groups,\n+   see :ref:`Tabular Datasets<cpp-dataset>`.\n+\n+Performance and Memory Efficiency\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+For remote filesystems, use read coalescing (pre-buffering) to reduce number of API calls:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties();\n+   reader_properties.set_prebuffer(true);\n+\n+The defaults are generally tuned towards good performance, but parallel column\n+decoding is off by default. Enable it in the constructor of :class:`ArrowReaderProperties`:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties(/*use_threads=*/true);\n+\n+If memory efficiency is more important than performance, then:\n+\n+#. Do *not* turn on read coalescing (pre-buffering) in :class:`parquet::ArrowReaderProperties`.\n+#. Read data in batches using :func:`arrow::FileReader::GetRecordBatchReader`.\n+#. Turn on ``enable_buffered_stream`` in :class:`parquet::ReaderProperties`.\n+\n+In addition, if you know certain columns contain many repeated values, you can\n+read them as :term:`dictionary encoded<dictionary-encoding>` columns. This is \n+enabled with the ``set_read_dictionary`` setting on :class:`ArrowReaderProperties`. \n+If the files were written with Arrow C++ and the ``store_schema`` was activated,\n+then the original Arrow schema will be automatically read and will override this\n+setting.\n+\n+StreamReader\n+------------\n+\n+The :class:`StreamReader` allows for Parquet files to be read using\n+standard C++ input operators which ensures type-safety.\n+\n+Please note that types must match the schema exactly i.e. if the\n+schema field is an unsigned 16-bit integer then you must supply a\n+uint16_t type.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to read field by supplying the incorrect type.\n+\n+* Attempt to read beyond end of row.\n+\n+* Attempt to read beyond end of file.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_reader.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::ReadableFile> infile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         infile,\n+         arrow::io::ReadableFile::Open(\"test.parquet\"));\n+\n+      parquet::StreamReader os{parquet::ParquetFileReader::Open(infile)};\n+\n+      std::string article;\n+      float price;\n+      uint32_t quantity;\n+\n+      while ( !os.eof() )\n+      {\n+         os >> article >> price >> quantity >> parquet::EndRow;\n+         // ...\n+      }\n+   }\n+\n+Writing Parquet files\n+=====================\n+\n+WriteTable\n+----------\n+\n+The :func:`arrow::WriteTable` function writes an entire\n+:class:`::arrow::Table` to an output file.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 19-21\n+   :dedent: 2\n+\n+.. warning::\n+\n+   Column compression is off by default in C++. See :ref:`below <parquet-writer-properties>` \n+   for how to choose a compression codec in the writer properties.\n+\n+To write out data batch-by-batch, use :class:`arrow::FileWriter`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 23-25,32,36\n+   :dedent: 2\n+\n+StreamWriter\n+------------\n+\n+The :class:`StreamWriter` allows for Parquet files to be written using\n+standard C++ output operators.  This type-safe approach also ensures\n+that rows are written without omitting fields and allows for new row\n+groups to be created automatically (after certain volume of data) or\n+explicitly by using the :type:`EndRowGroup` stream modifier.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to write a field using an incorrect type.\n+\n+* Attempt to write too many fields in a row.\n+\n+* Attempt to skip a required field.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_writer.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::FileOutputStream> outfile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         outfile,\n+         arrow::io::FileOutputStream::Open(\"test.parquet\"));\n+\n+      parquet::WriterProperties::Builder builder;\n+      std::shared_ptr<parquet::schema::GroupNode> schema;\n+\n+      // Set up builder with required compression type etc.\n+      // Define schema.\n+      // ...\n+\n+      parquet::StreamWriter os{\n+         parquet::ParquetFileWriter::Open(outfile, schema, builder.build())};\n+\n+      // Loop over some data structure which provides the required\n+      // fields to be written and write each row.\n+      for (const auto& a : getArticles())\n+      {\n+         os << a.name() << a.price() << a.quantity() << parquet::EndRow;\n+      }\n+   }\n+\n+.. _parquet-writer-properties:\n+\n+Writer properties\n+-----------------\n+\n+To configure how Parquet files are written, use the :class:`WriterProperties::Builder`:\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+   #include \"arrow/util/type_fwd.h\"\n+\n+   using parquet::WriterProperties;\n+   using parquet::ParquetVersion;\n+   using parquet::ParquetDataPageVersion;\n+   using arrow::Compression;\n+\n+   std::shared_ptr<WriterProperties> props = WriterProperties::Builder()\n+      .max_row_group_length(64 * 1024)\n+      .created_by(\"My Application\")\n+      .version(ParquetVersion::PARQUET_2_6)\n+      .data_page_version(ParquetDataPageVersion::V2)\n+      .compression(Compression::SNAPPY)\n+      .build();\n+\n+The ``max_row_group_length`` sets an upper bound that takes precedent over the\n+``chunk_size`` passed in the write methods.\n+\n+You can set the version of Parquet to write with ``version``, which determines\n+which logical types are available. In addition, you can set the data page version\n+with ``data_page_version``. It's V1 by default; setting to V2 will allow more\n+optimal compression (skipping compressing pages where there isn't a space \n+benefit), but not all readers support this data page version.\n+\n+Compression is off by default, but to get the most out of Parquet, you should \n+also choose a compression codec. You can choose one for the whole file or \n+choose one for individual columns. If you choose a mix, the file-level option\n+will apply to columns that don't have a specific compression codec. See \n+:class:`::arrow::Compression` for options.\n+\n+Column data encodings can likewise be applied at the file-level or at the \n+column level. By default, the writer will attempt to dictionary encode all \n+supported columns, unless the dictionary grows too large. This behavior can\n+be changed at file-level or at the column level with ``disable_dictionary()``.\n+When not using dictionary encoding, it will fallback to the encoding set for \n+the column or the overall file; by default ``Encoding::PLAIN``, but this can\n+be changed with ``encoding()``.\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+   #include \"arrow/util/type_fwd.h\"\n+\n+   using parquet::WriterProperties;\n+   using arrow::Compression;\n+   using parquet::Encoding;\n+\n+   std::shared_ptr<WriterProperties> props = WriterProperties::Builder()\n+     .compression(Compression::SNAPPY)        // Fallback\n+     ->compression(\"colA\", Compression::ZSTD) // Only applies to colA\n+     ->encoding(Encoding::BIT_PACKED)         // Fallback\n+     ->encoding(\"colB\", Encoding::RLE)        // Only applies to colB\n\nReview Comment:\n   ```suggestion\r\n        ->encoding(\"colB\", Encoding::RLE)        // Only applies to column \"colB\"\r\n   ```\n\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,302 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data into Arrow Tables and Record\n+Batches.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n+offered for ease of use and type-safety.  It is of course also useful\n+when data must be streamed as files are read and written\n+incrementally.\n+\n+Please note that the performance of the :class:`StreamReader` and\n+:class:`StreamWriter` classes will not be as good due to the type\n+checking and the fact that column values are processed one at a time.\n+\n+FileReader\n+----------\n+\n+To read Parquet data into Arrow structures, use :class:`arrow::FileReader`.\n+To construct, it requires a :class:`::arrow::io::RandomAccessFile` instance \n+representing the input file. To read the whole file at once, \n+use :func:`arrow::FileReader::ReadTable`:\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 9-10,14\n+   :dedent: 2\n+\n+Finer-grained options are available through the\n+:class:`arrow::FileReaderBuilder` helper class, which accepts the :class:`ReaderProperties`\n+and :class:`ArrowReaderProperties` classes.\n+\n+For reading as a stream of batches, use the :func:`arrow::FileReader::GetRecordBatchReader`\n+method to retrieve a :class:`arrow::RecordBatchReader`. It will use the batch \n+size set in :class:`ArrowReaderProperties`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 25\n+   :dedent: 2\n+\n+.. seealso::\n+\n+   For reading multi-file datasets or pushing down filters to prune row groups,\n+   see :ref:`Tabular Datasets<cpp-dataset>`.\n+\n+Performance and Memory Efficiency\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+For remote filesystems, use read coalescing (pre-buffering) to reduce number of API calls:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties();\n+   reader_properties.set_prebuffer(true);\n+\n+The defaults are generally tuned towards good performance, but parallel column\n+decoding is off by default. Enable it in the constructor of :class:`ArrowReaderProperties`:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties(/*use_threads=*/true);\n+\n+If memory efficiency is more important than performance, then:\n+\n+#. Do *not* turn on read coalescing (pre-buffering) in :class:`parquet::ArrowReaderProperties`.\n+#. Read data in batches using :func:`arrow::FileReader::GetRecordBatchReader`.\n+#. Turn on ``enable_buffered_stream`` in :class:`parquet::ReaderProperties`.\n+\n+In addition, if you know certain columns contain many repeated values, you can\n+read them as :term:`dictionary encoded<dictionary-encoding>` columns. This is \n+enabled with the ``set_read_dictionary`` setting on :class:`ArrowReaderProperties`. \n+If the files were written with Arrow C++ and the ``store_schema`` was activated,\n+then the original Arrow schema will be automatically read and will override this\n+setting.\n+\n+StreamReader\n+------------\n+\n+The :class:`StreamReader` allows for Parquet files to be read using\n+standard C++ input operators which ensures type-safety.\n+\n+Please note that types must match the schema exactly i.e. if the\n+schema field is an unsigned 16-bit integer then you must supply a\n+uint16_t type.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to read field by supplying the incorrect type.\n+\n+* Attempt to read beyond end of row.\n+\n+* Attempt to read beyond end of file.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_reader.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::ReadableFile> infile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         infile,\n+         arrow::io::ReadableFile::Open(\"test.parquet\"));\n+\n+      parquet::StreamReader os{parquet::ParquetFileReader::Open(infile)};\n+\n+      std::string article;\n+      float price;\n+      uint32_t quantity;\n+\n+      while ( !os.eof() )\n+      {\n+         os >> article >> price >> quantity >> parquet::EndRow;\n+         // ...\n+      }\n+   }\n+\n+Writing Parquet files\n+=====================\n+\n+WriteTable\n+----------\n+\n+The :func:`arrow::WriteTable` function writes an entire\n+:class:`::arrow::Table` to an output file.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 19-21\n+   :dedent: 2\n+\n+.. warning::\n+\n+   Column compression is off by default in C++. See :ref:`below <parquet-writer-properties>` \n+   for how to choose a compression codec in the writer properties.\n+\n+To write out data batch-by-batch, use :class:`arrow::FileWriter`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 23-25,32,36\n+   :dedent: 2\n+\n+StreamWriter\n+------------\n+\n+The :class:`StreamWriter` allows for Parquet files to be written using\n+standard C++ output operators.  This type-safe approach also ensures\n+that rows are written without omitting fields and allows for new row\n+groups to be created automatically (after certain volume of data) or\n+explicitly by using the :type:`EndRowGroup` stream modifier.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to write a field using an incorrect type.\n+\n+* Attempt to write too many fields in a row.\n+\n+* Attempt to skip a required field.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_writer.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::FileOutputStream> outfile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         outfile,\n+         arrow::io::FileOutputStream::Open(\"test.parquet\"));\n+\n+      parquet::WriterProperties::Builder builder;\n+      std::shared_ptr<parquet::schema::GroupNode> schema;\n+\n+      // Set up builder with required compression type etc.\n+      // Define schema.\n+      // ...\n+\n+      parquet::StreamWriter os{\n+         parquet::ParquetFileWriter::Open(outfile, schema, builder.build())};\n+\n+      // Loop over some data structure which provides the required\n+      // fields to be written and write each row.\n+      for (const auto& a : getArticles())\n+      {\n+         os << a.name() << a.price() << a.quantity() << parquet::EndRow;\n+      }\n+   }\n+\n+.. _parquet-writer-properties:\n+\n+Writer properties\n+-----------------\n+\n+To configure how Parquet files are written, use the :class:`WriterProperties::Builder`:\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+   #include \"arrow/util/type_fwd.h\"\n+\n+   using parquet::WriterProperties;\n+   using parquet::ParquetVersion;\n+   using parquet::ParquetDataPageVersion;\n+   using arrow::Compression;\n+\n+   std::shared_ptr<WriterProperties> props = WriterProperties::Builder()\n+      .max_row_group_length(64 * 1024)\n+      .created_by(\"My Application\")\n+      .version(ParquetVersion::PARQUET_2_6)\n+      .data_page_version(ParquetDataPageVersion::V2)\n+      .compression(Compression::SNAPPY)\n+      .build();\n+\n+The ``max_row_group_length`` sets an upper bound that takes precedent over the\n+``chunk_size`` passed in the write methods.\n+\n+You can set the version of Parquet to write with ``version``, which determines\n+which logical types are available. In addition, you can set the data page version\n+with ``data_page_version``. It's V1 by default; setting to V2 will allow more\n+optimal compression (skipping compressing pages where there isn't a space \n+benefit), but not all readers support this data page version.\n\nReview Comment:\n   Hmm, I'm not sure I understand your question @ksuarez1423 . Would you like to rephrase?\n\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,302 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data into Arrow Tables and Record\n+Batches.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n+offered for ease of use and type-safety.  It is of course also useful\n+when data must be streamed as files are read and written\n+incrementally.\n+\n+Please note that the performance of the :class:`StreamReader` and\n+:class:`StreamWriter` classes will not be as good due to the type\n+checking and the fact that column values are processed one at a time.\n+\n+FileReader\n+----------\n+\n+To read Parquet data into Arrow structures, use :class:`arrow::FileReader`.\n+To construct, it requires a :class:`::arrow::io::RandomAccessFile` instance \n+representing the input file. To read the whole file at once, \n+use :func:`arrow::FileReader::ReadTable`:\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 9-10,14\n+   :dedent: 2\n+\n+Finer-grained options are available through the\n+:class:`arrow::FileReaderBuilder` helper class, which accepts the :class:`ReaderProperties`\n+and :class:`ArrowReaderProperties` classes.\n+\n+For reading as a stream of batches, use the :func:`arrow::FileReader::GetRecordBatchReader`\n+method to retrieve a :class:`arrow::RecordBatchReader`. It will use the batch \n+size set in :class:`ArrowReaderProperties`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 25\n+   :dedent: 2\n+\n+.. seealso::\n+\n+   For reading multi-file datasets or pushing down filters to prune row groups,\n+   see :ref:`Tabular Datasets<cpp-dataset>`.\n+\n+Performance and Memory Efficiency\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+For remote filesystems, use read coalescing (pre-buffering) to reduce number of API calls:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties();\n+   reader_properties.set_prebuffer(true);\n+\n+The defaults are generally tuned towards good performance, but parallel column\n+decoding is off by default. Enable it in the constructor of :class:`ArrowReaderProperties`:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties(/*use_threads=*/true);\n+\n+If memory efficiency is more important than performance, then:\n+\n+#. Do *not* turn on read coalescing (pre-buffering) in :class:`parquet::ArrowReaderProperties`.\n+#. Read data in batches using :func:`arrow::FileReader::GetRecordBatchReader`.\n+#. Turn on ``enable_buffered_stream`` in :class:`parquet::ReaderProperties`.\n+\n+In addition, if you know certain columns contain many repeated values, you can\n+read them as :term:`dictionary encoded<dictionary-encoding>` columns. This is \n+enabled with the ``set_read_dictionary`` setting on :class:`ArrowReaderProperties`. \n+If the files were written with Arrow C++ and the ``store_schema`` was activated,\n+then the original Arrow schema will be automatically read and will override this\n+setting.\n+\n+StreamReader\n+------------\n+\n+The :class:`StreamReader` allows for Parquet files to be read using\n+standard C++ input operators which ensures type-safety.\n+\n+Please note that types must match the schema exactly i.e. if the\n+schema field is an unsigned 16-bit integer then you must supply a\n+uint16_t type.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to read field by supplying the incorrect type.\n+\n+* Attempt to read beyond end of row.\n+\n+* Attempt to read beyond end of file.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_reader.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::ReadableFile> infile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         infile,\n+         arrow::io::ReadableFile::Open(\"test.parquet\"));\n+\n+      parquet::StreamReader os{parquet::ParquetFileReader::Open(infile)};\n+\n+      std::string article;\n+      float price;\n+      uint32_t quantity;\n+\n+      while ( !os.eof() )\n+      {\n+         os >> article >> price >> quantity >> parquet::EndRow;\n+         // ...\n+      }\n+   }\n+\n+Writing Parquet files\n+=====================\n+\n+WriteTable\n+----------\n+\n+The :func:`arrow::WriteTable` function writes an entire\n+:class:`::arrow::Table` to an output file.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 19-21\n+   :dedent: 2\n+\n+.. warning::\n+\n+   Column compression is off by default in C++. See :ref:`below <parquet-writer-properties>` \n+   for how to choose a compression codec in the writer properties.\n+\n+To write out data batch-by-batch, use :class:`arrow::FileWriter`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 23-25,32,36\n+   :dedent: 2\n+\n+StreamWriter\n+------------\n+\n+The :class:`StreamWriter` allows for Parquet files to be written using\n+standard C++ output operators.  This type-safe approach also ensures\n+that rows are written without omitting fields and allows for new row\n+groups to be created automatically (after certain volume of data) or\n+explicitly by using the :type:`EndRowGroup` stream modifier.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to write a field using an incorrect type.\n+\n+* Attempt to write too many fields in a row.\n+\n+* Attempt to skip a required field.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_writer.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::FileOutputStream> outfile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         outfile,\n+         arrow::io::FileOutputStream::Open(\"test.parquet\"));\n+\n+      parquet::WriterProperties::Builder builder;\n+      std::shared_ptr<parquet::schema::GroupNode> schema;\n+\n+      // Set up builder with required compression type etc.\n+      // Define schema.\n+      // ...\n+\n+      parquet::StreamWriter os{\n+         parquet::ParquetFileWriter::Open(outfile, schema, builder.build())};\n+\n+      // Loop over some data structure which provides the required\n+      // fields to be written and write each row.\n+      for (const auto& a : getArticles())\n+      {\n+         os << a.name() << a.price() << a.quantity() << parquet::EndRow;\n+      }\n+   }\n+\n+.. _parquet-writer-properties:\n+\n+Writer properties\n+-----------------\n+\n+To configure how Parquet files are written, use the :class:`WriterProperties::Builder`:\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+   #include \"arrow/util/type_fwd.h\"\n+\n+   using parquet::WriterProperties;\n+   using parquet::ParquetVersion;\n+   using parquet::ParquetDataPageVersion;\n+   using arrow::Compression;\n+\n+   std::shared_ptr<WriterProperties> props = WriterProperties::Builder()\n+      .max_row_group_length(64 * 1024)\n+      .created_by(\"My Application\")\n+      .version(ParquetVersion::PARQUET_2_6)\n+      .data_page_version(ParquetDataPageVersion::V2)\n+      .compression(Compression::SNAPPY)\n+      .build();\n+\n+The ``max_row_group_length`` sets an upper bound that takes precedent over the\n+``chunk_size`` passed in the write methods.\n+\n+You can set the version of Parquet to write with ``version``, which determines\n+which logical types are available. In addition, you can set the data page version\n+with ``data_page_version``. It's V1 by default; setting to V2 will allow more\n+optimal compression (skipping compressing pages where there isn't a space \n+benefit), but not all readers support this data page version.\n+\n+Compression is off by default, but to get the most out of Parquet, you should \n+also choose a compression codec. You can choose one for the whole file or \n+choose one for individual columns. If you choose a mix, the file-level option\n+will apply to columns that don't have a specific compression codec. See \n+:class:`::arrow::Compression` for options.\n+\n+Column data encodings can likewise be applied at the file-level or at the \n+column level. By default, the writer will attempt to dictionary encode all \n+supported columns, unless the dictionary grows too large. This behavior can\n+be changed at file-level or at the column level with ``disable_dictionary()``.\n+When not using dictionary encoding, it will fallback to the encoding set for \n+the column or the overall file; by default ``Encoding::PLAIN``, but this can\n+be changed with ``encoding()``.\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+   #include \"arrow/util/type_fwd.h\"\n+\n+   using parquet::WriterProperties;\n+   using arrow::Compression;\n+   using parquet::Encoding;\n+\n+   std::shared_ptr<WriterProperties> props = WriterProperties::Builder()\n+     .compression(Compression::SNAPPY)        // Fallback\n+     ->compression(\"colA\", Compression::ZSTD) // Only applies to colA\n+     ->encoding(Encoding::BIT_PACKED)         // Fallback\n+     ->encoding(\"colB\", Encoding::RLE)        // Only applies to colB\n+     ->disable_dictionary(\"colB\")             // Always use RLE, never dictionary\n+     ->disable_statistics(\"colB\")             // Stats won't be written for colB\n+     ->build();\n+\n+Statistics are enabled by default for all columns. You can disable statistics for\n+all columns or specific columns using ``disable_statistics`` on the builder.\n+There is a ``max_statistics_size`` which limits the maximum number of bytes that\n+may be used for min and max values, useful for types like strings or binary blobs.\n+\n+There are also Arrow-specific settings that can be configured with\n+:class:`parquet::ArrowWriterProperties`:\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+\n+   using parquet::ArrowWriterProperties;\n+\n+   std::shared_ptr<ArrowWriterProperties> arrow_props = ArrowWriterProperties::Builder()\n+      .enable_deprecated_int96_timestamps() // default False\n+      ->store_schema() // default False\n+      ->enable_compliant_nested_types() // default False\n+      ->build();\n+\n+These options mostly dictate how Arrow types are converted to Parquet types.\n+Turning on ``store_schema`` will cause the writer to place the serialized Arrow\n\nReview Comment:\n   ```suggestion\r\n   Turning on ``store_schema`` will cause the writer to store the serialized Arrow\r\n   ```\n\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,302 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data into Arrow Tables and Record\n+Batches.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n+offered for ease of use and type-safety.  It is of course also useful\n+when data must be streamed as files are read and written\n+incrementally.\n+\n+Please note that the performance of the :class:`StreamReader` and\n+:class:`StreamWriter` classes will not be as good due to the type\n+checking and the fact that column values are processed one at a time.\n+\n+FileReader\n+----------\n+\n+To read Parquet data into Arrow structures, use :class:`arrow::FileReader`.\n+To construct, it requires a :class:`::arrow::io::RandomAccessFile` instance \n+representing the input file. To read the whole file at once, \n+use :func:`arrow::FileReader::ReadTable`:\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 9-10,14\n+   :dedent: 2\n+\n+Finer-grained options are available through the\n+:class:`arrow::FileReaderBuilder` helper class, which accepts the :class:`ReaderProperties`\n+and :class:`ArrowReaderProperties` classes.\n+\n+For reading as a stream of batches, use the :func:`arrow::FileReader::GetRecordBatchReader`\n+method to retrieve a :class:`arrow::RecordBatchReader`. It will use the batch \n+size set in :class:`ArrowReaderProperties`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 25\n+   :dedent: 2\n+\n+.. seealso::\n+\n+   For reading multi-file datasets or pushing down filters to prune row groups,\n+   see :ref:`Tabular Datasets<cpp-dataset>`.\n+\n+Performance and Memory Efficiency\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+For remote filesystems, use read coalescing (pre-buffering) to reduce number of API calls:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties();\n+   reader_properties.set_prebuffer(true);\n+\n+The defaults are generally tuned towards good performance, but parallel column\n+decoding is off by default. Enable it in the constructor of :class:`ArrowReaderProperties`:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties(/*use_threads=*/true);\n+\n+If memory efficiency is more important than performance, then:\n+\n+#. Do *not* turn on read coalescing (pre-buffering) in :class:`parquet::ArrowReaderProperties`.\n+#. Read data in batches using :func:`arrow::FileReader::GetRecordBatchReader`.\n+#. Turn on ``enable_buffered_stream`` in :class:`parquet::ReaderProperties`.\n+\n+In addition, if you know certain columns contain many repeated values, you can\n+read them as :term:`dictionary encoded<dictionary-encoding>` columns. This is \n+enabled with the ``set_read_dictionary`` setting on :class:`ArrowReaderProperties`. \n+If the files were written with Arrow C++ and the ``store_schema`` was activated,\n+then the original Arrow schema will be automatically read and will override this\n+setting.\n+\n+StreamReader\n+------------\n+\n+The :class:`StreamReader` allows for Parquet files to be read using\n+standard C++ input operators which ensures type-safety.\n+\n+Please note that types must match the schema exactly i.e. if the\n+schema field is an unsigned 16-bit integer then you must supply a\n+uint16_t type.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to read field by supplying the incorrect type.\n+\n+* Attempt to read beyond end of row.\n+\n+* Attempt to read beyond end of file.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_reader.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::ReadableFile> infile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         infile,\n+         arrow::io::ReadableFile::Open(\"test.parquet\"));\n+\n+      parquet::StreamReader os{parquet::ParquetFileReader::Open(infile)};\n+\n+      std::string article;\n+      float price;\n+      uint32_t quantity;\n+\n+      while ( !os.eof() )\n+      {\n+         os >> article >> price >> quantity >> parquet::EndRow;\n+         // ...\n+      }\n+   }\n+\n+Writing Parquet files\n+=====================\n+\n+WriteTable\n+----------\n+\n+The :func:`arrow::WriteTable` function writes an entire\n+:class:`::arrow::Table` to an output file.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 19-21\n+   :dedent: 2\n+\n+.. warning::\n+\n+   Column compression is off by default in C++. See :ref:`below <parquet-writer-properties>` \n+   for how to choose a compression codec in the writer properties.\n+\n+To write out data batch-by-batch, use :class:`arrow::FileWriter`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 23-25,32,36\n+   :dedent: 2\n+\n+StreamWriter\n+------------\n+\n+The :class:`StreamWriter` allows for Parquet files to be written using\n+standard C++ output operators.  This type-safe approach also ensures\n+that rows are written without omitting fields and allows for new row\n+groups to be created automatically (after certain volume of data) or\n+explicitly by using the :type:`EndRowGroup` stream modifier.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to write a field using an incorrect type.\n+\n+* Attempt to write too many fields in a row.\n+\n+* Attempt to skip a required field.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_writer.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::FileOutputStream> outfile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         outfile,\n+         arrow::io::FileOutputStream::Open(\"test.parquet\"));\n+\n+      parquet::WriterProperties::Builder builder;\n+      std::shared_ptr<parquet::schema::GroupNode> schema;\n+\n+      // Set up builder with required compression type etc.\n+      // Define schema.\n+      // ...\n+\n+      parquet::StreamWriter os{\n+         parquet::ParquetFileWriter::Open(outfile, schema, builder.build())};\n+\n+      // Loop over some data structure which provides the required\n+      // fields to be written and write each row.\n+      for (const auto& a : getArticles())\n+      {\n+         os << a.name() << a.price() << a.quantity() << parquet::EndRow;\n+      }\n+   }\n+\n+.. _parquet-writer-properties:\n+\n+Writer properties\n+-----------------\n+\n+To configure how Parquet files are written, use the :class:`WriterProperties::Builder`:\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+   #include \"arrow/util/type_fwd.h\"\n+\n+   using parquet::WriterProperties;\n+   using parquet::ParquetVersion;\n+   using parquet::ParquetDataPageVersion;\n+   using arrow::Compression;\n+\n+   std::shared_ptr<WriterProperties> props = WriterProperties::Builder()\n+      .max_row_group_length(64 * 1024)\n+      .created_by(\"My Application\")\n+      .version(ParquetVersion::PARQUET_2_6)\n+      .data_page_version(ParquetDataPageVersion::V2)\n+      .compression(Compression::SNAPPY)\n+      .build();\n+\n+The ``max_row_group_length`` sets an upper bound that takes precedent over the\n+``chunk_size`` passed in the write methods.\n+\n+You can set the version of Parquet to write with ``version``, which determines\n+which logical types are available. In addition, you can set the data page version\n+with ``data_page_version``. It's V1 by default; setting to V2 will allow more\n+optimal compression (skipping compressing pages where there isn't a space \n+benefit), but not all readers support this data page version.\n+\n+Compression is off by default, but to get the most out of Parquet, you should \n+also choose a compression codec. You can choose one for the whole file or \n+choose one for individual columns. If you choose a mix, the file-level option\n+will apply to columns that don't have a specific compression codec. See \n+:class:`::arrow::Compression` for options.\n+\n+Column data encodings can likewise be applied at the file-level or at the \n+column level. By default, the writer will attempt to dictionary encode all \n+supported columns, unless the dictionary grows too large. This behavior can\n+be changed at file-level or at the column level with ``disable_dictionary()``.\n+When not using dictionary encoding, it will fallback to the encoding set for \n+the column or the overall file; by default ``Encoding::PLAIN``, but this can\n+be changed with ``encoding()``.\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+   #include \"arrow/util/type_fwd.h\"\n+\n+   using parquet::WriterProperties;\n+   using arrow::Compression;\n+   using parquet::Encoding;\n+\n+   std::shared_ptr<WriterProperties> props = WriterProperties::Builder()\n+     .compression(Compression::SNAPPY)        // Fallback\n+     ->compression(\"colA\", Compression::ZSTD) // Only applies to colA\n+     ->encoding(Encoding::BIT_PACKED)         // Fallback\n+     ->encoding(\"colB\", Encoding::RLE)        // Only applies to colB\n+     ->disable_dictionary(\"colB\")             // Always use RLE, never dictionary\n\nReview Comment:\n   ```suggestion\r\n        ->disable_dictionary(\"colB\")             // Never dictionary-encode column \"colB\"\r\n   ```\n\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,302 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data into Arrow Tables and Record\n+Batches.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n+offered for ease of use and type-safety.  It is of course also useful\n+when data must be streamed as files are read and written\n+incrementally.\n+\n+Please note that the performance of the :class:`StreamReader` and\n+:class:`StreamWriter` classes will not be as good due to the type\n+checking and the fact that column values are processed one at a time.\n+\n+FileReader\n+----------\n+\n+To read Parquet data into Arrow structures, use :class:`arrow::FileReader`.\n+To construct, it requires a :class:`::arrow::io::RandomAccessFile` instance \n+representing the input file. To read the whole file at once, \n+use :func:`arrow::FileReader::ReadTable`:\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 9-10,14\n+   :dedent: 2\n+\n+Finer-grained options are available through the\n+:class:`arrow::FileReaderBuilder` helper class, which accepts the :class:`ReaderProperties`\n+and :class:`ArrowReaderProperties` classes.\n+\n+For reading as a stream of batches, use the :func:`arrow::FileReader::GetRecordBatchReader`\n+method to retrieve a :class:`arrow::RecordBatchReader`. It will use the batch \n+size set in :class:`ArrowReaderProperties`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 25\n+   :dedent: 2\n+\n+.. seealso::\n+\n+   For reading multi-file datasets or pushing down filters to prune row groups,\n+   see :ref:`Tabular Datasets<cpp-dataset>`.\n+\n+Performance and Memory Efficiency\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+For remote filesystems, use read coalescing (pre-buffering) to reduce number of API calls:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties();\n+   reader_properties.set_prebuffer(true);\n+\n+The defaults are generally tuned towards good performance, but parallel column\n+decoding is off by default. Enable it in the constructor of :class:`ArrowReaderProperties`:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties(/*use_threads=*/true);\n+\n+If memory efficiency is more important than performance, then:\n+\n+#. Do *not* turn on read coalescing (pre-buffering) in :class:`parquet::ArrowReaderProperties`.\n+#. Read data in batches using :func:`arrow::FileReader::GetRecordBatchReader`.\n+#. Turn on ``enable_buffered_stream`` in :class:`parquet::ReaderProperties`.\n+\n+In addition, if you know certain columns contain many repeated values, you can\n+read them as :term:`dictionary encoded<dictionary-encoding>` columns. This is \n+enabled with the ``set_read_dictionary`` setting on :class:`ArrowReaderProperties`. \n+If the files were written with Arrow C++ and the ``store_schema`` was activated,\n+then the original Arrow schema will be automatically read and will override this\n+setting.\n+\n+StreamReader\n+------------\n+\n+The :class:`StreamReader` allows for Parquet files to be read using\n+standard C++ input operators which ensures type-safety.\n+\n+Please note that types must match the schema exactly i.e. if the\n+schema field is an unsigned 16-bit integer then you must supply a\n+uint16_t type.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to read field by supplying the incorrect type.\n+\n+* Attempt to read beyond end of row.\n+\n+* Attempt to read beyond end of file.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_reader.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::ReadableFile> infile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         infile,\n+         arrow::io::ReadableFile::Open(\"test.parquet\"));\n+\n+      parquet::StreamReader os{parquet::ParquetFileReader::Open(infile)};\n+\n+      std::string article;\n+      float price;\n+      uint32_t quantity;\n+\n+      while ( !os.eof() )\n+      {\n+         os >> article >> price >> quantity >> parquet::EndRow;\n+         // ...\n+      }\n+   }\n+\n+Writing Parquet files\n+=====================\n+\n+WriteTable\n+----------\n+\n+The :func:`arrow::WriteTable` function writes an entire\n+:class:`::arrow::Table` to an output file.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 19-21\n+   :dedent: 2\n+\n+.. warning::\n+\n+   Column compression is off by default in C++. See :ref:`below <parquet-writer-properties>` \n+   for how to choose a compression codec in the writer properties.\n+\n+To write out data batch-by-batch, use :class:`arrow::FileWriter`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 23-25,32,36\n+   :dedent: 2\n+\n+StreamWriter\n+------------\n+\n+The :class:`StreamWriter` allows for Parquet files to be written using\n+standard C++ output operators.  This type-safe approach also ensures\n+that rows are written without omitting fields and allows for new row\n+groups to be created automatically (after certain volume of data) or\n+explicitly by using the :type:`EndRowGroup` stream modifier.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to write a field using an incorrect type.\n+\n+* Attempt to write too many fields in a row.\n+\n+* Attempt to skip a required field.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_writer.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::FileOutputStream> outfile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         outfile,\n+         arrow::io::FileOutputStream::Open(\"test.parquet\"));\n+\n+      parquet::WriterProperties::Builder builder;\n+      std::shared_ptr<parquet::schema::GroupNode> schema;\n+\n+      // Set up builder with required compression type etc.\n+      // Define schema.\n+      // ...\n+\n+      parquet::StreamWriter os{\n+         parquet::ParquetFileWriter::Open(outfile, schema, builder.build())};\n+\n+      // Loop over some data structure which provides the required\n+      // fields to be written and write each row.\n+      for (const auto& a : getArticles())\n+      {\n+         os << a.name() << a.price() << a.quantity() << parquet::EndRow;\n+      }\n+   }\n+\n+.. _parquet-writer-properties:\n+\n+Writer properties\n+-----------------\n+\n+To configure how Parquet files are written, use the :class:`WriterProperties::Builder`:\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+   #include \"arrow/util/type_fwd.h\"\n+\n+   using parquet::WriterProperties;\n+   using parquet::ParquetVersion;\n+   using parquet::ParquetDataPageVersion;\n+   using arrow::Compression;\n+\n+   std::shared_ptr<WriterProperties> props = WriterProperties::Builder()\n+      .max_row_group_length(64 * 1024)\n+      .created_by(\"My Application\")\n+      .version(ParquetVersion::PARQUET_2_6)\n+      .data_page_version(ParquetDataPageVersion::V2)\n+      .compression(Compression::SNAPPY)\n+      .build();\n+\n+The ``max_row_group_length`` sets an upper bound that takes precedent over the\n+``chunk_size`` passed in the write methods.\n+\n+You can set the version of Parquet to write with ``version``, which determines\n+which logical types are available. In addition, you can set the data page version\n+with ``data_page_version``. It's V1 by default; setting to V2 will allow more\n+optimal compression (skipping compressing pages where there isn't a space \n+benefit), but not all readers support this data page version.\n+\n+Compression is off by default, but to get the most out of Parquet, you should \n+also choose a compression codec. You can choose one for the whole file or \n+choose one for individual columns. If you choose a mix, the file-level option\n+will apply to columns that don't have a specific compression codec. See \n+:class:`::arrow::Compression` for options.\n+\n+Column data encodings can likewise be applied at the file-level or at the \n+column level. By default, the writer will attempt to dictionary encode all \n+supported columns, unless the dictionary grows too large. This behavior can\n+be changed at file-level or at the column level with ``disable_dictionary()``.\n+When not using dictionary encoding, it will fallback to the encoding set for \n+the column or the overall file; by default ``Encoding::PLAIN``, but this can\n+be changed with ``encoding()``.\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+   #include \"arrow/util/type_fwd.h\"\n+\n+   using parquet::WriterProperties;\n+   using arrow::Compression;\n+   using parquet::Encoding;\n+\n+   std::shared_ptr<WriterProperties> props = WriterProperties::Builder()\n+     .compression(Compression::SNAPPY)        // Fallback\n+     ->compression(\"colA\", Compression::ZSTD) // Only applies to colA\n\nReview Comment:\n   ```suggestion\r\n        ->compression(\"colA\", Compression::ZSTD) // Only applies to column \"colA\"\r\n   ```\n\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,302 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data into Arrow Tables and Record\n+Batches.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n+offered for ease of use and type-safety.  It is of course also useful\n+when data must be streamed as files are read and written\n+incrementally.\n+\n+Please note that the performance of the :class:`StreamReader` and\n+:class:`StreamWriter` classes will not be as good due to the type\n+checking and the fact that column values are processed one at a time.\n+\n+FileReader\n+----------\n+\n+To read Parquet data into Arrow structures, use :class:`arrow::FileReader`.\n+To construct, it requires a :class:`::arrow::io::RandomAccessFile` instance \n+representing the input file. To read the whole file at once, \n+use :func:`arrow::FileReader::ReadTable`:\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 9-10,14\n+   :dedent: 2\n+\n+Finer-grained options are available through the\n+:class:`arrow::FileReaderBuilder` helper class, which accepts the :class:`ReaderProperties`\n+and :class:`ArrowReaderProperties` classes.\n+\n+For reading as a stream of batches, use the :func:`arrow::FileReader::GetRecordBatchReader`\n+method to retrieve a :class:`arrow::RecordBatchReader`. It will use the batch \n+size set in :class:`ArrowReaderProperties`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 25\n+   :dedent: 2\n+\n+.. seealso::\n+\n+   For reading multi-file datasets or pushing down filters to prune row groups,\n+   see :ref:`Tabular Datasets<cpp-dataset>`.\n+\n+Performance and Memory Efficiency\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+For remote filesystems, use read coalescing (pre-buffering) to reduce number of API calls:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties();\n+   reader_properties.set_prebuffer(true);\n+\n+The defaults are generally tuned towards good performance, but parallel column\n+decoding is off by default. Enable it in the constructor of :class:`ArrowReaderProperties`:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties(/*use_threads=*/true);\n+\n+If memory efficiency is more important than performance, then:\n+\n+#. Do *not* turn on read coalescing (pre-buffering) in :class:`parquet::ArrowReaderProperties`.\n+#. Read data in batches using :func:`arrow::FileReader::GetRecordBatchReader`.\n+#. Turn on ``enable_buffered_stream`` in :class:`parquet::ReaderProperties`.\n+\n+In addition, if you know certain columns contain many repeated values, you can\n+read them as :term:`dictionary encoded<dictionary-encoding>` columns. This is \n+enabled with the ``set_read_dictionary`` setting on :class:`ArrowReaderProperties`. \n+If the files were written with Arrow C++ and the ``store_schema`` was activated,\n+then the original Arrow schema will be automatically read and will override this\n+setting.\n+\n+StreamReader\n+------------\n+\n+The :class:`StreamReader` allows for Parquet files to be read using\n+standard C++ input operators which ensures type-safety.\n+\n+Please note that types must match the schema exactly i.e. if the\n+schema field is an unsigned 16-bit integer then you must supply a\n+uint16_t type.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to read field by supplying the incorrect type.\n+\n+* Attempt to read beyond end of row.\n+\n+* Attempt to read beyond end of file.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_reader.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::ReadableFile> infile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         infile,\n+         arrow::io::ReadableFile::Open(\"test.parquet\"));\n+\n+      parquet::StreamReader os{parquet::ParquetFileReader::Open(infile)};\n\nReview Comment:\n   I tend to implicitly interpret ``os`` as \"output stream\", which is misleading here. Just call it ``stream`` perhaps?\n\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,302 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data into Arrow Tables and Record\n+Batches.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n+offered for ease of use and type-safety.  It is of course also useful\n+when data must be streamed as files are read and written\n+incrementally.\n+\n+Please note that the performance of the :class:`StreamReader` and\n+:class:`StreamWriter` classes will not be as good due to the type\n+checking and the fact that column values are processed one at a time.\n+\n+FileReader\n+----------\n+\n+To read Parquet data into Arrow structures, use :class:`arrow::FileReader`.\n+To construct, it requires a :class:`::arrow::io::RandomAccessFile` instance \n+representing the input file. To read the whole file at once, \n+use :func:`arrow::FileReader::ReadTable`:\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 9-10,14\n+   :dedent: 2\n+\n+Finer-grained options are available through the\n+:class:`arrow::FileReaderBuilder` helper class, which accepts the :class:`ReaderProperties`\n+and :class:`ArrowReaderProperties` classes.\n+\n+For reading as a stream of batches, use the :func:`arrow::FileReader::GetRecordBatchReader`\n+method to retrieve a :class:`arrow::RecordBatchReader`. It will use the batch \n+size set in :class:`ArrowReaderProperties`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 25\n+   :dedent: 2\n+\n+.. seealso::\n+\n+   For reading multi-file datasets or pushing down filters to prune row groups,\n+   see :ref:`Tabular Datasets<cpp-dataset>`.\n+\n+Performance and Memory Efficiency\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+For remote filesystems, use read coalescing (pre-buffering) to reduce number of API calls:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties();\n+   reader_properties.set_prebuffer(true);\n+\n+The defaults are generally tuned towards good performance, but parallel column\n+decoding is off by default. Enable it in the constructor of :class:`ArrowReaderProperties`:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties(/*use_threads=*/true);\n+\n+If memory efficiency is more important than performance, then:\n+\n+#. Do *not* turn on read coalescing (pre-buffering) in :class:`parquet::ArrowReaderProperties`.\n+#. Read data in batches using :func:`arrow::FileReader::GetRecordBatchReader`.\n+#. Turn on ``enable_buffered_stream`` in :class:`parquet::ReaderProperties`.\n+\n+In addition, if you know certain columns contain many repeated values, you can\n+read them as :term:`dictionary encoded<dictionary-encoding>` columns. This is \n+enabled with the ``set_read_dictionary`` setting on :class:`ArrowReaderProperties`. \n+If the files were written with Arrow C++ and the ``store_schema`` was activated,\n+then the original Arrow schema will be automatically read and will override this\n+setting.\n+\n+StreamReader\n+------------\n+\n+The :class:`StreamReader` allows for Parquet files to be read using\n+standard C++ input operators which ensures type-safety.\n+\n+Please note that types must match the schema exactly i.e. if the\n+schema field is an unsigned 16-bit integer then you must supply a\n+uint16_t type.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to read field by supplying the incorrect type.\n+\n+* Attempt to read beyond end of row.\n+\n+* Attempt to read beyond end of file.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_reader.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::ReadableFile> infile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         infile,\n+         arrow::io::ReadableFile::Open(\"test.parquet\"));\n+\n+      parquet::StreamReader os{parquet::ParquetFileReader::Open(infile)};\n+\n+      std::string article;\n+      float price;\n+      uint32_t quantity;\n+\n+      while ( !os.eof() )\n+      {\n+         os >> article >> price >> quantity >> parquet::EndRow;\n+         // ...\n+      }\n+   }\n+\n+Writing Parquet files\n+=====================\n+\n+WriteTable\n+----------\n+\n+The :func:`arrow::WriteTable` function writes an entire\n+:class:`::arrow::Table` to an output file.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 19-21\n+   :dedent: 2\n+\n+.. warning::\n+\n+   Column compression is off by default in C++. See :ref:`below <parquet-writer-properties>` \n+   for how to choose a compression codec in the writer properties.\n+\n+To write out data batch-by-batch, use :class:`arrow::FileWriter`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 23-25,32,36\n+   :dedent: 2\n+\n+StreamWriter\n+------------\n+\n+The :class:`StreamWriter` allows for Parquet files to be written using\n+standard C++ output operators.  This type-safe approach also ensures\n+that rows are written without omitting fields and allows for new row\n+groups to be created automatically (after certain volume of data) or\n+explicitly by using the :type:`EndRowGroup` stream modifier.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to write a field using an incorrect type.\n+\n+* Attempt to write too many fields in a row.\n+\n+* Attempt to skip a required field.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_writer.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::FileOutputStream> outfile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         outfile,\n+         arrow::io::FileOutputStream::Open(\"test.parquet\"));\n+\n+      parquet::WriterProperties::Builder builder;\n+      std::shared_ptr<parquet::schema::GroupNode> schema;\n+\n+      // Set up builder with required compression type etc.\n+      // Define schema.\n+      // ...\n+\n+      parquet::StreamWriter os{\n+         parquet::ParquetFileWriter::Open(outfile, schema, builder.build())};\n+\n+      // Loop over some data structure which provides the required\n+      // fields to be written and write each row.\n+      for (const auto& a : getArticles())\n+      {\n+         os << a.name() << a.price() << a.quantity() << parquet::EndRow;\n+      }\n+   }\n+\n+.. _parquet-writer-properties:\n+\n+Writer properties\n+-----------------\n+\n+To configure how Parquet files are written, use the :class:`WriterProperties::Builder`:\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+   #include \"arrow/util/type_fwd.h\"\n+\n+   using parquet::WriterProperties;\n+   using parquet::ParquetVersion;\n+   using parquet::ParquetDataPageVersion;\n+   using arrow::Compression;\n+\n+   std::shared_ptr<WriterProperties> props = WriterProperties::Builder()\n+      .max_row_group_length(64 * 1024)\n+      .created_by(\"My Application\")\n+      .version(ParquetVersion::PARQUET_2_6)\n+      .data_page_version(ParquetDataPageVersion::V2)\n+      .compression(Compression::SNAPPY)\n+      .build();\n+\n+The ``max_row_group_length`` sets an upper bound that takes precedent over the\n+``chunk_size`` passed in the write methods.\n+\n+You can set the version of Parquet to write with ``version``, which determines\n+which logical types are available. In addition, you can set the data page version\n+with ``data_page_version``. It's V1 by default; setting to V2 will allow more\n+optimal compression (skipping compressing pages where there isn't a space \n+benefit), but not all readers support this data page version.\n+\n+Compression is off by default, but to get the most out of Parquet, you should \n+also choose a compression codec. You can choose one for the whole file or \n+choose one for individual columns. If you choose a mix, the file-level option\n+will apply to columns that don't have a specific compression codec. See \n+:class:`::arrow::Compression` for options.\n+\n+Column data encodings can likewise be applied at the file-level or at the \n+column level. By default, the writer will attempt to dictionary encode all \n+supported columns, unless the dictionary grows too large. This behavior can\n+be changed at file-level or at the column level with ``disable_dictionary()``.\n+When not using dictionary encoding, it will fallback to the encoding set for \n+the column or the overall file; by default ``Encoding::PLAIN``, but this can\n+be changed with ``encoding()``.\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+   #include \"arrow/util/type_fwd.h\"\n+\n+   using parquet::WriterProperties;\n+   using arrow::Compression;\n+   using parquet::Encoding;\n+\n+   std::shared_ptr<WriterProperties> props = WriterProperties::Builder()\n+     .compression(Compression::SNAPPY)        // Fallback\n+     ->compression(\"colA\", Compression::ZSTD) // Only applies to colA\n+     ->encoding(Encoding::BIT_PACKED)         // Fallback\n+     ->encoding(\"colB\", Encoding::RLE)        // Only applies to colB\n+     ->disable_dictionary(\"colB\")             // Always use RLE, never dictionary\n+     ->disable_statistics(\"colB\")             // Stats won't be written for colB\n+     ->build();\n+\n+Statistics are enabled by default for all columns. You can disable statistics for\n+all columns or specific columns using ``disable_statistics`` on the builder.\n+There is a ``max_statistics_size`` which limits the maximum number of bytes that\n+may be used for min and max values, useful for types like strings or binary blobs.\n+\n+There are also Arrow-specific settings that can be configured with\n+:class:`parquet::ArrowWriterProperties`:\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+\n+   using parquet::ArrowWriterProperties;\n+\n+   std::shared_ptr<ArrowWriterProperties> arrow_props = ArrowWriterProperties::Builder()\n+      .enable_deprecated_int96_timestamps() // default False\n+      ->store_schema() // default False\n+      ->enable_compliant_nested_types() // default False\n+      ->build();\n+\n+These options mostly dictate how Arrow types are converted to Parquet types.\n+Turning on ``store_schema`` will cause the writer to place the serialized Arrow\n+schema within the file metadata. This allows the Arrow reader to automatically\n+determine which columns should be read back as dictionary-encoded columns,\n+potentially saving memory.\n\nReview Comment:\n   Not only dictionary encoding is concerned. You can take a look at the existing rules [here](https://github.com/apache/arrow/blob/a9d2504b02f7c40a6c2dbed2a69ab6c447c1fa5b/cpp/src/parquet/arrow/schema.cc#L827-L996).\r\n   \r\n   ```suggestion\r\n   schema within the file metadata. Since there is no bijection between Parquet\r\n   schemas and Arrow schemas, storing the Arrow schema allows the Arrow reader\r\n   to more faithfully recreate the original data.\r\n   ```\n\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,302 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data into Arrow Tables and Record\n+Batches.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n+offered for ease of use and type-safety.  It is of course also useful\n+when data must be streamed as files are read and written\n+incrementally.\n+\n+Please note that the performance of the :class:`StreamReader` and\n+:class:`StreamWriter` classes will not be as good due to the type\n+checking and the fact that column values are processed one at a time.\n+\n+FileReader\n+----------\n+\n+To read Parquet data into Arrow structures, use :class:`arrow::FileReader`.\n+To construct, it requires a :class:`::arrow::io::RandomAccessFile` instance \n+representing the input file. To read the whole file at once, \n+use :func:`arrow::FileReader::ReadTable`:\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 9-10,14\n+   :dedent: 2\n+\n+Finer-grained options are available through the\n+:class:`arrow::FileReaderBuilder` helper class, which accepts the :class:`ReaderProperties`\n+and :class:`ArrowReaderProperties` classes.\n+\n+For reading as a stream of batches, use the :func:`arrow::FileReader::GetRecordBatchReader`\n+method to retrieve a :class:`arrow::RecordBatchReader`. It will use the batch \n+size set in :class:`ArrowReaderProperties`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 25\n+   :dedent: 2\n+\n+.. seealso::\n+\n+   For reading multi-file datasets or pushing down filters to prune row groups,\n+   see :ref:`Tabular Datasets<cpp-dataset>`.\n+\n+Performance and Memory Efficiency\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+For remote filesystems, use read coalescing (pre-buffering) to reduce number of API calls:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties();\n+   reader_properties.set_prebuffer(true);\n+\n+The defaults are generally tuned towards good performance, but parallel column\n+decoding is off by default. Enable it in the constructor of :class:`ArrowReaderProperties`:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties(/*use_threads=*/true);\n+\n+If memory efficiency is more important than performance, then:\n+\n+#. Do *not* turn on read coalescing (pre-buffering) in :class:`parquet::ArrowReaderProperties`.\n+#. Read data in batches using :func:`arrow::FileReader::GetRecordBatchReader`.\n+#. Turn on ``enable_buffered_stream`` in :class:`parquet::ReaderProperties`.\n+\n+In addition, if you know certain columns contain many repeated values, you can\n+read them as :term:`dictionary encoded<dictionary-encoding>` columns. This is \n+enabled with the ``set_read_dictionary`` setting on :class:`ArrowReaderProperties`. \n+If the files were written with Arrow C++ and the ``store_schema`` was activated,\n+then the original Arrow schema will be automatically read and will override this\n+setting.\n+\n+StreamReader\n+------------\n+\n+The :class:`StreamReader` allows for Parquet files to be read using\n+standard C++ input operators which ensures type-safety.\n+\n+Please note that types must match the schema exactly i.e. if the\n+schema field is an unsigned 16-bit integer then you must supply a\n+uint16_t type.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to read field by supplying the incorrect type.\n+\n+* Attempt to read beyond end of row.\n+\n+* Attempt to read beyond end of file.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_reader.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::ReadableFile> infile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         infile,\n+         arrow::io::ReadableFile::Open(\"test.parquet\"));\n+\n+      parquet::StreamReader os{parquet::ParquetFileReader::Open(infile)};\n+\n+      std::string article;\n+      float price;\n+      uint32_t quantity;\n+\n+      while ( !os.eof() )\n+      {\n+         os >> article >> price >> quantity >> parquet::EndRow;\n+         // ...\n+      }\n+   }\n+\n+Writing Parquet files\n+=====================\n+\n+WriteTable\n+----------\n+\n+The :func:`arrow::WriteTable` function writes an entire\n+:class:`::arrow::Table` to an output file.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 19-21\n+   :dedent: 2\n+\n+.. warning::\n\nReview Comment:\n   We should keep warnings for dangerous things, experimental API markers, etc.\r\n   \r\n   ```suggestion\r\n   .. note::\r\n   ```\n\n\n\n",
                    "created": "2022-10-12T12:42:15.513+0000",
                    "updated": "2022-10-12T12:42:15.513+0000",
                    "started": "2022-10-12T12:42:15.513+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "816141",
                    "issueId": "13403973"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13403973/worklog/818122",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wjones127 commented on code in PR #14018:\nURL: https://github.com/apache/arrow/pull/14018#discussion_r998632424\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,302 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data into Arrow Tables and Record\n+Batches.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n+offered for ease of use and type-safety.  It is of course also useful\n+when data must be streamed as files are read and written\n+incrementally.\n+\n+Please note that the performance of the :class:`StreamReader` and\n+:class:`StreamWriter` classes will not be as good due to the type\n+checking and the fact that column values are processed one at a time.\n+\n+FileReader\n+----------\n+\n+To read Parquet data into Arrow structures, use :class:`arrow::FileReader`.\n+To construct, it requires a :class:`::arrow::io::RandomAccessFile` instance \n+representing the input file. To read the whole file at once, \n+use :func:`arrow::FileReader::ReadTable`:\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 9-10,14\n+   :dedent: 2\n+\n+Finer-grained options are available through the\n+:class:`arrow::FileReaderBuilder` helper class, which accepts the :class:`ReaderProperties`\n+and :class:`ArrowReaderProperties` classes.\n+\n+For reading as a stream of batches, use the :func:`arrow::FileReader::GetRecordBatchReader`\n+method to retrieve a :class:`arrow::RecordBatchReader`. It will use the batch \n+size set in :class:`ArrowReaderProperties`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 25\n+   :dedent: 2\n+\n+.. seealso::\n+\n+   For reading multi-file datasets or pushing down filters to prune row groups,\n+   see :ref:`Tabular Datasets<cpp-dataset>`.\n+\n+Performance and Memory Efficiency\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+For remote filesystems, use read coalescing (pre-buffering) to reduce number of API calls:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties();\n+   reader_properties.set_prebuffer(true);\n+\n+The defaults are generally tuned towards good performance, but parallel column\n+decoding is off by default. Enable it in the constructor of :class:`ArrowReaderProperties`:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties(/*use_threads=*/true);\n+\n+If memory efficiency is more important than performance, then:\n+\n+#. Do *not* turn on read coalescing (pre-buffering) in :class:`parquet::ArrowReaderProperties`.\n+#. Read data in batches using :func:`arrow::FileReader::GetRecordBatchReader`.\n+#. Turn on ``enable_buffered_stream`` in :class:`parquet::ReaderProperties`.\n+\n+In addition, if you know certain columns contain many repeated values, you can\n+read them as :term:`dictionary encoded<dictionary-encoding>` columns. This is \n+enabled with the ``set_read_dictionary`` setting on :class:`ArrowReaderProperties`. \n+If the files were written with Arrow C++ and the ``store_schema`` was activated,\n+then the original Arrow schema will be automatically read and will override this\n+setting.\n+\n+StreamReader\n+------------\n+\n+The :class:`StreamReader` allows for Parquet files to be read using\n+standard C++ input operators which ensures type-safety.\n+\n+Please note that types must match the schema exactly i.e. if the\n+schema field is an unsigned 16-bit integer then you must supply a\n+uint16_t type.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to read field by supplying the incorrect type.\n+\n+* Attempt to read beyond end of row.\n+\n+* Attempt to read beyond end of file.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_reader.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::ReadableFile> infile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         infile,\n+         arrow::io::ReadableFile::Open(\"test.parquet\"));\n+\n+      parquet::StreamReader os{parquet::ParquetFileReader::Open(infile)};\n+\n+      std::string article;\n+      float price;\n+      uint32_t quantity;\n+\n+      while ( !os.eof() )\n+      {\n+         os >> article >> price >> quantity >> parquet::EndRow;\n+         // ...\n+      }\n+   }\n+\n+Writing Parquet files\n+=====================\n+\n+WriteTable\n+----------\n+\n+The :func:`arrow::WriteTable` function writes an entire\n+:class:`::arrow::Table` to an output file.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 19-21\n+   :dedent: 2\n+\n+.. warning::\n+\n+   Column compression is off by default in C++. See :ref:`below <parquet-writer-properties>` \n+   for how to choose a compression codec in the writer properties.\n+\n+To write out data batch-by-batch, use :class:`arrow::FileWriter`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 23-25,32,36\n+   :dedent: 2\n+\n+StreamWriter\n+------------\n+\n+The :class:`StreamWriter` allows for Parquet files to be written using\n+standard C++ output operators.  This type-safe approach also ensures\n+that rows are written without omitting fields and allows for new row\n+groups to be created automatically (after certain volume of data) or\n+explicitly by using the :type:`EndRowGroup` stream modifier.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to write a field using an incorrect type.\n+\n+* Attempt to write too many fields in a row.\n+\n+* Attempt to skip a required field.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_writer.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::FileOutputStream> outfile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         outfile,\n+         arrow::io::FileOutputStream::Open(\"test.parquet\"));\n+\n+      parquet::WriterProperties::Builder builder;\n+      std::shared_ptr<parquet::schema::GroupNode> schema;\n+\n+      // Set up builder with required compression type etc.\n+      // Define schema.\n+      // ...\n+\n+      parquet::StreamWriter os{\n+         parquet::ParquetFileWriter::Open(outfile, schema, builder.build())};\n+\n+      // Loop over some data structure which provides the required\n+      // fields to be written and write each row.\n+      for (const auto& a : getArticles())\n+      {\n+         os << a.name() << a.price() << a.quantity() << parquet::EndRow;\n+      }\n+   }\n+\n+.. _parquet-writer-properties:\n+\n+Writer properties\n+-----------------\n+\n+To configure how Parquet files are written, use the :class:`WriterProperties::Builder`:\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+   #include \"arrow/util/type_fwd.h\"\n+\n+   using parquet::WriterProperties;\n+   using parquet::ParquetVersion;\n+   using parquet::ParquetDataPageVersion;\n+   using arrow::Compression;\n+\n+   std::shared_ptr<WriterProperties> props = WriterProperties::Builder()\n+      .max_row_group_length(64 * 1024)\n+      .created_by(\"My Application\")\n+      .version(ParquetVersion::PARQUET_2_6)\n+      .data_page_version(ParquetDataPageVersion::V2)\n+      .compression(Compression::SNAPPY)\n+      .build();\n+\n+The ``max_row_group_length`` sets an upper bound that takes precedent over the\n+``chunk_size`` passed in the write methods.\n+\n+You can set the version of Parquet to write with ``version``, which determines\n+which logical types are available. In addition, you can set the data page version\n+with ``data_page_version``. It's V1 by default; setting to V2 will allow more\n+optimal compression (skipping compressing pages where there isn't a space \n+benefit), but not all readers support this data page version.\n\nReview Comment:\n   I think Kae is asking which readers don't support V2 pages; I think listing that support matrix is out-of-scope of this PR, but it would be nice to see.\n\n\n\n",
                    "created": "2022-10-18T19:34:52.306+0000",
                    "updated": "2022-10-18T19:34:52.306+0000",
                    "started": "2022-10-18T19:34:52.306+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "818122",
                    "issueId": "13403973"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13403973/worklog/818123",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #14018:\nURL: https://github.com/apache/arrow/pull/14018#discussion_r998634636\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,302 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data into Arrow Tables and Record\n+Batches.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n+offered for ease of use and type-safety.  It is of course also useful\n+when data must be streamed as files are read and written\n+incrementally.\n+\n+Please note that the performance of the :class:`StreamReader` and\n+:class:`StreamWriter` classes will not be as good due to the type\n+checking and the fact that column values are processed one at a time.\n+\n+FileReader\n+----------\n+\n+To read Parquet data into Arrow structures, use :class:`arrow::FileReader`.\n+To construct, it requires a :class:`::arrow::io::RandomAccessFile` instance \n+representing the input file. To read the whole file at once, \n+use :func:`arrow::FileReader::ReadTable`:\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 9-10,14\n+   :dedent: 2\n+\n+Finer-grained options are available through the\n+:class:`arrow::FileReaderBuilder` helper class, which accepts the :class:`ReaderProperties`\n+and :class:`ArrowReaderProperties` classes.\n+\n+For reading as a stream of batches, use the :func:`arrow::FileReader::GetRecordBatchReader`\n+method to retrieve a :class:`arrow::RecordBatchReader`. It will use the batch \n+size set in :class:`ArrowReaderProperties`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 25\n+   :dedent: 2\n+\n+.. seealso::\n+\n+   For reading multi-file datasets or pushing down filters to prune row groups,\n+   see :ref:`Tabular Datasets<cpp-dataset>`.\n+\n+Performance and Memory Efficiency\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+For remote filesystems, use read coalescing (pre-buffering) to reduce number of API calls:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties();\n+   reader_properties.set_prebuffer(true);\n+\n+The defaults are generally tuned towards good performance, but parallel column\n+decoding is off by default. Enable it in the constructor of :class:`ArrowReaderProperties`:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties(/*use_threads=*/true);\n+\n+If memory efficiency is more important than performance, then:\n+\n+#. Do *not* turn on read coalescing (pre-buffering) in :class:`parquet::ArrowReaderProperties`.\n+#. Read data in batches using :func:`arrow::FileReader::GetRecordBatchReader`.\n+#. Turn on ``enable_buffered_stream`` in :class:`parquet::ReaderProperties`.\n+\n+In addition, if you know certain columns contain many repeated values, you can\n+read them as :term:`dictionary encoded<dictionary-encoding>` columns. This is \n+enabled with the ``set_read_dictionary`` setting on :class:`ArrowReaderProperties`. \n+If the files were written with Arrow C++ and the ``store_schema`` was activated,\n+then the original Arrow schema will be automatically read and will override this\n+setting.\n+\n+StreamReader\n+------------\n+\n+The :class:`StreamReader` allows for Parquet files to be read using\n+standard C++ input operators which ensures type-safety.\n+\n+Please note that types must match the schema exactly i.e. if the\n+schema field is an unsigned 16-bit integer then you must supply a\n+uint16_t type.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to read field by supplying the incorrect type.\n+\n+* Attempt to read beyond end of row.\n+\n+* Attempt to read beyond end of file.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_reader.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::ReadableFile> infile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         infile,\n+         arrow::io::ReadableFile::Open(\"test.parquet\"));\n+\n+      parquet::StreamReader os{parquet::ParquetFileReader::Open(infile)};\n+\n+      std::string article;\n+      float price;\n+      uint32_t quantity;\n+\n+      while ( !os.eof() )\n+      {\n+         os >> article >> price >> quantity >> parquet::EndRow;\n+         // ...\n+      }\n+   }\n+\n+Writing Parquet files\n+=====================\n+\n+WriteTable\n+----------\n+\n+The :func:`arrow::WriteTable` function writes an entire\n+:class:`::arrow::Table` to an output file.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 19-21\n+   :dedent: 2\n+\n+.. warning::\n+\n+   Column compression is off by default in C++. See :ref:`below <parquet-writer-properties>` \n+   for how to choose a compression codec in the writer properties.\n+\n+To write out data batch-by-batch, use :class:`arrow::FileWriter`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 23-25,32,36\n+   :dedent: 2\n+\n+StreamWriter\n+------------\n+\n+The :class:`StreamWriter` allows for Parquet files to be written using\n+standard C++ output operators.  This type-safe approach also ensures\n+that rows are written without omitting fields and allows for new row\n+groups to be created automatically (after certain volume of data) or\n+explicitly by using the :type:`EndRowGroup` stream modifier.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to write a field using an incorrect type.\n+\n+* Attempt to write too many fields in a row.\n+\n+* Attempt to skip a required field.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_writer.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::FileOutputStream> outfile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         outfile,\n+         arrow::io::FileOutputStream::Open(\"test.parquet\"));\n+\n+      parquet::WriterProperties::Builder builder;\n+      std::shared_ptr<parquet::schema::GroupNode> schema;\n+\n+      // Set up builder with required compression type etc.\n+      // Define schema.\n+      // ...\n+\n+      parquet::StreamWriter os{\n+         parquet::ParquetFileWriter::Open(outfile, schema, builder.build())};\n+\n+      // Loop over some data structure which provides the required\n+      // fields to be written and write each row.\n+      for (const auto& a : getArticles())\n+      {\n+         os << a.name() << a.price() << a.quantity() << parquet::EndRow;\n+      }\n+   }\n+\n+.. _parquet-writer-properties:\n+\n+Writer properties\n+-----------------\n+\n+To configure how Parquet files are written, use the :class:`WriterProperties::Builder`:\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+   #include \"arrow/util/type_fwd.h\"\n+\n+   using parquet::WriterProperties;\n+   using parquet::ParquetVersion;\n+   using parquet::ParquetDataPageVersion;\n+   using arrow::Compression;\n+\n+   std::shared_ptr<WriterProperties> props = WriterProperties::Builder()\n+      .max_row_group_length(64 * 1024)\n+      .created_by(\"My Application\")\n+      .version(ParquetVersion::PARQUET_2_6)\n+      .data_page_version(ParquetDataPageVersion::V2)\n+      .compression(Compression::SNAPPY)\n+      .build();\n+\n+The ``max_row_group_length`` sets an upper bound that takes precedent over the\n+``chunk_size`` passed in the write methods.\n+\n+You can set the version of Parquet to write with ``version``, which determines\n+which logical types are available. In addition, you can set the data page version\n+with ``data_page_version``. It's V1 by default; setting to V2 will allow more\n+optimal compression (skipping compressing pages where there isn't a space \n+benefit), but not all readers support this data page version.\n\nReview Comment:\n   Right, that should certainly happen at the level of the Parquet project, not Arrow.\n\n\n\n",
                    "created": "2022-10-18T19:37:27.641+0000",
                    "updated": "2022-10-18T19:37:27.641+0000",
                    "started": "2022-10-18T19:37:27.641+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "818123",
                    "issueId": "13403973"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13403973/worklog/818127",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wjones127 commented on code in PR #14018:\nURL: https://github.com/apache/arrow/pull/14018#discussion_r998641828\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,302 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data into Arrow Tables and Record\n+Batches.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n+offered for ease of use and type-safety.  It is of course also useful\n+when data must be streamed as files are read and written\n+incrementally.\n+\n+Please note that the performance of the :class:`StreamReader` and\n+:class:`StreamWriter` classes will not be as good due to the type\n+checking and the fact that column values are processed one at a time.\n+\n+FileReader\n+----------\n+\n+To read Parquet data into Arrow structures, use :class:`arrow::FileReader`.\n+To construct, it requires a :class:`::arrow::io::RandomAccessFile` instance \n+representing the input file. To read the whole file at once, \n+use :func:`arrow::FileReader::ReadTable`:\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 9-10,14\n+   :dedent: 2\n+\n+Finer-grained options are available through the\n+:class:`arrow::FileReaderBuilder` helper class, which accepts the :class:`ReaderProperties`\n+and :class:`ArrowReaderProperties` classes.\n+\n+For reading as a stream of batches, use the :func:`arrow::FileReader::GetRecordBatchReader`\n+method to retrieve a :class:`arrow::RecordBatchReader`. It will use the batch \n+size set in :class:`ArrowReaderProperties`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 25\n+   :dedent: 2\n+\n+.. seealso::\n+\n+   For reading multi-file datasets or pushing down filters to prune row groups,\n+   see :ref:`Tabular Datasets<cpp-dataset>`.\n+\n+Performance and Memory Efficiency\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+For remote filesystems, use read coalescing (pre-buffering) to reduce number of API calls:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties();\n+   reader_properties.set_prebuffer(true);\n+\n+The defaults are generally tuned towards good performance, but parallel column\n+decoding is off by default. Enable it in the constructor of :class:`ArrowReaderProperties`:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties(/*use_threads=*/true);\n+\n+If memory efficiency is more important than performance, then:\n+\n+#. Do *not* turn on read coalescing (pre-buffering) in :class:`parquet::ArrowReaderProperties`.\n+#. Read data in batches using :func:`arrow::FileReader::GetRecordBatchReader`.\n+#. Turn on ``enable_buffered_stream`` in :class:`parquet::ReaderProperties`.\n+\n+In addition, if you know certain columns contain many repeated values, you can\n+read them as :term:`dictionary encoded<dictionary-encoding>` columns. This is \n+enabled with the ``set_read_dictionary`` setting on :class:`ArrowReaderProperties`. \n+If the files were written with Arrow C++ and the ``store_schema`` was activated,\n+then the original Arrow schema will be automatically read and will override this\n+setting.\n+\n+StreamReader\n+------------\n+\n+The :class:`StreamReader` allows for Parquet files to be read using\n+standard C++ input operators which ensures type-safety.\n+\n+Please note that types must match the schema exactly i.e. if the\n+schema field is an unsigned 16-bit integer then you must supply a\n+uint16_t type.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to read field by supplying the incorrect type.\n+\n+* Attempt to read beyond end of row.\n+\n+* Attempt to read beyond end of file.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_reader.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::ReadableFile> infile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         infile,\n+         arrow::io::ReadableFile::Open(\"test.parquet\"));\n+\n+      parquet::StreamReader os{parquet::ParquetFileReader::Open(infile)};\n+\n+      std::string article;\n+      float price;\n+      uint32_t quantity;\n+\n+      while ( !os.eof() )\n+      {\n+         os >> article >> price >> quantity >> parquet::EndRow;\n+         // ...\n+      }\n+   }\n+\n+Writing Parquet files\n+=====================\n+\n+WriteTable\n+----------\n+\n+The :func:`arrow::WriteTable` function writes an entire\n+:class:`::arrow::Table` to an output file.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 19-21\n+   :dedent: 2\n+\n+.. warning::\n+\n+   Column compression is off by default in C++. See :ref:`below <parquet-writer-properties>` \n+   for how to choose a compression codec in the writer properties.\n+\n+To write out data batch-by-batch, use :class:`arrow::FileWriter`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 23-25,32,36\n+   :dedent: 2\n+\n+StreamWriter\n+------------\n+\n+The :class:`StreamWriter` allows for Parquet files to be written using\n+standard C++ output operators.  This type-safe approach also ensures\n+that rows are written without omitting fields and allows for new row\n+groups to be created automatically (after certain volume of data) or\n+explicitly by using the :type:`EndRowGroup` stream modifier.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to write a field using an incorrect type.\n+\n+* Attempt to write too many fields in a row.\n+\n+* Attempt to skip a required field.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_writer.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::FileOutputStream> outfile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         outfile,\n+         arrow::io::FileOutputStream::Open(\"test.parquet\"));\n+\n+      parquet::WriterProperties::Builder builder;\n+      std::shared_ptr<parquet::schema::GroupNode> schema;\n+\n+      // Set up builder with required compression type etc.\n+      // Define schema.\n+      // ...\n+\n+      parquet::StreamWriter os{\n+         parquet::ParquetFileWriter::Open(outfile, schema, builder.build())};\n+\n+      // Loop over some data structure which provides the required\n+      // fields to be written and write each row.\n+      for (const auto& a : getArticles())\n+      {\n+         os << a.name() << a.price() << a.quantity() << parquet::EndRow;\n+      }\n+   }\n+\n+.. _parquet-writer-properties:\n+\n+Writer properties\n+-----------------\n+\n+To configure how Parquet files are written, use the :class:`WriterProperties::Builder`:\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+   #include \"arrow/util/type_fwd.h\"\n+\n+   using parquet::WriterProperties;\n+   using parquet::ParquetVersion;\n+   using parquet::ParquetDataPageVersion;\n+   using arrow::Compression;\n+\n+   std::shared_ptr<WriterProperties> props = WriterProperties::Builder()\n+      .max_row_group_length(64 * 1024)\n+      .created_by(\"My Application\")\n+      .version(ParquetVersion::PARQUET_2_6)\n+      .data_page_version(ParquetDataPageVersion::V2)\n+      .compression(Compression::SNAPPY)\n+      .build();\n+\n+The ``max_row_group_length`` sets an upper bound that takes precedent over the\n+``chunk_size`` passed in the write methods.\n+\n+You can set the version of Parquet to write with ``version``, which determines\n+which logical types are available. In addition, you can set the data page version\n+with ``data_page_version``. It's V1 by default; setting to V2 will allow more\n+optimal compression (skipping compressing pages where there isn't a space \n+benefit), but not all readers support this data page version.\n+\n+Compression is off by default, but to get the most out of Parquet, you should \n+also choose a compression codec. You can choose one for the whole file or \n+choose one for individual columns. If you choose a mix, the file-level option\n+will apply to columns that don't have a specific compression codec. See \n+:class:`::arrow::Compression` for options.\n+\n+Column data encodings can likewise be applied at the file-level or at the \n+column level. By default, the writer will attempt to dictionary encode all \n+supported columns, unless the dictionary grows too large. This behavior can\n+be changed at file-level or at the column level with ``disable_dictionary()``.\n+When not using dictionary encoding, it will fallback to the encoding set for \n+the column or the overall file; by default ``Encoding::PLAIN``, but this can\n+be changed with ``encoding()``.\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+   #include \"arrow/util/type_fwd.h\"\n+\n+   using parquet::WriterProperties;\n+   using arrow::Compression;\n+   using parquet::Encoding;\n+\n+   std::shared_ptr<WriterProperties> props = WriterProperties::Builder()\n+     .compression(Compression::SNAPPY)        // Fallback\n+     ->compression(\"colA\", Compression::ZSTD) // Only applies to colA\n+     ->encoding(Encoding::BIT_PACKED)         // Fallback\n+     ->encoding(\"colB\", Encoding::RLE)        // Only applies to colB\n+     ->disable_dictionary(\"colB\")             // Always use RLE, never dictionary\n+     ->disable_statistics(\"colB\")             // Stats won't be written for colB\n\nReview Comment:\n   Perhaps not, except in edge cases. I'll remove the example but leave the mention in the prose, since I think it is worth knowing that they are enabled for all columns by default and that there is a size limit on them.\n\n\n\n",
                    "created": "2022-10-18T19:46:43.670+0000",
                    "updated": "2022-10-18T19:46:43.670+0000",
                    "started": "2022-10-18T19:46:43.669+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "818127",
                    "issueId": "13403973"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13403973/worklog/818171",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wjones127 commented on code in PR #14018:\nURL: https://github.com/apache/arrow/pull/14018#discussion_r998734879\n\n\n##########\ndocs/source/cpp/parquet.rst:\n##########\n@@ -32,6 +32,302 @@ is a space-efficient columnar storage format for complex data.  The Parquet\n C++ implementation is part of the Apache Arrow project and benefits\n from tight integration with the Arrow C++ classes and facilities.\n \n+Reading Parquet files\n+=====================\n+\n+The :class:`arrow::FileReader` class reads data into Arrow Tables and Record\n+Batches.\n+\n+The :class:`StreamReader` and :class:`StreamWriter` classes allow for\n+data to be written using a C++ input/output streams approach to\n+read/write fields column by column and row by row.  This approach is\n+offered for ease of use and type-safety.  It is of course also useful\n+when data must be streamed as files are read and written\n+incrementally.\n+\n+Please note that the performance of the :class:`StreamReader` and\n+:class:`StreamWriter` classes will not be as good due to the type\n+checking and the fact that column values are processed one at a time.\n+\n+FileReader\n+----------\n+\n+To read Parquet data into Arrow structures, use :class:`arrow::FileReader`.\n+To construct, it requires a :class:`::arrow::io::RandomAccessFile` instance \n+representing the input file. To read the whole file at once, \n+use :func:`arrow::FileReader::ReadTable`:\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 9-10,14\n+   :dedent: 2\n+\n+Finer-grained options are available through the\n+:class:`arrow::FileReaderBuilder` helper class, which accepts the :class:`ReaderProperties`\n+and :class:`ArrowReaderProperties` classes.\n+\n+For reading as a stream of batches, use the :func:`arrow::FileReader::GetRecordBatchReader`\n+method to retrieve a :class:`arrow::RecordBatchReader`. It will use the batch \n+size set in :class:`ArrowReaderProperties`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status ReadInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 25\n+   :dedent: 2\n+\n+.. seealso::\n+\n+   For reading multi-file datasets or pushing down filters to prune row groups,\n+   see :ref:`Tabular Datasets<cpp-dataset>`.\n+\n+Performance and Memory Efficiency\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+For remote filesystems, use read coalescing (pre-buffering) to reduce number of API calls:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties();\n+   reader_properties.set_prebuffer(true);\n+\n+The defaults are generally tuned towards good performance, but parallel column\n+decoding is off by default. Enable it in the constructor of :class:`ArrowReaderProperties`:\n+\n+.. code-block:: cpp\n+\n+   auto arrow_reader_props = parquet::ArrowReaderProperties(/*use_threads=*/true);\n+\n+If memory efficiency is more important than performance, then:\n+\n+#. Do *not* turn on read coalescing (pre-buffering) in :class:`parquet::ArrowReaderProperties`.\n+#. Read data in batches using :func:`arrow::FileReader::GetRecordBatchReader`.\n+#. Turn on ``enable_buffered_stream`` in :class:`parquet::ReaderProperties`.\n+\n+In addition, if you know certain columns contain many repeated values, you can\n+read them as :term:`dictionary encoded<dictionary-encoding>` columns. This is \n+enabled with the ``set_read_dictionary`` setting on :class:`ArrowReaderProperties`. \n+If the files were written with Arrow C++ and the ``store_schema`` was activated,\n+then the original Arrow schema will be automatically read and will override this\n+setting.\n+\n+StreamReader\n+------------\n+\n+The :class:`StreamReader` allows for Parquet files to be read using\n+standard C++ input operators which ensures type-safety.\n+\n+Please note that types must match the schema exactly i.e. if the\n+schema field is an unsigned 16-bit integer then you must supply a\n+uint16_t type.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to read field by supplying the incorrect type.\n+\n+* Attempt to read beyond end of row.\n+\n+* Attempt to read beyond end of file.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_reader.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::ReadableFile> infile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         infile,\n+         arrow::io::ReadableFile::Open(\"test.parquet\"));\n+\n+      parquet::StreamReader os{parquet::ParquetFileReader::Open(infile)};\n+\n+      std::string article;\n+      float price;\n+      uint32_t quantity;\n+\n+      while ( !os.eof() )\n+      {\n+         os >> article >> price >> quantity >> parquet::EndRow;\n+         // ...\n+      }\n+   }\n+\n+Writing Parquet files\n+=====================\n+\n+WriteTable\n+----------\n+\n+The :func:`arrow::WriteTable` function writes an entire\n+:class:`::arrow::Table` to an output file.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteFullFile(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 19-21\n+   :dedent: 2\n+\n+.. warning::\n+\n+   Column compression is off by default in C++. See :ref:`below <parquet-writer-properties>` \n+   for how to choose a compression codec in the writer properties.\n+\n+To write out data batch-by-batch, use :class:`arrow::FileWriter`.\n+\n+.. literalinclude:: ../../../cpp/examples/arrow/parquet_read_write.cc\n+   :language: cpp\n+   :start-after: arrow::Status WriteInBatches(\n+   :end-before: return arrow::Status::OK();\n+   :emphasize-lines: 23-25,32,36\n+   :dedent: 2\n+\n+StreamWriter\n+------------\n+\n+The :class:`StreamWriter` allows for Parquet files to be written using\n+standard C++ output operators.  This type-safe approach also ensures\n+that rows are written without omitting fields and allows for new row\n+groups to be created automatically (after certain volume of data) or\n+explicitly by using the :type:`EndRowGroup` stream modifier.\n+\n+Exceptions are used to signal errors.  A :class:`ParquetException` is\n+thrown in the following circumstances:\n+\n+* Attempt to write a field using an incorrect type.\n+\n+* Attempt to write too many fields in a row.\n+\n+* Attempt to skip a required field.\n+\n+.. code-block:: cpp\n+\n+   #include \"arrow/io/file.h\"\n+   #include \"parquet/stream_writer.h\"\n+\n+   {\n+      std::shared_ptr<arrow::io::FileOutputStream> outfile;\n+\n+      PARQUET_ASSIGN_OR_THROW(\n+         outfile,\n+         arrow::io::FileOutputStream::Open(\"test.parquet\"));\n+\n+      parquet::WriterProperties::Builder builder;\n+      std::shared_ptr<parquet::schema::GroupNode> schema;\n+\n+      // Set up builder with required compression type etc.\n+      // Define schema.\n+      // ...\n+\n+      parquet::StreamWriter os{\n+         parquet::ParquetFileWriter::Open(outfile, schema, builder.build())};\n+\n+      // Loop over some data structure which provides the required\n+      // fields to be written and write each row.\n+      for (const auto& a : getArticles())\n+      {\n+         os << a.name() << a.price() << a.quantity() << parquet::EndRow;\n+      }\n+   }\n+\n+.. _parquet-writer-properties:\n+\n+Writer properties\n+-----------------\n+\n+To configure how Parquet files are written, use the :class:`WriterProperties::Builder`:\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+   #include \"arrow/util/type_fwd.h\"\n+\n+   using parquet::WriterProperties;\n+   using parquet::ParquetVersion;\n+   using parquet::ParquetDataPageVersion;\n+   using arrow::Compression;\n+\n+   std::shared_ptr<WriterProperties> props = WriterProperties::Builder()\n+      .max_row_group_length(64 * 1024)\n+      .created_by(\"My Application\")\n+      .version(ParquetVersion::PARQUET_2_6)\n+      .data_page_version(ParquetDataPageVersion::V2)\n+      .compression(Compression::SNAPPY)\n+      .build();\n+\n+The ``max_row_group_length`` sets an upper bound that takes precedent over the\n+``chunk_size`` passed in the write methods.\n+\n+You can set the version of Parquet to write with ``version``, which determines\n+which logical types are available. In addition, you can set the data page version\n+with ``data_page_version``. It's V1 by default; setting to V2 will allow more\n+optimal compression (skipping compressing pages where there isn't a space \n+benefit), but not all readers support this data page version.\n+\n+Compression is off by default, but to get the most out of Parquet, you should \n+also choose a compression codec. You can choose one for the whole file or \n+choose one for individual columns. If you choose a mix, the file-level option\n+will apply to columns that don't have a specific compression codec. See \n+:class:`::arrow::Compression` for options.\n+\n+Column data encodings can likewise be applied at the file-level or at the \n+column level. By default, the writer will attempt to dictionary encode all \n+supported columns, unless the dictionary grows too large. This behavior can\n+be changed at file-level or at the column level with ``disable_dictionary()``.\n+When not using dictionary encoding, it will fallback to the encoding set for \n+the column or the overall file; by default ``Encoding::PLAIN``, but this can\n+be changed with ``encoding()``.\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+   #include \"arrow/util/type_fwd.h\"\n+\n+   using parquet::WriterProperties;\n+   using arrow::Compression;\n+   using parquet::Encoding;\n+\n+   std::shared_ptr<WriterProperties> props = WriterProperties::Builder()\n+     .compression(Compression::SNAPPY)        // Fallback\n+     ->compression(\"colA\", Compression::ZSTD) // Only applies to colA\n+     ->encoding(Encoding::BIT_PACKED)         // Fallback\n+     ->encoding(\"colB\", Encoding::RLE)        // Only applies to colB\n+     ->disable_dictionary(\"colB\")             // Always use RLE, never dictionary\n+     ->disable_statistics(\"colB\")             // Stats won't be written for colB\n+     ->build();\n+\n+Statistics are enabled by default for all columns. You can disable statistics for\n+all columns or specific columns using ``disable_statistics`` on the builder.\n+There is a ``max_statistics_size`` which limits the maximum number of bytes that\n+may be used for min and max values, useful for types like strings or binary blobs.\n+\n+There are also Arrow-specific settings that can be configured with\n+:class:`parquet::ArrowWriterProperties`:\n+\n+.. code-block:: cpp\n+\n+   #include \"parquet/arrow/writer.h\"\n+\n+   using parquet::ArrowWriterProperties;\n+\n+   std::shared_ptr<ArrowWriterProperties> arrow_props = ArrowWriterProperties::Builder()\n+      .enable_deprecated_int96_timestamps() // default False\n+      ->store_schema() // default False\n+      ->enable_compliant_nested_types() // default False\n+      ->build();\n+\n+These options mostly dictate how Arrow types are converted to Parquet types.\n+Turning on ``store_schema`` will cause the writer to place the serialized Arrow\n+schema within the file metadata. This allows the Arrow reader to automatically\n+determine which columns should be read back as dictionary-encoded columns,\n+potentially saving memory.\n\nReview Comment:\n   Thanks! That's a really good point. I'll add that change and provide a few helpful examples of what this mapping does.\n\n\n\n",
                    "created": "2022-10-18T21:38:03.425+0000",
                    "updated": "2022-10-18T21:38:03.425+0000",
                    "started": "2022-10-18T21:38:03.425+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "818171",
                    "issueId": "13403973"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 16800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@66fbe9c1[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@27c52908[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@215e902f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@2fdd7065[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@205bd13c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@2e3f504d[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7b35724d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@3faf7b16[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@41838fee[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@156a02ab[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@451dbd51[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@1ae192f[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 16800,
        "customfield_12312520": null,
        "customfield_12312521": "2021-09-29 01:51:36.0",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": null,
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-14161/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2021-09-29T01:51:36.000+0000",
        "updated": "2022-11-08T23:02:44.000+0000",
        "timeoriginalestimate": null,
        "description": "Missing documentation on Reading/Writing Parquet files C++ api:\r\n * [WriteTable|https://arrow.apache.org/docs/cpp/api/formats.html#_CPPv4N7parquet5arrow10WriteTableERKN5arrow5TableEP10MemoryPoolNSt10shared_ptrIN5arrow2io12OutputStreamEEE7int64_tNSt10shared_ptrI16WriterPropertiesEENSt10shared_ptrI21ArrowWriterPropertiesEE] missing docs on chunk_size found some [here|https://github.com/apache/parquet-cpp/blob/642da055adf009652689b20e68a198cffb857651/examples/parquet-arrow/src/reader-writer.cc#L53] _size of the RowGroup in the parquet file. Normally you would choose this to be rather large_\r\n * Typo in file reader [example|https://arrow.apache.org/docs/cpp/parquet.html#filereader] the include should be {{#include \"parquet/arrow/reader.h\"}}\r\n * [WriteProperties/Builder|https://arrow.apache.org/docs/cpp/api/formats.html#_CPPv4N7parquet16WriterPropertiesE] missing docs on {{compression}}\r\n * Missing example on using WriteProperties",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "4h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 16800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Parquet][Docs] Reading/Writing Parquet Files",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [],
            "maxResults": 0,
            "total": 0,
            "startAt": 0
        },
        "customfield_12311820": "0|z0vei0:",
        "customfield_12314139": null
    }
}