{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13340004",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340004",
    "key": "ARROW-10559",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=alamb",
            "name": "alamb",
            "key": "alamb",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=alamb&avatarId=43364",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=alamb&avatarId=43364",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=alamb&avatarId=43364",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=alamb&avatarId=43364"
            },
            "displayName": "Andrew Lamb",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12335005",
                "id": "12335005",
                "name": "Rust - DataFusion"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=alamb",
            "name": "alamb",
            "key": "alamb",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=alamb&avatarId=43364",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=alamb&avatarId=43364",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=alamb&avatarId=43364",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=alamb&avatarId=43364"
            },
            "displayName": "Andrew Lamb",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=alamb",
            "name": "alamb",
            "key": "alamb",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=alamb&avatarId=43364",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=alamb&avatarId=43364",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=alamb&avatarId=43364",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=alamb&avatarId=43364"
            },
            "displayName": "Andrew Lamb",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 6000,
            "total": 6000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 6000,
            "total": 6000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10559/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 10,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340004/worklog/510307",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb opened a new pull request #8639:\nURL: https://github.com/apache/arrow/pull/8639\n\n\n   The module has gotten fairly large and so refactoring it into smaller chunks will improve readability \u2013 as suggested by Jorge https://github.com/apache/arrow/pull/8619#pullrequestreview-527391221\r\n   \r\n   This PR just moves code around -- it is not intended to change any semantics\r\n   \r\n   Reviewing it commit-by-commit might be helpful to see how each piece went\r\n   \r\n   I can also break it up into a sequence of smaller PRs if that would help review\r\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T16:08:42.227+0000",
                    "updated": "2020-11-11T16:08:42.227+0000",
                    "started": "2020-11-11T16:08:42.227+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510307",
                    "issueId": "13340004"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340004/worklog/510308",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on a change in pull request #8639:\nURL: https://github.com/apache/arrow/pull/8639#discussion_r521467373\n\n\n\n##########\nFile path: rust/datafusion/src/logical_plan/mod.rs\n##########\n@@ -21,2300 +21,21 @@\n //! Logical query plans can then be optimized and executed directly, or translated into\n //! physical query plans and executed.\n \n-use std::fmt::{self, Debug, Display};\n-use std::{any::Any, collections::HashMap, collections::HashSet, sync::Arc};\n-\n-use aggregates::{AccumulatorFunctionImplementation, StateTypeFunction};\n-use arrow::{\n-    compute::can_cast_types,\n-    datatypes::{DataType, Field, Schema, SchemaRef},\n-};\n-\n-use crate::datasource::parquet::ParquetTable;\n-use crate::datasource::TableProvider;\n-use crate::error::{DataFusionError, Result};\n-use crate::{\n-    datasource::csv::{CsvFile, CsvReadOptions},\n-    physical_plan::udaf::AggregateUDF,\n-    scalar::ScalarValue,\n-};\n-use crate::{\n-    physical_plan::{\n-        aggregates, expressions::binary_operator_data_type, functions, udf::ScalarUDF,\n-    },\n-    sql::parser::FileType,\n-};\n-use arrow::record_batch::RecordBatch;\n-use functions::{ReturnTypeFunction, ScalarFunctionImplementation, Signature};\n-\n+mod builder;\n\nReview comment:\n       This module now  `pub use` s all `struct`, `enum` and `traits` that were public in this module so no client code should need to change.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T16:10:59.423+0000",
                    "updated": "2020-11-11T16:10:59.423+0000",
                    "started": "2020-11-11T16:10:59.422+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510308",
                    "issueId": "13340004"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340004/worklog/510315",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8639:\nURL: https://github.com/apache/arrow/pull/8639#discussion_r521475124\n\n\n\n##########\nFile path: rust/datafusion/src/logical_plan/mod.rs\n##########\n@@ -1264,31 +1050,6 @@ mod tests {\n         Ok(())\n     }\n \n-    #[test]\n-    fn test_visitor() {\n-        let schema = Schema::new(vec![]);\n-        assert_eq!(\"[]\", format!(\"{}\", display_schema(&schema)));\n-    }\n-\n-    #[test]\n-    fn test_display_empty_schema() {\n-        let schema = Schema::new(vec![]);\n-        assert_eq!(\"[]\", format!(\"{}\", display_schema(&schema)));\n-    }\n-\n-    #[test]\n-    fn test_display_schema() {\n-        let schema = Schema::new(vec![\n-            Field::new(\"id\", DataType::Int32, false),\n-            Field::new(\"first_name\", DataType::Utf8, true),\n-        ]);\n-\n-        assert_eq!(\n-            \"[id:Int32, first_name:Utf8;N]\",\n-            format!(\"{}\", display_schema(&schema))\n-        );\n-    }\n\nReview comment:\n       Maybe one of the tests disapeared in this commit? (I count -3 +2)\n\n##########\nFile path: rust/datafusion/src/logical_plan/mod.rs\n##########\n@@ -21,2300 +21,21 @@\n //! Logical query plans can then be optimized and executed directly, or translated into\n //! physical query plans and executed.\n \n-use std::fmt::{self, Debug, Display};\n-use std::{any::Any, collections::HashMap, collections::HashSet, sync::Arc};\n-\n-use aggregates::{AccumulatorFunctionImplementation, StateTypeFunction};\n-use arrow::{\n-    compute::can_cast_types,\n-    datatypes::{DataType, Field, Schema, SchemaRef},\n-};\n-\n-use crate::datasource::parquet::ParquetTable;\n-use crate::datasource::TableProvider;\n-use crate::error::{DataFusionError, Result};\n-use crate::{\n-    datasource::csv::{CsvFile, CsvReadOptions},\n-    physical_plan::udaf::AggregateUDF,\n-    scalar::ScalarValue,\n-};\n-use crate::{\n-    physical_plan::{\n-        aggregates, expressions::binary_operator_data_type, functions, udf::ScalarUDF,\n-    },\n-    sql::parser::FileType,\n-};\n-use arrow::record_batch::RecordBatch;\n-use functions::{ReturnTypeFunction, ScalarFunctionImplementation, Signature};\n-\n+mod builder;\n+mod display;\n+mod expr;\n+mod extension;\n mod operators;\n+mod plan;\n+mod registry;\n+\n+pub use builder::LogicalPlanBuilder;\n+pub use display::display_schema;\n+pub use expr::{\n+    and, array, avg, binary_expr, col, concat, count, create_udaf, create_udf,\n+    exprlist_to_fields, length, lit, max, min, sum, Expr, Literal,\n+};\n+pub use extension::UserDefinedLogicalNode;\n pub use operators::Operator;\n-\n-fn create_function_name(\n-    fun: &String,\n-    distinct: bool,\n-    args: &[Expr],\n-    input_schema: &Schema,\n-) -> Result<String> {\n-    let names: Vec<String> = args\n-        .iter()\n-        .map(|e| create_name(e, input_schema))\n-        .collect::<Result<_>>()?;\n-    let distinct_str = match distinct {\n-        true => \"DISTINCT \",\n-        false => \"\",\n-    };\n-    Ok(format!(\"{}({}{})\", fun, distinct_str, names.join(\",\")))\n-}\n-\n-/// Returns a readable name of an expression based on the input schema.\n-/// This function recursively transverses the expression for names such as \"CAST(a > 2)\".\n-fn create_name(e: &Expr, input_schema: &Schema) -> Result<String> {\n-    match e {\n-        Expr::Alias(_, name) => Ok(name.clone()),\n-        Expr::Column(name) => Ok(name.clone()),\n-        Expr::ScalarVariable(variable_names) => Ok(variable_names.join(\".\")),\n-        Expr::Literal(value) => Ok(format!(\"{:?}\", value)),\n-        Expr::BinaryExpr { left, op, right } => {\n-            let left = create_name(left, input_schema)?;\n-            let right = create_name(right, input_schema)?;\n-            Ok(format!(\"{} {:?} {}\", left, op, right))\n-        }\n-        Expr::Cast { expr, data_type } => {\n-            let expr = create_name(expr, input_schema)?;\n-            Ok(format!(\"CAST({} AS {:?})\", expr, data_type))\n-        }\n-        Expr::Not(expr) => {\n-            let expr = create_name(expr, input_schema)?;\n-            Ok(format!(\"NOT {}\", expr))\n-        }\n-        Expr::IsNull(expr) => {\n-            let expr = create_name(expr, input_schema)?;\n-            Ok(format!(\"{} IS NULL\", expr))\n-        }\n-        Expr::IsNotNull(expr) => {\n-            let expr = create_name(expr, input_schema)?;\n-            Ok(format!(\"{} IS NOT NULL\", expr))\n-        }\n-        Expr::ScalarFunction { fun, args, .. } => {\n-            create_function_name(&fun.to_string(), false, args, input_schema)\n-        }\n-        Expr::ScalarUDF { fun, args, .. } => {\n-            create_function_name(&fun.name, false, args, input_schema)\n-        }\n-        Expr::AggregateFunction {\n-            fun,\n-            distinct,\n-            args,\n-            ..\n-        } => create_function_name(&fun.to_string(), *distinct, args, input_schema),\n-        Expr::AggregateUDF { fun, args } => {\n-            let mut names = Vec::with_capacity(args.len());\n-            for e in args {\n-                names.push(create_name(e, input_schema)?);\n-            }\n-            Ok(format!(\"{}({})\", fun.name, names.join(\",\")))\n-        }\n-        other => Err(DataFusionError::NotImplemented(format!(\n-            \"Physical plan does not support logical expression {:?}\",\n-            other\n-        ))),\n-    }\n-}\n-\n-/// Create field meta-data from an expression, for use in a result set schema\n-pub fn exprlist_to_fields(expr: &[Expr], input_schema: &Schema) -> Result<Vec<Field>> {\n-    expr.iter().map(|e| e.to_field(input_schema)).collect()\n-}\n-\n-/// `Expr` is a logical expression. A logical expression is something like `1 + 1`, or `CAST(c1 AS int)`.\n-/// Logical expressions know how to compute its [arrow::datatypes::DataType] and nullability.\n-/// `Expr` is a central struct of DataFusion's query API.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # use datafusion::logical_plan::Expr;\n-/// # use datafusion::error::Result;\n-/// # fn main() -> Result<()> {\n-/// let expr = Expr::Column(\"c1\".to_string()) + Expr::Column(\"c2\".to_string());\n-/// println!(\"{:?}\", expr);\n-/// # Ok(())\n-/// # }\n-/// ```\n-#[derive(Clone)]\n-pub enum Expr {\n-    /// An expression with a specific name.\n-    Alias(Box<Expr>, String),\n-    /// A named reference to a field in a schema.\n-    Column(String),\n-    /// A named reference to a variable in a registry.\n-    ScalarVariable(Vec<String>),\n-    /// A constant value.\n-    Literal(ScalarValue),\n-    /// A binary expression such as \"age > 21\"\n-    BinaryExpr {\n-        /// Left-hand side of the expression\n-        left: Box<Expr>,\n-        /// The comparison operator\n-        op: Operator,\n-        /// Right-hand side of the expression\n-        right: Box<Expr>,\n-    },\n-    /// Parenthesized expression. E.g. `(foo > bar)` or `(1)`\n-    Nested(Box<Expr>),\n-    /// Negation of an expression. The expression's type must be a boolean to make sense.\n-    Not(Box<Expr>),\n-    /// Whether an expression is not Null. This expression is never null.\n-    IsNotNull(Box<Expr>),\n-    /// Whether an expression is Null. This expression is never null.\n-    IsNull(Box<Expr>),\n-    /// Casts the expression to a given type. This expression is guaranteed to have a fixed type.\n-    Cast {\n-        /// The expression being cast\n-        expr: Box<Expr>,\n-        /// The `DataType` the expression will yield\n-        data_type: DataType,\n-    },\n-    /// A sort expression, that can be used to sort values.\n-    Sort {\n-        /// The expression to sort on\n-        expr: Box<Expr>,\n-        /// The direction of the sort\n-        asc: bool,\n-        /// Whether to put Nulls before all other data values\n-        nulls_first: bool,\n-    },\n-    /// Represents the call of a built-in scalar function with a set of arguments.\n-    ScalarFunction {\n-        /// The function\n-        fun: functions::BuiltinScalarFunction,\n-        /// List of expressions to feed to the functions as arguments\n-        args: Vec<Expr>,\n-    },\n-    /// Represents the call of a user-defined scalar function with arguments.\n-    ScalarUDF {\n-        /// The function\n-        fun: Arc<ScalarUDF>,\n-        /// List of expressions to feed to the functions as arguments\n-        args: Vec<Expr>,\n-    },\n-    /// Represents the call of an aggregate built-in function with arguments.\n-    AggregateFunction {\n-        /// Name of the function\n-        fun: aggregates::AggregateFunction,\n-        /// List of expressions to feed to the functions as arguments\n-        args: Vec<Expr>,\n-        /// Whether this is a DISTINCT aggregation or not\n-        distinct: bool,\n-    },\n-    /// aggregate function\n-    AggregateUDF {\n-        /// The function\n-        fun: Arc<AggregateUDF>,\n-        /// List of expressions to feed to the functions as arguments\n-        args: Vec<Expr>,\n-    },\n-    /// Represents a reference to all fields in a schema.\n-    Wildcard,\n-}\n-\n-impl Expr {\n-    /// Returns the [arrow::datatypes::DataType] of the expression based on [arrow::datatypes::Schema].\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function errors when it is not possible to compute its [arrow::datatypes::DataType].\n-    /// This happens when e.g. the expression refers to a column that does not exist in the schema, or when\n-    /// the expression is incorrectly typed (e.g. `[utf8] + [bool]`).\n-    pub fn get_type(&self, schema: &Schema) -> Result<DataType> {\n-        match self {\n-            Expr::Alias(expr, _) => expr.get_type(schema),\n-            Expr::Column(name) => Ok(schema.field_with_name(name)?.data_type().clone()),\n-            Expr::ScalarVariable(_) => Ok(DataType::Utf8),\n-            Expr::Literal(l) => Ok(l.get_datatype()),\n-            Expr::Cast { data_type, .. } => Ok(data_type.clone()),\n-            Expr::ScalarUDF { fun, args } => {\n-                let data_types = args\n-                    .iter()\n-                    .map(|e| e.get_type(schema))\n-                    .collect::<Result<Vec<_>>>()?;\n-                Ok((fun.return_type)(&data_types)?.as_ref().clone())\n-            }\n-            Expr::ScalarFunction { fun, args } => {\n-                let data_types = args\n-                    .iter()\n-                    .map(|e| e.get_type(schema))\n-                    .collect::<Result<Vec<_>>>()?;\n-                functions::return_type(fun, &data_types)\n-            }\n-            Expr::AggregateFunction { fun, args, .. } => {\n-                let data_types = args\n-                    .iter()\n-                    .map(|e| e.get_type(schema))\n-                    .collect::<Result<Vec<_>>>()?;\n-                aggregates::return_type(fun, &data_types)\n-            }\n-            Expr::AggregateUDF { fun, args, .. } => {\n-                let data_types = args\n-                    .iter()\n-                    .map(|e| e.get_type(schema))\n-                    .collect::<Result<Vec<_>>>()?;\n-                Ok((fun.return_type)(&data_types)?.as_ref().clone())\n-            }\n-            Expr::Not(_) => Ok(DataType::Boolean),\n-            Expr::IsNull(_) => Ok(DataType::Boolean),\n-            Expr::IsNotNull(_) => Ok(DataType::Boolean),\n-            Expr::BinaryExpr {\n-                ref left,\n-                ref right,\n-                ref op,\n-            } => binary_operator_data_type(\n-                &left.get_type(schema)?,\n-                op,\n-                &right.get_type(schema)?,\n-            ),\n-            Expr::Sort { ref expr, .. } => expr.get_type(schema),\n-            Expr::Wildcard => Err(DataFusionError::Internal(\n-                \"Wildcard expressions are not valid in a logical query plan\".to_owned(),\n-            )),\n-            Expr::Nested(e) => e.get_type(schema),\n-        }\n-    }\n-\n-    /// Returns the nullability of the expression based on [arrow::datatypes::Schema].\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function errors when it is not possible to compute its nullability.\n-    /// This happens when the expression refers to a column that does not exist in the schema.\n-    pub fn nullable(&self, input_schema: &Schema) -> Result<bool> {\n-        match self {\n-            Expr::Alias(expr, _) => expr.nullable(input_schema),\n-            Expr::Column(name) => Ok(input_schema.field_with_name(name)?.is_nullable()),\n-            Expr::Literal(value) => Ok(value.is_null()),\n-            Expr::ScalarVariable(_) => Ok(true),\n-            Expr::Cast { expr, .. } => expr.nullable(input_schema),\n-            Expr::ScalarFunction { .. } => Ok(true),\n-            Expr::ScalarUDF { .. } => Ok(true),\n-            Expr::AggregateFunction { .. } => Ok(true),\n-            Expr::AggregateUDF { .. } => Ok(true),\n-            Expr::Not(expr) => expr.nullable(input_schema),\n-            Expr::IsNull(_) => Ok(false),\n-            Expr::IsNotNull(_) => Ok(false),\n-            Expr::BinaryExpr {\n-                ref left,\n-                ref right,\n-                ..\n-            } => Ok(left.nullable(input_schema)? || right.nullable(input_schema)?),\n-            Expr::Sort { ref expr, .. } => expr.nullable(input_schema),\n-            Expr::Nested(e) => e.nullable(input_schema),\n-            Expr::Wildcard => Err(DataFusionError::Internal(\n-                \"Wildcard expressions are not valid in a logical query plan\".to_owned(),\n-            )),\n-        }\n-    }\n-\n-    /// Returns the name of this expression based on [arrow::datatypes::Schema].\n-    ///\n-    /// This represents how a column with this expression is named when no alias is chosen\n-    pub fn name(&self, input_schema: &Schema) -> Result<String> {\n-        create_name(self, input_schema)\n-    }\n-\n-    /// Returns a [arrow::datatypes::Field] compatible with this expression.\n-    pub fn to_field(&self, input_schema: &Schema) -> Result<Field> {\n-        Ok(Field::new(\n-            &self.name(input_schema)?,\n-            self.get_type(input_schema)?,\n-            self.nullable(input_schema)?,\n-        ))\n-    }\n-\n-    /// Wraps this expression in a cast to a target [arrow::datatypes::DataType].\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function errors when it is impossible to cast the\n-    /// expression to the target [arrow::datatypes::DataType].\n-    pub fn cast_to(&self, cast_to_type: &DataType, schema: &Schema) -> Result<Expr> {\n-        let this_type = self.get_type(schema)?;\n-        if this_type == *cast_to_type {\n-            Ok(self.clone())\n-        } else if can_cast_types(&this_type, cast_to_type) {\n-            Ok(Expr::Cast {\n-                expr: Box::new(self.clone()),\n-                data_type: cast_to_type.clone(),\n-            })\n-        } else {\n-            Err(DataFusionError::Plan(format!(\n-                \"Cannot automatically convert {:?} to {:?}\",\n-                this_type, cast_to_type\n-            )))\n-        }\n-    }\n-\n-    /// Equal\n-    pub fn eq(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Eq, other.clone())\n-    }\n-\n-    /// Not equal\n-    pub fn not_eq(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::NotEq, other.clone())\n-    }\n-\n-    /// Greater than\n-    pub fn gt(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Gt, other.clone())\n-    }\n-\n-    /// Greater than or equal to\n-    pub fn gt_eq(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::GtEq, other.clone())\n-    }\n-\n-    /// Less than\n-    pub fn lt(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Lt, other.clone())\n-    }\n-\n-    /// Less than or equal to\n-    pub fn lt_eq(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::LtEq, other.clone())\n-    }\n-\n-    /// And\n-    pub fn and(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::And, other)\n-    }\n-\n-    /// Or\n-    pub fn or(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Or, other)\n-    }\n-\n-    /// Not\n-    pub fn not(&self) -> Expr {\n-        Expr::Not(Box::new(self.clone()))\n-    }\n-\n-    /// Calculate the modulus of two expressions\n-    pub fn modulus(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Modulus, other.clone())\n-    }\n-\n-    /// like (string) another expression\n-    pub fn like(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Like, other.clone())\n-    }\n-\n-    /// not like another expression\n-    pub fn not_like(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::NotLike, other.clone())\n-    }\n-\n-    /// Alias\n-    pub fn alias(&self, name: &str) -> Expr {\n-        Expr::Alias(Box::new(self.clone()), name.to_owned())\n-    }\n-\n-    /// Create a sort expression from an existing expression.\n-    ///\n-    /// ```\n-    /// # use datafusion::logical_plan::col;\n-    /// let sort_expr = col(\"foo\").sort(true, true); // SORT ASC NULLS_FIRST\n-    /// ```\n-    pub fn sort(&self, asc: bool, nulls_first: bool) -> Expr {\n-        Expr::Sort {\n-            expr: Box::new(self.clone()),\n-            asc,\n-            nulls_first,\n-        }\n-    }\n-}\n-\n-fn binary_expr(l: Expr, op: Operator, r: Expr) -> Expr {\n-    Expr::BinaryExpr {\n-        left: Box::new(l),\n-        op,\n-        right: Box::new(r),\n-    }\n-}\n-\n-/// return a new expression with a logical AND\n-pub fn and(left: &Expr, right: &Expr) -> Expr {\n-    Expr::BinaryExpr {\n-        left: Box::new(left.clone()),\n-        op: Operator::And,\n-        right: Box::new(right.clone()),\n-    }\n-}\n-\n-/// Create a column expression based on a column name\n-pub fn col(name: &str) -> Expr {\n-    Expr::Column(name.to_owned())\n-}\n-\n-/// Create an expression to represent the min() aggregate function\n-pub fn min(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Min,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Create an expression to represent the max() aggregate function\n-pub fn max(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Max,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Create an expression to represent the sum() aggregate function\n-pub fn sum(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Sum,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Create an expression to represent the avg() aggregate function\n-pub fn avg(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Avg,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Create an expression to represent the count() aggregate function\n-pub fn count(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Count,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Whether it can be represented as a literal expression\n-pub trait Literal {\n-    /// convert the value to a Literal expression\n-    fn lit(&self) -> Expr;\n-}\n-\n-impl Literal for &str {\n-    fn lit(&self) -> Expr {\n-        Expr::Literal(ScalarValue::Utf8(Some((*self).to_owned())))\n-    }\n-}\n-\n-impl Literal for String {\n-    fn lit(&self) -> Expr {\n-        Expr::Literal(ScalarValue::Utf8(Some((*self).to_owned())))\n-    }\n-}\n-\n-macro_rules! make_literal {\n-    ($TYPE:ty, $SCALAR:ident) => {\n-        #[allow(missing_docs)]\n-        impl Literal for $TYPE {\n-            fn lit(&self) -> Expr {\n-                Expr::Literal(ScalarValue::$SCALAR(Some(self.clone())))\n-            }\n-        }\n-    };\n-}\n-\n-make_literal!(bool, Boolean);\n-make_literal!(f32, Float32);\n-make_literal!(f64, Float64);\n-make_literal!(i8, Int8);\n-make_literal!(i16, Int16);\n-make_literal!(i32, Int32);\n-make_literal!(i64, Int64);\n-make_literal!(u8, UInt8);\n-make_literal!(u16, UInt16);\n-make_literal!(u32, UInt32);\n-make_literal!(u64, UInt64);\n-\n-/// Create a literal expression\n-pub fn lit<T: Literal>(n: T) -> Expr {\n-    n.lit()\n-}\n-\n-/// Create an convenience function representing a unary scalar function\n-macro_rules! unary_math_expr {\n-    ($ENUM:ident, $FUNC:ident) => {\n-        #[allow(missing_docs)]\n-        pub fn $FUNC(e: Expr) -> Expr {\n-            Expr::ScalarFunction {\n-                fun: functions::BuiltinScalarFunction::$ENUM,\n-                args: vec![e],\n-            }\n-        }\n-    };\n-}\n-\n-// generate methods for creating the supported unary math expressions\n-unary_math_expr!(Sqrt, sqrt);\n-unary_math_expr!(Sin, sin);\n-unary_math_expr!(Cos, cos);\n-unary_math_expr!(Tan, tan);\n-unary_math_expr!(Asin, asin);\n-unary_math_expr!(Acos, acos);\n-unary_math_expr!(Atan, atan);\n-unary_math_expr!(Floor, floor);\n-unary_math_expr!(Ceil, ceil);\n-unary_math_expr!(Round, round);\n-unary_math_expr!(Trunc, trunc);\n-unary_math_expr!(Abs, abs);\n-unary_math_expr!(Signum, signum);\n-unary_math_expr!(Exp, exp);\n-unary_math_expr!(Log, ln);\n-unary_math_expr!(Log2, log2);\n\nReview comment:\n       Should these be removed? I though that they were needed to plan these expressions.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T16:30:21.210+0000",
                    "updated": "2020-11-11T16:30:21.210+0000",
                    "started": "2020-11-11T16:30:21.210+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510315",
                    "issueId": "13340004"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340004/worklog/510316",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8639:\nURL: https://github.com/apache/arrow/pull/8639#issuecomment-725524192\n\n\n   https://issues.apache.org/jira/browse/ARROW-10559\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T16:32:03.620+0000",
                    "updated": "2020-11-11T16:32:03.620+0000",
                    "started": "2020-11-11T16:32:03.620+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510316",
                    "issueId": "13340004"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340004/worklog/510318",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on a change in pull request #8639:\nURL: https://github.com/apache/arrow/pull/8639#discussion_r521484903\n\n\n\n##########\nFile path: rust/datafusion/src/logical_plan/mod.rs\n##########\n@@ -1264,31 +1050,6 @@ mod tests {\n         Ok(())\n     }\n \n-    #[test]\n-    fn test_visitor() {\n-        let schema = Schema::new(vec![]);\n-        assert_eq!(\"[]\", format!(\"{}\", display_schema(&schema)));\n-    }\n-\n-    #[test]\n-    fn test_display_empty_schema() {\n-        let schema = Schema::new(vec![]);\n-        assert_eq!(\"[]\", format!(\"{}\", display_schema(&schema)));\n-    }\n-\n-    #[test]\n-    fn test_display_schema() {\n-        let schema = Schema::new(vec![\n-            Field::new(\"id\", DataType::Int32, false),\n-            Field::new(\"first_name\", DataType::Utf8, true),\n-        ]);\n-\n-        assert_eq!(\n-            \"[id:Int32, first_name:Utf8;N]\",\n-            format!(\"{}\", display_schema(&schema))\n-        );\n-    }\n\nReview comment:\n       Good \ud83d\udc41\ufe0f \r\n   \r\n   I removed \r\n   ```\r\n       fn test_visitor() {\r\n           let schema = Schema::new(vec![]);\r\n           assert_eq!(\"[]\", format!(\"{}\", display_schema(&schema)));\r\n       }\r\n   ```\r\n   \r\n   Which is redundant, except for the name, with the test immediately below: \r\n   ```\r\n       #[test]\r\n       fn test_display_empty_schema() {\r\n           let schema = Schema::new(vec![]);\r\n           assert_eq!(\"[]\", format!(\"{}\", display_schema(&schema)));\r\n       }\r\n   ```\r\n   \r\n   Aka it was removing a copy / paste bug (that I added \ud83d\ude1e )\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T16:34:21.588+0000",
                    "updated": "2020-11-11T16:34:21.588+0000",
                    "started": "2020-11-11T16:34:21.588+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510318",
                    "issueId": "13340004"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340004/worklog/510319",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on a change in pull request #8639:\nURL: https://github.com/apache/arrow/pull/8639#discussion_r521488424\n\n\n\n##########\nFile path: rust/datafusion/src/logical_plan/mod.rs\n##########\n@@ -21,2300 +21,21 @@\n //! Logical query plans can then be optimized and executed directly, or translated into\n //! physical query plans and executed.\n \n-use std::fmt::{self, Debug, Display};\n-use std::{any::Any, collections::HashMap, collections::HashSet, sync::Arc};\n-\n-use aggregates::{AccumulatorFunctionImplementation, StateTypeFunction};\n-use arrow::{\n-    compute::can_cast_types,\n-    datatypes::{DataType, Field, Schema, SchemaRef},\n-};\n-\n-use crate::datasource::parquet::ParquetTable;\n-use crate::datasource::TableProvider;\n-use crate::error::{DataFusionError, Result};\n-use crate::{\n-    datasource::csv::{CsvFile, CsvReadOptions},\n-    physical_plan::udaf::AggregateUDF,\n-    scalar::ScalarValue,\n-};\n-use crate::{\n-    physical_plan::{\n-        aggregates, expressions::binary_operator_data_type, functions, udf::ScalarUDF,\n-    },\n-    sql::parser::FileType,\n-};\n-use arrow::record_batch::RecordBatch;\n-use functions::{ReturnTypeFunction, ScalarFunctionImplementation, Signature};\n-\n+mod builder;\n+mod display;\n+mod expr;\n+mod extension;\n mod operators;\n+mod plan;\n+mod registry;\n+\n+pub use builder::LogicalPlanBuilder;\n+pub use display::display_schema;\n+pub use expr::{\n+    and, array, avg, binary_expr, col, concat, count, create_udaf, create_udf,\n+    exprlist_to_fields, length, lit, max, min, sum, Expr, Literal,\n+};\n+pub use extension::UserDefinedLogicalNode;\n pub use operators::Operator;\n-\n-fn create_function_name(\n-    fun: &String,\n-    distinct: bool,\n-    args: &[Expr],\n-    input_schema: &Schema,\n-) -> Result<String> {\n-    let names: Vec<String> = args\n-        .iter()\n-        .map(|e| create_name(e, input_schema))\n-        .collect::<Result<_>>()?;\n-    let distinct_str = match distinct {\n-        true => \"DISTINCT \",\n-        false => \"\",\n-    };\n-    Ok(format!(\"{}({}{})\", fun, distinct_str, names.join(\",\")))\n-}\n-\n-/// Returns a readable name of an expression based on the input schema.\n-/// This function recursively transverses the expression for names such as \"CAST(a > 2)\".\n-fn create_name(e: &Expr, input_schema: &Schema) -> Result<String> {\n-    match e {\n-        Expr::Alias(_, name) => Ok(name.clone()),\n-        Expr::Column(name) => Ok(name.clone()),\n-        Expr::ScalarVariable(variable_names) => Ok(variable_names.join(\".\")),\n-        Expr::Literal(value) => Ok(format!(\"{:?}\", value)),\n-        Expr::BinaryExpr { left, op, right } => {\n-            let left = create_name(left, input_schema)?;\n-            let right = create_name(right, input_schema)?;\n-            Ok(format!(\"{} {:?} {}\", left, op, right))\n-        }\n-        Expr::Cast { expr, data_type } => {\n-            let expr = create_name(expr, input_schema)?;\n-            Ok(format!(\"CAST({} AS {:?})\", expr, data_type))\n-        }\n-        Expr::Not(expr) => {\n-            let expr = create_name(expr, input_schema)?;\n-            Ok(format!(\"NOT {}\", expr))\n-        }\n-        Expr::IsNull(expr) => {\n-            let expr = create_name(expr, input_schema)?;\n-            Ok(format!(\"{} IS NULL\", expr))\n-        }\n-        Expr::IsNotNull(expr) => {\n-            let expr = create_name(expr, input_schema)?;\n-            Ok(format!(\"{} IS NOT NULL\", expr))\n-        }\n-        Expr::ScalarFunction { fun, args, .. } => {\n-            create_function_name(&fun.to_string(), false, args, input_schema)\n-        }\n-        Expr::ScalarUDF { fun, args, .. } => {\n-            create_function_name(&fun.name, false, args, input_schema)\n-        }\n-        Expr::AggregateFunction {\n-            fun,\n-            distinct,\n-            args,\n-            ..\n-        } => create_function_name(&fun.to_string(), *distinct, args, input_schema),\n-        Expr::AggregateUDF { fun, args } => {\n-            let mut names = Vec::with_capacity(args.len());\n-            for e in args {\n-                names.push(create_name(e, input_schema)?);\n-            }\n-            Ok(format!(\"{}({})\", fun.name, names.join(\",\")))\n-        }\n-        other => Err(DataFusionError::NotImplemented(format!(\n-            \"Physical plan does not support logical expression {:?}\",\n-            other\n-        ))),\n-    }\n-}\n-\n-/// Create field meta-data from an expression, for use in a result set schema\n-pub fn exprlist_to_fields(expr: &[Expr], input_schema: &Schema) -> Result<Vec<Field>> {\n-    expr.iter().map(|e| e.to_field(input_schema)).collect()\n-}\n-\n-/// `Expr` is a logical expression. A logical expression is something like `1 + 1`, or `CAST(c1 AS int)`.\n-/// Logical expressions know how to compute its [arrow::datatypes::DataType] and nullability.\n-/// `Expr` is a central struct of DataFusion's query API.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # use datafusion::logical_plan::Expr;\n-/// # use datafusion::error::Result;\n-/// # fn main() -> Result<()> {\n-/// let expr = Expr::Column(\"c1\".to_string()) + Expr::Column(\"c2\".to_string());\n-/// println!(\"{:?}\", expr);\n-/// # Ok(())\n-/// # }\n-/// ```\n-#[derive(Clone)]\n-pub enum Expr {\n-    /// An expression with a specific name.\n-    Alias(Box<Expr>, String),\n-    /// A named reference to a field in a schema.\n-    Column(String),\n-    /// A named reference to a variable in a registry.\n-    ScalarVariable(Vec<String>),\n-    /// A constant value.\n-    Literal(ScalarValue),\n-    /// A binary expression such as \"age > 21\"\n-    BinaryExpr {\n-        /// Left-hand side of the expression\n-        left: Box<Expr>,\n-        /// The comparison operator\n-        op: Operator,\n-        /// Right-hand side of the expression\n-        right: Box<Expr>,\n-    },\n-    /// Parenthesized expression. E.g. `(foo > bar)` or `(1)`\n-    Nested(Box<Expr>),\n-    /// Negation of an expression. The expression's type must be a boolean to make sense.\n-    Not(Box<Expr>),\n-    /// Whether an expression is not Null. This expression is never null.\n-    IsNotNull(Box<Expr>),\n-    /// Whether an expression is Null. This expression is never null.\n-    IsNull(Box<Expr>),\n-    /// Casts the expression to a given type. This expression is guaranteed to have a fixed type.\n-    Cast {\n-        /// The expression being cast\n-        expr: Box<Expr>,\n-        /// The `DataType` the expression will yield\n-        data_type: DataType,\n-    },\n-    /// A sort expression, that can be used to sort values.\n-    Sort {\n-        /// The expression to sort on\n-        expr: Box<Expr>,\n-        /// The direction of the sort\n-        asc: bool,\n-        /// Whether to put Nulls before all other data values\n-        nulls_first: bool,\n-    },\n-    /// Represents the call of a built-in scalar function with a set of arguments.\n-    ScalarFunction {\n-        /// The function\n-        fun: functions::BuiltinScalarFunction,\n-        /// List of expressions to feed to the functions as arguments\n-        args: Vec<Expr>,\n-    },\n-    /// Represents the call of a user-defined scalar function with arguments.\n-    ScalarUDF {\n-        /// The function\n-        fun: Arc<ScalarUDF>,\n-        /// List of expressions to feed to the functions as arguments\n-        args: Vec<Expr>,\n-    },\n-    /// Represents the call of an aggregate built-in function with arguments.\n-    AggregateFunction {\n-        /// Name of the function\n-        fun: aggregates::AggregateFunction,\n-        /// List of expressions to feed to the functions as arguments\n-        args: Vec<Expr>,\n-        /// Whether this is a DISTINCT aggregation or not\n-        distinct: bool,\n-    },\n-    /// aggregate function\n-    AggregateUDF {\n-        /// The function\n-        fun: Arc<AggregateUDF>,\n-        /// List of expressions to feed to the functions as arguments\n-        args: Vec<Expr>,\n-    },\n-    /// Represents a reference to all fields in a schema.\n-    Wildcard,\n-}\n-\n-impl Expr {\n-    /// Returns the [arrow::datatypes::DataType] of the expression based on [arrow::datatypes::Schema].\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function errors when it is not possible to compute its [arrow::datatypes::DataType].\n-    /// This happens when e.g. the expression refers to a column that does not exist in the schema, or when\n-    /// the expression is incorrectly typed (e.g. `[utf8] + [bool]`).\n-    pub fn get_type(&self, schema: &Schema) -> Result<DataType> {\n-        match self {\n-            Expr::Alias(expr, _) => expr.get_type(schema),\n-            Expr::Column(name) => Ok(schema.field_with_name(name)?.data_type().clone()),\n-            Expr::ScalarVariable(_) => Ok(DataType::Utf8),\n-            Expr::Literal(l) => Ok(l.get_datatype()),\n-            Expr::Cast { data_type, .. } => Ok(data_type.clone()),\n-            Expr::ScalarUDF { fun, args } => {\n-                let data_types = args\n-                    .iter()\n-                    .map(|e| e.get_type(schema))\n-                    .collect::<Result<Vec<_>>>()?;\n-                Ok((fun.return_type)(&data_types)?.as_ref().clone())\n-            }\n-            Expr::ScalarFunction { fun, args } => {\n-                let data_types = args\n-                    .iter()\n-                    .map(|e| e.get_type(schema))\n-                    .collect::<Result<Vec<_>>>()?;\n-                functions::return_type(fun, &data_types)\n-            }\n-            Expr::AggregateFunction { fun, args, .. } => {\n-                let data_types = args\n-                    .iter()\n-                    .map(|e| e.get_type(schema))\n-                    .collect::<Result<Vec<_>>>()?;\n-                aggregates::return_type(fun, &data_types)\n-            }\n-            Expr::AggregateUDF { fun, args, .. } => {\n-                let data_types = args\n-                    .iter()\n-                    .map(|e| e.get_type(schema))\n-                    .collect::<Result<Vec<_>>>()?;\n-                Ok((fun.return_type)(&data_types)?.as_ref().clone())\n-            }\n-            Expr::Not(_) => Ok(DataType::Boolean),\n-            Expr::IsNull(_) => Ok(DataType::Boolean),\n-            Expr::IsNotNull(_) => Ok(DataType::Boolean),\n-            Expr::BinaryExpr {\n-                ref left,\n-                ref right,\n-                ref op,\n-            } => binary_operator_data_type(\n-                &left.get_type(schema)?,\n-                op,\n-                &right.get_type(schema)?,\n-            ),\n-            Expr::Sort { ref expr, .. } => expr.get_type(schema),\n-            Expr::Wildcard => Err(DataFusionError::Internal(\n-                \"Wildcard expressions are not valid in a logical query plan\".to_owned(),\n-            )),\n-            Expr::Nested(e) => e.get_type(schema),\n-        }\n-    }\n-\n-    /// Returns the nullability of the expression based on [arrow::datatypes::Schema].\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function errors when it is not possible to compute its nullability.\n-    /// This happens when the expression refers to a column that does not exist in the schema.\n-    pub fn nullable(&self, input_schema: &Schema) -> Result<bool> {\n-        match self {\n-            Expr::Alias(expr, _) => expr.nullable(input_schema),\n-            Expr::Column(name) => Ok(input_schema.field_with_name(name)?.is_nullable()),\n-            Expr::Literal(value) => Ok(value.is_null()),\n-            Expr::ScalarVariable(_) => Ok(true),\n-            Expr::Cast { expr, .. } => expr.nullable(input_schema),\n-            Expr::ScalarFunction { .. } => Ok(true),\n-            Expr::ScalarUDF { .. } => Ok(true),\n-            Expr::AggregateFunction { .. } => Ok(true),\n-            Expr::AggregateUDF { .. } => Ok(true),\n-            Expr::Not(expr) => expr.nullable(input_schema),\n-            Expr::IsNull(_) => Ok(false),\n-            Expr::IsNotNull(_) => Ok(false),\n-            Expr::BinaryExpr {\n-                ref left,\n-                ref right,\n-                ..\n-            } => Ok(left.nullable(input_schema)? || right.nullable(input_schema)?),\n-            Expr::Sort { ref expr, .. } => expr.nullable(input_schema),\n-            Expr::Nested(e) => e.nullable(input_schema),\n-            Expr::Wildcard => Err(DataFusionError::Internal(\n-                \"Wildcard expressions are not valid in a logical query plan\".to_owned(),\n-            )),\n-        }\n-    }\n-\n-    /// Returns the name of this expression based on [arrow::datatypes::Schema].\n-    ///\n-    /// This represents how a column with this expression is named when no alias is chosen\n-    pub fn name(&self, input_schema: &Schema) -> Result<String> {\n-        create_name(self, input_schema)\n-    }\n-\n-    /// Returns a [arrow::datatypes::Field] compatible with this expression.\n-    pub fn to_field(&self, input_schema: &Schema) -> Result<Field> {\n-        Ok(Field::new(\n-            &self.name(input_schema)?,\n-            self.get_type(input_schema)?,\n-            self.nullable(input_schema)?,\n-        ))\n-    }\n-\n-    /// Wraps this expression in a cast to a target [arrow::datatypes::DataType].\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function errors when it is impossible to cast the\n-    /// expression to the target [arrow::datatypes::DataType].\n-    pub fn cast_to(&self, cast_to_type: &DataType, schema: &Schema) -> Result<Expr> {\n-        let this_type = self.get_type(schema)?;\n-        if this_type == *cast_to_type {\n-            Ok(self.clone())\n-        } else if can_cast_types(&this_type, cast_to_type) {\n-            Ok(Expr::Cast {\n-                expr: Box::new(self.clone()),\n-                data_type: cast_to_type.clone(),\n-            })\n-        } else {\n-            Err(DataFusionError::Plan(format!(\n-                \"Cannot automatically convert {:?} to {:?}\",\n-                this_type, cast_to_type\n-            )))\n-        }\n-    }\n-\n-    /// Equal\n-    pub fn eq(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Eq, other.clone())\n-    }\n-\n-    /// Not equal\n-    pub fn not_eq(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::NotEq, other.clone())\n-    }\n-\n-    /// Greater than\n-    pub fn gt(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Gt, other.clone())\n-    }\n-\n-    /// Greater than or equal to\n-    pub fn gt_eq(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::GtEq, other.clone())\n-    }\n-\n-    /// Less than\n-    pub fn lt(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Lt, other.clone())\n-    }\n-\n-    /// Less than or equal to\n-    pub fn lt_eq(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::LtEq, other.clone())\n-    }\n-\n-    /// And\n-    pub fn and(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::And, other)\n-    }\n-\n-    /// Or\n-    pub fn or(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Or, other)\n-    }\n-\n-    /// Not\n-    pub fn not(&self) -> Expr {\n-        Expr::Not(Box::new(self.clone()))\n-    }\n-\n-    /// Calculate the modulus of two expressions\n-    pub fn modulus(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Modulus, other.clone())\n-    }\n-\n-    /// like (string) another expression\n-    pub fn like(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Like, other.clone())\n-    }\n-\n-    /// not like another expression\n-    pub fn not_like(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::NotLike, other.clone())\n-    }\n-\n-    /// Alias\n-    pub fn alias(&self, name: &str) -> Expr {\n-        Expr::Alias(Box::new(self.clone()), name.to_owned())\n-    }\n-\n-    /// Create a sort expression from an existing expression.\n-    ///\n-    /// ```\n-    /// # use datafusion::logical_plan::col;\n-    /// let sort_expr = col(\"foo\").sort(true, true); // SORT ASC NULLS_FIRST\n-    /// ```\n-    pub fn sort(&self, asc: bool, nulls_first: bool) -> Expr {\n-        Expr::Sort {\n-            expr: Box::new(self.clone()),\n-            asc,\n-            nulls_first,\n-        }\n-    }\n-}\n-\n-fn binary_expr(l: Expr, op: Operator, r: Expr) -> Expr {\n-    Expr::BinaryExpr {\n-        left: Box::new(l),\n-        op,\n-        right: Box::new(r),\n-    }\n-}\n-\n-/// return a new expression with a logical AND\n-pub fn and(left: &Expr, right: &Expr) -> Expr {\n-    Expr::BinaryExpr {\n-        left: Box::new(left.clone()),\n-        op: Operator::And,\n-        right: Box::new(right.clone()),\n-    }\n-}\n-\n-/// Create a column expression based on a column name\n-pub fn col(name: &str) -> Expr {\n-    Expr::Column(name.to_owned())\n-}\n-\n-/// Create an expression to represent the min() aggregate function\n-pub fn min(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Min,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Create an expression to represent the max() aggregate function\n-pub fn max(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Max,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Create an expression to represent the sum() aggregate function\n-pub fn sum(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Sum,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Create an expression to represent the avg() aggregate function\n-pub fn avg(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Avg,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Create an expression to represent the count() aggregate function\n-pub fn count(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Count,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Whether it can be represented as a literal expression\n-pub trait Literal {\n-    /// convert the value to a Literal expression\n-    fn lit(&self) -> Expr;\n-}\n-\n-impl Literal for &str {\n-    fn lit(&self) -> Expr {\n-        Expr::Literal(ScalarValue::Utf8(Some((*self).to_owned())))\n-    }\n-}\n-\n-impl Literal for String {\n-    fn lit(&self) -> Expr {\n-        Expr::Literal(ScalarValue::Utf8(Some((*self).to_owned())))\n-    }\n-}\n-\n-macro_rules! make_literal {\n-    ($TYPE:ty, $SCALAR:ident) => {\n-        #[allow(missing_docs)]\n-        impl Literal for $TYPE {\n-            fn lit(&self) -> Expr {\n-                Expr::Literal(ScalarValue::$SCALAR(Some(self.clone())))\n-            }\n-        }\n-    };\n-}\n-\n-make_literal!(bool, Boolean);\n-make_literal!(f32, Float32);\n-make_literal!(f64, Float64);\n-make_literal!(i8, Int8);\n-make_literal!(i16, Int16);\n-make_literal!(i32, Int32);\n-make_literal!(i64, Int64);\n-make_literal!(u8, UInt8);\n-make_literal!(u16, UInt16);\n-make_literal!(u32, UInt32);\n-make_literal!(u64, UInt64);\n-\n-/// Create a literal expression\n-pub fn lit<T: Literal>(n: T) -> Expr {\n-    n.lit()\n-}\n-\n-/// Create an convenience function representing a unary scalar function\n-macro_rules! unary_math_expr {\n-    ($ENUM:ident, $FUNC:ident) => {\n-        #[allow(missing_docs)]\n-        pub fn $FUNC(e: Expr) -> Expr {\n-            Expr::ScalarFunction {\n-                fun: functions::BuiltinScalarFunction::$ENUM,\n-                args: vec![e],\n-            }\n-        }\n-    };\n-}\n-\n-// generate methods for creating the supported unary math expressions\n-unary_math_expr!(Sqrt, sqrt);\n-unary_math_expr!(Sin, sin);\n-unary_math_expr!(Cos, cos);\n-unary_math_expr!(Tan, tan);\n-unary_math_expr!(Asin, asin);\n-unary_math_expr!(Acos, acos);\n-unary_math_expr!(Atan, atan);\n-unary_math_expr!(Floor, floor);\n-unary_math_expr!(Ceil, ceil);\n-unary_math_expr!(Round, round);\n-unary_math_expr!(Trunc, trunc);\n-unary_math_expr!(Abs, abs);\n-unary_math_expr!(Signum, signum);\n-unary_math_expr!(Exp, exp);\n-unary_math_expr!(Log, ln);\n-unary_math_expr!(Log2, log2);\n\nReview comment:\n       The compiler started complaining to me that they were not used so I removed them and the tests keep passing\r\n   \r\n   I just tested with the repl and I seem to be able to plan the expressions just fine, so I guess the compiler was right from what I can see. Maybe I am missing something\r\n   \r\n   \r\n   ```\r\n   (arrow_dev) alamb@MacBook-Pro:~/Software/arrow2/rust$ git status\r\n   On branch alamb/ARROW-10559-split-up\r\n   Your branch is up to date with 'alamb/alamb/ARROW-10559-split-up'.\r\n   \r\n   nothing to commit, working tree clean\r\n   (arrow_dev) alamb@MacBook-Pro:~/Software/arrow2/rust$ cd datafusion/\r\n   (arrow_dev) alamb@MacBook-Pro:~/Software/arrow2/rust/datafusion$ echo \"1\" > /tmp/table.csv\r\n   (arrow_dev) alamb@MacBook-Pro:~/Software/arrow2/rust/datafusion$ echo \"2\" >> /tmp/table.csv\r\n   (arrow_dev) alamb@MacBook-Pro:~/Software/arrow2/rust/datafusion$ \r\n   (arrow_dev) alamb@MacBook-Pro:~/Software/arrow2/rust/datafusion$ cargo run --bin repl\r\n       Finished dev [unoptimized + debuginfo] target(s) in 0.13s\r\n        Running `/Users/alamb/Software/arrow2/rust/target/debug/repl`\r\n   > \r\n   \r\n   CREATE EXTERNAL TABLE t(a int)\r\n   STORED AS CSV\r\n   LOCATION '/tmp/table.csv';\r\n   \r\n   0 rows in set. Query took 0 seconds.\r\n   > select sqrt(a) from t;\r\n   +--------------------+\r\n   | sqrt(a)            |\r\n   +--------------------+\r\n   | 1                  |\r\n   | 1.4142135623730951 |\r\n   +--------------------+\r\n   2 row in set. Query took 0 seconds.\r\n   > \r\n   ```\r\n   \r\n   \ud83e\udd14  So I guess they aren't needed?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T16:39:40.517+0000",
                    "updated": "2020-11-11T16:39:40.517+0000",
                    "started": "2020-11-11T16:39:40.517+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510319",
                    "issueId": "13340004"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340004/worklog/510326",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8639:\nURL: https://github.com/apache/arrow/pull/8639#discussion_r521494620\n\n\n\n##########\nFile path: rust/datafusion/src/logical_plan/mod.rs\n##########\n@@ -21,2300 +21,21 @@\n //! Logical query plans can then be optimized and executed directly, or translated into\n //! physical query plans and executed.\n \n-use std::fmt::{self, Debug, Display};\n-use std::{any::Any, collections::HashMap, collections::HashSet, sync::Arc};\n-\n-use aggregates::{AccumulatorFunctionImplementation, StateTypeFunction};\n-use arrow::{\n-    compute::can_cast_types,\n-    datatypes::{DataType, Field, Schema, SchemaRef},\n-};\n-\n-use crate::datasource::parquet::ParquetTable;\n-use crate::datasource::TableProvider;\n-use crate::error::{DataFusionError, Result};\n-use crate::{\n-    datasource::csv::{CsvFile, CsvReadOptions},\n-    physical_plan::udaf::AggregateUDF,\n-    scalar::ScalarValue,\n-};\n-use crate::{\n-    physical_plan::{\n-        aggregates, expressions::binary_operator_data_type, functions, udf::ScalarUDF,\n-    },\n-    sql::parser::FileType,\n-};\n-use arrow::record_batch::RecordBatch;\n-use functions::{ReturnTypeFunction, ScalarFunctionImplementation, Signature};\n-\n+mod builder;\n+mod display;\n+mod expr;\n+mod extension;\n mod operators;\n+mod plan;\n+mod registry;\n+\n+pub use builder::LogicalPlanBuilder;\n+pub use display::display_schema;\n+pub use expr::{\n+    and, array, avg, binary_expr, col, concat, count, create_udaf, create_udf,\n+    exprlist_to_fields, length, lit, max, min, sum, Expr, Literal,\n+};\n+pub use extension::UserDefinedLogicalNode;\n pub use operators::Operator;\n-\n-fn create_function_name(\n-    fun: &String,\n-    distinct: bool,\n-    args: &[Expr],\n-    input_schema: &Schema,\n-) -> Result<String> {\n-    let names: Vec<String> = args\n-        .iter()\n-        .map(|e| create_name(e, input_schema))\n-        .collect::<Result<_>>()?;\n-    let distinct_str = match distinct {\n-        true => \"DISTINCT \",\n-        false => \"\",\n-    };\n-    Ok(format!(\"{}({}{})\", fun, distinct_str, names.join(\",\")))\n-}\n-\n-/// Returns a readable name of an expression based on the input schema.\n-/// This function recursively transverses the expression for names such as \"CAST(a > 2)\".\n-fn create_name(e: &Expr, input_schema: &Schema) -> Result<String> {\n-    match e {\n-        Expr::Alias(_, name) => Ok(name.clone()),\n-        Expr::Column(name) => Ok(name.clone()),\n-        Expr::ScalarVariable(variable_names) => Ok(variable_names.join(\".\")),\n-        Expr::Literal(value) => Ok(format!(\"{:?}\", value)),\n-        Expr::BinaryExpr { left, op, right } => {\n-            let left = create_name(left, input_schema)?;\n-            let right = create_name(right, input_schema)?;\n-            Ok(format!(\"{} {:?} {}\", left, op, right))\n-        }\n-        Expr::Cast { expr, data_type } => {\n-            let expr = create_name(expr, input_schema)?;\n-            Ok(format!(\"CAST({} AS {:?})\", expr, data_type))\n-        }\n-        Expr::Not(expr) => {\n-            let expr = create_name(expr, input_schema)?;\n-            Ok(format!(\"NOT {}\", expr))\n-        }\n-        Expr::IsNull(expr) => {\n-            let expr = create_name(expr, input_schema)?;\n-            Ok(format!(\"{} IS NULL\", expr))\n-        }\n-        Expr::IsNotNull(expr) => {\n-            let expr = create_name(expr, input_schema)?;\n-            Ok(format!(\"{} IS NOT NULL\", expr))\n-        }\n-        Expr::ScalarFunction { fun, args, .. } => {\n-            create_function_name(&fun.to_string(), false, args, input_schema)\n-        }\n-        Expr::ScalarUDF { fun, args, .. } => {\n-            create_function_name(&fun.name, false, args, input_schema)\n-        }\n-        Expr::AggregateFunction {\n-            fun,\n-            distinct,\n-            args,\n-            ..\n-        } => create_function_name(&fun.to_string(), *distinct, args, input_schema),\n-        Expr::AggregateUDF { fun, args } => {\n-            let mut names = Vec::with_capacity(args.len());\n-            for e in args {\n-                names.push(create_name(e, input_schema)?);\n-            }\n-            Ok(format!(\"{}({})\", fun.name, names.join(\",\")))\n-        }\n-        other => Err(DataFusionError::NotImplemented(format!(\n-            \"Physical plan does not support logical expression {:?}\",\n-            other\n-        ))),\n-    }\n-}\n-\n-/// Create field meta-data from an expression, for use in a result set schema\n-pub fn exprlist_to_fields(expr: &[Expr], input_schema: &Schema) -> Result<Vec<Field>> {\n-    expr.iter().map(|e| e.to_field(input_schema)).collect()\n-}\n-\n-/// `Expr` is a logical expression. A logical expression is something like `1 + 1`, or `CAST(c1 AS int)`.\n-/// Logical expressions know how to compute its [arrow::datatypes::DataType] and nullability.\n-/// `Expr` is a central struct of DataFusion's query API.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # use datafusion::logical_plan::Expr;\n-/// # use datafusion::error::Result;\n-/// # fn main() -> Result<()> {\n-/// let expr = Expr::Column(\"c1\".to_string()) + Expr::Column(\"c2\".to_string());\n-/// println!(\"{:?}\", expr);\n-/// # Ok(())\n-/// # }\n-/// ```\n-#[derive(Clone)]\n-pub enum Expr {\n-    /// An expression with a specific name.\n-    Alias(Box<Expr>, String),\n-    /// A named reference to a field in a schema.\n-    Column(String),\n-    /// A named reference to a variable in a registry.\n-    ScalarVariable(Vec<String>),\n-    /// A constant value.\n-    Literal(ScalarValue),\n-    /// A binary expression such as \"age > 21\"\n-    BinaryExpr {\n-        /// Left-hand side of the expression\n-        left: Box<Expr>,\n-        /// The comparison operator\n-        op: Operator,\n-        /// Right-hand side of the expression\n-        right: Box<Expr>,\n-    },\n-    /// Parenthesized expression. E.g. `(foo > bar)` or `(1)`\n-    Nested(Box<Expr>),\n-    /// Negation of an expression. The expression's type must be a boolean to make sense.\n-    Not(Box<Expr>),\n-    /// Whether an expression is not Null. This expression is never null.\n-    IsNotNull(Box<Expr>),\n-    /// Whether an expression is Null. This expression is never null.\n-    IsNull(Box<Expr>),\n-    /// Casts the expression to a given type. This expression is guaranteed to have a fixed type.\n-    Cast {\n-        /// The expression being cast\n-        expr: Box<Expr>,\n-        /// The `DataType` the expression will yield\n-        data_type: DataType,\n-    },\n-    /// A sort expression, that can be used to sort values.\n-    Sort {\n-        /// The expression to sort on\n-        expr: Box<Expr>,\n-        /// The direction of the sort\n-        asc: bool,\n-        /// Whether to put Nulls before all other data values\n-        nulls_first: bool,\n-    },\n-    /// Represents the call of a built-in scalar function with a set of arguments.\n-    ScalarFunction {\n-        /// The function\n-        fun: functions::BuiltinScalarFunction,\n-        /// List of expressions to feed to the functions as arguments\n-        args: Vec<Expr>,\n-    },\n-    /// Represents the call of a user-defined scalar function with arguments.\n-    ScalarUDF {\n-        /// The function\n-        fun: Arc<ScalarUDF>,\n-        /// List of expressions to feed to the functions as arguments\n-        args: Vec<Expr>,\n-    },\n-    /// Represents the call of an aggregate built-in function with arguments.\n-    AggregateFunction {\n-        /// Name of the function\n-        fun: aggregates::AggregateFunction,\n-        /// List of expressions to feed to the functions as arguments\n-        args: Vec<Expr>,\n-        /// Whether this is a DISTINCT aggregation or not\n-        distinct: bool,\n-    },\n-    /// aggregate function\n-    AggregateUDF {\n-        /// The function\n-        fun: Arc<AggregateUDF>,\n-        /// List of expressions to feed to the functions as arguments\n-        args: Vec<Expr>,\n-    },\n-    /// Represents a reference to all fields in a schema.\n-    Wildcard,\n-}\n-\n-impl Expr {\n-    /// Returns the [arrow::datatypes::DataType] of the expression based on [arrow::datatypes::Schema].\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function errors when it is not possible to compute its [arrow::datatypes::DataType].\n-    /// This happens when e.g. the expression refers to a column that does not exist in the schema, or when\n-    /// the expression is incorrectly typed (e.g. `[utf8] + [bool]`).\n-    pub fn get_type(&self, schema: &Schema) -> Result<DataType> {\n-        match self {\n-            Expr::Alias(expr, _) => expr.get_type(schema),\n-            Expr::Column(name) => Ok(schema.field_with_name(name)?.data_type().clone()),\n-            Expr::ScalarVariable(_) => Ok(DataType::Utf8),\n-            Expr::Literal(l) => Ok(l.get_datatype()),\n-            Expr::Cast { data_type, .. } => Ok(data_type.clone()),\n-            Expr::ScalarUDF { fun, args } => {\n-                let data_types = args\n-                    .iter()\n-                    .map(|e| e.get_type(schema))\n-                    .collect::<Result<Vec<_>>>()?;\n-                Ok((fun.return_type)(&data_types)?.as_ref().clone())\n-            }\n-            Expr::ScalarFunction { fun, args } => {\n-                let data_types = args\n-                    .iter()\n-                    .map(|e| e.get_type(schema))\n-                    .collect::<Result<Vec<_>>>()?;\n-                functions::return_type(fun, &data_types)\n-            }\n-            Expr::AggregateFunction { fun, args, .. } => {\n-                let data_types = args\n-                    .iter()\n-                    .map(|e| e.get_type(schema))\n-                    .collect::<Result<Vec<_>>>()?;\n-                aggregates::return_type(fun, &data_types)\n-            }\n-            Expr::AggregateUDF { fun, args, .. } => {\n-                let data_types = args\n-                    .iter()\n-                    .map(|e| e.get_type(schema))\n-                    .collect::<Result<Vec<_>>>()?;\n-                Ok((fun.return_type)(&data_types)?.as_ref().clone())\n-            }\n-            Expr::Not(_) => Ok(DataType::Boolean),\n-            Expr::IsNull(_) => Ok(DataType::Boolean),\n-            Expr::IsNotNull(_) => Ok(DataType::Boolean),\n-            Expr::BinaryExpr {\n-                ref left,\n-                ref right,\n-                ref op,\n-            } => binary_operator_data_type(\n-                &left.get_type(schema)?,\n-                op,\n-                &right.get_type(schema)?,\n-            ),\n-            Expr::Sort { ref expr, .. } => expr.get_type(schema),\n-            Expr::Wildcard => Err(DataFusionError::Internal(\n-                \"Wildcard expressions are not valid in a logical query plan\".to_owned(),\n-            )),\n-            Expr::Nested(e) => e.get_type(schema),\n-        }\n-    }\n-\n-    /// Returns the nullability of the expression based on [arrow::datatypes::Schema].\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function errors when it is not possible to compute its nullability.\n-    /// This happens when the expression refers to a column that does not exist in the schema.\n-    pub fn nullable(&self, input_schema: &Schema) -> Result<bool> {\n-        match self {\n-            Expr::Alias(expr, _) => expr.nullable(input_schema),\n-            Expr::Column(name) => Ok(input_schema.field_with_name(name)?.is_nullable()),\n-            Expr::Literal(value) => Ok(value.is_null()),\n-            Expr::ScalarVariable(_) => Ok(true),\n-            Expr::Cast { expr, .. } => expr.nullable(input_schema),\n-            Expr::ScalarFunction { .. } => Ok(true),\n-            Expr::ScalarUDF { .. } => Ok(true),\n-            Expr::AggregateFunction { .. } => Ok(true),\n-            Expr::AggregateUDF { .. } => Ok(true),\n-            Expr::Not(expr) => expr.nullable(input_schema),\n-            Expr::IsNull(_) => Ok(false),\n-            Expr::IsNotNull(_) => Ok(false),\n-            Expr::BinaryExpr {\n-                ref left,\n-                ref right,\n-                ..\n-            } => Ok(left.nullable(input_schema)? || right.nullable(input_schema)?),\n-            Expr::Sort { ref expr, .. } => expr.nullable(input_schema),\n-            Expr::Nested(e) => e.nullable(input_schema),\n-            Expr::Wildcard => Err(DataFusionError::Internal(\n-                \"Wildcard expressions are not valid in a logical query plan\".to_owned(),\n-            )),\n-        }\n-    }\n-\n-    /// Returns the name of this expression based on [arrow::datatypes::Schema].\n-    ///\n-    /// This represents how a column with this expression is named when no alias is chosen\n-    pub fn name(&self, input_schema: &Schema) -> Result<String> {\n-        create_name(self, input_schema)\n-    }\n-\n-    /// Returns a [arrow::datatypes::Field] compatible with this expression.\n-    pub fn to_field(&self, input_schema: &Schema) -> Result<Field> {\n-        Ok(Field::new(\n-            &self.name(input_schema)?,\n-            self.get_type(input_schema)?,\n-            self.nullable(input_schema)?,\n-        ))\n-    }\n-\n-    /// Wraps this expression in a cast to a target [arrow::datatypes::DataType].\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function errors when it is impossible to cast the\n-    /// expression to the target [arrow::datatypes::DataType].\n-    pub fn cast_to(&self, cast_to_type: &DataType, schema: &Schema) -> Result<Expr> {\n-        let this_type = self.get_type(schema)?;\n-        if this_type == *cast_to_type {\n-            Ok(self.clone())\n-        } else if can_cast_types(&this_type, cast_to_type) {\n-            Ok(Expr::Cast {\n-                expr: Box::new(self.clone()),\n-                data_type: cast_to_type.clone(),\n-            })\n-        } else {\n-            Err(DataFusionError::Plan(format!(\n-                \"Cannot automatically convert {:?} to {:?}\",\n-                this_type, cast_to_type\n-            )))\n-        }\n-    }\n-\n-    /// Equal\n-    pub fn eq(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Eq, other.clone())\n-    }\n-\n-    /// Not equal\n-    pub fn not_eq(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::NotEq, other.clone())\n-    }\n-\n-    /// Greater than\n-    pub fn gt(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Gt, other.clone())\n-    }\n-\n-    /// Greater than or equal to\n-    pub fn gt_eq(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::GtEq, other.clone())\n-    }\n-\n-    /// Less than\n-    pub fn lt(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Lt, other.clone())\n-    }\n-\n-    /// Less than or equal to\n-    pub fn lt_eq(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::LtEq, other.clone())\n-    }\n-\n-    /// And\n-    pub fn and(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::And, other)\n-    }\n-\n-    /// Or\n-    pub fn or(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Or, other)\n-    }\n-\n-    /// Not\n-    pub fn not(&self) -> Expr {\n-        Expr::Not(Box::new(self.clone()))\n-    }\n-\n-    /// Calculate the modulus of two expressions\n-    pub fn modulus(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Modulus, other.clone())\n-    }\n-\n-    /// like (string) another expression\n-    pub fn like(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Like, other.clone())\n-    }\n-\n-    /// not like another expression\n-    pub fn not_like(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::NotLike, other.clone())\n-    }\n-\n-    /// Alias\n-    pub fn alias(&self, name: &str) -> Expr {\n-        Expr::Alias(Box::new(self.clone()), name.to_owned())\n-    }\n-\n-    /// Create a sort expression from an existing expression.\n-    ///\n-    /// ```\n-    /// # use datafusion::logical_plan::col;\n-    /// let sort_expr = col(\"foo\").sort(true, true); // SORT ASC NULLS_FIRST\n-    /// ```\n-    pub fn sort(&self, asc: bool, nulls_first: bool) -> Expr {\n-        Expr::Sort {\n-            expr: Box::new(self.clone()),\n-            asc,\n-            nulls_first,\n-        }\n-    }\n-}\n-\n-fn binary_expr(l: Expr, op: Operator, r: Expr) -> Expr {\n-    Expr::BinaryExpr {\n-        left: Box::new(l),\n-        op,\n-        right: Box::new(r),\n-    }\n-}\n-\n-/// return a new expression with a logical AND\n-pub fn and(left: &Expr, right: &Expr) -> Expr {\n-    Expr::BinaryExpr {\n-        left: Box::new(left.clone()),\n-        op: Operator::And,\n-        right: Box::new(right.clone()),\n-    }\n-}\n-\n-/// Create a column expression based on a column name\n-pub fn col(name: &str) -> Expr {\n-    Expr::Column(name.to_owned())\n-}\n-\n-/// Create an expression to represent the min() aggregate function\n-pub fn min(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Min,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Create an expression to represent the max() aggregate function\n-pub fn max(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Max,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Create an expression to represent the sum() aggregate function\n-pub fn sum(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Sum,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Create an expression to represent the avg() aggregate function\n-pub fn avg(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Avg,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Create an expression to represent the count() aggregate function\n-pub fn count(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Count,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Whether it can be represented as a literal expression\n-pub trait Literal {\n-    /// convert the value to a Literal expression\n-    fn lit(&self) -> Expr;\n-}\n-\n-impl Literal for &str {\n-    fn lit(&self) -> Expr {\n-        Expr::Literal(ScalarValue::Utf8(Some((*self).to_owned())))\n-    }\n-}\n-\n-impl Literal for String {\n-    fn lit(&self) -> Expr {\n-        Expr::Literal(ScalarValue::Utf8(Some((*self).to_owned())))\n-    }\n-}\n-\n-macro_rules! make_literal {\n-    ($TYPE:ty, $SCALAR:ident) => {\n-        #[allow(missing_docs)]\n-        impl Literal for $TYPE {\n-            fn lit(&self) -> Expr {\n-                Expr::Literal(ScalarValue::$SCALAR(Some(self.clone())))\n-            }\n-        }\n-    };\n-}\n-\n-make_literal!(bool, Boolean);\n-make_literal!(f32, Float32);\n-make_literal!(f64, Float64);\n-make_literal!(i8, Int8);\n-make_literal!(i16, Int16);\n-make_literal!(i32, Int32);\n-make_literal!(i64, Int64);\n-make_literal!(u8, UInt8);\n-make_literal!(u16, UInt16);\n-make_literal!(u32, UInt32);\n-make_literal!(u64, UInt64);\n-\n-/// Create a literal expression\n-pub fn lit<T: Literal>(n: T) -> Expr {\n-    n.lit()\n-}\n-\n-/// Create an convenience function representing a unary scalar function\n-macro_rules! unary_math_expr {\n-    ($ENUM:ident, $FUNC:ident) => {\n-        #[allow(missing_docs)]\n-        pub fn $FUNC(e: Expr) -> Expr {\n-            Expr::ScalarFunction {\n-                fun: functions::BuiltinScalarFunction::$ENUM,\n-                args: vec![e],\n-            }\n-        }\n-    };\n-}\n-\n-// generate methods for creating the supported unary math expressions\n-unary_math_expr!(Sqrt, sqrt);\n-unary_math_expr!(Sin, sin);\n-unary_math_expr!(Cos, cos);\n-unary_math_expr!(Tan, tan);\n-unary_math_expr!(Asin, asin);\n-unary_math_expr!(Acos, acos);\n-unary_math_expr!(Atan, atan);\n-unary_math_expr!(Floor, floor);\n-unary_math_expr!(Ceil, ceil);\n-unary_math_expr!(Round, round);\n-unary_math_expr!(Trunc, trunc);\n-unary_math_expr!(Abs, abs);\n-unary_math_expr!(Signum, signum);\n-unary_math_expr!(Exp, exp);\n-unary_math_expr!(Log, ln);\n-unary_math_expr!(Log2, log2);\n\nReview comment:\n       I think that they are used when creating a statement via the DataFrame API. I.e. in `examples/dataframe.rs`, if we want to create an expression that is `sqrt(col(\"c1\"))`, we need to import `sqrt` from `logical_plan`. No?\r\n   \r\n   I find it odd that the compiler is arguing that `pub` functions are not being used, though xD\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T16:49:03.613+0000",
                    "updated": "2020-11-11T16:49:03.613+0000",
                    "started": "2020-11-11T16:49:03.612+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510326",
                    "issueId": "13340004"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340004/worklog/510370",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on a change in pull request #8639:\nURL: https://github.com/apache/arrow/pull/8639#discussion_r521541312\n\n\n\n##########\nFile path: rust/datafusion/src/logical_plan/mod.rs\n##########\n@@ -21,2300 +21,21 @@\n //! Logical query plans can then be optimized and executed directly, or translated into\n //! physical query plans and executed.\n \n-use std::fmt::{self, Debug, Display};\n-use std::{any::Any, collections::HashMap, collections::HashSet, sync::Arc};\n-\n-use aggregates::{AccumulatorFunctionImplementation, StateTypeFunction};\n-use arrow::{\n-    compute::can_cast_types,\n-    datatypes::{DataType, Field, Schema, SchemaRef},\n-};\n-\n-use crate::datasource::parquet::ParquetTable;\n-use crate::datasource::TableProvider;\n-use crate::error::{DataFusionError, Result};\n-use crate::{\n-    datasource::csv::{CsvFile, CsvReadOptions},\n-    physical_plan::udaf::AggregateUDF,\n-    scalar::ScalarValue,\n-};\n-use crate::{\n-    physical_plan::{\n-        aggregates, expressions::binary_operator_data_type, functions, udf::ScalarUDF,\n-    },\n-    sql::parser::FileType,\n-};\n-use arrow::record_batch::RecordBatch;\n-use functions::{ReturnTypeFunction, ScalarFunctionImplementation, Signature};\n-\n+mod builder;\n+mod display;\n+mod expr;\n+mod extension;\n mod operators;\n+mod plan;\n+mod registry;\n+\n+pub use builder::LogicalPlanBuilder;\n+pub use display::display_schema;\n+pub use expr::{\n+    and, array, avg, binary_expr, col, concat, count, create_udaf, create_udf,\n+    exprlist_to_fields, length, lit, max, min, sum, Expr, Literal,\n+};\n+pub use extension::UserDefinedLogicalNode;\n pub use operators::Operator;\n-\n-fn create_function_name(\n-    fun: &String,\n-    distinct: bool,\n-    args: &[Expr],\n-    input_schema: &Schema,\n-) -> Result<String> {\n-    let names: Vec<String> = args\n-        .iter()\n-        .map(|e| create_name(e, input_schema))\n-        .collect::<Result<_>>()?;\n-    let distinct_str = match distinct {\n-        true => \"DISTINCT \",\n-        false => \"\",\n-    };\n-    Ok(format!(\"{}({}{})\", fun, distinct_str, names.join(\",\")))\n-}\n-\n-/// Returns a readable name of an expression based on the input schema.\n-/// This function recursively transverses the expression for names such as \"CAST(a > 2)\".\n-fn create_name(e: &Expr, input_schema: &Schema) -> Result<String> {\n-    match e {\n-        Expr::Alias(_, name) => Ok(name.clone()),\n-        Expr::Column(name) => Ok(name.clone()),\n-        Expr::ScalarVariable(variable_names) => Ok(variable_names.join(\".\")),\n-        Expr::Literal(value) => Ok(format!(\"{:?}\", value)),\n-        Expr::BinaryExpr { left, op, right } => {\n-            let left = create_name(left, input_schema)?;\n-            let right = create_name(right, input_schema)?;\n-            Ok(format!(\"{} {:?} {}\", left, op, right))\n-        }\n-        Expr::Cast { expr, data_type } => {\n-            let expr = create_name(expr, input_schema)?;\n-            Ok(format!(\"CAST({} AS {:?})\", expr, data_type))\n-        }\n-        Expr::Not(expr) => {\n-            let expr = create_name(expr, input_schema)?;\n-            Ok(format!(\"NOT {}\", expr))\n-        }\n-        Expr::IsNull(expr) => {\n-            let expr = create_name(expr, input_schema)?;\n-            Ok(format!(\"{} IS NULL\", expr))\n-        }\n-        Expr::IsNotNull(expr) => {\n-            let expr = create_name(expr, input_schema)?;\n-            Ok(format!(\"{} IS NOT NULL\", expr))\n-        }\n-        Expr::ScalarFunction { fun, args, .. } => {\n-            create_function_name(&fun.to_string(), false, args, input_schema)\n-        }\n-        Expr::ScalarUDF { fun, args, .. } => {\n-            create_function_name(&fun.name, false, args, input_schema)\n-        }\n-        Expr::AggregateFunction {\n-            fun,\n-            distinct,\n-            args,\n-            ..\n-        } => create_function_name(&fun.to_string(), *distinct, args, input_schema),\n-        Expr::AggregateUDF { fun, args } => {\n-            let mut names = Vec::with_capacity(args.len());\n-            for e in args {\n-                names.push(create_name(e, input_schema)?);\n-            }\n-            Ok(format!(\"{}({})\", fun.name, names.join(\",\")))\n-        }\n-        other => Err(DataFusionError::NotImplemented(format!(\n-            \"Physical plan does not support logical expression {:?}\",\n-            other\n-        ))),\n-    }\n-}\n-\n-/// Create field meta-data from an expression, for use in a result set schema\n-pub fn exprlist_to_fields(expr: &[Expr], input_schema: &Schema) -> Result<Vec<Field>> {\n-    expr.iter().map(|e| e.to_field(input_schema)).collect()\n-}\n-\n-/// `Expr` is a logical expression. A logical expression is something like `1 + 1`, or `CAST(c1 AS int)`.\n-/// Logical expressions know how to compute its [arrow::datatypes::DataType] and nullability.\n-/// `Expr` is a central struct of DataFusion's query API.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # use datafusion::logical_plan::Expr;\n-/// # use datafusion::error::Result;\n-/// # fn main() -> Result<()> {\n-/// let expr = Expr::Column(\"c1\".to_string()) + Expr::Column(\"c2\".to_string());\n-/// println!(\"{:?}\", expr);\n-/// # Ok(())\n-/// # }\n-/// ```\n-#[derive(Clone)]\n-pub enum Expr {\n-    /// An expression with a specific name.\n-    Alias(Box<Expr>, String),\n-    /// A named reference to a field in a schema.\n-    Column(String),\n-    /// A named reference to a variable in a registry.\n-    ScalarVariable(Vec<String>),\n-    /// A constant value.\n-    Literal(ScalarValue),\n-    /// A binary expression such as \"age > 21\"\n-    BinaryExpr {\n-        /// Left-hand side of the expression\n-        left: Box<Expr>,\n-        /// The comparison operator\n-        op: Operator,\n-        /// Right-hand side of the expression\n-        right: Box<Expr>,\n-    },\n-    /// Parenthesized expression. E.g. `(foo > bar)` or `(1)`\n-    Nested(Box<Expr>),\n-    /// Negation of an expression. The expression's type must be a boolean to make sense.\n-    Not(Box<Expr>),\n-    /// Whether an expression is not Null. This expression is never null.\n-    IsNotNull(Box<Expr>),\n-    /// Whether an expression is Null. This expression is never null.\n-    IsNull(Box<Expr>),\n-    /// Casts the expression to a given type. This expression is guaranteed to have a fixed type.\n-    Cast {\n-        /// The expression being cast\n-        expr: Box<Expr>,\n-        /// The `DataType` the expression will yield\n-        data_type: DataType,\n-    },\n-    /// A sort expression, that can be used to sort values.\n-    Sort {\n-        /// The expression to sort on\n-        expr: Box<Expr>,\n-        /// The direction of the sort\n-        asc: bool,\n-        /// Whether to put Nulls before all other data values\n-        nulls_first: bool,\n-    },\n-    /// Represents the call of a built-in scalar function with a set of arguments.\n-    ScalarFunction {\n-        /// The function\n-        fun: functions::BuiltinScalarFunction,\n-        /// List of expressions to feed to the functions as arguments\n-        args: Vec<Expr>,\n-    },\n-    /// Represents the call of a user-defined scalar function with arguments.\n-    ScalarUDF {\n-        /// The function\n-        fun: Arc<ScalarUDF>,\n-        /// List of expressions to feed to the functions as arguments\n-        args: Vec<Expr>,\n-    },\n-    /// Represents the call of an aggregate built-in function with arguments.\n-    AggregateFunction {\n-        /// Name of the function\n-        fun: aggregates::AggregateFunction,\n-        /// List of expressions to feed to the functions as arguments\n-        args: Vec<Expr>,\n-        /// Whether this is a DISTINCT aggregation or not\n-        distinct: bool,\n-    },\n-    /// aggregate function\n-    AggregateUDF {\n-        /// The function\n-        fun: Arc<AggregateUDF>,\n-        /// List of expressions to feed to the functions as arguments\n-        args: Vec<Expr>,\n-    },\n-    /// Represents a reference to all fields in a schema.\n-    Wildcard,\n-}\n-\n-impl Expr {\n-    /// Returns the [arrow::datatypes::DataType] of the expression based on [arrow::datatypes::Schema].\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function errors when it is not possible to compute its [arrow::datatypes::DataType].\n-    /// This happens when e.g. the expression refers to a column that does not exist in the schema, or when\n-    /// the expression is incorrectly typed (e.g. `[utf8] + [bool]`).\n-    pub fn get_type(&self, schema: &Schema) -> Result<DataType> {\n-        match self {\n-            Expr::Alias(expr, _) => expr.get_type(schema),\n-            Expr::Column(name) => Ok(schema.field_with_name(name)?.data_type().clone()),\n-            Expr::ScalarVariable(_) => Ok(DataType::Utf8),\n-            Expr::Literal(l) => Ok(l.get_datatype()),\n-            Expr::Cast { data_type, .. } => Ok(data_type.clone()),\n-            Expr::ScalarUDF { fun, args } => {\n-                let data_types = args\n-                    .iter()\n-                    .map(|e| e.get_type(schema))\n-                    .collect::<Result<Vec<_>>>()?;\n-                Ok((fun.return_type)(&data_types)?.as_ref().clone())\n-            }\n-            Expr::ScalarFunction { fun, args } => {\n-                let data_types = args\n-                    .iter()\n-                    .map(|e| e.get_type(schema))\n-                    .collect::<Result<Vec<_>>>()?;\n-                functions::return_type(fun, &data_types)\n-            }\n-            Expr::AggregateFunction { fun, args, .. } => {\n-                let data_types = args\n-                    .iter()\n-                    .map(|e| e.get_type(schema))\n-                    .collect::<Result<Vec<_>>>()?;\n-                aggregates::return_type(fun, &data_types)\n-            }\n-            Expr::AggregateUDF { fun, args, .. } => {\n-                let data_types = args\n-                    .iter()\n-                    .map(|e| e.get_type(schema))\n-                    .collect::<Result<Vec<_>>>()?;\n-                Ok((fun.return_type)(&data_types)?.as_ref().clone())\n-            }\n-            Expr::Not(_) => Ok(DataType::Boolean),\n-            Expr::IsNull(_) => Ok(DataType::Boolean),\n-            Expr::IsNotNull(_) => Ok(DataType::Boolean),\n-            Expr::BinaryExpr {\n-                ref left,\n-                ref right,\n-                ref op,\n-            } => binary_operator_data_type(\n-                &left.get_type(schema)?,\n-                op,\n-                &right.get_type(schema)?,\n-            ),\n-            Expr::Sort { ref expr, .. } => expr.get_type(schema),\n-            Expr::Wildcard => Err(DataFusionError::Internal(\n-                \"Wildcard expressions are not valid in a logical query plan\".to_owned(),\n-            )),\n-            Expr::Nested(e) => e.get_type(schema),\n-        }\n-    }\n-\n-    /// Returns the nullability of the expression based on [arrow::datatypes::Schema].\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function errors when it is not possible to compute its nullability.\n-    /// This happens when the expression refers to a column that does not exist in the schema.\n-    pub fn nullable(&self, input_schema: &Schema) -> Result<bool> {\n-        match self {\n-            Expr::Alias(expr, _) => expr.nullable(input_schema),\n-            Expr::Column(name) => Ok(input_schema.field_with_name(name)?.is_nullable()),\n-            Expr::Literal(value) => Ok(value.is_null()),\n-            Expr::ScalarVariable(_) => Ok(true),\n-            Expr::Cast { expr, .. } => expr.nullable(input_schema),\n-            Expr::ScalarFunction { .. } => Ok(true),\n-            Expr::ScalarUDF { .. } => Ok(true),\n-            Expr::AggregateFunction { .. } => Ok(true),\n-            Expr::AggregateUDF { .. } => Ok(true),\n-            Expr::Not(expr) => expr.nullable(input_schema),\n-            Expr::IsNull(_) => Ok(false),\n-            Expr::IsNotNull(_) => Ok(false),\n-            Expr::BinaryExpr {\n-                ref left,\n-                ref right,\n-                ..\n-            } => Ok(left.nullable(input_schema)? || right.nullable(input_schema)?),\n-            Expr::Sort { ref expr, .. } => expr.nullable(input_schema),\n-            Expr::Nested(e) => e.nullable(input_schema),\n-            Expr::Wildcard => Err(DataFusionError::Internal(\n-                \"Wildcard expressions are not valid in a logical query plan\".to_owned(),\n-            )),\n-        }\n-    }\n-\n-    /// Returns the name of this expression based on [arrow::datatypes::Schema].\n-    ///\n-    /// This represents how a column with this expression is named when no alias is chosen\n-    pub fn name(&self, input_schema: &Schema) -> Result<String> {\n-        create_name(self, input_schema)\n-    }\n-\n-    /// Returns a [arrow::datatypes::Field] compatible with this expression.\n-    pub fn to_field(&self, input_schema: &Schema) -> Result<Field> {\n-        Ok(Field::new(\n-            &self.name(input_schema)?,\n-            self.get_type(input_schema)?,\n-            self.nullable(input_schema)?,\n-        ))\n-    }\n-\n-    /// Wraps this expression in a cast to a target [arrow::datatypes::DataType].\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function errors when it is impossible to cast the\n-    /// expression to the target [arrow::datatypes::DataType].\n-    pub fn cast_to(&self, cast_to_type: &DataType, schema: &Schema) -> Result<Expr> {\n-        let this_type = self.get_type(schema)?;\n-        if this_type == *cast_to_type {\n-            Ok(self.clone())\n-        } else if can_cast_types(&this_type, cast_to_type) {\n-            Ok(Expr::Cast {\n-                expr: Box::new(self.clone()),\n-                data_type: cast_to_type.clone(),\n-            })\n-        } else {\n-            Err(DataFusionError::Plan(format!(\n-                \"Cannot automatically convert {:?} to {:?}\",\n-                this_type, cast_to_type\n-            )))\n-        }\n-    }\n-\n-    /// Equal\n-    pub fn eq(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Eq, other.clone())\n-    }\n-\n-    /// Not equal\n-    pub fn not_eq(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::NotEq, other.clone())\n-    }\n-\n-    /// Greater than\n-    pub fn gt(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Gt, other.clone())\n-    }\n-\n-    /// Greater than or equal to\n-    pub fn gt_eq(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::GtEq, other.clone())\n-    }\n-\n-    /// Less than\n-    pub fn lt(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Lt, other.clone())\n-    }\n-\n-    /// Less than or equal to\n-    pub fn lt_eq(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::LtEq, other.clone())\n-    }\n-\n-    /// And\n-    pub fn and(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::And, other)\n-    }\n-\n-    /// Or\n-    pub fn or(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Or, other)\n-    }\n-\n-    /// Not\n-    pub fn not(&self) -> Expr {\n-        Expr::Not(Box::new(self.clone()))\n-    }\n-\n-    /// Calculate the modulus of two expressions\n-    pub fn modulus(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Modulus, other.clone())\n-    }\n-\n-    /// like (string) another expression\n-    pub fn like(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Like, other.clone())\n-    }\n-\n-    /// not like another expression\n-    pub fn not_like(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::NotLike, other.clone())\n-    }\n-\n-    /// Alias\n-    pub fn alias(&self, name: &str) -> Expr {\n-        Expr::Alias(Box::new(self.clone()), name.to_owned())\n-    }\n-\n-    /// Create a sort expression from an existing expression.\n-    ///\n-    /// ```\n-    /// # use datafusion::logical_plan::col;\n-    /// let sort_expr = col(\"foo\").sort(true, true); // SORT ASC NULLS_FIRST\n-    /// ```\n-    pub fn sort(&self, asc: bool, nulls_first: bool) -> Expr {\n-        Expr::Sort {\n-            expr: Box::new(self.clone()),\n-            asc,\n-            nulls_first,\n-        }\n-    }\n-}\n-\n-fn binary_expr(l: Expr, op: Operator, r: Expr) -> Expr {\n-    Expr::BinaryExpr {\n-        left: Box::new(l),\n-        op,\n-        right: Box::new(r),\n-    }\n-}\n-\n-/// return a new expression with a logical AND\n-pub fn and(left: &Expr, right: &Expr) -> Expr {\n-    Expr::BinaryExpr {\n-        left: Box::new(left.clone()),\n-        op: Operator::And,\n-        right: Box::new(right.clone()),\n-    }\n-}\n-\n-/// Create a column expression based on a column name\n-pub fn col(name: &str) -> Expr {\n-    Expr::Column(name.to_owned())\n-}\n-\n-/// Create an expression to represent the min() aggregate function\n-pub fn min(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Min,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Create an expression to represent the max() aggregate function\n-pub fn max(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Max,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Create an expression to represent the sum() aggregate function\n-pub fn sum(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Sum,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Create an expression to represent the avg() aggregate function\n-pub fn avg(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Avg,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Create an expression to represent the count() aggregate function\n-pub fn count(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Count,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Whether it can be represented as a literal expression\n-pub trait Literal {\n-    /// convert the value to a Literal expression\n-    fn lit(&self) -> Expr;\n-}\n-\n-impl Literal for &str {\n-    fn lit(&self) -> Expr {\n-        Expr::Literal(ScalarValue::Utf8(Some((*self).to_owned())))\n-    }\n-}\n-\n-impl Literal for String {\n-    fn lit(&self) -> Expr {\n-        Expr::Literal(ScalarValue::Utf8(Some((*self).to_owned())))\n-    }\n-}\n-\n-macro_rules! make_literal {\n-    ($TYPE:ty, $SCALAR:ident) => {\n-        #[allow(missing_docs)]\n-        impl Literal for $TYPE {\n-            fn lit(&self) -> Expr {\n-                Expr::Literal(ScalarValue::$SCALAR(Some(self.clone())))\n-            }\n-        }\n-    };\n-}\n-\n-make_literal!(bool, Boolean);\n-make_literal!(f32, Float32);\n-make_literal!(f64, Float64);\n-make_literal!(i8, Int8);\n-make_literal!(i16, Int16);\n-make_literal!(i32, Int32);\n-make_literal!(i64, Int64);\n-make_literal!(u8, UInt8);\n-make_literal!(u16, UInt16);\n-make_literal!(u32, UInt32);\n-make_literal!(u64, UInt64);\n-\n-/// Create a literal expression\n-pub fn lit<T: Literal>(n: T) -> Expr {\n-    n.lit()\n-}\n-\n-/// Create an convenience function representing a unary scalar function\n-macro_rules! unary_math_expr {\n-    ($ENUM:ident, $FUNC:ident) => {\n-        #[allow(missing_docs)]\n-        pub fn $FUNC(e: Expr) -> Expr {\n-            Expr::ScalarFunction {\n-                fun: functions::BuiltinScalarFunction::$ENUM,\n-                args: vec![e],\n-            }\n-        }\n-    };\n-}\n-\n-// generate methods for creating the supported unary math expressions\n-unary_math_expr!(Sqrt, sqrt);\n-unary_math_expr!(Sin, sin);\n-unary_math_expr!(Cos, cos);\n-unary_math_expr!(Tan, tan);\n-unary_math_expr!(Asin, asin);\n-unary_math_expr!(Acos, acos);\n-unary_math_expr!(Atan, atan);\n-unary_math_expr!(Floor, floor);\n-unary_math_expr!(Ceil, ceil);\n-unary_math_expr!(Round, round);\n-unary_math_expr!(Trunc, trunc);\n-unary_math_expr!(Abs, abs);\n-unary_math_expr!(Signum, signum);\n-unary_math_expr!(Exp, exp);\n-unary_math_expr!(Log, ln);\n-unary_math_expr!(Log2, log2);\n\nReview comment:\n       I think the issue is that I didn't then publically export them. I'll put the code back in.\r\n   \r\n   It is probably bad that we didn't have tests that failed when they got removed\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T18:00:44.537+0000",
                    "updated": "2020-11-11T18:00:44.537+0000",
                    "started": "2020-11-11T18:00:44.537+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510370",
                    "issueId": "13340004"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340004/worklog/510374",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on a change in pull request #8639:\nURL: https://github.com/apache/arrow/pull/8639#discussion_r521553659\n\n\n\n##########\nFile path: rust/datafusion/src/logical_plan/mod.rs\n##########\n@@ -21,2300 +21,21 @@\n //! Logical query plans can then be optimized and executed directly, or translated into\n //! physical query plans and executed.\n \n-use std::fmt::{self, Debug, Display};\n-use std::{any::Any, collections::HashMap, collections::HashSet, sync::Arc};\n-\n-use aggregates::{AccumulatorFunctionImplementation, StateTypeFunction};\n-use arrow::{\n-    compute::can_cast_types,\n-    datatypes::{DataType, Field, Schema, SchemaRef},\n-};\n-\n-use crate::datasource::parquet::ParquetTable;\n-use crate::datasource::TableProvider;\n-use crate::error::{DataFusionError, Result};\n-use crate::{\n-    datasource::csv::{CsvFile, CsvReadOptions},\n-    physical_plan::udaf::AggregateUDF,\n-    scalar::ScalarValue,\n-};\n-use crate::{\n-    physical_plan::{\n-        aggregates, expressions::binary_operator_data_type, functions, udf::ScalarUDF,\n-    },\n-    sql::parser::FileType,\n-};\n-use arrow::record_batch::RecordBatch;\n-use functions::{ReturnTypeFunction, ScalarFunctionImplementation, Signature};\n-\n+mod builder;\n+mod display;\n+mod expr;\n+mod extension;\n mod operators;\n+mod plan;\n+mod registry;\n+\n+pub use builder::LogicalPlanBuilder;\n+pub use display::display_schema;\n+pub use expr::{\n+    and, array, avg, binary_expr, col, concat, count, create_udaf, create_udf,\n+    exprlist_to_fields, length, lit, max, min, sum, Expr, Literal,\n+};\n+pub use extension::UserDefinedLogicalNode;\n pub use operators::Operator;\n-\n-fn create_function_name(\n-    fun: &String,\n-    distinct: bool,\n-    args: &[Expr],\n-    input_schema: &Schema,\n-) -> Result<String> {\n-    let names: Vec<String> = args\n-        .iter()\n-        .map(|e| create_name(e, input_schema))\n-        .collect::<Result<_>>()?;\n-    let distinct_str = match distinct {\n-        true => \"DISTINCT \",\n-        false => \"\",\n-    };\n-    Ok(format!(\"{}({}{})\", fun, distinct_str, names.join(\",\")))\n-}\n-\n-/// Returns a readable name of an expression based on the input schema.\n-/// This function recursively transverses the expression for names such as \"CAST(a > 2)\".\n-fn create_name(e: &Expr, input_schema: &Schema) -> Result<String> {\n-    match e {\n-        Expr::Alias(_, name) => Ok(name.clone()),\n-        Expr::Column(name) => Ok(name.clone()),\n-        Expr::ScalarVariable(variable_names) => Ok(variable_names.join(\".\")),\n-        Expr::Literal(value) => Ok(format!(\"{:?}\", value)),\n-        Expr::BinaryExpr { left, op, right } => {\n-            let left = create_name(left, input_schema)?;\n-            let right = create_name(right, input_schema)?;\n-            Ok(format!(\"{} {:?} {}\", left, op, right))\n-        }\n-        Expr::Cast { expr, data_type } => {\n-            let expr = create_name(expr, input_schema)?;\n-            Ok(format!(\"CAST({} AS {:?})\", expr, data_type))\n-        }\n-        Expr::Not(expr) => {\n-            let expr = create_name(expr, input_schema)?;\n-            Ok(format!(\"NOT {}\", expr))\n-        }\n-        Expr::IsNull(expr) => {\n-            let expr = create_name(expr, input_schema)?;\n-            Ok(format!(\"{} IS NULL\", expr))\n-        }\n-        Expr::IsNotNull(expr) => {\n-            let expr = create_name(expr, input_schema)?;\n-            Ok(format!(\"{} IS NOT NULL\", expr))\n-        }\n-        Expr::ScalarFunction { fun, args, .. } => {\n-            create_function_name(&fun.to_string(), false, args, input_schema)\n-        }\n-        Expr::ScalarUDF { fun, args, .. } => {\n-            create_function_name(&fun.name, false, args, input_schema)\n-        }\n-        Expr::AggregateFunction {\n-            fun,\n-            distinct,\n-            args,\n-            ..\n-        } => create_function_name(&fun.to_string(), *distinct, args, input_schema),\n-        Expr::AggregateUDF { fun, args } => {\n-            let mut names = Vec::with_capacity(args.len());\n-            for e in args {\n-                names.push(create_name(e, input_schema)?);\n-            }\n-            Ok(format!(\"{}({})\", fun.name, names.join(\",\")))\n-        }\n-        other => Err(DataFusionError::NotImplemented(format!(\n-            \"Physical plan does not support logical expression {:?}\",\n-            other\n-        ))),\n-    }\n-}\n-\n-/// Create field meta-data from an expression, for use in a result set schema\n-pub fn exprlist_to_fields(expr: &[Expr], input_schema: &Schema) -> Result<Vec<Field>> {\n-    expr.iter().map(|e| e.to_field(input_schema)).collect()\n-}\n-\n-/// `Expr` is a logical expression. A logical expression is something like `1 + 1`, or `CAST(c1 AS int)`.\n-/// Logical expressions know how to compute its [arrow::datatypes::DataType] and nullability.\n-/// `Expr` is a central struct of DataFusion's query API.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # use datafusion::logical_plan::Expr;\n-/// # use datafusion::error::Result;\n-/// # fn main() -> Result<()> {\n-/// let expr = Expr::Column(\"c1\".to_string()) + Expr::Column(\"c2\".to_string());\n-/// println!(\"{:?}\", expr);\n-/// # Ok(())\n-/// # }\n-/// ```\n-#[derive(Clone)]\n-pub enum Expr {\n-    /// An expression with a specific name.\n-    Alias(Box<Expr>, String),\n-    /// A named reference to a field in a schema.\n-    Column(String),\n-    /// A named reference to a variable in a registry.\n-    ScalarVariable(Vec<String>),\n-    /// A constant value.\n-    Literal(ScalarValue),\n-    /// A binary expression such as \"age > 21\"\n-    BinaryExpr {\n-        /// Left-hand side of the expression\n-        left: Box<Expr>,\n-        /// The comparison operator\n-        op: Operator,\n-        /// Right-hand side of the expression\n-        right: Box<Expr>,\n-    },\n-    /// Parenthesized expression. E.g. `(foo > bar)` or `(1)`\n-    Nested(Box<Expr>),\n-    /// Negation of an expression. The expression's type must be a boolean to make sense.\n-    Not(Box<Expr>),\n-    /// Whether an expression is not Null. This expression is never null.\n-    IsNotNull(Box<Expr>),\n-    /// Whether an expression is Null. This expression is never null.\n-    IsNull(Box<Expr>),\n-    /// Casts the expression to a given type. This expression is guaranteed to have a fixed type.\n-    Cast {\n-        /// The expression being cast\n-        expr: Box<Expr>,\n-        /// The `DataType` the expression will yield\n-        data_type: DataType,\n-    },\n-    /// A sort expression, that can be used to sort values.\n-    Sort {\n-        /// The expression to sort on\n-        expr: Box<Expr>,\n-        /// The direction of the sort\n-        asc: bool,\n-        /// Whether to put Nulls before all other data values\n-        nulls_first: bool,\n-    },\n-    /// Represents the call of a built-in scalar function with a set of arguments.\n-    ScalarFunction {\n-        /// The function\n-        fun: functions::BuiltinScalarFunction,\n-        /// List of expressions to feed to the functions as arguments\n-        args: Vec<Expr>,\n-    },\n-    /// Represents the call of a user-defined scalar function with arguments.\n-    ScalarUDF {\n-        /// The function\n-        fun: Arc<ScalarUDF>,\n-        /// List of expressions to feed to the functions as arguments\n-        args: Vec<Expr>,\n-    },\n-    /// Represents the call of an aggregate built-in function with arguments.\n-    AggregateFunction {\n-        /// Name of the function\n-        fun: aggregates::AggregateFunction,\n-        /// List of expressions to feed to the functions as arguments\n-        args: Vec<Expr>,\n-        /// Whether this is a DISTINCT aggregation or not\n-        distinct: bool,\n-    },\n-    /// aggregate function\n-    AggregateUDF {\n-        /// The function\n-        fun: Arc<AggregateUDF>,\n-        /// List of expressions to feed to the functions as arguments\n-        args: Vec<Expr>,\n-    },\n-    /// Represents a reference to all fields in a schema.\n-    Wildcard,\n-}\n-\n-impl Expr {\n-    /// Returns the [arrow::datatypes::DataType] of the expression based on [arrow::datatypes::Schema].\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function errors when it is not possible to compute its [arrow::datatypes::DataType].\n-    /// This happens when e.g. the expression refers to a column that does not exist in the schema, or when\n-    /// the expression is incorrectly typed (e.g. `[utf8] + [bool]`).\n-    pub fn get_type(&self, schema: &Schema) -> Result<DataType> {\n-        match self {\n-            Expr::Alias(expr, _) => expr.get_type(schema),\n-            Expr::Column(name) => Ok(schema.field_with_name(name)?.data_type().clone()),\n-            Expr::ScalarVariable(_) => Ok(DataType::Utf8),\n-            Expr::Literal(l) => Ok(l.get_datatype()),\n-            Expr::Cast { data_type, .. } => Ok(data_type.clone()),\n-            Expr::ScalarUDF { fun, args } => {\n-                let data_types = args\n-                    .iter()\n-                    .map(|e| e.get_type(schema))\n-                    .collect::<Result<Vec<_>>>()?;\n-                Ok((fun.return_type)(&data_types)?.as_ref().clone())\n-            }\n-            Expr::ScalarFunction { fun, args } => {\n-                let data_types = args\n-                    .iter()\n-                    .map(|e| e.get_type(schema))\n-                    .collect::<Result<Vec<_>>>()?;\n-                functions::return_type(fun, &data_types)\n-            }\n-            Expr::AggregateFunction { fun, args, .. } => {\n-                let data_types = args\n-                    .iter()\n-                    .map(|e| e.get_type(schema))\n-                    .collect::<Result<Vec<_>>>()?;\n-                aggregates::return_type(fun, &data_types)\n-            }\n-            Expr::AggregateUDF { fun, args, .. } => {\n-                let data_types = args\n-                    .iter()\n-                    .map(|e| e.get_type(schema))\n-                    .collect::<Result<Vec<_>>>()?;\n-                Ok((fun.return_type)(&data_types)?.as_ref().clone())\n-            }\n-            Expr::Not(_) => Ok(DataType::Boolean),\n-            Expr::IsNull(_) => Ok(DataType::Boolean),\n-            Expr::IsNotNull(_) => Ok(DataType::Boolean),\n-            Expr::BinaryExpr {\n-                ref left,\n-                ref right,\n-                ref op,\n-            } => binary_operator_data_type(\n-                &left.get_type(schema)?,\n-                op,\n-                &right.get_type(schema)?,\n-            ),\n-            Expr::Sort { ref expr, .. } => expr.get_type(schema),\n-            Expr::Wildcard => Err(DataFusionError::Internal(\n-                \"Wildcard expressions are not valid in a logical query plan\".to_owned(),\n-            )),\n-            Expr::Nested(e) => e.get_type(schema),\n-        }\n-    }\n-\n-    /// Returns the nullability of the expression based on [arrow::datatypes::Schema].\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function errors when it is not possible to compute its nullability.\n-    /// This happens when the expression refers to a column that does not exist in the schema.\n-    pub fn nullable(&self, input_schema: &Schema) -> Result<bool> {\n-        match self {\n-            Expr::Alias(expr, _) => expr.nullable(input_schema),\n-            Expr::Column(name) => Ok(input_schema.field_with_name(name)?.is_nullable()),\n-            Expr::Literal(value) => Ok(value.is_null()),\n-            Expr::ScalarVariable(_) => Ok(true),\n-            Expr::Cast { expr, .. } => expr.nullable(input_schema),\n-            Expr::ScalarFunction { .. } => Ok(true),\n-            Expr::ScalarUDF { .. } => Ok(true),\n-            Expr::AggregateFunction { .. } => Ok(true),\n-            Expr::AggregateUDF { .. } => Ok(true),\n-            Expr::Not(expr) => expr.nullable(input_schema),\n-            Expr::IsNull(_) => Ok(false),\n-            Expr::IsNotNull(_) => Ok(false),\n-            Expr::BinaryExpr {\n-                ref left,\n-                ref right,\n-                ..\n-            } => Ok(left.nullable(input_schema)? || right.nullable(input_schema)?),\n-            Expr::Sort { ref expr, .. } => expr.nullable(input_schema),\n-            Expr::Nested(e) => e.nullable(input_schema),\n-            Expr::Wildcard => Err(DataFusionError::Internal(\n-                \"Wildcard expressions are not valid in a logical query plan\".to_owned(),\n-            )),\n-        }\n-    }\n-\n-    /// Returns the name of this expression based on [arrow::datatypes::Schema].\n-    ///\n-    /// This represents how a column with this expression is named when no alias is chosen\n-    pub fn name(&self, input_schema: &Schema) -> Result<String> {\n-        create_name(self, input_schema)\n-    }\n-\n-    /// Returns a [arrow::datatypes::Field] compatible with this expression.\n-    pub fn to_field(&self, input_schema: &Schema) -> Result<Field> {\n-        Ok(Field::new(\n-            &self.name(input_schema)?,\n-            self.get_type(input_schema)?,\n-            self.nullable(input_schema)?,\n-        ))\n-    }\n-\n-    /// Wraps this expression in a cast to a target [arrow::datatypes::DataType].\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function errors when it is impossible to cast the\n-    /// expression to the target [arrow::datatypes::DataType].\n-    pub fn cast_to(&self, cast_to_type: &DataType, schema: &Schema) -> Result<Expr> {\n-        let this_type = self.get_type(schema)?;\n-        if this_type == *cast_to_type {\n-            Ok(self.clone())\n-        } else if can_cast_types(&this_type, cast_to_type) {\n-            Ok(Expr::Cast {\n-                expr: Box::new(self.clone()),\n-                data_type: cast_to_type.clone(),\n-            })\n-        } else {\n-            Err(DataFusionError::Plan(format!(\n-                \"Cannot automatically convert {:?} to {:?}\",\n-                this_type, cast_to_type\n-            )))\n-        }\n-    }\n-\n-    /// Equal\n-    pub fn eq(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Eq, other.clone())\n-    }\n-\n-    /// Not equal\n-    pub fn not_eq(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::NotEq, other.clone())\n-    }\n-\n-    /// Greater than\n-    pub fn gt(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Gt, other.clone())\n-    }\n-\n-    /// Greater than or equal to\n-    pub fn gt_eq(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::GtEq, other.clone())\n-    }\n-\n-    /// Less than\n-    pub fn lt(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Lt, other.clone())\n-    }\n-\n-    /// Less than or equal to\n-    pub fn lt_eq(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::LtEq, other.clone())\n-    }\n-\n-    /// And\n-    pub fn and(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::And, other)\n-    }\n-\n-    /// Or\n-    pub fn or(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Or, other)\n-    }\n-\n-    /// Not\n-    pub fn not(&self) -> Expr {\n-        Expr::Not(Box::new(self.clone()))\n-    }\n-\n-    /// Calculate the modulus of two expressions\n-    pub fn modulus(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Modulus, other.clone())\n-    }\n-\n-    /// like (string) another expression\n-    pub fn like(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::Like, other.clone())\n-    }\n-\n-    /// not like another expression\n-    pub fn not_like(&self, other: Expr) -> Expr {\n-        binary_expr(self.clone(), Operator::NotLike, other.clone())\n-    }\n-\n-    /// Alias\n-    pub fn alias(&self, name: &str) -> Expr {\n-        Expr::Alias(Box::new(self.clone()), name.to_owned())\n-    }\n-\n-    /// Create a sort expression from an existing expression.\n-    ///\n-    /// ```\n-    /// # use datafusion::logical_plan::col;\n-    /// let sort_expr = col(\"foo\").sort(true, true); // SORT ASC NULLS_FIRST\n-    /// ```\n-    pub fn sort(&self, asc: bool, nulls_first: bool) -> Expr {\n-        Expr::Sort {\n-            expr: Box::new(self.clone()),\n-            asc,\n-            nulls_first,\n-        }\n-    }\n-}\n-\n-fn binary_expr(l: Expr, op: Operator, r: Expr) -> Expr {\n-    Expr::BinaryExpr {\n-        left: Box::new(l),\n-        op,\n-        right: Box::new(r),\n-    }\n-}\n-\n-/// return a new expression with a logical AND\n-pub fn and(left: &Expr, right: &Expr) -> Expr {\n-    Expr::BinaryExpr {\n-        left: Box::new(left.clone()),\n-        op: Operator::And,\n-        right: Box::new(right.clone()),\n-    }\n-}\n-\n-/// Create a column expression based on a column name\n-pub fn col(name: &str) -> Expr {\n-    Expr::Column(name.to_owned())\n-}\n-\n-/// Create an expression to represent the min() aggregate function\n-pub fn min(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Min,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Create an expression to represent the max() aggregate function\n-pub fn max(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Max,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Create an expression to represent the sum() aggregate function\n-pub fn sum(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Sum,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Create an expression to represent the avg() aggregate function\n-pub fn avg(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Avg,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Create an expression to represent the count() aggregate function\n-pub fn count(expr: Expr) -> Expr {\n-    Expr::AggregateFunction {\n-        fun: aggregates::AggregateFunction::Count,\n-        distinct: false,\n-        args: vec![expr],\n-    }\n-}\n-\n-/// Whether it can be represented as a literal expression\n-pub trait Literal {\n-    /// convert the value to a Literal expression\n-    fn lit(&self) -> Expr;\n-}\n-\n-impl Literal for &str {\n-    fn lit(&self) -> Expr {\n-        Expr::Literal(ScalarValue::Utf8(Some((*self).to_owned())))\n-    }\n-}\n-\n-impl Literal for String {\n-    fn lit(&self) -> Expr {\n-        Expr::Literal(ScalarValue::Utf8(Some((*self).to_owned())))\n-    }\n-}\n-\n-macro_rules! make_literal {\n-    ($TYPE:ty, $SCALAR:ident) => {\n-        #[allow(missing_docs)]\n-        impl Literal for $TYPE {\n-            fn lit(&self) -> Expr {\n-                Expr::Literal(ScalarValue::$SCALAR(Some(self.clone())))\n-            }\n-        }\n-    };\n-}\n-\n-make_literal!(bool, Boolean);\n-make_literal!(f32, Float32);\n-make_literal!(f64, Float64);\n-make_literal!(i8, Int8);\n-make_literal!(i16, Int16);\n-make_literal!(i32, Int32);\n-make_literal!(i64, Int64);\n-make_literal!(u8, UInt8);\n-make_literal!(u16, UInt16);\n-make_literal!(u32, UInt32);\n-make_literal!(u64, UInt64);\n-\n-/// Create a literal expression\n-pub fn lit<T: Literal>(n: T) -> Expr {\n-    n.lit()\n-}\n-\n-/// Create an convenience function representing a unary scalar function\n-macro_rules! unary_math_expr {\n-    ($ENUM:ident, $FUNC:ident) => {\n-        #[allow(missing_docs)]\n-        pub fn $FUNC(e: Expr) -> Expr {\n-            Expr::ScalarFunction {\n-                fun: functions::BuiltinScalarFunction::$ENUM,\n-                args: vec![e],\n-            }\n-        }\n-    };\n-}\n-\n-// generate methods for creating the supported unary math expressions\n-unary_math_expr!(Sqrt, sqrt);\n-unary_math_expr!(Sin, sin);\n-unary_math_expr!(Cos, cos);\n-unary_math_expr!(Tan, tan);\n-unary_math_expr!(Asin, asin);\n-unary_math_expr!(Acos, acos);\n-unary_math_expr!(Atan, atan);\n-unary_math_expr!(Floor, floor);\n-unary_math_expr!(Ceil, ceil);\n-unary_math_expr!(Round, round);\n-unary_math_expr!(Trunc, trunc);\n-unary_math_expr!(Abs, abs);\n-unary_math_expr!(Signum, signum);\n-unary_math_expr!(Exp, exp);\n-unary_math_expr!(Log, ln);\n-unary_math_expr!(Log2, log2);\n\nReview comment:\n       Code restored in https://github.com/apache/arrow/pull/8639/commits/ed05ee56cd99d8e22c5f0f3aec8ecddcd22bd1e0 and publically `use`d in https://github.com/apache/arrow/pull/8639/commits/60cd9fe463bb79db24f221a354a1f3334aa577d7\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T18:23:13.372+0000",
                    "updated": "2020-11-11T18:23:13.372+0000",
                    "started": "2020-11-11T18:23:13.371+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510374",
                    "issueId": "13340004"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340004/worklog/510596",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao closed pull request #8639:\nURL: https://github.com/apache/arrow/pull/8639\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-12T05:15:57.767+0000",
                    "updated": "2020-11-12T05:15:57.767+0000",
                    "started": "2020-11-12T05:15:57.766+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510596",
                    "issueId": "13340004"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 6000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@3ced588a[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2dddd974[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@16c62bb6[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@55134663[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@63321b20[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@6b9235ff[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4c2e38a0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@3414f18[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7059bf4b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@a9e5172[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@374883b9[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@3e7833c7[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 6000,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Nov 12 05:15:58 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-11-12T05:15:58.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10559/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-11-11T14:47:08.000+0000",
        "updated": "2020-11-12T05:15:58.000+0000",
        "timeoriginalestimate": null,
        "description": "The module has gotten fairly large and so refactoring it into smaller chunks will improve readability  -- as suggested by Jorge https://github.com/apache/arrow/pull/8619#pullrequestreview-527391221\r\n",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "1h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 6000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust] [DataFusion] Break up logical_plan/mod.rs into smaller modules",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340004/comment/17230357",
                    "id": "17230357",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
                        "name": "jorgecarleitao",
                        "key": "jorgecarleitao",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
                        },
                        "displayName": "Jorge Leit\u00e3o",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Issue resolved by pull request 8639\n[https://github.com/apache/arrow/pull/8639]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
                        "name": "jorgecarleitao",
                        "key": "jorgecarleitao",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
                        },
                        "displayName": "Jorge Leit\u00e3o",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2020-11-12T05:15:58.641+0000",
                    "updated": "2020-11-12T05:15:58.641+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0khfs:",
        "customfield_12314139": null
    }
}