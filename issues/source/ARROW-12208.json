{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13369599",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599",
    "key": "ARROW-12208",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349493",
                "id": "12349493",
                "description": "",
                "name": "4.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-04-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12613643",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12613643",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13372344",
                    "key": "ARROW-12379",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13372344",
                    "fields": {
                        "summary": "[C++][CI] Thread sanitizer failure in SerialExecutor",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
                            "id": "1",
                            "description": "A problem which impairs or prevents the functions of the product.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
                            "name": "Bug",
                            "subtask": false,
                            "avatarId": 21133
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 28200,
            "total": 28200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 28200,
            "total": 28200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12208/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 47,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/worklog/576874",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace opened a new pull request #9892:\nURL: https://github.com/apache/arrow/pull/9892\n\n\n   Added a serial executor which can run async code serially without needing to create threads.  In addition, modifies the Scanner::ToTable and FileSystemDataset::Write to execute serially.  Scanner::Scan is still non-serial but I think this is OK.  The I/O thread pool is still being used however.  To truly remove all instances of std::thread we'd need to change the I/O context to use the serial executor but let's see if this makes R happy enough first.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-05T14:31:58.216+0000",
                    "updated": "2021-04-05T14:31:58.216+0000",
                    "started": "2021-04-05T14:31:58.216+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "576874",
                    "issueId": "13369599"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/worklog/576876",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on pull request #9892:\nURL: https://github.com/apache/arrow/pull/9892#issuecomment-813425806\n\n\n   @pitrou I initially wanted to replace the IOContext's executor with the serial executor as well but I wasn't sure what the best way to do that would be.  For example, I could create a new IOContext with the same pool & stop token but a different executor and pass that down but I wasn't sure if that would be correct.\r\n   \r\n   I think a simplified version of my question is \"does the IOContext come from the calling user (via options) or from the filesystem?\"\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-05T14:34:39.183+0000",
                    "updated": "2021-04-05T14:34:39.183+0000",
                    "started": "2021-04-05T14:34:39.183+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "576876",
                    "issueId": "13369599"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/worklog/576878",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #9892:\nURL: https://github.com/apache/arrow/pull/9892#issuecomment-813426833\n\n\n   > I think a simplified version of my question is \"does the IOContext come from the calling user (via options) or from the filesystem?\"\r\n   \r\n   Indeed, I think we should clarify this. I would say: by default, the default IOContext comes from the filesystem but can be overriden by the user. But we may need to modify the IOContext API slightly so that `executor = nullptr` is taken to mean \"take the default\".\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-05T14:36:35.309+0000",
                    "updated": "2021-04-05T14:36:35.309+0000",
                    "started": "2021-04-05T14:36:35.309+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "576878",
                    "issueId": "13369599"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/worklog/576883",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on pull request #9892:\nURL: https://github.com/apache/arrow/pull/9892#issuecomment-813430502\n\n\n   Ok, that makes sense.  I think that RTools is happy enough with the I/O threads (they have always existed anyways) so I'll defer that work for the future.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-05T14:43:27.398+0000",
                    "updated": "2021-04-05T14:43:27.398+0000",
                    "started": "2021-04-05T14:43:27.398+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "576883",
                    "issueId": "13369599"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/worklog/576972",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #9892:\nURL: https://github.com/apache/arrow/pull/9892#issuecomment-813515705\n\n\n   https://issues.apache.org/jira/browse/ARROW-12208\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-05T17:20:07.530+0000",
                    "updated": "2021-04-05T17:20:07.530+0000",
                    "started": "2021-04-05T17:20:07.529+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "576972",
                    "issueId": "13369599"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/worklog/577295",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on pull request #9892:\nURL: https://github.com/apache/arrow/pull/9892#issuecomment-813792443\n\n\n   JNI check seems unrelated.  Please review.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-06T03:19:35.257+0000",
                    "updated": "2021-04-06T03:19:35.257+0000",
                    "started": "2021-04-06T03:19:35.257+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "577295",
                    "issueId": "13369599"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/worklog/577598",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #9892:\nURL: https://github.com/apache/arrow/pull/9892#discussion_r607843734\n\n\n\n##########\nFile path: cpp/src/arrow/util/thread_pool.h\n##########\n@@ -262,5 +321,40 @@ class ARROW_EXPORT ThreadPool : public Executor {\n // Return the process-global thread pool for CPU-bound tasks.\n ARROW_EXPORT ThreadPool* GetCpuThreadPool();\n \n+/// \\brief Runs a potentially async operation serially\n+///\n+/// This means that all CPU tasks spawned by the operation will run on the thread calling\n+/// this method and the future will be completed before this call finishes.\n+template <typename T = arrow::detail::Empty>\n+Result<T> RunSerially(FnOnce<Future<T>(Executor*)> get_future) {\n+  struct InnerCallback {\n+    void operator()(const Result<T> res) { std::move(finish_signal)(std::move(res)); }\n+    SerialExecutor::FinishSignal<T> finish_signal;\n+  };\n+  struct OuterCallback {\n+    Status operator()(Executor* executor, SerialExecutor::FinishSignal<T> finish_signal) {\n+      auto fut = std::move(get_future)(executor);\n+      fut.AddCallback(InnerCallback{std::move(finish_signal)});\n+      return Status::OK();\n+    }\n+    FnOnce<Future<T>(Executor*)> get_future;\n+  };\n+  return SerialExecutor::RunInSerialExecutor<T>(OuterCallback{std::move(get_future)});\n+}\n+\n+/// \\brief Potentially runs an async operation serially if use_threads is true\n+/// \\see RunSerially\n+///\n+/// If `use_threads` is false then the operation is run normally but this method will\n+/// still block the calling thread until the operation has completed.\n\nReview comment:\n       ```suggestion\r\n   /// \\brief Potentially runs an async operation serially if use_threads is false\r\n   /// \\see RunSerially\r\n   ///\r\n   /// If `use_threads` is true then the operation is run normally but this method will\r\n   /// still block the calling thread until the operation has completed.\r\n   ```\r\n   Did you mean this?\n\n##########\nFile path: cpp/src/arrow/util/thread_pool_test.cc\n##########\n@@ -123,6 +123,125 @@ class AddTester {\n   std::vector<int> outs_;\n };\n \n+template <typename T = arrow::detail::Empty>\n+struct TerminalCallback {\n+  void operator()() {\n+    auto result = std::move(callback)();\n+    std::move(finish_signal)(result);\n+  }\n+\n+  FnOnce<Result<T>()> callback;\n+  SerialExecutor::FinishSignal<T> finish_signal;\n+};\n+\n+template <>\n+struct TerminalCallback<arrow::detail::Empty> {\n+  void operator()() {\n+    auto st = std::move(callback)();\n+    if (!st.ok()) {\n+      std::move(finish_signal)(st);\n+    } else {\n+      std::move(finish_signal)(arrow::detail::Empty());\n+    }\n+  }\n+\n+  FnOnce<Status()> callback;\n+  SerialExecutor::FinishSignal<> finish_signal;\n+};\n+\n+TEST(TestSerialExecutor, Create) {\n+  bool task_ran = false;\n+  SerialExecutor::Scheduler<> task = [&](Executor* executor,\n+                                         SerialExecutor::FinishSignal<> finish_signal) {\n+    EXPECT_TRUE(executor != nullptr);\n+    task_ran = true;\n+    std::move(finish_signal)(arrow::detail::Empty());\n+    return Status::OK();\n+  };\n+  ASSERT_OK(SerialExecutor::RunInSerialExecutor(std::move(task)));\n+  EXPECT_TRUE(task_ran);\n+}\n+\n+TEST(TestSerialExecutor, SpawnNested) {\n+  bool nested_ran = false;\n+  SerialExecutor::Scheduler<> scheduler =\n+      [&](Executor* executor, SerialExecutor::FinishSignal<> finish_signal) {\n+        return executor->Spawn(TerminalCallback<>{[&] {\n+                                                    nested_ran = true;\n+                                                    return Status::OK();\n+                                                  },\n+                                                  std::move(finish_signal)});\n+      };\n+  ASSERT_OK(SerialExecutor::RunInSerialExecutor(std::move(scheduler)));\n+  EXPECT_TRUE(nested_ran);\n+}\n+\n+TEST(TestSerialExecutor, WithResult) {\n+  SerialExecutor::Scheduler<int> scheduler =\n+      [&](Executor* executor, SerialExecutor::FinishSignal<int> finish_signal) {\n+        return executor->Spawn(\n+            TerminalCallback<int>{[] { return 42; }, std::move(finish_signal)});\n+      };\n+  ASSERT_OK_AND_EQ(42, SerialExecutor::RunInSerialExecutor(std::move(scheduler)));\n+}\n+\n+TEST(TestSerialExecutor, StopToken) {\n+  bool nested_ran = false;\n+  StopSource stop_source;\n+  SerialExecutor::Scheduler<> scheduler =\n+      [&](Executor* executor, SerialExecutor::FinishSignal<> finish_signal) {\n+        RETURN_NOT_OK(executor->Spawn([&] { nested_ran = true; }, stop_source.token()));\n+        RETURN_NOT_OK(executor->Spawn(\n+            TerminalCallback<>{[&] { return Status::OK(); }, std::move(finish_signal)}));\n+        stop_source.RequestStop(Status::Invalid(\"XYZ\"));\n+        return Status::OK();\n+      };\n+  ASSERT_OK(SerialExecutor::RunInSerialExecutor(std::move(scheduler)));\n+  EXPECT_FALSE(nested_ran);\n+}\n+\n+TEST(TestSerialExecutor, ContinueAfterExternal) {\n+  bool continuation_ran = false;\n+  EXPECT_OK_AND_ASSIGN(auto mockIoPool, ThreadPool::Make(1));\n\nReview comment:\n       style nit: mock_io_pool\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-06T13:45:55.551+0000",
                    "updated": "2021-04-06T13:45:55.551+0000",
                    "started": "2021-04-06T13:45:55.551+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "577598",
                    "issueId": "13369599"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/worklog/577661",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #9892:\nURL: https://github.com/apache/arrow/pull/9892#discussion_r607892026\n\n\n\n##########\nFile path: cpp/src/arrow/util/thread_pool.cc\n##########\n@@ -44,6 +44,63 @@ struct Task {\n \n }  // namespace\n \n+struct SerialExecutor::State {\n+  std::queue<Task> task_queue;\n+  std::mutex mutex;\n+  std::condition_variable wait_for_tasks;\n+};\n+\n+SerialExecutor::SerialExecutor() : state_(new State()) {}\n+SerialExecutor::~SerialExecutor() {}\n+\n+Status SerialExecutor::SpawnReal(TaskHints hints, FnOnce<void()> task,\n+                                 StopToken stop_token, StopCallback&& stop_callback) {\n+  // The serial task queue is truly serial (no mutex needed) but SpawnReal may be called\n+  // from external threads (e.g. when transferring back from blocking I/O threads) so a\n+  // mutex is needed\n+  {\n+    std::lock_guard<std::mutex> lg(state_->mutex);\n+    state_->task_queue.push(\n+        Task{std::move(task), std::move(stop_token), std::move(stop_callback)});\n+  }\n+  state_->wait_for_tasks.notify_one();\n+  return Status::OK();\n+}\n+\n+void SerialExecutor::MarkFinished(bool& finished) {\n\nReview comment:\n       `bool* finished`, since it's mutable.\n\n##########\nFile path: cpp/src/arrow/util/thread_pool.h\n##########\n@@ -189,6 +190,64 @@ class ARROW_EXPORT Executor {\n                            StopCallback&&) = 0;\n };\n \n+/// \\brief An executor implementation that runs all tasks on a single thread using an\n+/// event loop.\n+///\n+/// Note: Any sort of nested parallelism will deadlock this executor.  Blocking waits are\n+/// fine but if one task needs to wait for another task it must be expressed as an\n+/// asynchronous continuation.\n+class ARROW_EXPORT SerialExecutor : public Executor {\n+ public:\n+  template <typename T = ::arrow::detail::Empty>\n+  using FinishSignal = internal::FnOnce<void(const Result<T>&)>;\n+  template <typename T = ::arrow::detail::Empty>\n+  using Scheduler = internal::FnOnce<Status(Executor*, FinishSignal<T>)>;\n\nReview comment:\n       \"Scheduler\" is confusing. \"TopLevelTask\" perhaps?\n\n##########\nFile path: cpp/src/arrow/dataset/scanner_internal.h\n##########\n@@ -29,10 +29,12 @@\n #include \"arrow/dataset/partition.h\"\n #include \"arrow/dataset/scanner.h\"\n #include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n\nReview comment:\n       Is this required?\n\n##########\nFile path: cpp/src/arrow/util/thread_pool_test.cc\n##########\n@@ -123,6 +123,125 @@ class AddTester {\n   std::vector<int> outs_;\n };\n \n+template <typename T = arrow::detail::Empty>\n+struct TerminalCallback {\n+  void operator()() {\n+    auto result = std::move(callback)();\n+    std::move(finish_signal)(result);\n+  }\n+\n+  FnOnce<Result<T>()> callback;\n+  SerialExecutor::FinishSignal<T> finish_signal;\n+};\n+\n+template <>\n+struct TerminalCallback<arrow::detail::Empty> {\n+  void operator()() {\n+    auto st = std::move(callback)();\n+    if (!st.ok()) {\n+      std::move(finish_signal)(st);\n+    } else {\n+      std::move(finish_signal)(arrow::detail::Empty());\n+    }\n+  }\n+\n+  FnOnce<Status()> callback;\n+  SerialExecutor::FinishSignal<> finish_signal;\n+};\n+\n+TEST(TestSerialExecutor, Create) {\n+  bool task_ran = false;\n+  SerialExecutor::Scheduler<> task = [&](Executor* executor,\n+                                         SerialExecutor::FinishSignal<> finish_signal) {\n+    EXPECT_TRUE(executor != nullptr);\n+    task_ran = true;\n+    std::move(finish_signal)(arrow::detail::Empty());\n+    return Status::OK();\n+  };\n+  ASSERT_OK(SerialExecutor::RunInSerialExecutor(std::move(task)));\n+  EXPECT_TRUE(task_ran);\n+}\n+\n+TEST(TestSerialExecutor, SpawnNested) {\n+  bool nested_ran = false;\n+  SerialExecutor::Scheduler<> scheduler =\n+      [&](Executor* executor, SerialExecutor::FinishSignal<> finish_signal) {\n+        return executor->Spawn(TerminalCallback<>{[&] {\n+                                                    nested_ran = true;\n+                                                    return Status::OK();\n+                                                  },\n+                                                  std::move(finish_signal)});\n+      };\n+  ASSERT_OK(SerialExecutor::RunInSerialExecutor(std::move(scheduler)));\n+  EXPECT_TRUE(nested_ran);\n+}\n+\n+TEST(TestSerialExecutor, WithResult) {\n+  SerialExecutor::Scheduler<int> scheduler =\n+      [&](Executor* executor, SerialExecutor::FinishSignal<int> finish_signal) {\n+        return executor->Spawn(\n+            TerminalCallback<int>{[] { return 42; }, std::move(finish_signal)});\n+      };\n+  ASSERT_OK_AND_EQ(42, SerialExecutor::RunInSerialExecutor(std::move(scheduler)));\n+}\n+\n+TEST(TestSerialExecutor, StopToken) {\n+  bool nested_ran = false;\n+  StopSource stop_source;\n+  SerialExecutor::Scheduler<> scheduler =\n+      [&](Executor* executor, SerialExecutor::FinishSignal<> finish_signal) {\n+        RETURN_NOT_OK(executor->Spawn([&] { nested_ran = true; }, stop_source.token()));\n+        RETURN_NOT_OK(executor->Spawn(\n+            TerminalCallback<>{[&] { return Status::OK(); }, std::move(finish_signal)}));\n+        stop_source.RequestStop(Status::Invalid(\"XYZ\"));\n+        return Status::OK();\n+      };\n+  ASSERT_OK(SerialExecutor::RunInSerialExecutor(std::move(scheduler)));\n+  EXPECT_FALSE(nested_ran);\n+}\n+\n+TEST(TestSerialExecutor, ContinueAfterExternal) {\n+  bool continuation_ran = false;\n+  EXPECT_OK_AND_ASSIGN(auto mockIoPool, ThreadPool::Make(1));\n+  SerialExecutor::Scheduler<> scheduler =\n+      [&](Executor* executor, SerialExecutor::FinishSignal<> finish_signal) {\n+        struct Callback {\n+          void operator()(const Result<arrow::detail::Empty>& emp) {\n+            continuation_ran = true;\n+            std::move(finish_signal)(emp);\n+          }\n+          SerialExecutor::FinishSignal<> finish_signal;\n+          bool& continuation_ran;\n+        };\n+        executor\n+            ->Transfer(DeferNotOk(mockIoPool->Submit([&] {\n+              SleepABit();\n+              return Status::OK();\n+            })))\n+            .AddCallback(Callback{std::move(finish_signal), continuation_ran});\n+        return Status::OK();\n+      };\n+  ASSERT_OK(SerialExecutor::RunInSerialExecutor(std::move(scheduler)));\n+  EXPECT_TRUE(continuation_ran);\n+}\n+\n+TEST(TestSerialExecutor, SchedulerAbort) {\n+  SerialExecutor::Scheduler<> scheduler =\n+      [&](Executor* executor, SerialExecutor::FinishSignal<> finish_signal) {\n+        return Status::Invalid(\"XYZ\");\n+      };\n+  ASSERT_RAISES(Invalid, SerialExecutor::RunInSerialExecutor(std::move(scheduler)));\n+}\n+\n+TEST(TestSerialExecutor, PropagatedError) {\n+  SerialExecutor::Scheduler<> scheduler =\n+      [&](Executor* executor, SerialExecutor::FinishSignal<> finish_signal) {\n+        std::move(finish_signal)(Status::Invalid(\"XYZ\"));\n+        return Status::OK();\n+      };\n+  ASSERT_RAISES(Invalid, SerialExecutor::RunInSerialExecutor(std::move(scheduler)));\n\nReview comment:\n       Hmm... instead of testing `RunInSerialExecutor` explicitly, can all these tests call `RunSynchronously`, so that you can run the same tests for different `use_threads`?\n\n##########\nFile path: cpp/src/arrow/util/thread_pool.h\n##########\n@@ -262,5 +321,40 @@ class ARROW_EXPORT ThreadPool : public Executor {\n // Return the process-global thread pool for CPU-bound tasks.\n ARROW_EXPORT ThreadPool* GetCpuThreadPool();\n \n+/// \\brief Runs a potentially async operation serially\n+///\n+/// This means that all CPU tasks spawned by the operation will run on the thread calling\n+/// this method and the future will be completed before this call finishes.\n+template <typename T = arrow::detail::Empty>\n+Result<T> RunSerially(FnOnce<Future<T>(Executor*)> get_future) {\n+  struct InnerCallback {\n+    void operator()(const Result<T> res) { std::move(finish_signal)(std::move(res)); }\n+    SerialExecutor::FinishSignal<T> finish_signal;\n+  };\n+  struct OuterCallback {\n+    Status operator()(Executor* executor, SerialExecutor::FinishSignal<T> finish_signal) {\n+      auto fut = std::move(get_future)(executor);\n+      fut.AddCallback(InnerCallback{std::move(finish_signal)});\n+      return Status::OK();\n+    }\n+    FnOnce<Future<T>(Executor*)> get_future;\n+  };\n+  return SerialExecutor::RunInSerialExecutor<T>(OuterCallback{std::move(get_future)});\n+}\n+\n+/// \\brief Potentially runs an async operation serially if use_threads is true\n\nReview comment:\n       This isn't very descriptive. Please something such as:\r\n   ```c++\r\n   /// \\brief Spawn a future and any dependent tasks on an executor, wait for completion\r\n   ///\r\n   /// If `use_threads` is true, the global CPU executor is used.\r\n   /// If `use_threads` is false, a temporary SerialExecutor is used.\r\n   /// `get_future` is called (from this thread) with the chosen executor and must\r\n   /// return a future that will eventually finish. This function returns once the\r\n   /// future has finished.\r\n   ```\r\n   \n\n##########\nFile path: cpp/src/arrow/util/thread_pool.h\n##########\n@@ -262,5 +321,40 @@ class ARROW_EXPORT ThreadPool : public Executor {\n // Return the process-global thread pool for CPU-bound tasks.\n ARROW_EXPORT ThreadPool* GetCpuThreadPool();\n \n+/// \\brief Runs a potentially async operation serially\n\nReview comment:\n       \"Run\"\n\n##########\nFile path: cpp/src/arrow/util/thread_pool.h\n##########\n@@ -189,6 +190,64 @@ class ARROW_EXPORT Executor {\n                            StopCallback&&) = 0;\n };\n \n+/// \\brief An executor implementation that runs all tasks on a single thread using an\n+/// event loop.\n+///\n+/// Note: Any sort of nested parallelism will deadlock this executor.  Blocking waits are\n\nReview comment:\n       This is true of a parallel executor as well, no? \n\n##########\nFile path: cpp/src/arrow/dataset/file_csv.cc\n##########\n@@ -166,14 +174,15 @@ class CsvScanTask : public ScanTask {\n         source_(fragment->source()) {}\n \n   Result<RecordBatchIterator> Execute() override {\n-    ARROW_ASSIGN_OR_RAISE(auto gen, ExecuteAsync());\n+    ARROW_ASSIGN_OR_RAISE(auto gen, ExecuteAsync(internal::GetCpuThreadPool()));\n\nReview comment:\n       Shouldn't you lookup `ScanOptions::use_threads`? Or am I missing something?\n\n##########\nFile path: cpp/src/arrow/util/thread_pool.h\n##########\n@@ -262,5 +321,40 @@ class ARROW_EXPORT ThreadPool : public Executor {\n // Return the process-global thread pool for CPU-bound tasks.\n ARROW_EXPORT ThreadPool* GetCpuThreadPool();\n \n+/// \\brief Runs a potentially async operation serially\n+///\n+/// This means that all CPU tasks spawned by the operation will run on the thread calling\n+/// this method and the future will be completed before this call finishes.\n+template <typename T = arrow::detail::Empty>\n+Result<T> RunSerially(FnOnce<Future<T>(Executor*)> get_future) {\n+  struct InnerCallback {\n+    void operator()(const Result<T> res) { std::move(finish_signal)(std::move(res)); }\n+    SerialExecutor::FinishSignal<T> finish_signal;\n+  };\n+  struct OuterCallback {\n+    Status operator()(Executor* executor, SerialExecutor::FinishSignal<T> finish_signal) {\n+      auto fut = std::move(get_future)(executor);\n+      fut.AddCallback(InnerCallback{std::move(finish_signal)});\n+      return Status::OK();\n+    }\n+    FnOnce<Future<T>(Executor*)> get_future;\n+  };\n+  return SerialExecutor::RunInSerialExecutor<T>(OuterCallback{std::move(get_future)});\n+}\n+\n+/// \\brief Potentially runs an async operation serially if use_threads is true\n+/// \\see RunSerially\n+///\n+/// If `use_threads` is false then the operation is run normally but this method will\n+/// still block the calling thread until the operation has completed.\n+template <typename T>\n+Result<T> RunSynchronously(FnOnce<Future<T>(Executor*)> get_future, bool use_threads) {\n\nReview comment:\n       Why not return a `Future<T>` instead? It seems that would at least remove the `FinishSignal` complication.\n\n##########\nFile path: cpp/src/arrow/util/thread_pool_test.cc\n##########\n@@ -123,6 +123,125 @@ class AddTester {\n   std::vector<int> outs_;\n };\n \n+template <typename T = arrow::detail::Empty>\n\nReview comment:\n       Add comments for this?\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.h\n##########\n@@ -32,6 +32,7 @@\n #include \"arrow/memory_pool.h\"\n #include \"arrow/type_fwd.h\"\n #include \"arrow/util/async_generator.h\"\n+#include \"arrow/util/thread_pool.h\"\n\nReview comment:\n       No need to, `internal::Executor` is already declared in `arrow/util/type_fwd.h`.\r\n   Also, can you try to remove `async_generator.h`?\n\n##########\nFile path: cpp/src/arrow/util/thread_pool_test.cc\n##########\n@@ -123,6 +123,125 @@ class AddTester {\n   std::vector<int> outs_;\n };\n \n+template <typename T = arrow::detail::Empty>\n+struct TerminalCallback {\n+  void operator()() {\n+    auto result = std::move(callback)();\n+    std::move(finish_signal)(result);\n+  }\n+\n+  FnOnce<Result<T>()> callback;\n+  SerialExecutor::FinishSignal<T> finish_signal;\n+};\n+\n+template <>\n+struct TerminalCallback<arrow::detail::Empty> {\n+  void operator()() {\n+    auto st = std::move(callback)();\n+    if (!st.ok()) {\n+      std::move(finish_signal)(st);\n+    } else {\n+      std::move(finish_signal)(arrow::detail::Empty());\n+    }\n+  }\n+\n+  FnOnce<Status()> callback;\n+  SerialExecutor::FinishSignal<> finish_signal;\n+};\n+\n+TEST(TestSerialExecutor, Create) {\n+  bool task_ran = false;\n+  SerialExecutor::Scheduler<> task = [&](Executor* executor,\n+                                         SerialExecutor::FinishSignal<> finish_signal) {\n+    EXPECT_TRUE(executor != nullptr);\n\nReview comment:\n       `ASSERT_NE`\n\n##########\nFile path: cpp/src/arrow/util/thread_pool.cc\n##########\n@@ -44,6 +44,63 @@ struct Task {\n \n }  // namespace\n \n+struct SerialExecutor::State {\n+  std::queue<Task> task_queue;\n+  std::mutex mutex;\n+  std::condition_variable wait_for_tasks;\n+};\n+\n+SerialExecutor::SerialExecutor() : state_(new State()) {}\n+SerialExecutor::~SerialExecutor() {}\n+\n+Status SerialExecutor::SpawnReal(TaskHints hints, FnOnce<void()> task,\n+                                 StopToken stop_token, StopCallback&& stop_callback) {\n+  // The serial task queue is truly serial (no mutex needed) but SpawnReal may be called\n+  // from external threads (e.g. when transferring back from blocking I/O threads) so a\n+  // mutex is needed\n+  {\n+    std::lock_guard<std::mutex> lg(state_->mutex);\n+    state_->task_queue.push(\n+        Task{std::move(task), std::move(stop_token), std::move(stop_callback)});\n+  }\n+  state_->wait_for_tasks.notify_one();\n+  return Status::OK();\n+}\n+\n+void SerialExecutor::MarkFinished(bool& finished) {\n+  {\n+    std::lock_guard<std::mutex> lk(state_->mutex);\n+    finished = true;\n+  }\n+  state_->wait_for_tasks.notify_one();\n+}\n+\n+void SerialExecutor::RunLoop(const bool& finished) {\n+  std::unique_lock<std::mutex> lk(state_->mutex);\n+\n+  while (!finished) {\n+    while (!state_->task_queue.empty()) {\n+      Task& task = state_->task_queue.front();\n\nReview comment:\n       The `task_queue` can be mutated from another thread, and I don't think there are any guarantees about reference stability.\n\n##########\nFile path: cpp/src/arrow/util/thread_pool.h\n##########\n@@ -189,6 +190,64 @@ class ARROW_EXPORT Executor {\n                            StopCallback&&) = 0;\n };\n \n+/// \\brief An executor implementation that runs all tasks on a single thread using an\n+/// event loop.\n+///\n+/// Note: Any sort of nested parallelism will deadlock this executor.  Blocking waits are\n+/// fine but if one task needs to wait for another task it must be expressed as an\n+/// asynchronous continuation.\n+class ARROW_EXPORT SerialExecutor : public Executor {\n+ public:\n+  template <typename T = ::arrow::detail::Empty>\n+  using FinishSignal = internal::FnOnce<void(const Result<T>&)>;\n+  template <typename T = ::arrow::detail::Empty>\n+  using Scheduler = internal::FnOnce<Status(Executor*, FinishSignal<T>)>;\n+\n+  SerialExecutor();\n+  ~SerialExecutor();\n+\n+  int GetCapacity() override { return 1; };\n+  Status SpawnReal(TaskHints hints, FnOnce<void()> task, StopToken,\n+                   StopCallback&&) override;\n+\n+  /// \\brief Runs the scheduler and any scheduled tasks\n+  ///\n+  /// The scheduler must either return an invalid status or call the finish signal.\n+  /// Failure to do this will result in a deadlock.  For this reason it is preferable (if\n+  /// possible) to use the helper methods (below) RunSynchronously/RunSerially which\n+  /// delegates the responsiblity onto a Future producer's existing responsibility to\n+  /// always mark a future finished (which can someday be aided by ARROW-12207).\n+  template <typename T>\n+  static Result<T> RunInSerialExecutor(Scheduler<T> initial_task) {\n+    auto serial_executor = std::make_shared<SerialExecutor>();\n\nReview comment:\n       Nit, but this can probably be `SerialExecutor serial_executor;`\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-06T14:58:44.945+0000",
                    "updated": "2021-04-06T14:58:44.945+0000",
                    "started": "2021-04-06T14:58:44.945+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "577661",
                    "issueId": "13369599"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/worklog/577779",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9892:\nURL: https://github.com/apache/arrow/pull/9892#discussion_r608052063\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.h\n##########\n@@ -32,6 +32,7 @@\n #include \"arrow/memory_pool.h\"\n #include \"arrow/type_fwd.h\"\n #include \"arrow/util/async_generator.h\"\n+#include \"arrow/util/thread_pool.h\"\n\nReview comment:\n       I tried and failed removing `async_generator.h` before.  The crux of the issue was...\r\n   \r\n   `AsyncGenerator<T>` is a typedef of `std::function<Future<T>()>` and not a proper class in its own right (in fact, `async_generator.h` hides all generator classes behind `MakeXYZGenerator` and so it doesn't actually need to export any types beyond `std::function`.\r\n   \r\n   `std::function<Future<T>()>` requires `<functional>`.\r\n   \r\n   We don't want `<functional>` in a `type_fwd`.\r\n   \r\n   I'm open to suggestions.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-06T17:36:58.725+0000",
                    "updated": "2021-04-06T17:36:58.725+0000",
                    "started": "2021-04-06T17:36:58.725+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "577779",
                    "issueId": "13369599"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/worklog/577780",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9892:\nURL: https://github.com/apache/arrow/pull/9892#discussion_r608052063\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.h\n##########\n@@ -32,6 +32,7 @@\n #include \"arrow/memory_pool.h\"\n #include \"arrow/type_fwd.h\"\n #include \"arrow/util/async_generator.h\"\n+#include \"arrow/util/thread_pool.h\"\n\nReview comment:\n       I tried and failed removing `async_generator.h` before.  The crux of the issue was...\r\n   \r\n   `AsyncGenerator<T>` is a typedef of `std::function<Future<T>()>` and not a proper class in its own right (in fact, `async_generator.h` hides all generator classes behind `MakeXYZGenerator` and so it doesn't actually need to export any types beyond `std::function`).\r\n   \r\n   `std::function<Future<T>()>` requires `<functional>`.\r\n   \r\n   We don't want `<functional>` in a `type_fwd`.\r\n   \r\n   I'm open to suggestions.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-06T17:37:11.739+0000",
                    "updated": "2021-04-06T17:37:11.739+0000",
                    "started": "2021-04-06T17:37:11.739+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "577780",
                    "issueId": "13369599"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/worklog/577781",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #9892:\nURL: https://github.com/apache/arrow/pull/9892#discussion_r608054697\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.h\n##########\n@@ -32,6 +32,7 @@\n #include \"arrow/memory_pool.h\"\n #include \"arrow/type_fwd.h\"\n #include \"arrow/util/async_generator.h\"\n+#include \"arrow/util/thread_pool.h\"\n\nReview comment:\n       Perhaps we can use `std::function<Future<T>()>` directly instead of the typedef. @bkietz what do you think?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-06T17:40:48.008+0000",
                    "updated": "2021-04-06T17:40:48.008+0000",
                    "started": "2021-04-06T17:40:48.008+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "577781",
                    "issueId": "13369599"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/worklog/577955",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9892:\nURL: https://github.com/apache/arrow/pull/9892#discussion_r608213491\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.h\n##########\n@@ -32,6 +32,7 @@\n #include \"arrow/memory_pool.h\"\n #include \"arrow/type_fwd.h\"\n #include \"arrow/util/async_generator.h\"\n+#include \"arrow/util/thread_pool.h\"\n\nReview comment:\n       Sorry, I was not clear with my language.  By \"no types beyond `std::function`\" I meant \"no classes or structs\".  We would still need to include `async_generator.h` for the functions (e.g. `MakeMappedGenerator`).\r\n   \r\n   So without the typedef you still have the problem that you cannot forward declare the `MakeXyz` functions without including `<functional>` in the forward declaration.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-06T22:12:34.865+0000",
                    "updated": "2021-04-06T22:12:34.865+0000",
                    "started": "2021-04-06T22:12:34.865+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "577955",
                    "issueId": "13369599"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/worklog/577968",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9892:\nURL: https://github.com/apache/arrow/pull/9892#discussion_r608219924\n\n\n\n##########\nFile path: cpp/src/arrow/util/thread_pool.h\n##########\n@@ -262,5 +321,40 @@ class ARROW_EXPORT ThreadPool : public Executor {\n // Return the process-global thread pool for CPU-bound tasks.\n ARROW_EXPORT ThreadPool* GetCpuThreadPool();\n \n+/// \\brief Runs a potentially async operation serially\n+///\n+/// This means that all CPU tasks spawned by the operation will run on the thread calling\n+/// this method and the future will be completed before this call finishes.\n+template <typename T = arrow::detail::Empty>\n+Result<T> RunSerially(FnOnce<Future<T>(Executor*)> get_future) {\n+  struct InnerCallback {\n+    void operator()(const Result<T> res) { std::move(finish_signal)(std::move(res)); }\n+    SerialExecutor::FinishSignal<T> finish_signal;\n+  };\n+  struct OuterCallback {\n+    Status operator()(Executor* executor, SerialExecutor::FinishSignal<T> finish_signal) {\n+      auto fut = std::move(get_future)(executor);\n+      fut.AddCallback(InnerCallback{std::move(finish_signal)});\n+      return Status::OK();\n+    }\n+    FnOnce<Future<T>(Executor*)> get_future;\n+  };\n+  return SerialExecutor::RunInSerialExecutor<T>(OuterCallback{std::move(get_future)});\n+}\n+\n+/// \\brief Potentially runs an async operation serially if use_threads is true\n+/// \\see RunSerially\n+///\n+/// If `use_threads` is false then the operation is run normally but this method will\n+/// still block the calling thread until the operation has completed.\n+template <typename T>\n+Result<T> RunSynchronously(FnOnce<Future<T>(Executor*)> get_future, bool use_threads) {\n\nReview comment:\n       I'm not sure I follow.  The purpose of this code is to run asynchronous code synchronously in the calling thread.  So the function cannot return until future has been completed.\r\n   \r\n   For example, consider an asynchronous operation that reads a file asynchronously from the filesystem and parses it into a schema.  First...\r\n   \r\n   * The calling thread sets up the read (this happens in the calling thread even if run asynchronously) and then launches the read with io_executor->Submit.\r\n   * The I/O thread performs the read.  Meanwhile, the calling thread waits for the read to finish.  This is different than standard asynchronous flow.  In standard asynchronous flow the calling thread would have returned a future at this point.\r\n   * The I/O thread finishes the read and adds a follow-up task to the CPU executor.  In this case that is our newly created thread pool.  The calling thread wakes up and processes the follow-up task.  In normal asynchronous flow this follow-up task would have been submitted to the CPU thread pool.\r\n   * The calling thread finishes the follow-up task and calls the finish signal.  The calling thread then returns all the way out of the `RunSynchronously` call.  In normal asynchronous flow we would have returned from that call long ago and the CPU thread would just be marking a future complete.\r\n   \r\n   However, there are some other choices we can make here.\r\n   \r\n   * We could require the I/O executor be replaced with our newly created serial executor as well.  This way we don't use any I/O threads OR CPU threads (this is how the previous implementation operated anyways).  In that case we don't need the finish condition because we know we are done when we run out of tasks in the thread pool.  We could also modify the SpawnReal function to return an invalid status if the current calling thread was not the original calling thread (this would safeguard against mistakenly using the I/O executor).\r\n   * We could keep track (perhaps in some thread local) of a counter when we schedule tasks on other executors and then decrement this \"outgoing task count\" when those tasks finish.  In that case we don't need the finish condition because we know we are finished when `outgoing task count == 0 && task_queue.empty()`\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-06T22:28:19.160+0000",
                    "updated": "2021-04-06T22:28:19.160+0000",
                    "started": "2021-04-06T22:28:19.160+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "577968",
                    "issueId": "13369599"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/worklog/577997",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9892:\nURL: https://github.com/apache/arrow/pull/9892#discussion_r608243318\n\n\n\n##########\nFile path: cpp/src/arrow/util/thread_pool.h\n##########\n@@ -262,5 +321,40 @@ class ARROW_EXPORT ThreadPool : public Executor {\n // Return the process-global thread pool for CPU-bound tasks.\n ARROW_EXPORT ThreadPool* GetCpuThreadPool();\n \n+/// \\brief Runs a potentially async operation serially\n+///\n+/// This means that all CPU tasks spawned by the operation will run on the thread calling\n+/// this method and the future will be completed before this call finishes.\n+template <typename T = arrow::detail::Empty>\n+Result<T> RunSerially(FnOnce<Future<T>(Executor*)> get_future) {\n+  struct InnerCallback {\n+    void operator()(const Result<T> res) { std::move(finish_signal)(std::move(res)); }\n+    SerialExecutor::FinishSignal<T> finish_signal;\n+  };\n+  struct OuterCallback {\n+    Status operator()(Executor* executor, SerialExecutor::FinishSignal<T> finish_signal) {\n+      auto fut = std::move(get_future)(executor);\n+      fut.AddCallback(InnerCallback{std::move(finish_signal)});\n+      return Status::OK();\n+    }\n+    FnOnce<Future<T>(Executor*)> get_future;\n+  };\n+  return SerialExecutor::RunInSerialExecutor<T>(OuterCallback{std::move(get_future)});\n+}\n+\n+/// \\brief Potentially runs an async operation serially if use_threads is true\n+/// \\see RunSerially\n+///\n+/// If `use_threads` is false then the operation is run normally but this method will\n+/// still block the calling thread until the operation has completed.\n\nReview comment:\n       I used Antoine's comments below which fixes this.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-06T23:31:53.942+0000",
                    "updated": "2021-04-06T23:31:53.942+0000",
                    "started": "2021-04-06T23:31:53.942+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "577997",
                    "issueId": "13369599"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/worklog/577999",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9892:\nURL: https://github.com/apache/arrow/pull/9892#discussion_r608243354\n\n\n\n##########\nFile path: cpp/src/arrow/util/thread_pool_test.cc\n##########\n@@ -123,6 +123,125 @@ class AddTester {\n   std::vector<int> outs_;\n };\n \n+template <typename T = arrow::detail::Empty>\n+struct TerminalCallback {\n+  void operator()() {\n+    auto result = std::move(callback)();\n+    std::move(finish_signal)(result);\n+  }\n+\n+  FnOnce<Result<T>()> callback;\n+  SerialExecutor::FinishSignal<T> finish_signal;\n+};\n+\n+template <>\n+struct TerminalCallback<arrow::detail::Empty> {\n+  void operator()() {\n+    auto st = std::move(callback)();\n+    if (!st.ok()) {\n+      std::move(finish_signal)(st);\n+    } else {\n+      std::move(finish_signal)(arrow::detail::Empty());\n+    }\n+  }\n+\n+  FnOnce<Status()> callback;\n+  SerialExecutor::FinishSignal<> finish_signal;\n+};\n+\n+TEST(TestSerialExecutor, Create) {\n+  bool task_ran = false;\n+  SerialExecutor::Scheduler<> task = [&](Executor* executor,\n+                                         SerialExecutor::FinishSignal<> finish_signal) {\n+    EXPECT_TRUE(executor != nullptr);\n+    task_ran = true;\n+    std::move(finish_signal)(arrow::detail::Empty());\n+    return Status::OK();\n+  };\n+  ASSERT_OK(SerialExecutor::RunInSerialExecutor(std::move(task)));\n+  EXPECT_TRUE(task_ran);\n+}\n+\n+TEST(TestSerialExecutor, SpawnNested) {\n+  bool nested_ran = false;\n+  SerialExecutor::Scheduler<> scheduler =\n+      [&](Executor* executor, SerialExecutor::FinishSignal<> finish_signal) {\n+        return executor->Spawn(TerminalCallback<>{[&] {\n+                                                    nested_ran = true;\n+                                                    return Status::OK();\n+                                                  },\n+                                                  std::move(finish_signal)});\n+      };\n+  ASSERT_OK(SerialExecutor::RunInSerialExecutor(std::move(scheduler)));\n+  EXPECT_TRUE(nested_ran);\n+}\n+\n+TEST(TestSerialExecutor, WithResult) {\n+  SerialExecutor::Scheduler<int> scheduler =\n+      [&](Executor* executor, SerialExecutor::FinishSignal<int> finish_signal) {\n+        return executor->Spawn(\n+            TerminalCallback<int>{[] { return 42; }, std::move(finish_signal)});\n+      };\n+  ASSERT_OK_AND_EQ(42, SerialExecutor::RunInSerialExecutor(std::move(scheduler)));\n+}\n+\n+TEST(TestSerialExecutor, StopToken) {\n+  bool nested_ran = false;\n+  StopSource stop_source;\n+  SerialExecutor::Scheduler<> scheduler =\n+      [&](Executor* executor, SerialExecutor::FinishSignal<> finish_signal) {\n+        RETURN_NOT_OK(executor->Spawn([&] { nested_ran = true; }, stop_source.token()));\n+        RETURN_NOT_OK(executor->Spawn(\n+            TerminalCallback<>{[&] { return Status::OK(); }, std::move(finish_signal)}));\n+        stop_source.RequestStop(Status::Invalid(\"XYZ\"));\n+        return Status::OK();\n+      };\n+  ASSERT_OK(SerialExecutor::RunInSerialExecutor(std::move(scheduler)));\n+  EXPECT_FALSE(nested_ran);\n+}\n+\n+TEST(TestSerialExecutor, ContinueAfterExternal) {\n+  bool continuation_ran = false;\n+  EXPECT_OK_AND_ASSIGN(auto mockIoPool, ThreadPool::Make(1));\n\nReview comment:\n       Thanks.  Fixed.\n\n##########\nFile path: cpp/src/arrow/util/thread_pool.cc\n##########\n@@ -44,6 +44,63 @@ struct Task {\n \n }  // namespace\n \n+struct SerialExecutor::State {\n+  std::queue<Task> task_queue;\n+  std::mutex mutex;\n+  std::condition_variable wait_for_tasks;\n+};\n+\n+SerialExecutor::SerialExecutor() : state_(new State()) {}\n+SerialExecutor::~SerialExecutor() {}\n+\n+Status SerialExecutor::SpawnReal(TaskHints hints, FnOnce<void()> task,\n+                                 StopToken stop_token, StopCallback&& stop_callback) {\n+  // The serial task queue is truly serial (no mutex needed) but SpawnReal may be called\n+  // from external threads (e.g. when transferring back from blocking I/O threads) so a\n+  // mutex is needed\n+  {\n+    std::lock_guard<std::mutex> lg(state_->mutex);\n+    state_->task_queue.push(\n+        Task{std::move(task), std::move(stop_token), std::move(stop_callback)});\n+  }\n+  state_->wait_for_tasks.notify_one();\n+  return Status::OK();\n+}\n+\n+void SerialExecutor::MarkFinished(bool& finished) {\n\nReview comment:\n       Fixed.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-06T23:32:11.607+0000",
                    "updated": "2021-04-06T23:32:11.607+0000",
                    "started": "2021-04-06T23:32:11.606+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "577999",
                    "issueId": "13369599"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/worklog/578000",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9892:\nURL: https://github.com/apache/arrow/pull/9892#discussion_r608243602\n\n\n\n##########\nFile path: cpp/src/arrow/util/thread_pool.cc\n##########\n@@ -44,6 +44,63 @@ struct Task {\n \n }  // namespace\n \n+struct SerialExecutor::State {\n+  std::queue<Task> task_queue;\n+  std::mutex mutex;\n+  std::condition_variable wait_for_tasks;\n+};\n+\n+SerialExecutor::SerialExecutor() : state_(new State()) {}\n+SerialExecutor::~SerialExecutor() {}\n+\n+Status SerialExecutor::SpawnReal(TaskHints hints, FnOnce<void()> task,\n+                                 StopToken stop_token, StopCallback&& stop_callback) {\n+  // The serial task queue is truly serial (no mutex needed) but SpawnReal may be called\n+  // from external threads (e.g. when transferring back from blocking I/O threads) so a\n+  // mutex is needed\n+  {\n+    std::lock_guard<std::mutex> lg(state_->mutex);\n+    state_->task_queue.push(\n+        Task{std::move(task), std::move(stop_token), std::move(stop_callback)});\n+  }\n+  state_->wait_for_tasks.notify_one();\n+  return Status::OK();\n+}\n+\n+void SerialExecutor::MarkFinished(bool& finished) {\n+  {\n+    std::lock_guard<std::mutex> lk(state_->mutex);\n+    finished = true;\n+  }\n+  state_->wait_for_tasks.notify_one();\n+}\n+\n+void SerialExecutor::RunLoop(const bool& finished) {\n+  std::unique_lock<std::mutex> lk(state_->mutex);\n+\n+  while (!finished) {\n+    while (!state_->task_queue.empty()) {\n+      Task& task = state_->task_queue.front();\n\nReview comment:\n       True, I thought I was fine since I re-lock before I pop but I suppose the underlying storage could be getting reallocated.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-06T23:32:46.573+0000",
                    "updated": "2021-04-06T23:32:46.573+0000",
                    "started": "2021-04-06T23:32:46.572+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "578000",
                    "issueId": "13369599"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/worklog/578001",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9892:\nURL: https://github.com/apache/arrow/pull/9892#discussion_r608243632\n\n\n\n##########\nFile path: cpp/src/arrow/util/thread_pool.cc\n##########\n@@ -44,6 +44,63 @@ struct Task {\n \n }  // namespace\n \n+struct SerialExecutor::State {\n+  std::queue<Task> task_queue;\n+  std::mutex mutex;\n+  std::condition_variable wait_for_tasks;\n+};\n+\n+SerialExecutor::SerialExecutor() : state_(new State()) {}\n+SerialExecutor::~SerialExecutor() {}\n+\n+Status SerialExecutor::SpawnReal(TaskHints hints, FnOnce<void()> task,\n+                                 StopToken stop_token, StopCallback&& stop_callback) {\n+  // The serial task queue is truly serial (no mutex needed) but SpawnReal may be called\n+  // from external threads (e.g. when transferring back from blocking I/O threads) so a\n+  // mutex is needed\n+  {\n+    std::lock_guard<std::mutex> lg(state_->mutex);\n+    state_->task_queue.push(\n+        Task{std::move(task), std::move(stop_token), std::move(stop_callback)});\n+  }\n+  state_->wait_for_tasks.notify_one();\n+  return Status::OK();\n+}\n+\n+void SerialExecutor::MarkFinished(bool& finished) {\n+  {\n+    std::lock_guard<std::mutex> lk(state_->mutex);\n+    finished = true;\n+  }\n+  state_->wait_for_tasks.notify_one();\n+}\n+\n+void SerialExecutor::RunLoop(const bool& finished) {\n+  std::unique_lock<std::mutex> lk(state_->mutex);\n+\n+  while (!finished) {\n+    while (!state_->task_queue.empty()) {\n+      Task& task = state_->task_queue.front();\n\nReview comment:\n       Fixed.\n\n##########\nFile path: cpp/src/arrow/util/thread_pool.h\n##########\n@@ -189,6 +190,64 @@ class ARROW_EXPORT Executor {\n                            StopCallback&&) = 0;\n };\n \n+/// \\brief An executor implementation that runs all tasks on a single thread using an\n+/// event loop.\n+///\n+/// Note: Any sort of nested parallelism will deadlock this executor.  Blocking waits are\n+/// fine but if one task needs to wait for another task it must be expressed as an\n+/// asynchronous continuation.\n+class ARROW_EXPORT SerialExecutor : public Executor {\n+ public:\n+  template <typename T = ::arrow::detail::Empty>\n+  using FinishSignal = internal::FnOnce<void(const Result<T>&)>;\n+  template <typename T = ::arrow::detail::Empty>\n+  using Scheduler = internal::FnOnce<Status(Executor*, FinishSignal<T>)>;\n\nReview comment:\n       Renamed to TopLevelTask\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-06T23:33:10.367+0000",
                    "updated": "2021-04-06T23:33:10.367+0000",
                    "started": "2021-04-06T23:33:10.367+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "578001",
                    "issueId": "13369599"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/worklog/578002",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9892:\nURL: https://github.com/apache/arrow/pull/9892#discussion_r608243743\n\n\n\n##########\nFile path: cpp/src/arrow/util/thread_pool.h\n##########\n@@ -189,6 +190,64 @@ class ARROW_EXPORT Executor {\n                            StopCallback&&) = 0;\n };\n \n+/// \\brief An executor implementation that runs all tasks on a single thread using an\n+/// event loop.\n+///\n+/// Note: Any sort of nested parallelism will deadlock this executor.  Blocking waits are\n\nReview comment:\n       True, I added the comment to the other thread pool as well.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-06T23:33:23.402+0000",
                    "updated": "2021-04-06T23:33:23.402+0000",
                    "started": "2021-04-06T23:33:23.402+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "578002",
                    "issueId": "13369599"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/worklog/578003",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9892:\nURL: https://github.com/apache/arrow/pull/9892#discussion_r608243837\n\n\n\n##########\nFile path: cpp/src/arrow/util/thread_pool.h\n##########\n@@ -262,5 +321,40 @@ class ARROW_EXPORT ThreadPool : public Executor {\n // Return the process-global thread pool for CPU-bound tasks.\n ARROW_EXPORT ThreadPool* GetCpuThreadPool();\n \n+/// \\brief Runs a potentially async operation serially\n+///\n+/// This means that all CPU tasks spawned by the operation will run on the thread calling\n+/// this method and the future will be completed before this call finishes.\n+template <typename T = arrow::detail::Empty>\n+Result<T> RunSerially(FnOnce<Future<T>(Executor*)> get_future) {\n+  struct InnerCallback {\n+    void operator()(const Result<T> res) { std::move(finish_signal)(std::move(res)); }\n+    SerialExecutor::FinishSignal<T> finish_signal;\n+  };\n+  struct OuterCallback {\n+    Status operator()(Executor* executor, SerialExecutor::FinishSignal<T> finish_signal) {\n+      auto fut = std::move(get_future)(executor);\n+      fut.AddCallback(InnerCallback{std::move(finish_signal)});\n+      return Status::OK();\n+    }\n+    FnOnce<Future<T>(Executor*)> get_future;\n+  };\n+  return SerialExecutor::RunInSerialExecutor<T>(OuterCallback{std::move(get_future)});\n+}\n+\n+/// \\brief Potentially runs an async operation serially if use_threads is true\n\nReview comment:\n       Used the suggested comments, thanks.\n\n##########\nFile path: cpp/src/arrow/util/thread_pool.h\n##########\n@@ -262,5 +321,40 @@ class ARROW_EXPORT ThreadPool : public Executor {\n // Return the process-global thread pool for CPU-bound tasks.\n ARROW_EXPORT ThreadPool* GetCpuThreadPool();\n \n+/// \\brief Runs a potentially async operation serially\n\nReview comment:\n       Fixed.\n\n##########\nFile path: cpp/src/arrow/util/thread_pool_test.cc\n##########\n@@ -123,6 +123,125 @@ class AddTester {\n   std::vector<int> outs_;\n };\n \n+template <typename T = arrow::detail::Empty>\n+struct TerminalCallback {\n+  void operator()() {\n+    auto result = std::move(callback)();\n+    std::move(finish_signal)(result);\n+  }\n+\n+  FnOnce<Result<T>()> callback;\n+  SerialExecutor::FinishSignal<T> finish_signal;\n+};\n+\n+template <>\n+struct TerminalCallback<arrow::detail::Empty> {\n+  void operator()() {\n+    auto st = std::move(callback)();\n+    if (!st.ok()) {\n+      std::move(finish_signal)(st);\n+    } else {\n+      std::move(finish_signal)(arrow::detail::Empty());\n+    }\n+  }\n+\n+  FnOnce<Status()> callback;\n+  SerialExecutor::FinishSignal<> finish_signal;\n+};\n+\n+TEST(TestSerialExecutor, Create) {\n+  bool task_ran = false;\n+  SerialExecutor::Scheduler<> task = [&](Executor* executor,\n+                                         SerialExecutor::FinishSignal<> finish_signal) {\n+    EXPECT_TRUE(executor != nullptr);\n\nReview comment:\n       Fixed.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-06T23:33:47.289+0000",
                    "updated": "2021-04-06T23:33:47.289+0000",
                    "started": "2021-04-06T23:33:47.289+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "578003",
                    "issueId": "13369599"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/worklog/578004",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9892:\nURL: https://github.com/apache/arrow/pull/9892#discussion_r608244017\n\n\n\n##########\nFile path: cpp/src/arrow/util/thread_pool_test.cc\n##########\n@@ -123,6 +123,125 @@ class AddTester {\n   std::vector<int> outs_;\n };\n \n+template <typename T = arrow::detail::Empty>\n\nReview comment:\n       These methods went away addressing the next comment.\n\n##########\nFile path: cpp/src/arrow/util/thread_pool_test.cc\n##########\n@@ -123,6 +123,125 @@ class AddTester {\n   std::vector<int> outs_;\n };\n \n+template <typename T = arrow::detail::Empty>\n+struct TerminalCallback {\n+  void operator()() {\n+    auto result = std::move(callback)();\n+    std::move(finish_signal)(result);\n+  }\n+\n+  FnOnce<Result<T>()> callback;\n+  SerialExecutor::FinishSignal<T> finish_signal;\n+};\n+\n+template <>\n+struct TerminalCallback<arrow::detail::Empty> {\n+  void operator()() {\n+    auto st = std::move(callback)();\n+    if (!st.ok()) {\n+      std::move(finish_signal)(st);\n+    } else {\n+      std::move(finish_signal)(arrow::detail::Empty());\n+    }\n+  }\n+\n+  FnOnce<Status()> callback;\n+  SerialExecutor::FinishSignal<> finish_signal;\n+};\n+\n+TEST(TestSerialExecutor, Create) {\n+  bool task_ran = false;\n+  SerialExecutor::Scheduler<> task = [&](Executor* executor,\n+                                         SerialExecutor::FinishSignal<> finish_signal) {\n+    EXPECT_TRUE(executor != nullptr);\n+    task_ran = true;\n+    std::move(finish_signal)(arrow::detail::Empty());\n+    return Status::OK();\n+  };\n+  ASSERT_OK(SerialExecutor::RunInSerialExecutor(std::move(task)));\n+  EXPECT_TRUE(task_ran);\n+}\n+\n+TEST(TestSerialExecutor, SpawnNested) {\n+  bool nested_ran = false;\n+  SerialExecutor::Scheduler<> scheduler =\n+      [&](Executor* executor, SerialExecutor::FinishSignal<> finish_signal) {\n+        return executor->Spawn(TerminalCallback<>{[&] {\n+                                                    nested_ran = true;\n+                                                    return Status::OK();\n+                                                  },\n+                                                  std::move(finish_signal)});\n+      };\n+  ASSERT_OK(SerialExecutor::RunInSerialExecutor(std::move(scheduler)));\n+  EXPECT_TRUE(nested_ran);\n+}\n+\n+TEST(TestSerialExecutor, WithResult) {\n+  SerialExecutor::Scheduler<int> scheduler =\n+      [&](Executor* executor, SerialExecutor::FinishSignal<int> finish_signal) {\n+        return executor->Spawn(\n+            TerminalCallback<int>{[] { return 42; }, std::move(finish_signal)});\n+      };\n+  ASSERT_OK_AND_EQ(42, SerialExecutor::RunInSerialExecutor(std::move(scheduler)));\n+}\n+\n+TEST(TestSerialExecutor, StopToken) {\n+  bool nested_ran = false;\n+  StopSource stop_source;\n+  SerialExecutor::Scheduler<> scheduler =\n+      [&](Executor* executor, SerialExecutor::FinishSignal<> finish_signal) {\n+        RETURN_NOT_OK(executor->Spawn([&] { nested_ran = true; }, stop_source.token()));\n+        RETURN_NOT_OK(executor->Spawn(\n+            TerminalCallback<>{[&] { return Status::OK(); }, std::move(finish_signal)}));\n+        stop_source.RequestStop(Status::Invalid(\"XYZ\"));\n+        return Status::OK();\n+      };\n+  ASSERT_OK(SerialExecutor::RunInSerialExecutor(std::move(scheduler)));\n+  EXPECT_FALSE(nested_ran);\n+}\n+\n+TEST(TestSerialExecutor, ContinueAfterExternal) {\n+  bool continuation_ran = false;\n+  EXPECT_OK_AND_ASSIGN(auto mockIoPool, ThreadPool::Make(1));\n+  SerialExecutor::Scheduler<> scheduler =\n+      [&](Executor* executor, SerialExecutor::FinishSignal<> finish_signal) {\n+        struct Callback {\n+          void operator()(const Result<arrow::detail::Empty>& emp) {\n+            continuation_ran = true;\n+            std::move(finish_signal)(emp);\n+          }\n+          SerialExecutor::FinishSignal<> finish_signal;\n+          bool& continuation_ran;\n+        };\n+        executor\n+            ->Transfer(DeferNotOk(mockIoPool->Submit([&] {\n+              SleepABit();\n+              return Status::OK();\n+            })))\n+            .AddCallback(Callback{std::move(finish_signal), continuation_ran});\n+        return Status::OK();\n+      };\n+  ASSERT_OK(SerialExecutor::RunInSerialExecutor(std::move(scheduler)));\n+  EXPECT_TRUE(continuation_ran);\n+}\n+\n+TEST(TestSerialExecutor, SchedulerAbort) {\n+  SerialExecutor::Scheduler<> scheduler =\n+      [&](Executor* executor, SerialExecutor::FinishSignal<> finish_signal) {\n+        return Status::Invalid(\"XYZ\");\n+      };\n+  ASSERT_RAISES(Invalid, SerialExecutor::RunInSerialExecutor(std::move(scheduler)));\n+}\n+\n+TEST(TestSerialExecutor, PropagatedError) {\n+  SerialExecutor::Scheduler<> scheduler =\n+      [&](Executor* executor, SerialExecutor::FinishSignal<> finish_signal) {\n+        std::move(finish_signal)(Status::Invalid(\"XYZ\"));\n+        return Status::OK();\n+      };\n+  ASSERT_RAISES(Invalid, SerialExecutor::RunInSerialExecutor(std::move(scheduler)));\n\nReview comment:\n       Fixed.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-06T23:34:12.139+0000",
                    "updated": "2021-04-06T23:34:12.139+0000",
                    "started": "2021-04-06T23:34:12.139+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "578004",
                    "issueId": "13369599"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 28200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@5dbc88ee[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@33e0c21f[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2c49d7f3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@190c085f[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3b50b9d4[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@70a2f10c[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@12b646a4[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@6b81ea5d[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@55a170e0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@32ecc1c9[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@124f2256[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@7678f140[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 28200,
        "customfield_12312520": null,
        "customfield_12312521": "Fri Apr 09 21:19:40 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-04-09T21:19:40.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12208/watchers",
            "watchCount": 4,
            "isWatching": false
        },
        "created": "2021-04-05T14:22:27.000+0000",
        "updated": "2021-04-14T14:17:56.000+0000",
        "timeoriginalestimate": null,
        "description": "This is required allow Windows 32-bit RTools 3.5 builds avoid crashing as they don't seem to properly implement the `<threading>` header.\r\n\r\n\u00a0\r\n\r\nHowever, it could be generally useful to anyone that wants to avoid thread creation.\r\n\r\n\u00a0\r\n\r\nCurrently, the asynchronous approaches introduce necessary threading.\u00a0 For example, even a simple call to check if the CSVFileFormat supports a file requires peeking the file and reading the first block.\u00a0 These I/O operations happen on the I/O pools and then are transferred to the CPU thread pool (which is NOT the same thing as the calling thread) meanwhile the calling thread is blocked waiting for results.\r\n\r\n\u00a0\r\n\r\nThis can be avoided by treating the calling thread as a single threaded thread pool and then using that as the CPU thread pool.\u00a0 This allows all CPU work to be done on the calling thread alone.\u00a0 This could also allow us to remove duplicate code paths (e.g. code paths that exist only to keep functions serial such as the serial CSV reader) in the future.\r\n\r\n\u00a0\r\n\r\nThis capability could be extended to include the I/O thread pool as well at some point in the future.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "7h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 28200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Add the ability to run async tasks without using the CPU thread pool",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/comment/17314895",
                    "id": "17314895",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "I would not bother about RTools 3.5 at this point. We're dropping it in a month or two. Just disable whatever functionality doesn't work (especially if the problems are 32-bit only).\r\n\r\nRegardless, this is conceptually a worthwhile proposal, but I don't know if it will be easy to implement.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-04-05T14:26:32.252+0000",
                    "updated": "2021-04-05T14:26:32.252+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/comment/17314902",
                    "id": "17314902",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Ah, my understanding from Neal was that we cannot release release 4.0 with RTools 3.5 broken.\u00a0 I had already been working on this as part of ARROW-12161 but ended up creating this separate Jira as the PR is doing more than just fixing a bug.\u00a0 I already have an implementation.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2021-04-05T14:40:35.615+0000",
                    "updated": "2021-04-05T14:40:35.615+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/comment/17314907",
                    "id": "17314907",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=npr",
                        "name": "npr",
                        "key": "npr",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Neal Richardson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Correct, we cannot release 4.0 with a broken RTools 3.5 build. But if necessary we can conditionally disable features in it--we already do this for S3 support.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=npr",
                        "name": "npr",
                        "key": "npr",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Neal Richardson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2021-04-05T14:48:36.080+0000",
                    "updated": "2021-04-05T14:48:36.080+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13369599/comment/17318331",
                    "id": "17318331",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=npr",
                        "name": "npr",
                        "key": "npr",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Neal Richardson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Issue resolved by pull request 9892\n[https://github.com/apache/arrow/pull/9892]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=npr",
                        "name": "npr",
                        "key": "npr",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Neal Richardson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2021-04-09T21:19:40.357+0000",
                    "updated": "2021-04-09T21:19:40.357+0000"
                }
            ],
            "maxResults": 4,
            "total": 4,
            "startAt": 0
        },
        "customfield_12311820": "0|z0pjb4:",
        "customfield_12314139": null
    }
}