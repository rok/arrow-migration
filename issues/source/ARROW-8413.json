{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13297951",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297951",
    "key": "ARROW-8413",
    "fields": {
        "parent": {
            "id": "13107102",
            "key": "ARROW-1644",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13107102",
            "fields": {
                "summary": "[C++][Parquet] Read and write nested Parquet data with a mix of struct and list nesting levels",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                    "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                    "name": "Resolved",
                    "id": "5",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                    "id": "2",
                    "description": "A new feature of the product, which has yet to be developed.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                    "name": "New Feature",
                    "subtask": false,
                    "avatarId": 21141
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12347769",
                "id": "12347769",
                "description": "",
                "name": "1.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-07-24"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
            "name": "emkornfield@gmail.com",
            "key": "emkornfield@gmail.com",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
            "name": "emkornfield@gmail.com",
            "key": "emkornfield@gmail.com",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
            "name": "emkornfield@gmail.com",
            "key": "emkornfield@gmail.com",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 50400,
            "total": 50400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 50400,
            "total": 50400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-8413/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 84,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297951/worklog/426335",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on a change in pull request #6985:\nURL: https://github.com/apache/arrow/pull/6985#discussion_r413428461\n\n\n\n##########\nFile path: cpp/src/arrow/util/bit_util.h\n##########\n@@ -43,13 +43,18 @@\n \n #if defined(_MSC_VER)\n #include <intrin.h>\n+#include <nmmintrin.h>\n #pragma intrinsic(_BitScanReverse)\n #pragma intrinsic(_BitScanForward)\n #define ARROW_BYTE_SWAP64 _byteswap_uint64\n #define ARROW_BYTE_SWAP32 _byteswap_ulong\n+#define ARROW_POPCOUNT64 __popcnt64\n+#define ARROW_POPCOUNT32 __popcnt\n #else\n #define ARROW_BYTE_SWAP64 __builtin_bswap64\n #define ARROW_BYTE_SWAP32 __builtin_bswap32\n+#define ARROW_POPCOUNT64 __builtin_popcountll\n+#define ARROW_POPCOUNT32 __builtin_popcount\n\nReview comment:\n       TIL, C++20 has std::popcount.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-23T00:44:50.389+0000",
                    "updated": "2020-04-23T00:44:50.389+0000",
                    "started": "2020-04-23T00:44:50.389+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426335",
                    "issueId": "13297951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297951/worklog/426388",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #6985:\nURL: https://github.com/apache/arrow/pull/6985#discussion_r413530683\n\n\n\n##########\nFile path: cpp/src/arrow/util/bit_util.h\n##########\n@@ -43,13 +43,18 @@\n \n #if defined(_MSC_VER)\n #include <intrin.h>\n+#include <nmmintrin.h>\n #pragma intrinsic(_BitScanReverse)\n #pragma intrinsic(_BitScanForward)\n #define ARROW_BYTE_SWAP64 _byteswap_uint64\n #define ARROW_BYTE_SWAP32 _byteswap_ulong\n+#define ARROW_POPCOUNT64 __popcnt64\n+#define ARROW_POPCOUNT32 __popcnt\n #else\n #define ARROW_BYTE_SWAP64 __builtin_bswap64\n #define ARROW_BYTE_SWAP32 __builtin_bswap32\n+#define ARROW_POPCOUNT64 __builtin_popcountll\n+#define ARROW_POPCOUNT32 __builtin_popcount\n\nReview comment:\n       Yep, so we'll be able to use it by 2030 hopefully? :)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-23T05:58:59.202+0000",
                    "updated": "2020-04-23T05:58:59.202+0000",
                    "started": "2020-04-23T05:58:59.202+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426388",
                    "issueId": "13297951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297951/worklog/426394",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #6985:\nURL: https://github.com/apache/arrow/pull/6985#discussion_r413533870\n\n\n\n##########\nFile path: cpp/src/parquet/column_reader.cc\n##########\n@@ -50,6 +51,141 @@ using arrow::internal::checked_cast;\n \n namespace parquet {\n \n+namespace {\n+\n+inline void CheckLevelRange(const int16_t* levels, int64_t num_levels,\n+                            const int16_t max_expected_level) {\n+  int16_t min_level = std::numeric_limits<int16_t>::max();\n+  int16_t max_level = std::numeric_limits<int16_t>::min();\n+  for (int x = 0; x < num_levels; x++) {\n+    min_level = std::min(levels[x], min_level);\n+    max_level = std::max(levels[x], max_level);\n+  }\n+  if (ARROW_PREDICT_FALSE(num_levels > 0 && (min_level < 0 || max_level > max_level))) {\n+    throw ParquetException(\"definition level exceeds maximum\");\n+  }\n+}\n+\n+#if !defined(ARROW_HAVE_BMI2)\n+\n+inline void DefinitionLevelsToBitmapScalar(\n+    const int16_t* def_levels, int64_t num_def_levels, const int16_t max_definition_level,\n+    const int16_t max_repetition_level, int64_t* values_read, int64_t* null_count,\n+    uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  // We assume here that valid_bits is large enough to accommodate the\n+  // additional definition levels and the ones that have already been written\n+  ::arrow::internal::BitmapWriter valid_bits_writer(valid_bits, valid_bits_offset,\n+                                                    num_def_levels);\n+\n+  // TODO(itaiin): As an interim solution we are splitting the code path here\n+  // between repeated+flat column reads, and non-repeated+nested reads.\n+  // Those paths need to be merged in the future\n+  for (int i = 0; i < num_def_levels; ++i) {\n+    if (def_levels[i] == max_definition_level) {\n+      valid_bits_writer.Set();\n+    } else if (max_repetition_level > 0) {\n+      // repetition+flat case\n+      if (def_levels[i] == (max_definition_level - 1)) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        continue;\n+      }\n+    } else {\n+      // non-repeated+nested case\n+      if (def_levels[i] < max_definition_level) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        throw ParquetException(\"definition level exceeds maximum\");\n+      }\n+    }\n+\n+    valid_bits_writer.Next();\n+  }\n+  valid_bits_writer.Finish();\n+  *values_read = valid_bits_writer.position();\n+}\n+#endif\n+\n+template <bool has_repeated_parent>\n+void DefinitionLevelsToBitmapSimd(const int16_t* def_levels, int64_t num_def_levels,\n+                                  const int16_t required_definition_level,\n+                                  int64_t* values_read, int64_t* null_count,\n+                                  uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  constexpr int64_t kBitMaskSize = 64;\n+  int64_t set_count = 0;\n+  *values_read = 0;\n+  while (num_def_levels > 0) {\n+    int64_t batch_size = std::min(num_def_levels, kBitMaskSize);\n+    CheckLevelRange(def_levels, batch_size, required_definition_level);\n+    uint64_t defined_bitmap = internal::GreaterThanBitmap(def_levels, batch_size,\n+                                                          required_definition_level - 1);\n+    if (has_repeated_parent) {\n+      // This is currently a specialized code path assuming only (nested) lists\n+      // present through the leaf (i.e. no structs).\n+      // Upper level code only calls this method\n+      // when the leaf-values are nullable (otherwise no spacing is needed),\n+      // Because only nested lists exists it is sufficient to know that the field\n+      // was either null or included it (i.e. >= previous definition level -> > previous\n+      // definition - 1). If there where structs mixed in, we need to know the def_level\n+      // of the repeated parent so we can check for def_level > \"def level of repeated\n+      // parent\".\n+      uint64_t present_bitmap = internal::GreaterThanBitmap(\n+          def_levels, batch_size, required_definition_level - 2);\n+      *values_read += internal::AppendSelectedBitsToValidityBitmap(\n+          /*new_bits=*/defined_bitmap,\n+          /*selection_bitmap*/ present_bitmap, valid_bits, &valid_bits_offset,\n+          &set_count);\n+    } else {\n+      internal::AppendToValidityBitmap(\n+          /*new_bits=*/defined_bitmap,\n+          /*new_bit_count=*/batch_size, valid_bits, &valid_bits_offset, &set_count);\n+      *values_read += batch_size;\n+    }\n+    def_levels += batch_size;\n+    num_def_levels -= batch_size;\n+  }\n+  *null_count += *values_read - set_count;\n+}\n+\n+inline void DefinitionLevelsToBitmapDispatch(\n+    const int16_t* def_levels, int64_t num_def_levels, const int16_t max_definition_level,\n+    const int16_t max_repetition_level, int64_t* values_read, int64_t* null_count,\n+    uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  if (max_repetition_level > 0) {\n+#if ARROW_LITTLE_ENDIAN\n+// we use AVx2 as a proxy for BMI2 instruction set, since there doesn't seem to be a clean\n+// way o detect that latter for MSVC.\n+#if defined(ARROW_HAVE_BMI2)\n+    // We need BIM2 instruction which is AVX2 should imply.\n\nReview comment:\n       Remove the comment as it was stale.\n\n##########\nFile path: cpp/src/parquet/CMakeLists.txt\n##########\n@@ -336,6 +336,7 @@ set_source_files_properties(public_api_test.cc\n add_parquet_test(reader_test\n                  SOURCES\n                  column_reader_test.cc\n+\t\t level_conversion_test.cc\n\nReview comment:\n       done.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-23T06:07:12.983+0000",
                    "updated": "2020-04-23T06:07:12.983+0000",
                    "started": "2020-04-23T06:07:12.983+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426394",
                    "issueId": "13297951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297951/worklog/426401",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #6985:\nURL: https://github.com/apache/arrow/pull/6985#discussion_r413575153\n\n\n\n##########\nFile path: cpp/cmake_modules/SetupCxxFlags.cmake\n##########\n@@ -40,12 +40,13 @@ if(ARROW_CPU_FLAG STREQUAL \"x86\")\n     set(CXX_SUPPORTS_SSE4_2 TRUE)\n   else()\n     set(ARROW_SSE4_2_FLAG \"-msse4.2\")\n-    set(ARROW_AVX2_FLAG \"-mavx2\")\n+    set(ARROW_AVX2_FLAG \"-march=core-avx2\")\n\nReview comment:\n       hopefully this is acceptable change.  I'm open to other suggestions on how to enable bmi2 (not for some reason using \"-mbmi2 -mavx2\" didn't seem to work for me, but I can try again.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-23T07:26:04.541+0000",
                    "updated": "2020-04-23T07:26:04.541+0000",
                    "started": "2020-04-23T07:26:04.541+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426401",
                    "issueId": "13297951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297951/worklog/426402",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #6985:\nURL: https://github.com/apache/arrow/pull/6985#discussion_r413576031\n\n\n\n##########\nFile path: cpp/src/parquet/column_reader.cc\n##########\n@@ -50,6 +51,140 @@ using arrow::internal::checked_cast;\n \n namespace parquet {\n \n+namespace {\n+\n+inline void CheckLevelRange(const int16_t* levels, int64_t num_levels,\n+                            const int16_t max_expected_level) {\n+  int16_t min_level = std::numeric_limits<int16_t>::max();\n+  int16_t max_level = std::numeric_limits<int16_t>::min();\n+  for (int x = 0; x < num_levels; x++) {\n+    min_level = std::min(levels[x], min_level);\n+    max_level = std::max(levels[x], max_level);\n+  }\n+  if (ARROW_PREDICT_FALSE(num_levels > 0 && (min_level < 0 || max_level > max_level))) {\n+    throw ParquetException(\"definition level exceeds maximum\");\n+  }\n+}\n+\n+#if !defined(ARROW_HAVE_BMI2)\n+\n+inline void DefinitionLevelsToBitmapScalar(\n+    const int16_t* def_levels, int64_t num_def_levels, const int16_t max_definition_level,\n+    const int16_t max_repetition_level, int64_t* values_read, int64_t* null_count,\n+    uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  // We assume here that valid_bits is large enough to accommodate the\n+  // additional definition levels and the ones that have already been written\n+  ::arrow::internal::BitmapWriter valid_bits_writer(valid_bits, valid_bits_offset,\n+                                                    num_def_levels);\n+\n+  // TODO(itaiin): As an interim solution we are splitting the code path here\n+  // between repeated+flat column reads, and non-repeated+nested reads.\n+  // Those paths need to be merged in the future\n+  for (int i = 0; i < num_def_levels; ++i) {\n+    if (def_levels[i] == max_definition_level) {\n+      valid_bits_writer.Set();\n+    } else if (max_repetition_level > 0) {\n+      // repetition+flat case\n+      if (def_levels[i] == (max_definition_level - 1)) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        continue;\n+      }\n+    } else {\n+      // non-repeated+nested case\n+      if (def_levels[i] < max_definition_level) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        throw ParquetException(\"definition level exceeds maximum\");\n+      }\n+    }\n+\n+    valid_bits_writer.Next();\n+  }\n+  valid_bits_writer.Finish();\n+  *values_read = valid_bits_writer.position();\n+}\n+#endif\n+\n+template <bool has_repeated_parent>\n+void DefinitionLevelsToBitmapSimd(const int16_t* def_levels, int64_t num_def_levels,\n+                                  const int16_t required_definition_level,\n+                                  int64_t* values_read, int64_t* null_count,\n+                                  uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  constexpr int64_t kBitMaskSize = 64;\n+  int64_t set_count = 0;\n+  *values_read = 0;\n+  while (num_def_levels > 0) {\n+    int64_t batch_size = std::min(num_def_levels, kBitMaskSize);\n+    CheckLevelRange(def_levels, batch_size, required_definition_level);\n+    uint64_t defined_bitmap = internal::GreaterThanBitmap(def_levels, batch_size,\n+                                                          required_definition_level - 1);\n+    if (has_repeated_parent) {\n+      // This is currently a specialized code path assuming only (nested) lists\n+      // present through the leaf (i.e. no structs).\n+      // Upper level code only calls this method\n+      // when the leaf-values are nullable (otherwise no spacing is needed),\n+      // Because only nested lists exists it is sufficient to know that the field\n+      // was either null or included it (i.e. >= previous definition level -> > previous\n+      // definition - 1). If there where structs mixed in, we need to know the def_level\n\nReview comment:\n       fix comment should \"- 2\"\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-23T07:27:34.026+0000",
                    "updated": "2020-04-23T07:27:34.026+0000",
                    "started": "2020-04-23T07:27:34.026+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426402",
                    "issueId": "13297951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297951/worklog/426403",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #6985:\nURL: https://github.com/apache/arrow/pull/6985#discussion_r413576031\n\n\n\n##########\nFile path: cpp/src/parquet/column_reader.cc\n##########\n@@ -50,6 +51,140 @@ using arrow::internal::checked_cast;\n \n namespace parquet {\n \n+namespace {\n+\n+inline void CheckLevelRange(const int16_t* levels, int64_t num_levels,\n+                            const int16_t max_expected_level) {\n+  int16_t min_level = std::numeric_limits<int16_t>::max();\n+  int16_t max_level = std::numeric_limits<int16_t>::min();\n+  for (int x = 0; x < num_levels; x++) {\n+    min_level = std::min(levels[x], min_level);\n+    max_level = std::max(levels[x], max_level);\n+  }\n+  if (ARROW_PREDICT_FALSE(num_levels > 0 && (min_level < 0 || max_level > max_level))) {\n+    throw ParquetException(\"definition level exceeds maximum\");\n+  }\n+}\n+\n+#if !defined(ARROW_HAVE_BMI2)\n+\n+inline void DefinitionLevelsToBitmapScalar(\n+    const int16_t* def_levels, int64_t num_def_levels, const int16_t max_definition_level,\n+    const int16_t max_repetition_level, int64_t* values_read, int64_t* null_count,\n+    uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  // We assume here that valid_bits is large enough to accommodate the\n+  // additional definition levels and the ones that have already been written\n+  ::arrow::internal::BitmapWriter valid_bits_writer(valid_bits, valid_bits_offset,\n+                                                    num_def_levels);\n+\n+  // TODO(itaiin): As an interim solution we are splitting the code path here\n+  // between repeated+flat column reads, and non-repeated+nested reads.\n+  // Those paths need to be merged in the future\n+  for (int i = 0; i < num_def_levels; ++i) {\n+    if (def_levels[i] == max_definition_level) {\n+      valid_bits_writer.Set();\n+    } else if (max_repetition_level > 0) {\n+      // repetition+flat case\n+      if (def_levels[i] == (max_definition_level - 1)) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        continue;\n+      }\n+    } else {\n+      // non-repeated+nested case\n+      if (def_levels[i] < max_definition_level) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        throw ParquetException(\"definition level exceeds maximum\");\n+      }\n+    }\n+\n+    valid_bits_writer.Next();\n+  }\n+  valid_bits_writer.Finish();\n+  *values_read = valid_bits_writer.position();\n+}\n+#endif\n+\n+template <bool has_repeated_parent>\n+void DefinitionLevelsToBitmapSimd(const int16_t* def_levels, int64_t num_def_levels,\n+                                  const int16_t required_definition_level,\n+                                  int64_t* values_read, int64_t* null_count,\n+                                  uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  constexpr int64_t kBitMaskSize = 64;\n+  int64_t set_count = 0;\n+  *values_read = 0;\n+  while (num_def_levels > 0) {\n+    int64_t batch_size = std::min(num_def_levels, kBitMaskSize);\n+    CheckLevelRange(def_levels, batch_size, required_definition_level);\n+    uint64_t defined_bitmap = internal::GreaterThanBitmap(def_levels, batch_size,\n+                                                          required_definition_level - 1);\n+    if (has_repeated_parent) {\n+      // This is currently a specialized code path assuming only (nested) lists\n+      // present through the leaf (i.e. no structs).\n+      // Upper level code only calls this method\n+      // when the leaf-values are nullable (otherwise no spacing is needed),\n+      // Because only nested lists exists it is sufficient to know that the field\n+      // was either null or included it (i.e. >= previous definition level -> > previous\n+      // definition - 1). If there where structs mixed in, we need to know the def_level\n\nReview comment:\n       fix comment should \"- 2\"\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-23T07:27:57.678+0000",
                    "updated": "2020-04-23T07:27:57.678+0000",
                    "started": "2020-04-23T07:27:57.678+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426403",
                    "issueId": "13297951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297951/worklog/426404",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #6985:\nURL: https://github.com/apache/arrow/pull/6985#discussion_r413576741\n\n\n\n##########\nFile path: cpp/src/parquet/column_reader.cc\n##########\n@@ -50,6 +51,140 @@ using arrow::internal::checked_cast;\n \n namespace parquet {\n \n+namespace {\n+\n+inline void CheckLevelRange(const int16_t* levels, int64_t num_levels,\n+                            const int16_t max_expected_level) {\n+  int16_t min_level = std::numeric_limits<int16_t>::max();\n+  int16_t max_level = std::numeric_limits<int16_t>::min();\n+  for (int x = 0; x < num_levels; x++) {\n+    min_level = std::min(levels[x], min_level);\n+    max_level = std::max(levels[x], max_level);\n+  }\n+  if (ARROW_PREDICT_FALSE(num_levels > 0 && (min_level < 0 || max_level > max_level))) {\n+    throw ParquetException(\"definition level exceeds maximum\");\n+  }\n+}\n+\n+#if !defined(ARROW_HAVE_BMI2)\n+\n+inline void DefinitionLevelsToBitmapScalar(\n+    const int16_t* def_levels, int64_t num_def_levels, const int16_t max_definition_level,\n+    const int16_t max_repetition_level, int64_t* values_read, int64_t* null_count,\n+    uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  // We assume here that valid_bits is large enough to accommodate the\n+  // additional definition levels and the ones that have already been written\n+  ::arrow::internal::BitmapWriter valid_bits_writer(valid_bits, valid_bits_offset,\n+                                                    num_def_levels);\n+\n+  // TODO(itaiin): As an interim solution we are splitting the code path here\n+  // between repeated+flat column reads, and non-repeated+nested reads.\n+  // Those paths need to be merged in the future\n+  for (int i = 0; i < num_def_levels; ++i) {\n+    if (def_levels[i] == max_definition_level) {\n+      valid_bits_writer.Set();\n+    } else if (max_repetition_level > 0) {\n+      // repetition+flat case\n+      if (def_levels[i] == (max_definition_level - 1)) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        continue;\n+      }\n+    } else {\n+      // non-repeated+nested case\n+      if (def_levels[i] < max_definition_level) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        throw ParquetException(\"definition level exceeds maximum\");\n+      }\n+    }\n+\n+    valid_bits_writer.Next();\n+  }\n+  valid_bits_writer.Finish();\n+  *values_read = valid_bits_writer.position();\n+}\n+#endif\n+\n+template <bool has_repeated_parent>\n+void DefinitionLevelsToBitmapSimd(const int16_t* def_levels, int64_t num_def_levels,\n+                                  const int16_t required_definition_level,\n+                                  int64_t* values_read, int64_t* null_count,\n+                                  uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  constexpr int64_t kBitMaskSize = 64;\n+  int64_t set_count = 0;\n+  *values_read = 0;\n+  while (num_def_levels > 0) {\n+    int64_t batch_size = std::min(num_def_levels, kBitMaskSize);\n+    CheckLevelRange(def_levels, batch_size, required_definition_level);\n+    uint64_t defined_bitmap = internal::GreaterThanBitmap(def_levels, batch_size,\n+                                                          required_definition_level - 1);\n+    if (has_repeated_parent) {\n+      // This is currently a specialized code path assuming only (nested) lists\n+      // present through the leaf (i.e. no structs).\n+      // Upper level code only calls this method\n+      // when the leaf-values are nullable (otherwise no spacing is needed),\n+      // Because only nested lists exists it is sufficient to know that the field\n+      // was either null or included it (i.e. >= previous definition level -> > previous\n+      // definition - 1). If there where structs mixed in, we need to know the def_level\n\nReview comment:\n       I think \"- 1\" might be confusing here because we subtract below.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-23T07:28:41.204+0000",
                    "updated": "2020-04-23T07:28:41.204+0000",
                    "started": "2020-04-23T07:28:41.204+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426404",
                    "issueId": "13297951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297951/worklog/426405",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on issue #6985:\nURL: https://github.com/apache/arrow/pull/6985#issuecomment-618231752\n\n\n   CC @wesm @pitrou I think this is ready for review now.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-23T07:30:49.429+0000",
                    "updated": "2020-04-23T07:30:49.429+0000",
                    "started": "2020-04-23T07:30:49.429+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426405",
                    "issueId": "13297951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297951/worklog/426407",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield edited a comment on issue #6985:\nURL: https://github.com/apache/arrow/pull/6985#issuecomment-618231752\n\n\n   CC @wesm @pitrou I think this is ready for review now. Will take a closer look at CI failures tomorrow.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-23T07:33:47.856+0000",
                    "updated": "2020-04-23T07:33:47.856+0000",
                    "started": "2020-04-23T07:33:47.855+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426407",
                    "issueId": "13297951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297951/worklog/426460",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #6985:\nURL: https://github.com/apache/arrow/pull/6985#discussion_r413696312\n\n\n\n##########\nFile path: cpp/cmake_modules/SetupCxxFlags.cmake\n##########\n@@ -40,12 +40,13 @@ if(ARROW_CPU_FLAG STREQUAL \"x86\")\n     set(CXX_SUPPORTS_SSE4_2 TRUE)\n   else()\n     set(ARROW_SSE4_2_FLAG \"-msse4.2\")\n-    set(ARROW_AVX2_FLAG \"-mavx2\")\n+    set(ARROW_AVX2_FLAG \"-march=core-avx2\")\n\nReview comment:\n       It would be nice if you could try again.\n\n##########\nFile path: cpp/cmake_modules/SetupCxxFlags.cmake\n##########\n@@ -40,12 +40,13 @@ if(ARROW_CPU_FLAG STREQUAL \"x86\")\n     set(CXX_SUPPORTS_SSE4_2 TRUE)\n   else()\n     set(ARROW_SSE4_2_FLAG \"-msse4.2\")\n-    set(ARROW_AVX2_FLAG \"-mavx2\")\n+    set(ARROW_AVX2_FLAG \"-march=core-avx2\")\n     # skylake-avx512 consists of AVX512F,AVX512BW,AVX512VL,AVX512CD,AVX512DQ\n     set(ARROW_AVX512_FLAG \"-march=skylake-avx512\")\n     check_cxx_compiler_flag(${ARROW_SSE4_2_FLAG} CXX_SUPPORTS_SSE4_2)\n   endif()\n   check_cxx_compiler_flag(${ARROW_AVX2_FLAG} CXX_SUPPORTS_AVX2)\n+  check_cxx_compiler_flag(${ARROW_AVX2_FLAG} CXX_SUPPORTS_AVX2)\n\nReview comment:\n       This doesn't seem useful :-)\n\n##########\nFile path: cpp/src/parquet/column_reader.cc\n##########\n@@ -50,6 +51,140 @@ using arrow::internal::checked_cast;\n \n namespace parquet {\n \n+namespace {\n+\n+inline void CheckLevelRange(const int16_t* levels, int64_t num_levels,\n+                            const int16_t max_expected_level) {\n+  int16_t min_level = std::numeric_limits<int16_t>::max();\n+  int16_t max_level = std::numeric_limits<int16_t>::min();\n+  for (int x = 0; x < num_levels; x++) {\n+    min_level = std::min(levels[x], min_level);\n+    max_level = std::max(levels[x], max_level);\n+  }\n+  if (ARROW_PREDICT_FALSE(num_levels > 0 && (min_level < 0 || max_level > max_level))) {\n+    throw ParquetException(\"definition level exceeds maximum\");\n+  }\n+}\n+\n+#if !defined(ARROW_HAVE_BMI2)\n+\n+inline void DefinitionLevelsToBitmapScalar(\n+    const int16_t* def_levels, int64_t num_def_levels, const int16_t max_definition_level,\n+    const int16_t max_repetition_level, int64_t* values_read, int64_t* null_count,\n+    uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  // We assume here that valid_bits is large enough to accommodate the\n+  // additional definition levels and the ones that have already been written\n+  ::arrow::internal::BitmapWriter valid_bits_writer(valid_bits, valid_bits_offset,\n+                                                    num_def_levels);\n+\n+  // TODO(itaiin): As an interim solution we are splitting the code path here\n+  // between repeated+flat column reads, and non-repeated+nested reads.\n+  // Those paths need to be merged in the future\n+  for (int i = 0; i < num_def_levels; ++i) {\n+    if (def_levels[i] == max_definition_level) {\n+      valid_bits_writer.Set();\n+    } else if (max_repetition_level > 0) {\n+      // repetition+flat case\n+      if (def_levels[i] == (max_definition_level - 1)) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        continue;\n+      }\n+    } else {\n+      // non-repeated+nested case\n+      if (def_levels[i] < max_definition_level) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        throw ParquetException(\"definition level exceeds maximum\");\n+      }\n+    }\n+\n+    valid_bits_writer.Next();\n+  }\n+  valid_bits_writer.Finish();\n+  *values_read = valid_bits_writer.position();\n+}\n+#endif\n+\n+template <bool has_repeated_parent>\n+void DefinitionLevelsToBitmapSimd(const int16_t* def_levels, int64_t num_def_levels,\n+                                  const int16_t required_definition_level,\n+                                  int64_t* values_read, int64_t* null_count,\n+                                  uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  constexpr int64_t kBitMaskSize = 64;\n+  int64_t set_count = 0;\n+  *values_read = 0;\n+  while (num_def_levels > 0) {\n+    int64_t batch_size = std::min(num_def_levels, kBitMaskSize);\n+    CheckLevelRange(def_levels, batch_size, required_definition_level);\n+    uint64_t defined_bitmap = internal::GreaterThanBitmap(def_levels, batch_size,\n+                                                          required_definition_level - 1);\n+    if (has_repeated_parent) {\n+      // This is currently a specialized code path assuming only (nested) lists\n+      // present through the leaf (i.e. no structs).\n+      // Upper level code only calls this method\n+      // when the leaf-values are nullable (otherwise no spacing is needed),\n+      // Because only nested lists exists it is sufficient to know that the field\n+      // was either null or included it (i.e. >= previous definition level -> > previous\n+      // definition - 1). If there where structs mixed in, we need to know the def_level\n+      // of the repeated parent so we can check for def_level > \"def level of repeated\n+      // parent\".\n+      uint64_t present_bitmap = internal::GreaterThanBitmap(\n+          def_levels, batch_size, required_definition_level - 2);\n+      *values_read += internal::AppendSelectedBitsToValidityBitmap(\n+          /*new_bits=*/defined_bitmap,\n+          /*selection_bitmap*/ present_bitmap, valid_bits, &valid_bits_offset,\n+          &set_count);\n+    } else {\n+      internal::AppendToValidityBitmap(\n+          /*new_bits=*/defined_bitmap,\n+          /*new_bit_count=*/batch_size, valid_bits, &valid_bits_offset, &set_count);\n+      *values_read += batch_size;\n+    }\n+    def_levels += batch_size;\n+    num_def_levels -= batch_size;\n+  }\n+  *null_count += *values_read - set_count;\n+}\n+\n+inline void DefinitionLevelsToBitmapDispatch(\n+    const int16_t* def_levels, int64_t num_def_levels, const int16_t max_definition_level,\n+    const int16_t max_repetition_level, int64_t* values_read, int64_t* null_count,\n+    uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  if (max_repetition_level > 0) {\n+#if ARROW_LITTLE_ENDIAN\n+\n+#if defined(ARROW_HAVE_BMI2)\n+    // BMI2 is required for efficient bit extraction.\n+    DefinitionLevelsToBitmapSimd</*has_repeated_parent=*/true>(\n+        def_levels, num_def_levels, max_definition_level, values_read, null_count,\n+        valid_bits, valid_bits_offset);\n+#else\n+    DefinitionLevelsToBitmapScalar(def_levels, num_def_levels, max_definition_level,\n+                                   max_repetition_level, values_read, null_count,\n+                                   valid_bits, valid_bits_offset);\n+#endif  // ARROW_HAVE_BMI2\n+\n+  } else {\n+    // No Special intsturction are used for non-repeated case.\n\nReview comment:\n       \"instructions\"\n\n##########\nFile path: cpp/src/parquet/column_reader.cc\n##########\n@@ -50,6 +51,140 @@ using arrow::internal::checked_cast;\n \n namespace parquet {\n \n+namespace {\n+\n+inline void CheckLevelRange(const int16_t* levels, int64_t num_levels,\n\nReview comment:\n       I think it would be nice to move the low-level handling of levels to a dedicated C++ file.\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -0,0 +1,191 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include \"arrow/util/bit_util.h\"\n+\n+#if defined(ARROW_HAVE_BMI2)\n+#include \"x86intrin.h\"\n+#endif\n+\n+namespace parquet {\n+namespace internal {\n+// These APIs are likely to be revised as part of ARROW-8494 to reduce duplicate code.\n+// They currently represent minimal functionality for vectorized computation of definition\n+// levels.\n+\n+/// Builds a bitmap by applying predicate to the level vector provided.\n+///\n+/// \\param[in] levels Rep or def level array.\n+/// \\param[in] num_levels The number of levels to process (must be [0, 64])\n+/// \\param[in] predicate The predicate to apply (must have the signature `bool\n+/// predicate(int16_t)`.\n+/// \\returns The bitmap using least significant \"bit\" ordering.\n+///\n+/// N.B. Correct byte ordering is dependent on little-endian architectures.\n+///\n+template <typename Predicate>\n+uint64_t LevelsToBitmap(const int16_t* levels, int64_t num_levels, Predicate predicate) {\n+  // Both clang and GCC can vectorize this automatically with AVX2.\n+  uint64_t mask = 0;\n+  for (int x = 0; x < num_levels; x++) {\n+    mask |= static_cast<int64_t>(predicate(levels[x]) ? 1 : 0) << x;\n+  }\n+  return mask;\n+}\n+\n+/// Builds a  bitmap where each set bit indicates the correspond level is greater\n+/// than rhs.\n+static inline int64_t GreaterThanBitmap(const int16_t* levels, int64_t num_levels,\n\nReview comment:\n       Why does it return `int64_t` rather than `uint64_t`?\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -0,0 +1,191 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include \"arrow/util/bit_util.h\"\n+\n+#if defined(ARROW_HAVE_BMI2)\n+#include \"x86intrin.h\"\n+#endif\n+\n+namespace parquet {\n+namespace internal {\n+// These APIs are likely to be revised as part of ARROW-8494 to reduce duplicate code.\n+// They currently represent minimal functionality for vectorized computation of definition\n+// levels.\n+\n+/// Builds a bitmap by applying predicate to the level vector provided.\n+///\n+/// \\param[in] levels Rep or def level array.\n+/// \\param[in] num_levels The number of levels to process (must be [0, 64])\n+/// \\param[in] predicate The predicate to apply (must have the signature `bool\n+/// predicate(int16_t)`.\n+/// \\returns The bitmap using least significant \"bit\" ordering.\n+///\n+/// N.B. Correct byte ordering is dependent on little-endian architectures.\n+///\n+template <typename Predicate>\n+uint64_t LevelsToBitmap(const int16_t* levels, int64_t num_levels, Predicate predicate) {\n+  // Both clang and GCC can vectorize this automatically with AVX2.\n+  uint64_t mask = 0;\n+  for (int x = 0; x < num_levels; x++) {\n+    mask |= static_cast<int64_t>(predicate(levels[x]) ? 1 : 0) << x;\n+  }\n+  return mask;\n+}\n+\n+/// Builds a  bitmap where each set bit indicates the correspond level is greater\n+/// than rhs.\n+static inline int64_t GreaterThanBitmap(const int16_t* levels, int64_t num_levels,\n+                                        int16_t rhs) {\n+  return LevelsToBitmap(levels, num_levels, [&](int16_t value) { return value > rhs; });\n+}\n+\n+/// Append bits number_of_bits from new_bits to valid_bits and valid_bits_offset.\n+///\n+/// \\param[in] new_bits The zero-padded bitmap to append.\n+/// \\param[in] number_of_bits The number of bits to append from new_bits.\n+/// \\param[in] valid_bits_length The number of bytes allocated in valid_bits.\n+/// \\param[in] valid_bits_offset The bit-offset at which to start appending new bits.\n+/// \\param[in,out] valid_bits The validity bitmap to append to.\n+/// \\returns The new bit offset inside of valid_bits.\n+static inline int64_t AppendBitmap(uint64_t new_bits, int64_t number_of_bits,\n\nReview comment:\n       Function name is far too generic. How about `AppendWordToBitmap`?\n\n##########\nFile path: cpp/src/parquet/level_conversion_test.cc\n##########\n@@ -0,0 +1,162 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"parquet/level_conversion.h\"\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+\n+#include <string>\n+\n+#include \"arrow/util/bit_util.h\"\n+\n+namespace parquet {\n+namespace internal {\n+\n+using ::testing::ElementsAreArray;\n+\n+std::string ToString(const uint8_t* bitmap, int64_t bit_count) {\n\nReview comment:\n       Please, a more specific name (such as `BitmapToString`).\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -0,0 +1,191 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include \"arrow/util/bit_util.h\"\n+\n+#if defined(ARROW_HAVE_BMI2)\n+#include \"x86intrin.h\"\n+#endif\n+\n+namespace parquet {\n+namespace internal {\n+// These APIs are likely to be revised as part of ARROW-8494 to reduce duplicate code.\n+// They currently represent minimal functionality for vectorized computation of definition\n+// levels.\n+\n+/// Builds a bitmap by applying predicate to the level vector provided.\n+///\n+/// \\param[in] levels Rep or def level array.\n+/// \\param[in] num_levels The number of levels to process (must be [0, 64])\n+/// \\param[in] predicate The predicate to apply (must have the signature `bool\n+/// predicate(int16_t)`.\n+/// \\returns The bitmap using least significant \"bit\" ordering.\n+///\n+/// N.B. Correct byte ordering is dependent on little-endian architectures.\n+///\n+template <typename Predicate>\n+uint64_t LevelsToBitmap(const int16_t* levels, int64_t num_levels, Predicate predicate) {\n+  // Both clang and GCC can vectorize this automatically with AVX2.\n+  uint64_t mask = 0;\n+  for (int x = 0; x < num_levels; x++) {\n+    mask |= static_cast<int64_t>(predicate(levels[x]) ? 1 : 0) << x;\n+  }\n+  return mask;\n+}\n+\n+/// Builds a  bitmap where each set bit indicates the correspond level is greater\n+/// than rhs.\n+static inline int64_t GreaterThanBitmap(const int16_t* levels, int64_t num_levels,\n+                                        int16_t rhs) {\n+  return LevelsToBitmap(levels, num_levels, [&](int16_t value) { return value > rhs; });\n+}\n+\n+/// Append bits number_of_bits from new_bits to valid_bits and valid_bits_offset.\n+///\n+/// \\param[in] new_bits The zero-padded bitmap to append.\n\nReview comment:\n       \"zero-padded\" doesn't give a clue. Are the `number_of_bits` LSBs appended?\n\n##########\nFile path: cpp/src/parquet/level_conversion_test.cc\n##########\n@@ -0,0 +1,162 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"parquet/level_conversion.h\"\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+\n+#include <string>\n+\n+#include \"arrow/util/bit_util.h\"\n+\n+namespace parquet {\n+namespace internal {\n+\n+using ::testing::ElementsAreArray;\n+\n+std::string ToString(const uint8_t* bitmap, int64_t bit_count) {\n+  return arrow::internal::Bitmap(bitmap, /*offset*/ 0, /*length=*/bit_count).ToString();\n+}\n+\n+std::string ToString(const std::vector<uint8_t>& bitmap, int64_t bit_count) {\n\nReview comment:\n       Ditto here.\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -0,0 +1,191 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include \"arrow/util/bit_util.h\"\n+\n+#if defined(ARROW_HAVE_BMI2)\n+#include \"x86intrin.h\"\n+#endif\n+\n+namespace parquet {\n+namespace internal {\n+// These APIs are likely to be revised as part of ARROW-8494 to reduce duplicate code.\n+// They currently represent minimal functionality for vectorized computation of definition\n+// levels.\n+\n+/// Builds a bitmap by applying predicate to the level vector provided.\n+///\n+/// \\param[in] levels Rep or def level array.\n+/// \\param[in] num_levels The number of levels to process (must be [0, 64])\n+/// \\param[in] predicate The predicate to apply (must have the signature `bool\n+/// predicate(int16_t)`.\n+/// \\returns The bitmap using least significant \"bit\" ordering.\n+///\n+/// N.B. Correct byte ordering is dependent on little-endian architectures.\n+///\n+template <typename Predicate>\n+uint64_t LevelsToBitmap(const int16_t* levels, int64_t num_levels, Predicate predicate) {\n+  // Both clang and GCC can vectorize this automatically with AVX2.\n+  uint64_t mask = 0;\n+  for (int x = 0; x < num_levels; x++) {\n+    mask |= static_cast<int64_t>(predicate(levels[x]) ? 1 : 0) << x;\n+  }\n+  return mask;\n+}\n+\n+/// Builds a  bitmap where each set bit indicates the correspond level is greater\n\nReview comment:\n       \"corresponding\"?\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -0,0 +1,191 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include \"arrow/util/bit_util.h\"\n+\n+#if defined(ARROW_HAVE_BMI2)\n+#include \"x86intrin.h\"\n+#endif\n+\n+namespace parquet {\n+namespace internal {\n+// These APIs are likely to be revised as part of ARROW-8494 to reduce duplicate code.\n+// They currently represent minimal functionality for vectorized computation of definition\n+// levels.\n+\n+/// Builds a bitmap by applying predicate to the level vector provided.\n+///\n+/// \\param[in] levels Rep or def level array.\n+/// \\param[in] num_levels The number of levels to process (must be [0, 64])\n+/// \\param[in] predicate The predicate to apply (must have the signature `bool\n+/// predicate(int16_t)`.\n+/// \\returns The bitmap using least significant \"bit\" ordering.\n+///\n+/// N.B. Correct byte ordering is dependent on little-endian architectures.\n+///\n+template <typename Predicate>\n+uint64_t LevelsToBitmap(const int16_t* levels, int64_t num_levels, Predicate predicate) {\n+  // Both clang and GCC can vectorize this automatically with AVX2.\n+  uint64_t mask = 0;\n+  for (int x = 0; x < num_levels; x++) {\n+    mask |= static_cast<int64_t>(predicate(levels[x]) ? 1 : 0) << x;\n+  }\n+  return mask;\n+}\n+\n+/// Builds a  bitmap where each set bit indicates the correspond level is greater\n+/// than rhs.\n+static inline int64_t GreaterThanBitmap(const int16_t* levels, int64_t num_levels,\n+                                        int16_t rhs) {\n+  return LevelsToBitmap(levels, num_levels, [&](int16_t value) { return value > rhs; });\n+}\n+\n+/// Append bits number_of_bits from new_bits to valid_bits and valid_bits_offset.\n+///\n+/// \\param[in] new_bits The zero-padded bitmap to append.\n+/// \\param[in] number_of_bits The number of bits to append from new_bits.\n+/// \\param[in] valid_bits_length The number of bytes allocated in valid_bits.\n+/// \\param[in] valid_bits_offset The bit-offset at which to start appending new bits.\n+/// \\param[in,out] valid_bits The validity bitmap to append to.\n+/// \\returns The new bit offset inside of valid_bits.\n+static inline int64_t AppendBitmap(uint64_t new_bits, int64_t number_of_bits,\n+                                   int64_t valid_bits_length, int64_t valid_bits_offset,\n+                                   uint8_t* valid_bits) {\n+  // Selection masks to retrieve all low order bits for each bytes.\n+  constexpr uint64_t kLsbSelectionMasks[] = {\n+      0,  // unused.\n+      0x0101010101010101,\n+      0x0303030303030303,\n+      0x0707070707070707,\n+      0x0F0F0F0F0F0F0F0F,\n+      0x1F1F1F1F1F1F1F1F,\n+      0x3F3F3F3F3F3F3F3F,\n+      0x7F7F7F7F7F7F7F7F,\n+  };\n+  int64_t valid_byte_offset = valid_bits_offset / 8;\n+  int64_t bit_offset = valid_bits_offset % 8;\n+\n+  int64_t new_offset = valid_bits_offset + number_of_bits;\n+  union ByteAddressableBitmap {\n+    explicit ByteAddressableBitmap(uint64_t mask) : mask(mask) {}\n+    uint64_t mask;\n+    uint8_t bytes[8];\n+  };\n+\n+  if (bit_offset != 0) {\n+    int64_t bits_to_carry = 8 - bit_offset;\n+    // Get the mask the will select the lower order bits  (the ones to carry\n+    // over to the existing byte and shift up.\n+    const ByteAddressableBitmap carry_bits(kLsbSelectionMasks[bits_to_carry]);\n+    // Mask to select non-carried bits.\n+    const ByteAddressableBitmap inverse_selection(~carry_bits.mask);\n+    // Fill out the last incomplete byte in the output, by extracting the least\n+    // siginficant bits from the first byte.\n+    const ByteAddressableBitmap new_bitmap(new_bits);\n+    // valid bits should be a valid bitmask so all trailing bytes hsould be unset\n+    // so no mask is need to start.\n+    valid_bits[valid_byte_offset] =\n+        valid_bits[valid_byte_offset] |  // See above the\n+        (((new_bitmap.bytes[0] & carry_bits.bytes[0])) << bit_offset);\n+\n+    // We illustrate logic with a 3-byte example in little endian/LSB order.\n+    // Note this ordering is the reversed from HEX masks above with are expressed\n+    // big-endian/MSB and shifts right move the bits to the left (division).\n+    // 0  1  2  3  4  5  6  7   8  9  10 11 12 13 14 15   16 17 18 19 20 21 22 23\n+    // Shifted mask should look like this assuming bit offset = 6:\n+    // 2  3  4  5  6  7  N  N   10 11 12 13 14 15  N  N   18 19 20 21 22 23  N  N\n\nReview comment:\n       ??? Why are the \"N\"s lost here?\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -0,0 +1,191 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include \"arrow/util/bit_util.h\"\n+\n+#if defined(ARROW_HAVE_BMI2)\n+#include \"x86intrin.h\"\n+#endif\n+\n+namespace parquet {\n+namespace internal {\n+// These APIs are likely to be revised as part of ARROW-8494 to reduce duplicate code.\n+// They currently represent minimal functionality for vectorized computation of definition\n+// levels.\n+\n+/// Builds a bitmap by applying predicate to the level vector provided.\n+///\n+/// \\param[in] levels Rep or def level array.\n+/// \\param[in] num_levels The number of levels to process (must be [0, 64])\n+/// \\param[in] predicate The predicate to apply (must have the signature `bool\n+/// predicate(int16_t)`.\n+/// \\returns The bitmap using least significant \"bit\" ordering.\n+///\n+/// N.B. Correct byte ordering is dependent on little-endian architectures.\n+///\n+template <typename Predicate>\n+uint64_t LevelsToBitmap(const int16_t* levels, int64_t num_levels, Predicate predicate) {\n+  // Both clang and GCC can vectorize this automatically with AVX2.\n+  uint64_t mask = 0;\n+  for (int x = 0; x < num_levels; x++) {\n+    mask |= static_cast<int64_t>(predicate(levels[x]) ? 1 : 0) << x;\n+  }\n+  return mask;\n+}\n+\n+/// Builds a  bitmap where each set bit indicates the correspond level is greater\n+/// than rhs.\n+static inline int64_t GreaterThanBitmap(const int16_t* levels, int64_t num_levels,\n+                                        int16_t rhs) {\n+  return LevelsToBitmap(levels, num_levels, [&](int16_t value) { return value > rhs; });\n+}\n+\n+/// Append bits number_of_bits from new_bits to valid_bits and valid_bits_offset.\n+///\n+/// \\param[in] new_bits The zero-padded bitmap to append.\n+/// \\param[in] number_of_bits The number of bits to append from new_bits.\n+/// \\param[in] valid_bits_length The number of bytes allocated in valid_bits.\n+/// \\param[in] valid_bits_offset The bit-offset at which to start appending new bits.\n+/// \\param[in,out] valid_bits The validity bitmap to append to.\n+/// \\returns The new bit offset inside of valid_bits.\n+static inline int64_t AppendBitmap(uint64_t new_bits, int64_t number_of_bits,\n+                                   int64_t valid_bits_length, int64_t valid_bits_offset,\n+                                   uint8_t* valid_bits) {\n+  // Selection masks to retrieve all low order bits for each bytes.\n+  constexpr uint64_t kLsbSelectionMasks[] = {\n\nReview comment:\n       This entire function looks cryptic.\r\n   1) ideally this would be in `bit-util.h`\r\n   2) why not add something like a `AppendWord(uint64_t word, int64_t nbits)` to `BitmapWriter` or `FirstTimeBitmapWriter`?\r\n   3) the implementation looks gratuitously complicated\r\n   \n\n##########\nFile path: cpp/src/parquet/level_conversion_test.cc\n##########\n@@ -0,0 +1,162 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"parquet/level_conversion.h\"\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+\n+#include <string>\n+\n+#include \"arrow/util/bit_util.h\"\n+\n+namespace parquet {\n+namespace internal {\n+\n+using ::testing::ElementsAreArray;\n+\n+std::string ToString(const uint8_t* bitmap, int64_t bit_count) {\n+  return arrow::internal::Bitmap(bitmap, /*offset*/ 0, /*length=*/bit_count).ToString();\n+}\n+\n+std::string ToString(const std::vector<uint8_t>& bitmap, int64_t bit_count) {\n+  return ToString(bitmap.data(), bit_count);\n+}\n+\n+TEST(TestGreaterThanBitmap, GeneratesExpectedBitmasks) {\n+  std::vector<int16_t> levels = {0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7,\n+                                 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7,\n+                                 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7,\n+                                 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7};\n+  EXPECT_EQ(GreaterThanBitmap(levels.data(), /*num_levels=*/0, /*rhs*/ 0), 0);\n+  EXPECT_EQ(GreaterThanBitmap(levels.data(), /*num_levels=*/64, /*rhs*/ 8), 0);\n+  EXPECT_EQ(GreaterThanBitmap(levels.data(), /*num_levels=*/64, /*rhs*/ -1),\n+            0xFFFFFFFFFFFFFFFF);\n+  // Should be zero padded.\n+  EXPECT_EQ(GreaterThanBitmap(levels.data(), /*num_levels=*/47, /*rhs*/ -1),\n+            0x7FFFFFFFFFFF);\n+  EXPECT_EQ(GreaterThanBitmap(levels.data(), /*num_levels=*/64, /*rhs*/ 6),\n+            0x8080808080808080);\n+}\n+\n+TEST(TestAppendBitmap, TestOffsetOverwritesCorrectBitsOnExistingByte) {\n+  auto check_append = [](const std::string& expected_bits, int64_t offset) {\n+    std::vector<uint8_t> valid_bits = {0x00};\n+    constexpr int64_t kBitsAfterAppend = 8;\n+    ASSERT_EQ(\n+        AppendBitmap(/*new_bits=*/0xFF, /*number_of_bits*/ 8 - offset,\n+                     /*valid_bits_length=*/valid_bits.size(), offset, valid_bits.data()),\n+        kBitsAfterAppend);\n+    EXPECT_EQ(ToString(valid_bits, kBitsAfterAppend), expected_bits);\n+  };\n+  check_append(\"11111111\", 0);\n+  check_append(\"01111111\", 1);\n+  check_append(\"00111111\", 2);\n+  check_append(\"00011111\", 3);\n+  check_append(\"00001111\", 4);\n+  check_append(\"00000111\", 5);\n+  check_append(\"00000011\", 6);\n+  check_append(\"00000001\", 7);\n+}\n+\n+TEST(TestAppendBitmap, TestOffsetShiftBitsCorrectly) {\n+  constexpr uint64_t kPattern = 0x9A9A9A9A9A9A9A9A;\n+  auto check_append = [&](const std::string& leading_bits, const std::string& middle_bits,\n+                          const std::string& trailing_bits, int64_t offset) {\n+    ASSERT_GE(offset, 8);\n+    std::vector<uint8_t> valid_bits(/*count=*/10, 0);\n+    valid_bits[0] = 0x99;\n+\n+    AppendBitmap(/*new_bits=*/kPattern, /*number_of_bits*/ 64,\n+                 /*valid_bits_length=*/valid_bits.size(), offset, valid_bits.data());\n+    EXPECT_EQ(valid_bits[0], 0x99);  // shouldn't get chanked.\n+    EXPECT_EQ(ToString(valid_bits.data() + 1, /*num_bits=*/8), leading_bits);\n+    for (int x = 2; x < 9; x++) {\n+      EXPECT_EQ(ToString(valid_bits.data() + x, /*num_bits=*/8), middle_bits);\n+    }\n+    EXPECT_EQ(ToString(valid_bits.data() + 9, /*num_bits=*/8), trailing_bits);\n+  };\n+  // Original Pattern = \"01011001\"\n+  check_append(/*leading_bits= */ \"01011001\", /*middle_bits=*/\"01011001\",\n+               /*trailing_bits=*/\"00000000\", /*offset=*/8);\n+  check_append(\"00101100\", \"10101100\", \"10000000\", 9);\n+  check_append(\"00010110\", \"01010110\", \"01000000\", 10);\n+  check_append(\"00001011\", \"00101011\", \"00100000\", 11);\n+  check_append(\"00000101\", \"10010101\", \"10010000\", 12);\n+  check_append(\"00000010\", \"11001010\", \"11001000\", 13);\n+  check_append(\"00000001\", \"01100101\", \"01100100\", 14);\n+  check_append(\"00000000\", \"10110010\", \"10110010\", 15);\n+}\n+\n+TEST(TestAppendBitmap, AllBytesAreWrittenWithEnoughSpace) {\n+  std::vector<uint8_t> valid_bits(/*count=*/9, 0);\n+\n+  uint64_t bitmap = 0xFFFFFFFFFFFFFFFF;\n+  AppendBitmap(bitmap, /*number_of_bits*/ 7,\n+               /*valid_bits_length=*/valid_bits.size(),\n+               /*valid_bits_offset=*/1,\n+               /*valid_bits=*/valid_bits.data());\n+  EXPECT_THAT(valid_bits, ElementsAreArray(std::vector<uint8_t>{\n+                              0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01}));\n+}\n+\n+TEST(TestAppendBitmap, OnlyApproriateBytesWrittenWhenLessThen8BytesAvailable) {\n+  std::vector<uint8_t> valid_bits = {0x00, 0x00};\n+\n+  uint64_t bitmap = 0x1FF;\n+  AppendBitmap(bitmap, /*number_of_bits*/ 7,\n+               /*valid_bits_length=*/2,\n+               /*valid_bits_offset=*/1,\n+               /*valid_bits=*/valid_bits.data());\n+\n+  EXPECT_THAT(valid_bits, ElementsAreArray(std::vector<uint8_t>{0xFE, 0x00}));\n+\n+  AppendBitmap(bitmap, /*number_of_bits*/ 9,\n+               /*valid_bits_length=*/2,\n+               /*valid_bits_offset=*/1,\n+               /*valid_bits=*/valid_bits.data());\n+  EXPECT_THAT(valid_bits, ElementsAreArray(std::vector<uint8_t>{0xFE, 0x03}));\n+}\n+\n+TEST(TestAppendToValidityBitmap, BasicOperation) {\n+  std::vector<uint8_t> validity_bitmap(/*count*/ 8, 0);\n+  int64_t valid_bitmap_offset = 1;\n+  int64_t set_bit_count = 5;\n+  AppendToValidityBitmap(/*new_bits*/ 0x99, /*new_bit_count=*/31, validity_bitmap.data(),\n+                         &valid_bitmap_offset, &set_bit_count);\n+  EXPECT_EQ(ToString(validity_bitmap, valid_bitmap_offset),\n+            \"01001100 10000000 00000000 00000000\");\n+  EXPECT_EQ(set_bit_count, /*5 + 4 set bits=*/9);\n+}\n+\n+TEST(TestAppendSelectedBitsToValidityBitmap, BasicOperation) {\n+#if !defined(ARROW_HAVE_BMI2)\n\nReview comment:\n       Then just don't define the test.\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -0,0 +1,191 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include \"arrow/util/bit_util.h\"\n+\n+#if defined(ARROW_HAVE_BMI2)\n+#include \"x86intrin.h\"\n+#endif\n+\n+namespace parquet {\n+namespace internal {\n+// These APIs are likely to be revised as part of ARROW-8494 to reduce duplicate code.\n+// They currently represent minimal functionality for vectorized computation of definition\n+// levels.\n+\n+/// Builds a bitmap by applying predicate to the level vector provided.\n+///\n+/// \\param[in] levels Rep or def level array.\n+/// \\param[in] num_levels The number of levels to process (must be [0, 64])\n+/// \\param[in] predicate The predicate to apply (must have the signature `bool\n+/// predicate(int16_t)`.\n+/// \\returns The bitmap using least significant \"bit\" ordering.\n+///\n+/// N.B. Correct byte ordering is dependent on little-endian architectures.\n+///\n+template <typename Predicate>\n+uint64_t LevelsToBitmap(const int16_t* levels, int64_t num_levels, Predicate predicate) {\n+  // Both clang and GCC can vectorize this automatically with AVX2.\n+  uint64_t mask = 0;\n+  for (int x = 0; x < num_levels; x++) {\n+    mask |= static_cast<int64_t>(predicate(levels[x]) ? 1 : 0) << x;\n+  }\n+  return mask;\n+}\n+\n+/// Builds a  bitmap where each set bit indicates the correspond level is greater\n+/// than rhs.\n+static inline int64_t GreaterThanBitmap(const int16_t* levels, int64_t num_levels,\n+                                        int16_t rhs) {\n+  return LevelsToBitmap(levels, num_levels, [&](int16_t value) { return value > rhs; });\n+}\n+\n+/// Append bits number_of_bits from new_bits to valid_bits and valid_bits_offset.\n+///\n+/// \\param[in] new_bits The zero-padded bitmap to append.\n+/// \\param[in] number_of_bits The number of bits to append from new_bits.\n+/// \\param[in] valid_bits_length The number of bytes allocated in valid_bits.\n+/// \\param[in] valid_bits_offset The bit-offset at which to start appending new bits.\n+/// \\param[in,out] valid_bits The validity bitmap to append to.\n+/// \\returns The new bit offset inside of valid_bits.\n+static inline int64_t AppendBitmap(uint64_t new_bits, int64_t number_of_bits,\n+                                   int64_t valid_bits_length, int64_t valid_bits_offset,\n+                                   uint8_t* valid_bits) {\n+  // Selection masks to retrieve all low order bits for each bytes.\n+  constexpr uint64_t kLsbSelectionMasks[] = {\n+      0,  // unused.\n+      0x0101010101010101,\n+      0x0303030303030303,\n+      0x0707070707070707,\n+      0x0F0F0F0F0F0F0F0F,\n+      0x1F1F1F1F1F1F1F1F,\n+      0x3F3F3F3F3F3F3F3F,\n+      0x7F7F7F7F7F7F7F7F,\n+  };\n+  int64_t valid_byte_offset = valid_bits_offset / 8;\n+  int64_t bit_offset = valid_bits_offset % 8;\n+\n+  int64_t new_offset = valid_bits_offset + number_of_bits;\n+  union ByteAddressableBitmap {\n+    explicit ByteAddressableBitmap(uint64_t mask) : mask(mask) {}\n+    uint64_t mask;\n+    uint8_t bytes[8];\n+  };\n+\n+  if (bit_offset != 0) {\n+    int64_t bits_to_carry = 8 - bit_offset;\n+    // Get the mask the will select the lower order bits  (the ones to carry\n+    // over to the existing byte and shift up.\n+    const ByteAddressableBitmap carry_bits(kLsbSelectionMasks[bits_to_carry]);\n+    // Mask to select non-carried bits.\n+    const ByteAddressableBitmap inverse_selection(~carry_bits.mask);\n+    // Fill out the last incomplete byte in the output, by extracting the least\n+    // siginficant bits from the first byte.\n+    const ByteAddressableBitmap new_bitmap(new_bits);\n+    // valid bits should be a valid bitmask so all trailing bytes hsould be unset\n+    // so no mask is need to start.\n+    valid_bits[valid_byte_offset] =\n+        valid_bits[valid_byte_offset] |  // See above the\n+        (((new_bitmap.bytes[0] & carry_bits.bytes[0])) << bit_offset);\n+\n+    // We illustrate logic with a 3-byte example in little endian/LSB order.\n+    // Note this ordering is the reversed from HEX masks above with are expressed\n+    // big-endian/MSB and shifts right move the bits to the left (division).\n+    // 0  1  2  3  4  5  6  7   8  9  10 11 12 13 14 15   16 17 18 19 20 21 22 23\n+    // Shifted mask should look like this assuming bit offset = 6:\n+    // 2  3  4  5  6  7  N  N   10 11 12 13 14 15  N  N   18 19 20 21 22 23  N  N\n+    // clang-format on\n+    uint64_t shifted_new_bits = (new_bits & inverse_selection.mask) >> bits_to_carry;\n+    // captured_carry:\n+    // 0  1  N  N  N  N  N  N   8  9  N  N  N   N  N  N   16 17  N  N  N  N  N  N\n+    uint64_t captured_carry = carry_bits.mask & new_bits;\n+    // mask_cary_bits:\n+    // N  N  N  N  N  N  8  9   N  N  N  N  N   N 16 17    N  N   N  N  N  N  N  N\n+    uint64_t mask_carry_bits = (captured_carry >> 8) << bit_offset;\n+\n+    new_bits = shifted_new_bits | mask_carry_bits;\n+    // Don't overwrite the first byte\n+    valid_byte_offset += 1;\n+    number_of_bits -= bits_to_carry;\n+  }\n+\n+  int64_t bytes_for_new_bits = ::arrow::BitUtil::BytesForBits(number_of_bits);\n+  if (valid_bits_length - ::arrow::BitUtil::BytesForBits(valid_bits_offset) >=\n+      static_cast<int64_t>(sizeof(new_bits))) {\n+    // This should be the common case and  inlined as a single instruction which\n+    // should be cheaper then the general case of calling mempcy, so it is likely\n+    // worth the extra branch.\n+    std::memcpy(valid_bits + valid_byte_offset, &new_bits, sizeof(new_bits));\n+  } else {\n+    std::memcpy(valid_bits + valid_byte_offset, &new_bits, bytes_for_new_bits);\n+  }\n+  return new_offset;\n+}\n+\n+/// \\brief Appends bit values to the validitdy bimap_valid bits, based on bitmaps\n+/// generated by GreaterThanBitmap, and the appropriate treshold definition_leve.\n\nReview comment:\n       I don't think it makes sense for this to be a helper function.\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -0,0 +1,191 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include \"arrow/util/bit_util.h\"\n+\n+#if defined(ARROW_HAVE_BMI2)\n+#include \"x86intrin.h\"\n+#endif\n+\n+namespace parquet {\n+namespace internal {\n+// These APIs are likely to be revised as part of ARROW-8494 to reduce duplicate code.\n+// They currently represent minimal functionality for vectorized computation of definition\n+// levels.\n+\n+/// Builds a bitmap by applying predicate to the level vector provided.\n+///\n+/// \\param[in] levels Rep or def level array.\n+/// \\param[in] num_levels The number of levels to process (must be [0, 64])\n+/// \\param[in] predicate The predicate to apply (must have the signature `bool\n+/// predicate(int16_t)`.\n+/// \\returns The bitmap using least significant \"bit\" ordering.\n+///\n+/// N.B. Correct byte ordering is dependent on little-endian architectures.\n+///\n+template <typename Predicate>\n+uint64_t LevelsToBitmap(const int16_t* levels, int64_t num_levels, Predicate predicate) {\n+  // Both clang and GCC can vectorize this automatically with AVX2.\n+  uint64_t mask = 0;\n+  for (int x = 0; x < num_levels; x++) {\n+    mask |= static_cast<int64_t>(predicate(levels[x]) ? 1 : 0) << x;\n+  }\n+  return mask;\n+}\n+\n+/// Builds a  bitmap where each set bit indicates the correspond level is greater\n+/// than rhs.\n+static inline int64_t GreaterThanBitmap(const int16_t* levels, int64_t num_levels,\n+                                        int16_t rhs) {\n+  return LevelsToBitmap(levels, num_levels, [&](int16_t value) { return value > rhs; });\n+}\n+\n+/// Append bits number_of_bits from new_bits to valid_bits and valid_bits_offset.\n+///\n+/// \\param[in] new_bits The zero-padded bitmap to append.\n+/// \\param[in] number_of_bits The number of bits to append from new_bits.\n+/// \\param[in] valid_bits_length The number of bytes allocated in valid_bits.\n+/// \\param[in] valid_bits_offset The bit-offset at which to start appending new bits.\n+/// \\param[in,out] valid_bits The validity bitmap to append to.\n+/// \\returns The new bit offset inside of valid_bits.\n+static inline int64_t AppendBitmap(uint64_t new_bits, int64_t number_of_bits,\n+                                   int64_t valid_bits_length, int64_t valid_bits_offset,\n+                                   uint8_t* valid_bits) {\n+  // Selection masks to retrieve all low order bits for each bytes.\n+  constexpr uint64_t kLsbSelectionMasks[] = {\n+      0,  // unused.\n+      0x0101010101010101,\n+      0x0303030303030303,\n+      0x0707070707070707,\n+      0x0F0F0F0F0F0F0F0F,\n+      0x1F1F1F1F1F1F1F1F,\n+      0x3F3F3F3F3F3F3F3F,\n+      0x7F7F7F7F7F7F7F7F,\n+  };\n+  int64_t valid_byte_offset = valid_bits_offset / 8;\n+  int64_t bit_offset = valid_bits_offset % 8;\n+\n+  int64_t new_offset = valid_bits_offset + number_of_bits;\n+  union ByteAddressableBitmap {\n+    explicit ByteAddressableBitmap(uint64_t mask) : mask(mask) {}\n+    uint64_t mask;\n+    uint8_t bytes[8];\n+  };\n+\n+  if (bit_offset != 0) {\n+    int64_t bits_to_carry = 8 - bit_offset;\n+    // Get the mask the will select the lower order bits  (the ones to carry\n+    // over to the existing byte and shift up.\n+    const ByteAddressableBitmap carry_bits(kLsbSelectionMasks[bits_to_carry]);\n+    // Mask to select non-carried bits.\n+    const ByteAddressableBitmap inverse_selection(~carry_bits.mask);\n+    // Fill out the last incomplete byte in the output, by extracting the least\n+    // siginficant bits from the first byte.\n+    const ByteAddressableBitmap new_bitmap(new_bits);\n+    // valid bits should be a valid bitmask so all trailing bytes hsould be unset\n+    // so no mask is need to start.\n+    valid_bits[valid_byte_offset] =\n+        valid_bits[valid_byte_offset] |  // See above the\n+        (((new_bitmap.bytes[0] & carry_bits.bytes[0])) << bit_offset);\n+\n+    // We illustrate logic with a 3-byte example in little endian/LSB order.\n+    // Note this ordering is the reversed from HEX masks above with are expressed\n+    // big-endian/MSB and shifts right move the bits to the left (division).\n+    // 0  1  2  3  4  5  6  7   8  9  10 11 12 13 14 15   16 17 18 19 20 21 22 23\n+    // Shifted mask should look like this assuming bit offset = 6:\n+    // 2  3  4  5  6  7  N  N   10 11 12 13 14 15  N  N   18 19 20 21 22 23  N  N\n+    // clang-format on\n+    uint64_t shifted_new_bits = (new_bits & inverse_selection.mask) >> bits_to_carry;\n+    // captured_carry:\n+    // 0  1  N  N  N  N  N  N   8  9  N  N  N   N  N  N   16 17  N  N  N  N  N  N\n+    uint64_t captured_carry = carry_bits.mask & new_bits;\n+    // mask_cary_bits:\n+    // N  N  N  N  N  N  8  9   N  N  N  N  N   N 16 17    N  N   N  N  N  N  N  N\n+    uint64_t mask_carry_bits = (captured_carry >> 8) << bit_offset;\n+\n+    new_bits = shifted_new_bits | mask_carry_bits;\n+    // Don't overwrite the first byte\n+    valid_byte_offset += 1;\n+    number_of_bits -= bits_to_carry;\n+  }\n+\n+  int64_t bytes_for_new_bits = ::arrow::BitUtil::BytesForBits(number_of_bits);\n+  if (valid_bits_length - ::arrow::BitUtil::BytesForBits(valid_bits_offset) >=\n+      static_cast<int64_t>(sizeof(new_bits))) {\n+    // This should be the common case and  inlined as a single instruction which\n+    // should be cheaper then the general case of calling mempcy, so it is likely\n+    // worth the extra branch.\n+    std::memcpy(valid_bits + valid_byte_offset, &new_bits, sizeof(new_bits));\n+  } else {\n+    std::memcpy(valid_bits + valid_byte_offset, &new_bits, bytes_for_new_bits);\n+  }\n+  return new_offset;\n+}\n+\n+/// \\brief Appends bit values to the validitdy bimap_valid bits, based on bitmaps\n+/// generated by GreaterThanBitmap, and the appropriate treshold definition_leve.\n+///\n+/// \\param[in] new_bits Bitmap to append (intrepreted as Little-endian/LSB).\n+/// \\param[in] new_bit_count The number of bits to append  from new_bits.\n+/// \\param[in,out] validity_bitmap The validity bitmap to update.\n+/// \\param[in,out] validity_bitmap_offset The offset to start appending bits to in\n+/// valid_bits (updated to latest bitmap).\n+/// \\param[in,out] set_bit_count The number of set bits appended is added to\n+/// set_bit_count.\n+void AppendToValidityBitmap(uint64_t new_bits, int64_t new_bit_count,\n+                            uint8_t* validity_bitmap, int64_t* validity_bitmap_offset,\n+                            int64_t* set_bit_count) {\n+  int64_t min_valid_bits_size =\n+      ::arrow::BitUtil::BytesForBits(new_bit_count + *validity_bitmap_offset);\n+\n+  *set_bit_count += ::arrow::BitUtil::PopCount(new_bits);\n+  *validity_bitmap_offset = AppendBitmap(new_bits, new_bit_count, min_valid_bits_size,\n+                                         *validity_bitmap_offset, validity_bitmap);\n+}\n+\n+/// The same as AppendToValidityBitmap but only appends bits from bitmap that have\n+/// a corresponding bit set in selection_bitmap.\n+///\n+/// \\returns The number of bits appended.\n+///\n+/// N.B. This is only implemented for archiectures that suppor the BMI2 instruction\n+/// set.\n+int64_t AppendSelectedBitsToValidityBitmap(uint64_t new_bits, uint64_t selection_bitmap,\n+                                           uint8_t* validity_bitmap,\n+                                           int64_t* validity_bitmap_offset,\n+                                           int64_t* set_bit_count) {\n+#if defined(ARROW_HAVE_BMI2)\n+  // If the parent list was empty at for the given slot it should not be added to the\n+  // bitmap.\n+  uint64_t selected_bits = _pext_u64(new_bits, selection_bitmap);\n+  int64_t selected_count =\n+      static_cast<int64_t>(::arrow::BitUtil::PopCount(selection_bitmap));\n+\n+  AppendToValidityBitmap(selected_bits, selected_count, validity_bitmap,\n+                         validity_bitmap_offset, set_bit_count);\n+  return selected_count;\n+#else\n+  // We shouldn't get here.\n\nReview comment:\n       Then please only define this function if `ARROW_HAVE_BMI2` is defined.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-23T10:45:55.880+0000",
                    "updated": "2020-04-23T10:45:55.880+0000",
                    "started": "2020-04-23T10:45:55.880+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426460",
                    "issueId": "13297951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297951/worklog/426575",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kiszk commented on a change in pull request #6985:\nURL: https://github.com/apache/arrow/pull/6985#discussion_r413905959\n\n\n\n##########\nFile path: cpp/src/parquet/column_reader.cc\n##########\n@@ -50,6 +51,140 @@ using arrow::internal::checked_cast;\n \n namespace parquet {\n \n+namespace {\n+\n+inline void CheckLevelRange(const int16_t* levels, int64_t num_levels,\n+                            const int16_t max_expected_level) {\n+  int16_t min_level = std::numeric_limits<int16_t>::max();\n+  int16_t max_level = std::numeric_limits<int16_t>::min();\n+  for (int x = 0; x < num_levels; x++) {\n+    min_level = std::min(levels[x], min_level);\n+    max_level = std::max(levels[x], max_level);\n+  }\n+  if (ARROW_PREDICT_FALSE(num_levels > 0 && (min_level < 0 || max_level > max_level))) {\n+    throw ParquetException(\"definition level exceeds maximum\");\n+  }\n+}\n+\n+#if !defined(ARROW_HAVE_BMI2)\n+\n+inline void DefinitionLevelsToBitmapScalar(\n+    const int16_t* def_levels, int64_t num_def_levels, const int16_t max_definition_level,\n+    const int16_t max_repetition_level, int64_t* values_read, int64_t* null_count,\n+    uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  // We assume here that valid_bits is large enough to accommodate the\n+  // additional definition levels and the ones that have already been written\n+  ::arrow::internal::BitmapWriter valid_bits_writer(valid_bits, valid_bits_offset,\n+                                                    num_def_levels);\n+\n+  // TODO(itaiin): As an interim solution we are splitting the code path here\n+  // between repeated+flat column reads, and non-repeated+nested reads.\n+  // Those paths need to be merged in the future\n+  for (int i = 0; i < num_def_levels; ++i) {\n+    if (def_levels[i] == max_definition_level) {\n+      valid_bits_writer.Set();\n+    } else if (max_repetition_level > 0) {\n+      // repetition+flat case\n+      if (def_levels[i] == (max_definition_level - 1)) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        continue;\n+      }\n+    } else {\n+      // non-repeated+nested case\n+      if (def_levels[i] < max_definition_level) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        throw ParquetException(\"definition level exceeds maximum\");\n+      }\n+    }\n+\n+    valid_bits_writer.Next();\n+  }\n+  valid_bits_writer.Finish();\n+  *values_read = valid_bits_writer.position();\n+}\n+#endif\n+\n+template <bool has_repeated_parent>\n+void DefinitionLevelsToBitmapSimd(const int16_t* def_levels, int64_t num_def_levels,\n+                                  const int16_t required_definition_level,\n+                                  int64_t* values_read, int64_t* null_count,\n+                                  uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  constexpr int64_t kBitMaskSize = 64;\n+  int64_t set_count = 0;\n+  *values_read = 0;\n+  while (num_def_levels > 0) {\n+    int64_t batch_size = std::min(num_def_levels, kBitMaskSize);\n+    CheckLevelRange(def_levels, batch_size, required_definition_level);\n+    uint64_t defined_bitmap = internal::GreaterThanBitmap(def_levels, batch_size,\n+                                                          required_definition_level - 1);\n+    if (has_repeated_parent) {\n+      // This is currently a specialized code path assuming only (nested) lists\n+      // present through the leaf (i.e. no structs).\n+      // Upper level code only calls this method\n+      // when the leaf-values are nullable (otherwise no spacing is needed),\n+      // Because only nested lists exists it is sufficient to know that the field\n+      // was either null or included it (i.e. >= previous definition level -> > previous\n+      // definition - 1). If there where structs mixed in, we need to know the def_level\n+      // of the repeated parent so we can check for def_level > \"def level of repeated\n+      // parent\".\n+      uint64_t present_bitmap = internal::GreaterThanBitmap(\n+          def_levels, batch_size, required_definition_level - 2);\n+      *values_read += internal::AppendSelectedBitsToValidityBitmap(\n+          /*new_bits=*/defined_bitmap,\n+          /*selection_bitmap*/ present_bitmap, valid_bits, &valid_bits_offset,\n+          &set_count);\n+    } else {\n+      internal::AppendToValidityBitmap(\n+          /*new_bits=*/defined_bitmap,\n+          /*new_bit_count=*/batch_size, valid_bits, &valid_bits_offset, &set_count);\n+      *values_read += batch_size;\n+    }\n+    def_levels += batch_size;\n+    num_def_levels -= batch_size;\n+  }\n+  *null_count += *values_read - set_count;\n+}\n+\n+inline void DefinitionLevelsToBitmapDispatch(\n+    const int16_t* def_levels, int64_t num_def_levels, const int16_t max_definition_level,\n+    const int16_t max_repetition_level, int64_t* values_read, int64_t* null_count,\n+    uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  if (max_repetition_level > 0) {\n+#if ARROW_LITTLE_ENDIAN\n+\n+#if defined(ARROW_HAVE_BMI2)\n+    // BMI2 is required for efficient bit extraction.\n+    DefinitionLevelsToBitmapSimd</*has_repeated_parent=*/true>(\n+        def_levels, num_def_levels, max_definition_level, values_read, null_count,\n+        valid_bits, valid_bits_offset);\n+#else\n+    DefinitionLevelsToBitmapScalar(def_levels, num_def_levels, max_definition_level,\n+                                   max_repetition_level, values_read, null_count,\n+                                   valid_bits, valid_bits_offset);\n+#endif  // ARROW_HAVE_BMI2\n+\n+  } else {\n+    // No Special intsturction are used for non-repeated case.\n+    DefinitionLevelsToBitmapSimd</*has_repeated_parent=*/false>(\n+        def_levels, num_def_levels, max_definition_level, values_read, null_count,\n+        valid_bits, valid_bits_offset);\n+  }\n+}\n+\n+#else  // big-endian\n+    // Optimized SIMD uses bit shifts that are unlikely to work on big endian platforms.\n+    DefinitionLevelsToBitmapScalar(def_levels, num_def_levels, max_definition_level,\n+                                   max_repitition_level, values_read, null_count,\n\nReview comment:\n       typo: `max_repitition_level` -> `max_repetition_level`\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-23T15:40:19.848+0000",
                    "updated": "2020-04-23T15:40:19.848+0000",
                    "started": "2020-04-23T15:40:19.848+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426575",
                    "issueId": "13297951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297951/worklog/426578",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kiszk commented on a change in pull request #6985:\nURL: https://github.com/apache/arrow/pull/6985#discussion_r413908372\n\n\n\n##########\nFile path: cpp/src/parquet/column_reader.cc\n##########\n@@ -50,6 +51,140 @@ using arrow::internal::checked_cast;\n \n namespace parquet {\n \n+namespace {\n+\n+inline void CheckLevelRange(const int16_t* levels, int64_t num_levels,\n+                            const int16_t max_expected_level) {\n+  int16_t min_level = std::numeric_limits<int16_t>::max();\n+  int16_t max_level = std::numeric_limits<int16_t>::min();\n+  for (int x = 0; x < num_levels; x++) {\n+    min_level = std::min(levels[x], min_level);\n+    max_level = std::max(levels[x], max_level);\n+  }\n+  if (ARROW_PREDICT_FALSE(num_levels > 0 && (min_level < 0 || max_level > max_level))) {\n+    throw ParquetException(\"definition level exceeds maximum\");\n+  }\n+}\n+\n+#if !defined(ARROW_HAVE_BMI2)\n+\n+inline void DefinitionLevelsToBitmapScalar(\n+    const int16_t* def_levels, int64_t num_def_levels, const int16_t max_definition_level,\n+    const int16_t max_repetition_level, int64_t* values_read, int64_t* null_count,\n+    uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  // We assume here that valid_bits is large enough to accommodate the\n+  // additional definition levels and the ones that have already been written\n+  ::arrow::internal::BitmapWriter valid_bits_writer(valid_bits, valid_bits_offset,\n+                                                    num_def_levels);\n+\n+  // TODO(itaiin): As an interim solution we are splitting the code path here\n+  // between repeated+flat column reads, and non-repeated+nested reads.\n+  // Those paths need to be merged in the future\n+  for (int i = 0; i < num_def_levels; ++i) {\n+    if (def_levels[i] == max_definition_level) {\n+      valid_bits_writer.Set();\n+    } else if (max_repetition_level > 0) {\n+      // repetition+flat case\n+      if (def_levels[i] == (max_definition_level - 1)) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        continue;\n+      }\n+    } else {\n+      // non-repeated+nested case\n+      if (def_levels[i] < max_definition_level) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        throw ParquetException(\"definition level exceeds maximum\");\n+      }\n+    }\n+\n+    valid_bits_writer.Next();\n+  }\n+  valid_bits_writer.Finish();\n+  *values_read = valid_bits_writer.position();\n+}\n+#endif\n+\n+template <bool has_repeated_parent>\n+void DefinitionLevelsToBitmapSimd(const int16_t* def_levels, int64_t num_def_levels,\n+                                  const int16_t required_definition_level,\n+                                  int64_t* values_read, int64_t* null_count,\n+                                  uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  constexpr int64_t kBitMaskSize = 64;\n+  int64_t set_count = 0;\n+  *values_read = 0;\n+  while (num_def_levels > 0) {\n+    int64_t batch_size = std::min(num_def_levels, kBitMaskSize);\n+    CheckLevelRange(def_levels, batch_size, required_definition_level);\n+    uint64_t defined_bitmap = internal::GreaterThanBitmap(def_levels, batch_size,\n+                                                          required_definition_level - 1);\n+    if (has_repeated_parent) {\n+      // This is currently a specialized code path assuming only (nested) lists\n+      // present through the leaf (i.e. no structs).\n+      // Upper level code only calls this method\n+      // when the leaf-values are nullable (otherwise no spacing is needed),\n+      // Because only nested lists exists it is sufficient to know that the field\n+      // was either null or included it (i.e. >= previous definition level -> > previous\n+      // definition - 1). If there where structs mixed in, we need to know the def_level\n+      // of the repeated parent so we can check for def_level > \"def level of repeated\n+      // parent\".\n+      uint64_t present_bitmap = internal::GreaterThanBitmap(\n+          def_levels, batch_size, required_definition_level - 2);\n+      *values_read += internal::AppendSelectedBitsToValidityBitmap(\n+          /*new_bits=*/defined_bitmap,\n+          /*selection_bitmap*/ present_bitmap, valid_bits, &valid_bits_offset,\n+          &set_count);\n+    } else {\n+      internal::AppendToValidityBitmap(\n+          /*new_bits=*/defined_bitmap,\n+          /*new_bit_count=*/batch_size, valid_bits, &valid_bits_offset, &set_count);\n+      *values_read += batch_size;\n+    }\n+    def_levels += batch_size;\n+    num_def_levels -= batch_size;\n+  }\n+  *null_count += *values_read - set_count;\n+}\n+\n+inline void DefinitionLevelsToBitmapDispatch(\n+    const int16_t* def_levels, int64_t num_def_levels, const int16_t max_definition_level,\n+    const int16_t max_repetition_level, int64_t* values_read, int64_t* null_count,\n+    uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  if (max_repetition_level > 0) {\n+#if ARROW_LITTLE_ENDIAN\n+\n+#if defined(ARROW_HAVE_BMI2)\n+    // BMI2 is required for efficient bit extraction.\n+    DefinitionLevelsToBitmapSimd</*has_repeated_parent=*/true>(\n+        def_levels, num_def_levels, max_definition_level, values_read, null_count,\n+        valid_bits, valid_bits_offset);\n+#else\n+    DefinitionLevelsToBitmapScalar(def_levels, num_def_levels, max_definition_level,\n+                                   max_repetition_level, values_read, null_count,\n+                                   valid_bits, valid_bits_offset);\n+#endif  // ARROW_HAVE_BMI2\n+\n+  } else {\n+    // No Special intsturction are used for non-repeated case.\n+    DefinitionLevelsToBitmapSimd</*has_repeated_parent=*/false>(\n+        def_levels, num_def_levels, max_definition_level, values_read, null_count,\n+        valid_bits, valid_bits_offset);\n+  }\n+}\n\nReview comment:\n       Do we need to move these two lines before line 186?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-23T15:43:18.081+0000",
                    "updated": "2020-04-23T15:43:18.081+0000",
                    "started": "2020-04-23T15:43:18.081+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426578",
                    "issueId": "13297951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297951/worklog/426612",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kiszk commented on a change in pull request #6985:\nURL: https://github.com/apache/arrow/pull/6985#discussion_r413953833\n\n\n\n##########\nFile path: cpp/src/parquet/column_reader.cc\n##########\n@@ -50,6 +51,140 @@ using arrow::internal::checked_cast;\n \n namespace parquet {\n \n+namespace {\n+\n+inline void CheckLevelRange(const int16_t* levels, int64_t num_levels,\n+                            const int16_t max_expected_level) {\n+  int16_t min_level = std::numeric_limits<int16_t>::max();\n+  int16_t max_level = std::numeric_limits<int16_t>::min();\n+  for (int x = 0; x < num_levels; x++) {\n+    min_level = std::min(levels[x], min_level);\n+    max_level = std::max(levels[x], max_level);\n+  }\n+  if (ARROW_PREDICT_FALSE(num_levels > 0 && (min_level < 0 || max_level > max_level))) {\n+    throw ParquetException(\"definition level exceeds maximum\");\n+  }\n+}\n+\n+#if !defined(ARROW_HAVE_BMI2)\n+\n+inline void DefinitionLevelsToBitmapScalar(\n+    const int16_t* def_levels, int64_t num_def_levels, const int16_t max_definition_level,\n+    const int16_t max_repetition_level, int64_t* values_read, int64_t* null_count,\n+    uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  // We assume here that valid_bits is large enough to accommodate the\n+  // additional definition levels and the ones that have already been written\n+  ::arrow::internal::BitmapWriter valid_bits_writer(valid_bits, valid_bits_offset,\n+                                                    num_def_levels);\n+\n+  // TODO(itaiin): As an interim solution we are splitting the code path here\n+  // between repeated+flat column reads, and non-repeated+nested reads.\n+  // Those paths need to be merged in the future\n+  for (int i = 0; i < num_def_levels; ++i) {\n+    if (def_levels[i] == max_definition_level) {\n+      valid_bits_writer.Set();\n+    } else if (max_repetition_level > 0) {\n+      // repetition+flat case\n+      if (def_levels[i] == (max_definition_level - 1)) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        continue;\n+      }\n+    } else {\n+      // non-repeated+nested case\n+      if (def_levels[i] < max_definition_level) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        throw ParquetException(\"definition level exceeds maximum\");\n+      }\n+    }\n+\n+    valid_bits_writer.Next();\n+  }\n+  valid_bits_writer.Finish();\n+  *values_read = valid_bits_writer.position();\n+}\n+#endif\n+\n+template <bool has_repeated_parent>\n+void DefinitionLevelsToBitmapSimd(const int16_t* def_levels, int64_t num_def_levels,\n+                                  const int16_t required_definition_level,\n+                                  int64_t* values_read, int64_t* null_count,\n+                                  uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  constexpr int64_t kBitMaskSize = 64;\n+  int64_t set_count = 0;\n+  *values_read = 0;\n+  while (num_def_levels > 0) {\n+    int64_t batch_size = std::min(num_def_levels, kBitMaskSize);\n+    CheckLevelRange(def_levels, batch_size, required_definition_level);\n+    uint64_t defined_bitmap = internal::GreaterThanBitmap(def_levels, batch_size,\n+                                                          required_definition_level - 1);\n+    if (has_repeated_parent) {\n+      // This is currently a specialized code path assuming only (nested) lists\n\nReview comment:\n       Since this path is executed only when #if defined(ARROW_HAVE_BMI2) is true, it would be good to add such as code\r\n   \r\n   ```\r\n   #if defined(ARROW_HAVE_BMI2)\r\n   ...\r\n   #else\r\n     assert(false && \"must not execute this without BMI2\");\r\n   #endif\r\n   ```\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-23T16:41:36.641+0000",
                    "updated": "2020-04-23T16:41:36.641+0000",
                    "started": "2020-04-23T16:41:36.641+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426612",
                    "issueId": "13297951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297951/worklog/426614",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kiszk commented on a change in pull request #6985:\nURL: https://github.com/apache/arrow/pull/6985#discussion_r413954827\n\n\n\n##########\nFile path: cpp/src/parquet/level_conversion_test.cc\n##########\n@@ -0,0 +1,162 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"parquet/level_conversion.h\"\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+\n+#include <string>\n+\n+#include \"arrow/util/bit_util.h\"\n+\n+namespace parquet {\n+namespace internal {\n+\n+using ::testing::ElementsAreArray;\n+\n+std::string ToString(const uint8_t* bitmap, int64_t bit_count) {\n+  return arrow::internal::Bitmap(bitmap, /*offset*/ 0, /*length=*/bit_count).ToString();\n+}\n+\n+std::string ToString(const std::vector<uint8_t>& bitmap, int64_t bit_count) {\n+  return ToString(bitmap.data(), bit_count);\n+}\n+\n+TEST(TestGreaterThanBitmap, GeneratesExpectedBitmasks) {\n\nReview comment:\n       Most of these tests fail on big-endian platform\r\n   \r\n   ```\r\n   [  FAILED  ] TestAppendBitmap.TestOffsetOverwritesCorrectBitsOnExistingByte\r\n   [  FAILED  ] TestAppendBitmap.TestOffsetShiftBitsCorrectly\r\n   [  FAILED  ] TestAppendBitmap.AllBytesAreWrittenWithEnoughSpace\r\n   [  FAILED  ] TestAppendBitmap.OnlyApproriateBytesWrittenWhenLessThen8BytesAvailable\r\n   [  FAILED  ] TestAppendToValidityBitmap.BasicOperation\r\n   ```\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-23T16:43:04.849+0000",
                    "updated": "2020-04-23T16:43:04.849+0000",
                    "started": "2020-04-23T16:43:04.849+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426614",
                    "issueId": "13297951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297951/worklog/426615",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kiszk commented on a change in pull request #6985:\nURL: https://github.com/apache/arrow/pull/6985#discussion_r413954827\n\n\n\n##########\nFile path: cpp/src/parquet/level_conversion_test.cc\n##########\n@@ -0,0 +1,162 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"parquet/level_conversion.h\"\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+\n+#include <string>\n+\n+#include \"arrow/util/bit_util.h\"\n+\n+namespace parquet {\n+namespace internal {\n+\n+using ::testing::ElementsAreArray;\n+\n+std::string ToString(const uint8_t* bitmap, int64_t bit_count) {\n+  return arrow::internal::Bitmap(bitmap, /*offset*/ 0, /*length=*/bit_count).ToString();\n+}\n+\n+std::string ToString(const std::vector<uint8_t>& bitmap, int64_t bit_count) {\n+  return ToString(bitmap.data(), bit_count);\n+}\n+\n+TEST(TestGreaterThanBitmap, GeneratesExpectedBitmasks) {\n\nReview comment:\n       FYI: Most of these tests fail on big-endian platform\r\n   \r\n   ```\r\n   [  FAILED  ] TestAppendBitmap.TestOffsetOverwritesCorrectBitsOnExistingByte\r\n   [  FAILED  ] TestAppendBitmap.TestOffsetShiftBitsCorrectly\r\n   [  FAILED  ] TestAppendBitmap.AllBytesAreWrittenWithEnoughSpace\r\n   [  FAILED  ] TestAppendBitmap.OnlyApproriateBytesWrittenWhenLessThen8BytesAvailable\r\n   [  FAILED  ] TestAppendToValidityBitmap.BasicOperation\r\n   ```\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-23T16:43:18.285+0000",
                    "updated": "2020-04-23T16:43:18.285+0000",
                    "started": "2020-04-23T16:43:18.284+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426615",
                    "issueId": "13297951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297951/worklog/426624",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kiszk commented on a change in pull request #6985:\nURL: https://github.com/apache/arrow/pull/6985#discussion_r413960907\n\n\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -0,0 +1,191 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include \"arrow/util/bit_util.h\"\n+\n+#if defined(ARROW_HAVE_BMI2)\n+#include \"x86intrin.h\"\n+#endif\n+\n+namespace parquet {\n+namespace internal {\n+// These APIs are likely to be revised as part of ARROW-8494 to reduce duplicate code.\n+// They currently represent minimal functionality for vectorized computation of definition\n+// levels.\n+\n+/// Builds a bitmap by applying predicate to the level vector provided.\n+///\n+/// \\param[in] levels Rep or def level array.\n+/// \\param[in] num_levels The number of levels to process (must be [0, 64])\n+/// \\param[in] predicate The predicate to apply (must have the signature `bool\n+/// predicate(int16_t)`.\n+/// \\returns The bitmap using least significant \"bit\" ordering.\n+///\n+/// N.B. Correct byte ordering is dependent on little-endian architectures.\n+///\n+template <typename Predicate>\n+uint64_t LevelsToBitmap(const int16_t* levels, int64_t num_levels, Predicate predicate) {\n+  // Both clang and GCC can vectorize this automatically with AVX2.\n+  uint64_t mask = 0;\n+  for (int x = 0; x < num_levels; x++) {\n+    mask |= static_cast<int64_t>(predicate(levels[x]) ? 1 : 0) << x;\n+  }\n+  return mask;\n+}\n+\n+/// Builds a  bitmap where each set bit indicates the correspond level is greater\n+/// than rhs.\n+static inline int64_t GreaterThanBitmap(const int16_t* levels, int64_t num_levels,\n+                                        int16_t rhs) {\n+  return LevelsToBitmap(levels, num_levels, [&](int16_t value) { return value > rhs; });\n+}\n+\n+/// Append bits number_of_bits from new_bits to valid_bits and valid_bits_offset.\n+///\n+/// \\param[in] new_bits The zero-padded bitmap to append.\n+/// \\param[in] number_of_bits The number of bits to append from new_bits.\n+/// \\param[in] valid_bits_length The number of bytes allocated in valid_bits.\n+/// \\param[in] valid_bits_offset The bit-offset at which to start appending new bits.\n+/// \\param[in,out] valid_bits The validity bitmap to append to.\n+/// \\returns The new bit offset inside of valid_bits.\n+static inline int64_t AppendBitmap(uint64_t new_bits, int64_t number_of_bits,\n+                                   int64_t valid_bits_length, int64_t valid_bits_offset,\n+                                   uint8_t* valid_bits) {\n+  // Selection masks to retrieve all low order bits for each bytes.\n+  constexpr uint64_t kLsbSelectionMasks[] = {\n+      0,  // unused.\n+      0x0101010101010101,\n+      0x0303030303030303,\n+      0x0707070707070707,\n+      0x0F0F0F0F0F0F0F0F,\n+      0x1F1F1F1F1F1F1F1F,\n+      0x3F3F3F3F3F3F3F3F,\n+      0x7F7F7F7F7F7F7F7F,\n+  };\n+  int64_t valid_byte_offset = valid_bits_offset / 8;\n+  int64_t bit_offset = valid_bits_offset % 8;\n+\n+  int64_t new_offset = valid_bits_offset + number_of_bits;\n+  union ByteAddressableBitmap {\n\nReview comment:\n       Why do we need to use union? `bytes[]` is used only at line 106.   \r\n   It looks simple to explicitly extract the lowest 8bit instead of using union.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-23T16:51:51.551+0000",
                    "updated": "2020-04-23T16:51:51.551+0000",
                    "started": "2020-04-23T16:51:51.550+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426624",
                    "issueId": "13297951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297951/worklog/426632",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kiszk commented on a change in pull request #6985:\nURL: https://github.com/apache/arrow/pull/6985#discussion_r413970301\n\n\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -0,0 +1,191 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include \"arrow/util/bit_util.h\"\n+\n+#if defined(ARROW_HAVE_BMI2)\n+#include \"x86intrin.h\"\n+#endif\n+\n+namespace parquet {\n+namespace internal {\n+// These APIs are likely to be revised as part of ARROW-8494 to reduce duplicate code.\n+// They currently represent minimal functionality for vectorized computation of definition\n+// levels.\n+\n+/// Builds a bitmap by applying predicate to the level vector provided.\n+///\n+/// \\param[in] levels Rep or def level array.\n+/// \\param[in] num_levels The number of levels to process (must be [0, 64])\n+/// \\param[in] predicate The predicate to apply (must have the signature `bool\n+/// predicate(int16_t)`.\n+/// \\returns The bitmap using least significant \"bit\" ordering.\n+///\n+/// N.B. Correct byte ordering is dependent on little-endian architectures.\n+///\n+template <typename Predicate>\n+uint64_t LevelsToBitmap(const int16_t* levels, int64_t num_levels, Predicate predicate) {\n+  // Both clang and GCC can vectorize this automatically with AVX2.\n+  uint64_t mask = 0;\n+  for (int x = 0; x < num_levels; x++) {\n+    mask |= static_cast<int64_t>(predicate(levels[x]) ? 1 : 0) << x;\n+  }\n+  return mask;\n+}\n+\n+/// Builds a  bitmap where each set bit indicates the correspond level is greater\n+/// than rhs.\n+static inline int64_t GreaterThanBitmap(const int16_t* levels, int64_t num_levels,\n\nReview comment:\n       Is this function used only for a little-endian platform?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-23T17:04:56.851+0000",
                    "updated": "2020-04-23T17:04:56.851+0000",
                    "started": "2020-04-23T17:04:56.851+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "426632",
                    "issueId": "13297951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297951/worklog/427284",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #6985:\nURL: https://github.com/apache/arrow/pull/6985#discussion_r414295562\n\n\n\n##########\nFile path: cpp/cmake_modules/SetupCxxFlags.cmake\n##########\n@@ -40,12 +40,13 @@ if(ARROW_CPU_FLAG STREQUAL \"x86\")\n     set(CXX_SUPPORTS_SSE4_2 TRUE)\n   else()\n     set(ARROW_SSE4_2_FLAG \"-msse4.2\")\n-    set(ARROW_AVX2_FLAG \"-mavx2\")\n+    set(ARROW_AVX2_FLAG \"-march=core-avx2\")\n     # skylake-avx512 consists of AVX512F,AVX512BW,AVX512VL,AVX512CD,AVX512DQ\n     set(ARROW_AVX512_FLAG \"-march=skylake-avx512\")\n     check_cxx_compiler_flag(${ARROW_SSE4_2_FLAG} CXX_SUPPORTS_SSE4_2)\n   endif()\n   check_cxx_compiler_flag(${ARROW_AVX2_FLAG} CXX_SUPPORTS_AVX2)\n+  check_cxx_compiler_flag(${ARROW_AVX2_FLAG} CXX_SUPPORTS_AVX2)\n\nReview comment:\n       should be removed now.\n\n##########\nFile path: cpp/src/parquet/column_reader.cc\n##########\n@@ -50,6 +51,140 @@ using arrow::internal::checked_cast;\n \n namespace parquet {\n \n+namespace {\n+\n+inline void CheckLevelRange(const int16_t* levels, int64_t num_levels,\n\nReview comment:\n       I've moved all everything in the anonymous namespace to level_conversion.cc\n\n##########\nFile path: cpp/src/parquet/column_reader.cc\n##########\n@@ -50,6 +51,140 @@ using arrow::internal::checked_cast;\n \n namespace parquet {\n \n+namespace {\n+\n+inline void CheckLevelRange(const int16_t* levels, int64_t num_levels,\n+                            const int16_t max_expected_level) {\n+  int16_t min_level = std::numeric_limits<int16_t>::max();\n+  int16_t max_level = std::numeric_limits<int16_t>::min();\n+  for (int x = 0; x < num_levels; x++) {\n+    min_level = std::min(levels[x], min_level);\n+    max_level = std::max(levels[x], max_level);\n+  }\n+  if (ARROW_PREDICT_FALSE(num_levels > 0 && (min_level < 0 || max_level > max_level))) {\n+    throw ParquetException(\"definition level exceeds maximum\");\n+  }\n+}\n+\n+#if !defined(ARROW_HAVE_BMI2)\n+\n+inline void DefinitionLevelsToBitmapScalar(\n+    const int16_t* def_levels, int64_t num_def_levels, const int16_t max_definition_level,\n+    const int16_t max_repetition_level, int64_t* values_read, int64_t* null_count,\n+    uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  // We assume here that valid_bits is large enough to accommodate the\n+  // additional definition levels and the ones that have already been written\n+  ::arrow::internal::BitmapWriter valid_bits_writer(valid_bits, valid_bits_offset,\n+                                                    num_def_levels);\n+\n+  // TODO(itaiin): As an interim solution we are splitting the code path here\n+  // between repeated+flat column reads, and non-repeated+nested reads.\n+  // Those paths need to be merged in the future\n+  for (int i = 0; i < num_def_levels; ++i) {\n+    if (def_levels[i] == max_definition_level) {\n+      valid_bits_writer.Set();\n+    } else if (max_repetition_level > 0) {\n+      // repetition+flat case\n+      if (def_levels[i] == (max_definition_level - 1)) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        continue;\n+      }\n+    } else {\n+      // non-repeated+nested case\n+      if (def_levels[i] < max_definition_level) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        throw ParquetException(\"definition level exceeds maximum\");\n+      }\n+    }\n+\n+    valid_bits_writer.Next();\n+  }\n+  valid_bits_writer.Finish();\n+  *values_read = valid_bits_writer.position();\n+}\n+#endif\n+\n+template <bool has_repeated_parent>\n+void DefinitionLevelsToBitmapSimd(const int16_t* def_levels, int64_t num_def_levels,\n+                                  const int16_t required_definition_level,\n+                                  int64_t* values_read, int64_t* null_count,\n+                                  uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  constexpr int64_t kBitMaskSize = 64;\n+  int64_t set_count = 0;\n+  *values_read = 0;\n+  while (num_def_levels > 0) {\n+    int64_t batch_size = std::min(num_def_levels, kBitMaskSize);\n+    CheckLevelRange(def_levels, batch_size, required_definition_level);\n+    uint64_t defined_bitmap = internal::GreaterThanBitmap(def_levels, batch_size,\n+                                                          required_definition_level - 1);\n+    if (has_repeated_parent) {\n+      // This is currently a specialized code path assuming only (nested) lists\n\nReview comment:\n       done.\n\n##########\nFile path: cpp/src/parquet/column_reader.cc\n##########\n@@ -50,6 +51,140 @@ using arrow::internal::checked_cast;\n \n namespace parquet {\n \n+namespace {\n+\n+inline void CheckLevelRange(const int16_t* levels, int64_t num_levels,\n+                            const int16_t max_expected_level) {\n+  int16_t min_level = std::numeric_limits<int16_t>::max();\n+  int16_t max_level = std::numeric_limits<int16_t>::min();\n+  for (int x = 0; x < num_levels; x++) {\n+    min_level = std::min(levels[x], min_level);\n+    max_level = std::max(levels[x], max_level);\n+  }\n+  if (ARROW_PREDICT_FALSE(num_levels > 0 && (min_level < 0 || max_level > max_level))) {\n+    throw ParquetException(\"definition level exceeds maximum\");\n+  }\n+}\n+\n+#if !defined(ARROW_HAVE_BMI2)\n+\n+inline void DefinitionLevelsToBitmapScalar(\n+    const int16_t* def_levels, int64_t num_def_levels, const int16_t max_definition_level,\n+    const int16_t max_repetition_level, int64_t* values_read, int64_t* null_count,\n+    uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  // We assume here that valid_bits is large enough to accommodate the\n+  // additional definition levels and the ones that have already been written\n+  ::arrow::internal::BitmapWriter valid_bits_writer(valid_bits, valid_bits_offset,\n+                                                    num_def_levels);\n+\n+  // TODO(itaiin): As an interim solution we are splitting the code path here\n+  // between repeated+flat column reads, and non-repeated+nested reads.\n+  // Those paths need to be merged in the future\n+  for (int i = 0; i < num_def_levels; ++i) {\n+    if (def_levels[i] == max_definition_level) {\n+      valid_bits_writer.Set();\n+    } else if (max_repetition_level > 0) {\n+      // repetition+flat case\n+      if (def_levels[i] == (max_definition_level - 1)) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        continue;\n+      }\n+    } else {\n+      // non-repeated+nested case\n+      if (def_levels[i] < max_definition_level) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        throw ParquetException(\"definition level exceeds maximum\");\n+      }\n+    }\n+\n+    valid_bits_writer.Next();\n+  }\n+  valid_bits_writer.Finish();\n+  *values_read = valid_bits_writer.position();\n+}\n+#endif\n+\n+template <bool has_repeated_parent>\n+void DefinitionLevelsToBitmapSimd(const int16_t* def_levels, int64_t num_def_levels,\n+                                  const int16_t required_definition_level,\n+                                  int64_t* values_read, int64_t* null_count,\n+                                  uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  constexpr int64_t kBitMaskSize = 64;\n+  int64_t set_count = 0;\n+  *values_read = 0;\n+  while (num_def_levels > 0) {\n+    int64_t batch_size = std::min(num_def_levels, kBitMaskSize);\n+    CheckLevelRange(def_levels, batch_size, required_definition_level);\n+    uint64_t defined_bitmap = internal::GreaterThanBitmap(def_levels, batch_size,\n+                                                          required_definition_level - 1);\n+    if (has_repeated_parent) {\n+      // This is currently a specialized code path assuming only (nested) lists\n+      // present through the leaf (i.e. no structs).\n+      // Upper level code only calls this method\n+      // when the leaf-values are nullable (otherwise no spacing is needed),\n+      // Because only nested lists exists it is sufficient to know that the field\n+      // was either null or included it (i.e. >= previous definition level -> > previous\n+      // definition - 1). If there where structs mixed in, we need to know the def_level\n+      // of the repeated parent so we can check for def_level > \"def level of repeated\n+      // parent\".\n+      uint64_t present_bitmap = internal::GreaterThanBitmap(\n+          def_levels, batch_size, required_definition_level - 2);\n+      *values_read += internal::AppendSelectedBitsToValidityBitmap(\n+          /*new_bits=*/defined_bitmap,\n+          /*selection_bitmap*/ present_bitmap, valid_bits, &valid_bits_offset,\n+          &set_count);\n+    } else {\n+      internal::AppendToValidityBitmap(\n+          /*new_bits=*/defined_bitmap,\n+          /*new_bit_count=*/batch_size, valid_bits, &valid_bits_offset, &set_count);\n+      *values_read += batch_size;\n+    }\n+    def_levels += batch_size;\n+    num_def_levels -= batch_size;\n+  }\n+  *null_count += *values_read - set_count;\n+}\n+\n+inline void DefinitionLevelsToBitmapDispatch(\n+    const int16_t* def_levels, int64_t num_def_levels, const int16_t max_definition_level,\n+    const int16_t max_repetition_level, int64_t* values_read, int64_t* null_count,\n+    uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  if (max_repetition_level > 0) {\n+#if ARROW_LITTLE_ENDIAN\n+\n+#if defined(ARROW_HAVE_BMI2)\n+    // BMI2 is required for efficient bit extraction.\n+    DefinitionLevelsToBitmapSimd</*has_repeated_parent=*/true>(\n+        def_levels, num_def_levels, max_definition_level, values_read, null_count,\n+        valid_bits, valid_bits_offset);\n+#else\n+    DefinitionLevelsToBitmapScalar(def_levels, num_def_levels, max_definition_level,\n+                                   max_repetition_level, values_read, null_count,\n+                                   valid_bits, valid_bits_offset);\n+#endif  // ARROW_HAVE_BMI2\n+\n+  } else {\n+    // No Special intsturction are used for non-repeated case.\n\nReview comment:\n       done.\n\n##########\nFile path: cpp/src/parquet/column_reader.cc\n##########\n@@ -50,6 +51,140 @@ using arrow::internal::checked_cast;\n \n namespace parquet {\n \n+namespace {\n+\n+inline void CheckLevelRange(const int16_t* levels, int64_t num_levels,\n+                            const int16_t max_expected_level) {\n+  int16_t min_level = std::numeric_limits<int16_t>::max();\n+  int16_t max_level = std::numeric_limits<int16_t>::min();\n+  for (int x = 0; x < num_levels; x++) {\n+    min_level = std::min(levels[x], min_level);\n+    max_level = std::max(levels[x], max_level);\n+  }\n+  if (ARROW_PREDICT_FALSE(num_levels > 0 && (min_level < 0 || max_level > max_level))) {\n+    throw ParquetException(\"definition level exceeds maximum\");\n+  }\n+}\n+\n+#if !defined(ARROW_HAVE_BMI2)\n+\n+inline void DefinitionLevelsToBitmapScalar(\n+    const int16_t* def_levels, int64_t num_def_levels, const int16_t max_definition_level,\n+    const int16_t max_repetition_level, int64_t* values_read, int64_t* null_count,\n+    uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  // We assume here that valid_bits is large enough to accommodate the\n+  // additional definition levels and the ones that have already been written\n+  ::arrow::internal::BitmapWriter valid_bits_writer(valid_bits, valid_bits_offset,\n+                                                    num_def_levels);\n+\n+  // TODO(itaiin): As an interim solution we are splitting the code path here\n+  // between repeated+flat column reads, and non-repeated+nested reads.\n+  // Those paths need to be merged in the future\n+  for (int i = 0; i < num_def_levels; ++i) {\n+    if (def_levels[i] == max_definition_level) {\n+      valid_bits_writer.Set();\n+    } else if (max_repetition_level > 0) {\n+      // repetition+flat case\n+      if (def_levels[i] == (max_definition_level - 1)) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        continue;\n+      }\n+    } else {\n+      // non-repeated+nested case\n+      if (def_levels[i] < max_definition_level) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        throw ParquetException(\"definition level exceeds maximum\");\n+      }\n+    }\n+\n+    valid_bits_writer.Next();\n+  }\n+  valid_bits_writer.Finish();\n+  *values_read = valid_bits_writer.position();\n+}\n+#endif\n+\n+template <bool has_repeated_parent>\n+void DefinitionLevelsToBitmapSimd(const int16_t* def_levels, int64_t num_def_levels,\n+                                  const int16_t required_definition_level,\n+                                  int64_t* values_read, int64_t* null_count,\n+                                  uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  constexpr int64_t kBitMaskSize = 64;\n+  int64_t set_count = 0;\n+  *values_read = 0;\n+  while (num_def_levels > 0) {\n+    int64_t batch_size = std::min(num_def_levels, kBitMaskSize);\n+    CheckLevelRange(def_levels, batch_size, required_definition_level);\n+    uint64_t defined_bitmap = internal::GreaterThanBitmap(def_levels, batch_size,\n+                                                          required_definition_level - 1);\n+    if (has_repeated_parent) {\n+      // This is currently a specialized code path assuming only (nested) lists\n+      // present through the leaf (i.e. no structs).\n+      // Upper level code only calls this method\n+      // when the leaf-values are nullable (otherwise no spacing is needed),\n+      // Because only nested lists exists it is sufficient to know that the field\n+      // was either null or included it (i.e. >= previous definition level -> > previous\n+      // definition - 1). If there where structs mixed in, we need to know the def_level\n+      // of the repeated parent so we can check for def_level > \"def level of repeated\n+      // parent\".\n+      uint64_t present_bitmap = internal::GreaterThanBitmap(\n+          def_levels, batch_size, required_definition_level - 2);\n+      *values_read += internal::AppendSelectedBitsToValidityBitmap(\n+          /*new_bits=*/defined_bitmap,\n+          /*selection_bitmap*/ present_bitmap, valid_bits, &valid_bits_offset,\n+          &set_count);\n+    } else {\n+      internal::AppendToValidityBitmap(\n+          /*new_bits=*/defined_bitmap,\n+          /*new_bit_count=*/batch_size, valid_bits, &valid_bits_offset, &set_count);\n+      *values_read += batch_size;\n+    }\n+    def_levels += batch_size;\n+    num_def_levels -= batch_size;\n+  }\n+  *null_count += *values_read - set_count;\n+}\n+\n+inline void DefinitionLevelsToBitmapDispatch(\n+    const int16_t* def_levels, int64_t num_def_levels, const int16_t max_definition_level,\n+    const int16_t max_repetition_level, int64_t* values_read, int64_t* null_count,\n+    uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  if (max_repetition_level > 0) {\n+#if ARROW_LITTLE_ENDIAN\n+\n+#if defined(ARROW_HAVE_BMI2)\n+    // BMI2 is required for efficient bit extraction.\n+    DefinitionLevelsToBitmapSimd</*has_repeated_parent=*/true>(\n+        def_levels, num_def_levels, max_definition_level, values_read, null_count,\n+        valid_bits, valid_bits_offset);\n+#else\n+    DefinitionLevelsToBitmapScalar(def_levels, num_def_levels, max_definition_level,\n+                                   max_repetition_level, values_read, null_count,\n+                                   valid_bits, valid_bits_offset);\n+#endif  // ARROW_HAVE_BMI2\n+\n+  } else {\n+    // No Special intsturction are used for non-repeated case.\n+    DefinitionLevelsToBitmapSimd</*has_repeated_parent=*/false>(\n+        def_levels, num_def_levels, max_definition_level, values_read, null_count,\n+        valid_bits, valid_bits_offset);\n+  }\n+}\n\nReview comment:\n       I think just 1.\n\n##########\nFile path: cpp/src/parquet/column_reader.cc\n##########\n@@ -50,6 +51,140 @@ using arrow::internal::checked_cast;\n \n namespace parquet {\n \n+namespace {\n+\n+inline void CheckLevelRange(const int16_t* levels, int64_t num_levels,\n+                            const int16_t max_expected_level) {\n+  int16_t min_level = std::numeric_limits<int16_t>::max();\n+  int16_t max_level = std::numeric_limits<int16_t>::min();\n+  for (int x = 0; x < num_levels; x++) {\n+    min_level = std::min(levels[x], min_level);\n+    max_level = std::max(levels[x], max_level);\n+  }\n+  if (ARROW_PREDICT_FALSE(num_levels > 0 && (min_level < 0 || max_level > max_level))) {\n+    throw ParquetException(\"definition level exceeds maximum\");\n+  }\n+}\n+\n+#if !defined(ARROW_HAVE_BMI2)\n+\n+inline void DefinitionLevelsToBitmapScalar(\n+    const int16_t* def_levels, int64_t num_def_levels, const int16_t max_definition_level,\n+    const int16_t max_repetition_level, int64_t* values_read, int64_t* null_count,\n+    uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  // We assume here that valid_bits is large enough to accommodate the\n+  // additional definition levels and the ones that have already been written\n+  ::arrow::internal::BitmapWriter valid_bits_writer(valid_bits, valid_bits_offset,\n+                                                    num_def_levels);\n+\n+  // TODO(itaiin): As an interim solution we are splitting the code path here\n+  // between repeated+flat column reads, and non-repeated+nested reads.\n+  // Those paths need to be merged in the future\n+  for (int i = 0; i < num_def_levels; ++i) {\n+    if (def_levels[i] == max_definition_level) {\n+      valid_bits_writer.Set();\n+    } else if (max_repetition_level > 0) {\n+      // repetition+flat case\n+      if (def_levels[i] == (max_definition_level - 1)) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        continue;\n+      }\n+    } else {\n+      // non-repeated+nested case\n+      if (def_levels[i] < max_definition_level) {\n+        valid_bits_writer.Clear();\n+        *null_count += 1;\n+      } else {\n+        throw ParquetException(\"definition level exceeds maximum\");\n+      }\n+    }\n+\n+    valid_bits_writer.Next();\n+  }\n+  valid_bits_writer.Finish();\n+  *values_read = valid_bits_writer.position();\n+}\n+#endif\n+\n+template <bool has_repeated_parent>\n+void DefinitionLevelsToBitmapSimd(const int16_t* def_levels, int64_t num_def_levels,\n+                                  const int16_t required_definition_level,\n+                                  int64_t* values_read, int64_t* null_count,\n+                                  uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  constexpr int64_t kBitMaskSize = 64;\n+  int64_t set_count = 0;\n+  *values_read = 0;\n+  while (num_def_levels > 0) {\n+    int64_t batch_size = std::min(num_def_levels, kBitMaskSize);\n+    CheckLevelRange(def_levels, batch_size, required_definition_level);\n+    uint64_t defined_bitmap = internal::GreaterThanBitmap(def_levels, batch_size,\n+                                                          required_definition_level - 1);\n+    if (has_repeated_parent) {\n+      // This is currently a specialized code path assuming only (nested) lists\n+      // present through the leaf (i.e. no structs).\n+      // Upper level code only calls this method\n+      // when the leaf-values are nullable (otherwise no spacing is needed),\n+      // Because only nested lists exists it is sufficient to know that the field\n+      // was either null or included it (i.e. >= previous definition level -> > previous\n+      // definition - 1). If there where structs mixed in, we need to know the def_level\n+      // of the repeated parent so we can check for def_level > \"def level of repeated\n+      // parent\".\n+      uint64_t present_bitmap = internal::GreaterThanBitmap(\n+          def_levels, batch_size, required_definition_level - 2);\n+      *values_read += internal::AppendSelectedBitsToValidityBitmap(\n+          /*new_bits=*/defined_bitmap,\n+          /*selection_bitmap*/ present_bitmap, valid_bits, &valid_bits_offset,\n+          &set_count);\n+    } else {\n+      internal::AppendToValidityBitmap(\n+          /*new_bits=*/defined_bitmap,\n+          /*new_bit_count=*/batch_size, valid_bits, &valid_bits_offset, &set_count);\n+      *values_read += batch_size;\n+    }\n+    def_levels += batch_size;\n+    num_def_levels -= batch_size;\n+  }\n+  *null_count += *values_read - set_count;\n+}\n+\n+inline void DefinitionLevelsToBitmapDispatch(\n+    const int16_t* def_levels, int64_t num_def_levels, const int16_t max_definition_level,\n+    const int16_t max_repetition_level, int64_t* values_read, int64_t* null_count,\n+    uint8_t* valid_bits, int64_t valid_bits_offset) {\n+  if (max_repetition_level > 0) {\n+#if ARROW_LITTLE_ENDIAN\n+\n+#if defined(ARROW_HAVE_BMI2)\n+    // BMI2 is required for efficient bit extraction.\n+    DefinitionLevelsToBitmapSimd</*has_repeated_parent=*/true>(\n+        def_levels, num_def_levels, max_definition_level, values_read, null_count,\n+        valid_bits, valid_bits_offset);\n+#else\n+    DefinitionLevelsToBitmapScalar(def_levels, num_def_levels, max_definition_level,\n+                                   max_repetition_level, values_read, null_count,\n+                                   valid_bits, valid_bits_offset);\n+#endif  // ARROW_HAVE_BMI2\n+\n+  } else {\n+    // No Special intsturction are used for non-repeated case.\n+    DefinitionLevelsToBitmapSimd</*has_repeated_parent=*/false>(\n+        def_levels, num_def_levels, max_definition_level, values_read, null_count,\n+        valid_bits, valid_bits_offset);\n+  }\n+}\n+\n+#else  // big-endian\n+    // Optimized SIMD uses bit shifts that are unlikely to work on big endian platforms.\n+    DefinitionLevelsToBitmapScalar(def_levels, num_def_levels, max_definition_level,\n+                                   max_repitition_level, values_read, null_count,\n\nReview comment:\n       done.\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -0,0 +1,191 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include \"arrow/util/bit_util.h\"\n+\n+#if defined(ARROW_HAVE_BMI2)\n+#include \"x86intrin.h\"\n+#endif\n+\n+namespace parquet {\n+namespace internal {\n+// These APIs are likely to be revised as part of ARROW-8494 to reduce duplicate code.\n+// They currently represent minimal functionality for vectorized computation of definition\n+// levels.\n+\n+/// Builds a bitmap by applying predicate to the level vector provided.\n+///\n+/// \\param[in] levels Rep or def level array.\n+/// \\param[in] num_levels The number of levels to process (must be [0, 64])\n+/// \\param[in] predicate The predicate to apply (must have the signature `bool\n+/// predicate(int16_t)`.\n+/// \\returns The bitmap using least significant \"bit\" ordering.\n+///\n+/// N.B. Correct byte ordering is dependent on little-endian architectures.\n+///\n+template <typename Predicate>\n+uint64_t LevelsToBitmap(const int16_t* levels, int64_t num_levels, Predicate predicate) {\n+  // Both clang and GCC can vectorize this automatically with AVX2.\n+  uint64_t mask = 0;\n+  for (int x = 0; x < num_levels; x++) {\n+    mask |= static_cast<int64_t>(predicate(levels[x]) ? 1 : 0) << x;\n+  }\n+  return mask;\n+}\n+\n+/// Builds a  bitmap where each set bit indicates the correspond level is greater\n\nReview comment:\n       yes.  fixed.\n\n##########\nFile path: cpp/src/parquet/column_reader.cc\n##########\n@@ -50,6 +51,140 @@ using arrow::internal::checked_cast;\n \n namespace parquet {\n \n+namespace {\n+\n+inline void CheckLevelRange(const int16_t* levels, int64_t num_levels,\n\nReview comment:\n       Note that this prevents inlining of the Scalar version which was happening before, but I'm not sure that is a big deal.\n\n##########\nFile path: cpp/src/parquet/level_conversion_test.cc\n##########\n@@ -0,0 +1,162 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"parquet/level_conversion.h\"\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+\n+#include <string>\n+\n+#include \"arrow/util/bit_util.h\"\n+\n+namespace parquet {\n+namespace internal {\n+\n+using ::testing::ElementsAreArray;\n+\n+std::string ToString(const uint8_t* bitmap, int64_t bit_count) {\n\nReview comment:\n       done.\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -0,0 +1,191 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include \"arrow/util/bit_util.h\"\n+\n+#if defined(ARROW_HAVE_BMI2)\n+#include \"x86intrin.h\"\n+#endif\n+\n+namespace parquet {\n+namespace internal {\n+// These APIs are likely to be revised as part of ARROW-8494 to reduce duplicate code.\n+// They currently represent minimal functionality for vectorized computation of definition\n+// levels.\n+\n+/// Builds a bitmap by applying predicate to the level vector provided.\n+///\n+/// \\param[in] levels Rep or def level array.\n+/// \\param[in] num_levels The number of levels to process (must be [0, 64])\n+/// \\param[in] predicate The predicate to apply (must have the signature `bool\n+/// predicate(int16_t)`.\n+/// \\returns The bitmap using least significant \"bit\" ordering.\n+///\n+/// N.B. Correct byte ordering is dependent on little-endian architectures.\n+///\n+template <typename Predicate>\n+uint64_t LevelsToBitmap(const int16_t* levels, int64_t num_levels, Predicate predicate) {\n+  // Both clang and GCC can vectorize this automatically with AVX2.\n+  uint64_t mask = 0;\n+  for (int x = 0; x < num_levels; x++) {\n+    mask |= static_cast<int64_t>(predicate(levels[x]) ? 1 : 0) << x;\n+  }\n+  return mask;\n+}\n+\n+/// Builds a  bitmap where each set bit indicates the correspond level is greater\n+/// than rhs.\n+static inline int64_t GreaterThanBitmap(const int16_t* levels, int64_t num_levels,\n+                                        int16_t rhs) {\n+  return LevelsToBitmap(levels, num_levels, [&](int16_t value) { return value > rhs; });\n+}\n+\n+/// Append bits number_of_bits from new_bits to valid_bits and valid_bits_offset.\n+///\n+/// \\param[in] new_bits The zero-padded bitmap to append.\n+/// \\param[in] number_of_bits The number of bits to append from new_bits.\n+/// \\param[in] valid_bits_length The number of bytes allocated in valid_bits.\n+/// \\param[in] valid_bits_offset The bit-offset at which to start appending new bits.\n+/// \\param[in,out] valid_bits The validity bitmap to append to.\n+/// \\returns The new bit offset inside of valid_bits.\n+static inline int64_t AppendBitmap(uint64_t new_bits, int64_t number_of_bits,\n+                                   int64_t valid_bits_length, int64_t valid_bits_offset,\n+                                   uint8_t* valid_bits) {\n+  // Selection masks to retrieve all low order bits for each bytes.\n+  constexpr uint64_t kLsbSelectionMasks[] = {\n+      0,  // unused.\n+      0x0101010101010101,\n+      0x0303030303030303,\n+      0x0707070707070707,\n+      0x0F0F0F0F0F0F0F0F,\n+      0x1F1F1F1F1F1F1F1F,\n+      0x3F3F3F3F3F3F3F3F,\n+      0x7F7F7F7F7F7F7F7F,\n+  };\n+  int64_t valid_byte_offset = valid_bits_offset / 8;\n+  int64_t bit_offset = valid_bits_offset % 8;\n+\n+  int64_t new_offset = valid_bits_offset + number_of_bits;\n+  union ByteAddressableBitmap {\n+    explicit ByteAddressableBitmap(uint64_t mask) : mask(mask) {}\n+    uint64_t mask;\n+    uint8_t bytes[8];\n+  };\n+\n+  if (bit_offset != 0) {\n+    int64_t bits_to_carry = 8 - bit_offset;\n+    // Get the mask the will select the lower order bits  (the ones to carry\n+    // over to the existing byte and shift up.\n+    const ByteAddressableBitmap carry_bits(kLsbSelectionMasks[bits_to_carry]);\n+    // Mask to select non-carried bits.\n+    const ByteAddressableBitmap inverse_selection(~carry_bits.mask);\n+    // Fill out the last incomplete byte in the output, by extracting the least\n+    // siginficant bits from the first byte.\n+    const ByteAddressableBitmap new_bitmap(new_bits);\n+    // valid bits should be a valid bitmask so all trailing bytes hsould be unset\n+    // so no mask is need to start.\n+    valid_bits[valid_byte_offset] =\n+        valid_bits[valid_byte_offset] |  // See above the\n+        (((new_bitmap.bytes[0] & carry_bits.bytes[0])) << bit_offset);\n+\n+    // We illustrate logic with a 3-byte example in little endian/LSB order.\n+    // Note this ordering is the reversed from HEX masks above with are expressed\n+    // big-endian/MSB and shifts right move the bits to the left (division).\n+    // 0  1  2  3  4  5  6  7   8  9  10 11 12 13 14 15   16 17 18 19 20 21 22 23\n+    // Shifted mask should look like this assuming bit offset = 6:\n+    // 2  3  4  5  6  7  N  N   10 11 12 13 14 15  N  N   18 19 20 21 22 23  N  N\n+    // clang-format on\n+    uint64_t shifted_new_bits = (new_bits & inverse_selection.mask) >> bits_to_carry;\n+    // captured_carry:\n+    // 0  1  N  N  N  N  N  N   8  9  N  N  N   N  N  N   16 17  N  N  N  N  N  N\n+    uint64_t captured_carry = carry_bits.mask & new_bits;\n+    // mask_cary_bits:\n+    // N  N  N  N  N  N  8  9   N  N  N  N  N   N 16 17    N  N   N  N  N  N  N  N\n+    uint64_t mask_carry_bits = (captured_carry >> 8) << bit_offset;\n+\n+    new_bits = shifted_new_bits | mask_carry_bits;\n+    // Don't overwrite the first byte\n+    valid_byte_offset += 1;\n+    number_of_bits -= bits_to_carry;\n+  }\n+\n+  int64_t bytes_for_new_bits = ::arrow::BitUtil::BytesForBits(number_of_bits);\n+  if (valid_bits_length - ::arrow::BitUtil::BytesForBits(valid_bits_offset) >=\n+      static_cast<int64_t>(sizeof(new_bits))) {\n+    // This should be the common case and  inlined as a single instruction which\n+    // should be cheaper then the general case of calling mempcy, so it is likely\n+    // worth the extra branch.\n+    std::memcpy(valid_bits + valid_byte_offset, &new_bits, sizeof(new_bits));\n+  } else {\n+    std::memcpy(valid_bits + valid_byte_offset, &new_bits, bytes_for_new_bits);\n+  }\n+  return new_offset;\n+}\n+\n+/// \\brief Appends bit values to the validitdy bimap_valid bits, based on bitmaps\n+/// generated by GreaterThanBitmap, and the appropriate treshold definition_leve.\n\nReview comment:\n       I agree now that the AppendWord is moved to FirstTimeBitmapWriter\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -0,0 +1,191 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include \"arrow/util/bit_util.h\"\n+\n+#if defined(ARROW_HAVE_BMI2)\n+#include \"x86intrin.h\"\n+#endif\n+\n+namespace parquet {\n+namespace internal {\n+// These APIs are likely to be revised as part of ARROW-8494 to reduce duplicate code.\n+// They currently represent minimal functionality for vectorized computation of definition\n+// levels.\n+\n+/// Builds a bitmap by applying predicate to the level vector provided.\n+///\n+/// \\param[in] levels Rep or def level array.\n+/// \\param[in] num_levels The number of levels to process (must be [0, 64])\n+/// \\param[in] predicate The predicate to apply (must have the signature `bool\n+/// predicate(int16_t)`.\n+/// \\returns The bitmap using least significant \"bit\" ordering.\n+///\n+/// N.B. Correct byte ordering is dependent on little-endian architectures.\n+///\n+template <typename Predicate>\n+uint64_t LevelsToBitmap(const int16_t* levels, int64_t num_levels, Predicate predicate) {\n+  // Both clang and GCC can vectorize this automatically with AVX2.\n+  uint64_t mask = 0;\n+  for (int x = 0; x < num_levels; x++) {\n+    mask |= static_cast<int64_t>(predicate(levels[x]) ? 1 : 0) << x;\n+  }\n+  return mask;\n+}\n+\n+/// Builds a  bitmap where each set bit indicates the correspond level is greater\n+/// than rhs.\n+static inline int64_t GreaterThanBitmap(const int16_t* levels, int64_t num_levels,\n\nReview comment:\n       oversight, fixed. wrapped this one and the one below if if/def guards for little endian.\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -0,0 +1,191 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include \"arrow/util/bit_util.h\"\n+\n+#if defined(ARROW_HAVE_BMI2)\n+#include \"x86intrin.h\"\n+#endif\n+\n+namespace parquet {\n+namespace internal {\n+// These APIs are likely to be revised as part of ARROW-8494 to reduce duplicate code.\n+// They currently represent minimal functionality for vectorized computation of definition\n+// levels.\n+\n+/// Builds a bitmap by applying predicate to the level vector provided.\n+///\n+/// \\param[in] levels Rep or def level array.\n+/// \\param[in] num_levels The number of levels to process (must be [0, 64])\n+/// \\param[in] predicate The predicate to apply (must have the signature `bool\n+/// predicate(int16_t)`.\n+/// \\returns The bitmap using least significant \"bit\" ordering.\n+///\n+/// N.B. Correct byte ordering is dependent on little-endian architectures.\n+///\n+template <typename Predicate>\n+uint64_t LevelsToBitmap(const int16_t* levels, int64_t num_levels, Predicate predicate) {\n+  // Both clang and GCC can vectorize this automatically with AVX2.\n+  uint64_t mask = 0;\n+  for (int x = 0; x < num_levels; x++) {\n+    mask |= static_cast<int64_t>(predicate(levels[x]) ? 1 : 0) << x;\n+  }\n+  return mask;\n+}\n+\n+/// Builds a  bitmap where each set bit indicates the correspond level is greater\n+/// than rhs.\n+static inline int64_t GreaterThanBitmap(const int16_t* levels, int64_t num_levels,\n+                                        int16_t rhs) {\n+  return LevelsToBitmap(levels, num_levels, [&](int16_t value) { return value > rhs; });\n+}\n+\n+/// Append bits number_of_bits from new_bits to valid_bits and valid_bits_offset.\n+///\n+/// \\param[in] new_bits The zero-padded bitmap to append.\n+/// \\param[in] number_of_bits The number of bits to append from new_bits.\n+/// \\param[in] valid_bits_length The number of bytes allocated in valid_bits.\n+/// \\param[in] valid_bits_offset The bit-offset at which to start appending new bits.\n+/// \\param[in,out] valid_bits The validity bitmap to append to.\n+/// \\returns The new bit offset inside of valid_bits.\n+static inline int64_t AppendBitmap(uint64_t new_bits, int64_t number_of_bits,\n+                                   int64_t valid_bits_length, int64_t valid_bits_offset,\n+                                   uint8_t* valid_bits) {\n+  // Selection masks to retrieve all low order bits for each bytes.\n+  constexpr uint64_t kLsbSelectionMasks[] = {\n+      0,  // unused.\n+      0x0101010101010101,\n+      0x0303030303030303,\n+      0x0707070707070707,\n+      0x0F0F0F0F0F0F0F0F,\n+      0x1F1F1F1F1F1F1F1F,\n+      0x3F3F3F3F3F3F3F3F,\n+      0x7F7F7F7F7F7F7F7F,\n+  };\n+  int64_t valid_byte_offset = valid_bits_offset / 8;\n+  int64_t bit_offset = valid_bits_offset % 8;\n+\n+  int64_t new_offset = valid_bits_offset + number_of_bits;\n+  union ByteAddressableBitmap {\n\nReview comment:\n       I originally thought I would have to do more.  I removed the union.\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -0,0 +1,191 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include \"arrow/util/bit_util.h\"\n+\n+#if defined(ARROW_HAVE_BMI2)\n+#include \"x86intrin.h\"\n+#endif\n+\n+namespace parquet {\n+namespace internal {\n+// These APIs are likely to be revised as part of ARROW-8494 to reduce duplicate code.\n+// They currently represent minimal functionality for vectorized computation of definition\n+// levels.\n+\n+/// Builds a bitmap by applying predicate to the level vector provided.\n+///\n+/// \\param[in] levels Rep or def level array.\n+/// \\param[in] num_levels The number of levels to process (must be [0, 64])\n+/// \\param[in] predicate The predicate to apply (must have the signature `bool\n+/// predicate(int16_t)`.\n+/// \\returns The bitmap using least significant \"bit\" ordering.\n+///\n+/// N.B. Correct byte ordering is dependent on little-endian architectures.\n+///\n+template <typename Predicate>\n+uint64_t LevelsToBitmap(const int16_t* levels, int64_t num_levels, Predicate predicate) {\n+  // Both clang and GCC can vectorize this automatically with AVX2.\n+  uint64_t mask = 0;\n+  for (int x = 0; x < num_levels; x++) {\n+    mask |= static_cast<int64_t>(predicate(levels[x]) ? 1 : 0) << x;\n+  }\n+  return mask;\n+}\n+\n+/// Builds a  bitmap where each set bit indicates the correspond level is greater\n+/// than rhs.\n+static inline int64_t GreaterThanBitmap(const int16_t* levels, int64_t num_levels,\n+                                        int16_t rhs) {\n+  return LevelsToBitmap(levels, num_levels, [&](int16_t value) { return value > rhs; });\n+}\n+\n+/// Append bits number_of_bits from new_bits to valid_bits and valid_bits_offset.\n+///\n+/// \\param[in] new_bits The zero-padded bitmap to append.\n+/// \\param[in] number_of_bits The number of bits to append from new_bits.\n+/// \\param[in] valid_bits_length The number of bytes allocated in valid_bits.\n+/// \\param[in] valid_bits_offset The bit-offset at which to start appending new bits.\n+/// \\param[in,out] valid_bits The validity bitmap to append to.\n+/// \\returns The new bit offset inside of valid_bits.\n+static inline int64_t AppendBitmap(uint64_t new_bits, int64_t number_of_bits,\n+                                   int64_t valid_bits_length, int64_t valid_bits_offset,\n+                                   uint8_t* valid_bits) {\n+  // Selection masks to retrieve all low order bits for each bytes.\n+  constexpr uint64_t kLsbSelectionMasks[] = {\n+      0,  // unused.\n+      0x0101010101010101,\n+      0x0303030303030303,\n+      0x0707070707070707,\n+      0x0F0F0F0F0F0F0F0F,\n+      0x1F1F1F1F1F1F1F1F,\n+      0x3F3F3F3F3F3F3F3F,\n+      0x7F7F7F7F7F7F7F7F,\n+  };\n+  int64_t valid_byte_offset = valid_bits_offset / 8;\n+  int64_t bit_offset = valid_bits_offset % 8;\n+\n+  int64_t new_offset = valid_bits_offset + number_of_bits;\n+  union ByteAddressableBitmap {\n+    explicit ByteAddressableBitmap(uint64_t mask) : mask(mask) {}\n+    uint64_t mask;\n+    uint8_t bytes[8];\n+  };\n+\n+  if (bit_offset != 0) {\n+    int64_t bits_to_carry = 8 - bit_offset;\n+    // Get the mask the will select the lower order bits  (the ones to carry\n+    // over to the existing byte and shift up.\n+    const ByteAddressableBitmap carry_bits(kLsbSelectionMasks[bits_to_carry]);\n+    // Mask to select non-carried bits.\n+    const ByteAddressableBitmap inverse_selection(~carry_bits.mask);\n+    // Fill out the last incomplete byte in the output, by extracting the least\n+    // siginficant bits from the first byte.\n+    const ByteAddressableBitmap new_bitmap(new_bits);\n+    // valid bits should be a valid bitmask so all trailing bytes hsould be unset\n+    // so no mask is need to start.\n+    valid_bits[valid_byte_offset] =\n+        valid_bits[valid_byte_offset] |  // See above the\n+        (((new_bitmap.bytes[0] & carry_bits.bytes[0])) << bit_offset);\n+\n+    // We illustrate logic with a 3-byte example in little endian/LSB order.\n+    // Note this ordering is the reversed from HEX masks above with are expressed\n+    // big-endian/MSB and shifts right move the bits to the left (division).\n+    // 0  1  2  3  4  5  6  7   8  9  10 11 12 13 14 15   16 17 18 19 20 21 22 23\n+    // Shifted mask should look like this assuming bit offset = 6:\n+    // 2  3  4  5  6  7  N  N   10 11 12 13 14 15  N  N   18 19 20 21 22 23  N  N\n\nReview comment:\n       Add an additional line showing the mask.  Also clarified that N indicates not-set (not that they disappear, I'm not sure if this is what you meant?)  Or are you illustrating another error with the documentation?\n\n##########\nFile path: cpp/src/parquet/level_conversion_test.cc\n##########\n@@ -0,0 +1,162 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"parquet/level_conversion.h\"\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+\n+#include <string>\n+\n+#include \"arrow/util/bit_util.h\"\n+\n+namespace parquet {\n+namespace internal {\n+\n+using ::testing::ElementsAreArray;\n+\n+std::string ToString(const uint8_t* bitmap, int64_t bit_count) {\n+  return arrow::internal::Bitmap(bitmap, /*offset*/ 0, /*length=*/bit_count).ToString();\n+}\n+\n+std::string ToString(const std::vector<uint8_t>& bitmap, int64_t bit_count) {\n+  return ToString(bitmap.data(), bit_count);\n+}\n+\n+TEST(TestGreaterThanBitmap, GeneratesExpectedBitmasks) {\n+  std::vector<int16_t> levels = {0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7,\n+                                 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7,\n+                                 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7,\n+                                 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7};\n+  EXPECT_EQ(GreaterThanBitmap(levels.data(), /*num_levels=*/0, /*rhs*/ 0), 0);\n+  EXPECT_EQ(GreaterThanBitmap(levels.data(), /*num_levels=*/64, /*rhs*/ 8), 0);\n+  EXPECT_EQ(GreaterThanBitmap(levels.data(), /*num_levels=*/64, /*rhs*/ -1),\n+            0xFFFFFFFFFFFFFFFF);\n+  // Should be zero padded.\n+  EXPECT_EQ(GreaterThanBitmap(levels.data(), /*num_levels=*/47, /*rhs*/ -1),\n+            0x7FFFFFFFFFFF);\n+  EXPECT_EQ(GreaterThanBitmap(levels.data(), /*num_levels=*/64, /*rhs*/ 6),\n+            0x8080808080808080);\n+}\n+\n+TEST(TestAppendBitmap, TestOffsetOverwritesCorrectBitsOnExistingByte) {\n+  auto check_append = [](const std::string& expected_bits, int64_t offset) {\n+    std::vector<uint8_t> valid_bits = {0x00};\n+    constexpr int64_t kBitsAfterAppend = 8;\n+    ASSERT_EQ(\n+        AppendBitmap(/*new_bits=*/0xFF, /*number_of_bits*/ 8 - offset,\n+                     /*valid_bits_length=*/valid_bits.size(), offset, valid_bits.data()),\n+        kBitsAfterAppend);\n+    EXPECT_EQ(ToString(valid_bits, kBitsAfterAppend), expected_bits);\n+  };\n+  check_append(\"11111111\", 0);\n+  check_append(\"01111111\", 1);\n+  check_append(\"00111111\", 2);\n+  check_append(\"00011111\", 3);\n+  check_append(\"00001111\", 4);\n+  check_append(\"00000111\", 5);\n+  check_append(\"00000011\", 6);\n+  check_append(\"00000001\", 7);\n+}\n+\n+TEST(TestAppendBitmap, TestOffsetShiftBitsCorrectly) {\n+  constexpr uint64_t kPattern = 0x9A9A9A9A9A9A9A9A;\n+  auto check_append = [&](const std::string& leading_bits, const std::string& middle_bits,\n+                          const std::string& trailing_bits, int64_t offset) {\n+    ASSERT_GE(offset, 8);\n+    std::vector<uint8_t> valid_bits(/*count=*/10, 0);\n+    valid_bits[0] = 0x99;\n+\n+    AppendBitmap(/*new_bits=*/kPattern, /*number_of_bits*/ 64,\n+                 /*valid_bits_length=*/valid_bits.size(), offset, valid_bits.data());\n+    EXPECT_EQ(valid_bits[0], 0x99);  // shouldn't get chanked.\n+    EXPECT_EQ(ToString(valid_bits.data() + 1, /*num_bits=*/8), leading_bits);\n+    for (int x = 2; x < 9; x++) {\n+      EXPECT_EQ(ToString(valid_bits.data() + x, /*num_bits=*/8), middle_bits);\n+    }\n+    EXPECT_EQ(ToString(valid_bits.data() + 9, /*num_bits=*/8), trailing_bits);\n+  };\n+  // Original Pattern = \"01011001\"\n+  check_append(/*leading_bits= */ \"01011001\", /*middle_bits=*/\"01011001\",\n+               /*trailing_bits=*/\"00000000\", /*offset=*/8);\n+  check_append(\"00101100\", \"10101100\", \"10000000\", 9);\n+  check_append(\"00010110\", \"01010110\", \"01000000\", 10);\n+  check_append(\"00001011\", \"00101011\", \"00100000\", 11);\n+  check_append(\"00000101\", \"10010101\", \"10010000\", 12);\n+  check_append(\"00000010\", \"11001010\", \"11001000\", 13);\n+  check_append(\"00000001\", \"01100101\", \"01100100\", 14);\n+  check_append(\"00000000\", \"10110010\", \"10110010\", 15);\n+}\n+\n+TEST(TestAppendBitmap, AllBytesAreWrittenWithEnoughSpace) {\n+  std::vector<uint8_t> valid_bits(/*count=*/9, 0);\n+\n+  uint64_t bitmap = 0xFFFFFFFFFFFFFFFF;\n+  AppendBitmap(bitmap, /*number_of_bits*/ 7,\n+               /*valid_bits_length=*/valid_bits.size(),\n+               /*valid_bits_offset=*/1,\n+               /*valid_bits=*/valid_bits.data());\n+  EXPECT_THAT(valid_bits, ElementsAreArray(std::vector<uint8_t>{\n+                              0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01}));\n+}\n+\n+TEST(TestAppendBitmap, OnlyApproriateBytesWrittenWhenLessThen8BytesAvailable) {\n+  std::vector<uint8_t> valid_bits = {0x00, 0x00};\n+\n+  uint64_t bitmap = 0x1FF;\n+  AppendBitmap(bitmap, /*number_of_bits*/ 7,\n+               /*valid_bits_length=*/2,\n+               /*valid_bits_offset=*/1,\n+               /*valid_bits=*/valid_bits.data());\n+\n+  EXPECT_THAT(valid_bits, ElementsAreArray(std::vector<uint8_t>{0xFE, 0x00}));\n+\n+  AppendBitmap(bitmap, /*number_of_bits*/ 9,\n+               /*valid_bits_length=*/2,\n+               /*valid_bits_offset=*/1,\n+               /*valid_bits=*/valid_bits.data());\n+  EXPECT_THAT(valid_bits, ElementsAreArray(std::vector<uint8_t>{0xFE, 0x03}));\n+}\n+\n+TEST(TestAppendToValidityBitmap, BasicOperation) {\n+  std::vector<uint8_t> validity_bitmap(/*count*/ 8, 0);\n+  int64_t valid_bitmap_offset = 1;\n+  int64_t set_bit_count = 5;\n+  AppendToValidityBitmap(/*new_bits*/ 0x99, /*new_bit_count=*/31, validity_bitmap.data(),\n+                         &valid_bitmap_offset, &set_bit_count);\n+  EXPECT_EQ(ToString(validity_bitmap, valid_bitmap_offset),\n+            \"01001100 10000000 00000000 00000000\");\n+  EXPECT_EQ(set_bit_count, /*5 + 4 set bits=*/9);\n+}\n+\n+TEST(TestAppendSelectedBitsToValidityBitmap, BasicOperation) {\n+#if !defined(ARROW_HAVE_BMI2)\n\nReview comment:\n       good point. done.\n\n##########\nFile path: cpp/src/parquet/level_conversion_test.cc\n##########\n@@ -0,0 +1,162 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"parquet/level_conversion.h\"\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+\n+#include <string>\n+\n+#include \"arrow/util/bit_util.h\"\n+\n+namespace parquet {\n+namespace internal {\n+\n+using ::testing::ElementsAreArray;\n+\n+std::string ToString(const uint8_t* bitmap, int64_t bit_count) {\n+  return arrow::internal::Bitmap(bitmap, /*offset*/ 0, /*length=*/bit_count).ToString();\n+}\n+\n+std::string ToString(const std::vector<uint8_t>& bitmap, int64_t bit_count) {\n\nReview comment:\n       done.\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -0,0 +1,191 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include \"arrow/util/bit_util.h\"\n+\n+#if defined(ARROW_HAVE_BMI2)\n+#include \"x86intrin.h\"\n+#endif\n+\n+namespace parquet {\n+namespace internal {\n+// These APIs are likely to be revised as part of ARROW-8494 to reduce duplicate code.\n+// They currently represent minimal functionality for vectorized computation of definition\n+// levels.\n+\n+/// Builds a bitmap by applying predicate to the level vector provided.\n+///\n+/// \\param[in] levels Rep or def level array.\n+/// \\param[in] num_levels The number of levels to process (must be [0, 64])\n+/// \\param[in] predicate The predicate to apply (must have the signature `bool\n+/// predicate(int16_t)`.\n+/// \\returns The bitmap using least significant \"bit\" ordering.\n+///\n+/// N.B. Correct byte ordering is dependent on little-endian architectures.\n+///\n+template <typename Predicate>\n+uint64_t LevelsToBitmap(const int16_t* levels, int64_t num_levels, Predicate predicate) {\n+  // Both clang and GCC can vectorize this automatically with AVX2.\n+  uint64_t mask = 0;\n+  for (int x = 0; x < num_levels; x++) {\n+    mask |= static_cast<int64_t>(predicate(levels[x]) ? 1 : 0) << x;\n+  }\n+  return mask;\n+}\n+\n+/// Builds a  bitmap where each set bit indicates the correspond level is greater\n+/// than rhs.\n+static inline int64_t GreaterThanBitmap(const int16_t* levels, int64_t num_levels,\n+                                        int16_t rhs) {\n+  return LevelsToBitmap(levels, num_levels, [&](int16_t value) { return value > rhs; });\n+}\n+\n+/// Append bits number_of_bits from new_bits to valid_bits and valid_bits_offset.\n+///\n+/// \\param[in] new_bits The zero-padded bitmap to append.\n+/// \\param[in] number_of_bits The number of bits to append from new_bits.\n+/// \\param[in] valid_bits_length The number of bytes allocated in valid_bits.\n+/// \\param[in] valid_bits_offset The bit-offset at which to start appending new bits.\n+/// \\param[in,out] valid_bits The validity bitmap to append to.\n+/// \\returns The new bit offset inside of valid_bits.\n+static inline int64_t AppendBitmap(uint64_t new_bits, int64_t number_of_bits,\n+                                   int64_t valid_bits_length, int64_t valid_bits_offset,\n+                                   uint8_t* valid_bits) {\n+  // Selection masks to retrieve all low order bits for each bytes.\n+  constexpr uint64_t kLsbSelectionMasks[] = {\n+      0,  // unused.\n+      0x0101010101010101,\n+      0x0303030303030303,\n+      0x0707070707070707,\n+      0x0F0F0F0F0F0F0F0F,\n+      0x1F1F1F1F1F1F1F1F,\n+      0x3F3F3F3F3F3F3F3F,\n+      0x7F7F7F7F7F7F7F7F,\n+  };\n+  int64_t valid_byte_offset = valid_bits_offset / 8;\n+  int64_t bit_offset = valid_bits_offset % 8;\n+\n+  int64_t new_offset = valid_bits_offset + number_of_bits;\n+  union ByteAddressableBitmap {\n+    explicit ByteAddressableBitmap(uint64_t mask) : mask(mask) {}\n+    uint64_t mask;\n+    uint8_t bytes[8];\n+  };\n+\n+  if (bit_offset != 0) {\n+    int64_t bits_to_carry = 8 - bit_offset;\n+    // Get the mask the will select the lower order bits  (the ones to carry\n+    // over to the existing byte and shift up.\n+    const ByteAddressableBitmap carry_bits(kLsbSelectionMasks[bits_to_carry]);\n+    // Mask to select non-carried bits.\n+    const ByteAddressableBitmap inverse_selection(~carry_bits.mask);\n+    // Fill out the last incomplete byte in the output, by extracting the least\n+    // siginficant bits from the first byte.\n+    const ByteAddressableBitmap new_bitmap(new_bits);\n+    // valid bits should be a valid bitmask so all trailing bytes hsould be unset\n+    // so no mask is need to start.\n+    valid_bits[valid_byte_offset] =\n+        valid_bits[valid_byte_offset] |  // See above the\n+        (((new_bitmap.bytes[0] & carry_bits.bytes[0])) << bit_offset);\n+\n+    // We illustrate logic with a 3-byte example in little endian/LSB order.\n+    // Note this ordering is the reversed from HEX masks above with are expressed\n+    // big-endian/MSB and shifts right move the bits to the left (division).\n+    // 0  1  2  3  4  5  6  7   8  9  10 11 12 13 14 15   16 17 18 19 20 21 22 23\n+    // Shifted mask should look like this assuming bit offset = 6:\n+    // 2  3  4  5  6  7  N  N   10 11 12 13 14 15  N  N   18 19 20 21 22 23  N  N\n+    // clang-format on\n+    uint64_t shifted_new_bits = (new_bits & inverse_selection.mask) >> bits_to_carry;\n+    // captured_carry:\n+    // 0  1  N  N  N  N  N  N   8  9  N  N  N   N  N  N   16 17  N  N  N  N  N  N\n+    uint64_t captured_carry = carry_bits.mask & new_bits;\n+    // mask_cary_bits:\n+    // N  N  N  N  N  N  8  9   N  N  N  N  N   N 16 17    N  N   N  N  N  N  N  N\n+    uint64_t mask_carry_bits = (captured_carry >> 8) << bit_offset;\n+\n+    new_bits = shifted_new_bits | mask_carry_bits;\n+    // Don't overwrite the first byte\n+    valid_byte_offset += 1;\n+    number_of_bits -= bits_to_carry;\n+  }\n+\n+  int64_t bytes_for_new_bits = ::arrow::BitUtil::BytesForBits(number_of_bits);\n+  if (valid_bits_length - ::arrow::BitUtil::BytesForBits(valid_bits_offset) >=\n+      static_cast<int64_t>(sizeof(new_bits))) {\n+    // This should be the common case and  inlined as a single instruction which\n+    // should be cheaper then the general case of calling mempcy, so it is likely\n+    // worth the extra branch.\n+    std::memcpy(valid_bits + valid_byte_offset, &new_bits, sizeof(new_bits));\n+  } else {\n+    std::memcpy(valid_bits + valid_byte_offset, &new_bits, bytes_for_new_bits);\n+  }\n+  return new_offset;\n+}\n+\n+/// \\brief Appends bit values to the validitdy bimap_valid bits, based on bitmaps\n+/// generated by GreaterThanBitmap, and the appropriate treshold definition_leve.\n+///\n+/// \\param[in] new_bits Bitmap to append (intrepreted as Little-endian/LSB).\n+/// \\param[in] new_bit_count The number of bits to append  from new_bits.\n+/// \\param[in,out] validity_bitmap The validity bitmap to update.\n+/// \\param[in,out] validity_bitmap_offset The offset to start appending bits to in\n+/// valid_bits (updated to latest bitmap).\n+/// \\param[in,out] set_bit_count The number of set bits appended is added to\n+/// set_bit_count.\n+void AppendToValidityBitmap(uint64_t new_bits, int64_t new_bit_count,\n+                            uint8_t* validity_bitmap, int64_t* validity_bitmap_offset,\n+                            int64_t* set_bit_count) {\n+  int64_t min_valid_bits_size =\n+      ::arrow::BitUtil::BytesForBits(new_bit_count + *validity_bitmap_offset);\n+\n+  *set_bit_count += ::arrow::BitUtil::PopCount(new_bits);\n+  *validity_bitmap_offset = AppendBitmap(new_bits, new_bit_count, min_valid_bits_size,\n+                                         *validity_bitmap_offset, validity_bitmap);\n+}\n+\n+/// The same as AppendToValidityBitmap but only appends bits from bitmap that have\n+/// a corresponding bit set in selection_bitmap.\n+///\n+/// \\returns The number of bits appended.\n+///\n+/// N.B. This is only implemented for archiectures that suppor the BMI2 instruction\n+/// set.\n+int64_t AppendSelectedBitsToValidityBitmap(uint64_t new_bits, uint64_t selection_bitmap,\n+                                           uint8_t* validity_bitmap,\n+                                           int64_t* validity_bitmap_offset,\n+                                           int64_t* set_bit_count) {\n+#if defined(ARROW_HAVE_BMI2)\n+  // If the parent list was empty at for the given slot it should not be added to the\n+  // bitmap.\n+  uint64_t selected_bits = _pext_u64(new_bits, selection_bitmap);\n+  int64_t selected_count =\n+      static_cast<int64_t>(::arrow::BitUtil::PopCount(selection_bitmap));\n+\n+  AppendToValidityBitmap(selected_bits, selected_count, validity_bitmap,\n+                         validity_bitmap_offset, set_bit_count);\n+  return selected_count;\n+#else\n+  // We shouldn't get here.\n\nReview comment:\n       done.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-26T05:22:17.476+0000",
                    "updated": "2020-04-26T05:22:17.476+0000",
                    "started": "2020-04-26T05:22:17.476+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "427284",
                    "issueId": "13297951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297951/worklog/427285",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #6985:\nURL: https://github.com/apache/arrow/pull/6985#discussion_r415221009\n\n\n\n##########\nFile path: cpp/src/parquet/level_conversion_test.cc\n##########\n@@ -0,0 +1,162 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"parquet/level_conversion.h\"\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+\n+#include <string>\n+\n+#include \"arrow/util/bit_util.h\"\n+\n+namespace parquet {\n+namespace internal {\n+\n+using ::testing::ElementsAreArray;\n+\n+std::string ToString(const uint8_t* bitmap, int64_t bit_count) {\n+  return arrow::internal::Bitmap(bitmap, /*offset*/ 0, /*length=*/bit_count).ToString();\n+}\n+\n+std::string ToString(const std::vector<uint8_t>& bitmap, int64_t bit_count) {\n+  return ToString(bitmap.data(), bit_count);\n+}\n+\n+TEST(TestGreaterThanBitmap, GeneratesExpectedBitmasks) {\n\nReview comment:\n       There was a substantial refactoring, I tried to provide guards but without a big-endian machine in CI it will be very hard to to catch all of these issues.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-26T05:28:30.089+0000",
                    "updated": "2020-04-26T05:28:30.089+0000",
                    "started": "2020-04-26T05:28:30.088+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "427285",
                    "issueId": "13297951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297951/worklog/427286",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #6985:\nURL: https://github.com/apache/arrow/pull/6985#discussion_r415221052\n\n\n\n##########\nFile path: cpp/cmake_modules/SetupCxxFlags.cmake\n##########\n@@ -40,12 +40,13 @@ if(ARROW_CPU_FLAG STREQUAL \"x86\")\n     set(CXX_SUPPORTS_SSE4_2 TRUE)\n   else()\n     set(ARROW_SSE4_2_FLAG \"-msse4.2\")\n-    set(ARROW_AVX2_FLAG \"-mavx2\")\n+    set(ARROW_AVX2_FLAG \"-march=core-avx2\")\n\nReview comment:\n       done, seems to work.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-26T05:28:53.530+0000",
                    "updated": "2020-04-26T05:28:53.530+0000",
                    "started": "2020-04-26T05:28:53.530+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "427286",
                    "issueId": "13297951"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 50400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@417e56fb[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2bb3d9fa[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@324da5c4[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@784d67e[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1c82272f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@229f5de2[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7da3aff0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@5c35a11c[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@51834eea[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@9ab7975[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@69978b9f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@185beaf0[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 50400,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Jun 04 23:58:56 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-06-04T23:58:56.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-8413/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-04-13T06:13:14.000+0000",
        "updated": "2020-06-04T23:58:56.000+0000",
        "timeoriginalestimate": null,
        "description": "The current code is should be split apart and made more efficient to consolidate logic need to support all nesting combinations.\r\n\r\n\u00a0\r\n\r\nWe need to be able to pass in an arbitrary min definitions level to prune away elements that aren't included in lists.\u00a0\u00a0\r\n\r\nThe functionality is also somewhat replicated in reading\u00a0 the struct code, the two paths should be consolidated.\r\n\r\n\u00a0\r\n\r\n\u00a0",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "14h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 50400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Refactor DefLevelsToBitmap",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297951/comment/17126276",
                    "id": "17126276",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 6985\n[https://github.com/apache/arrow/pull/6985]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-06-04T23:58:56.364+0000",
                    "updated": "2020-06-04T23:58:56.364+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0dk5c:",
        "customfield_12314139": null
    }
}