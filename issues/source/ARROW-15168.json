{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13418671",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418671",
    "key": "ARROW-15168",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351051",
                "id": "12351051",
                "description": "",
                "name": "8.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-05-06"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=paleolimbot",
            "name": "paleolimbot",
            "key": "paleolimbot",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=paleolimbot&avatarId=47795",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=paleolimbot&avatarId=47795",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=paleolimbot&avatarId=47795",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=paleolimbot&avatarId=47795"
            },
            "displayName": "Dewey Dunnington",
            "active": true,
            "timeZone": "America/Halifax"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333008",
                "id": "12333008",
                "name": "R"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=paleolimbot",
            "name": "paleolimbot",
            "key": "paleolimbot",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=paleolimbot&avatarId=47795",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=paleolimbot&avatarId=47795",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=paleolimbot&avatarId=47795",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=paleolimbot&avatarId=47795"
            },
            "displayName": "Dewey Dunnington",
            "active": true,
            "timeZone": "America/Halifax"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=paleolimbot",
            "name": "paleolimbot",
            "key": "paleolimbot",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=paleolimbot&avatarId=47795",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=paleolimbot&avatarId=47795",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=paleolimbot&avatarId=47795",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=paleolimbot&avatarId=47795"
            },
            "displayName": "Dewey Dunnington",
            "active": true,
            "timeZone": "America/Halifax"
        },
        "aggregateprogress": {
            "progress": 33600,
            "total": 33600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 33600,
            "total": 33600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15168/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 56,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418671/worklog/753638",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #12817:\nURL: https://github.com/apache/arrow/pull/12817#issuecomment-1090703225\n\n   https://issues.apache.org/jira/browse/ARROW-15168\n\n\n",
                    "created": "2022-04-06T19:47:09.197+0000",
                    "updated": "2022-04-06T19:47:09.197+0000",
                    "started": "2022-04-06T19:47:09.197+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "753638",
                    "issueId": "13418671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418671/worklog/753639",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #12817:\nURL: https://github.com/apache/arrow/pull/12817#issuecomment-1090703307\n\n   :warning: Ticket **has not been started in JIRA**, please click 'Start Progress'.\n\n\n",
                    "created": "2022-04-06T19:47:11.110+0000",
                    "updated": "2022-04-06T19:47:11.110+0000",
                    "started": "2022-04-06T19:47:11.110+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "753639",
                    "issueId": "13418671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418671/worklog/757152",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paleolimbot commented on PR #12817:\nURL: https://github.com/apache/arrow/pull/12817#issuecomment-1099521412\n\n   Ok! This is ready for a review. The main motivation here is to allow other packages to define conversions to Arrow objects. This is most useful for Table objects, since we currently convert to Table before `write_parquet/ipc_stream/feather/csv_arrow()` and because converting an R vector, and for Array objects, because the R Vector -> Array conversion is at the heart of the default conversion to Table. A motivating project for these methods is 'geoarrow', which implements an ExtensionType to store geometry columns (e.g., `sf::st_sfc()`) and table-level metadata for table-level objects (e.g., `sf::st_sf()`).\r\n   \r\n   Other methods I added here are important for lower-level packages like the work-in-progress 'substrait' and 'narrow', where there are analogues for `DataType` (e.g., the `narrow_schema()` or `substrait.Type`), `Schema` (e.g., the `narrow_schema()` or `substrait.NamedStruct`) , and `RecordBatchReader` (e.g., the `narrow_array_stream()`). In particular, I think that `as_record_batch_reader()` will be very useful (more flexible than `Table` for things like database results that can be streamed into the writers).\r\n   \r\n   Adding the S3 methods was reasonably straightforward; however, actually using them was quite complicated because R Vector -> Array conversion is highly optimized and mostly done in C++. The approach I took was to keep the existing code, changing as little as possible, for R objects that we handle internally. For other objects, the C++ code calls `type()` and `as_arrow_array()`. As is apparent based on the number of files changed by this PR, that \"simple\" approach lead to a whack-a-mole of test failures that I think I was able to solve with a minimal footprint; however, another option is to close this PR and tackle the changes in reverse order with smaller PRs.\r\n   \r\n   In a nutshell, before, users were stuck with the built-in behaviour for objects with a custom class. This was usually OK, but occasionally sub-optimal, non-functional, or corupting. I've picked a probably rare example because record-style vectors are new, but the current set of conversions assumes that they're list-like (as opposed to data-frame like):\r\n   \r\n   ``` r\r\n   # install.packages(\"arrow\")\r\n   library(arrow, warn.conflicts = FALSE)\r\n   \r\n   tbl <- tibble::tibble(\r\n     x = 1:5,\r\n     points = wk::xy(x = 1:5, y = 6:10)\r\n   )\r\n   \r\n   # wk::xy() is a record-style vector, like POSIXlt, with a vctrs implementation\r\n   str(unclass(tbl$points))\r\n   #> List of 2\r\n   #>  $ x: num [1:5] 1 2 3 4 5\r\n   #>  $ y: num [1:5] 6 7 8 9 10\r\n   \r\n   # in the release version this this fails\r\n   Table$create(tbl)\r\n   #> Error: Invalid: All columns must have the same length\r\n   \r\n   # ...or generates bogus output\r\n   as.data.frame(Table$create(x = 1:2, points = tbl$points))\r\n   #> Warning: Invalid metadata$r\r\n   #> # A tibble: 2 \u00d7 2\r\n   #>       x         points\r\n   #>   <int> <list<double>>\r\n   #> 1     1            [5]\r\n   #> 2     2            [5]\r\n   ```\r\n   \r\n   After this PR you can define `type()` and `as_arrow_array()` and the conversion should \"just work\". This is particularly useful in conjunction with the new extension type support, which can handle most (non-list-based) vctr classes (e.g., this PR removes the internal conversions for POSIXlt and haven types because the vctrs extension array handles them out of the box).\r\n   \r\n   ``` r\r\n   # remotes::install_github(\"apache/arrow/r#12817\")\r\n   library(arrow, warn.conflicts = FALSE)\r\n   \r\n   tbl <- tibble::tibble(\r\n     x = 1:5,\r\n     points = wk::xy(x = 1:5, y = 6:10)\r\n   )\r\n   \r\n   # wk::xy() is a record-style vector, like POSIXlt, with a vctrs implementation\r\n   str(unclass(tbl$points))\r\n   #> List of 2\r\n   #>  $ x: num [1:5] 1 2 3 4 5\r\n   #>  $ y: num [1:5] 6 7 8 9 10\r\n   \r\n   # this now fails:\r\n   tf <- tempfile()\r\n   write_feather(tbl, tf)\r\n   #> Error:\r\n   #> ! Can't infer Arrow data type from object inheriting from wk_xy / wk_rcrd\r\n   \r\n   # until...\r\n   type.wk_xy <- function(x, ...) {\r\n     vctrs_extension_type(vctrs::vec_ptype(x))\r\n   }\r\n   \r\n   as_arrow_array.wk_xy <- function(x, ...) {\r\n     vctrs_extension_array(x)\r\n   }\r\n   \r\n   # now works!\r\n   write_feather(tbl, tf)\r\n   read_feather(tf)\r\n   #> # A tibble: 5 \u00d7 2\r\n   #>       x points \r\n   #>   <int> <wk_xy>\r\n   #> 1     1 (1  6) \r\n   #> 2     2 (2  7) \r\n   #> 3     3 (3  8) \r\n   #> 4     4 (4  9) \r\n   #> 5     5 (5 10)\r\n   \r\n   # if for some reason the extension type is not loaded, we get the storage type\r\n   # with no warning (maybe not ideal?)\r\n   arrow::unregister_extension_type(\"arrow.r.vctrs\")\r\n   read_feather(tf)\r\n   #> # A tibble: 5 \u00d7 2\r\n   #>       x points$x    $y\r\n   #>   <int>    <dbl> <dbl>\r\n   #> 1     1        1     6\r\n   #> 2     2        2     7\r\n   #> 3     3        3     8\r\n   #> 4     4        4     9\r\n   #> 5     5        5    10\r\n   ```\r\n   \r\n   <sup>Created on 2022-04-14 by the [reprex package](https://reprex.tidyverse.org) (v2.0.1)</sup>\n\n\n",
                    "created": "2022-04-14T18:43:42.834+0000",
                    "updated": "2022-04-14T18:43:42.834+0000",
                    "started": "2022-04-14T18:43:42.833+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "757152",
                    "issueId": "13418671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418671/worklog/757237",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wjones127 commented on code in PR #12817:\nURL: https://github.com/apache/arrow/pull/12817#discussion_r850805719\n\n\n##########\nr/R/record-batch-reader.R:\n##########\n@@ -176,3 +176,37 @@ RecordBatchFileReader$create <- function(file) {\n   assert_is(file, \"InputStream\")\n   ipc___RecordBatchFileReader__Open(file)\n }\n+\n+#' Convert an object to an Arrow RecordBatchReader\n+#'\n+#' @param x An object to convert to a [RecordBatchReader]\n+#' @param ... Passed to S3 methods\n+#'\n+#' @return A [RecordBatchReader]\n+#' @export\n+#'\n+#' @examplesIf arrow_available() && arrow_with_dataset()\n+#' reader <- as_record_batch_reader(data.frame(col1 = 1, col2 = \"two\"))\n+#' reader$read_next_batch()\n+#'\n+as_record_batch_reader <- function(x, ...) {\n+  UseMethod(\"as_record_batch_reader\")\n+}\n+\n+#' @rdname as_record_batch_reader\n+#' @export\n+as_record_batch_reader.RecordBatchReader <- function(x, ...) {\n+  x\n+}\n+\n+#' @rdname as_arrow_table\n\nReview Comment:\n   ```suggestion\n   #' @rdname as_record_batch_reader\n   ```\n\n\n\n##########\nr/R/record-batch-reader.R:\n##########\n@@ -176,3 +176,37 @@ RecordBatchFileReader$create <- function(file) {\n   assert_is(file, \"InputStream\")\n   ipc___RecordBatchFileReader__Open(file)\n }\n+\n+#' Convert an object to an Arrow RecordBatchReader\n+#'\n+#' @param x An object to convert to a [RecordBatchReader]\n+#' @param ... Passed to S3 methods\n+#'\n+#' @return A [RecordBatchReader]\n+#' @export\n+#'\n+#' @examplesIf arrow_available() && arrow_with_dataset()\n+#' reader <- as_record_batch_reader(data.frame(col1 = 1, col2 = \"two\"))\n+#' reader$read_next_batch()\n+#'\n+as_record_batch_reader <- function(x, ...) {\n+  UseMethod(\"as_record_batch_reader\")\n+}\n+\n+#' @rdname as_record_batch_reader\n+#' @export\n+as_record_batch_reader.RecordBatchReader <- function(x, ...) {\n+  x\n+}\n+\n+#' @rdname as_arrow_table\n+#' @export\n+as_record_batch_reader.default <- function(x, ...) {\n+  Scanner$create(x)$ToRecordBatchReader()\n+}\n+\n+#' @rdname as_arrow_table\n\nReview Comment:\n   ```suggestion\n   #' @rdname as_record_batch_reader\n   ```\n\n\n\n##########\nr/R/type.R:\n##########\n@@ -69,16 +70,43 @@ FLOAT_TYPES <- c(\"float16\", \"float32\", \"float64\", \"halffloat\", \"float\", \"double\"\n #' type(mtcars)\n #' type(Sys.Date())\n #' @export\n-type <- function(x) UseMethod(\"type\")\n+type <- function(x, ...) UseMethod(\"type\")\n \n #' @export\n-type.default <- function(x) Array__infer_type(x)\n+type.default <- function(x, ..., from_array_infer_type = FALSE) {\n+  # If from_array_infer_type is TRUE, this is a call from C++ and there was\n+  # no S3 method defined for this object.\n+  if (from_array_infer_type) {\n+    abort(\n+      sprintf(\n+        \"Can't infer Arrow data type from object inheriting from %s\",\n+        paste(class(x), collapse = \" / \")\n+      )\n+    )\n+  }\n+\n+  # If from_array_infer_type is FALSE, this is a user calling type() from R\n+  # and we to call into C++. If there is no built-in conversion for this\n+  # object type, C++ will call back here with from_array_infer_type = TRUE\n+  # to generate a nice error message.\n+  Array__infer_type(x)\n+}\n+\n+#' @export\n+type.ArrowDatum <- function(x, ...) x$type\n+\n+#' @export\n+type.Expression <- function(x, ...) x$type()\n \n #' @export\n-type.ArrowDatum <- function(x) x$type\n+type.vctrs_vctr <- function(x, ...) {\n+  vctrs_extension_type(vctrs::vec_ptype(x))\n+}\n \n #' @export\n\nReview Comment:\n   I'm not sure we care, but I noticed we don't show these other implementations in the docs, like we do with the other S3 methods.\n\n\n\n##########\nr/R/util.R:\n##########\n@@ -138,18 +138,17 @@ handle_parquet_io_error <- function(e, format) {\n   stop(e)\n }\n \n-is_writable_table <- function(x) {\n-  inherits(x, c(\"data.frame\", \"ArrowTabular\"))\n-}\n-\n-# This attribute is used when is_writable is passed into assert_that, and allows\n-# the call to form part of the error message when is_writable is FALSE\n-attr(is_writable_table, \"fail\") <- function(call, env) {\n-  paste0(\n-    deparse(call$x),\n-    \" must be an object of class 'data.frame', 'RecordBatch', or 'Table', not '\",\n-    class(env[[deparse(call$x)]])[[1]],\n-    \"'.\"\n+as_writable_table <- function(x, arg_name = \"x\") {\n\nReview Comment:\n   If we are passing down the `arg_name`, do we want to also take the call object to pass in? That would make it so the function calling this helper would be shown instead of `as_writable_table` in the error chain.\n\n\n\n##########\nr/src/table.cpp:\n##########\n@@ -226,20 +222,41 @@ arrow::Status AddMetadataFromDots(SEXP lst, int num_fields,\n   cpp11::writable::list metadata(2);\n   metadata.names() = arrow::r::data::names_metadata;\n \n-  bool has_metadata = false;\n+  bool has_top_level_metadata = false;\n \n   // \"top level\" attributes, only relevant if the first object is not named and a data\n   // frame\n   cpp11::strings names = Rf_getAttrib(lst, R_NamesSymbol);\n   if (names[0] == \"\" && Rf_inherits(VECTOR_ELT(lst, 0), \"data.frame\")) {\n     SEXP top_level = metadata[0] = arrow_attributes(VECTOR_ELT(lst, 0), true);\n     if (!Rf_isNull(top_level) && XLENGTH(top_level) > 0) {\n-      has_metadata = true;\n+      has_top_level_metadata = true;\n     }\n   }\n \n   // recurse to get all columns metadata\n-  metadata[1] = CollectColumnMetadata(lst, num_fields, has_metadata);\n+  cpp11::writable::list metadata_columns = CollectColumnMetadata(lst, num_fields);\n+\n+  // Remove metadata for ExtensionType columns, because these have their own mechanism for\n+  // preserving R type information\n+  for (R_xlen_t i = 0; i < schema->num_fields(); i++) {\n+    if (schema->field(i)->type()->id() == Type::EXTENSION) {\n+      metadata_columns[i] = R_NilValue;\n\nReview Comment:\n   Does this handle nested ExtensionType columns? is that a worry at all?\n\n\n\n##########\nr/R/type.R:\n##########\n@@ -59,6 +59,7 @@ FLOAT_TYPES <- c(\"float16\", \"float32\", \"float64\", \"halffloat\", \"float\", \"double\"\n #' infer the arrow Array type from an R vector\n #'\n #' @param x an R vector\n\nReview Comment:\n   This says \"an R vector\", but it seems it's much more expansive than that now. Should we update this? (Or maybe \"vector\" is just a very expansive term in R; is a list of dataframes a vector?)\n\n\n\n##########\nr/tests/testthat/test-metadata.R:\n##########\n@@ -63,6 +63,13 @@ test_that(\"R metadata is not stored for types that map to Arrow types (factor, D\n   expect_null(Table$create(example_with_times[1:3])$metadata$r)\n })\n \n+test_that(\"R metadata is not stored for ExtensionType columns\", {\n+  tab <- Table$create(\n+    x = vctrs::new_vctr(1:5, class = \"special_integer\")\n+  )\n\nReview Comment:\n   Was checking if this works if the extensiontype is nested too, but ran into error:\n   \n   ```r\n   tab <- Table$create(\n     x = data.frame(a = vctrs::new_vctr(1:5, class = \"special_integer\"))\n   )\n   # Error: NotImplemented: extension\n   ```\n\n\n\n",
                    "created": "2022-04-14T22:22:31.529+0000",
                    "updated": "2022-04-14T22:22:31.529+0000",
                    "started": "2022-04-14T22:22:31.528+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "757237",
                    "issueId": "13418671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418671/worklog/757899",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson commented on code in PR #12817:\nURL: https://github.com/apache/arrow/pull/12817#discussion_r852136789\n\n\n##########\nr/R/chunked-array.R:\n##########\n@@ -153,3 +153,47 @@ ChunkedArray$create <- function(..., type = NULL) {\n #' @rdname ChunkedArray\n #' @export\n chunked_array <- ChunkedArray$create\n+\n+#' Convert an object to an Arrow ChunkedArray\n+#'\n+#' Whereas [chunked_array()] constructs a [ChunkedArray] from zero or more\n+#' [Array]s, `as_chunked_array()` converts a single object to a\n\nReview Comment:\n   `ChunkedArray$create()` accepts R vectors too\n\n\n\n##########\nr/R/array.R:\n##########\n@@ -217,6 +217,93 @@ Array$create <- function(x, type = NULL) {\n Array$import_from_c <- ImportArray\n \n \n+#' Convert an object to an Arrow Array\n+#'\n+#' Whereas `Array$create()` constructs an [Array] from the built-in data types\n+#' for which the Arrow package implements fast converters, `as_arrow_array()`\n+#' provides a means by which other packages can define conversions to Arrow\n+#' objects.\n+#'\n+#' @param x An object to convert to an Arrow Array\n+#' @param ... Passed to S3 methods\n+#' @param type A [type][data-type] for the final Array. A value of `NULL`\n+#'   will default to the type guessed by [type()].\n+#'\n+#' @return An [Array].\n+#' @export\n+#'\n+#' @examplesIf arrow_available()\n+#' as_arrow_array(1:5)\n+#'\n+as_arrow_array <- function(x, ..., type = NULL) {\n+  UseMethod(\"as_arrow_array\")\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.Array <- function(x, ..., type = NULL) {\n+  if (is.null(type)) {\n+    x\n+  } else {\n+    x$cast(type)\n+  }\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.ChunkedArray <- function(x, ..., type = NULL) {\n+  concat_arrays(!!! x$chunks, type = type)\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.vctrs_vctr <- function(x, ..., type = NULL) {\n+  if (is.null(type)) {\n+    vctrs_extension_array(x)\n+  } else if (inherits(type, \"VctrsExtensionType\")) {\n+    vctrs_extension_array(\n+      x,\n+      ptype = type$ptype(),\n+      storage_type = type$storage_type()\n+    )\n+  } else {\n+    NextMethod()\n+  }\n+}\n+\n+#' @export\n+as_arrow_array.POSIXlt <- function(x, ..., type = NULL) {\n+  as_arrow_array.vctrs_vctr(x, ..., type = type)\n\nReview Comment:\n   Is there a risk of infinite loop if you have an object with class `c(\"vctrs_vctr\", \"POSIXlt\")`? Or do we trust NextMethod() to do sane things?\n\n\n\n##########\nr/R/type.R:\n##########\n@@ -69,16 +70,43 @@ FLOAT_TYPES <- c(\"float16\", \"float32\", \"float64\", \"halffloat\", \"float\", \"double\"\n #' type(mtcars)\n #' type(Sys.Date())\n #' @export\n-type <- function(x) UseMethod(\"type\")\n+type <- function(x, ...) UseMethod(\"type\")\n \n #' @export\n-type.default <- function(x) Array__infer_type(x)\n+type.default <- function(x, ..., from_array_infer_type = FALSE) {\n+  # If from_array_infer_type is TRUE, this is a call from C++ and there was\n+  # no S3 method defined for this object.\n+  if (from_array_infer_type) {\n+    abort(\n+      sprintf(\n+        \"Can't infer Arrow data type from object inheriting from %s\",\n+        paste(class(x), collapse = \" / \")\n+      )\n+    )\n+  }\n+\n+  # If from_array_infer_type is FALSE, this is a user calling type() from R\n+  # and we to call into C++. If there is no built-in conversion for this\n+  # object type, C++ will call back here with from_array_infer_type = TRUE\n\nReview Comment:\n   Again, why do we need to call back to R? We can throw errors from C++, there shouldn't be any information in R that we don't have in C++.\n\n\n\n##########\nr/R/array.R:\n##########\n@@ -217,6 +217,93 @@ Array$create <- function(x, type = NULL) {\n Array$import_from_c <- ImportArray\n \n \n+#' Convert an object to an Arrow Array\n+#'\n+#' Whereas `Array$create()` constructs an [Array] from the built-in data types\n+#' for which the Arrow package implements fast converters, `as_arrow_array()`\n+#' provides a means by which other packages can define conversions to Arrow\n+#' objects.\n+#'\n+#' @param x An object to convert to an Arrow Array\n+#' @param ... Passed to S3 methods\n+#' @param type A [type][data-type] for the final Array. A value of `NULL`\n+#'   will default to the type guessed by [type()].\n+#'\n+#' @return An [Array].\n+#' @export\n+#'\n+#' @examplesIf arrow_available()\n+#' as_arrow_array(1:5)\n+#'\n+as_arrow_array <- function(x, ..., type = NULL) {\n+  UseMethod(\"as_arrow_array\")\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.Array <- function(x, ..., type = NULL) {\n+  if (is.null(type)) {\n+    x\n+  } else {\n+    x$cast(type)\n+  }\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.ChunkedArray <- function(x, ..., type = NULL) {\n+  concat_arrays(!!! x$chunks, type = type)\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.vctrs_vctr <- function(x, ..., type = NULL) {\n+  if (is.null(type)) {\n+    vctrs_extension_array(x)\n+  } else if (inherits(type, \"VctrsExtensionType\")) {\n+    vctrs_extension_array(\n+      x,\n+      ptype = type$ptype(),\n+      storage_type = type$storage_type()\n+    )\n+  } else {\n+    NextMethod()\n+  }\n+}\n+\n+#' @export\n+as_arrow_array.POSIXlt <- function(x, ..., type = NULL) {\n+  as_arrow_array.vctrs_vctr(x, ..., type = type)\n+}\n+\n+\n+#' @export\n+as_arrow_array.default <- function(x, ..., type = NULL, from_constructor = FALSE) {\n+  # If from_constructor is TRUE, this is a call from C++ for which S3 dispatch\n+  # failed to find a method for the object. If this is the case, we error.\n+  if (from_constructor && is.null(type)) {\n+    abort(\n+      sprintf(\n+        \"Can't create Array from object of type %s\",\n+        paste(class(x), collapse = \" / \")\n+      )\n+    )\n+  } else if (from_constructor) {\n+    abort(\n+      sprintf(\n+        \"Can't create Array<%s> from object of type %s\",\n+        format(type$code()),\n+        paste(class(x), collapse = \" / \")\n+      )\n+    )\n+  }\n+\n+  # If from_constructor is FALSE, we use the built-in logic exposed by\n+  # Array$create(). If there is no built-in conversion, C++ will call back\n+  # here with from_constructor = TRUE to generate a nice error message.\n\nReview Comment:\n   Why does C++ have to call back here to create an error message?\n\n\n\n##########\nr/R/type.R:\n##########\n@@ -69,16 +70,43 @@ FLOAT_TYPES <- c(\"float16\", \"float32\", \"float64\", \"halffloat\", \"float\", \"double\"\n #' type(mtcars)\n #' type(Sys.Date())\n #' @export\n-type <- function(x) UseMethod(\"type\")\n+type <- function(x, ...) UseMethod(\"type\")\n\nReview Comment:\n   Should this migrate to be called `data_type`? Seems inconsistent with `as_data_type`.\n\n\n\n##########\nr/R/record-batch-reader.R:\n##########\n@@ -176,3 +176,37 @@ RecordBatchFileReader$create <- function(file) {\n   assert_is(file, \"InputStream\")\n   ipc___RecordBatchFileReader__Open(file)\n }\n+\n+#' Convert an object to an Arrow RecordBatchReader\n+#'\n+#' @param x An object to convert to a [RecordBatchReader]\n+#' @param ... Passed to S3 methods\n+#'\n+#' @return A [RecordBatchReader]\n+#' @export\n+#'\n+#' @examplesIf arrow_available() && arrow_with_dataset()\n+#' reader <- as_record_batch_reader(data.frame(col1 = 1, col2 = \"two\"))\n+#' reader$read_next_batch()\n+#'\n+as_record_batch_reader <- function(x, ...) {\n+  UseMethod(\"as_record_batch_reader\")\n+}\n+\n+#' @rdname as_record_batch_reader\n+#' @export\n+as_record_batch_reader.RecordBatchReader <- function(x, ...) {\n+  x\n+}\n+\n+#' @rdname as_arrow_table\n+#' @export\n+as_record_batch_reader.default <- function(x, ...) {\n+  Scanner$create(x)$ToRecordBatchReader()\n\nReview Comment:\n   I'm not sure we want this. We're trying to reduce or eliminate our usage of Scanner, and this is also masking a bunch of complexity. \n\n\n\n##########\nr/R/record-batch.R:\n##########\n@@ -189,3 +189,58 @@ record_batch <- RecordBatch$create\n \n #' @export\n names.RecordBatch <- function(x) x$names()\n+\n+#' Convert an object to an Arrow RecordBatch\n+#'\n+#' Whereas [record_batch()] constructs a [RecordBatch] from one or more columns,\n+#' `as_record_batch()` converts a single object to an Arrow [RecordBatch].\n+#'\n+#' @param x An object to convert to an Arrow RecordBatch\n+#' @param ... Passed to S3 methods\n+#' @inheritParams record_batch\n+#'\n+#' @return A [RecordBatch]\n+#' @export\n+#'\n+#' @examplesIf arrow_available()\n+#' as_record_batch(data.frame(col1 = 1, col2 = \"two\"))\n+#'\n+as_record_batch <- function(x, ..., schema = NULL) {\n+  UseMethod(\"as_record_batch\")\n+}\n+\n+#' @rdname as_record_batch\n+#' @export\n+as_record_batch.RecordBatch <- function(x, ..., schema = NULL) {\n+  if (is.null(schema)) {\n+    x\n+  } else {\n+    x$cast(schema)\n+  }\n+}\n+\n+#' @rdname as_record_batch\n+#' @export\n+as_record_batch.Table <- function(x, ..., schema = NULL) {\n+  if (x$num_columns == 0) {\n+    batch <- record_batch(data.frame())\n+    return(batch$Take(rep_len(0, x$num_rows)))\n+  }\n+\n+  arrays_out <- vector(mode = \"list\", length = x$num_columns)\n+  for (i in seq_len(x$num_columns)) {\n+    arrays_out[[i]] <- as_arrow_array(\n+      x$column(i - 1L),\n+      type = schema[[i]]$type\n+    )\n+  }\n+  names(arrays_out) <- names(x)\n+\n+  record_batch(!!! arrays_out)\n\nReview Comment:\n   ```suggestion\r\n     arrays_out <- lapply(x$columns, as_arrow_array)\r\n     out <- RecordBatch$create(!!!arrays_out)\r\n     if (!is.null(schema)) {\r\n       out <- out$cast(schema)\r\n     }\r\n     out\r\n   ```\n\n\n\n",
                    "created": "2022-04-18T14:15:57.504+0000",
                    "updated": "2022-04-18T14:15:57.504+0000",
                    "started": "2022-04-18T14:15:57.504+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "757899",
                    "issueId": "13418671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418671/worklog/757948",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paleolimbot commented on code in PR #12817:\nURL: https://github.com/apache/arrow/pull/12817#discussion_r852216643\n\n\n##########\nr/R/array.R:\n##########\n@@ -217,6 +217,93 @@ Array$create <- function(x, type = NULL) {\n Array$import_from_c <- ImportArray\n \n \n+#' Convert an object to an Arrow Array\n+#'\n+#' Whereas `Array$create()` constructs an [Array] from the built-in data types\n+#' for which the Arrow package implements fast converters, `as_arrow_array()`\n+#' provides a means by which other packages can define conversions to Arrow\n+#' objects.\n+#'\n+#' @param x An object to convert to an Arrow Array\n+#' @param ... Passed to S3 methods\n+#' @param type A [type][data-type] for the final Array. A value of `NULL`\n+#'   will default to the type guessed by [type()].\n+#'\n+#' @return An [Array].\n+#' @export\n+#'\n+#' @examplesIf arrow_available()\n+#' as_arrow_array(1:5)\n+#'\n+as_arrow_array <- function(x, ..., type = NULL) {\n+  UseMethod(\"as_arrow_array\")\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.Array <- function(x, ..., type = NULL) {\n+  if (is.null(type)) {\n+    x\n+  } else {\n+    x$cast(type)\n+  }\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.ChunkedArray <- function(x, ..., type = NULL) {\n+  concat_arrays(!!! x$chunks, type = type)\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.vctrs_vctr <- function(x, ..., type = NULL) {\n+  if (is.null(type)) {\n+    vctrs_extension_array(x)\n+  } else if (inherits(type, \"VctrsExtensionType\")) {\n+    vctrs_extension_array(\n+      x,\n+      ptype = type$ptype(),\n+      storage_type = type$storage_type()\n+    )\n+  } else {\n+    NextMethod()\n+  }\n+}\n+\n+#' @export\n+as_arrow_array.POSIXlt <- function(x, ..., type = NULL) {\n+  as_arrow_array.vctrs_vctr(x, ..., type = type)\n\nReview Comment:\n   I hadn't considered that! It doesn't look like that example causes problems and I haven't historically had problems with `NextMethod()`. Is there a related case I should be checking?\r\n   \r\n   ``` r\r\n   # remotes::install_github(\"apache/arrow/r#12817\")\r\n   library(arrow, warn.conflicts = FALSE)\r\n   \r\n   x <- as.POSIXlt(Sys.Date())\r\n   class(x) <- c(\"vctrs_vctr\", \"POSIXlt\")\r\n   array <- as_arrow_array(x)\r\n   x2 <- as.vector(array)\r\n   class(x2)\r\n   #> [1] \"vctrs_vctr\" \"POSIXlt\"\r\n   ```\n\n\n\n",
                    "created": "2022-04-18T15:54:51.040+0000",
                    "updated": "2022-04-18T15:54:51.040+0000",
                    "started": "2022-04-18T15:54:51.039+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "757948",
                    "issueId": "13418671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418671/worklog/757950",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson commented on code in PR #12817:\nURL: https://github.com/apache/arrow/pull/12817#discussion_r852219775\n\n\n##########\nr/R/array.R:\n##########\n@@ -217,6 +217,93 @@ Array$create <- function(x, type = NULL) {\n Array$import_from_c <- ImportArray\n \n \n+#' Convert an object to an Arrow Array\n+#'\n+#' Whereas `Array$create()` constructs an [Array] from the built-in data types\n+#' for which the Arrow package implements fast converters, `as_arrow_array()`\n+#' provides a means by which other packages can define conversions to Arrow\n+#' objects.\n+#'\n+#' @param x An object to convert to an Arrow Array\n+#' @param ... Passed to S3 methods\n+#' @param type A [type][data-type] for the final Array. A value of `NULL`\n+#'   will default to the type guessed by [type()].\n+#'\n+#' @return An [Array].\n+#' @export\n+#'\n+#' @examplesIf arrow_available()\n+#' as_arrow_array(1:5)\n+#'\n+as_arrow_array <- function(x, ..., type = NULL) {\n+  UseMethod(\"as_arrow_array\")\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.Array <- function(x, ..., type = NULL) {\n+  if (is.null(type)) {\n+    x\n+  } else {\n+    x$cast(type)\n+  }\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.ChunkedArray <- function(x, ..., type = NULL) {\n+  concat_arrays(!!! x$chunks, type = type)\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.vctrs_vctr <- function(x, ..., type = NULL) {\n+  if (is.null(type)) {\n+    vctrs_extension_array(x)\n+  } else if (inherits(type, \"VctrsExtensionType\")) {\n+    vctrs_extension_array(\n+      x,\n+      ptype = type$ptype(),\n+      storage_type = type$storage_type()\n+    )\n+  } else {\n+    NextMethod()\n+  }\n+}\n+\n+#' @export\n+as_arrow_array.POSIXlt <- function(x, ..., type = NULL) {\n+  as_arrow_array.vctrs_vctr(x, ..., type = type)\n\nReview Comment:\n   No, I was just seeing the vctrs_vctr method doing NextMethod() and POSIXlt calling vctrs_vctr so thought they would bounce back to each other, and maybe they do but NextMethod handles it.\n\n\n\n",
                    "created": "2022-04-18T15:59:31.438+0000",
                    "updated": "2022-04-18T15:59:31.438+0000",
                    "started": "2022-04-18T15:59:31.438+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "757950",
                    "issueId": "13418671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418671/worklog/757952",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paleolimbot commented on code in PR #12817:\nURL: https://github.com/apache/arrow/pull/12817#discussion_r852224810\n\n\n##########\nr/R/array.R:\n##########\n@@ -217,6 +217,93 @@ Array$create <- function(x, type = NULL) {\n Array$import_from_c <- ImportArray\n \n \n+#' Convert an object to an Arrow Array\n+#'\n+#' Whereas `Array$create()` constructs an [Array] from the built-in data types\n+#' for which the Arrow package implements fast converters, `as_arrow_array()`\n+#' provides a means by which other packages can define conversions to Arrow\n+#' objects.\n+#'\n+#' @param x An object to convert to an Arrow Array\n+#' @param ... Passed to S3 methods\n+#' @param type A [type][data-type] for the final Array. A value of `NULL`\n+#'   will default to the type guessed by [type()].\n+#'\n+#' @return An [Array].\n+#' @export\n+#'\n+#' @examplesIf arrow_available()\n+#' as_arrow_array(1:5)\n+#'\n+as_arrow_array <- function(x, ..., type = NULL) {\n+  UseMethod(\"as_arrow_array\")\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.Array <- function(x, ..., type = NULL) {\n+  if (is.null(type)) {\n+    x\n+  } else {\n+    x$cast(type)\n+  }\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.ChunkedArray <- function(x, ..., type = NULL) {\n+  concat_arrays(!!! x$chunks, type = type)\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.vctrs_vctr <- function(x, ..., type = NULL) {\n+  if (is.null(type)) {\n+    vctrs_extension_array(x)\n+  } else if (inherits(type, \"VctrsExtensionType\")) {\n+    vctrs_extension_array(\n+      x,\n+      ptype = type$ptype(),\n+      storage_type = type$storage_type()\n+    )\n+  } else {\n+    NextMethod()\n+  }\n+}\n+\n+#' @export\n+as_arrow_array.POSIXlt <- function(x, ..., type = NULL) {\n+  as_arrow_array.vctrs_vctr(x, ..., type = type)\n+}\n+\n+\n+#' @export\n+as_arrow_array.default <- function(x, ..., type = NULL, from_constructor = FALSE) {\n+  # If from_constructor is TRUE, this is a call from C++ for which S3 dispatch\n+  # failed to find a method for the object. If this is the case, we error.\n+  if (from_constructor && is.null(type)) {\n+    abort(\n+      sprintf(\n+        \"Can't create Array from object of type %s\",\n+        paste(class(x), collapse = \" / \")\n+      )\n+    )\n+  } else if (from_constructor) {\n+    abort(\n+      sprintf(\n+        \"Can't create Array<%s> from object of type %s\",\n+        format(type$code()),\n+        paste(class(x), collapse = \" / \")\n+      )\n+    )\n+  }\n+\n+  # If from_constructor is FALSE, we use the built-in logic exposed by\n+  # Array$create(). If there is no built-in conversion, C++ will call back\n+  # here with from_constructor = TRUE to generate a nice error message.\n\nReview Comment:\n   I agree that it's weird. It's because array creation occurs from both R and C++ (and most of the time the call comes from C++). For example, `Table$create()` does:\r\n   \r\n   - `[R] Table$create()`\r\n   - `[C++] Table__from_dots()` \r\n       - `[C++] arrow::r::RConverter` (using all the old code pathways if we handle that object type internally, or) \r\n       - `arrow::r::RExtensionConverter` -> `[R] as_arrow_array()`.\r\n   \r\n   Other R calls that use this or a similar path are `Array$create()`, `ChunkedArray$create()` and  `RecordBatch$create()`. Perhaps some of that usage should use `as_arrow_array()` instead, but table creation in particular makes good use of threading and this was the best I came up with that didn't undo all of that optimization!\n\n\n\n",
                    "created": "2022-04-18T16:07:17.331+0000",
                    "updated": "2022-04-18T16:07:17.331+0000",
                    "started": "2022-04-18T16:07:17.330+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "757952",
                    "issueId": "13418671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418671/worklog/757961",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paleolimbot commented on code in PR #12817:\nURL: https://github.com/apache/arrow/pull/12817#discussion_r852234012\n\n\n##########\nr/R/record-batch-reader.R:\n##########\n@@ -176,3 +176,37 @@ RecordBatchFileReader$create <- function(file) {\n   assert_is(file, \"InputStream\")\n   ipc___RecordBatchFileReader__Open(file)\n }\n+\n+#' Convert an object to an Arrow RecordBatchReader\n+#'\n+#' @param x An object to convert to a [RecordBatchReader]\n+#' @param ... Passed to S3 methods\n+#'\n+#' @return A [RecordBatchReader]\n+#' @export\n+#'\n+#' @examplesIf arrow_available() && arrow_with_dataset()\n+#' reader <- as_record_batch_reader(data.frame(col1 = 1, col2 = \"two\"))\n+#' reader$read_next_batch()\n+#'\n+as_record_batch_reader <- function(x, ...) {\n+  UseMethod(\"as_record_batch_reader\")\n+}\n+\n+#' @rdname as_record_batch_reader\n+#' @export\n+as_record_batch_reader.RecordBatchReader <- function(x, ...) {\n+  x\n+}\n+\n+#' @rdname as_arrow_table\n+#' @export\n+as_record_batch_reader.default <- function(x, ...) {\n+  Scanner$create(x)$ToRecordBatchReader()\n\nReview Comment:\n   That's a good point and it definitely shouldn't be in the default method. Is there a better bit of code I should use to handle all the ArrowTabulars (data.frame, Dataset, Table, RecordBatch, etc?). I don't think we have to provide any guarantees about the result or keep the options stable across versions (if a user or developer does want to provide options regarding size or ordering of batches, they can create a `RecordBatchReader` themselves?).\n\n\n\n",
                    "created": "2022-04-18T16:21:38.261+0000",
                    "updated": "2022-04-18T16:21:38.261+0000",
                    "started": "2022-04-18T16:21:38.260+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "757961",
                    "issueId": "13418671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418671/worklog/757966",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paleolimbot commented on code in PR #12817:\nURL: https://github.com/apache/arrow/pull/12817#discussion_r852237357\n\n\n##########\nr/R/type.R:\n##########\n@@ -69,16 +70,43 @@ FLOAT_TYPES <- c(\"float16\", \"float32\", \"float64\", \"halffloat\", \"float\", \"double\"\n #' type(mtcars)\n #' type(Sys.Date())\n #' @export\n-type <- function(x) UseMethod(\"type\")\n+type <- function(x, ...) UseMethod(\"type\")\n \n #' @export\n-type.default <- function(x) Array__infer_type(x)\n+type.default <- function(x, ..., from_array_infer_type = FALSE) {\n+  # If from_array_infer_type is TRUE, this is a call from C++ and there was\n+  # no S3 method defined for this object.\n+  if (from_array_infer_type) {\n+    abort(\n+      sprintf(\n+        \"Can't infer Arrow data type from object inheriting from %s\",\n+        paste(class(x), collapse = \" / \")\n+      )\n+    )\n+  }\n+\n+  # If from_array_infer_type is FALSE, this is a user calling type() from R\n+  # and we to call into C++. If there is no built-in conversion for this\n+  # object type, C++ will call back here with from_array_infer_type = TRUE\n\nReview Comment:\n   See the above note about `as_arrow_array()`, except the C++ functions involved are `InferSchemaFromDots` (which gets called by e.g. `Table___from_dots()`). After getting all the tests to pass I also had the thought of \"there has to be a way to make this simpler!\", although to do so some changes would be required in the existing conversion pathways (and I was trying specifically to avoid changing those to minimize the scope of this PR).\n\n\n\n",
                    "created": "2022-04-18T16:26:33.713+0000",
                    "updated": "2022-04-18T16:26:33.713+0000",
                    "started": "2022-04-18T16:26:33.713+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "757966",
                    "issueId": "13418671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418671/worklog/757969",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paleolimbot commented on code in PR #12817:\nURL: https://github.com/apache/arrow/pull/12817#discussion_r852239435\n\n\n##########\nr/R/type.R:\n##########\n@@ -69,16 +70,43 @@ FLOAT_TYPES <- c(\"float16\", \"float32\", \"float64\", \"halffloat\", \"float\", \"double\"\n #' type(mtcars)\n #' type(Sys.Date())\n #' @export\n-type <- function(x) UseMethod(\"type\")\n+type <- function(x, ...) UseMethod(\"type\")\n\nReview Comment:\n   ..or `as_data_type` could be `as_type()`? (I don't remember why I didn't do that in the first place). If renaming `type()` is an option, my vote would be `infer_type()` or `infer_data_type()` since we're not exactly constructing a type here, we're giving a hypothetical future type from something that might be converted to an Array.\n\n\n\n",
                    "created": "2022-04-18T16:29:53.934+0000",
                    "updated": "2022-04-18T16:29:53.934+0000",
                    "started": "2022-04-18T16:29:53.934+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "757969",
                    "issueId": "13418671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418671/worklog/758104",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson commented on code in PR #12817:\nURL: https://github.com/apache/arrow/pull/12817#discussion_r852392032\n\n\n##########\nr/R/array.R:\n##########\n@@ -217,6 +217,93 @@ Array$create <- function(x, type = NULL) {\n Array$import_from_c <- ImportArray\n \n \n+#' Convert an object to an Arrow Array\n+#'\n+#' Whereas `Array$create()` constructs an [Array] from the built-in data types\n+#' for which the Arrow package implements fast converters, `as_arrow_array()`\n+#' provides a means by which other packages can define conversions to Arrow\n+#' objects.\n+#'\n+#' @param x An object to convert to an Arrow Array\n+#' @param ... Passed to S3 methods\n+#' @param type A [type][data-type] for the final Array. A value of `NULL`\n+#'   will default to the type guessed by [type()].\n+#'\n+#' @return An [Array].\n+#' @export\n+#'\n+#' @examplesIf arrow_available()\n+#' as_arrow_array(1:5)\n+#'\n+as_arrow_array <- function(x, ..., type = NULL) {\n+  UseMethod(\"as_arrow_array\")\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.Array <- function(x, ..., type = NULL) {\n+  if (is.null(type)) {\n+    x\n+  } else {\n+    x$cast(type)\n+  }\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.ChunkedArray <- function(x, ..., type = NULL) {\n+  concat_arrays(!!! x$chunks, type = type)\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.vctrs_vctr <- function(x, ..., type = NULL) {\n+  if (is.null(type)) {\n+    vctrs_extension_array(x)\n+  } else if (inherits(type, \"VctrsExtensionType\")) {\n+    vctrs_extension_array(\n+      x,\n+      ptype = type$ptype(),\n+      storage_type = type$storage_type()\n+    )\n+  } else {\n+    NextMethod()\n+  }\n+}\n+\n+#' @export\n+as_arrow_array.POSIXlt <- function(x, ..., type = NULL) {\n+  as_arrow_array.vctrs_vctr(x, ..., type = type)\n+}\n+\n+\n+#' @export\n+as_arrow_array.default <- function(x, ..., type = NULL, from_constructor = FALSE) {\n+  # If from_constructor is TRUE, this is a call from C++ for which S3 dispatch\n+  # failed to find a method for the object. If this is the case, we error.\n+  if (from_constructor && is.null(type)) {\n+    abort(\n+      sprintf(\n+        \"Can't create Array from object of type %s\",\n+        paste(class(x), collapse = \" / \")\n+      )\n+    )\n+  } else if (from_constructor) {\n+    abort(\n+      sprintf(\n+        \"Can't create Array<%s> from object of type %s\",\n+        format(type$code()),\n+        paste(class(x), collapse = \" / \")\n+      )\n+    )\n+  }\n+\n+  # If from_constructor is FALSE, we use the built-in logic exposed by\n+  # Array$create(). If there is no built-in conversion, C++ will call back\n+  # here with from_constructor = TRUE to generate a nice error message.\n\nReview Comment:\n   What happens if you don't error if `from_constructor = TRUE`?\r\n   \r\n   I think I understand how you get here now, but I don't know that I'll remember next time I look at this. IIUC it's because the extension type handler is calling as_arrow_array() from C++, and if you have implemented as_arrow_array.YourType, you won't hit this default method. But if you do, it means that we don't know what to do with this extension type, so we error. Right?\r\n   \r\n   But aren't all extension types based on regular types, which we can convert?\n\n\n\n",
                    "created": "2022-04-18T20:30:32.992+0000",
                    "updated": "2022-04-18T20:30:32.992+0000",
                    "started": "2022-04-18T20:30:32.991+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "758104",
                    "issueId": "13418671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418671/worklog/758109",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson commented on code in PR #12817:\nURL: https://github.com/apache/arrow/pull/12817#discussion_r852397531\n\n\n##########\nr/R/record-batch-reader.R:\n##########\n@@ -176,3 +176,37 @@ RecordBatchFileReader$create <- function(file) {\n   assert_is(file, \"InputStream\")\n   ipc___RecordBatchFileReader__Open(file)\n }\n+\n+#' Convert an object to an Arrow RecordBatchReader\n+#'\n+#' @param x An object to convert to a [RecordBatchReader]\n+#' @param ... Passed to S3 methods\n+#'\n+#' @return A [RecordBatchReader]\n+#' @export\n+#'\n+#' @examplesIf arrow_available() && arrow_with_dataset()\n+#' reader <- as_record_batch_reader(data.frame(col1 = 1, col2 = \"two\"))\n+#' reader$read_next_batch()\n+#'\n+as_record_batch_reader <- function(x, ...) {\n+  UseMethod(\"as_record_batch_reader\")\n+}\n+\n+#' @rdname as_record_batch_reader\n+#' @export\n+as_record_batch_reader.RecordBatchReader <- function(x, ...) {\n+  x\n+}\n+\n+#' @rdname as_arrow_table\n+#' @export\n+as_record_batch_reader.default <- function(x, ...) {\n+  Scanner$create(x)$ToRecordBatchReader()\n\nReview Comment:\n   It's probably more work than it's worth for this PR so you may want to make a followup.\r\n   \r\n   * Table has a method in C++ that turns it into a RBR but I don't think we have bindings for it.\r\n   * RecordBatch probably does too or it would be trivial to write in r/src; in test-record-batch-reader.R there are some tests that make a RecordBatchStreamReader via RecordBatchStreamWriter but that seems a little baroque\r\n   * data.frame should go through RecordBatch or Table's method\r\n   * Dataset and arrow_dplyr_query should go through the ExecPlan, but there is still this issue where the plan is returning a Table due to things that the ExecPlan can't evaluate faithfully in C++. That could be improved to return RBR in most cases, and for the ones that needed to be Table can be wrapped back in RBR. But again that's probably more than you want to bite off here.\n\n\n\n",
                    "created": "2022-04-18T20:37:59.140+0000",
                    "updated": "2022-04-18T20:37:59.140+0000",
                    "started": "2022-04-18T20:37:59.140+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "758109",
                    "issueId": "13418671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418671/worklog/758110",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson commented on code in PR #12817:\nURL: https://github.com/apache/arrow/pull/12817#discussion_r852398025\n\n\n##########\nr/R/type.R:\n##########\n@@ -68,17 +69,50 @@ FLOAT_TYPES <- c(\"float16\", \"float32\", \"float64\", \"halffloat\", \"float\", \"double\"\n #' type(c(\"A\", \"B\", \"C\"))\n #' type(mtcars)\n #' type(Sys.Date())\n+#' type(as.POSIXlt(Sys.Date()))\n+#' type(vctrs::new_vctr(1:5, class = \"my_custom_vctr_class\"))\n #' @export\n-type <- function(x) UseMethod(\"type\")\n+type <- function(x) infer_type(x)\n \n+#' @rdname type\n #' @export\n-type.default <- function(x) Array__infer_type(x)\n+infer_type <- function(x, ...) UseMethod(\"infer_type\")\n \n #' @export\n-type.ArrowDatum <- function(x) x$type\n+infer_type.default <- function(x, ..., from_array_infer_type = FALSE) {\n+  # If from_array_infer_type is TRUE, this is a call from C++ and there was\n+  # no S3 method defined for this object.\n+  if (from_array_infer_type) {\n+    abort(\n+      sprintf(\n+        \"Can't infer Arrow data type from object inheriting from %s\",\n+        paste(class(x), collapse = \" / \")\n+      )\n+    )\n+  }\n+\n+  # If from_array_infer_type is FALSE, this is a user calling type() from R\n+  # and we to call into C++. If there is no built-in conversion for this\n+  # object type, C++ will call back here with from_array_infer_type = TRUE\n+  # to generate a nice error message.\n+  Array__infer_type(x)\n+}\n+\n+#' @export\n+infer_type.ArrowDatum <- function(x, ...) x$type\n\nReview Comment:\n   This isn't an inference though\n\n\n\n",
                    "created": "2022-04-18T20:38:44.162+0000",
                    "updated": "2022-04-18T20:38:44.162+0000",
                    "started": "2022-04-18T20:38:44.162+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "758110",
                    "issueId": "13418671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418671/worklog/758111",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson commented on code in PR #12817:\nURL: https://github.com/apache/arrow/pull/12817#discussion_r852398025\n\n\n##########\nr/R/type.R:\n##########\n@@ -68,17 +69,50 @@ FLOAT_TYPES <- c(\"float16\", \"float32\", \"float64\", \"halffloat\", \"float\", \"double\"\n #' type(c(\"A\", \"B\", \"C\"))\n #' type(mtcars)\n #' type(Sys.Date())\n+#' type(as.POSIXlt(Sys.Date()))\n+#' type(vctrs::new_vctr(1:5, class = \"my_custom_vctr_class\"))\n #' @export\n-type <- function(x) UseMethod(\"type\")\n+type <- function(x) infer_type(x)\n \n+#' @rdname type\n #' @export\n-type.default <- function(x) Array__infer_type(x)\n+infer_type <- function(x, ...) UseMethod(\"infer_type\")\n \n #' @export\n-type.ArrowDatum <- function(x) x$type\n+infer_type.default <- function(x, ..., from_array_infer_type = FALSE) {\n+  # If from_array_infer_type is TRUE, this is a call from C++ and there was\n+  # no S3 method defined for this object.\n+  if (from_array_infer_type) {\n+    abort(\n+      sprintf(\n+        \"Can't infer Arrow data type from object inheriting from %s\",\n+        paste(class(x), collapse = \" / \")\n+      )\n+    )\n+  }\n+\n+  # If from_array_infer_type is FALSE, this is a user calling type() from R\n+  # and we to call into C++. If there is no built-in conversion for this\n+  # object type, C++ will call back here with from_array_infer_type = TRUE\n+  # to generate a nice error message.\n+  Array__infer_type(x)\n+}\n+\n+#' @export\n+infer_type.ArrowDatum <- function(x, ...) x$type\n\nReview Comment:\n   This isn't an inference though. (Not a reason not to do this, just observing)\n\n\n\n",
                    "created": "2022-04-18T20:39:14.453+0000",
                    "updated": "2022-04-18T20:39:14.453+0000",
                    "started": "2022-04-18T20:39:14.453+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "758111",
                    "issueId": "13418671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418671/worklog/758112",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson commented on code in PR #12817:\nURL: https://github.com/apache/arrow/pull/12817#discussion_r852399642\n\n\n##########\nr/R/type.R:\n##########\n@@ -68,17 +69,50 @@ FLOAT_TYPES <- c(\"float16\", \"float32\", \"float64\", \"halffloat\", \"float\", \"double\"\n #' type(c(\"A\", \"B\", \"C\"))\n #' type(mtcars)\n #' type(Sys.Date())\n+#' type(as.POSIXlt(Sys.Date()))\n+#' type(vctrs::new_vctr(1:5, class = \"my_custom_vctr_class\"))\n #' @export\n-type <- function(x) UseMethod(\"type\")\n+type <- function(x) infer_type(x)\n\nReview Comment:\n   This is probably safe to do but you should add to deprecated.R something like\r\n   \r\n   ```\r\n   type <- function(x) {\r\n     .Deprecated(\"infer_type\")\r\n     infer_type(x)\r\n   }\r\n   ```\r\n   \r\n   in case anyone was using this.\n\n\n\n",
                    "created": "2022-04-18T20:40:29.483+0000",
                    "updated": "2022-04-18T20:40:29.483+0000",
                    "started": "2022-04-18T20:40:29.482+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "758112",
                    "issueId": "13418671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418671/worklog/758626",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paleolimbot commented on code in PR #12817:\nURL: https://github.com/apache/arrow/pull/12817#discussion_r853309711\n\n\n##########\nr/R/util.R:\n##########\n@@ -138,18 +138,17 @@ handle_parquet_io_error <- function(e, format) {\n   stop(e)\n }\n \n-is_writable_table <- function(x) {\n-  inherits(x, c(\"data.frame\", \"ArrowTabular\"))\n-}\n-\n-# This attribute is used when is_writable is passed into assert_that, and allows\n-# the call to form part of the error message when is_writable is FALSE\n-attr(is_writable_table, \"fail\") <- function(call, env) {\n-  paste0(\n-    deparse(call$x),\n-    \" must be an object of class 'data.frame', 'RecordBatch', or 'Table', not '\",\n-    class(env[[deparse(call$x)]])[[1]],\n-    \"'.\"\n+as_writable_table <- function(x, arg_name = \"x\") {\n\nReview Comment:\n   I opted to just simplify this a bit...it only gets used in a few places! I'll send you a message about the use of `sys.call()` vs `caller_env()`...I did some digging and it makes sense to me now why the docs say to use `caller_env()`.\n\n\n\n",
                    "created": "2022-04-19T17:14:41.223+0000",
                    "updated": "2022-04-19T17:14:41.223+0000",
                    "started": "2022-04-19T17:14:41.223+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "758626",
                    "issueId": "13418671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418671/worklog/758627",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson commented on code in PR #12817:\nURL: https://github.com/apache/arrow/pull/12817#discussion_r853283433\n\n\n##########\nr/R/array.R:\n##########\n@@ -217,6 +217,125 @@ Array$create <- function(x, type = NULL) {\n Array$import_from_c <- ImportArray\n \n \n+#' Convert an object to an Arrow Array\n+#'\n+#' Whereas `Array$create()` constructs an [Array] from the built-in data types\n+#' for which the Arrow package implements fast converters, `as_arrow_array()`\n+#' provides a means by which other packages can define conversions to Arrow\n+#' objects.\n+#'\n+#' @param x An object to convert to an Arrow Array\n+#' @param ... Passed to S3 methods\n+#' @param type A [type][data-type] for the final Array. A value of `NULL`\n+#'   will default to the type guessed by [type()].\n+#'\n+#' @return An [Array].\n+#' @export\n+#'\n+#' @examplesIf arrow_available()\n+#' as_arrow_array(1:5)\n+#'\n+as_arrow_array <- function(x, ..., type = NULL) {\n+  UseMethod(\"as_arrow_array\")\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.Array <- function(x, ..., type = NULL) {\n+  if (is.null(type)) {\n+    x\n+  } else {\n+    x$cast(type)\n+  }\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.ChunkedArray <- function(x, ..., type = NULL) {\n+  concat_arrays(!!! x$chunks, type = type)\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.vctrs_vctr <- function(x, ..., type = NULL) {\n+  if (is.null(type)) {\n+    vctrs_extension_array(x)\n+  } else if (inherits(type, \"VctrsExtensionType\")) {\n+    vctrs_extension_array(\n+      x,\n+      ptype = type$ptype(),\n+      storage_type = type$storage_type()\n+    )\n+  } else {\n+    stop_cant_convert_array(x, type)\n\nReview Comment:\n   Why not NextMethod anymore?\n\n\n\n##########\nr/R/array.R:\n##########\n@@ -217,6 +217,125 @@ Array$create <- function(x, type = NULL) {\n Array$import_from_c <- ImportArray\n \n \n+#' Convert an object to an Arrow Array\n+#'\n+#' Whereas `Array$create()` constructs an [Array] from the built-in data types\n+#' for which the Arrow package implements fast converters, `as_arrow_array()`\n+#' provides a means by which other packages can define conversions to Arrow\n+#' objects.\n+#'\n+#' @param x An object to convert to an Arrow Array\n+#' @param ... Passed to S3 methods\n+#' @param type A [type][data-type] for the final Array. A value of `NULL`\n+#'   will default to the type guessed by [type()].\n+#'\n+#' @return An [Array].\n+#' @export\n+#'\n+#' @examplesIf arrow_available()\n\nReview Comment:\n   arrow is always available now\r\n   \r\n   ```suggestion\r\n   #' @examples\r\n   ```\n\n\n\n##########\nr/R/array.R:\n##########\n@@ -217,6 +217,125 @@ Array$create <- function(x, type = NULL) {\n Array$import_from_c <- ImportArray\n \n \n+#' Convert an object to an Arrow Array\n+#'\n+#' Whereas `Array$create()` constructs an [Array] from the built-in data types\n\nReview Comment:\n   This leaves me with some questions. Are `as_arrow_array()` conversions not optimized? If `as_arrow_array()` is going to call the regular Arrow converters for normal types, and it would work with extension types, why would I ever call `Array$create()`? When would `Array$create()` and `as_arrow_array()` do different things?\r\n   \r\n   Maybe you can illustrate through some `@examples`. \n\n\n\n##########\nr/R/array.R:\n##########\n@@ -217,6 +217,125 @@ Array$create <- function(x, type = NULL) {\n Array$import_from_c <- ImportArray\n \n \n+#' Convert an object to an Arrow Array\n+#'\n+#' Whereas `Array$create()` constructs an [Array] from the built-in data types\n+#' for which the Arrow package implements fast converters, `as_arrow_array()`\n+#' provides a means by which other packages can define conversions to Arrow\n+#' objects.\n+#'\n+#' @param x An object to convert to an Arrow Array\n+#' @param ... Passed to S3 methods\n+#' @param type A [type][data-type] for the final Array. A value of `NULL`\n+#'   will default to the type guessed by [type()].\n+#'\n+#' @return An [Array].\n+#' @export\n+#'\n+#' @examplesIf arrow_available()\n+#' as_arrow_array(1:5)\n+#'\n+as_arrow_array <- function(x, ..., type = NULL) {\n+  UseMethod(\"as_arrow_array\")\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.Array <- function(x, ..., type = NULL) {\n+  if (is.null(type)) {\n+    x\n+  } else {\n+    x$cast(type)\n+  }\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.ChunkedArray <- function(x, ..., type = NULL) {\n+  concat_arrays(!!! x$chunks, type = type)\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.vctrs_vctr <- function(x, ..., type = NULL) {\n+  if (is.null(type)) {\n+    vctrs_extension_array(x)\n+  } else if (inherits(type, \"VctrsExtensionType\")) {\n+    vctrs_extension_array(\n+      x,\n+      ptype = type$ptype(),\n+      storage_type = type$storage_type()\n+    )\n+  } else {\n+    stop_cant_convert_array(x, type)\n+  }\n+}\n+\n+#' @export\n+as_arrow_array.POSIXlt <- function(x, ..., type = NULL) {\n+  as_arrow_array.vctrs_vctr(x, ..., type = type)\n+}\n+\n+#' @export\n+as_arrow_array.data.frame <- function(x, ..., type = NULL) {\n+  type <- type %||% infer_type(x)\n+\n+  if (inherits(type, \"VctrsExtensionType\")) {\n+    storage <- as_arrow_array(x, type = type$storage_type())\n+    new_extension_array(storage, type)\n+  } else if (inherits(type, \"StructType\")) {\n+    fields <- type$fields()\n+    names <- map_chr(fields, \"name\")\n+    types <- map(fields, \"type\")\n+    arrays <- Map(as_arrow_array, x, types)\n+    names(arrays) <- names\n+\n+    # ...because there isn't a StructArray$create() yet\n+    batch <- record_batch(!!! arrays)\n+    array_ptr <- allocate_arrow_array()\n+    schema_ptr <- allocate_arrow_schema()\n+    batch$export_to_c(array_ptr, schema_ptr)\n+    Array$import_from_c(array_ptr, schema_ptr)\n+  } else {\n+    stop_cant_convert_array(x, type)\n+  }\n+}\n+\n+#' @export\n+as_arrow_array.default <- function(x, ..., type = NULL, from_constructor = FALSE) {\n+  # If from_constructor is TRUE, this is a call from C++ for which S3 dispatch\n+  # failed to find a method for the object. If this is the case, we error.\n\nReview Comment:\n   Presumably C++ has also tried using the regular type inference as well?\n\n\n\n##########\nr/R/record-batch.R:\n##########\n@@ -189,3 +189,56 @@ record_batch <- RecordBatch$create\n \n #' @export\n names.RecordBatch <- function(x) x$names()\n+\n+#' Convert an object to an Arrow RecordBatch\n+#'\n+#' Whereas [record_batch()] constructs a [RecordBatch] from one or more columns,\n+#' `as_record_batch()` converts a single object to an Arrow [RecordBatch].\n+#'\n+#' @param x An object to convert to an Arrow RecordBatch\n+#' @param ... Passed to S3 methods\n+#' @inheritParams record_batch\n+#'\n+#' @return A [RecordBatch]\n+#' @export\n+#'\n+#' @examplesIf arrow_available()\n\nReview Comment:\n   ```suggestion\r\n   #' @examples\r\n   ```\n\n\n\n##########\nr/tests/testthat/test-Array.R:\n##########\n@@ -1010,6 +1010,110 @@ test_that(\"auto int64 conversion to int can be disabled (ARROW-10093)\", {\n   })\n })\n \n+test_that(\"as_arrow_array() default method calls Array$create()\", {\n+  expect_equal(\n+    as_arrow_array(1:10),\n+    Array$create(1:10)\n+  )\n+\n+  expect_equal(\n+    as_arrow_array(1:10, type = float64()),\n+    Array$create(1:10, type = float64())\n+  )\n+})\n+\n+test_that(\"as_arrow_array() works for Array\", {\n+  array <- Array$create(logical(), type = null())\n+  expect_identical(as_arrow_array(array), array)\n+  expect_equal(\n+    as_arrow_array(array, type = int32()),\n+    Array$create(integer())\n+  )\n+})\n+\n+test_that(\"as_arrow_array() works for ChunkedArray\", {\n+  expect_equal(\n+    as_arrow_array(chunked_array(type = null())),\n+    Array$create(logical(), type = null())\n+  )\n+\n+  expect_equal(\n+    as_arrow_array(chunked_array(1:3, 4:6)),\n+    Array$create(1:6)\n+  )\n+\n+  expect_equal(\n+    as_arrow_array(chunked_array(1:3, 4:6), type = float64()),\n+    Array$create(1:6, type = float64())\n+  )\n+})\n+\n+test_that(\"as_arrow_array() works for vctr_vctr types\", {\n+  vctr <- vctrs::new_vctr(1:5, class = \"custom_vctr\")\n+  expect_equal(\n+    as_arrow_array(vctr),\n+    vctrs_extension_array(vctr)\n+  )\n+\n+  # with explicit type\n+  expect_equal(\n+    as_arrow_array(\n+      vctr,\n+      type = vctrs_extension_type(\n+        vctrs::vec_ptype(vctr),\n+        storage_type = float64()\n+      )\n+    ),\n+    vctrs_extension_array(\n+      vctr,\n+      storage_type = float64()\n+    )\n+  )\n+\n+  # with impossible type\n+  expect_snapshot_error(as_arrow_array(vctr, type = float64()))\n+})\n+\n+test_that(\"as_arrow_array() works for nested extension types\", {\n+  vctr <- vctrs::new_vctr(1:5, class = \"custom_vctr\")\n+\n+  nested <- tibble::tibble(x = vctr)\n+  type <- infer_type(nested)\n+\n+  # with type = NULL\n+  nested_array <- as_arrow_array(nested)\n+  expect_identical(as.vector(nested_array), nested)\n+\n+  # with explicit type\n+  expect_equal(as_arrow_array(nested, type = type), nested_array)\n+\n+  # with extension type\n+  extension_array <- vctrs_extension_array(nested)\n+  expect_equal(\n+    as_arrow_array(nested, type = extension_array$type),\n+    extension_array\n+  )\n+})\n+\n+test_that(\"as_arrow_array() default method errors for impossible cases\", {\n+  vec <- structure(list(), class = \"class_not_supported\")\n+\n+  # check errors simulating a call from C++\n+  expect_snapshot_error(as_arrow_array(vec, from_constructor = TRUE))\n+  expect_snapshot_error(\n+    as_arrow_array(vec, type = float64(), from_constructor = TRUE)\n+  )\n+\n+  # check that the errors propagate through Array$create()\n+  type.class_not_supported <- function(x, ...) {\n\nReview Comment:\n   Didn't you name this to infer_type? \n\n\n\n##########\nr/tests/testthat/test-type.R:\n##########\n@@ -242,3 +268,19 @@ test_that(\"type() gets the right type for Expression\", {\n   expect_equal(add_xy$type(), type(add_xy))\n   expect_equal(type(add_xy), float64())\n })\n+\n+test_that(\"type() infers type for POSIXlt\", {\n\nReview Comment:\n   This is now infer_type()?\n\n\n\n##########\nr/tests/testthat/test-ipc_stream.R:\n##########\n@@ -0,0 +1,30 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n\nReview Comment:\n   Can you please rename this file to `test-ipc-stream.R` for consistency?\n\n\n\n##########\nr/tests/testthat/test-backwards-compatibility.R:\n##########\n@@ -112,10 +112,36 @@ for (comp in c(\"lz4\", \"uncompressed\", \"zstd\")) {\n     # not maintained and the embedded tibble's attributes are read in a wrong\n     # order. Since this is prior to 1.0.0 punting on checking the attributes\n     # though classes are always checked, so that must be removed before checking.\n-    example_with_metadata_sans_special_class <- example_with_metadata\n+    example_with_metadata_sans_special_class <- old_example_with_metadata\n     example_with_metadata_sans_special_class$a <- unclass(example_with_metadata_sans_special_class$a)\n     expect_equal(df, example_with_metadata_sans_special_class, ignore_attr = TRUE)\n   })\n }\n \n+test_that(\"sfc columns written by arrow <= 7.0.0 can be re-read\", {\n+  # nolint start\n+  # df <- data.frame(x = I(list(structure(1, foo = \"bar\"), structure(2, baz = \"qux\"))))\n+  # class(df$x) <- c(\"sfc_MULTIPOLYGON\", \"sfc\", \"list\")\n+  # withr::with_options(\n+  #   list(\"arrow.preserve_row_level_metadata\" = TRUE), {\n\nReview Comment:\n   But this isn't the default in 7.0.0 is it?\n\n\n\n##########\nr/R/record-batch.R:\n##########\n@@ -189,3 +189,56 @@ record_batch <- RecordBatch$create\n \n #' @export\n names.RecordBatch <- function(x) x$names()\n+\n+#' Convert an object to an Arrow RecordBatch\n+#'\n+#' Whereas [record_batch()] constructs a [RecordBatch] from one or more columns,\n+#' `as_record_batch()` converts a single object to an Arrow [RecordBatch].\n+#'\n+#' @param x An object to convert to an Arrow RecordBatch\n+#' @param ... Passed to S3 methods\n+#' @inheritParams record_batch\n+#'\n+#' @return A [RecordBatch]\n+#' @export\n+#'\n+#' @examplesIf arrow_available()\n+#' as_record_batch(data.frame(col1 = 1, col2 = \"two\"))\n+#'\n+as_record_batch <- function(x, ..., schema = NULL) {\n+  UseMethod(\"as_record_batch\")\n+}\n+\n+#' @rdname as_record_batch\n+#' @export\n+as_record_batch.RecordBatch <- function(x, ..., schema = NULL) {\n+  if (is.null(schema)) {\n+    x\n+  } else {\n+    x$cast(schema)\n+  }\n+}\n+\n+#' @rdname as_record_batch\n+#' @export\n+as_record_batch.Table <- function(x, ..., schema = NULL) {\n+  if (x$num_columns == 0) {\n+    batch <- record_batch(data.frame())\n+    return(batch$Take(rep_len(0, x$num_rows)))\n+  }\n+\n+  arrays_out <- lapply(x$columns, as_arrow_array)\n\nReview Comment:\n   Same comment on @wjones127 's PR, seems like Table$columns should return a named list, right (or what would the harm be in applying the names)?\n\n\n\n##########\nr/R/array.R:\n##########\n@@ -217,6 +217,125 @@ Array$create <- function(x, type = NULL) {\n Array$import_from_c <- ImportArray\n \n \n+#' Convert an object to an Arrow Array\n+#'\n+#' Whereas `Array$create()` constructs an [Array] from the built-in data types\n+#' for which the Arrow package implements fast converters, `as_arrow_array()`\n+#' provides a means by which other packages can define conversions to Arrow\n+#' objects.\n+#'\n+#' @param x An object to convert to an Arrow Array\n+#' @param ... Passed to S3 methods\n+#' @param type A [type][data-type] for the final Array. A value of `NULL`\n+#'   will default to the type guessed by [type()].\n+#'\n+#' @return An [Array].\n+#' @export\n+#'\n+#' @examplesIf arrow_available()\n+#' as_arrow_array(1:5)\n+#'\n+as_arrow_array <- function(x, ..., type = NULL) {\n+  UseMethod(\"as_arrow_array\")\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.Array <- function(x, ..., type = NULL) {\n+  if (is.null(type)) {\n+    x\n+  } else {\n+    x$cast(type)\n+  }\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.ChunkedArray <- function(x, ..., type = NULL) {\n+  concat_arrays(!!! x$chunks, type = type)\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.vctrs_vctr <- function(x, ..., type = NULL) {\n+  if (is.null(type)) {\n+    vctrs_extension_array(x)\n+  } else if (inherits(type, \"VctrsExtensionType\")) {\n+    vctrs_extension_array(\n+      x,\n+      ptype = type$ptype(),\n+      storage_type = type$storage_type()\n+    )\n+  } else {\n+    stop_cant_convert_array(x, type)\n+  }\n+}\n+\n+#' @export\n+as_arrow_array.POSIXlt <- function(x, ..., type = NULL) {\n+  as_arrow_array.vctrs_vctr(x, ..., type = type)\n+}\n+\n+#' @export\n+as_arrow_array.data.frame <- function(x, ..., type = NULL) {\n+  type <- type %||% infer_type(x)\n+\n+  if (inherits(type, \"VctrsExtensionType\")) {\n+    storage <- as_arrow_array(x, type = type$storage_type())\n+    new_extension_array(storage, type)\n+  } else if (inherits(type, \"StructType\")) {\n+    fields <- type$fields()\n+    names <- map_chr(fields, \"name\")\n+    types <- map(fields, \"type\")\n+    arrays <- Map(as_arrow_array, x, types)\n+    names(arrays) <- names\n+\n+    # ...because there isn't a StructArray$create() yet\n\nReview Comment:\n   There isn't (but there is in C++), but I think the reason we didn't add bindings to create from a vector of Arrays is because `Array$create(data.frame)` produces a StructArray. Why can't we use that here?\n\n\n\n##########\nr/R/record-batch-reader.R:\n##########\n@@ -176,3 +176,61 @@ RecordBatchFileReader$create <- function(file) {\n   assert_is(file, \"InputStream\")\n   ipc___RecordBatchFileReader__Open(file)\n }\n+\n+#' Convert an object to an Arrow RecordBatchReader\n+#'\n+#' @param x An object to convert to a [RecordBatchReader]\n+#' @param ... Passed to S3 methods\n+#'\n+#' @return A [RecordBatchReader]\n+#' @export\n+#'\n+#' @examplesIf arrow_available() && arrow_with_dataset()\n+#' reader <- as_record_batch_reader(data.frame(col1 = 1, col2 = \"two\"))\n+#' reader$read_next_batch()\n+#'\n+as_record_batch_reader <- function(x, ...) {\n+  UseMethod(\"as_record_batch_reader\")\n+}\n+\n+#' @rdname as_record_batch_reader\n+#' @export\n+as_record_batch_reader.RecordBatchReader <- function(x, ...) {\n+  x\n+}\n+\n+#' @rdname as_record_batch_reader\n+#' @export\n+as_record_batch_reader.Table <- function(x, ...) {\n+  RecordBatchReader__from_Table(x)\n+}\n+\n+#' @rdname as_record_batch_reader\n+#' @export\n+as_record_batch_reader.RecordBatch <- function(x, ...) {\n+  as_record_batch_reader(as_arrow_table(x))\n+}\n+\n+#' @rdname as_record_batch_reader\n+#' @export\n+as_record_batch_reader.data.frame <- function(x, ...) {\n+  as_record_batch_reader(as_arrow_table(x))\n+}\n+\n+#' @rdname as_record_batch_reader\n+#' @export\n+as_record_batch_reader.Dataset <- function(x, ...) {\n+  Scanner$create(x)$ToRecordBatchReader()\n+}\n+\n+#' @rdname as_record_batch_reader\n+#' @export\n+as_record_batch_reader.arrow_dplyr_query <- function(x, ...) {\n+  as_record_batch_reader(collect.arrow_dplyr_query(x, as_data_frame = FALSE))\n\nReview Comment:\n   ```suggestion\r\n     # TODO(ARROW-15271): make ExecPlan return RBR\r\n     as_record_batch_reader(collect.arrow_dplyr_query(x, as_data_frame = FALSE))\r\n   ```\n\n\n\n##########\nr/R/table.R:\n##########\n@@ -166,3 +166,63 @@ names.Table <- function(x) x$ColumnNames()\n #' as.data.frame(tbl[4:8, c(\"gear\", \"hp\", \"wt\")])\n #' @export\n arrow_table <- Table$create\n+\n+\n+#' Convert an object to an Arrow Table\n+#'\n+#' Whereas [arrow_table()] constructs a table from one or more columns,\n+#' `as_arrow_table()` converts a single object to an Arrow [Table].\n+#'\n+#' @param x An object to convert to an Arrow Table\n+#' @param ... Passed to S3 methods\n+#' @inheritParams arrow_table\n+#'\n+#' @return A [Table]\n+#' @export\n+#'\n+#' @examplesIf arrow_available()\n\nReview Comment:\n   ```suggestion\r\n   #' @examples\r\n   ```\n\n\n\n##########\nr/R/record-batch.R:\n##########\n@@ -189,3 +189,56 @@ record_batch <- RecordBatch$create\n \n #' @export\n names.RecordBatch <- function(x) x$names()\n+\n+#' Convert an object to an Arrow RecordBatch\n+#'\n+#' Whereas [record_batch()] constructs a [RecordBatch] from one or more columns,\n+#' `as_record_batch()` converts a single object to an Arrow [RecordBatch].\n+#'\n+#' @param x An object to convert to an Arrow RecordBatch\n+#' @param ... Passed to S3 methods\n+#' @inheritParams record_batch\n+#'\n+#' @return A [RecordBatch]\n+#' @export\n+#'\n+#' @examplesIf arrow_available()\n+#' as_record_batch(data.frame(col1 = 1, col2 = \"two\"))\n+#'\n+as_record_batch <- function(x, ..., schema = NULL) {\n+  UseMethod(\"as_record_batch\")\n+}\n+\n+#' @rdname as_record_batch\n+#' @export\n+as_record_batch.RecordBatch <- function(x, ..., schema = NULL) {\n+  if (is.null(schema)) {\n+    x\n+  } else {\n+    x$cast(schema)\n+  }\n+}\n+\n+#' @rdname as_record_batch\n+#' @export\n+as_record_batch.Table <- function(x, ..., schema = NULL) {\n+  if (x$num_columns == 0) {\n+    batch <- record_batch(data.frame())\n+    return(batch$Take(rep_len(0, x$num_rows)))\n+  }\n+\n+  arrays_out <- lapply(x$columns, as_arrow_array)\n+  names(arrays_out) <- names(x)\n+  out <- RecordBatch__from_arrays(NULL, arrays_out)\n\nReview Comment:\n   Or if you wanted to avoid calling the C++ wrapper directly (I personally try to limit the places that happens just so we make sure to check inputs to protect against segfault):\r\n   \r\n   ```suggestion\r\n     out <- RecordBatch$create(!!!arrays_out)\r\n   ```\n\n\n\n##########\nr/tests/testthat/helper-data.R:\n##########\n@@ -25,7 +25,7 @@ example_data <- tibble::tibble(\n   fct = factor(letters[c(1:4, NA, NA, 7:10)])\n )\n \n-example_with_metadata <- tibble::tibble(\n+old_example_with_metadata <- tibble::tibble(\n\nReview Comment:\n   Why rename?\n\n\n\n##########\nr/R/record-batch.R:\n##########\n@@ -189,3 +189,56 @@ record_batch <- RecordBatch$create\n \n #' @export\n names.RecordBatch <- function(x) x$names()\n+\n+#' Convert an object to an Arrow RecordBatch\n+#'\n+#' Whereas [record_batch()] constructs a [RecordBatch] from one or more columns,\n+#' `as_record_batch()` converts a single object to an Arrow [RecordBatch].\n+#'\n+#' @param x An object to convert to an Arrow RecordBatch\n+#' @param ... Passed to S3 methods\n+#' @inheritParams record_batch\n+#'\n+#' @return A [RecordBatch]\n+#' @export\n+#'\n+#' @examplesIf arrow_available()\n+#' as_record_batch(data.frame(col1 = 1, col2 = \"two\"))\n\nReview Comment:\n   This is another case where examples would be good to show the difference between record_batch() and as_record_batch()\n\n\n\n##########\nr/tests/testthat/test-RecordBatch.R:\n##########\n@@ -688,3 +688,53 @@ test_that(\"RecordBatchReader to C-interface to arrow_dplyr_query\", {\n   # must clean up the pointer or we leak\n   delete_arrow_array_stream(stream_ptr)\n })\n+\n+\n+test_that(\"as_record_batch() works for RecordBatch\", {\n+  batch <- record_batch(col1 = 1L, col2 = \"two\")\n+  expect_identical(as_record_batch(batch), batch)\n+  expect_equal(\n+    as_record_batch(batch, schema = schema(col1 = float64(), col2 = string())),\n+    record_batch(col1 = Array$create(1, type = float64()), col2 = \"two\")\n+  )\n+})\n+\n+test_that(\"as_record_batch() works for Table\", {\n+  batch <- record_batch(col1 = 1L, col2 = \"two\")\n+  table <- arrow_table(col1 = 1L, col2 = \"two\")\n+\n+  expect_equal(as_record_batch(table), batch)\n+  expect_equal(\n+    as_record_batch(table, schema = schema(col1 = float64(), col2 = string())),\n+    record_batch(col1 = Array$create(1, type = float64()), col2 = \"two\")\n+  )\n+\n+  # also check zero column table and make sure row count is preserved\n+  table0 <- table[integer()]\n+  expect_identical(table0$num_columns, 0L)\n+  expect_identical(table0$num_rows, 1L)\n+\n+  batch0 <- as_record_batch(table0)\n+  expect_identical(batch0$num_columns, 0L)\n+  expect_identical(batch0$num_rows, 1L)\n+})\n+\n+test_that(\"as_record_batch() works for data.frame()\", {\n+  batch <- record_batch(col1 = 1L, col2 = \"two\")\n+  tbl <- tibble::tibble(col1 = 1L, col2 = \"two\")\n+\n+  # metadata prevents these from being equal\n\nReview Comment:\n   Why? Should they have different metadata?\r\n   \r\n   If so, you don't have to delete the metadata, you can do `expect_equal(batch2, batch, ignore_attr = TRUE)`\n\n\n\n##########\nr/tests/testthat/test-Array.R:\n##########\n@@ -1010,6 +1010,110 @@ test_that(\"auto int64 conversion to int can be disabled (ARROW-10093)\", {\n   })\n })\n \n+test_that(\"as_arrow_array() default method calls Array$create()\", {\n+  expect_equal(\n+    as_arrow_array(1:10),\n+    Array$create(1:10)\n+  )\n+\n+  expect_equal(\n+    as_arrow_array(1:10, type = float64()),\n+    Array$create(1:10, type = float64())\n+  )\n+})\n+\n+test_that(\"as_arrow_array() works for Array\", {\n+  array <- Array$create(logical(), type = null())\n+  expect_identical(as_arrow_array(array), array)\n+  expect_equal(\n+    as_arrow_array(array, type = int32()),\n+    Array$create(integer())\n+  )\n+})\n+\n+test_that(\"as_arrow_array() works for ChunkedArray\", {\n+  expect_equal(\n+    as_arrow_array(chunked_array(type = null())),\n+    Array$create(logical(), type = null())\n+  )\n+\n+  expect_equal(\n+    as_arrow_array(chunked_array(1:3, 4:6)),\n+    Array$create(1:6)\n+  )\n+\n+  expect_equal(\n+    as_arrow_array(chunked_array(1:3, 4:6), type = float64()),\n+    Array$create(1:6, type = float64())\n+  )\n+})\n+\n+test_that(\"as_arrow_array() works for vctr_vctr types\", {\n+  vctr <- vctrs::new_vctr(1:5, class = \"custom_vctr\")\n+  expect_equal(\n+    as_arrow_array(vctr),\n+    vctrs_extension_array(vctr)\n+  )\n+\n+  # with explicit type\n+  expect_equal(\n+    as_arrow_array(\n+      vctr,\n+      type = vctrs_extension_type(\n+        vctrs::vec_ptype(vctr),\n+        storage_type = float64()\n+      )\n+    ),\n+    vctrs_extension_array(\n+      vctr,\n+      storage_type = float64()\n+    )\n+  )\n+\n+  # with impossible type\n+  expect_snapshot_error(as_arrow_array(vctr, type = float64()))\n+})\n+\n+test_that(\"as_arrow_array() works for nested extension types\", {\n+  vctr <- vctrs::new_vctr(1:5, class = \"custom_vctr\")\n+\n+  nested <- tibble::tibble(x = vctr)\n+  type <- infer_type(nested)\n+\n+  # with type = NULL\n+  nested_array <- as_arrow_array(nested)\n+  expect_identical(as.vector(nested_array), nested)\n+\n+  # with explicit type\n+  expect_equal(as_arrow_array(nested, type = type), nested_array)\n+\n+  # with extension type\n+  extension_array <- vctrs_extension_array(nested)\n+  expect_equal(\n+    as_arrow_array(nested, type = extension_array$type),\n+    extension_array\n+  )\n+})\n+\n+test_that(\"as_arrow_array() default method errors for impossible cases\", {\n+  vec <- structure(list(), class = \"class_not_supported\")\n+\n+  # check errors simulating a call from C++\n+  expect_snapshot_error(as_arrow_array(vec, from_constructor = TRUE))\n+  expect_snapshot_error(\n+    as_arrow_array(vec, type = float64(), from_constructor = TRUE)\n+  )\n+\n+  # check that the errors propagate through Array$create()\n+  type.class_not_supported <- function(x, ...) {\n+    float64()\n+  }\n+\n+  # slightly different error if type was specified\n\nReview Comment:\n   Forgive the dead-horse beating, but it's hard for me to tell that this is the case by looking at the test file.\n\n\n\n##########\nr/tests/testthat/test-Array.R:\n##########\n@@ -1010,6 +1010,110 @@ test_that(\"auto int64 conversion to int can be disabled (ARROW-10093)\", {\n   })\n })\n \n+test_that(\"as_arrow_array() default method calls Array$create()\", {\n+  expect_equal(\n+    as_arrow_array(1:10),\n+    Array$create(1:10)\n+  )\n+\n+  expect_equal(\n+    as_arrow_array(1:10, type = float64()),\n+    Array$create(1:10, type = float64())\n+  )\n+})\n+\n+test_that(\"as_arrow_array() works for Array\", {\n+  array <- Array$create(logical(), type = null())\n+  expect_identical(as_arrow_array(array), array)\n+  expect_equal(\n+    as_arrow_array(array, type = int32()),\n+    Array$create(integer())\n+  )\n+})\n+\n+test_that(\"as_arrow_array() works for ChunkedArray\", {\n+  expect_equal(\n+    as_arrow_array(chunked_array(type = null())),\n+    Array$create(logical(), type = null())\n+  )\n+\n+  expect_equal(\n+    as_arrow_array(chunked_array(1:3, 4:6)),\n+    Array$create(1:6)\n+  )\n+\n+  expect_equal(\n+    as_arrow_array(chunked_array(1:3, 4:6), type = float64()),\n+    Array$create(1:6, type = float64())\n+  )\n+})\n+\n+test_that(\"as_arrow_array() works for vctr_vctr types\", {\n\nReview Comment:\n   ```suggestion\r\n   test_that(\"as_arrow_array() works for vctrs_vctr types\", {\r\n   ```\n\n\n\n",
                    "created": "2022-04-19T17:14:43.061+0000",
                    "updated": "2022-04-19T17:14:43.061+0000",
                    "started": "2022-04-19T17:14:43.061+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "758627",
                    "issueId": "13418671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418671/worklog/758699",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paleolimbot commented on code in PR #12817:\nURL: https://github.com/apache/arrow/pull/12817#discussion_r853357707\n\n\n##########\nr/src/table.cpp:\n##########\n@@ -226,20 +222,41 @@ arrow::Status AddMetadataFromDots(SEXP lst, int num_fields,\n   cpp11::writable::list metadata(2);\n   metadata.names() = arrow::r::data::names_metadata;\n \n-  bool has_metadata = false;\n+  bool has_top_level_metadata = false;\n \n   // \"top level\" attributes, only relevant if the first object is not named and a data\n   // frame\n   cpp11::strings names = Rf_getAttrib(lst, R_NamesSymbol);\n   if (names[0] == \"\" && Rf_inherits(VECTOR_ELT(lst, 0), \"data.frame\")) {\n     SEXP top_level = metadata[0] = arrow_attributes(VECTOR_ELT(lst, 0), true);\n     if (!Rf_isNull(top_level) && XLENGTH(top_level) > 0) {\n-      has_metadata = true;\n+      has_top_level_metadata = true;\n     }\n   }\n \n   // recurse to get all columns metadata\n-  metadata[1] = CollectColumnMetadata(lst, num_fields, has_metadata);\n+  cpp11::writable::list metadata_columns = CollectColumnMetadata(lst, num_fields);\n+\n+  // Remove metadata for ExtensionType columns, because these have their own mechanism for\n+  // preserving R type information\n+  for (R_xlen_t i = 0; i < schema->num_fields(); i++) {\n+    if (schema->field(i)->type()->id() == Type::EXTENSION) {\n+      metadata_columns[i] = R_NilValue;\n\nReview Comment:\n   This was a really good catch! It led me down a bit of a rabbit hole but it now works!\r\n   \r\n   ``` r\r\n   # remotes::install_github(\"apache/arrow/r#12817\")\r\n   library(arrow, warn.conflicts = FALSE)\r\n   \r\n   nested <- tibble::tibble(x = vctrs::new_vctr(1:5, class = \"custom_vctr\"))\r\n   infer_type(nested)\r\n   #> StructType\r\n   #> struct<x: <custom_vctr[0]>>\r\n   as_arrow_array(nested)\r\n   #> StructArray\r\n   #> <struct<x: <custom_vctr[0]>>>\r\n   #> ",
                    "created": "2022-04-19T18:12:56.034+0000",
                    "updated": "2022-04-19T18:12:56.034+0000",
                    "started": "2022-04-19T18:12:56.034+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "758699",
                    "issueId": "13418671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418671/worklog/758706",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paleolimbot commented on code in PR #12817:\nURL: https://github.com/apache/arrow/pull/12817#discussion_r853361427\n\n\n##########\nr/R/array.R:\n##########\n@@ -217,6 +217,93 @@ Array$create <- function(x, type = NULL) {\n Array$import_from_c <- ImportArray\n \n \n+#' Convert an object to an Arrow Array\n+#'\n+#' Whereas `Array$create()` constructs an [Array] from the built-in data types\n+#' for which the Arrow package implements fast converters, `as_arrow_array()`\n+#' provides a means by which other packages can define conversions to Arrow\n+#' objects.\n+#'\n+#' @param x An object to convert to an Arrow Array\n+#' @param ... Passed to S3 methods\n+#' @param type A [type][data-type] for the final Array. A value of `NULL`\n+#'   will default to the type guessed by [type()].\n+#'\n+#' @return An [Array].\n+#' @export\n+#'\n+#' @examplesIf arrow_available()\n+#' as_arrow_array(1:5)\n+#'\n+as_arrow_array <- function(x, ..., type = NULL) {\n+  UseMethod(\"as_arrow_array\")\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.Array <- function(x, ..., type = NULL) {\n+  if (is.null(type)) {\n+    x\n+  } else {\n+    x$cast(type)\n+  }\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.ChunkedArray <- function(x, ..., type = NULL) {\n+  concat_arrays(!!! x$chunks, type = type)\n+}\n+\n+#' @rdname as_arrow_array\n+#' @export\n+as_arrow_array.vctrs_vctr <- function(x, ..., type = NULL) {\n+  if (is.null(type)) {\n+    vctrs_extension_array(x)\n+  } else if (inherits(type, \"VctrsExtensionType\")) {\n+    vctrs_extension_array(\n+      x,\n+      ptype = type$ptype(),\n+      storage_type = type$storage_type()\n+    )\n+  } else {\n+    NextMethod()\n+  }\n+}\n+\n+#' @export\n+as_arrow_array.POSIXlt <- function(x, ..., type = NULL) {\n+  as_arrow_array.vctrs_vctr(x, ..., type = type)\n\nReview Comment:\n   You were totally right...I was using `NextMethod()` to re-use the error generation code, so you could trigger an infinite loop with an invalid `type` and an oddly formed `POSIXlt`. A better approach was to pull the error code into its own function (this also came up in the `data.frame` method that was needed to make nested extension types work).\n\n\n\n",
                    "created": "2022-04-19T18:17:41.265+0000",
                    "updated": "2022-04-19T18:17:41.265+0000",
                    "started": "2022-04-19T18:17:41.264+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "758706",
                    "issueId": "13418671"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 33600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@33ee639b[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@71247c8b[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6a1d79f8[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@380f8014[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@14a1875e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@47f15b0a[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@462238b5[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@2691f45[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1a6af321[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@578ec26d[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3ebfb9[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@4ae71bcc[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 33600,
        "customfield_12312520": null,
        "customfield_12312521": "Sat Apr 23 13:07:05 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-04-23T13:07:05.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15168/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2021-12-20T17:58:45.000+0000",
        "updated": "2022-04-28T17:11:49.000+0000",
        "timeoriginalestimate": null,
        "description": "Right now we create Tables, RecordBatches, ChunkedArrays, and Arrays using the corresponding {{$create()}} functions (or a few shortcut functions). This works well for converting other Arrow or base R types to Arow objects but doesn\u2019t work well for objects in other packages (e.g., sf). This is related to ARROW-14378 in that it provides a mechanism for other packages support writing objects to Arrow in a more Arrow-native form instead of serializing attributes that are unlikely to be readable in other packages. Many of these came up when experimenting with {{carrow}} when trying to provide seamless arrow package compatibility for S3 objects that wrap external pointers to C API data structures. S3 is a good way to do this because the other package doesn't have to put arrow in {{Imports}} since it's a heavy dependency.\r\n\r\nFor argument\u2019s sake I\u2019ll propose adding the following methods: \r\n\r\n-   {{as_arrow_array(x, type = NULL)}} -> {{Array}} \r\n-   {{as_arrow_chunked_array(x, type = NULL)}} -> {{ChunkedArray}} \r\n-   {{as_arrow_record_batch(x, schema = NULL)}} -> {{RecordBatch}} \r\n-   {{as_arrow_table(x, schema = NULL)}} -> {{Table}} \r\n-   {{as_arrow_data_type(x)}} -> {{DataType}} \r\n-   {{as_arrow_record_batch_reader(x, schema = NULL)}} -> {{RecordBatchReader}} \r\n\r\nI\u2019ll note that use {{as_adq()}} internally for similar reasons (to convert a few different object types into a arrow dplyr query when that\u2019s the data structure we need). \r\n\r\nAs part of this ticket, if we choose to move forward, we should implement the default methods with some internal consistency (i.e., somebody wanting to provide Arrow support in a package probably only has to implement {{as_arrow_array()}} to get most support.\r\n",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "9h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 33600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[R] Add S3 generics to create main Arrow objects",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418671/comment/17504651",
                    "id": "17504651",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jonkeane",
                        "name": "jonkeane",
                        "key": "jonkeane",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Jonathan Keane",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "This sounds good to me. We do have a few of these helpers (though they aren't generics...) like {{arrow_table}}. I'm fine with transitioning all of those to {{as_...}} versions of themselves, or we could drop the {{as_}} and repurpose them (AFAIK {{arrow_table}} is literally an alias for {{Table$create}} right now.)",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jonkeane",
                        "name": "jonkeane",
                        "key": "jonkeane",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Jonathan Keane",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2022-03-10T23:26:05.061+0000",
                    "updated": "2022-03-10T23:26:05.061+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418671/comment/17526856",
                    "id": "17526856",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=npr",
                        "name": "npr",
                        "key": "npr",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Neal Richardson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Issue resolved by pull request 12817\n[https://github.com/apache/arrow/pull/12817]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=npr",
                        "name": "npr",
                        "key": "npr",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Neal Richardson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-04-23T13:07:05.732+0000",
                    "updated": "2022-04-23T13:07:05.732+0000"
                }
            ],
            "maxResults": 2,
            "total": 2,
            "startAt": 0
        },
        "customfield_12311820": "0|z0xwi0:",
        "customfield_12314139": null
    }
}