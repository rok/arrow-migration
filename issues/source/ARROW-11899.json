{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13362913",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362913",
    "key": "ARROW-11899",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349493",
                "id": "12349493",
                "description": "",
                "name": "4.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-04-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=fan_li_ya",
            "name": "fan_li_ya",
            "key": "fan_li_ya",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Liya Fan",
            "active": true,
            "timeZone": "Asia/Shanghai"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328933",
                "id": "12328933",
                "name": "Java"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=fan_li_ya",
            "name": "fan_li_ya",
            "key": "fan_li_ya",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Liya Fan",
            "active": true,
            "timeZone": "Asia/Shanghai"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=fan_li_ya",
            "name": "fan_li_ya",
            "key": "fan_li_ya",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Liya Fan",
            "active": true,
            "timeZone": "Asia/Shanghai"
        },
        "aggregateprogress": {
            "progress": 12600,
            "total": 12600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 12600,
            "total": 12600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11899/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 21,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362913/worklog/569680",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 opened a new pull request #9769:\nURL: https://github.com/apache/arrow/pull/9769\n\n\n   This issue is in response to the discussion in https://github.com/apache/arrow/pull/8949/files#r588049088\r\n   \r\n   We want to refactor the compression codec related code into two parts: one for the core compression logic, and the other for Arrow specific logic.\r\n   \r\n   This will make it easier to support other compression types.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-22T12:51:48.563+0000",
                    "updated": "2021-03-22T12:51:48.563+0000",
                    "started": "2021-03-22T12:51:48.562+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "569680",
                    "issueId": "13362913"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362913/worklog/569721",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #9769:\nURL: https://github.com/apache/arrow/pull/9769#issuecomment-804089720\n\n\n   https://issues.apache.org/jira/browse/ARROW-11899\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-22T14:06:46.327+0000",
                    "updated": "2021-03-22T14:06:46.327+0000",
                    "started": "2021-03-22T14:06:46.327+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "569721",
                    "issueId": "13362913"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362913/worklog/570904",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #9769:\nURL: https://github.com/apache/arrow/pull/9769#discussion_r600129388\n\n\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/compression/AbstractCompressionCodec.java\n##########\n@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.compression;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.util.MemoryUtil;\n+import org.apache.arrow.util.Preconditions;\n+\n+/**\n+ * The base class for concrete compression codecs, providing\n+ * common logic for all compression codecs.\n+ */\n+public abstract class AbstractCompressionCodec implements CompressionCodec {\n+\n+  @Override\n+  public ArrowBuf compress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n+    Preconditions.checkArgument(uncompressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The uncompressed buffer size exceeds the integer limit\");\n+\n+    if (uncompressedBuffer.writerIndex() == 0L) {\n+      // shortcut for empty buffer\n+      ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      compressedBuffer.setLong(0, 0);\n+      compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      uncompressedBuffer.close();\n+      return compressedBuffer;\n+    }\n+\n+    ArrowBuf compressedBuffer = doCompress(allocator, uncompressedBuffer);\n+    long compressedLength = compressedBuffer.writerIndex() - CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH;\n+    long uncompressedLength = uncompressedBuffer.writerIndex();\n+\n+    if (compressedLength > uncompressedLength) {\n+      // compressed buffer is larger, send the raw buffer\n+      compressedBuffer.close();\n+      compressedBuffer = CompressionUtil.packageRawBuffer(allocator, uncompressedBuffer);\n+    } else {\n+      writeUncompressedLength(compressedBuffer, uncompressedLength);\n+    }\n+\n+    uncompressedBuffer.close();\n+    return compressedBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf decompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The compressed buffer size exceeds the integer limit\");\n\nReview comment:\n       nit: give limit in error message through format parameter?\r\n   \r\n   Can you remind me why we require integer limit?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-24T03:11:23.225+0000",
                    "updated": "2021-03-24T03:11:23.225+0000",
                    "started": "2021-03-24T03:11:23.224+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "570904",
                    "issueId": "13362913"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362913/worklog/570906",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #9769:\nURL: https://github.com/apache/arrow/pull/9769#discussion_r600131274\n\n\n\n##########\nFile path: java/compression/src/main/java/org/apache/arrow/compression/Lz4CompressionCodec.java\n##########\n@@ -38,109 +36,39 @@\n /**\n  * Compression codec for the LZ4 algorithm.\n  */\n-public class Lz4CompressionCodec implements CompressionCodec {\n+public class Lz4CompressionCodec extends AbstractCompressionCodec {\n \n-  @Override\n-  public ArrowBuf compress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n-    Preconditions.checkArgument(uncompressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n-        \"The uncompressed buffer size exceeds the integer limit\");\n-\n-    if (uncompressedBuffer.writerIndex() == 0L) {\n-      // shortcut for empty buffer\n-      ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n-      compressedBuffer.setLong(0, 0);\n-      compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n-      uncompressedBuffer.close();\n-      return compressedBuffer;\n-    }\n-\n-    try {\n-      ArrowBuf compressedBuffer = doCompress(allocator, uncompressedBuffer);\n-      long compressedLength = compressedBuffer.writerIndex() - CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH;\n-      if (compressedLength > uncompressedBuffer.writerIndex()) {\n-        // compressed buffer is larger, send the raw buffer\n-        compressedBuffer.close();\n-        compressedBuffer = CompressionUtil.packageRawBuffer(allocator, uncompressedBuffer);\n-      }\n-\n-      uncompressedBuffer.close();\n-      return compressedBuffer;\n-    } catch (IOException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n-\n-  private ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) throws IOException {\n+  protected ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n     byte[] inBytes = new byte[(int) uncompressedBuffer.writerIndex()];\n     PlatformDependent.copyMemory(uncompressedBuffer.memoryAddress(), inBytes, 0, uncompressedBuffer.writerIndex());\n     ByteArrayOutputStream baos = new ByteArrayOutputStream();\n     try (InputStream in = new ByteArrayInputStream(inBytes);\n          OutputStream out = new FramedLZ4CompressorOutputStream(baos)) {\n       IOUtils.copy(in, out);\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n     }\n \n     byte[] outBytes = baos.toByteArray();\n \n     ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH + outBytes.length);\n-\n-    long uncompressedLength = uncompressedBuffer.writerIndex();\n-    if (!MemoryUtil.LITTLE_ENDIAN) {\n-      uncompressedLength = Long.reverseBytes(uncompressedLength);\n-    }\n-    // first 8 bytes reserved for uncompressed length, according to the specification\n-    compressedBuffer.setLong(0, uncompressedLength);\n-\n     PlatformDependent.copyMemory(\n         outBytes, 0, compressedBuffer.memoryAddress() + CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH, outBytes.length);\n     compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH + outBytes.length);\n     return compressedBuffer;\n   }\n \n-  @Override\n-  public ArrowBuf decompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n-    Preconditions.checkArgument(compressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n-        \"The compressed buffer size exceeds the integer limit\");\n-\n-    Preconditions.checkArgument(compressedBuffer.writerIndex() >= CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH,\n-        \"Not enough data to decompress.\");\n-\n-    long decompressedLength = compressedBuffer.getLong(0);\n-    if (!MemoryUtil.LITTLE_ENDIAN) {\n-      decompressedLength = Long.reverseBytes(decompressedLength);\n-    }\n-\n-    if (decompressedLength == 0L) {\n-      // shortcut for empty buffer\n-      compressedBuffer.close();\n-      return allocator.getEmpty();\n-    }\n-\n-    if (decompressedLength == CompressionUtil.NO_COMPRESSION_LENGTH) {\n-      // no compression\n-      return CompressionUtil.extractUncompressedBuffer(compressedBuffer);\n-    }\n-\n-    try {\n-      ArrowBuf decompressedBuffer = doDecompress(allocator, compressedBuffer);\n-      compressedBuffer.close();\n-      return decompressedBuffer;\n-    } catch (IOException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n-\n-  private ArrowBuf doDecompress(BufferAllocator allocator, ArrowBuf compressedBuffer) throws IOException {\n-    long decompressedLength = compressedBuffer.getLong(0);\n-    if (!MemoryUtil.LITTLE_ENDIAN) {\n-      decompressedLength = Long.reverseBytes(decompressedLength);\n-    }\n+  protected ArrowBuf doDecompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n+    long decompressedLength = readUncompressedLength(compressedBuffer);\n\nReview comment:\n       i made a suggestion for a slightly different signature here that would eliminated the need to reference methods on the parent class.  If we go in that direction, do you think it might make sense to use composition instead of inheritance?  (haven't thought about it deeply).\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/compression/AbstractCompressionCodec.java\n##########\n@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.compression;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.util.MemoryUtil;\n+import org.apache.arrow.util.Preconditions;\n+\n+/**\n+ * The base class for concrete compression codecs, providing\n+ * common logic for all compression codecs.\n+ */\n+public abstract class AbstractCompressionCodec implements CompressionCodec {\n+\n+  @Override\n+  public ArrowBuf compress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n+    Preconditions.checkArgument(uncompressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The uncompressed buffer size exceeds the integer limit\");\n+\n+    if (uncompressedBuffer.writerIndex() == 0L) {\n+      // shortcut for empty buffer\n+      ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      compressedBuffer.setLong(0, 0);\n+      compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      uncompressedBuffer.close();\n+      return compressedBuffer;\n+    }\n+\n+    ArrowBuf compressedBuffer = doCompress(allocator, uncompressedBuffer);\n+    long compressedLength = compressedBuffer.writerIndex() - CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH;\n+    long uncompressedLength = uncompressedBuffer.writerIndex();\n+\n+    if (compressedLength > uncompressedLength) {\n+      // compressed buffer is larger, send the raw buffer\n+      compressedBuffer.close();\n+      compressedBuffer = CompressionUtil.packageRawBuffer(allocator, uncompressedBuffer);\n+    } else {\n+      writeUncompressedLength(compressedBuffer, uncompressedLength);\n+    }\n+\n+    uncompressedBuffer.close();\n+    return compressedBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf decompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The compressed buffer size exceeds the integer limit\");\n+\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() >= CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH,\n+        \"Not enough data to decompress.\");\n+\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+\n+    if (decompressedLength == 0L) {\n+      // shortcut for empty buffer\n+      compressedBuffer.close();\n+      return allocator.getEmpty();\n+    }\n+\n+    if (decompressedLength == CompressionUtil.NO_COMPRESSION_LENGTH) {\n+      // no compression\n+      return CompressionUtil.extractUncompressedBuffer(compressedBuffer);\n+    }\n+\n+    ArrowBuf decompressedBuffer = doDecompress(allocator, compressedBuffer);\n+    compressedBuffer.close();\n+    return decompressedBuffer;\n+  }\n+\n+  protected void writeUncompressedLength(ArrowBuf compressedBuffer, long uncompressedLength) {\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      uncompressedLength = Long.reverseBytes(uncompressedLength);\n+    }\n+    // first 8 bytes reserved for uncompressed length, according to the specification\n+    compressedBuffer.setLong(0, uncompressedLength);\n+  }\n+\n+  protected long readUncompressedLength(ArrowBuf compressedBuffer) {\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+    return decompressedLength;\n+  }\n+\n+  /**\n+   * The method that actually performs the data compression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n\nReview comment:\n       maybe clarify that is expected that the length of the returned buffer is always \"compressed data size in bytes\" + 8 bytes reserved at the beginning of the buffer.  \r\n   \r\n   Can you clarify contract for ownership of uncompressed buffer?\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/compression/AbstractCompressionCodec.java\n##########\n@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.compression;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.util.MemoryUtil;\n+import org.apache.arrow.util.Preconditions;\n+\n+/**\n+ * The base class for concrete compression codecs, providing\n+ * common logic for all compression codecs.\n+ */\n+public abstract class AbstractCompressionCodec implements CompressionCodec {\n+\n+  @Override\n+  public ArrowBuf compress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n+    Preconditions.checkArgument(uncompressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The uncompressed buffer size exceeds the integer limit\");\n+\n+    if (uncompressedBuffer.writerIndex() == 0L) {\n+      // shortcut for empty buffer\n+      ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      compressedBuffer.setLong(0, 0);\n+      compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      uncompressedBuffer.close();\n+      return compressedBuffer;\n+    }\n+\n+    ArrowBuf compressedBuffer = doCompress(allocator, uncompressedBuffer);\n+    long compressedLength = compressedBuffer.writerIndex() - CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH;\n+    long uncompressedLength = uncompressedBuffer.writerIndex();\n+\n+    if (compressedLength > uncompressedLength) {\n+      // compressed buffer is larger, send the raw buffer\n+      compressedBuffer.close();\n+      compressedBuffer = CompressionUtil.packageRawBuffer(allocator, uncompressedBuffer);\n+    } else {\n+      writeUncompressedLength(compressedBuffer, uncompressedLength);\n+    }\n+\n+    uncompressedBuffer.close();\n+    return compressedBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf decompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The compressed buffer size exceeds the integer limit\");\n+\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() >= CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH,\n+        \"Not enough data to decompress.\");\n+\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+\n+    if (decompressedLength == 0L) {\n+      // shortcut for empty buffer\n+      compressedBuffer.close();\n+      return allocator.getEmpty();\n+    }\n+\n+    if (decompressedLength == CompressionUtil.NO_COMPRESSION_LENGTH) {\n+      // no compression\n+      return CompressionUtil.extractUncompressedBuffer(compressedBuffer);\n+    }\n+\n+    ArrowBuf decompressedBuffer = doDecompress(allocator, compressedBuffer);\n+    compressedBuffer.close();\n+    return decompressedBuffer;\n+  }\n+\n+  protected void writeUncompressedLength(ArrowBuf compressedBuffer, long uncompressedLength) {\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      uncompressedLength = Long.reverseBytes(uncompressedLength);\n+    }\n+    // first 8 bytes reserved for uncompressed length, according to the specification\n+    compressedBuffer.setLong(0, uncompressedLength);\n+  }\n+\n+  protected long readUncompressedLength(ArrowBuf compressedBuffer) {\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+    return decompressedLength;\n+  }\n+\n+  /**\n+   * The method that actually performs the data compression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n+   */\n+  protected abstract ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer);\n+\n+  /**\n+   * The method that actually performs the data decompression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n\nReview comment:\n       I think for decompression it probably makes sense to provide the slice buffer only including the compressed data, and a preallocated output buffer to simply implementations of other codec.  What do you think?\n\n##########\nFile path: java/compression/src/main/java/org/apache/arrow/compression/Lz4CompressionCodec.java\n##########\n@@ -38,109 +36,39 @@\n /**\n  * Compression codec for the LZ4 algorithm.\n  */\n-public class Lz4CompressionCodec implements CompressionCodec {\n+public class Lz4CompressionCodec extends AbstractCompressionCodec {\n \n-  @Override\n-  public ArrowBuf compress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n-    Preconditions.checkArgument(uncompressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n-        \"The uncompressed buffer size exceeds the integer limit\");\n-\n-    if (uncompressedBuffer.writerIndex() == 0L) {\n-      // shortcut for empty buffer\n-      ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n-      compressedBuffer.setLong(0, 0);\n-      compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n-      uncompressedBuffer.close();\n-      return compressedBuffer;\n-    }\n-\n-    try {\n-      ArrowBuf compressedBuffer = doCompress(allocator, uncompressedBuffer);\n-      long compressedLength = compressedBuffer.writerIndex() - CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH;\n-      if (compressedLength > uncompressedBuffer.writerIndex()) {\n-        // compressed buffer is larger, send the raw buffer\n-        compressedBuffer.close();\n-        compressedBuffer = CompressionUtil.packageRawBuffer(allocator, uncompressedBuffer);\n-      }\n-\n-      uncompressedBuffer.close();\n-      return compressedBuffer;\n-    } catch (IOException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n-\n-  private ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) throws IOException {\n+  protected ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n\nReview comment:\n       nit \"@override\"?\n\n##########\nFile path: java/compression/src/main/java/org/apache/arrow/compression/Lz4CompressionCodec.java\n##########\n@@ -38,109 +36,39 @@\n /**\n  * Compression codec for the LZ4 algorithm.\n  */\n-public class Lz4CompressionCodec implements CompressionCodec {\n+public class Lz4CompressionCodec extends AbstractCompressionCodec {\n \n-  @Override\n-  public ArrowBuf compress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n-    Preconditions.checkArgument(uncompressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n-        \"The uncompressed buffer size exceeds the integer limit\");\n-\n-    if (uncompressedBuffer.writerIndex() == 0L) {\n-      // shortcut for empty buffer\n-      ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n-      compressedBuffer.setLong(0, 0);\n-      compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n-      uncompressedBuffer.close();\n-      return compressedBuffer;\n-    }\n-\n-    try {\n-      ArrowBuf compressedBuffer = doCompress(allocator, uncompressedBuffer);\n-      long compressedLength = compressedBuffer.writerIndex() - CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH;\n-      if (compressedLength > uncompressedBuffer.writerIndex()) {\n-        // compressed buffer is larger, send the raw buffer\n-        compressedBuffer.close();\n-        compressedBuffer = CompressionUtil.packageRawBuffer(allocator, uncompressedBuffer);\n-      }\n-\n-      uncompressedBuffer.close();\n-      return compressedBuffer;\n-    } catch (IOException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n-\n-  private ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) throws IOException {\n+  protected ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n     byte[] inBytes = new byte[(int) uncompressedBuffer.writerIndex()];\n     PlatformDependent.copyMemory(uncompressedBuffer.memoryAddress(), inBytes, 0, uncompressedBuffer.writerIndex());\n     ByteArrayOutputStream baos = new ByteArrayOutputStream();\n     try (InputStream in = new ByteArrayInputStream(inBytes);\n          OutputStream out = new FramedLZ4CompressorOutputStream(baos)) {\n       IOUtils.copy(in, out);\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n     }\n \n     byte[] outBytes = baos.toByteArray();\n \n     ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH + outBytes.length);\n-\n-    long uncompressedLength = uncompressedBuffer.writerIndex();\n-    if (!MemoryUtil.LITTLE_ENDIAN) {\n-      uncompressedLength = Long.reverseBytes(uncompressedLength);\n-    }\n-    // first 8 bytes reserved for uncompressed length, according to the specification\n-    compressedBuffer.setLong(0, uncompressedLength);\n-\n     PlatformDependent.copyMemory(\n         outBytes, 0, compressedBuffer.memoryAddress() + CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH, outBytes.length);\n     compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH + outBytes.length);\n     return compressedBuffer;\n   }\n \n-  @Override\n-  public ArrowBuf decompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n-    Preconditions.checkArgument(compressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n-        \"The compressed buffer size exceeds the integer limit\");\n-\n-    Preconditions.checkArgument(compressedBuffer.writerIndex() >= CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH,\n-        \"Not enough data to decompress.\");\n-\n-    long decompressedLength = compressedBuffer.getLong(0);\n-    if (!MemoryUtil.LITTLE_ENDIAN) {\n-      decompressedLength = Long.reverseBytes(decompressedLength);\n-    }\n-\n-    if (decompressedLength == 0L) {\n-      // shortcut for empty buffer\n-      compressedBuffer.close();\n-      return allocator.getEmpty();\n-    }\n-\n-    if (decompressedLength == CompressionUtil.NO_COMPRESSION_LENGTH) {\n-      // no compression\n-      return CompressionUtil.extractUncompressedBuffer(compressedBuffer);\n-    }\n-\n-    try {\n-      ArrowBuf decompressedBuffer = doDecompress(allocator, compressedBuffer);\n-      compressedBuffer.close();\n-      return decompressedBuffer;\n-    } catch (IOException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n-\n-  private ArrowBuf doDecompress(BufferAllocator allocator, ArrowBuf compressedBuffer) throws IOException {\n-    long decompressedLength = compressedBuffer.getLong(0);\n-    if (!MemoryUtil.LITTLE_ENDIAN) {\n-      decompressedLength = Long.reverseBytes(decompressedLength);\n-    }\n+  protected ArrowBuf doDecompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n\nReview comment:\n       nit \"@override\"?\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/compression/AbstractCompressionCodec.java\n##########\n@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.compression;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.util.MemoryUtil;\n+import org.apache.arrow.util.Preconditions;\n+\n+/**\n+ * The base class for concrete compression codecs, providing\n+ * common logic for all compression codecs.\n+ */\n+public abstract class AbstractCompressionCodec implements CompressionCodec {\n+\n+  @Override\n+  public ArrowBuf compress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n+    Preconditions.checkArgument(uncompressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The uncompressed buffer size exceeds the integer limit\");\n+\n+    if (uncompressedBuffer.writerIndex() == 0L) {\n+      // shortcut for empty buffer\n+      ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      compressedBuffer.setLong(0, 0);\n+      compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      uncompressedBuffer.close();\n+      return compressedBuffer;\n+    }\n+\n+    ArrowBuf compressedBuffer = doCompress(allocator, uncompressedBuffer);\n+    long compressedLength = compressedBuffer.writerIndex() - CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH;\n+    long uncompressedLength = uncompressedBuffer.writerIndex();\n+\n+    if (compressedLength > uncompressedLength) {\n+      // compressed buffer is larger, send the raw buffer\n+      compressedBuffer.close();\n+      compressedBuffer = CompressionUtil.packageRawBuffer(allocator, uncompressedBuffer);\n+    } else {\n+      writeUncompressedLength(compressedBuffer, uncompressedLength);\n+    }\n+\n+    uncompressedBuffer.close();\n+    return compressedBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf decompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The compressed buffer size exceeds the integer limit\");\n+\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() >= CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH,\n+        \"Not enough data to decompress.\");\n+\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+\n+    if (decompressedLength == 0L) {\n+      // shortcut for empty buffer\n+      compressedBuffer.close();\n+      return allocator.getEmpty();\n+    }\n+\n+    if (decompressedLength == CompressionUtil.NO_COMPRESSION_LENGTH) {\n+      // no compression\n+      return CompressionUtil.extractUncompressedBuffer(compressedBuffer);\n+    }\n+\n+    ArrowBuf decompressedBuffer = doDecompress(allocator, compressedBuffer);\n+    compressedBuffer.close();\n+    return decompressedBuffer;\n+  }\n+\n+  protected void writeUncompressedLength(ArrowBuf compressedBuffer, long uncompressedLength) {\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      uncompressedLength = Long.reverseBytes(uncompressedLength);\n+    }\n+    // first 8 bytes reserved for uncompressed length, according to the specification\n+    compressedBuffer.setLong(0, uncompressedLength);\n+  }\n+\n+  protected long readUncompressedLength(ArrowBuf compressedBuffer) {\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+    return decompressedLength;\n+  }\n+\n+  /**\n+   * The method that actually performs the data compression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n+   */\n+  protected abstract ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer);\n+\n+  /**\n+   * The method that actually performs the data decompression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n\nReview comment:\n       Either way lets clarify ownership of the passed in buffer.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-24T03:19:27.500+0000",
                    "updated": "2021-03-24T03:19:27.500+0000",
                    "started": "2021-03-24T03:19:27.500+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "570906",
                    "issueId": "13362913"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362913/worklog/570915",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on pull request #9769:\nURL: https://github.com/apache/arrow/pull/9769#issuecomment-805469834\n\n\n   > @liyafan82 thanks. A few small comments/nits on documentation, and one question about the API.\r\n   \r\n   @emkornfield Thanks for your comments. I will address them ASAP. \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-24T04:03:34.488+0000",
                    "updated": "2021-03-24T04:03:34.488+0000",
                    "started": "2021-03-24T04:03:34.488+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "570915",
                    "issueId": "13362913"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362913/worklog/571640",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on a change in pull request #9769:\nURL: https://github.com/apache/arrow/pull/9769#discussion_r601035880\n\n\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/compression/AbstractCompressionCodec.java\n##########\n@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.compression;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.util.MemoryUtil;\n+import org.apache.arrow.util.Preconditions;\n+\n+/**\n+ * The base class for concrete compression codecs, providing\n+ * common logic for all compression codecs.\n+ */\n+public abstract class AbstractCompressionCodec implements CompressionCodec {\n+\n+  @Override\n+  public ArrowBuf compress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n+    Preconditions.checkArgument(uncompressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The uncompressed buffer size exceeds the integer limit\");\n+\n+    if (uncompressedBuffer.writerIndex() == 0L) {\n+      // shortcut for empty buffer\n+      ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      compressedBuffer.setLong(0, 0);\n+      compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      uncompressedBuffer.close();\n+      return compressedBuffer;\n+    }\n+\n+    ArrowBuf compressedBuffer = doCompress(allocator, uncompressedBuffer);\n+    long compressedLength = compressedBuffer.writerIndex() - CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH;\n+    long uncompressedLength = uncompressedBuffer.writerIndex();\n+\n+    if (compressedLength > uncompressedLength) {\n+      // compressed buffer is larger, send the raw buffer\n+      compressedBuffer.close();\n+      compressedBuffer = CompressionUtil.packageRawBuffer(allocator, uncompressedBuffer);\n+    } else {\n+      writeUncompressedLength(compressedBuffer, uncompressedLength);\n+    }\n+\n+    uncompressedBuffer.close();\n+    return compressedBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf decompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The compressed buffer size exceeds the integer limit\");\n\nReview comment:\n       Sorry this is an implementation specific constraint.\r\n   Since we must copy the data into an on-heap array, and the on-heap array cannot exceed 2GB in size, we have this limit.\r\n   \r\n   I have moved them to the concrete codec implementation, and give the limit explicitly in the message. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-25T04:39:22.526+0000",
                    "updated": "2021-03-25T04:39:22.526+0000",
                    "started": "2021-03-25T04:39:22.525+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "571640",
                    "issueId": "13362913"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362913/worklog/571641",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on a change in pull request #9769:\nURL: https://github.com/apache/arrow/pull/9769#discussion_r601036142\n\n\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/compression/AbstractCompressionCodec.java\n##########\n@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.compression;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.util.MemoryUtil;\n+import org.apache.arrow.util.Preconditions;\n+\n+/**\n+ * The base class for concrete compression codecs, providing\n+ * common logic for all compression codecs.\n+ */\n+public abstract class AbstractCompressionCodec implements CompressionCodec {\n+\n+  @Override\n+  public ArrowBuf compress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n+    Preconditions.checkArgument(uncompressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The uncompressed buffer size exceeds the integer limit\");\n+\n+    if (uncompressedBuffer.writerIndex() == 0L) {\n+      // shortcut for empty buffer\n+      ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      compressedBuffer.setLong(0, 0);\n+      compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      uncompressedBuffer.close();\n+      return compressedBuffer;\n+    }\n+\n+    ArrowBuf compressedBuffer = doCompress(allocator, uncompressedBuffer);\n+    long compressedLength = compressedBuffer.writerIndex() - CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH;\n+    long uncompressedLength = uncompressedBuffer.writerIndex();\n+\n+    if (compressedLength > uncompressedLength) {\n+      // compressed buffer is larger, send the raw buffer\n+      compressedBuffer.close();\n+      compressedBuffer = CompressionUtil.packageRawBuffer(allocator, uncompressedBuffer);\n+    } else {\n+      writeUncompressedLength(compressedBuffer, uncompressedLength);\n+    }\n+\n+    uncompressedBuffer.close();\n+    return compressedBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf decompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The compressed buffer size exceeds the integer limit\");\n+\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() >= CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH,\n+        \"Not enough data to decompress.\");\n+\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+\n+    if (decompressedLength == 0L) {\n+      // shortcut for empty buffer\n+      compressedBuffer.close();\n+      return allocator.getEmpty();\n+    }\n+\n+    if (decompressedLength == CompressionUtil.NO_COMPRESSION_LENGTH) {\n+      // no compression\n+      return CompressionUtil.extractUncompressedBuffer(compressedBuffer);\n+    }\n+\n+    ArrowBuf decompressedBuffer = doDecompress(allocator, compressedBuffer);\n+    compressedBuffer.close();\n+    return decompressedBuffer;\n+  }\n+\n+  protected void writeUncompressedLength(ArrowBuf compressedBuffer, long uncompressedLength) {\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      uncompressedLength = Long.reverseBytes(uncompressedLength);\n+    }\n+    // first 8 bytes reserved for uncompressed length, according to the specification\n+    compressedBuffer.setLong(0, uncompressedLength);\n+  }\n+\n+  protected long readUncompressedLength(ArrowBuf compressedBuffer) {\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+    return decompressedLength;\n+  }\n+\n+  /**\n+   * The method that actually performs the data compression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n\nReview comment:\n       I have changed the javadoc to clarify the layout, and made the ownership clear. Thanks for the good suggestion. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-25T04:40:15.523+0000",
                    "updated": "2021-03-25T04:40:15.523+0000",
                    "started": "2021-03-25T04:40:15.523+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "571641",
                    "issueId": "13362913"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362913/worklog/571642",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on a change in pull request #9769:\nURL: https://github.com/apache/arrow/pull/9769#discussion_r601038372\n\n\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/compression/AbstractCompressionCodec.java\n##########\n@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.compression;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.util.MemoryUtil;\n+import org.apache.arrow.util.Preconditions;\n+\n+/**\n+ * The base class for concrete compression codecs, providing\n+ * common logic for all compression codecs.\n+ */\n+public abstract class AbstractCompressionCodec implements CompressionCodec {\n+\n+  @Override\n+  public ArrowBuf compress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n+    Preconditions.checkArgument(uncompressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The uncompressed buffer size exceeds the integer limit\");\n+\n+    if (uncompressedBuffer.writerIndex() == 0L) {\n+      // shortcut for empty buffer\n+      ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      compressedBuffer.setLong(0, 0);\n+      compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      uncompressedBuffer.close();\n+      return compressedBuffer;\n+    }\n+\n+    ArrowBuf compressedBuffer = doCompress(allocator, uncompressedBuffer);\n+    long compressedLength = compressedBuffer.writerIndex() - CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH;\n+    long uncompressedLength = uncompressedBuffer.writerIndex();\n+\n+    if (compressedLength > uncompressedLength) {\n+      // compressed buffer is larger, send the raw buffer\n+      compressedBuffer.close();\n+      compressedBuffer = CompressionUtil.packageRawBuffer(allocator, uncompressedBuffer);\n+    } else {\n+      writeUncompressedLength(compressedBuffer, uncompressedLength);\n+    }\n+\n+    uncompressedBuffer.close();\n+    return compressedBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf decompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The compressed buffer size exceeds the integer limit\");\n+\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() >= CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH,\n+        \"Not enough data to decompress.\");\n+\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+\n+    if (decompressedLength == 0L) {\n+      // shortcut for empty buffer\n+      compressedBuffer.close();\n+      return allocator.getEmpty();\n+    }\n+\n+    if (decompressedLength == CompressionUtil.NO_COMPRESSION_LENGTH) {\n+      // no compression\n+      return CompressionUtil.extractUncompressedBuffer(compressedBuffer);\n+    }\n+\n+    ArrowBuf decompressedBuffer = doDecompress(allocator, compressedBuffer);\n+    compressedBuffer.close();\n+    return decompressedBuffer;\n+  }\n+\n+  protected void writeUncompressedLength(ArrowBuf compressedBuffer, long uncompressedLength) {\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      uncompressedLength = Long.reverseBytes(uncompressedLength);\n+    }\n+    // first 8 bytes reserved for uncompressed length, according to the specification\n+    compressedBuffer.setLong(0, uncompressedLength);\n+  }\n+\n+  protected long readUncompressedLength(ArrowBuf compressedBuffer) {\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+    return decompressedLength;\n+  }\n+\n+  /**\n+   * The method that actually performs the data compression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n+   */\n+  protected abstract ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer);\n+\n+  /**\n+   * The method that actually performs the data decompression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n\nReview comment:\n       I have revised the JavaDoc to clarify the buffer ownership. Thanks.\r\n   \r\n   The method of passing in only the compressed data sounds good to me. \r\n   However, there are some problem when implementing the `doDecompress` method: it may also need the uncompressed size (e.g. to allocate some internal data structures, like on-heap array in our implementation). Such information can be obtained from the size of the passed-in buffer. However, the buffer size can be larger than the uncompressed size, which may cause waste of memory.\r\n   \r\n   We can also change the interface to pass in the uncompressed size, but this would make the interface more complicated and asymmetric. \r\n   \r\n   So I have keeped the interface unchanged. If you feel strong about it, we can change the interface in that way. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-25T04:47:59.906+0000",
                    "updated": "2021-03-25T04:47:59.906+0000",
                    "started": "2021-03-25T04:47:59.906+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "571642",
                    "issueId": "13362913"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362913/worklog/571643",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on a change in pull request #9769:\nURL: https://github.com/apache/arrow/pull/9769#discussion_r601039000\n\n\n\n##########\nFile path: java/compression/src/main/java/org/apache/arrow/compression/Lz4CompressionCodec.java\n##########\n@@ -38,109 +36,39 @@\n /**\n  * Compression codec for the LZ4 algorithm.\n  */\n-public class Lz4CompressionCodec implements CompressionCodec {\n+public class Lz4CompressionCodec extends AbstractCompressionCodec {\n \n-  @Override\n-  public ArrowBuf compress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n-    Preconditions.checkArgument(uncompressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n-        \"The uncompressed buffer size exceeds the integer limit\");\n-\n-    if (uncompressedBuffer.writerIndex() == 0L) {\n-      // shortcut for empty buffer\n-      ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n-      compressedBuffer.setLong(0, 0);\n-      compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n-      uncompressedBuffer.close();\n-      return compressedBuffer;\n-    }\n-\n-    try {\n-      ArrowBuf compressedBuffer = doCompress(allocator, uncompressedBuffer);\n-      long compressedLength = compressedBuffer.writerIndex() - CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH;\n-      if (compressedLength > uncompressedBuffer.writerIndex()) {\n-        // compressed buffer is larger, send the raw buffer\n-        compressedBuffer.close();\n-        compressedBuffer = CompressionUtil.packageRawBuffer(allocator, uncompressedBuffer);\n-      }\n-\n-      uncompressedBuffer.close();\n-      return compressedBuffer;\n-    } catch (IOException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n-\n-  private ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) throws IOException {\n+  protected ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n     byte[] inBytes = new byte[(int) uncompressedBuffer.writerIndex()];\n     PlatformDependent.copyMemory(uncompressedBuffer.memoryAddress(), inBytes, 0, uncompressedBuffer.writerIndex());\n     ByteArrayOutputStream baos = new ByteArrayOutputStream();\n     try (InputStream in = new ByteArrayInputStream(inBytes);\n          OutputStream out = new FramedLZ4CompressorOutputStream(baos)) {\n       IOUtils.copy(in, out);\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n     }\n \n     byte[] outBytes = baos.toByteArray();\n \n     ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH + outBytes.length);\n-\n-    long uncompressedLength = uncompressedBuffer.writerIndex();\n-    if (!MemoryUtil.LITTLE_ENDIAN) {\n-      uncompressedLength = Long.reverseBytes(uncompressedLength);\n-    }\n-    // first 8 bytes reserved for uncompressed length, according to the specification\n-    compressedBuffer.setLong(0, uncompressedLength);\n-\n     PlatformDependent.copyMemory(\n         outBytes, 0, compressedBuffer.memoryAddress() + CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH, outBytes.length);\n     compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH + outBytes.length);\n     return compressedBuffer;\n   }\n \n-  @Override\n-  public ArrowBuf decompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n-    Preconditions.checkArgument(compressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n-        \"The compressed buffer size exceeds the integer limit\");\n-\n-    Preconditions.checkArgument(compressedBuffer.writerIndex() >= CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH,\n-        \"Not enough data to decompress.\");\n-\n-    long decompressedLength = compressedBuffer.getLong(0);\n-    if (!MemoryUtil.LITTLE_ENDIAN) {\n-      decompressedLength = Long.reverseBytes(decompressedLength);\n-    }\n-\n-    if (decompressedLength == 0L) {\n-      // shortcut for empty buffer\n-      compressedBuffer.close();\n-      return allocator.getEmpty();\n-    }\n-\n-    if (decompressedLength == CompressionUtil.NO_COMPRESSION_LENGTH) {\n-      // no compression\n-      return CompressionUtil.extractUncompressedBuffer(compressedBuffer);\n-    }\n-\n-    try {\n-      ArrowBuf decompressedBuffer = doDecompress(allocator, compressedBuffer);\n-      compressedBuffer.close();\n-      return decompressedBuffer;\n-    } catch (IOException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n-\n-  private ArrowBuf doDecompress(BufferAllocator allocator, ArrowBuf compressedBuffer) throws IOException {\n-    long decompressedLength = compressedBuffer.getLong(0);\n-    if (!MemoryUtil.LITTLE_ENDIAN) {\n-      decompressedLength = Long.reverseBytes(decompressedLength);\n-    }\n+  protected ArrowBuf doDecompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n+    long decompressedLength = readUncompressedLength(compressedBuffer);\n\nReview comment:\n       Here we are applying the template method design pattern, so inheritance seems a natural choice?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-25T04:50:02.888+0000",
                    "updated": "2021-03-25T04:50:02.888+0000",
                    "started": "2021-03-25T04:50:02.888+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "571643",
                    "issueId": "13362913"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362913/worklog/571644",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on a change in pull request #9769:\nURL: https://github.com/apache/arrow/pull/9769#discussion_r601039085\n\n\n\n##########\nFile path: java/compression/src/main/java/org/apache/arrow/compression/Lz4CompressionCodec.java\n##########\n@@ -38,109 +36,39 @@\n /**\n  * Compression codec for the LZ4 algorithm.\n  */\n-public class Lz4CompressionCodec implements CompressionCodec {\n+public class Lz4CompressionCodec extends AbstractCompressionCodec {\n \n-  @Override\n-  public ArrowBuf compress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n-    Preconditions.checkArgument(uncompressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n-        \"The uncompressed buffer size exceeds the integer limit\");\n-\n-    if (uncompressedBuffer.writerIndex() == 0L) {\n-      // shortcut for empty buffer\n-      ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n-      compressedBuffer.setLong(0, 0);\n-      compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n-      uncompressedBuffer.close();\n-      return compressedBuffer;\n-    }\n-\n-    try {\n-      ArrowBuf compressedBuffer = doCompress(allocator, uncompressedBuffer);\n-      long compressedLength = compressedBuffer.writerIndex() - CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH;\n-      if (compressedLength > uncompressedBuffer.writerIndex()) {\n-        // compressed buffer is larger, send the raw buffer\n-        compressedBuffer.close();\n-        compressedBuffer = CompressionUtil.packageRawBuffer(allocator, uncompressedBuffer);\n-      }\n-\n-      uncompressedBuffer.close();\n-      return compressedBuffer;\n-    } catch (IOException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n-\n-  private ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) throws IOException {\n+  protected ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n     byte[] inBytes = new byte[(int) uncompressedBuffer.writerIndex()];\n     PlatformDependent.copyMemory(uncompressedBuffer.memoryAddress(), inBytes, 0, uncompressedBuffer.writerIndex());\n     ByteArrayOutputStream baos = new ByteArrayOutputStream();\n     try (InputStream in = new ByteArrayInputStream(inBytes);\n          OutputStream out = new FramedLZ4CompressorOutputStream(baos)) {\n       IOUtils.copy(in, out);\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n     }\n \n     byte[] outBytes = baos.toByteArray();\n \n     ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH + outBytes.length);\n-\n-    long uncompressedLength = uncompressedBuffer.writerIndex();\n-    if (!MemoryUtil.LITTLE_ENDIAN) {\n-      uncompressedLength = Long.reverseBytes(uncompressedLength);\n-    }\n-    // first 8 bytes reserved for uncompressed length, according to the specification\n-    compressedBuffer.setLong(0, uncompressedLength);\n-\n     PlatformDependent.copyMemory(\n         outBytes, 0, compressedBuffer.memoryAddress() + CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH, outBytes.length);\n     compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH + outBytes.length);\n     return compressedBuffer;\n   }\n \n-  @Override\n-  public ArrowBuf decompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n-    Preconditions.checkArgument(compressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n-        \"The compressed buffer size exceeds the integer limit\");\n-\n-    Preconditions.checkArgument(compressedBuffer.writerIndex() >= CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH,\n-        \"Not enough data to decompress.\");\n-\n-    long decompressedLength = compressedBuffer.getLong(0);\n-    if (!MemoryUtil.LITTLE_ENDIAN) {\n-      decompressedLength = Long.reverseBytes(decompressedLength);\n-    }\n-\n-    if (decompressedLength == 0L) {\n-      // shortcut for empty buffer\n-      compressedBuffer.close();\n-      return allocator.getEmpty();\n-    }\n-\n-    if (decompressedLength == CompressionUtil.NO_COMPRESSION_LENGTH) {\n-      // no compression\n-      return CompressionUtil.extractUncompressedBuffer(compressedBuffer);\n-    }\n-\n-    try {\n-      ArrowBuf decompressedBuffer = doDecompress(allocator, compressedBuffer);\n-      compressedBuffer.close();\n-      return decompressedBuffer;\n-    } catch (IOException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n-\n-  private ArrowBuf doDecompress(BufferAllocator allocator, ArrowBuf compressedBuffer) throws IOException {\n-    long decompressedLength = compressedBuffer.getLong(0);\n-    if (!MemoryUtil.LITTLE_ENDIAN) {\n-      decompressedLength = Long.reverseBytes(decompressedLength);\n-    }\n+  protected ArrowBuf doDecompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n\nReview comment:\n       Revised. Thank you.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-25T04:50:15.914+0000",
                    "updated": "2021-03-25T04:50:15.914+0000",
                    "started": "2021-03-25T04:50:15.914+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "571644",
                    "issueId": "13362913"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362913/worklog/571645",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on a change in pull request #9769:\nURL: https://github.com/apache/arrow/pull/9769#discussion_r601039259\n\n\n\n##########\nFile path: java/compression/src/main/java/org/apache/arrow/compression/Lz4CompressionCodec.java\n##########\n@@ -38,109 +36,39 @@\n /**\n  * Compression codec for the LZ4 algorithm.\n  */\n-public class Lz4CompressionCodec implements CompressionCodec {\n+public class Lz4CompressionCodec extends AbstractCompressionCodec {\n \n-  @Override\n-  public ArrowBuf compress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n-    Preconditions.checkArgument(uncompressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n-        \"The uncompressed buffer size exceeds the integer limit\");\n-\n-    if (uncompressedBuffer.writerIndex() == 0L) {\n-      // shortcut for empty buffer\n-      ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n-      compressedBuffer.setLong(0, 0);\n-      compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n-      uncompressedBuffer.close();\n-      return compressedBuffer;\n-    }\n-\n-    try {\n-      ArrowBuf compressedBuffer = doCompress(allocator, uncompressedBuffer);\n-      long compressedLength = compressedBuffer.writerIndex() - CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH;\n-      if (compressedLength > uncompressedBuffer.writerIndex()) {\n-        // compressed buffer is larger, send the raw buffer\n-        compressedBuffer.close();\n-        compressedBuffer = CompressionUtil.packageRawBuffer(allocator, uncompressedBuffer);\n-      }\n-\n-      uncompressedBuffer.close();\n-      return compressedBuffer;\n-    } catch (IOException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n-\n-  private ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) throws IOException {\n+  protected ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n\nReview comment:\n       Nice catch. Thank you.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-25T04:50:59.146+0000",
                    "updated": "2021-03-25T04:50:59.146+0000",
                    "started": "2021-03-25T04:50:59.145+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "571645",
                    "issueId": "13362913"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362913/worklog/571646",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #9769:\nURL: https://github.com/apache/arrow/pull/9769#discussion_r601039315\n\n\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/compression/AbstractCompressionCodec.java\n##########\n@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.compression;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.util.MemoryUtil;\n+import org.apache.arrow.util.Preconditions;\n+\n+/**\n+ * The base class for concrete compression codecs, providing\n+ * common logic for all compression codecs.\n+ */\n+public abstract class AbstractCompressionCodec implements CompressionCodec {\n+\n+  @Override\n+  public ArrowBuf compress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n+    Preconditions.checkArgument(uncompressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The uncompressed buffer size exceeds the integer limit\");\n+\n+    if (uncompressedBuffer.writerIndex() == 0L) {\n+      // shortcut for empty buffer\n+      ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      compressedBuffer.setLong(0, 0);\n+      compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      uncompressedBuffer.close();\n+      return compressedBuffer;\n+    }\n+\n+    ArrowBuf compressedBuffer = doCompress(allocator, uncompressedBuffer);\n+    long compressedLength = compressedBuffer.writerIndex() - CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH;\n+    long uncompressedLength = uncompressedBuffer.writerIndex();\n+\n+    if (compressedLength > uncompressedLength) {\n+      // compressed buffer is larger, send the raw buffer\n+      compressedBuffer.close();\n+      compressedBuffer = CompressionUtil.packageRawBuffer(allocator, uncompressedBuffer);\n+    } else {\n+      writeUncompressedLength(compressedBuffer, uncompressedLength);\n+    }\n+\n+    uncompressedBuffer.close();\n+    return compressedBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf decompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The compressed buffer size exceeds the integer limit\");\n+\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() >= CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH,\n+        \"Not enough data to decompress.\");\n+\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+\n+    if (decompressedLength == 0L) {\n+      // shortcut for empty buffer\n+      compressedBuffer.close();\n+      return allocator.getEmpty();\n+    }\n+\n+    if (decompressedLength == CompressionUtil.NO_COMPRESSION_LENGTH) {\n+      // no compression\n+      return CompressionUtil.extractUncompressedBuffer(compressedBuffer);\n+    }\n+\n+    ArrowBuf decompressedBuffer = doDecompress(allocator, compressedBuffer);\n+    compressedBuffer.close();\n+    return decompressedBuffer;\n+  }\n+\n+  protected void writeUncompressedLength(ArrowBuf compressedBuffer, long uncompressedLength) {\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      uncompressedLength = Long.reverseBytes(uncompressedLength);\n+    }\n+    // first 8 bytes reserved for uncompressed length, according to the specification\n+    compressedBuffer.setLong(0, uncompressedLength);\n+  }\n+\n+  protected long readUncompressedLength(ArrowBuf compressedBuffer) {\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+    return decompressedLength;\n+  }\n+\n+  /**\n+   * The method that actually performs the data compression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n+   */\n+  protected abstract ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer);\n+\n+  /**\n+   * The method that actually performs the data decompression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n\nReview comment:\n       > Such information can be obtained from the size of the passed-in buffer. However, the buffer size can be larger than the uncompressed size, which may cause waste of memory.\r\n   \r\n   In what cases would we pass in a buffer that is larger than the decompressed size? (it seems like it would could always be allocated to the exact size needed?  Or are you saying some buffers need to be larger then the simply the uncompressed size?)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-25T04:51:02.169+0000",
                    "updated": "2021-03-25T04:51:02.169+0000",
                    "started": "2021-03-25T04:51:02.169+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "571646",
                    "issueId": "13362913"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362913/worklog/571665",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on a change in pull request #9769:\nURL: https://github.com/apache/arrow/pull/9769#discussion_r601085650\n\n\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/compression/AbstractCompressionCodec.java\n##########\n@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.compression;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.util.MemoryUtil;\n+import org.apache.arrow.util.Preconditions;\n+\n+/**\n+ * The base class for concrete compression codecs, providing\n+ * common logic for all compression codecs.\n+ */\n+public abstract class AbstractCompressionCodec implements CompressionCodec {\n+\n+  @Override\n+  public ArrowBuf compress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n+    Preconditions.checkArgument(uncompressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The uncompressed buffer size exceeds the integer limit\");\n+\n+    if (uncompressedBuffer.writerIndex() == 0L) {\n+      // shortcut for empty buffer\n+      ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      compressedBuffer.setLong(0, 0);\n+      compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      uncompressedBuffer.close();\n+      return compressedBuffer;\n+    }\n+\n+    ArrowBuf compressedBuffer = doCompress(allocator, uncompressedBuffer);\n+    long compressedLength = compressedBuffer.writerIndex() - CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH;\n+    long uncompressedLength = uncompressedBuffer.writerIndex();\n+\n+    if (compressedLength > uncompressedLength) {\n+      // compressed buffer is larger, send the raw buffer\n+      compressedBuffer.close();\n+      compressedBuffer = CompressionUtil.packageRawBuffer(allocator, uncompressedBuffer);\n+    } else {\n+      writeUncompressedLength(compressedBuffer, uncompressedLength);\n+    }\n+\n+    uncompressedBuffer.close();\n+    return compressedBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf decompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The compressed buffer size exceeds the integer limit\");\n+\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() >= CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH,\n+        \"Not enough data to decompress.\");\n+\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+\n+    if (decompressedLength == 0L) {\n+      // shortcut for empty buffer\n+      compressedBuffer.close();\n+      return allocator.getEmpty();\n+    }\n+\n+    if (decompressedLength == CompressionUtil.NO_COMPRESSION_LENGTH) {\n+      // no compression\n+      return CompressionUtil.extractUncompressedBuffer(compressedBuffer);\n+    }\n+\n+    ArrowBuf decompressedBuffer = doDecompress(allocator, compressedBuffer);\n+    compressedBuffer.close();\n+    return decompressedBuffer;\n+  }\n+\n+  protected void writeUncompressedLength(ArrowBuf compressedBuffer, long uncompressedLength) {\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      uncompressedLength = Long.reverseBytes(uncompressedLength);\n+    }\n+    // first 8 bytes reserved for uncompressed length, according to the specification\n+    compressedBuffer.setLong(0, uncompressedLength);\n+  }\n+\n+  protected long readUncompressedLength(ArrowBuf compressedBuffer) {\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+    return decompressedLength;\n+  }\n+\n+  /**\n+   * The method that actually performs the data compression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n+   */\n+  protected abstract ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer);\n+\n+  /**\n+   * The method that actually performs the data decompression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n\nReview comment:\n       The default allocation policy is to round the requested size to the next power of 2. \r\n   For example, if we ask for a 10MB buffer, the actual buffer size should be 16MB. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-25T06:14:41.387+0000",
                    "updated": "2021-03-25T06:14:41.387+0000",
                    "started": "2021-03-25T06:14:41.386+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "571665",
                    "issueId": "13362913"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362913/worklog/571666",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #9769:\nURL: https://github.com/apache/arrow/pull/9769#discussion_r601086944\n\n\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/compression/AbstractCompressionCodec.java\n##########\n@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.compression;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.util.MemoryUtil;\n+import org.apache.arrow.util.Preconditions;\n+\n+/**\n+ * The base class for concrete compression codecs, providing\n+ * common logic for all compression codecs.\n+ */\n+public abstract class AbstractCompressionCodec implements CompressionCodec {\n+\n+  @Override\n+  public ArrowBuf compress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n+    Preconditions.checkArgument(uncompressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The uncompressed buffer size exceeds the integer limit\");\n+\n+    if (uncompressedBuffer.writerIndex() == 0L) {\n+      // shortcut for empty buffer\n+      ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      compressedBuffer.setLong(0, 0);\n+      compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      uncompressedBuffer.close();\n+      return compressedBuffer;\n+    }\n+\n+    ArrowBuf compressedBuffer = doCompress(allocator, uncompressedBuffer);\n+    long compressedLength = compressedBuffer.writerIndex() - CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH;\n+    long uncompressedLength = uncompressedBuffer.writerIndex();\n+\n+    if (compressedLength > uncompressedLength) {\n+      // compressed buffer is larger, send the raw buffer\n+      compressedBuffer.close();\n+      compressedBuffer = CompressionUtil.packageRawBuffer(allocator, uncompressedBuffer);\n+    } else {\n+      writeUncompressedLength(compressedBuffer, uncompressedLength);\n+    }\n+\n+    uncompressedBuffer.close();\n+    return compressedBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf decompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The compressed buffer size exceeds the integer limit\");\n+\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() >= CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH,\n+        \"Not enough data to decompress.\");\n+\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+\n+    if (decompressedLength == 0L) {\n+      // shortcut for empty buffer\n+      compressedBuffer.close();\n+      return allocator.getEmpty();\n+    }\n+\n+    if (decompressedLength == CompressionUtil.NO_COMPRESSION_LENGTH) {\n+      // no compression\n+      return CompressionUtil.extractUncompressedBuffer(compressedBuffer);\n+    }\n+\n+    ArrowBuf decompressedBuffer = doDecompress(allocator, compressedBuffer);\n+    compressedBuffer.close();\n+    return decompressedBuffer;\n+  }\n+\n+  protected void writeUncompressedLength(ArrowBuf compressedBuffer, long uncompressedLength) {\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      uncompressedLength = Long.reverseBytes(uncompressedLength);\n+    }\n+    // first 8 bytes reserved for uncompressed length, according to the specification\n+    compressedBuffer.setLong(0, uncompressedLength);\n+  }\n+\n+  protected long readUncompressedLength(ArrowBuf compressedBuffer) {\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+    return decompressedLength;\n+  }\n+\n+  /**\n+   * The method that actually performs the data compression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n+   */\n+  protected abstract ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer);\n+\n+  /**\n+   * The method that actually performs the data decompression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n\nReview comment:\n       but isn't that capacity and not actual size?  I don't think there is much of choice for consumers anyways since we are providing them with the BufferAllocator which has its policy fixed?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-25T06:16:16.496+0000",
                    "updated": "2021-03-25T06:16:16.496+0000",
                    "started": "2021-03-25T06:16:16.496+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "571666",
                    "issueId": "13362913"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362913/worklog/571667",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on a change in pull request #9769:\nURL: https://github.com/apache/arrow/pull/9769#discussion_r601093101\n\n\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/compression/AbstractCompressionCodec.java\n##########\n@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.compression;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.util.MemoryUtil;\n+import org.apache.arrow.util.Preconditions;\n+\n+/**\n+ * The base class for concrete compression codecs, providing\n+ * common logic for all compression codecs.\n+ */\n+public abstract class AbstractCompressionCodec implements CompressionCodec {\n+\n+  @Override\n+  public ArrowBuf compress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n+    Preconditions.checkArgument(uncompressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The uncompressed buffer size exceeds the integer limit\");\n+\n+    if (uncompressedBuffer.writerIndex() == 0L) {\n+      // shortcut for empty buffer\n+      ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      compressedBuffer.setLong(0, 0);\n+      compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      uncompressedBuffer.close();\n+      return compressedBuffer;\n+    }\n+\n+    ArrowBuf compressedBuffer = doCompress(allocator, uncompressedBuffer);\n+    long compressedLength = compressedBuffer.writerIndex() - CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH;\n+    long uncompressedLength = uncompressedBuffer.writerIndex();\n+\n+    if (compressedLength > uncompressedLength) {\n+      // compressed buffer is larger, send the raw buffer\n+      compressedBuffer.close();\n+      compressedBuffer = CompressionUtil.packageRawBuffer(allocator, uncompressedBuffer);\n+    } else {\n+      writeUncompressedLength(compressedBuffer, uncompressedLength);\n+    }\n+\n+    uncompressedBuffer.close();\n+    return compressedBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf decompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The compressed buffer size exceeds the integer limit\");\n+\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() >= CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH,\n+        \"Not enough data to decompress.\");\n+\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+\n+    if (decompressedLength == 0L) {\n+      // shortcut for empty buffer\n+      compressedBuffer.close();\n+      return allocator.getEmpty();\n+    }\n+\n+    if (decompressedLength == CompressionUtil.NO_COMPRESSION_LENGTH) {\n+      // no compression\n+      return CompressionUtil.extractUncompressedBuffer(compressedBuffer);\n+    }\n+\n+    ArrowBuf decompressedBuffer = doDecompress(allocator, compressedBuffer);\n+    compressedBuffer.close();\n+    return decompressedBuffer;\n+  }\n+\n+  protected void writeUncompressedLength(ArrowBuf compressedBuffer, long uncompressedLength) {\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      uncompressedLength = Long.reverseBytes(uncompressedLength);\n+    }\n+    // first 8 bytes reserved for uncompressed length, according to the specification\n+    compressedBuffer.setLong(0, uncompressedLength);\n+  }\n+\n+  protected long readUncompressedLength(ArrowBuf compressedBuffer) {\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+    return decompressedLength;\n+  }\n+\n+  /**\n+   * The method that actually performs the data compression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n+   */\n+  protected abstract ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer);\n+\n+  /**\n+   * The method that actually performs the data decompression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n\nReview comment:\n       Right. It is capacity. \r\n   So we can use the `writerIndex` to denote the `actual size`. Does it sound good?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-25T06:23:25.702+0000",
                    "updated": "2021-03-25T06:23:25.702+0000",
                    "started": "2021-03-25T06:23:25.702+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "571667",
                    "issueId": "13362913"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362913/worklog/571678",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #9769:\nURL: https://github.com/apache/arrow/pull/9769#discussion_r601110118\n\n\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/compression/AbstractCompressionCodec.java\n##########\n@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.compression;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.util.MemoryUtil;\n+import org.apache.arrow.util.Preconditions;\n+\n+/**\n+ * The base class for concrete compression codecs, providing\n+ * common logic for all compression codecs.\n+ */\n+public abstract class AbstractCompressionCodec implements CompressionCodec {\n+\n+  @Override\n+  public ArrowBuf compress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n+    Preconditions.checkArgument(uncompressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The uncompressed buffer size exceeds the integer limit\");\n+\n+    if (uncompressedBuffer.writerIndex() == 0L) {\n+      // shortcut for empty buffer\n+      ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      compressedBuffer.setLong(0, 0);\n+      compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      uncompressedBuffer.close();\n+      return compressedBuffer;\n+    }\n+\n+    ArrowBuf compressedBuffer = doCompress(allocator, uncompressedBuffer);\n+    long compressedLength = compressedBuffer.writerIndex() - CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH;\n+    long uncompressedLength = uncompressedBuffer.writerIndex();\n+\n+    if (compressedLength > uncompressedLength) {\n+      // compressed buffer is larger, send the raw buffer\n+      compressedBuffer.close();\n+      compressedBuffer = CompressionUtil.packageRawBuffer(allocator, uncompressedBuffer);\n+    } else {\n+      writeUncompressedLength(compressedBuffer, uncompressedLength);\n+    }\n+\n+    uncompressedBuffer.close();\n+    return compressedBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf decompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The compressed buffer size exceeds the integer limit\");\n+\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() >= CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH,\n+        \"Not enough data to decompress.\");\n+\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+\n+    if (decompressedLength == 0L) {\n+      // shortcut for empty buffer\n+      compressedBuffer.close();\n+      return allocator.getEmpty();\n+    }\n+\n+    if (decompressedLength == CompressionUtil.NO_COMPRESSION_LENGTH) {\n+      // no compression\n+      return CompressionUtil.extractUncompressedBuffer(compressedBuffer);\n+    }\n+\n+    ArrowBuf decompressedBuffer = doDecompress(allocator, compressedBuffer);\n+    compressedBuffer.close();\n+    return decompressedBuffer;\n+  }\n+\n+  protected void writeUncompressedLength(ArrowBuf compressedBuffer, long uncompressedLength) {\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      uncompressedLength = Long.reverseBytes(uncompressedLength);\n+    }\n+    // first 8 bytes reserved for uncompressed length, according to the specification\n+    compressedBuffer.setLong(0, uncompressedLength);\n+  }\n+\n+  protected long readUncompressedLength(ArrowBuf compressedBuffer) {\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+    return decompressedLength;\n+  }\n+\n+  /**\n+   * The method that actually performs the data compression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n+   */\n+  protected abstract ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer);\n+\n+  /**\n+   * The method that actually performs the data decompression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n\nReview comment:\n       I would like to try to avoid using writerIndex if possible.\r\n   \r\n   \r\n   What I was thinking originally, is that a new ArrowBuf with capacity equal to the decompressed size is passed in.  So implementations can simply reference buffer size to know uncompressed size, and can allocate additional buffers if needed for scratch. writerIndex would be zero (and ideally would not be touched by the implementations).  \r\n   \r\n   At least looking at the zstd and lz4 c apis, it looks like both support this type of contract (extra output buffer padding doesn't seem necessary).  \r\n   \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-25T06:48:51.896+0000",
                    "updated": "2021-03-25T06:48:51.896+0000",
                    "started": "2021-03-25T06:48:51.896+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "571678",
                    "issueId": "13362913"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362913/worklog/571683",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on a change in pull request #9769:\nURL: https://github.com/apache/arrow/pull/9769#discussion_r601125833\n\n\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/compression/AbstractCompressionCodec.java\n##########\n@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.compression;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.util.MemoryUtil;\n+import org.apache.arrow.util.Preconditions;\n+\n+/**\n+ * The base class for concrete compression codecs, providing\n+ * common logic for all compression codecs.\n+ */\n+public abstract class AbstractCompressionCodec implements CompressionCodec {\n+\n+  @Override\n+  public ArrowBuf compress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n+    Preconditions.checkArgument(uncompressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The uncompressed buffer size exceeds the integer limit\");\n+\n+    if (uncompressedBuffer.writerIndex() == 0L) {\n+      // shortcut for empty buffer\n+      ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      compressedBuffer.setLong(0, 0);\n+      compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      uncompressedBuffer.close();\n+      return compressedBuffer;\n+    }\n+\n+    ArrowBuf compressedBuffer = doCompress(allocator, uncompressedBuffer);\n+    long compressedLength = compressedBuffer.writerIndex() - CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH;\n+    long uncompressedLength = uncompressedBuffer.writerIndex();\n+\n+    if (compressedLength > uncompressedLength) {\n+      // compressed buffer is larger, send the raw buffer\n+      compressedBuffer.close();\n+      compressedBuffer = CompressionUtil.packageRawBuffer(allocator, uncompressedBuffer);\n+    } else {\n+      writeUncompressedLength(compressedBuffer, uncompressedLength);\n+    }\n+\n+    uncompressedBuffer.close();\n+    return compressedBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf decompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The compressed buffer size exceeds the integer limit\");\n+\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() >= CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH,\n+        \"Not enough data to decompress.\");\n+\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+\n+    if (decompressedLength == 0L) {\n+      // shortcut for empty buffer\n+      compressedBuffer.close();\n+      return allocator.getEmpty();\n+    }\n+\n+    if (decompressedLength == CompressionUtil.NO_COMPRESSION_LENGTH) {\n+      // no compression\n+      return CompressionUtil.extractUncompressedBuffer(compressedBuffer);\n+    }\n+\n+    ArrowBuf decompressedBuffer = doDecompress(allocator, compressedBuffer);\n+    compressedBuffer.close();\n+    return decompressedBuffer;\n+  }\n+\n+  protected void writeUncompressedLength(ArrowBuf compressedBuffer, long uncompressedLength) {\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      uncompressedLength = Long.reverseBytes(uncompressedLength);\n+    }\n+    // first 8 bytes reserved for uncompressed length, according to the specification\n+    compressedBuffer.setLong(0, uncompressedLength);\n+  }\n+\n+  protected long readUncompressedLength(ArrowBuf compressedBuffer) {\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+    return decompressedLength;\n+  }\n+\n+  /**\n+   * The method that actually performs the data compression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n+   */\n+  protected abstract ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer);\n+\n+  /**\n+   * The method that actually performs the data decompression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n\nReview comment:\n       Agreed with your points about `writerIndex`.\r\n   Do you have any suggestions concerning this API?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-25T07:07:54.377+0000",
                    "updated": "2021-03-25T07:07:54.377+0000",
                    "started": "2021-03-25T07:07:54.377+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "571683",
                    "issueId": "13362913"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362913/worklog/572002",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #9769:\nURL: https://github.com/apache/arrow/pull/9769#discussion_r601675254\n\n\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/compression/AbstractCompressionCodec.java\n##########\n@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.compression;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.util.MemoryUtil;\n+import org.apache.arrow.util.Preconditions;\n+\n+/**\n+ * The base class for concrete compression codecs, providing\n+ * common logic for all compression codecs.\n+ */\n+public abstract class AbstractCompressionCodec implements CompressionCodec {\n+\n+  @Override\n+  public ArrowBuf compress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n+    Preconditions.checkArgument(uncompressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The uncompressed buffer size exceeds the integer limit\");\n+\n+    if (uncompressedBuffer.writerIndex() == 0L) {\n+      // shortcut for empty buffer\n+      ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      compressedBuffer.setLong(0, 0);\n+      compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      uncompressedBuffer.close();\n+      return compressedBuffer;\n+    }\n+\n+    ArrowBuf compressedBuffer = doCompress(allocator, uncompressedBuffer);\n+    long compressedLength = compressedBuffer.writerIndex() - CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH;\n+    long uncompressedLength = uncompressedBuffer.writerIndex();\n+\n+    if (compressedLength > uncompressedLength) {\n+      // compressed buffer is larger, send the raw buffer\n+      compressedBuffer.close();\n+      compressedBuffer = CompressionUtil.packageRawBuffer(allocator, uncompressedBuffer);\n+    } else {\n+      writeUncompressedLength(compressedBuffer, uncompressedLength);\n+    }\n+\n+    uncompressedBuffer.close();\n+    return compressedBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf decompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The compressed buffer size exceeds the integer limit\");\n+\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() >= CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH,\n+        \"Not enough data to decompress.\");\n+\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+\n+    if (decompressedLength == 0L) {\n+      // shortcut for empty buffer\n+      compressedBuffer.close();\n+      return allocator.getEmpty();\n+    }\n+\n+    if (decompressedLength == CompressionUtil.NO_COMPRESSION_LENGTH) {\n+      // no compression\n+      return CompressionUtil.extractUncompressedBuffer(compressedBuffer);\n+    }\n+\n+    ArrowBuf decompressedBuffer = doDecompress(allocator, compressedBuffer);\n+    compressedBuffer.close();\n+    return decompressedBuffer;\n+  }\n+\n+  protected void writeUncompressedLength(ArrowBuf compressedBuffer, long uncompressedLength) {\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      uncompressedLength = Long.reverseBytes(uncompressedLength);\n+    }\n+    // first 8 bytes reserved for uncompressed length, according to the specification\n+    compressedBuffer.setLong(0, uncompressedLength);\n+  }\n+\n+  protected long readUncompressedLength(ArrowBuf compressedBuffer) {\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+    return decompressedLength;\n+  }\n+\n+  /**\n+   * The method that actually performs the data compression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n+   */\n+  protected abstract ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer);\n+\n+  /**\n+   * The method that actually performs the data decompression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n\nReview comment:\n       I think so, would you mind if I push a commit to this PR? I'll try to make the changes this evening.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-25T16:59:15.540+0000",
                    "updated": "2021-03-25T16:59:15.540+0000",
                    "started": "2021-03-25T16:59:15.540+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "572002",
                    "issueId": "13362913"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362913/worklog/572418",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on a change in pull request #9769:\nURL: https://github.com/apache/arrow/pull/9769#discussion_r601964592\n\n\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/compression/AbstractCompressionCodec.java\n##########\n@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.compression;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.util.MemoryUtil;\n+import org.apache.arrow.util.Preconditions;\n+\n+/**\n+ * The base class for concrete compression codecs, providing\n+ * common logic for all compression codecs.\n+ */\n+public abstract class AbstractCompressionCodec implements CompressionCodec {\n+\n+  @Override\n+  public ArrowBuf compress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n+    Preconditions.checkArgument(uncompressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The uncompressed buffer size exceeds the integer limit\");\n+\n+    if (uncompressedBuffer.writerIndex() == 0L) {\n+      // shortcut for empty buffer\n+      ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      compressedBuffer.setLong(0, 0);\n+      compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      uncompressedBuffer.close();\n+      return compressedBuffer;\n+    }\n+\n+    ArrowBuf compressedBuffer = doCompress(allocator, uncompressedBuffer);\n+    long compressedLength = compressedBuffer.writerIndex() - CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH;\n+    long uncompressedLength = uncompressedBuffer.writerIndex();\n+\n+    if (compressedLength > uncompressedLength) {\n+      // compressed buffer is larger, send the raw buffer\n+      compressedBuffer.close();\n+      compressedBuffer = CompressionUtil.packageRawBuffer(allocator, uncompressedBuffer);\n+    } else {\n+      writeUncompressedLength(compressedBuffer, uncompressedLength);\n+    }\n+\n+    uncompressedBuffer.close();\n+    return compressedBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf decompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The compressed buffer size exceeds the integer limit\");\n+\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() >= CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH,\n+        \"Not enough data to decompress.\");\n+\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+\n+    if (decompressedLength == 0L) {\n+      // shortcut for empty buffer\n+      compressedBuffer.close();\n+      return allocator.getEmpty();\n+    }\n+\n+    if (decompressedLength == CompressionUtil.NO_COMPRESSION_LENGTH) {\n+      // no compression\n+      return CompressionUtil.extractUncompressedBuffer(compressedBuffer);\n+    }\n+\n+    ArrowBuf decompressedBuffer = doDecompress(allocator, compressedBuffer);\n+    compressedBuffer.close();\n+    return decompressedBuffer;\n+  }\n+\n+  protected void writeUncompressedLength(ArrowBuf compressedBuffer, long uncompressedLength) {\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      uncompressedLength = Long.reverseBytes(uncompressedLength);\n+    }\n+    // first 8 bytes reserved for uncompressed length, according to the specification\n+    compressedBuffer.setLong(0, uncompressedLength);\n+  }\n+\n+  protected long readUncompressedLength(ArrowBuf compressedBuffer) {\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+    return decompressedLength;\n+  }\n+\n+  /**\n+   * The method that actually performs the data compression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n+   */\n+  protected abstract ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer);\n+\n+  /**\n+   * The method that actually performs the data decompression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n\nReview comment:\n       Of course not. Please go ahead\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-26T02:06:23.226+0000",
                    "updated": "2021-03-26T02:06:23.226+0000",
                    "started": "2021-03-26T02:06:23.226+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "572418",
                    "issueId": "13362913"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362913/worklog/572861",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #9769:\nURL: https://github.com/apache/arrow/pull/9769#discussion_r602575075\n\n\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/compression/AbstractCompressionCodec.java\n##########\n@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.compression;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.util.MemoryUtil;\n+import org.apache.arrow.util.Preconditions;\n+\n+/**\n+ * The base class for concrete compression codecs, providing\n+ * common logic for all compression codecs.\n+ */\n+public abstract class AbstractCompressionCodec implements CompressionCodec {\n+\n+  @Override\n+  public ArrowBuf compress(BufferAllocator allocator, ArrowBuf uncompressedBuffer) {\n+    Preconditions.checkArgument(uncompressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The uncompressed buffer size exceeds the integer limit\");\n+\n+    if (uncompressedBuffer.writerIndex() == 0L) {\n+      // shortcut for empty buffer\n+      ArrowBuf compressedBuffer = allocator.buffer(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      compressedBuffer.setLong(0, 0);\n+      compressedBuffer.writerIndex(CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH);\n+      uncompressedBuffer.close();\n+      return compressedBuffer;\n+    }\n+\n+    ArrowBuf compressedBuffer = doCompress(allocator, uncompressedBuffer);\n+    long compressedLength = compressedBuffer.writerIndex() - CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH;\n+    long uncompressedLength = uncompressedBuffer.writerIndex();\n+\n+    if (compressedLength > uncompressedLength) {\n+      // compressed buffer is larger, send the raw buffer\n+      compressedBuffer.close();\n+      compressedBuffer = CompressionUtil.packageRawBuffer(allocator, uncompressedBuffer);\n+    } else {\n+      writeUncompressedLength(compressedBuffer, uncompressedLength);\n+    }\n+\n+    uncompressedBuffer.close();\n+    return compressedBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf decompress(BufferAllocator allocator, ArrowBuf compressedBuffer) {\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() <= Integer.MAX_VALUE,\n+        \"The compressed buffer size exceeds the integer limit\");\n+\n+    Preconditions.checkArgument(compressedBuffer.writerIndex() >= CompressionUtil.SIZE_OF_UNCOMPRESSED_LENGTH,\n+        \"Not enough data to decompress.\");\n+\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+\n+    if (decompressedLength == 0L) {\n+      // shortcut for empty buffer\n+      compressedBuffer.close();\n+      return allocator.getEmpty();\n+    }\n+\n+    if (decompressedLength == CompressionUtil.NO_COMPRESSION_LENGTH) {\n+      // no compression\n+      return CompressionUtil.extractUncompressedBuffer(compressedBuffer);\n+    }\n+\n+    ArrowBuf decompressedBuffer = doDecompress(allocator, compressedBuffer);\n+    compressedBuffer.close();\n+    return decompressedBuffer;\n+  }\n+\n+  protected void writeUncompressedLength(ArrowBuf compressedBuffer, long uncompressedLength) {\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      uncompressedLength = Long.reverseBytes(uncompressedLength);\n+    }\n+    // first 8 bytes reserved for uncompressed length, according to the specification\n+    compressedBuffer.setLong(0, uncompressedLength);\n+  }\n+\n+  protected long readUncompressedLength(ArrowBuf compressedBuffer) {\n+    long decompressedLength = compressedBuffer.getLong(0);\n+    if (!MemoryUtil.LITTLE_ENDIAN) {\n+      decompressedLength = Long.reverseBytes(decompressedLength);\n+    }\n+    return decompressedLength;\n+  }\n+\n+  /**\n+   * The method that actually performs the data compression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n+   */\n+  protected abstract ArrowBuf doCompress(BufferAllocator allocator, ArrowBuf uncompressedBuffer);\n+\n+  /**\n+   * The method that actually performs the data decompression.\n+   * Please note that the first 8 bytes of the compressed buffer is reserved for the uncompressed size.\n\nReview comment:\n       OK, I played around with this last night and couldn't get something to my satisfaction.  I don't think we should hold up merging this.  \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-26T20:40:51.656+0000",
                    "updated": "2021-03-26T20:40:51.656+0000",
                    "started": "2021-03-26T20:40:51.656+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "572861",
                    "issueId": "13362913"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 12600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@1957c940[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2536c28c[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@52688e03[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@41d90460[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@81ae75f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@6f8ec1a8[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@798052cc[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@7073b398[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2f0c92d6[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@3616851e[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4dfba722[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@20792276[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 12600,
        "customfield_12312520": null,
        "customfield_12312521": "Fri Mar 26 20:42:19 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-03-26T20:42:19.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11899/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2021-03-08T04:53:49.000+0000",
        "updated": "2021-03-26T20:42:19.000+0000",
        "timeoriginalestimate": null,
        "description": "This issue is in response to the discussion in https://github.com/apache/arrow/pull/8949/files#r588049088\r\n\r\nWe want to refactor the compression codec related code into two parts: one for the core compression logic, and the other for Arrow specific logic.\r\n\r\nThis will make it easier to support other compression types. ",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "3.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 12600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Java] Refactor the compression codec implementation into core/Arrow specific parts",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362913/comment/17309714",
                    "id": "17309714",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield",
                        "name": "emkornfield",
                        "key": "emkornfield",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Micah Kornfield",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Issue resolved by pull request 9769\n[https://github.com/apache/arrow/pull/9769]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield",
                        "name": "emkornfield",
                        "key": "emkornfield",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Micah Kornfield",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2021-03-26T20:42:19.363+0000",
                    "updated": "2021-03-26T20:42:19.363+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0oe80:",
        "customfield_12314139": null
    }
}