{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13406868",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406868",
    "key": "ARROW-14356",
    "fields": {
        "parent": {
            "id": "13380618",
            "key": "ARROW-12888",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13380618",
            "fields": {
                "summary": "[C++] Implement arrow::Table::GetSizeInBytes() that returns the sum of all Buffer sizes from the internal ArrayData objects",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                    "description": "The issue is open and ready for the assignee to start work on it.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                    "name": "Open",
                    "id": "1",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                        "id": 2,
                        "key": "new",
                        "colorName": "blue-gray",
                        "name": "To Do"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
                    "id": "1",
                    "description": "A problem which impairs or prevents the functions of the product.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
                    "name": "Bug",
                    "subtask": false,
                    "avatarId": 21133
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12350591",
                "id": "12350591",
                "description": "",
                "name": "7.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-02-03"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 19800,
            "total": 19800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 19800,
            "total": 19800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-14356/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 33,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406868/worklog/669810",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace opened a new pull request #11542:\nURL: https://github.com/apache/arrow/pull/11542\n\n\n   This creates a `byte_ranges` vector function which extracts the buffer ranges referenced by an array.  It's a bit involved because array offsets are in \"# of values\" and that does not always translate cleanly into an offset into the underlying buffers.  The trickiest case is dense unions where we need to traverse the values buffer to figure out the correct array offset for the child arrays.\r\n   \r\n   The one case not handled by this PR is dictionary arrays.  A sliced array may only reference a portion of the dictionary but since that referenced portion need not even be contiguous it would be too expensive to figure out.\r\n   \r\n   Pruning of duplicate ranges will be handled in ARROW-14357\r\n   \r\n   Once this is in I plan to wrap it with another utility function to sum up the range lengths (the only reason I'm returning ranges is so that I can later prune duplicate ranges).  This function will be complementary to (i.e. will not replace) the naive function TotalBufferSize added in #11441 .  The two functions will provide two possible ways of measuring the size of an element.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-10-25T21:37:53.565+0000",
                    "updated": "2021-10-25T21:37:53.565+0000",
                    "started": "2021-10-25T21:37:53.565+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "669810",
                    "issueId": "13406868"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406868/worklog/669811",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #11542:\nURL: https://github.com/apache/arrow/pull/11542#issuecomment-951352464\n\n\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-10-25T21:38:18.627+0000",
                    "updated": "2021-10-25T21:38:18.627+0000",
                    "started": "2021-10-25T21:38:18.627+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "669811",
                    "issueId": "13406868"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406868/worklog/669836",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "edponce commented on a change in pull request #11542:\nURL: https://github.com/apache/arrow/pull/11542#discussion_r736019566\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_buffer.cc\n##########\n@@ -0,0 +1,345 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <memory>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/array/builder_primitive.h\"\n+#include \"arrow/array/concatenate.h\"\n+#include \"arrow/buffer.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/function.h\"\n+#include \"arrow/compute/kernel.h\"\n+#include \"arrow/compute/registry.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/bit_util.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+struct GetByteRangesArray {\n+  const std::shared_ptr<ArrayData>& input;\n+  int64_t offset;\n+  int64_t length;\n+  UInt64Builder* range_starts;\n+  UInt64Builder* range_offsets;\n+  UInt64Builder* range_lengths;\n+\n+  Status VisitBitmap(const std::shared_ptr<Buffer>& buffer) {\n+    if (buffer) {\n+      uint64_t data_start = reinterpret_cast<uint64_t>(buffer->data());\n+      RETURN_NOT_OK(range_starts->Append(data_start));\n+      RETURN_NOT_OK(range_offsets->Append(BitUtil::RoundDown(offset, 8) / 8));\n+      RETURN_NOT_OK(range_lengths->Append(BitUtil::CoveringBytes(offset, length)));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status VisitFixedWidthArray(const Buffer& buffer, const FixedWidthType& type) {\n+    uint64_t data_start = reinterpret_cast<uint64_t>(buffer.data());\n+    uint64_t offset_bits = offset * type.bit_width();\n+    uint64_t offset_bytes = BitUtil::RoundDown(offset_bits, 8) / 8;\n+    uint64_t end_byte =\n+        BitUtil::RoundUp(offset_bits + (length * type.bit_width()), 8) / 8;\n+    uint64_t length_bytes = (end_byte - offset_bytes);\n+    RETURN_NOT_OK(range_starts->Append(data_start));\n+    RETURN_NOT_OK(range_offsets->Append(offset_bytes));\n+    return range_lengths->Append(length_bytes);\n+  }\n+\n+  Status Visit(const FixedWidthType& type) {\n+    static_assert(sizeof(uint8_t*) <= sizeof(uint64_t),\n+                  \"Undefined behavior if pointer larger than uint64_t\");\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+    RETURN_NOT_OK(VisitFixedWidthArray(*input->buffers[1], type));\n+    if (input->dictionary) {\n+      // This is slightly imprecise because we always assume the entire dictionary is\n+      // referenced.  If this array has an offset it may only be referencing a portion of\n+      // the dictionary\n+      GetByteRangesArray dict_visitor{input->dictionary,\n+                                      input->dictionary->offset,\n+                                      input->dictionary->length,\n+                                      range_starts,\n+                                      range_offsets,\n+                                      range_lengths};\n+      return VisitTypeInline(*input->dictionary->type, &dict_visitor);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const NullType& type) { return Status::OK(); }\n+\n+  template <typename BaseBinaryType>\n+  Status VisitBaseBinary(const BaseBinaryType& type) {\n+    using offset_type = typename BaseBinaryType::offset_type;\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+\n+    const Buffer& offsets_buffer = *input->buffers[1];\n+    RETURN_NOT_OK(\n+        range_starts->Append(reinterpret_cast<uint64_t>(offsets_buffer.data())));\n+    RETURN_NOT_OK(range_offsets->Append(sizeof(offset_type) * offset));\n+    RETURN_NOT_OK(range_lengths->Append(sizeof(offset_type) * length));\n+\n+    const offset_type* offsets = input->GetValues<offset_type>(1, offset);\n+    const Buffer& values = *input->buffers[2];\n+    offset_type start = offsets[0];\n+    offset_type end = offsets[length];\n+    RETURN_NOT_OK(range_starts->Append(reinterpret_cast<uint64_t>(values.data())));\n+    RETURN_NOT_OK(range_offsets->Append(static_cast<uint64_t>(start)));\n+    return range_lengths->Append(static_cast<uint64_t>(end - start));\n+  }\n+\n+  Status Visit(const BinaryType& type) { return VisitBaseBinary(type); }\n+\n+  Status Visit(const LargeBinaryType& type) { return VisitBaseBinary(type); }\n+\n+  template <typename BaseListType>\n+  Status VisitBaseList(const BaseListType& type) {\n+    using offset_type = typename BaseListType::offset_type;\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+\n+    const Buffer& offsets_buffer = *input->buffers[1];\n+    RETURN_NOT_OK(\n+        range_starts->Append(reinterpret_cast<uint64_t>(offsets_buffer.data())));\n+    RETURN_NOT_OK(range_offsets->Append(sizeof(offset_type) * offset));\n+    RETURN_NOT_OK(range_lengths->Append(sizeof(offset_type) * length));\n+\n+    const offset_type* offsets = input->GetValues<offset_type>(1, offset);\n+    int64_t start = static_cast<int64_t>(offsets[0]);\n+    int64_t end = static_cast<int64_t>(offsets[length]);\n+    GetByteRangesArray child{input->child_data[0], start,         end - start,\n+                             range_starts,         range_offsets, range_lengths};\n+    return VisitTypeInline(*type.value_type(), &child);\n+  }\n+\n+  Status Visit(const ListType& type) { return VisitBaseList(type); }\n+\n+  Status Visit(const LargeListType& type) { return VisitBaseList(type); }\n+\n+  Status Visit(const FixedSizeListType& type) {\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+    GetByteRangesArray child{input->child_data[0],\n+                             offset * type.list_size(),\n+                             length * type.list_size(),\n+                             range_starts,\n+                             range_offsets,\n+                             range_lengths};\n+    return VisitTypeInline(*type.value_type(), &child);\n+  }\n+\n+  Status Visit(const StructType& type) {\n+    for (int i = 0; i < type.num_fields(); i++) {\n+      GetByteRangesArray child{input->child_data[i],\n+                               offset + input->child_data[i]->offset,\n+                               length,\n+                               range_starts,\n+                               range_offsets,\n+                               range_lengths};\n+      RETURN_NOT_OK(VisitTypeInline(*type.field(i)->type(), &child));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const DenseUnionType& type) {\n+    // Skip validity map for DenseUnionType\n+    // Types buffer is always int8\n+    RETURN_NOT_OK(VisitFixedWidthArray(\n+        *input->buffers[1], *std::dynamic_pointer_cast<FixedWidthType>(int8())));\n+    // Offsets buffer is always int32\n+    RETURN_NOT_OK(VisitFixedWidthArray(\n+        *input->buffers[2], *std::dynamic_pointer_cast<FixedWidthType>(int32())));\n+\n+    // We have to loop through the types buffer to figure out the correct\n+    // offset / length being referenced in the child arrays\n+    std::array<std::size_t, UnionType::kMaxTypeCode> type_code_index_lookup;\n+    for (std::size_t i = 0; i < type.type_codes().size(); i++) {\n+      type_code_index_lookup[static_cast<std::size_t>(type.type_codes()[i])] = i;\n+    }\n+    std::vector<int64_t> lengths_per_type(type.type_codes().size());\n+    std::vector<int64_t> offsets_per_type(type.type_codes().size());\n+    const int8_t* type_codes = input->GetValues<int8_t>(1, 0);\n+    for (const int8_t* it = type_codes; it != type_codes + offset; it++) {\n+      offsets_per_type[type_code_index_lookup[static_cast<std::size_t>(*it)]]++;\n+    }\n+    for (const int8_t* it = type_codes + offset; it != type_codes + offset + length;\n+         it++) {\n+      lengths_per_type[type_code_index_lookup[static_cast<std::size_t>(*it)]]++;\n+    }\n+\n+    for (int i = 0; i < type.num_fields(); i++) {\n+      GetByteRangesArray child{\n+          input->child_data[i], offsets_per_type[i] + input->child_data[i]->offset,\n+          lengths_per_type[i],  range_starts,\n+          range_offsets,        range_lengths};\n+      RETURN_NOT_OK(VisitTypeInline(*type.field(i)->type(), &child));\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const SparseUnionType& type) {\n+    // Skip validity map for SparseUnionType\n+    // Types buffer is always int8\n+    RETURN_NOT_OK(VisitFixedWidthArray(\n+        *input->buffers[1], *std::dynamic_pointer_cast<FixedWidthType>(int8())));\n+\n+    for (int i = 0; i < type.num_fields(); i++) {\n+      GetByteRangesArray child{input->child_data[i],\n+                               offset + input->child_data[i]->offset,\n+                               length,\n+                               range_starts,\n+                               range_offsets,\n+                               range_lengths};\n+      RETURN_NOT_OK(VisitTypeInline(*type.field(i)->type(), &child));\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const ExtensionType& extension_type) {\n+    GetByteRangesArray storage{input,        offset,        length,\n+                               range_starts, range_offsets, range_lengths};\n+    return VisitTypeInline(*extension_type.storage_type(), &storage);\n+  }\n+\n+  Status Visit(const DataType& type) {\n+    return Status::TypeError(\"Extracting byte ranges not supported for type \",\n+                             type.ToString());\n+  }\n+\n+  static std::shared_ptr<DataType> RangesType() {\n+    return struct_(\n+        {field(\"start\", uint64()), field(\"offset\", uint64()), field(\"length\", uint64())});\n+  }\n+\n+  Result<std::shared_ptr<Array>> MakeRanges() {\n+    std::shared_ptr<Array> range_starts_arr, range_offsets_arr, range_lengths_arr;\n+    RETURN_NOT_OK(range_starts->Finish(&range_starts_arr));\n+    RETURN_NOT_OK(range_offsets->Finish(&range_offsets_arr));\n+    RETURN_NOT_OK(range_lengths->Finish(&range_lengths_arr));\n+    return StructArray::Make(\n+        {range_starts_arr, range_offsets_arr, range_lengths_arr},\n+        {field(\"start\", uint64()), field(\"offset\", uint64()), field(\"length\", uint64())});\n+  }\n+\n+  static Result<std::shared_ptr<Array>> Exec(const std::shared_ptr<ArrayData>& input) {\n+    UInt64Builder range_starts, range_offsets, range_lengths;\n+    GetByteRangesArray self{input,         input->offset,  input->length,\n+                            &range_starts, &range_offsets, &range_lengths};\n+    RETURN_NOT_OK(VisitTypeInline(*input->type, &self));\n+    return self.MakeRanges();\n+  }\n+};\n+\n+const FunctionDoc byte_ranges_doc(\n+    \"Returns an array of byte ranges referenced by the input\",\n+    (R\"(The output is a StructArray {\"start\": int64, \"offset\": int64, \"length\":)\"\n+     \" int64 } where each item represents a range of memory addressed by buffers in\"\n\nReview comment:\n       Is the comment correct between break lines? It seems to have a misplaced parenthesis and extra space before ending curly bracket.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-10-25T22:52:21.485+0000",
                    "updated": "2021-10-25T22:52:21.485+0000",
                    "started": "2021-10-25T22:52:21.485+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "669836",
                    "issueId": "13406868"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406868/worklog/670026",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #11542:\nURL: https://github.com/apache/arrow/pull/11542#discussion_r736424211\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_buffer.cc\n##########\n@@ -0,0 +1,345 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <memory>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/array/builder_primitive.h\"\n+#include \"arrow/array/concatenate.h\"\n+#include \"arrow/buffer.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/function.h\"\n+#include \"arrow/compute/kernel.h\"\n+#include \"arrow/compute/registry.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/bit_util.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+struct GetByteRangesArray {\n+  const std::shared_ptr<ArrayData>& input;\n+  int64_t offset;\n+  int64_t length;\n+  UInt64Builder* range_starts;\n+  UInt64Builder* range_offsets;\n+  UInt64Builder* range_lengths;\n+\n+  Status VisitBitmap(const std::shared_ptr<Buffer>& buffer) {\n+    if (buffer) {\n+      uint64_t data_start = reinterpret_cast<uint64_t>(buffer->data());\n+      RETURN_NOT_OK(range_starts->Append(data_start));\n+      RETURN_NOT_OK(range_offsets->Append(BitUtil::RoundDown(offset, 8) / 8));\n+      RETURN_NOT_OK(range_lengths->Append(BitUtil::CoveringBytes(offset, length)));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status VisitFixedWidthArray(const Buffer& buffer, const FixedWidthType& type) {\n+    uint64_t data_start = reinterpret_cast<uint64_t>(buffer.data());\n+    uint64_t offset_bits = offset * type.bit_width();\n+    uint64_t offset_bytes = BitUtil::RoundDown(offset_bits, 8) / 8;\n+    uint64_t end_byte =\n+        BitUtil::RoundUp(offset_bits + (length * type.bit_width()), 8) / 8;\n+    uint64_t length_bytes = (end_byte - offset_bytes);\n+    RETURN_NOT_OK(range_starts->Append(data_start));\n+    RETURN_NOT_OK(range_offsets->Append(offset_bytes));\n+    return range_lengths->Append(length_bytes);\n+  }\n+\n+  Status Visit(const FixedWidthType& type) {\n+    static_assert(sizeof(uint8_t*) <= sizeof(uint64_t),\n+                  \"Undefined behavior if pointer larger than uint64_t\");\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+    RETURN_NOT_OK(VisitFixedWidthArray(*input->buffers[1], type));\n+    if (input->dictionary) {\n+      // This is slightly imprecise because we always assume the entire dictionary is\n+      // referenced.  If this array has an offset it may only be referencing a portion of\n+      // the dictionary\n+      GetByteRangesArray dict_visitor{input->dictionary,\n+                                      input->dictionary->offset,\n+                                      input->dictionary->length,\n+                                      range_starts,\n+                                      range_offsets,\n+                                      range_lengths};\n+      return VisitTypeInline(*input->dictionary->type, &dict_visitor);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const NullType& type) { return Status::OK(); }\n+\n+  template <typename BaseBinaryType>\n+  Status VisitBaseBinary(const BaseBinaryType& type) {\n+    using offset_type = typename BaseBinaryType::offset_type;\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+\n+    const Buffer& offsets_buffer = *input->buffers[1];\n+    RETURN_NOT_OK(\n+        range_starts->Append(reinterpret_cast<uint64_t>(offsets_buffer.data())));\n+    RETURN_NOT_OK(range_offsets->Append(sizeof(offset_type) * offset));\n+    RETURN_NOT_OK(range_lengths->Append(sizeof(offset_type) * length));\n+\n+    const offset_type* offsets = input->GetValues<offset_type>(1, offset);\n+    const Buffer& values = *input->buffers[2];\n+    offset_type start = offsets[0];\n+    offset_type end = offsets[length];\n+    RETURN_NOT_OK(range_starts->Append(reinterpret_cast<uint64_t>(values.data())));\n+    RETURN_NOT_OK(range_offsets->Append(static_cast<uint64_t>(start)));\n+    return range_lengths->Append(static_cast<uint64_t>(end - start));\n+  }\n+\n+  Status Visit(const BinaryType& type) { return VisitBaseBinary(type); }\n+\n+  Status Visit(const LargeBinaryType& type) { return VisitBaseBinary(type); }\n+\n+  template <typename BaseListType>\n+  Status VisitBaseList(const BaseListType& type) {\n+    using offset_type = typename BaseListType::offset_type;\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+\n+    const Buffer& offsets_buffer = *input->buffers[1];\n+    RETURN_NOT_OK(\n+        range_starts->Append(reinterpret_cast<uint64_t>(offsets_buffer.data())));\n+    RETURN_NOT_OK(range_offsets->Append(sizeof(offset_type) * offset));\n+    RETURN_NOT_OK(range_lengths->Append(sizeof(offset_type) * length));\n+\n+    const offset_type* offsets = input->GetValues<offset_type>(1, offset);\n+    int64_t start = static_cast<int64_t>(offsets[0]);\n+    int64_t end = static_cast<int64_t>(offsets[length]);\n+    GetByteRangesArray child{input->child_data[0], start,         end - start,\n+                             range_starts,         range_offsets, range_lengths};\n+    return VisitTypeInline(*type.value_type(), &child);\n+  }\n+\n+  Status Visit(const ListType& type) { return VisitBaseList(type); }\n+\n+  Status Visit(const LargeListType& type) { return VisitBaseList(type); }\n+\n+  Status Visit(const FixedSizeListType& type) {\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+    GetByteRangesArray child{input->child_data[0],\n+                             offset * type.list_size(),\n+                             length * type.list_size(),\n+                             range_starts,\n+                             range_offsets,\n+                             range_lengths};\n+    return VisitTypeInline(*type.value_type(), &child);\n+  }\n+\n+  Status Visit(const StructType& type) {\n+    for (int i = 0; i < type.num_fields(); i++) {\n+      GetByteRangesArray child{input->child_data[i],\n+                               offset + input->child_data[i]->offset,\n+                               length,\n+                               range_starts,\n+                               range_offsets,\n+                               range_lengths};\n+      RETURN_NOT_OK(VisitTypeInline(*type.field(i)->type(), &child));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const DenseUnionType& type) {\n+    // Skip validity map for DenseUnionType\n+    // Types buffer is always int8\n+    RETURN_NOT_OK(VisitFixedWidthArray(\n+        *input->buffers[1], *std::dynamic_pointer_cast<FixedWidthType>(int8())));\n+    // Offsets buffer is always int32\n+    RETURN_NOT_OK(VisitFixedWidthArray(\n+        *input->buffers[2], *std::dynamic_pointer_cast<FixedWidthType>(int32())));\n+\n+    // We have to loop through the types buffer to figure out the correct\n+    // offset / length being referenced in the child arrays\n+    std::array<std::size_t, UnionType::kMaxTypeCode> type_code_index_lookup;\n+    for (std::size_t i = 0; i < type.type_codes().size(); i++) {\n+      type_code_index_lookup[static_cast<std::size_t>(type.type_codes()[i])] = i;\n+    }\n+    std::vector<int64_t> lengths_per_type(type.type_codes().size());\n+    std::vector<int64_t> offsets_per_type(type.type_codes().size());\n+    const int8_t* type_codes = input->GetValues<int8_t>(1, 0);\n+    for (const int8_t* it = type_codes; it != type_codes + offset; it++) {\n+      offsets_per_type[type_code_index_lookup[static_cast<std::size_t>(*it)]]++;\n+    }\n+    for (const int8_t* it = type_codes + offset; it != type_codes + offset + length;\n+         it++) {\n+      lengths_per_type[type_code_index_lookup[static_cast<std::size_t>(*it)]]++;\n+    }\n+\n+    for (int i = 0; i < type.num_fields(); i++) {\n+      GetByteRangesArray child{\n+          input->child_data[i], offsets_per_type[i] + input->child_data[i]->offset,\n+          lengths_per_type[i],  range_starts,\n+          range_offsets,        range_lengths};\n+      RETURN_NOT_OK(VisitTypeInline(*type.field(i)->type(), &child));\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const SparseUnionType& type) {\n+    // Skip validity map for SparseUnionType\n+    // Types buffer is always int8\n+    RETURN_NOT_OK(VisitFixedWidthArray(\n+        *input->buffers[1], *std::dynamic_pointer_cast<FixedWidthType>(int8())));\n+\n+    for (int i = 0; i < type.num_fields(); i++) {\n+      GetByteRangesArray child{input->child_data[i],\n+                               offset + input->child_data[i]->offset,\n+                               length,\n+                               range_starts,\n+                               range_offsets,\n+                               range_lengths};\n+      RETURN_NOT_OK(VisitTypeInline(*type.field(i)->type(), &child));\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const ExtensionType& extension_type) {\n+    GetByteRangesArray storage{input,        offset,        length,\n+                               range_starts, range_offsets, range_lengths};\n+    return VisitTypeInline(*extension_type.storage_type(), &storage);\n+  }\n+\n+  Status Visit(const DataType& type) {\n+    return Status::TypeError(\"Extracting byte ranges not supported for type \",\n+                             type.ToString());\n+  }\n+\n+  static std::shared_ptr<DataType> RangesType() {\n+    return struct_(\n+        {field(\"start\", uint64()), field(\"offset\", uint64()), field(\"length\", uint64())});\n+  }\n+\n+  Result<std::shared_ptr<Array>> MakeRanges() {\n+    std::shared_ptr<Array> range_starts_arr, range_offsets_arr, range_lengths_arr;\n+    RETURN_NOT_OK(range_starts->Finish(&range_starts_arr));\n+    RETURN_NOT_OK(range_offsets->Finish(&range_offsets_arr));\n+    RETURN_NOT_OK(range_lengths->Finish(&range_lengths_arr));\n+    return StructArray::Make(\n+        {range_starts_arr, range_offsets_arr, range_lengths_arr},\n+        {field(\"start\", uint64()), field(\"offset\", uint64()), field(\"length\", uint64())});\n+  }\n+\n+  static Result<std::shared_ptr<Array>> Exec(const std::shared_ptr<ArrayData>& input) {\n+    UInt64Builder range_starts, range_offsets, range_lengths;\n+    GetByteRangesArray self{input,         input->offset,  input->length,\n+                            &range_starts, &range_offsets, &range_lengths};\n+    RETURN_NOT_OK(VisitTypeInline(*input->type, &self));\n+    return self.MakeRanges();\n+  }\n+};\n+\n+const FunctionDoc byte_ranges_doc(\n+    \"Returns an array of byte ranges referenced by the input\",\n+    (R\"(The output is a StructArray {\"start\": int64, \"offset\": int64, \"length\":)\"\n+     \" int64 } where each item represents a range of memory addressed by buffers in\"\n\nReview comment:\n       The second string is a raw string so that I can use the `\"` without escaping so the parentheses are appropriate I think.  The space before the closing bracket I can fix.  Thanks.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-10-26T11:22:17.599+0000",
                    "updated": "2021-10-26T11:22:17.599+0000",
                    "started": "2021-10-26T11:22:17.599+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "670026",
                    "issueId": "13406868"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406868/worklog/670136",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11542:\nURL: https://github.com/apache/arrow/pull/11542#discussion_r736502630\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_buffer.cc\n##########\n@@ -0,0 +1,345 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <memory>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/array/builder_primitive.h\"\n+#include \"arrow/array/concatenate.h\"\n+#include \"arrow/buffer.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/function.h\"\n+#include \"arrow/compute/kernel.h\"\n+#include \"arrow/compute/registry.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/bit_util.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+struct GetByteRangesArray {\n+  const std::shared_ptr<ArrayData>& input;\n+  int64_t offset;\n+  int64_t length;\n+  UInt64Builder* range_starts;\n+  UInt64Builder* range_offsets;\n+  UInt64Builder* range_lengths;\n+\n+  Status VisitBitmap(const std::shared_ptr<Buffer>& buffer) {\n+    if (buffer) {\n+      uint64_t data_start = reinterpret_cast<uint64_t>(buffer->data());\n+      RETURN_NOT_OK(range_starts->Append(data_start));\n+      RETURN_NOT_OK(range_offsets->Append(BitUtil::RoundDown(offset, 8) / 8));\n+      RETURN_NOT_OK(range_lengths->Append(BitUtil::CoveringBytes(offset, length)));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status VisitFixedWidthArray(const Buffer& buffer, const FixedWidthType& type) {\n+    uint64_t data_start = reinterpret_cast<uint64_t>(buffer.data());\n+    uint64_t offset_bits = offset * type.bit_width();\n+    uint64_t offset_bytes = BitUtil::RoundDown(offset_bits, 8) / 8;\n+    uint64_t end_byte =\n+        BitUtil::RoundUp(offset_bits + (length * type.bit_width()), 8) / 8;\n+    uint64_t length_bytes = (end_byte - offset_bytes);\n+    RETURN_NOT_OK(range_starts->Append(data_start));\n+    RETURN_NOT_OK(range_offsets->Append(offset_bytes));\n+    return range_lengths->Append(length_bytes);\n+  }\n+\n+  Status Visit(const FixedWidthType& type) {\n+    static_assert(sizeof(uint8_t*) <= sizeof(uint64_t),\n+                  \"Undefined behavior if pointer larger than uint64_t\");\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+    RETURN_NOT_OK(VisitFixedWidthArray(*input->buffers[1], type));\n+    if (input->dictionary) {\n+      // This is slightly imprecise because we always assume the entire dictionary is\n\nReview comment:\n       I'm not so sure it's necessarily imprecise, since even if you use only one dictionary element, you would need to copy the dictionary and rewrite the indices in order to truly get rid of the memory. I think it's correct that we always include the entire dictionary.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_buffer.cc\n##########\n@@ -0,0 +1,345 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <memory>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/array/builder_primitive.h\"\n+#include \"arrow/array/concatenate.h\"\n+#include \"arrow/buffer.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/function.h\"\n+#include \"arrow/compute/kernel.h\"\n+#include \"arrow/compute/registry.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/bit_util.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+struct GetByteRangesArray {\n+  const std::shared_ptr<ArrayData>& input;\n+  int64_t offset;\n+  int64_t length;\n+  UInt64Builder* range_starts;\n+  UInt64Builder* range_offsets;\n+  UInt64Builder* range_lengths;\n+\n+  Status VisitBitmap(const std::shared_ptr<Buffer>& buffer) {\n+    if (buffer) {\n+      uint64_t data_start = reinterpret_cast<uint64_t>(buffer->data());\n+      RETURN_NOT_OK(range_starts->Append(data_start));\n+      RETURN_NOT_OK(range_offsets->Append(BitUtil::RoundDown(offset, 8) / 8));\n+      RETURN_NOT_OK(range_lengths->Append(BitUtil::CoveringBytes(offset, length)));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status VisitFixedWidthArray(const Buffer& buffer, const FixedWidthType& type) {\n+    uint64_t data_start = reinterpret_cast<uint64_t>(buffer.data());\n+    uint64_t offset_bits = offset * type.bit_width();\n+    uint64_t offset_bytes = BitUtil::RoundDown(offset_bits, 8) / 8;\n+    uint64_t end_byte =\n+        BitUtil::RoundUp(offset_bits + (length * type.bit_width()), 8) / 8;\n+    uint64_t length_bytes = (end_byte - offset_bytes);\n+    RETURN_NOT_OK(range_starts->Append(data_start));\n+    RETURN_NOT_OK(range_offsets->Append(offset_bytes));\n+    return range_lengths->Append(length_bytes);\n+  }\n+\n+  Status Visit(const FixedWidthType& type) {\n+    static_assert(sizeof(uint8_t*) <= sizeof(uint64_t),\n+                  \"Undefined behavior if pointer larger than uint64_t\");\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+    RETURN_NOT_OK(VisitFixedWidthArray(*input->buffers[1], type));\n+    if (input->dictionary) {\n+      // This is slightly imprecise because we always assume the entire dictionary is\n+      // referenced.  If this array has an offset it may only be referencing a portion of\n+      // the dictionary\n+      GetByteRangesArray dict_visitor{input->dictionary,\n+                                      input->dictionary->offset,\n+                                      input->dictionary->length,\n+                                      range_starts,\n+                                      range_offsets,\n+                                      range_lengths};\n+      return VisitTypeInline(*input->dictionary->type, &dict_visitor);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const NullType& type) { return Status::OK(); }\n+\n+  template <typename BaseBinaryType>\n+  Status VisitBaseBinary(const BaseBinaryType& type) {\n+    using offset_type = typename BaseBinaryType::offset_type;\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+\n+    const Buffer& offsets_buffer = *input->buffers[1];\n+    RETURN_NOT_OK(\n+        range_starts->Append(reinterpret_cast<uint64_t>(offsets_buffer.data())));\n+    RETURN_NOT_OK(range_offsets->Append(sizeof(offset_type) * offset));\n+    RETURN_NOT_OK(range_lengths->Append(sizeof(offset_type) * length));\n+\n+    const offset_type* offsets = input->GetValues<offset_type>(1, offset);\n+    const Buffer& values = *input->buffers[2];\n+    offset_type start = offsets[0];\n+    offset_type end = offsets[length];\n+    RETURN_NOT_OK(range_starts->Append(reinterpret_cast<uint64_t>(values.data())));\n+    RETURN_NOT_OK(range_offsets->Append(static_cast<uint64_t>(start)));\n+    return range_lengths->Append(static_cast<uint64_t>(end - start));\n+  }\n+\n+  Status Visit(const BinaryType& type) { return VisitBaseBinary(type); }\n+\n+  Status Visit(const LargeBinaryType& type) { return VisitBaseBinary(type); }\n+\n+  template <typename BaseListType>\n+  Status VisitBaseList(const BaseListType& type) {\n+    using offset_type = typename BaseListType::offset_type;\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+\n+    const Buffer& offsets_buffer = *input->buffers[1];\n+    RETURN_NOT_OK(\n+        range_starts->Append(reinterpret_cast<uint64_t>(offsets_buffer.data())));\n+    RETURN_NOT_OK(range_offsets->Append(sizeof(offset_type) * offset));\n+    RETURN_NOT_OK(range_lengths->Append(sizeof(offset_type) * length));\n+\n+    const offset_type* offsets = input->GetValues<offset_type>(1, offset);\n+    int64_t start = static_cast<int64_t>(offsets[0]);\n+    int64_t end = static_cast<int64_t>(offsets[length]);\n+    GetByteRangesArray child{input->child_data[0], start,         end - start,\n+                             range_starts,         range_offsets, range_lengths};\n+    return VisitTypeInline(*type.value_type(), &child);\n+  }\n+\n+  Status Visit(const ListType& type) { return VisitBaseList(type); }\n+\n+  Status Visit(const LargeListType& type) { return VisitBaseList(type); }\n+\n+  Status Visit(const FixedSizeListType& type) {\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+    GetByteRangesArray child{input->child_data[0],\n+                             offset * type.list_size(),\n+                             length * type.list_size(),\n+                             range_starts,\n+                             range_offsets,\n+                             range_lengths};\n+    return VisitTypeInline(*type.value_type(), &child);\n+  }\n+\n+  Status Visit(const StructType& type) {\n+    for (int i = 0; i < type.num_fields(); i++) {\n+      GetByteRangesArray child{input->child_data[i],\n+                               offset + input->child_data[i]->offset,\n+                               length,\n+                               range_starts,\n+                               range_offsets,\n+                               range_lengths};\n+      RETURN_NOT_OK(VisitTypeInline(*type.field(i)->type(), &child));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const DenseUnionType& type) {\n+    // Skip validity map for DenseUnionType\n+    // Types buffer is always int8\n+    RETURN_NOT_OK(VisitFixedWidthArray(\n+        *input->buffers[1], *std::dynamic_pointer_cast<FixedWidthType>(int8())));\n+    // Offsets buffer is always int32\n+    RETURN_NOT_OK(VisitFixedWidthArray(\n+        *input->buffers[2], *std::dynamic_pointer_cast<FixedWidthType>(int32())));\n+\n+    // We have to loop through the types buffer to figure out the correct\n+    // offset / length being referenced in the child arrays\n+    std::array<std::size_t, UnionType::kMaxTypeCode> type_code_index_lookup;\n\nReview comment:\n       Isn't this UnionType.child_ids()?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_buffer.cc\n##########\n@@ -0,0 +1,345 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <memory>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/array/builder_primitive.h\"\n+#include \"arrow/array/concatenate.h\"\n+#include \"arrow/buffer.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/function.h\"\n+#include \"arrow/compute/kernel.h\"\n+#include \"arrow/compute/registry.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/bit_util.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+struct GetByteRangesArray {\n+  const std::shared_ptr<ArrayData>& input;\n+  int64_t offset;\n+  int64_t length;\n+  UInt64Builder* range_starts;\n+  UInt64Builder* range_offsets;\n+  UInt64Builder* range_lengths;\n+\n+  Status VisitBitmap(const std::shared_ptr<Buffer>& buffer) {\n+    if (buffer) {\n+      uint64_t data_start = reinterpret_cast<uint64_t>(buffer->data());\n+      RETURN_NOT_OK(range_starts->Append(data_start));\n+      RETURN_NOT_OK(range_offsets->Append(BitUtil::RoundDown(offset, 8) / 8));\n+      RETURN_NOT_OK(range_lengths->Append(BitUtil::CoveringBytes(offset, length)));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status VisitFixedWidthArray(const Buffer& buffer, const FixedWidthType& type) {\n+    uint64_t data_start = reinterpret_cast<uint64_t>(buffer.data());\n+    uint64_t offset_bits = offset * type.bit_width();\n+    uint64_t offset_bytes = BitUtil::RoundDown(offset_bits, 8) / 8;\n+    uint64_t end_byte =\n+        BitUtil::RoundUp(offset_bits + (length * type.bit_width()), 8) / 8;\n+    uint64_t length_bytes = (end_byte - offset_bytes);\n+    RETURN_NOT_OK(range_starts->Append(data_start));\n+    RETURN_NOT_OK(range_offsets->Append(offset_bytes));\n+    return range_lengths->Append(length_bytes);\n+  }\n+\n+  Status Visit(const FixedWidthType& type) {\n+    static_assert(sizeof(uint8_t*) <= sizeof(uint64_t),\n+                  \"Undefined behavior if pointer larger than uint64_t\");\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+    RETURN_NOT_OK(VisitFixedWidthArray(*input->buffers[1], type));\n+    if (input->dictionary) {\n+      // This is slightly imprecise because we always assume the entire dictionary is\n+      // referenced.  If this array has an offset it may only be referencing a portion of\n+      // the dictionary\n+      GetByteRangesArray dict_visitor{input->dictionary,\n+                                      input->dictionary->offset,\n+                                      input->dictionary->length,\n+                                      range_starts,\n+                                      range_offsets,\n+                                      range_lengths};\n+      return VisitTypeInline(*input->dictionary->type, &dict_visitor);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const NullType& type) { return Status::OK(); }\n+\n+  template <typename BaseBinaryType>\n+  Status VisitBaseBinary(const BaseBinaryType& type) {\n+    using offset_type = typename BaseBinaryType::offset_type;\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+\n+    const Buffer& offsets_buffer = *input->buffers[1];\n+    RETURN_NOT_OK(\n+        range_starts->Append(reinterpret_cast<uint64_t>(offsets_buffer.data())));\n+    RETURN_NOT_OK(range_offsets->Append(sizeof(offset_type) * offset));\n+    RETURN_NOT_OK(range_lengths->Append(sizeof(offset_type) * length));\n+\n+    const offset_type* offsets = input->GetValues<offset_type>(1, offset);\n+    const Buffer& values = *input->buffers[2];\n+    offset_type start = offsets[0];\n+    offset_type end = offsets[length];\n+    RETURN_NOT_OK(range_starts->Append(reinterpret_cast<uint64_t>(values.data())));\n+    RETURN_NOT_OK(range_offsets->Append(static_cast<uint64_t>(start)));\n+    return range_lengths->Append(static_cast<uint64_t>(end - start));\n+  }\n+\n+  Status Visit(const BinaryType& type) { return VisitBaseBinary(type); }\n+\n+  Status Visit(const LargeBinaryType& type) { return VisitBaseBinary(type); }\n+\n+  template <typename BaseListType>\n+  Status VisitBaseList(const BaseListType& type) {\n+    using offset_type = typename BaseListType::offset_type;\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+\n+    const Buffer& offsets_buffer = *input->buffers[1];\n+    RETURN_NOT_OK(\n+        range_starts->Append(reinterpret_cast<uint64_t>(offsets_buffer.data())));\n+    RETURN_NOT_OK(range_offsets->Append(sizeof(offset_type) * offset));\n+    RETURN_NOT_OK(range_lengths->Append(sizeof(offset_type) * length));\n+\n+    const offset_type* offsets = input->GetValues<offset_type>(1, offset);\n+    int64_t start = static_cast<int64_t>(offsets[0]);\n+    int64_t end = static_cast<int64_t>(offsets[length]);\n+    GetByteRangesArray child{input->child_data[0], start,         end - start,\n+                             range_starts,         range_offsets, range_lengths};\n+    return VisitTypeInline(*type.value_type(), &child);\n+  }\n+\n+  Status Visit(const ListType& type) { return VisitBaseList(type); }\n+\n+  Status Visit(const LargeListType& type) { return VisitBaseList(type); }\n+\n+  Status Visit(const FixedSizeListType& type) {\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+    GetByteRangesArray child{input->child_data[0],\n+                             offset * type.list_size(),\n+                             length * type.list_size(),\n+                             range_starts,\n+                             range_offsets,\n+                             range_lengths};\n+    return VisitTypeInline(*type.value_type(), &child);\n+  }\n+\n+  Status Visit(const StructType& type) {\n+    for (int i = 0; i < type.num_fields(); i++) {\n+      GetByteRangesArray child{input->child_data[i],\n+                               offset + input->child_data[i]->offset,\n+                               length,\n+                               range_starts,\n+                               range_offsets,\n+                               range_lengths};\n+      RETURN_NOT_OK(VisitTypeInline(*type.field(i)->type(), &child));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const DenseUnionType& type) {\n+    // Skip validity map for DenseUnionType\n+    // Types buffer is always int8\n+    RETURN_NOT_OK(VisitFixedWidthArray(\n+        *input->buffers[1], *std::dynamic_pointer_cast<FixedWidthType>(int8())));\n+    // Offsets buffer is always int32\n+    RETURN_NOT_OK(VisitFixedWidthArray(\n+        *input->buffers[2], *std::dynamic_pointer_cast<FixedWidthType>(int32())));\n+\n+    // We have to loop through the types buffer to figure out the correct\n+    // offset / length being referenced in the child arrays\n+    std::array<std::size_t, UnionType::kMaxTypeCode> type_code_index_lookup;\n+    for (std::size_t i = 0; i < type.type_codes().size(); i++) {\n+      type_code_index_lookup[static_cast<std::size_t>(type.type_codes()[i])] = i;\n+    }\n+    std::vector<int64_t> lengths_per_type(type.type_codes().size());\n+    std::vector<int64_t> offsets_per_type(type.type_codes().size());\n+    const int8_t* type_codes = input->GetValues<int8_t>(1, 0);\n+    for (const int8_t* it = type_codes; it != type_codes + offset; it++) {\n+      offsets_per_type[type_code_index_lookup[static_cast<std::size_t>(*it)]]++;\n+    }\n+    for (const int8_t* it = type_codes + offset; it != type_codes + offset + length;\n+         it++) {\n+      lengths_per_type[type_code_index_lookup[static_cast<std::size_t>(*it)]]++;\n+    }\n+\n+    for (int i = 0; i < type.num_fields(); i++) {\n+      GetByteRangesArray child{\n+          input->child_data[i], offsets_per_type[i] + input->child_data[i]->offset,\n+          lengths_per_type[i],  range_starts,\n+          range_offsets,        range_lengths};\n+      RETURN_NOT_OK(VisitTypeInline(*type.field(i)->type(), &child));\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const SparseUnionType& type) {\n+    // Skip validity map for SparseUnionType\n+    // Types buffer is always int8\n+    RETURN_NOT_OK(VisitFixedWidthArray(\n+        *input->buffers[1], *std::dynamic_pointer_cast<FixedWidthType>(int8())));\n+\n+    for (int i = 0; i < type.num_fields(); i++) {\n+      GetByteRangesArray child{input->child_data[i],\n+                               offset + input->child_data[i]->offset,\n+                               length,\n+                               range_starts,\n+                               range_offsets,\n+                               range_lengths};\n+      RETURN_NOT_OK(VisitTypeInline(*type.field(i)->type(), &child));\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const ExtensionType& extension_type) {\n+    GetByteRangesArray storage{input,        offset,        length,\n+                               range_starts, range_offsets, range_lengths};\n+    return VisitTypeInline(*extension_type.storage_type(), &storage);\n+  }\n+\n+  Status Visit(const DataType& type) {\n+    return Status::TypeError(\"Extracting byte ranges not supported for type \",\n+                             type.ToString());\n+  }\n+\n+  static std::shared_ptr<DataType> RangesType() {\n+    return struct_(\n+        {field(\"start\", uint64()), field(\"offset\", uint64()), field(\"length\", uint64())});\n+  }\n+\n+  Result<std::shared_ptr<Array>> MakeRanges() {\n+    std::shared_ptr<Array> range_starts_arr, range_offsets_arr, range_lengths_arr;\n+    RETURN_NOT_OK(range_starts->Finish(&range_starts_arr));\n+    RETURN_NOT_OK(range_offsets->Finish(&range_offsets_arr));\n+    RETURN_NOT_OK(range_lengths->Finish(&range_lengths_arr));\n+    return StructArray::Make(\n+        {range_starts_arr, range_offsets_arr, range_lengths_arr},\n+        {field(\"start\", uint64()), field(\"offset\", uint64()), field(\"length\", uint64())});\n+  }\n+\n+  static Result<std::shared_ptr<Array>> Exec(const std::shared_ptr<ArrayData>& input) {\n+    UInt64Builder range_starts, range_offsets, range_lengths;\n+    GetByteRangesArray self{input,         input->offset,  input->length,\n+                            &range_starts, &range_offsets, &range_lengths};\n+    RETURN_NOT_OK(VisitTypeInline(*input->type, &self));\n+    return self.MakeRanges();\n+  }\n+};\n+\n+const FunctionDoc byte_ranges_doc(\n+    \"Returns an array of byte ranges referenced by the input\",\n+    (R\"(The output is a StructArray {\"start\": int64, \"offset\": int64, \"length\":)\"\n+     \" int64} where each item represents a range of memory addressed by buffers in\"\n+     \" the input.  The ranges should have no overlap even if buffers are shared in the\"\n+     \" input.  If any of the arrays are sliced zero-copy views of the data this method\"\n+     \" will return the sliced ranges that are referenced.  There is a slight exception\"\n+     \" in the case of dictionary arrays.  If a dictionary array is sliced we will still\"\n+     \" assume the entire dictionary is referenced by the sliced offsets array.  This\"\n+     \" will lead to overestimation if not all dictionary values are referenced.  If\"\n+     \" the first argument is a scalar this will return an empty array since there are no\"\n+     \" buffers referenced by the scalar.\"),\n+    {\"input\"});\n+\n+class ByteRangesMetaFunction : public MetaFunction {\n+ public:\n+  ByteRangesMetaFunction()\n+      : MetaFunction(\"byte_ranges\", Arity::Unary(), &byte_ranges_doc) {}\n+\n+  Result<Datum> ExecuteImpl(const std::vector<Datum>& args,\n+                            const FunctionOptions* options,\n+                            ExecContext* ctx) const override {\n+    DCHECK_GT(args.size(), 0);\n+    switch (args[0].kind()) {\n+      case Datum::SCALAR: {\n+        std::unique_ptr<ArrayBuilder> builder;\n+        RETURN_NOT_OK(\n+            MakeBuilder(ctx->memory_pool(), GetByteRangesArray::RangesType(), &builder));\n+        RETURN_NOT_OK(builder->Resize(0));\n+        return builder->Finish();\n+      }\n+      case Datum::ARRAY: {\n+        const std::shared_ptr<ArrayData>& array = args[0].array();\n+        DCHECK(array);\n+        return GetByteRangesArray::Exec(array);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        const std::shared_ptr<ChunkedArray>& chunked_array = args[0].chunked_array();\n+        DCHECK(chunked_array);\n+        ArrayVector chunks;\n+        for (const auto& chunk : chunked_array->chunks()) {\n+          ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Array> chunk_ranges,\n+                                GetByteRangesArray::Exec(chunk->data()));\n+          chunks.push_back(chunk_ranges);\n+        }\n+        return Concatenate(chunks, ctx->memory_pool());\n\nReview comment:\n       It seems we could avoid the concatenation by having GetBytesRangesArray take an ArrayBuilder* or such.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_buffer_test.cc\n##########\n@@ -0,0 +1,382 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstdint>\n+#include <functional>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/array/builder_primitive.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/extension_type.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace compute {\n+\n+struct ExpectedRange {\n+  // The index of the expected buffer.  If an array shares buffers then multiple\n+  // ExpectedRange objects will have the same index.\n+  int index;\n+  // The start of the expected range, as an offset from the source buffer start\n+  uint64_t offset;\n+  uint64_t length;\n+};\n+\n+std::shared_ptr<Array> ExpectedRangesToArray(\n+    const std::vector<ExpectedRange>& ranges,\n+    std::function<uint64_t(const ExpectedRange&)> key_func) {\n+  UInt64Builder builder;\n+  for (const auto& range : ranges) {\n+    ARROW_EXPECT_OK(builder.Append(key_func(range)));\n+  }\n+  std::shared_ptr<Array> arr;\n+  ARROW_EXPECT_OK(builder.Finish(&arr));\n+  return arr;\n+}\n+\n+std::shared_ptr<Array> RangesToOffsets(const std::vector<ExpectedRange>& ranges) {\n+  return ExpectedRangesToArray(ranges,\n+                               [](const ExpectedRange& range) { return range.offset; });\n+}\n+\n+std::shared_ptr<Array> RangesToLengths(const std::vector<ExpectedRange>& ranges) {\n+  return ExpectedRangesToArray(ranges,\n+                               [](const ExpectedRange& range) { return range.length; });\n+}\n+\n+// We can't validate the buffer addresses exactly because they are unpredictable pointer\n+// values.  However, when multiple ranges come from the same buffer we can validate that\n+// the buffers are the same.\n+void CheckBufferRangeStarts(const std::shared_ptr<Array>& starts,\n+                            const std::vector<ExpectedRange>& expected) {\n+  const std::shared_ptr<UInt64Array>& starts_uint64 =\n+      checked_pointer_cast<UInt64Array>(starts);\n+  std::unordered_map<int, uint64_t> previous_buffer_starts;\n+  ASSERT_NE(nullptr, starts_uint64);\n+  const uint64_t* starts_data = starts_uint64->raw_values();\n+  for (std::size_t i = 0; i < expected.size(); i++) {\n+    const auto& previous_buffer_start = previous_buffer_starts.find(expected[i].index);\n+    if (previous_buffer_start == previous_buffer_starts.end()) {\n+      previous_buffer_starts.insert({expected[i].index, starts_data[i]});\n+    } else {\n+      ASSERT_EQ(starts_data[i], previous_buffer_start->second);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void CheckBufferRanges(const std::shared_ptr<T>& input,\n+                       const std::vector<ExpectedRange>& expected) {\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> result, GetByteRanges(input));\n+  ValidateOutput(*result);\n+  std::shared_ptr<StructArray> result_struct = checked_pointer_cast<StructArray>(result);\n+  ASSERT_NE(nullptr, result_struct);\n+  AssertArraysEqual(*result_struct->field(1), *RangesToOffsets(expected));\n+  AssertArraysEqual(*result_struct->field(2), *RangesToLengths(expected));\n+  CheckBufferRangeStarts(result_struct->field(0), expected);\n+}\n+\n+template <typename T>\n+void CheckFixedWidthStarts(const std::shared_ptr<T>& input) {\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> result, GetByteRanges(input));\n+  ValidateOutput(*result);\n+  uint64_t expected_values_start =\n+      reinterpret_cast<uint64_t>(input->data()->buffers[1]->data());\n+  uint64_t expected_validity_start =\n+      reinterpret_cast<uint64_t>(input->null_bitmap_data());\n+  std::shared_ptr<StructArray> result_struct = checked_pointer_cast<StructArray>(result);\n+  const uint64_t* raw_starts =\n+      checked_pointer_cast<UInt64Array>(result_struct->field(0))->raw_values();\n+  ASSERT_EQ(expected_validity_start, raw_starts[0]);\n+  ASSERT_EQ(expected_values_start, raw_starts[1]);\n+}\n+\n+TEST(ByteRanges, StartValue) {\n+  std::shared_ptr<Array> bool_arr = ArrayFromJSON(\n+      boolean(), \"[true, true, true, null, null, null, true, true, true, true]\");\n+  CheckFixedWidthStarts(bool_arr);\n+  CheckFixedWidthStarts(bool_arr->Slice(9, 1));\n+\n+  std::shared_ptr<Array> ts_arr =\n+      ArrayFromJSON(timestamp(TimeUnit::SECOND),\n+                    R\"([\"1970-01-01\",\"2000-02-29\",\"3989-07-14\",\"1900-02-28\"])\");\n+  CheckFixedWidthStarts(bool_arr);\n+  CheckFixedWidthStarts(bool_arr->Slice(2, 1));\n\nReview comment:\n       Were these meant to be ts_arr?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_buffer_test.cc\n##########\n@@ -0,0 +1,382 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstdint>\n+#include <functional>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/array/builder_primitive.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/extension_type.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace compute {\n+\n+struct ExpectedRange {\n+  // The index of the expected buffer.  If an array shares buffers then multiple\n+  // ExpectedRange objects will have the same index.\n+  int index;\n+  // The start of the expected range, as an offset from the source buffer start\n+  uint64_t offset;\n+  uint64_t length;\n+};\n+\n+std::shared_ptr<Array> ExpectedRangesToArray(\n+    const std::vector<ExpectedRange>& ranges,\n+    std::function<uint64_t(const ExpectedRange&)> key_func) {\n+  UInt64Builder builder;\n+  for (const auto& range : ranges) {\n+    ARROW_EXPECT_OK(builder.Append(key_func(range)));\n+  }\n+  std::shared_ptr<Array> arr;\n+  ARROW_EXPECT_OK(builder.Finish(&arr));\n+  return arr;\n+}\n+\n+std::shared_ptr<Array> RangesToOffsets(const std::vector<ExpectedRange>& ranges) {\n+  return ExpectedRangesToArray(ranges,\n+                               [](const ExpectedRange& range) { return range.offset; });\n+}\n+\n+std::shared_ptr<Array> RangesToLengths(const std::vector<ExpectedRange>& ranges) {\n+  return ExpectedRangesToArray(ranges,\n+                               [](const ExpectedRange& range) { return range.length; });\n+}\n+\n+// We can't validate the buffer addresses exactly because they are unpredictable pointer\n+// values.  However, when multiple ranges come from the same buffer we can validate that\n+// the buffers are the same.\n+void CheckBufferRangeStarts(const std::shared_ptr<Array>& starts,\n+                            const std::vector<ExpectedRange>& expected) {\n+  const std::shared_ptr<UInt64Array>& starts_uint64 =\n+      checked_pointer_cast<UInt64Array>(starts);\n+  std::unordered_map<int, uint64_t> previous_buffer_starts;\n+  ASSERT_NE(nullptr, starts_uint64);\n+  const uint64_t* starts_data = starts_uint64->raw_values();\n+  for (std::size_t i = 0; i < expected.size(); i++) {\n+    const auto& previous_buffer_start = previous_buffer_starts.find(expected[i].index);\n+    if (previous_buffer_start == previous_buffer_starts.end()) {\n+      previous_buffer_starts.insert({expected[i].index, starts_data[i]});\n+    } else {\n+      ASSERT_EQ(starts_data[i], previous_buffer_start->second);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void CheckBufferRanges(const std::shared_ptr<T>& input,\n+                       const std::vector<ExpectedRange>& expected) {\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> result, GetByteRanges(input));\n+  ValidateOutput(*result);\n+  std::shared_ptr<StructArray> result_struct = checked_pointer_cast<StructArray>(result);\n+  ASSERT_NE(nullptr, result_struct);\n+  AssertArraysEqual(*result_struct->field(1), *RangesToOffsets(expected));\n+  AssertArraysEqual(*result_struct->field(2), *RangesToLengths(expected));\n+  CheckBufferRangeStarts(result_struct->field(0), expected);\n+}\n+\n+template <typename T>\n+void CheckFixedWidthStarts(const std::shared_ptr<T>& input) {\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> result, GetByteRanges(input));\n+  ValidateOutput(*result);\n+  uint64_t expected_values_start =\n+      reinterpret_cast<uint64_t>(input->data()->buffers[1]->data());\n+  uint64_t expected_validity_start =\n+      reinterpret_cast<uint64_t>(input->null_bitmap_data());\n+  std::shared_ptr<StructArray> result_struct = checked_pointer_cast<StructArray>(result);\n+  const uint64_t* raw_starts =\n+      checked_pointer_cast<UInt64Array>(result_struct->field(0))->raw_values();\n+  ASSERT_EQ(expected_validity_start, raw_starts[0]);\n+  ASSERT_EQ(expected_values_start, raw_starts[1]);\n+}\n+\n+TEST(ByteRanges, StartValue) {\n+  std::shared_ptr<Array> bool_arr = ArrayFromJSON(\n+      boolean(), \"[true, true, true, null, null, null, true, true, true, true]\");\n+  CheckFixedWidthStarts(bool_arr);\n+  CheckFixedWidthStarts(bool_arr->Slice(9, 1));\n+\n+  std::shared_ptr<Array> ts_arr =\n+      ArrayFromJSON(timestamp(TimeUnit::SECOND),\n+                    R\"([\"1970-01-01\",\"2000-02-29\",\"3989-07-14\",\"1900-02-28\"])\");\n+  CheckFixedWidthStarts(bool_arr);\n+  CheckFixedWidthStarts(bool_arr->Slice(2, 1));\n+}\n+\n+TEST(ByteRanges, FixedWidthTypes) {\n+  std::shared_ptr<Array> bool_arr = ArrayFromJSON(\n+      boolean(), \"[true, true, true, null, null, null, true, true, true, true]\");\n+  CheckBufferRanges(bool_arr, {{0, 0, 2}, {1, 0, 2}});\n+  CheckBufferRanges(bool_arr->Slice(1, 8), {{0, 0, 2}, {1, 0, 2}});\n+  CheckBufferRanges(bool_arr->Slice(1, 5), {{0, 0, 1}, {1, 0, 1}});\n+  CheckBufferRanges(bool_arr->Slice(5, 5), {{0, 0, 2}, {1, 0, 2}});\n+  CheckBufferRanges(bool_arr->Slice(9, 1), {{0, 1, 1}, {1, 1, 1}});\n+\n+  std::shared_ptr<Array> bool_arr_no_validity = ArrayFromJSON(boolean(), \"[true, true]\");\n+  CheckBufferRanges(bool_arr_no_validity, {{0, 0, 1}});\n+\n+  std::shared_ptr<Array> fsb_arr =\n+      ArrayFromJSON(fixed_size_binary(4), R\"([\"foox\", \"barz\", null])\");\n+  CheckBufferRanges(fsb_arr, {{0, 0, 1}, {1, 0, 12}});\n+  CheckBufferRanges(fsb_arr->Slice(1, 1), {{0, 0, 1}, {1, 4, 4}});\n+}\n+\n+TEST(ByteRanges, DictionaryArray) {\n+  std::shared_ptr<Array> dict_arr =\n+      ArrayFromJSON(dictionary(int16(), utf8()), R\"([\"x\", \"abc\", \"x\", null])\");\n+  CheckBufferRanges(dict_arr, {{0, 0, 1}, {1, 0, 8}, {2, 0, 8}, {3, 0, 4}});\n+  CheckBufferRanges(dict_arr->Slice(2, 2), {{0, 0, 1}, {1, 4, 4}, {2, 0, 8}, {3, 0, 4}});\n+}\n+\n+template <typename Type>\n+class ByteRangesVariableBinary : public ::testing::Test {};\n+typedef ::testing::Types<StringType, LargeStringType, BinaryType, LargeBinaryType>\n+    VariableLengthBinaryTypes;\n\nReview comment:\n       This should be BaseBinaryArrowTypes: https://github.com/apache/arrow/blob/836ffa5656d5107fd4895ae8d7eb0e20a3df23ba/cpp/src/arrow/testing/gtest_util.h#L178-L179\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_buffer_test.cc\n##########\n@@ -0,0 +1,382 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstdint>\n+#include <functional>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/array/builder_primitive.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/extension_type.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace compute {\n+\n+struct ExpectedRange {\n+  // The index of the expected buffer.  If an array shares buffers then multiple\n+  // ExpectedRange objects will have the same index.\n+  int index;\n+  // The start of the expected range, as an offset from the source buffer start\n+  uint64_t offset;\n+  uint64_t length;\n+};\n+\n+std::shared_ptr<Array> ExpectedRangesToArray(\n+    const std::vector<ExpectedRange>& ranges,\n+    std::function<uint64_t(const ExpectedRange&)> key_func) {\n+  UInt64Builder builder;\n+  for (const auto& range : ranges) {\n+    ARROW_EXPECT_OK(builder.Append(key_func(range)));\n+  }\n+  std::shared_ptr<Array> arr;\n+  ARROW_EXPECT_OK(builder.Finish(&arr));\n+  return arr;\n+}\n+\n+std::shared_ptr<Array> RangesToOffsets(const std::vector<ExpectedRange>& ranges) {\n+  return ExpectedRangesToArray(ranges,\n+                               [](const ExpectedRange& range) { return range.offset; });\n+}\n+\n+std::shared_ptr<Array> RangesToLengths(const std::vector<ExpectedRange>& ranges) {\n+  return ExpectedRangesToArray(ranges,\n+                               [](const ExpectedRange& range) { return range.length; });\n+}\n+\n+// We can't validate the buffer addresses exactly because they are unpredictable pointer\n+// values.  However, when multiple ranges come from the same buffer we can validate that\n+// the buffers are the same.\n+void CheckBufferRangeStarts(const std::shared_ptr<Array>& starts,\n+                            const std::vector<ExpectedRange>& expected) {\n+  const std::shared_ptr<UInt64Array>& starts_uint64 =\n+      checked_pointer_cast<UInt64Array>(starts);\n+  std::unordered_map<int, uint64_t> previous_buffer_starts;\n+  ASSERT_NE(nullptr, starts_uint64);\n+  const uint64_t* starts_data = starts_uint64->raw_values();\n+  for (std::size_t i = 0; i < expected.size(); i++) {\n+    const auto& previous_buffer_start = previous_buffer_starts.find(expected[i].index);\n+    if (previous_buffer_start == previous_buffer_starts.end()) {\n+      previous_buffer_starts.insert({expected[i].index, starts_data[i]});\n+    } else {\n+      ASSERT_EQ(starts_data[i], previous_buffer_start->second);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void CheckBufferRanges(const std::shared_ptr<T>& input,\n+                       const std::vector<ExpectedRange>& expected) {\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> result, GetByteRanges(input));\n+  ValidateOutput(*result);\n+  std::shared_ptr<StructArray> result_struct = checked_pointer_cast<StructArray>(result);\n+  ASSERT_NE(nullptr, result_struct);\n+  AssertArraysEqual(*result_struct->field(1), *RangesToOffsets(expected));\n+  AssertArraysEqual(*result_struct->field(2), *RangesToLengths(expected));\n+  CheckBufferRangeStarts(result_struct->field(0), expected);\n+}\n+\n+template <typename T>\n+void CheckFixedWidthStarts(const std::shared_ptr<T>& input) {\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> result, GetByteRanges(input));\n+  ValidateOutput(*result);\n+  uint64_t expected_values_start =\n+      reinterpret_cast<uint64_t>(input->data()->buffers[1]->data());\n+  uint64_t expected_validity_start =\n+      reinterpret_cast<uint64_t>(input->null_bitmap_data());\n+  std::shared_ptr<StructArray> result_struct = checked_pointer_cast<StructArray>(result);\n+  const uint64_t* raw_starts =\n+      checked_pointer_cast<UInt64Array>(result_struct->field(0))->raw_values();\n+  ASSERT_EQ(expected_validity_start, raw_starts[0]);\n+  ASSERT_EQ(expected_values_start, raw_starts[1]);\n+}\n+\n+TEST(ByteRanges, StartValue) {\n+  std::shared_ptr<Array> bool_arr = ArrayFromJSON(\n+      boolean(), \"[true, true, true, null, null, null, true, true, true, true]\");\n+  CheckFixedWidthStarts(bool_arr);\n+  CheckFixedWidthStarts(bool_arr->Slice(9, 1));\n+\n+  std::shared_ptr<Array> ts_arr =\n+      ArrayFromJSON(timestamp(TimeUnit::SECOND),\n+                    R\"([\"1970-01-01\",\"2000-02-29\",\"3989-07-14\",\"1900-02-28\"])\");\n+  CheckFixedWidthStarts(bool_arr);\n+  CheckFixedWidthStarts(bool_arr->Slice(2, 1));\n+}\n+\n+TEST(ByteRanges, FixedWidthTypes) {\n+  std::shared_ptr<Array> bool_arr = ArrayFromJSON(\n+      boolean(), \"[true, true, true, null, null, null, true, true, true, true]\");\n+  CheckBufferRanges(bool_arr, {{0, 0, 2}, {1, 0, 2}});\n+  CheckBufferRanges(bool_arr->Slice(1, 8), {{0, 0, 2}, {1, 0, 2}});\n+  CheckBufferRanges(bool_arr->Slice(1, 5), {{0, 0, 1}, {1, 0, 1}});\n+  CheckBufferRanges(bool_arr->Slice(5, 5), {{0, 0, 2}, {1, 0, 2}});\n+  CheckBufferRanges(bool_arr->Slice(9, 1), {{0, 1, 1}, {1, 1, 1}});\n+\n+  std::shared_ptr<Array> bool_arr_no_validity = ArrayFromJSON(boolean(), \"[true, true]\");\n+  CheckBufferRanges(bool_arr_no_validity, {{0, 0, 1}});\n+\n+  std::shared_ptr<Array> fsb_arr =\n+      ArrayFromJSON(fixed_size_binary(4), R\"([\"foox\", \"barz\", null])\");\n+  CheckBufferRanges(fsb_arr, {{0, 0, 1}, {1, 0, 12}});\n+  CheckBufferRanges(fsb_arr->Slice(1, 1), {{0, 0, 1}, {1, 4, 4}});\n+}\n+\n+TEST(ByteRanges, DictionaryArray) {\n+  std::shared_ptr<Array> dict_arr =\n+      ArrayFromJSON(dictionary(int16(), utf8()), R\"([\"x\", \"abc\", \"x\", null])\");\n+  CheckBufferRanges(dict_arr, {{0, 0, 1}, {1, 0, 8}, {2, 0, 8}, {3, 0, 4}});\n+  CheckBufferRanges(dict_arr->Slice(2, 2), {{0, 0, 1}, {1, 4, 4}, {2, 0, 8}, {3, 0, 4}});\n+}\n+\n+template <typename Type>\n+class ByteRangesVariableBinary : public ::testing::Test {};\n+typedef ::testing::Types<StringType, LargeStringType, BinaryType, LargeBinaryType>\n+    VariableLengthBinaryTypes;\n\nReview comment:\n       (and ditto below for the list types)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-10-26T14:50:21.736+0000",
                    "updated": "2021-10-26T14:50:21.736+0000",
                    "started": "2021-10-26T14:50:21.736+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "670136",
                    "issueId": "13406868"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406868/worklog/674307",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #11542:\nURL: https://github.com/apache/arrow/pull/11542#discussion_r741573603\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_buffer.cc\n##########\n@@ -0,0 +1,345 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <memory>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/array/builder_primitive.h\"\n+#include \"arrow/array/concatenate.h\"\n+#include \"arrow/buffer.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/function.h\"\n+#include \"arrow/compute/kernel.h\"\n+#include \"arrow/compute/registry.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/bit_util.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+struct GetByteRangesArray {\n+  const std::shared_ptr<ArrayData>& input;\n+  int64_t offset;\n+  int64_t length;\n+  UInt64Builder* range_starts;\n+  UInt64Builder* range_offsets;\n+  UInt64Builder* range_lengths;\n+\n+  Status VisitBitmap(const std::shared_ptr<Buffer>& buffer) {\n+    if (buffer) {\n+      uint64_t data_start = reinterpret_cast<uint64_t>(buffer->data());\n+      RETURN_NOT_OK(range_starts->Append(data_start));\n+      RETURN_NOT_OK(range_offsets->Append(BitUtil::RoundDown(offset, 8) / 8));\n+      RETURN_NOT_OK(range_lengths->Append(BitUtil::CoveringBytes(offset, length)));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status VisitFixedWidthArray(const Buffer& buffer, const FixedWidthType& type) {\n+    uint64_t data_start = reinterpret_cast<uint64_t>(buffer.data());\n+    uint64_t offset_bits = offset * type.bit_width();\n+    uint64_t offset_bytes = BitUtil::RoundDown(offset_bits, 8) / 8;\n+    uint64_t end_byte =\n+        BitUtil::RoundUp(offset_bits + (length * type.bit_width()), 8) / 8;\n+    uint64_t length_bytes = (end_byte - offset_bytes);\n+    RETURN_NOT_OK(range_starts->Append(data_start));\n+    RETURN_NOT_OK(range_offsets->Append(offset_bytes));\n+    return range_lengths->Append(length_bytes);\n+  }\n+\n+  Status Visit(const FixedWidthType& type) {\n+    static_assert(sizeof(uint8_t*) <= sizeof(uint64_t),\n+                  \"Undefined behavior if pointer larger than uint64_t\");\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+    RETURN_NOT_OK(VisitFixedWidthArray(*input->buffers[1], type));\n+    if (input->dictionary) {\n+      // This is slightly imprecise because we always assume the entire dictionary is\n+      // referenced.  If this array has an offset it may only be referencing a portion of\n+      // the dictionary\n+      GetByteRangesArray dict_visitor{input->dictionary,\n+                                      input->dictionary->offset,\n+                                      input->dictionary->length,\n+                                      range_starts,\n+                                      range_offsets,\n+                                      range_lengths};\n+      return VisitTypeInline(*input->dictionary->type, &dict_visitor);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const NullType& type) { return Status::OK(); }\n+\n+  template <typename BaseBinaryType>\n+  Status VisitBaseBinary(const BaseBinaryType& type) {\n+    using offset_type = typename BaseBinaryType::offset_type;\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+\n+    const Buffer& offsets_buffer = *input->buffers[1];\n+    RETURN_NOT_OK(\n+        range_starts->Append(reinterpret_cast<uint64_t>(offsets_buffer.data())));\n+    RETURN_NOT_OK(range_offsets->Append(sizeof(offset_type) * offset));\n+    RETURN_NOT_OK(range_lengths->Append(sizeof(offset_type) * length));\n+\n+    const offset_type* offsets = input->GetValues<offset_type>(1, offset);\n+    const Buffer& values = *input->buffers[2];\n+    offset_type start = offsets[0];\n+    offset_type end = offsets[length];\n+    RETURN_NOT_OK(range_starts->Append(reinterpret_cast<uint64_t>(values.data())));\n+    RETURN_NOT_OK(range_offsets->Append(static_cast<uint64_t>(start)));\n+    return range_lengths->Append(static_cast<uint64_t>(end - start));\n+  }\n+\n+  Status Visit(const BinaryType& type) { return VisitBaseBinary(type); }\n+\n+  Status Visit(const LargeBinaryType& type) { return VisitBaseBinary(type); }\n+\n+  template <typename BaseListType>\n+  Status VisitBaseList(const BaseListType& type) {\n+    using offset_type = typename BaseListType::offset_type;\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+\n+    const Buffer& offsets_buffer = *input->buffers[1];\n+    RETURN_NOT_OK(\n+        range_starts->Append(reinterpret_cast<uint64_t>(offsets_buffer.data())));\n+    RETURN_NOT_OK(range_offsets->Append(sizeof(offset_type) * offset));\n+    RETURN_NOT_OK(range_lengths->Append(sizeof(offset_type) * length));\n+\n+    const offset_type* offsets = input->GetValues<offset_type>(1, offset);\n+    int64_t start = static_cast<int64_t>(offsets[0]);\n+    int64_t end = static_cast<int64_t>(offsets[length]);\n+    GetByteRangesArray child{input->child_data[0], start,         end - start,\n+                             range_starts,         range_offsets, range_lengths};\n+    return VisitTypeInline(*type.value_type(), &child);\n+  }\n+\n+  Status Visit(const ListType& type) { return VisitBaseList(type); }\n+\n+  Status Visit(const LargeListType& type) { return VisitBaseList(type); }\n+\n+  Status Visit(const FixedSizeListType& type) {\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+    GetByteRangesArray child{input->child_data[0],\n+                             offset * type.list_size(),\n+                             length * type.list_size(),\n+                             range_starts,\n+                             range_offsets,\n+                             range_lengths};\n+    return VisitTypeInline(*type.value_type(), &child);\n+  }\n+\n+  Status Visit(const StructType& type) {\n+    for (int i = 0; i < type.num_fields(); i++) {\n+      GetByteRangesArray child{input->child_data[i],\n+                               offset + input->child_data[i]->offset,\n+                               length,\n+                               range_starts,\n+                               range_offsets,\n+                               range_lengths};\n+      RETURN_NOT_OK(VisitTypeInline(*type.field(i)->type(), &child));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const DenseUnionType& type) {\n+    // Skip validity map for DenseUnionType\n+    // Types buffer is always int8\n+    RETURN_NOT_OK(VisitFixedWidthArray(\n+        *input->buffers[1], *std::dynamic_pointer_cast<FixedWidthType>(int8())));\n+    // Offsets buffer is always int32\n+    RETURN_NOT_OK(VisitFixedWidthArray(\n+        *input->buffers[2], *std::dynamic_pointer_cast<FixedWidthType>(int32())));\n+\n+    // We have to loop through the types buffer to figure out the correct\n+    // offset / length being referenced in the child arrays\n+    std::array<std::size_t, UnionType::kMaxTypeCode> type_code_index_lookup;\n+    for (std::size_t i = 0; i < type.type_codes().size(); i++) {\n+      type_code_index_lookup[static_cast<std::size_t>(type.type_codes()[i])] = i;\n+    }\n+    std::vector<int64_t> lengths_per_type(type.type_codes().size());\n+    std::vector<int64_t> offsets_per_type(type.type_codes().size());\n+    const int8_t* type_codes = input->GetValues<int8_t>(1, 0);\n+    for (const int8_t* it = type_codes; it != type_codes + offset; it++) {\n+      offsets_per_type[type_code_index_lookup[static_cast<std::size_t>(*it)]]++;\n+    }\n+    for (const int8_t* it = type_codes + offset; it != type_codes + offset + length;\n+         it++) {\n+      lengths_per_type[type_code_index_lookup[static_cast<std::size_t>(*it)]]++;\n+    }\n+\n+    for (int i = 0; i < type.num_fields(); i++) {\n+      GetByteRangesArray child{\n+          input->child_data[i], offsets_per_type[i] + input->child_data[i]->offset,\n+          lengths_per_type[i],  range_starts,\n+          range_offsets,        range_lengths};\n+      RETURN_NOT_OK(VisitTypeInline(*type.field(i)->type(), &child));\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const SparseUnionType& type) {\n+    // Skip validity map for SparseUnionType\n+    // Types buffer is always int8\n+    RETURN_NOT_OK(VisitFixedWidthArray(\n+        *input->buffers[1], *std::dynamic_pointer_cast<FixedWidthType>(int8())));\n+\n+    for (int i = 0; i < type.num_fields(); i++) {\n+      GetByteRangesArray child{input->child_data[i],\n+                               offset + input->child_data[i]->offset,\n+                               length,\n+                               range_starts,\n+                               range_offsets,\n+                               range_lengths};\n+      RETURN_NOT_OK(VisitTypeInline(*type.field(i)->type(), &child));\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const ExtensionType& extension_type) {\n+    GetByteRangesArray storage{input,        offset,        length,\n+                               range_starts, range_offsets, range_lengths};\n+    return VisitTypeInline(*extension_type.storage_type(), &storage);\n+  }\n+\n+  Status Visit(const DataType& type) {\n+    return Status::TypeError(\"Extracting byte ranges not supported for type \",\n+                             type.ToString());\n+  }\n+\n+  static std::shared_ptr<DataType> RangesType() {\n+    return struct_(\n+        {field(\"start\", uint64()), field(\"offset\", uint64()), field(\"length\", uint64())});\n+  }\n+\n+  Result<std::shared_ptr<Array>> MakeRanges() {\n+    std::shared_ptr<Array> range_starts_arr, range_offsets_arr, range_lengths_arr;\n+    RETURN_NOT_OK(range_starts->Finish(&range_starts_arr));\n+    RETURN_NOT_OK(range_offsets->Finish(&range_offsets_arr));\n+    RETURN_NOT_OK(range_lengths->Finish(&range_lengths_arr));\n+    return StructArray::Make(\n+        {range_starts_arr, range_offsets_arr, range_lengths_arr},\n+        {field(\"start\", uint64()), field(\"offset\", uint64()), field(\"length\", uint64())});\n+  }\n+\n+  static Result<std::shared_ptr<Array>> Exec(const std::shared_ptr<ArrayData>& input) {\n+    UInt64Builder range_starts, range_offsets, range_lengths;\n+    GetByteRangesArray self{input,         input->offset,  input->length,\n+                            &range_starts, &range_offsets, &range_lengths};\n+    RETURN_NOT_OK(VisitTypeInline(*input->type, &self));\n+    return self.MakeRanges();\n+  }\n+};\n+\n+const FunctionDoc byte_ranges_doc(\n+    \"Returns an array of byte ranges referenced by the input\",\n+    (R\"(The output is a StructArray {\"start\": int64, \"offset\": int64, \"length\":)\"\n+     \" int64} where each item represents a range of memory addressed by buffers in\"\n+     \" the input.  The ranges should have no overlap even if buffers are shared in the\"\n+     \" input.  If any of the arrays are sliced zero-copy views of the data this method\"\n+     \" will return the sliced ranges that are referenced.  There is a slight exception\"\n+     \" in the case of dictionary arrays.  If a dictionary array is sliced we will still\"\n+     \" assume the entire dictionary is referenced by the sliced offsets array.  This\"\n+     \" will lead to overestimation if not all dictionary values are referenced.  If\"\n+     \" the first argument is a scalar this will return an empty array since there are no\"\n+     \" buffers referenced by the scalar.\"),\n+    {\"input\"});\n+\n+class ByteRangesMetaFunction : public MetaFunction {\n+ public:\n+  ByteRangesMetaFunction()\n+      : MetaFunction(\"byte_ranges\", Arity::Unary(), &byte_ranges_doc) {}\n+\n+  Result<Datum> ExecuteImpl(const std::vector<Datum>& args,\n+                            const FunctionOptions* options,\n+                            ExecContext* ctx) const override {\n+    DCHECK_GT(args.size(), 0);\n+    switch (args[0].kind()) {\n+      case Datum::SCALAR: {\n+        std::unique_ptr<ArrayBuilder> builder;\n+        RETURN_NOT_OK(\n+            MakeBuilder(ctx->memory_pool(), GetByteRangesArray::RangesType(), &builder));\n+        RETURN_NOT_OK(builder->Resize(0));\n+        return builder->Finish();\n+      }\n+      case Datum::ARRAY: {\n+        const std::shared_ptr<ArrayData>& array = args[0].array();\n+        DCHECK(array);\n+        return GetByteRangesArray::Exec(array);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        const std::shared_ptr<ChunkedArray>& chunked_array = args[0].chunked_array();\n+        DCHECK(chunked_array);\n+        ArrayVector chunks;\n+        for (const auto& chunk : chunked_array->chunks()) {\n+          ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Array> chunk_ranges,\n+                                GetByteRangesArray::Exec(chunk->data()));\n+          chunks.push_back(chunk_ranges);\n+        }\n+        return Concatenate(chunks, ctx->memory_pool());\n\nReview comment:\n       I moved this out of the compute layer and changed the functions to return lengths instead of arrays.  If someone needs all referenced ranges of a table they can cross that bridge when they come to it.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-03T02:03:53.166+0000",
                    "updated": "2021-11-03T02:03:53.166+0000",
                    "started": "2021-11-03T02:03:53.165+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "674307",
                    "issueId": "13406868"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406868/worklog/674314",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #11542:\nURL: https://github.com/apache/arrow/pull/11542#discussion_r741577703\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_buffer.cc\n##########\n@@ -0,0 +1,345 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <memory>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/array/builder_primitive.h\"\n+#include \"arrow/array/concatenate.h\"\n+#include \"arrow/buffer.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/function.h\"\n+#include \"arrow/compute/kernel.h\"\n+#include \"arrow/compute/registry.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/bit_util.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+struct GetByteRangesArray {\n+  const std::shared_ptr<ArrayData>& input;\n+  int64_t offset;\n+  int64_t length;\n+  UInt64Builder* range_starts;\n+  UInt64Builder* range_offsets;\n+  UInt64Builder* range_lengths;\n+\n+  Status VisitBitmap(const std::shared_ptr<Buffer>& buffer) {\n+    if (buffer) {\n+      uint64_t data_start = reinterpret_cast<uint64_t>(buffer->data());\n+      RETURN_NOT_OK(range_starts->Append(data_start));\n+      RETURN_NOT_OK(range_offsets->Append(BitUtil::RoundDown(offset, 8) / 8));\n+      RETURN_NOT_OK(range_lengths->Append(BitUtil::CoveringBytes(offset, length)));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status VisitFixedWidthArray(const Buffer& buffer, const FixedWidthType& type) {\n+    uint64_t data_start = reinterpret_cast<uint64_t>(buffer.data());\n+    uint64_t offset_bits = offset * type.bit_width();\n+    uint64_t offset_bytes = BitUtil::RoundDown(offset_bits, 8) / 8;\n+    uint64_t end_byte =\n+        BitUtil::RoundUp(offset_bits + (length * type.bit_width()), 8) / 8;\n+    uint64_t length_bytes = (end_byte - offset_bytes);\n+    RETURN_NOT_OK(range_starts->Append(data_start));\n+    RETURN_NOT_OK(range_offsets->Append(offset_bytes));\n+    return range_lengths->Append(length_bytes);\n+  }\n+\n+  Status Visit(const FixedWidthType& type) {\n+    static_assert(sizeof(uint8_t*) <= sizeof(uint64_t),\n+                  \"Undefined behavior if pointer larger than uint64_t\");\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+    RETURN_NOT_OK(VisitFixedWidthArray(*input->buffers[1], type));\n+    if (input->dictionary) {\n+      // This is slightly imprecise because we always assume the entire dictionary is\n+      // referenced.  If this array has an offset it may only be referencing a portion of\n+      // the dictionary\n+      GetByteRangesArray dict_visitor{input->dictionary,\n+                                      input->dictionary->offset,\n+                                      input->dictionary->length,\n+                                      range_starts,\n+                                      range_offsets,\n+                                      range_lengths};\n+      return VisitTypeInline(*input->dictionary->type, &dict_visitor);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const NullType& type) { return Status::OK(); }\n+\n+  template <typename BaseBinaryType>\n+  Status VisitBaseBinary(const BaseBinaryType& type) {\n+    using offset_type = typename BaseBinaryType::offset_type;\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+\n+    const Buffer& offsets_buffer = *input->buffers[1];\n+    RETURN_NOT_OK(\n+        range_starts->Append(reinterpret_cast<uint64_t>(offsets_buffer.data())));\n+    RETURN_NOT_OK(range_offsets->Append(sizeof(offset_type) * offset));\n+    RETURN_NOT_OK(range_lengths->Append(sizeof(offset_type) * length));\n+\n+    const offset_type* offsets = input->GetValues<offset_type>(1, offset);\n+    const Buffer& values = *input->buffers[2];\n+    offset_type start = offsets[0];\n+    offset_type end = offsets[length];\n+    RETURN_NOT_OK(range_starts->Append(reinterpret_cast<uint64_t>(values.data())));\n+    RETURN_NOT_OK(range_offsets->Append(static_cast<uint64_t>(start)));\n+    return range_lengths->Append(static_cast<uint64_t>(end - start));\n+  }\n+\n+  Status Visit(const BinaryType& type) { return VisitBaseBinary(type); }\n+\n+  Status Visit(const LargeBinaryType& type) { return VisitBaseBinary(type); }\n+\n+  template <typename BaseListType>\n+  Status VisitBaseList(const BaseListType& type) {\n+    using offset_type = typename BaseListType::offset_type;\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+\n+    const Buffer& offsets_buffer = *input->buffers[1];\n+    RETURN_NOT_OK(\n+        range_starts->Append(reinterpret_cast<uint64_t>(offsets_buffer.data())));\n+    RETURN_NOT_OK(range_offsets->Append(sizeof(offset_type) * offset));\n+    RETURN_NOT_OK(range_lengths->Append(sizeof(offset_type) * length));\n+\n+    const offset_type* offsets = input->GetValues<offset_type>(1, offset);\n+    int64_t start = static_cast<int64_t>(offsets[0]);\n+    int64_t end = static_cast<int64_t>(offsets[length]);\n+    GetByteRangesArray child{input->child_data[0], start,         end - start,\n+                             range_starts,         range_offsets, range_lengths};\n+    return VisitTypeInline(*type.value_type(), &child);\n+  }\n+\n+  Status Visit(const ListType& type) { return VisitBaseList(type); }\n+\n+  Status Visit(const LargeListType& type) { return VisitBaseList(type); }\n+\n+  Status Visit(const FixedSizeListType& type) {\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+    GetByteRangesArray child{input->child_data[0],\n+                             offset * type.list_size(),\n+                             length * type.list_size(),\n+                             range_starts,\n+                             range_offsets,\n+                             range_lengths};\n+    return VisitTypeInline(*type.value_type(), &child);\n+  }\n+\n+  Status Visit(const StructType& type) {\n+    for (int i = 0; i < type.num_fields(); i++) {\n+      GetByteRangesArray child{input->child_data[i],\n+                               offset + input->child_data[i]->offset,\n+                               length,\n+                               range_starts,\n+                               range_offsets,\n+                               range_lengths};\n+      RETURN_NOT_OK(VisitTypeInline(*type.field(i)->type(), &child));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const DenseUnionType& type) {\n+    // Skip validity map for DenseUnionType\n+    // Types buffer is always int8\n+    RETURN_NOT_OK(VisitFixedWidthArray(\n+        *input->buffers[1], *std::dynamic_pointer_cast<FixedWidthType>(int8())));\n+    // Offsets buffer is always int32\n+    RETURN_NOT_OK(VisitFixedWidthArray(\n+        *input->buffers[2], *std::dynamic_pointer_cast<FixedWidthType>(int32())));\n+\n+    // We have to loop through the types buffer to figure out the correct\n+    // offset / length being referenced in the child arrays\n+    std::array<std::size_t, UnionType::kMaxTypeCode> type_code_index_lookup;\n\nReview comment:\n       You are right.  Thanks for the pointer.  I hadn't realized that.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-03T02:20:52.208+0000",
                    "updated": "2021-11-03T02:20:52.208+0000",
                    "started": "2021-11-03T02:20:52.208+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "674314",
                    "issueId": "13406868"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406868/worklog/674316",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #11542:\nURL: https://github.com/apache/arrow/pull/11542#discussion_r741577774\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_buffer_test.cc\n##########\n@@ -0,0 +1,382 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstdint>\n+#include <functional>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/array/builder_primitive.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/extension_type.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace compute {\n+\n+struct ExpectedRange {\n+  // The index of the expected buffer.  If an array shares buffers then multiple\n+  // ExpectedRange objects will have the same index.\n+  int index;\n+  // The start of the expected range, as an offset from the source buffer start\n+  uint64_t offset;\n+  uint64_t length;\n+};\n+\n+std::shared_ptr<Array> ExpectedRangesToArray(\n+    const std::vector<ExpectedRange>& ranges,\n+    std::function<uint64_t(const ExpectedRange&)> key_func) {\n+  UInt64Builder builder;\n+  for (const auto& range : ranges) {\n+    ARROW_EXPECT_OK(builder.Append(key_func(range)));\n+  }\n+  std::shared_ptr<Array> arr;\n+  ARROW_EXPECT_OK(builder.Finish(&arr));\n+  return arr;\n+}\n+\n+std::shared_ptr<Array> RangesToOffsets(const std::vector<ExpectedRange>& ranges) {\n+  return ExpectedRangesToArray(ranges,\n+                               [](const ExpectedRange& range) { return range.offset; });\n+}\n+\n+std::shared_ptr<Array> RangesToLengths(const std::vector<ExpectedRange>& ranges) {\n+  return ExpectedRangesToArray(ranges,\n+                               [](const ExpectedRange& range) { return range.length; });\n+}\n+\n+// We can't validate the buffer addresses exactly because they are unpredictable pointer\n+// values.  However, when multiple ranges come from the same buffer we can validate that\n+// the buffers are the same.\n+void CheckBufferRangeStarts(const std::shared_ptr<Array>& starts,\n+                            const std::vector<ExpectedRange>& expected) {\n+  const std::shared_ptr<UInt64Array>& starts_uint64 =\n+      checked_pointer_cast<UInt64Array>(starts);\n+  std::unordered_map<int, uint64_t> previous_buffer_starts;\n+  ASSERT_NE(nullptr, starts_uint64);\n+  const uint64_t* starts_data = starts_uint64->raw_values();\n+  for (std::size_t i = 0; i < expected.size(); i++) {\n+    const auto& previous_buffer_start = previous_buffer_starts.find(expected[i].index);\n+    if (previous_buffer_start == previous_buffer_starts.end()) {\n+      previous_buffer_starts.insert({expected[i].index, starts_data[i]});\n+    } else {\n+      ASSERT_EQ(starts_data[i], previous_buffer_start->second);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void CheckBufferRanges(const std::shared_ptr<T>& input,\n+                       const std::vector<ExpectedRange>& expected) {\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> result, GetByteRanges(input));\n+  ValidateOutput(*result);\n+  std::shared_ptr<StructArray> result_struct = checked_pointer_cast<StructArray>(result);\n+  ASSERT_NE(nullptr, result_struct);\n+  AssertArraysEqual(*result_struct->field(1), *RangesToOffsets(expected));\n+  AssertArraysEqual(*result_struct->field(2), *RangesToLengths(expected));\n+  CheckBufferRangeStarts(result_struct->field(0), expected);\n+}\n+\n+template <typename T>\n+void CheckFixedWidthStarts(const std::shared_ptr<T>& input) {\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> result, GetByteRanges(input));\n+  ValidateOutput(*result);\n+  uint64_t expected_values_start =\n+      reinterpret_cast<uint64_t>(input->data()->buffers[1]->data());\n+  uint64_t expected_validity_start =\n+      reinterpret_cast<uint64_t>(input->null_bitmap_data());\n+  std::shared_ptr<StructArray> result_struct = checked_pointer_cast<StructArray>(result);\n+  const uint64_t* raw_starts =\n+      checked_pointer_cast<UInt64Array>(result_struct->field(0))->raw_values();\n+  ASSERT_EQ(expected_validity_start, raw_starts[0]);\n+  ASSERT_EQ(expected_values_start, raw_starts[1]);\n+}\n+\n+TEST(ByteRanges, StartValue) {\n+  std::shared_ptr<Array> bool_arr = ArrayFromJSON(\n+      boolean(), \"[true, true, true, null, null, null, true, true, true, true]\");\n+  CheckFixedWidthStarts(bool_arr);\n+  CheckFixedWidthStarts(bool_arr->Slice(9, 1));\n+\n+  std::shared_ptr<Array> ts_arr =\n+      ArrayFromJSON(timestamp(TimeUnit::SECOND),\n+                    R\"([\"1970-01-01\",\"2000-02-29\",\"3989-07-14\",\"1900-02-28\"])\");\n+  CheckFixedWidthStarts(bool_arr);\n+  CheckFixedWidthStarts(bool_arr->Slice(2, 1));\n\nReview comment:\n       Yep, good catch.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_buffer_test.cc\n##########\n@@ -0,0 +1,382 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstdint>\n+#include <functional>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/array/builder_primitive.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/extension_type.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace compute {\n+\n+struct ExpectedRange {\n+  // The index of the expected buffer.  If an array shares buffers then multiple\n+  // ExpectedRange objects will have the same index.\n+  int index;\n+  // The start of the expected range, as an offset from the source buffer start\n+  uint64_t offset;\n+  uint64_t length;\n+};\n+\n+std::shared_ptr<Array> ExpectedRangesToArray(\n+    const std::vector<ExpectedRange>& ranges,\n+    std::function<uint64_t(const ExpectedRange&)> key_func) {\n+  UInt64Builder builder;\n+  for (const auto& range : ranges) {\n+    ARROW_EXPECT_OK(builder.Append(key_func(range)));\n+  }\n+  std::shared_ptr<Array> arr;\n+  ARROW_EXPECT_OK(builder.Finish(&arr));\n+  return arr;\n+}\n+\n+std::shared_ptr<Array> RangesToOffsets(const std::vector<ExpectedRange>& ranges) {\n+  return ExpectedRangesToArray(ranges,\n+                               [](const ExpectedRange& range) { return range.offset; });\n+}\n+\n+std::shared_ptr<Array> RangesToLengths(const std::vector<ExpectedRange>& ranges) {\n+  return ExpectedRangesToArray(ranges,\n+                               [](const ExpectedRange& range) { return range.length; });\n+}\n+\n+// We can't validate the buffer addresses exactly because they are unpredictable pointer\n+// values.  However, when multiple ranges come from the same buffer we can validate that\n+// the buffers are the same.\n+void CheckBufferRangeStarts(const std::shared_ptr<Array>& starts,\n+                            const std::vector<ExpectedRange>& expected) {\n+  const std::shared_ptr<UInt64Array>& starts_uint64 =\n+      checked_pointer_cast<UInt64Array>(starts);\n+  std::unordered_map<int, uint64_t> previous_buffer_starts;\n+  ASSERT_NE(nullptr, starts_uint64);\n+  const uint64_t* starts_data = starts_uint64->raw_values();\n+  for (std::size_t i = 0; i < expected.size(); i++) {\n+    const auto& previous_buffer_start = previous_buffer_starts.find(expected[i].index);\n+    if (previous_buffer_start == previous_buffer_starts.end()) {\n+      previous_buffer_starts.insert({expected[i].index, starts_data[i]});\n+    } else {\n+      ASSERT_EQ(starts_data[i], previous_buffer_start->second);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void CheckBufferRanges(const std::shared_ptr<T>& input,\n+                       const std::vector<ExpectedRange>& expected) {\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> result, GetByteRanges(input));\n+  ValidateOutput(*result);\n+  std::shared_ptr<StructArray> result_struct = checked_pointer_cast<StructArray>(result);\n+  ASSERT_NE(nullptr, result_struct);\n+  AssertArraysEqual(*result_struct->field(1), *RangesToOffsets(expected));\n+  AssertArraysEqual(*result_struct->field(2), *RangesToLengths(expected));\n+  CheckBufferRangeStarts(result_struct->field(0), expected);\n+}\n+\n+template <typename T>\n+void CheckFixedWidthStarts(const std::shared_ptr<T>& input) {\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> result, GetByteRanges(input));\n+  ValidateOutput(*result);\n+  uint64_t expected_values_start =\n+      reinterpret_cast<uint64_t>(input->data()->buffers[1]->data());\n+  uint64_t expected_validity_start =\n+      reinterpret_cast<uint64_t>(input->null_bitmap_data());\n+  std::shared_ptr<StructArray> result_struct = checked_pointer_cast<StructArray>(result);\n+  const uint64_t* raw_starts =\n+      checked_pointer_cast<UInt64Array>(result_struct->field(0))->raw_values();\n+  ASSERT_EQ(expected_validity_start, raw_starts[0]);\n+  ASSERT_EQ(expected_values_start, raw_starts[1]);\n+}\n+\n+TEST(ByteRanges, StartValue) {\n+  std::shared_ptr<Array> bool_arr = ArrayFromJSON(\n+      boolean(), \"[true, true, true, null, null, null, true, true, true, true]\");\n+  CheckFixedWidthStarts(bool_arr);\n+  CheckFixedWidthStarts(bool_arr->Slice(9, 1));\n+\n+  std::shared_ptr<Array> ts_arr =\n+      ArrayFromJSON(timestamp(TimeUnit::SECOND),\n+                    R\"([\"1970-01-01\",\"2000-02-29\",\"3989-07-14\",\"1900-02-28\"])\");\n+  CheckFixedWidthStarts(bool_arr);\n+  CheckFixedWidthStarts(bool_arr->Slice(2, 1));\n+}\n+\n+TEST(ByteRanges, FixedWidthTypes) {\n+  std::shared_ptr<Array> bool_arr = ArrayFromJSON(\n+      boolean(), \"[true, true, true, null, null, null, true, true, true, true]\");\n+  CheckBufferRanges(bool_arr, {{0, 0, 2}, {1, 0, 2}});\n+  CheckBufferRanges(bool_arr->Slice(1, 8), {{0, 0, 2}, {1, 0, 2}});\n+  CheckBufferRanges(bool_arr->Slice(1, 5), {{0, 0, 1}, {1, 0, 1}});\n+  CheckBufferRanges(bool_arr->Slice(5, 5), {{0, 0, 2}, {1, 0, 2}});\n+  CheckBufferRanges(bool_arr->Slice(9, 1), {{0, 1, 1}, {1, 1, 1}});\n+\n+  std::shared_ptr<Array> bool_arr_no_validity = ArrayFromJSON(boolean(), \"[true, true]\");\n+  CheckBufferRanges(bool_arr_no_validity, {{0, 0, 1}});\n+\n+  std::shared_ptr<Array> fsb_arr =\n+      ArrayFromJSON(fixed_size_binary(4), R\"([\"foox\", \"barz\", null])\");\n+  CheckBufferRanges(fsb_arr, {{0, 0, 1}, {1, 0, 12}});\n+  CheckBufferRanges(fsb_arr->Slice(1, 1), {{0, 0, 1}, {1, 4, 4}});\n+}\n+\n+TEST(ByteRanges, DictionaryArray) {\n+  std::shared_ptr<Array> dict_arr =\n+      ArrayFromJSON(dictionary(int16(), utf8()), R\"([\"x\", \"abc\", \"x\", null])\");\n+  CheckBufferRanges(dict_arr, {{0, 0, 1}, {1, 0, 8}, {2, 0, 8}, {3, 0, 4}});\n+  CheckBufferRanges(dict_arr->Slice(2, 2), {{0, 0, 1}, {1, 4, 4}, {2, 0, 8}, {3, 0, 4}});\n+}\n+\n+template <typename Type>\n+class ByteRangesVariableBinary : public ::testing::Test {};\n+typedef ::testing::Types<StringType, LargeStringType, BinaryType, LargeBinaryType>\n+    VariableLengthBinaryTypes;\n\nReview comment:\n       Fixed.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-03T02:21:18.157+0000",
                    "updated": "2021-11-03T02:21:18.157+0000",
                    "started": "2021-11-03T02:21:18.157+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "674316",
                    "issueId": "13406868"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406868/worklog/674525",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on pull request #11542:\nURL: https://github.com/apache/arrow/pull/11542#issuecomment-958887877\n\n\n   I think I originally made it a kernel because in my mind \"array visitor\" implied kernel.  I've moved it out and into byte_size .h/.cc with the other utilities.  I also changed the utility functions to return a length instead of an array of ranges so I didn't have to concatenate.  I think this is ready for review again.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-03T10:45:29.910+0000",
                    "updated": "2021-11-03T10:45:29.910+0000",
                    "started": "2021-11-03T10:45:29.909+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "674525",
                    "issueId": "13406868"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406868/worklog/674583",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11542:\nURL: https://github.com/apache/arrow/pull/11542#discussion_r741888371\n\n\n\n##########\nFile path: cpp/src/arrow/util/byte_size.cc\n##########\n@@ -102,6 +108,282 @@ int64_t TotalBufferSize(const Table& table) {\n   return DoTotalBufferSize(table, &seen_buffers);\n }\n \n+namespace {\n+\n+struct GetByteRangesArray {\n+  const ArrayData& input;\n+  int64_t offset;\n+  int64_t length;\n+  UInt64Builder* range_starts;\n+  UInt64Builder* range_offsets;\n+  UInt64Builder* range_lengths;\n+\n+  Status VisitBitmap(const std::shared_ptr<Buffer>& buffer) const {\n+    if (buffer) {\n+      uint64_t data_start = reinterpret_cast<uint64_t>(buffer->data());\n+      RETURN_NOT_OK(range_starts->Append(data_start));\n+      RETURN_NOT_OK(range_offsets->Append(BitUtil::RoundDown(offset, 8) / 8));\n+      RETURN_NOT_OK(range_lengths->Append(BitUtil::CoveringBytes(offset, length)));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status VisitFixedWidthArray(const Buffer& buffer, const FixedWidthType& type) const {\n+    uint64_t data_start = reinterpret_cast<uint64_t>(buffer.data());\n+    uint64_t offset_bits = offset * type.bit_width();\n+    uint64_t offset_bytes = BitUtil::RoundDown(static_cast<int64_t>(offset_bits), 8) / 8;\n+    uint64_t end_byte =\n+        BitUtil::RoundUp(static_cast<int64_t>(offset_bits + (length * type.bit_width())),\n+                         8) /\n+        8;\n+    uint64_t length_bytes = (end_byte - offset_bytes);\n+    RETURN_NOT_OK(range_starts->Append(data_start));\n+    RETURN_NOT_OK(range_offsets->Append(offset_bytes));\n+    return range_lengths->Append(length_bytes);\n+  }\n+\n+  Status Visit(const FixedWidthType& type) const {\n+    static_assert(sizeof(uint8_t*) <= sizeof(uint64_t),\n+                  \"Undefined behavior if pointer larger than uint64_t\");\n+    RETURN_NOT_OK(VisitBitmap(input.buffers[0]));\n+    RETURN_NOT_OK(VisitFixedWidthArray(*input.buffers[1], type));\n+    if (input.dictionary) {\n+      // This is slightly imprecise because we always assume the entire dictionary is\n+      // referenced.  If this array has an offset it may only be referencing a portion of\n+      // the dictionary\n\nReview comment:\n       Even if there's no offset, the array may only reference a portion of the dictionary - so I don't think it's imprecise that we always count the entire dictionary.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-03T12:41:48.128+0000",
                    "updated": "2021-11-03T12:41:48.128+0000",
                    "started": "2021-11-03T12:41:48.128+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "674583",
                    "issueId": "13406868"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406868/worklog/674584",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm closed pull request #11542:\nURL: https://github.com/apache/arrow/pull/11542\n\n\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-03T12:42:21.503+0000",
                    "updated": "2021-11-03T12:42:21.503+0000",
                    "started": "2021-11-03T12:42:21.503+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "674584",
                    "issueId": "13406868"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406868/worklog/674585",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot commented on pull request #11542:\nURL: https://github.com/apache/arrow/pull/11542#issuecomment-958996202\n\n\n   Benchmark runs are scheduled for baseline = 96614116ccf15a488095dfbf7cb6f30e01878f3a and contender = 16af17c3327cfe624038913a7a808656082f69e0. 16af17c3327cfe624038913a7a808656082f69e0 is a master commit associated with this PR. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Scheduled] [ec2-t3-xlarge-us-east-2](https://conbench.ursa.dev/compare/runs/cc599c1b86d246d5b12d9fc5ef7db002...19187afe74e5437a98e4b34f526fd4e9/)\n   [Scheduled] [ursa-i9-9960x](https://conbench.ursa.dev/compare/runs/a2249907422e4576b7d826500086ce22...2709fd136f4a4438bc6a257d4a2a2c70/)\n   [Scheduled] [ursa-thinkcentre-m75q](https://conbench.ursa.dev/compare/runs/9de1125400744c02b20108a98f3bdda2...fe505e2d9b4d47b980fd9742b343f61a/)\n   Supported benchmarks:\n   ursa-i9-9960x: langs = Python, R, JavaScript\n   ursa-thinkcentre-m75q: langs = C++, Java\n   ec2-t3-xlarge-us-east-2: cloud = True\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-03T12:43:19.382+0000",
                    "updated": "2021-11-03T12:43:19.382+0000",
                    "started": "2021-11-03T12:43:19.381+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "674585",
                    "issueId": "13406868"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406868/worklog/674591",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #11542:\nURL: https://github.com/apache/arrow/pull/11542#discussion_r741903488\n\n\n\n##########\nFile path: cpp/src/arrow/util/byte_size.h\n##########\n@@ -36,18 +36,55 @@ namespace util {\n ///       only be counted once.\n int64_t ARROW_EXPORT TotalBufferSize(const ArrayData& array_data);\n /// \\brief The sum of bytes in each buffer referenced by the array\n-/// Note: The caveats on the ArrayData overload apply here as well\n+/// \\see TotalBufferSize(const ArrayData& array_data) for details\n int64_t ARROW_EXPORT TotalBufferSize(const Array& array);\n /// \\brief The sum of bytes in each buffer referenced by the array\n-/// Note: The caveats on the ArrayData overload apply here as well\n+/// \\see TotalBufferSize(const ArrayData& array_data) for details\n int64_t ARROW_EXPORT TotalBufferSize(const ChunkedArray& chunked_array);\n /// \\brief The sum of bytes in each buffer referenced by the batch\n-/// Note: The caveats on the ArrayData overload apply here as well\n+/// \\see TotalBufferSize(const ArrayData& array_data) for details\n int64_t ARROW_EXPORT TotalBufferSize(const RecordBatch& record_batch);\n /// \\brief The sum of bytes in each buffer referenced by the table\n-/// Note: The caveats on the ArrayData overload apply here as well\n+/// \\see TotalBufferSize(const ArrayData& array_data) for details\n int64_t ARROW_EXPORT TotalBufferSize(const Table& table);\n \n+/// \\brief Calculate the buffer ranges referenced by the array\n+///\n+/// These ranges will take into account array offsets\n+///\n+/// The ranges may contain duplicates\n+///\n+/// Dictionary arrays will ignore the offset of their containing array\n+///\n+/// The return value will be a struct array corresponding to the schema:\n+/// schema({field(\"start\", uint64()), field(\"offset\", uint64()), field(\"length\",\n+/// uint64()))\n\nReview comment:\n       It would have been nice to explain what \"start\", \"offset\" and \"length\" are.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-03T12:50:13.290+0000",
                    "updated": "2021-11-03T12:50:13.290+0000",
                    "started": "2021-11-03T12:50:13.290+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "674591",
                    "issueId": "13406868"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406868/worklog/674595",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot edited a comment on pull request #11542:\nURL: https://github.com/apache/arrow/pull/11542#issuecomment-958996202\n\n\n   Benchmark runs are scheduled for baseline = 96614116ccf15a488095dfbf7cb6f30e01878f3a and contender = 16af17c3327cfe624038913a7a808656082f69e0. 16af17c3327cfe624038913a7a808656082f69e0 is a master commit associated with this PR. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Finished :arrow_down:0.0% :arrow_up:0.0%] [ec2-t3-xlarge-us-east-2](https://conbench.ursa.dev/compare/runs/cc599c1b86d246d5b12d9fc5ef7db002...19187afe74e5437a98e4b34f526fd4e9/)\n   [Scheduled] [ursa-i9-9960x](https://conbench.ursa.dev/compare/runs/a2249907422e4576b7d826500086ce22...2709fd136f4a4438bc6a257d4a2a2c70/)\n   [Scheduled] [ursa-thinkcentre-m75q](https://conbench.ursa.dev/compare/runs/9de1125400744c02b20108a98f3bdda2...fe505e2d9b4d47b980fd9742b343f61a/)\n   Supported benchmarks:\n   ursa-i9-9960x: langs = Python, R, JavaScript\n   ursa-thinkcentre-m75q: langs = C++, Java\n   ec2-t3-xlarge-us-east-2: cloud = True\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-03T12:53:21.511+0000",
                    "updated": "2021-11-03T12:53:21.511+0000",
                    "started": "2021-11-03T12:53:21.511+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "674595",
                    "issueId": "13406868"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406868/worklog/674780",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot edited a comment on pull request #11542:\nURL: https://github.com/apache/arrow/pull/11542#issuecomment-958996202\n\n\n   Benchmark runs are scheduled for baseline = 96614116ccf15a488095dfbf7cb6f30e01878f3a and contender = 16af17c3327cfe624038913a7a808656082f69e0. 16af17c3327cfe624038913a7a808656082f69e0 is a master commit associated with this PR. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Finished :arrow_down:0.0% :arrow_up:0.0%] [ec2-t3-xlarge-us-east-2](https://conbench.ursa.dev/compare/runs/cc599c1b86d246d5b12d9fc5ef7db002...19187afe74e5437a98e4b34f526fd4e9/)\n   [Scheduled] [ursa-i9-9960x](https://conbench.ursa.dev/compare/runs/a2249907422e4576b7d826500086ce22...2709fd136f4a4438bc6a257d4a2a2c70/)\n   [Finished :arrow_down:0.31% :arrow_up:0.04%] [ursa-thinkcentre-m75q](https://conbench.ursa.dev/compare/runs/9de1125400744c02b20108a98f3bdda2...fe505e2d9b4d47b980fd9742b343f61a/)\n   Supported benchmarks:\n   ursa-i9-9960x: langs = Python, R, JavaScript\n   ursa-thinkcentre-m75q: langs = C++, Java\n   ec2-t3-xlarge-us-east-2: cloud = True\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-03T17:29:22.748+0000",
                    "updated": "2021-11-03T17:29:22.748+0000",
                    "started": "2021-11-03T17:29:22.748+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "674780",
                    "issueId": "13406868"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406868/worklog/674832",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot edited a comment on pull request #11542:\nURL: https://github.com/apache/arrow/pull/11542#issuecomment-958996202\n\n\n   Benchmark runs are scheduled for baseline = 96614116ccf15a488095dfbf7cb6f30e01878f3a and contender = 16af17c3327cfe624038913a7a808656082f69e0. 16af17c3327cfe624038913a7a808656082f69e0 is a master commit associated with this PR. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Finished :arrow_down:0.0% :arrow_up:0.0%] [ec2-t3-xlarge-us-east-2](https://conbench.ursa.dev/compare/runs/cc599c1b86d246d5b12d9fc5ef7db002...19187afe74e5437a98e4b34f526fd4e9/)\n   [Finished :arrow_down:0.0% :arrow_up:0.0%] [ursa-i9-9960x](https://conbench.ursa.dev/compare/runs/a2249907422e4576b7d826500086ce22...2709fd136f4a4438bc6a257d4a2a2c70/)\n   [Finished :arrow_down:0.31% :arrow_up:0.04%] [ursa-thinkcentre-m75q](https://conbench.ursa.dev/compare/runs/9de1125400744c02b20108a98f3bdda2...fe505e2d9b4d47b980fd9742b343f61a/)\n   Supported benchmarks:\n   ursa-i9-9960x: langs = Python, R, JavaScript\n   ursa-thinkcentre-m75q: langs = C++, Java\n   ec2-t3-xlarge-us-east-2: cloud = True\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-03T18:22:30.937+0000",
                    "updated": "2021-11-03T18:22:30.937+0000",
                    "started": "2021-11-03T18:22:30.937+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "674832",
                    "issueId": "13406868"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406868/worklog/674872",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #11542:\nURL: https://github.com/apache/arrow/pull/11542#discussion_r742261776\n\n\n\n##########\nFile path: cpp/src/arrow/util/byte_size.cc\n##########\n@@ -102,6 +108,282 @@ int64_t TotalBufferSize(const Table& table) {\n   return DoTotalBufferSize(table, &seen_buffers);\n }\n \n+namespace {\n+\n+struct GetByteRangesArray {\n+  const ArrayData& input;\n+  int64_t offset;\n+  int64_t length;\n+  UInt64Builder* range_starts;\n+  UInt64Builder* range_offsets;\n+  UInt64Builder* range_lengths;\n+\n+  Status VisitBitmap(const std::shared_ptr<Buffer>& buffer) const {\n+    if (buffer) {\n+      uint64_t data_start = reinterpret_cast<uint64_t>(buffer->data());\n+      RETURN_NOT_OK(range_starts->Append(data_start));\n+      RETURN_NOT_OK(range_offsets->Append(BitUtil::RoundDown(offset, 8) / 8));\n+      RETURN_NOT_OK(range_lengths->Append(BitUtil::CoveringBytes(offset, length)));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status VisitFixedWidthArray(const Buffer& buffer, const FixedWidthType& type) const {\n+    uint64_t data_start = reinterpret_cast<uint64_t>(buffer.data());\n+    uint64_t offset_bits = offset * type.bit_width();\n+    uint64_t offset_bytes = BitUtil::RoundDown(static_cast<int64_t>(offset_bits), 8) / 8;\n+    uint64_t end_byte =\n+        BitUtil::RoundUp(static_cast<int64_t>(offset_bits + (length * type.bit_width())),\n+                         8) /\n+        8;\n+    uint64_t length_bytes = (end_byte - offset_bytes);\n+    RETURN_NOT_OK(range_starts->Append(data_start));\n+    RETURN_NOT_OK(range_offsets->Append(offset_bytes));\n+    return range_lengths->Append(length_bytes);\n+  }\n+\n+  Status Visit(const FixedWidthType& type) const {\n+    static_assert(sizeof(uint8_t*) <= sizeof(uint64_t),\n+                  \"Undefined behavior if pointer larger than uint64_t\");\n+    RETURN_NOT_OK(VisitBitmap(input.buffers[0]));\n+    RETURN_NOT_OK(VisitFixedWidthArray(*input.buffers[1], type));\n+    if (input.dictionary) {\n+      // This is slightly imprecise because we always assume the entire dictionary is\n+      // referenced.  If this array has an offset it may only be referencing a portion of\n+      // the dictionary\n\nReview comment:\n       I see what you are saying but if we had some trick to easily account for it (without iterating through the data) I'd use it.  My goal here is for profiling so I'd like to understand how long it takes to move X bytes of data through the system.  My thinking of this measure is it is sort of a \"minimum bytes required to represent the data in the Arrow format\".  Ideally it should be consistent regardless of file format or row group configuration, etc.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-03T19:22:51.555+0000",
                    "updated": "2021-11-03T19:22:51.555+0000",
                    "started": "2021-11-03T19:22:51.555+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "674872",
                    "issueId": "13406868"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406868/worklog/675046",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on pull request #11542:\nURL: https://github.com/apache/arrow/pull/11542#issuecomment-958887877\n\n\n   I think I originally made it a kernel because in my mind \"array visitor\" implied kernel.  I've moved it out and into byte_size .h/.cc with the other utilities.  I also changed the utility functions to return a length instead of an array of ranges so I didn't have to concatenate.  I think this is ready for review again.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-04T00:05:05.674+0000",
                    "updated": "2021-11-04T00:05:05.674+0000",
                    "started": "2021-11-04T00:05:05.674+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "675046",
                    "issueId": "13406868"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406868/worklog/675093",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #11542:\nURL: https://github.com/apache/arrow/pull/11542#discussion_r741573603\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_buffer.cc\n##########\n@@ -0,0 +1,345 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <memory>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/array/builder_primitive.h\"\n+#include \"arrow/array/concatenate.h\"\n+#include \"arrow/buffer.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/function.h\"\n+#include \"arrow/compute/kernel.h\"\n+#include \"arrow/compute/registry.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/bit_util.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+struct GetByteRangesArray {\n+  const std::shared_ptr<ArrayData>& input;\n+  int64_t offset;\n+  int64_t length;\n+  UInt64Builder* range_starts;\n+  UInt64Builder* range_offsets;\n+  UInt64Builder* range_lengths;\n+\n+  Status VisitBitmap(const std::shared_ptr<Buffer>& buffer) {\n+    if (buffer) {\n+      uint64_t data_start = reinterpret_cast<uint64_t>(buffer->data());\n+      RETURN_NOT_OK(range_starts->Append(data_start));\n+      RETURN_NOT_OK(range_offsets->Append(BitUtil::RoundDown(offset, 8) / 8));\n+      RETURN_NOT_OK(range_lengths->Append(BitUtil::CoveringBytes(offset, length)));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status VisitFixedWidthArray(const Buffer& buffer, const FixedWidthType& type) {\n+    uint64_t data_start = reinterpret_cast<uint64_t>(buffer.data());\n+    uint64_t offset_bits = offset * type.bit_width();\n+    uint64_t offset_bytes = BitUtil::RoundDown(offset_bits, 8) / 8;\n+    uint64_t end_byte =\n+        BitUtil::RoundUp(offset_bits + (length * type.bit_width()), 8) / 8;\n+    uint64_t length_bytes = (end_byte - offset_bytes);\n+    RETURN_NOT_OK(range_starts->Append(data_start));\n+    RETURN_NOT_OK(range_offsets->Append(offset_bytes));\n+    return range_lengths->Append(length_bytes);\n+  }\n+\n+  Status Visit(const FixedWidthType& type) {\n+    static_assert(sizeof(uint8_t*) <= sizeof(uint64_t),\n+                  \"Undefined behavior if pointer larger than uint64_t\");\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+    RETURN_NOT_OK(VisitFixedWidthArray(*input->buffers[1], type));\n+    if (input->dictionary) {\n+      // This is slightly imprecise because we always assume the entire dictionary is\n+      // referenced.  If this array has an offset it may only be referencing a portion of\n+      // the dictionary\n+      GetByteRangesArray dict_visitor{input->dictionary,\n+                                      input->dictionary->offset,\n+                                      input->dictionary->length,\n+                                      range_starts,\n+                                      range_offsets,\n+                                      range_lengths};\n+      return VisitTypeInline(*input->dictionary->type, &dict_visitor);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const NullType& type) { return Status::OK(); }\n+\n+  template <typename BaseBinaryType>\n+  Status VisitBaseBinary(const BaseBinaryType& type) {\n+    using offset_type = typename BaseBinaryType::offset_type;\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+\n+    const Buffer& offsets_buffer = *input->buffers[1];\n+    RETURN_NOT_OK(\n+        range_starts->Append(reinterpret_cast<uint64_t>(offsets_buffer.data())));\n+    RETURN_NOT_OK(range_offsets->Append(sizeof(offset_type) * offset));\n+    RETURN_NOT_OK(range_lengths->Append(sizeof(offset_type) * length));\n+\n+    const offset_type* offsets = input->GetValues<offset_type>(1, offset);\n+    const Buffer& values = *input->buffers[2];\n+    offset_type start = offsets[0];\n+    offset_type end = offsets[length];\n+    RETURN_NOT_OK(range_starts->Append(reinterpret_cast<uint64_t>(values.data())));\n+    RETURN_NOT_OK(range_offsets->Append(static_cast<uint64_t>(start)));\n+    return range_lengths->Append(static_cast<uint64_t>(end - start));\n+  }\n+\n+  Status Visit(const BinaryType& type) { return VisitBaseBinary(type); }\n+\n+  Status Visit(const LargeBinaryType& type) { return VisitBaseBinary(type); }\n+\n+  template <typename BaseListType>\n+  Status VisitBaseList(const BaseListType& type) {\n+    using offset_type = typename BaseListType::offset_type;\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+\n+    const Buffer& offsets_buffer = *input->buffers[1];\n+    RETURN_NOT_OK(\n+        range_starts->Append(reinterpret_cast<uint64_t>(offsets_buffer.data())));\n+    RETURN_NOT_OK(range_offsets->Append(sizeof(offset_type) * offset));\n+    RETURN_NOT_OK(range_lengths->Append(sizeof(offset_type) * length));\n+\n+    const offset_type* offsets = input->GetValues<offset_type>(1, offset);\n+    int64_t start = static_cast<int64_t>(offsets[0]);\n+    int64_t end = static_cast<int64_t>(offsets[length]);\n+    GetByteRangesArray child{input->child_data[0], start,         end - start,\n+                             range_starts,         range_offsets, range_lengths};\n+    return VisitTypeInline(*type.value_type(), &child);\n+  }\n+\n+  Status Visit(const ListType& type) { return VisitBaseList(type); }\n+\n+  Status Visit(const LargeListType& type) { return VisitBaseList(type); }\n+\n+  Status Visit(const FixedSizeListType& type) {\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+    GetByteRangesArray child{input->child_data[0],\n+                             offset * type.list_size(),\n+                             length * type.list_size(),\n+                             range_starts,\n+                             range_offsets,\n+                             range_lengths};\n+    return VisitTypeInline(*type.value_type(), &child);\n+  }\n+\n+  Status Visit(const StructType& type) {\n+    for (int i = 0; i < type.num_fields(); i++) {\n+      GetByteRangesArray child{input->child_data[i],\n+                               offset + input->child_data[i]->offset,\n+                               length,\n+                               range_starts,\n+                               range_offsets,\n+                               range_lengths};\n+      RETURN_NOT_OK(VisitTypeInline(*type.field(i)->type(), &child));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const DenseUnionType& type) {\n+    // Skip validity map for DenseUnionType\n+    // Types buffer is always int8\n+    RETURN_NOT_OK(VisitFixedWidthArray(\n+        *input->buffers[1], *std::dynamic_pointer_cast<FixedWidthType>(int8())));\n+    // Offsets buffer is always int32\n+    RETURN_NOT_OK(VisitFixedWidthArray(\n+        *input->buffers[2], *std::dynamic_pointer_cast<FixedWidthType>(int32())));\n+\n+    // We have to loop through the types buffer to figure out the correct\n+    // offset / length being referenced in the child arrays\n+    std::array<std::size_t, UnionType::kMaxTypeCode> type_code_index_lookup;\n+    for (std::size_t i = 0; i < type.type_codes().size(); i++) {\n+      type_code_index_lookup[static_cast<std::size_t>(type.type_codes()[i])] = i;\n+    }\n+    std::vector<int64_t> lengths_per_type(type.type_codes().size());\n+    std::vector<int64_t> offsets_per_type(type.type_codes().size());\n+    const int8_t* type_codes = input->GetValues<int8_t>(1, 0);\n+    for (const int8_t* it = type_codes; it != type_codes + offset; it++) {\n+      offsets_per_type[type_code_index_lookup[static_cast<std::size_t>(*it)]]++;\n+    }\n+    for (const int8_t* it = type_codes + offset; it != type_codes + offset + length;\n+         it++) {\n+      lengths_per_type[type_code_index_lookup[static_cast<std::size_t>(*it)]]++;\n+    }\n+\n+    for (int i = 0; i < type.num_fields(); i++) {\n+      GetByteRangesArray child{\n+          input->child_data[i], offsets_per_type[i] + input->child_data[i]->offset,\n+          lengths_per_type[i],  range_starts,\n+          range_offsets,        range_lengths};\n+      RETURN_NOT_OK(VisitTypeInline(*type.field(i)->type(), &child));\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const SparseUnionType& type) {\n+    // Skip validity map for SparseUnionType\n+    // Types buffer is always int8\n+    RETURN_NOT_OK(VisitFixedWidthArray(\n+        *input->buffers[1], *std::dynamic_pointer_cast<FixedWidthType>(int8())));\n+\n+    for (int i = 0; i < type.num_fields(); i++) {\n+      GetByteRangesArray child{input->child_data[i],\n+                               offset + input->child_data[i]->offset,\n+                               length,\n+                               range_starts,\n+                               range_offsets,\n+                               range_lengths};\n+      RETURN_NOT_OK(VisitTypeInline(*type.field(i)->type(), &child));\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const ExtensionType& extension_type) {\n+    GetByteRangesArray storage{input,        offset,        length,\n+                               range_starts, range_offsets, range_lengths};\n+    return VisitTypeInline(*extension_type.storage_type(), &storage);\n+  }\n+\n+  Status Visit(const DataType& type) {\n+    return Status::TypeError(\"Extracting byte ranges not supported for type \",\n+                             type.ToString());\n+  }\n+\n+  static std::shared_ptr<DataType> RangesType() {\n+    return struct_(\n+        {field(\"start\", uint64()), field(\"offset\", uint64()), field(\"length\", uint64())});\n+  }\n+\n+  Result<std::shared_ptr<Array>> MakeRanges() {\n+    std::shared_ptr<Array> range_starts_arr, range_offsets_arr, range_lengths_arr;\n+    RETURN_NOT_OK(range_starts->Finish(&range_starts_arr));\n+    RETURN_NOT_OK(range_offsets->Finish(&range_offsets_arr));\n+    RETURN_NOT_OK(range_lengths->Finish(&range_lengths_arr));\n+    return StructArray::Make(\n+        {range_starts_arr, range_offsets_arr, range_lengths_arr},\n+        {field(\"start\", uint64()), field(\"offset\", uint64()), field(\"length\", uint64())});\n+  }\n+\n+  static Result<std::shared_ptr<Array>> Exec(const std::shared_ptr<ArrayData>& input) {\n+    UInt64Builder range_starts, range_offsets, range_lengths;\n+    GetByteRangesArray self{input,         input->offset,  input->length,\n+                            &range_starts, &range_offsets, &range_lengths};\n+    RETURN_NOT_OK(VisitTypeInline(*input->type, &self));\n+    return self.MakeRanges();\n+  }\n+};\n+\n+const FunctionDoc byte_ranges_doc(\n+    \"Returns an array of byte ranges referenced by the input\",\n+    (R\"(The output is a StructArray {\"start\": int64, \"offset\": int64, \"length\":)\"\n+     \" int64} where each item represents a range of memory addressed by buffers in\"\n+     \" the input.  The ranges should have no overlap even if buffers are shared in the\"\n+     \" input.  If any of the arrays are sliced zero-copy views of the data this method\"\n+     \" will return the sliced ranges that are referenced.  There is a slight exception\"\n+     \" in the case of dictionary arrays.  If a dictionary array is sliced we will still\"\n+     \" assume the entire dictionary is referenced by the sliced offsets array.  This\"\n+     \" will lead to overestimation if not all dictionary values are referenced.  If\"\n+     \" the first argument is a scalar this will return an empty array since there are no\"\n+     \" buffers referenced by the scalar.\"),\n+    {\"input\"});\n+\n+class ByteRangesMetaFunction : public MetaFunction {\n+ public:\n+  ByteRangesMetaFunction()\n+      : MetaFunction(\"byte_ranges\", Arity::Unary(), &byte_ranges_doc) {}\n+\n+  Result<Datum> ExecuteImpl(const std::vector<Datum>& args,\n+                            const FunctionOptions* options,\n+                            ExecContext* ctx) const override {\n+    DCHECK_GT(args.size(), 0);\n+    switch (args[0].kind()) {\n+      case Datum::SCALAR: {\n+        std::unique_ptr<ArrayBuilder> builder;\n+        RETURN_NOT_OK(\n+            MakeBuilder(ctx->memory_pool(), GetByteRangesArray::RangesType(), &builder));\n+        RETURN_NOT_OK(builder->Resize(0));\n+        return builder->Finish();\n+      }\n+      case Datum::ARRAY: {\n+        const std::shared_ptr<ArrayData>& array = args[0].array();\n+        DCHECK(array);\n+        return GetByteRangesArray::Exec(array);\n+      }\n+      case Datum::CHUNKED_ARRAY: {\n+        const std::shared_ptr<ChunkedArray>& chunked_array = args[0].chunked_array();\n+        DCHECK(chunked_array);\n+        ArrayVector chunks;\n+        for (const auto& chunk : chunked_array->chunks()) {\n+          ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Array> chunk_ranges,\n+                                GetByteRangesArray::Exec(chunk->data()));\n+          chunks.push_back(chunk_ranges);\n+        }\n+        return Concatenate(chunks, ctx->memory_pool());\n\nReview comment:\n       I moved this out of the compute layer and changed the functions to return lengths instead of arrays.  If someone needs all referenced ranges of a table they can cross that bridge when they come to it.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_buffer.cc\n##########\n@@ -0,0 +1,345 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <memory>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/array/builder_primitive.h\"\n+#include \"arrow/array/concatenate.h\"\n+#include \"arrow/buffer.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/function.h\"\n+#include \"arrow/compute/kernel.h\"\n+#include \"arrow/compute/registry.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/bit_util.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+struct GetByteRangesArray {\n+  const std::shared_ptr<ArrayData>& input;\n+  int64_t offset;\n+  int64_t length;\n+  UInt64Builder* range_starts;\n+  UInt64Builder* range_offsets;\n+  UInt64Builder* range_lengths;\n+\n+  Status VisitBitmap(const std::shared_ptr<Buffer>& buffer) {\n+    if (buffer) {\n+      uint64_t data_start = reinterpret_cast<uint64_t>(buffer->data());\n+      RETURN_NOT_OK(range_starts->Append(data_start));\n+      RETURN_NOT_OK(range_offsets->Append(BitUtil::RoundDown(offset, 8) / 8));\n+      RETURN_NOT_OK(range_lengths->Append(BitUtil::CoveringBytes(offset, length)));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status VisitFixedWidthArray(const Buffer& buffer, const FixedWidthType& type) {\n+    uint64_t data_start = reinterpret_cast<uint64_t>(buffer.data());\n+    uint64_t offset_bits = offset * type.bit_width();\n+    uint64_t offset_bytes = BitUtil::RoundDown(offset_bits, 8) / 8;\n+    uint64_t end_byte =\n+        BitUtil::RoundUp(offset_bits + (length * type.bit_width()), 8) / 8;\n+    uint64_t length_bytes = (end_byte - offset_bytes);\n+    RETURN_NOT_OK(range_starts->Append(data_start));\n+    RETURN_NOT_OK(range_offsets->Append(offset_bytes));\n+    return range_lengths->Append(length_bytes);\n+  }\n+\n+  Status Visit(const FixedWidthType& type) {\n+    static_assert(sizeof(uint8_t*) <= sizeof(uint64_t),\n+                  \"Undefined behavior if pointer larger than uint64_t\");\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+    RETURN_NOT_OK(VisitFixedWidthArray(*input->buffers[1], type));\n+    if (input->dictionary) {\n+      // This is slightly imprecise because we always assume the entire dictionary is\n+      // referenced.  If this array has an offset it may only be referencing a portion of\n+      // the dictionary\n+      GetByteRangesArray dict_visitor{input->dictionary,\n+                                      input->dictionary->offset,\n+                                      input->dictionary->length,\n+                                      range_starts,\n+                                      range_offsets,\n+                                      range_lengths};\n+      return VisitTypeInline(*input->dictionary->type, &dict_visitor);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const NullType& type) { return Status::OK(); }\n+\n+  template <typename BaseBinaryType>\n+  Status VisitBaseBinary(const BaseBinaryType& type) {\n+    using offset_type = typename BaseBinaryType::offset_type;\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+\n+    const Buffer& offsets_buffer = *input->buffers[1];\n+    RETURN_NOT_OK(\n+        range_starts->Append(reinterpret_cast<uint64_t>(offsets_buffer.data())));\n+    RETURN_NOT_OK(range_offsets->Append(sizeof(offset_type) * offset));\n+    RETURN_NOT_OK(range_lengths->Append(sizeof(offset_type) * length));\n+\n+    const offset_type* offsets = input->GetValues<offset_type>(1, offset);\n+    const Buffer& values = *input->buffers[2];\n+    offset_type start = offsets[0];\n+    offset_type end = offsets[length];\n+    RETURN_NOT_OK(range_starts->Append(reinterpret_cast<uint64_t>(values.data())));\n+    RETURN_NOT_OK(range_offsets->Append(static_cast<uint64_t>(start)));\n+    return range_lengths->Append(static_cast<uint64_t>(end - start));\n+  }\n+\n+  Status Visit(const BinaryType& type) { return VisitBaseBinary(type); }\n+\n+  Status Visit(const LargeBinaryType& type) { return VisitBaseBinary(type); }\n+\n+  template <typename BaseListType>\n+  Status VisitBaseList(const BaseListType& type) {\n+    using offset_type = typename BaseListType::offset_type;\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+\n+    const Buffer& offsets_buffer = *input->buffers[1];\n+    RETURN_NOT_OK(\n+        range_starts->Append(reinterpret_cast<uint64_t>(offsets_buffer.data())));\n+    RETURN_NOT_OK(range_offsets->Append(sizeof(offset_type) * offset));\n+    RETURN_NOT_OK(range_lengths->Append(sizeof(offset_type) * length));\n+\n+    const offset_type* offsets = input->GetValues<offset_type>(1, offset);\n+    int64_t start = static_cast<int64_t>(offsets[0]);\n+    int64_t end = static_cast<int64_t>(offsets[length]);\n+    GetByteRangesArray child{input->child_data[0], start,         end - start,\n+                             range_starts,         range_offsets, range_lengths};\n+    return VisitTypeInline(*type.value_type(), &child);\n+  }\n+\n+  Status Visit(const ListType& type) { return VisitBaseList(type); }\n+\n+  Status Visit(const LargeListType& type) { return VisitBaseList(type); }\n+\n+  Status Visit(const FixedSizeListType& type) {\n+    RETURN_NOT_OK(VisitBitmap(input->buffers[0]));\n+    GetByteRangesArray child{input->child_data[0],\n+                             offset * type.list_size(),\n+                             length * type.list_size(),\n+                             range_starts,\n+                             range_offsets,\n+                             range_lengths};\n+    return VisitTypeInline(*type.value_type(), &child);\n+  }\n+\n+  Status Visit(const StructType& type) {\n+    for (int i = 0; i < type.num_fields(); i++) {\n+      GetByteRangesArray child{input->child_data[i],\n+                               offset + input->child_data[i]->offset,\n+                               length,\n+                               range_starts,\n+                               range_offsets,\n+                               range_lengths};\n+      RETURN_NOT_OK(VisitTypeInline(*type.field(i)->type(), &child));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const DenseUnionType& type) {\n+    // Skip validity map for DenseUnionType\n+    // Types buffer is always int8\n+    RETURN_NOT_OK(VisitFixedWidthArray(\n+        *input->buffers[1], *std::dynamic_pointer_cast<FixedWidthType>(int8())));\n+    // Offsets buffer is always int32\n+    RETURN_NOT_OK(VisitFixedWidthArray(\n+        *input->buffers[2], *std::dynamic_pointer_cast<FixedWidthType>(int32())));\n+\n+    // We have to loop through the types buffer to figure out the correct\n+    // offset / length being referenced in the child arrays\n+    std::array<std::size_t, UnionType::kMaxTypeCode> type_code_index_lookup;\n\nReview comment:\n       You are right.  Thanks for the pointer.  I hadn't realized that.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_buffer_test.cc\n##########\n@@ -0,0 +1,382 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstdint>\n+#include <functional>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/array/builder_primitive.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/extension_type.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace compute {\n+\n+struct ExpectedRange {\n+  // The index of the expected buffer.  If an array shares buffers then multiple\n+  // ExpectedRange objects will have the same index.\n+  int index;\n+  // The start of the expected range, as an offset from the source buffer start\n+  uint64_t offset;\n+  uint64_t length;\n+};\n+\n+std::shared_ptr<Array> ExpectedRangesToArray(\n+    const std::vector<ExpectedRange>& ranges,\n+    std::function<uint64_t(const ExpectedRange&)> key_func) {\n+  UInt64Builder builder;\n+  for (const auto& range : ranges) {\n+    ARROW_EXPECT_OK(builder.Append(key_func(range)));\n+  }\n+  std::shared_ptr<Array> arr;\n+  ARROW_EXPECT_OK(builder.Finish(&arr));\n+  return arr;\n+}\n+\n+std::shared_ptr<Array> RangesToOffsets(const std::vector<ExpectedRange>& ranges) {\n+  return ExpectedRangesToArray(ranges,\n+                               [](const ExpectedRange& range) { return range.offset; });\n+}\n+\n+std::shared_ptr<Array> RangesToLengths(const std::vector<ExpectedRange>& ranges) {\n+  return ExpectedRangesToArray(ranges,\n+                               [](const ExpectedRange& range) { return range.length; });\n+}\n+\n+// We can't validate the buffer addresses exactly because they are unpredictable pointer\n+// values.  However, when multiple ranges come from the same buffer we can validate that\n+// the buffers are the same.\n+void CheckBufferRangeStarts(const std::shared_ptr<Array>& starts,\n+                            const std::vector<ExpectedRange>& expected) {\n+  const std::shared_ptr<UInt64Array>& starts_uint64 =\n+      checked_pointer_cast<UInt64Array>(starts);\n+  std::unordered_map<int, uint64_t> previous_buffer_starts;\n+  ASSERT_NE(nullptr, starts_uint64);\n+  const uint64_t* starts_data = starts_uint64->raw_values();\n+  for (std::size_t i = 0; i < expected.size(); i++) {\n+    const auto& previous_buffer_start = previous_buffer_starts.find(expected[i].index);\n+    if (previous_buffer_start == previous_buffer_starts.end()) {\n+      previous_buffer_starts.insert({expected[i].index, starts_data[i]});\n+    } else {\n+      ASSERT_EQ(starts_data[i], previous_buffer_start->second);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void CheckBufferRanges(const std::shared_ptr<T>& input,\n+                       const std::vector<ExpectedRange>& expected) {\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> result, GetByteRanges(input));\n+  ValidateOutput(*result);\n+  std::shared_ptr<StructArray> result_struct = checked_pointer_cast<StructArray>(result);\n+  ASSERT_NE(nullptr, result_struct);\n+  AssertArraysEqual(*result_struct->field(1), *RangesToOffsets(expected));\n+  AssertArraysEqual(*result_struct->field(2), *RangesToLengths(expected));\n+  CheckBufferRangeStarts(result_struct->field(0), expected);\n+}\n+\n+template <typename T>\n+void CheckFixedWidthStarts(const std::shared_ptr<T>& input) {\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> result, GetByteRanges(input));\n+  ValidateOutput(*result);\n+  uint64_t expected_values_start =\n+      reinterpret_cast<uint64_t>(input->data()->buffers[1]->data());\n+  uint64_t expected_validity_start =\n+      reinterpret_cast<uint64_t>(input->null_bitmap_data());\n+  std::shared_ptr<StructArray> result_struct = checked_pointer_cast<StructArray>(result);\n+  const uint64_t* raw_starts =\n+      checked_pointer_cast<UInt64Array>(result_struct->field(0))->raw_values();\n+  ASSERT_EQ(expected_validity_start, raw_starts[0]);\n+  ASSERT_EQ(expected_values_start, raw_starts[1]);\n+}\n+\n+TEST(ByteRanges, StartValue) {\n+  std::shared_ptr<Array> bool_arr = ArrayFromJSON(\n+      boolean(), \"[true, true, true, null, null, null, true, true, true, true]\");\n+  CheckFixedWidthStarts(bool_arr);\n+  CheckFixedWidthStarts(bool_arr->Slice(9, 1));\n+\n+  std::shared_ptr<Array> ts_arr =\n+      ArrayFromJSON(timestamp(TimeUnit::SECOND),\n+                    R\"([\"1970-01-01\",\"2000-02-29\",\"3989-07-14\",\"1900-02-28\"])\");\n+  CheckFixedWidthStarts(bool_arr);\n+  CheckFixedWidthStarts(bool_arr->Slice(2, 1));\n\nReview comment:\n       Yep, good catch.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_buffer_test.cc\n##########\n@@ -0,0 +1,382 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstdint>\n+#include <functional>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/array/builder_primitive.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/extension_type.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace compute {\n+\n+struct ExpectedRange {\n+  // The index of the expected buffer.  If an array shares buffers then multiple\n+  // ExpectedRange objects will have the same index.\n+  int index;\n+  // The start of the expected range, as an offset from the source buffer start\n+  uint64_t offset;\n+  uint64_t length;\n+};\n+\n+std::shared_ptr<Array> ExpectedRangesToArray(\n+    const std::vector<ExpectedRange>& ranges,\n+    std::function<uint64_t(const ExpectedRange&)> key_func) {\n+  UInt64Builder builder;\n+  for (const auto& range : ranges) {\n+    ARROW_EXPECT_OK(builder.Append(key_func(range)));\n+  }\n+  std::shared_ptr<Array> arr;\n+  ARROW_EXPECT_OK(builder.Finish(&arr));\n+  return arr;\n+}\n+\n+std::shared_ptr<Array> RangesToOffsets(const std::vector<ExpectedRange>& ranges) {\n+  return ExpectedRangesToArray(ranges,\n+                               [](const ExpectedRange& range) { return range.offset; });\n+}\n+\n+std::shared_ptr<Array> RangesToLengths(const std::vector<ExpectedRange>& ranges) {\n+  return ExpectedRangesToArray(ranges,\n+                               [](const ExpectedRange& range) { return range.length; });\n+}\n+\n+// We can't validate the buffer addresses exactly because they are unpredictable pointer\n+// values.  However, when multiple ranges come from the same buffer we can validate that\n+// the buffers are the same.\n+void CheckBufferRangeStarts(const std::shared_ptr<Array>& starts,\n+                            const std::vector<ExpectedRange>& expected) {\n+  const std::shared_ptr<UInt64Array>& starts_uint64 =\n+      checked_pointer_cast<UInt64Array>(starts);\n+  std::unordered_map<int, uint64_t> previous_buffer_starts;\n+  ASSERT_NE(nullptr, starts_uint64);\n+  const uint64_t* starts_data = starts_uint64->raw_values();\n+  for (std::size_t i = 0; i < expected.size(); i++) {\n+    const auto& previous_buffer_start = previous_buffer_starts.find(expected[i].index);\n+    if (previous_buffer_start == previous_buffer_starts.end()) {\n+      previous_buffer_starts.insert({expected[i].index, starts_data[i]});\n+    } else {\n+      ASSERT_EQ(starts_data[i], previous_buffer_start->second);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void CheckBufferRanges(const std::shared_ptr<T>& input,\n+                       const std::vector<ExpectedRange>& expected) {\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> result, GetByteRanges(input));\n+  ValidateOutput(*result);\n+  std::shared_ptr<StructArray> result_struct = checked_pointer_cast<StructArray>(result);\n+  ASSERT_NE(nullptr, result_struct);\n+  AssertArraysEqual(*result_struct->field(1), *RangesToOffsets(expected));\n+  AssertArraysEqual(*result_struct->field(2), *RangesToLengths(expected));\n+  CheckBufferRangeStarts(result_struct->field(0), expected);\n+}\n+\n+template <typename T>\n+void CheckFixedWidthStarts(const std::shared_ptr<T>& input) {\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> result, GetByteRanges(input));\n+  ValidateOutput(*result);\n+  uint64_t expected_values_start =\n+      reinterpret_cast<uint64_t>(input->data()->buffers[1]->data());\n+  uint64_t expected_validity_start =\n+      reinterpret_cast<uint64_t>(input->null_bitmap_data());\n+  std::shared_ptr<StructArray> result_struct = checked_pointer_cast<StructArray>(result);\n+  const uint64_t* raw_starts =\n+      checked_pointer_cast<UInt64Array>(result_struct->field(0))->raw_values();\n+  ASSERT_EQ(expected_validity_start, raw_starts[0]);\n+  ASSERT_EQ(expected_values_start, raw_starts[1]);\n+}\n+\n+TEST(ByteRanges, StartValue) {\n+  std::shared_ptr<Array> bool_arr = ArrayFromJSON(\n+      boolean(), \"[true, true, true, null, null, null, true, true, true, true]\");\n+  CheckFixedWidthStarts(bool_arr);\n+  CheckFixedWidthStarts(bool_arr->Slice(9, 1));\n+\n+  std::shared_ptr<Array> ts_arr =\n+      ArrayFromJSON(timestamp(TimeUnit::SECOND),\n+                    R\"([\"1970-01-01\",\"2000-02-29\",\"3989-07-14\",\"1900-02-28\"])\");\n+  CheckFixedWidthStarts(bool_arr);\n+  CheckFixedWidthStarts(bool_arr->Slice(2, 1));\n+}\n+\n+TEST(ByteRanges, FixedWidthTypes) {\n+  std::shared_ptr<Array> bool_arr = ArrayFromJSON(\n+      boolean(), \"[true, true, true, null, null, null, true, true, true, true]\");\n+  CheckBufferRanges(bool_arr, {{0, 0, 2}, {1, 0, 2}});\n+  CheckBufferRanges(bool_arr->Slice(1, 8), {{0, 0, 2}, {1, 0, 2}});\n+  CheckBufferRanges(bool_arr->Slice(1, 5), {{0, 0, 1}, {1, 0, 1}});\n+  CheckBufferRanges(bool_arr->Slice(5, 5), {{0, 0, 2}, {1, 0, 2}});\n+  CheckBufferRanges(bool_arr->Slice(9, 1), {{0, 1, 1}, {1, 1, 1}});\n+\n+  std::shared_ptr<Array> bool_arr_no_validity = ArrayFromJSON(boolean(), \"[true, true]\");\n+  CheckBufferRanges(bool_arr_no_validity, {{0, 0, 1}});\n+\n+  std::shared_ptr<Array> fsb_arr =\n+      ArrayFromJSON(fixed_size_binary(4), R\"([\"foox\", \"barz\", null])\");\n+  CheckBufferRanges(fsb_arr, {{0, 0, 1}, {1, 0, 12}});\n+  CheckBufferRanges(fsb_arr->Slice(1, 1), {{0, 0, 1}, {1, 4, 4}});\n+}\n+\n+TEST(ByteRanges, DictionaryArray) {\n+  std::shared_ptr<Array> dict_arr =\n+      ArrayFromJSON(dictionary(int16(), utf8()), R\"([\"x\", \"abc\", \"x\", null])\");\n+  CheckBufferRanges(dict_arr, {{0, 0, 1}, {1, 0, 8}, {2, 0, 8}, {3, 0, 4}});\n+  CheckBufferRanges(dict_arr->Slice(2, 2), {{0, 0, 1}, {1, 4, 4}, {2, 0, 8}, {3, 0, 4}});\n+}\n+\n+template <typename Type>\n+class ByteRangesVariableBinary : public ::testing::Test {};\n+typedef ::testing::Types<StringType, LargeStringType, BinaryType, LargeBinaryType>\n+    VariableLengthBinaryTypes;\n\nReview comment:\n       Fixed.\n\n##########\nFile path: cpp/src/arrow/util/byte_size.cc\n##########\n@@ -102,6 +108,282 @@ int64_t TotalBufferSize(const Table& table) {\n   return DoTotalBufferSize(table, &seen_buffers);\n }\n \n+namespace {\n+\n+struct GetByteRangesArray {\n+  const ArrayData& input;\n+  int64_t offset;\n+  int64_t length;\n+  UInt64Builder* range_starts;\n+  UInt64Builder* range_offsets;\n+  UInt64Builder* range_lengths;\n+\n+  Status VisitBitmap(const std::shared_ptr<Buffer>& buffer) const {\n+    if (buffer) {\n+      uint64_t data_start = reinterpret_cast<uint64_t>(buffer->data());\n+      RETURN_NOT_OK(range_starts->Append(data_start));\n+      RETURN_NOT_OK(range_offsets->Append(BitUtil::RoundDown(offset, 8) / 8));\n+      RETURN_NOT_OK(range_lengths->Append(BitUtil::CoveringBytes(offset, length)));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status VisitFixedWidthArray(const Buffer& buffer, const FixedWidthType& type) const {\n+    uint64_t data_start = reinterpret_cast<uint64_t>(buffer.data());\n+    uint64_t offset_bits = offset * type.bit_width();\n+    uint64_t offset_bytes = BitUtil::RoundDown(static_cast<int64_t>(offset_bits), 8) / 8;\n+    uint64_t end_byte =\n+        BitUtil::RoundUp(static_cast<int64_t>(offset_bits + (length * type.bit_width())),\n+                         8) /\n+        8;\n+    uint64_t length_bytes = (end_byte - offset_bytes);\n+    RETURN_NOT_OK(range_starts->Append(data_start));\n+    RETURN_NOT_OK(range_offsets->Append(offset_bytes));\n+    return range_lengths->Append(length_bytes);\n+  }\n+\n+  Status Visit(const FixedWidthType& type) const {\n+    static_assert(sizeof(uint8_t*) <= sizeof(uint64_t),\n+                  \"Undefined behavior if pointer larger than uint64_t\");\n+    RETURN_NOT_OK(VisitBitmap(input.buffers[0]));\n+    RETURN_NOT_OK(VisitFixedWidthArray(*input.buffers[1], type));\n+    if (input.dictionary) {\n+      // This is slightly imprecise because we always assume the entire dictionary is\n+      // referenced.  If this array has an offset it may only be referencing a portion of\n+      // the dictionary\n\nReview comment:\n       I see what you are saying but if we had some trick to easily account for it (without iterating through the data) I'd use it.  My goal here is for profiling so I'd like to understand how long it takes to move X bytes of data through the system.  My thinking of this measure is it is sort of a \"minimum bytes required to represent the data in the Arrow format\".  Ideally it should be consistent regardless of file format or row group configuration, etc.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-04T00:10:18.593+0000",
                    "updated": "2021-11-04T00:10:18.593+0000",
                    "started": "2021-11-04T00:10:18.593+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "675093",
                    "issueId": "13406868"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406868/worklog/675272",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #11542:\nURL: https://github.com/apache/arrow/pull/11542#discussion_r741903488\n\n\n\n##########\nFile path: cpp/src/arrow/util/byte_size.h\n##########\n@@ -36,18 +36,55 @@ namespace util {\n ///       only be counted once.\n int64_t ARROW_EXPORT TotalBufferSize(const ArrayData& array_data);\n /// \\brief The sum of bytes in each buffer referenced by the array\n-/// Note: The caveats on the ArrayData overload apply here as well\n+/// \\see TotalBufferSize(const ArrayData& array_data) for details\n int64_t ARROW_EXPORT TotalBufferSize(const Array& array);\n /// \\brief The sum of bytes in each buffer referenced by the array\n-/// Note: The caveats on the ArrayData overload apply here as well\n+/// \\see TotalBufferSize(const ArrayData& array_data) for details\n int64_t ARROW_EXPORT TotalBufferSize(const ChunkedArray& chunked_array);\n /// \\brief The sum of bytes in each buffer referenced by the batch\n-/// Note: The caveats on the ArrayData overload apply here as well\n+/// \\see TotalBufferSize(const ArrayData& array_data) for details\n int64_t ARROW_EXPORT TotalBufferSize(const RecordBatch& record_batch);\n /// \\brief The sum of bytes in each buffer referenced by the table\n-/// Note: The caveats on the ArrayData overload apply here as well\n+/// \\see TotalBufferSize(const ArrayData& array_data) for details\n int64_t ARROW_EXPORT TotalBufferSize(const Table& table);\n \n+/// \\brief Calculate the buffer ranges referenced by the array\n+///\n+/// These ranges will take into account array offsets\n+///\n+/// The ranges may contain duplicates\n+///\n+/// Dictionary arrays will ignore the offset of their containing array\n+///\n+/// The return value will be a struct array corresponding to the schema:\n+/// schema({field(\"start\", uint64()), field(\"offset\", uint64()), field(\"length\",\n+/// uint64()))\n\nReview comment:\n       It would have been nice to explain what \"start\", \"offset\" and \"length\" are.\n\n##########\nFile path: cpp/src/arrow/util/byte_size.h\n##########\n@@ -36,18 +36,55 @@ namespace util {\n ///       only be counted once.\n int64_t ARROW_EXPORT TotalBufferSize(const ArrayData& array_data);\n /// \\brief The sum of bytes in each buffer referenced by the array\n-/// Note: The caveats on the ArrayData overload apply here as well\n+/// \\see TotalBufferSize(const ArrayData& array_data) for details\n int64_t ARROW_EXPORT TotalBufferSize(const Array& array);\n /// \\brief The sum of bytes in each buffer referenced by the array\n-/// Note: The caveats on the ArrayData overload apply here as well\n+/// \\see TotalBufferSize(const ArrayData& array_data) for details\n int64_t ARROW_EXPORT TotalBufferSize(const ChunkedArray& chunked_array);\n /// \\brief The sum of bytes in each buffer referenced by the batch\n-/// Note: The caveats on the ArrayData overload apply here as well\n+/// \\see TotalBufferSize(const ArrayData& array_data) for details\n int64_t ARROW_EXPORT TotalBufferSize(const RecordBatch& record_batch);\n /// \\brief The sum of bytes in each buffer referenced by the table\n-/// Note: The caveats on the ArrayData overload apply here as well\n+/// \\see TotalBufferSize(const ArrayData& array_data) for details\n int64_t ARROW_EXPORT TotalBufferSize(const Table& table);\n \n+/// \\brief Calculate the buffer ranges referenced by the array\n+///\n+/// These ranges will take into account array offsets\n+///\n+/// The ranges may contain duplicates\n+///\n+/// Dictionary arrays will ignore the offset of their containing array\n+///\n+/// The return value will be a struct array corresponding to the schema:\n+/// schema({field(\"start\", uint64()), field(\"offset\", uint64()), field(\"length\",\n+/// uint64()))\n\nReview comment:\n       It would have been nice to explain what \"start\", \"offset\" and \"length\" are.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-04T00:35:28.689+0000",
                    "updated": "2021-11-04T00:35:28.689+0000",
                    "started": "2021-11-04T00:35:28.688+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "675272",
                    "issueId": "13406868"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 19800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@7cc59d5b[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@72702c9e[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@dd680cc[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@7eb14934[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1d9af29c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@faa0a11[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@36c33bc8[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@42cf3ccd[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@88b281a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@572e5198[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@789c3dce[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@438e5f44[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 19800,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Nov 03 12:42:17 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-11-03T12:42:17.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-14356/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2021-10-16T01:39:31.000+0000",
        "updated": "2021-11-04T01:49:22.000+0000",
        "timeoriginalestimate": null,
        "description": "It is difficult to calculate the size (in bytes) of an array that has offsets because offsets are \"# of values\" there is no type-erased way to known how many bytes each value occupies.\r\n",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "5.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 19800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Create kernel to determine buffer memory \"referenced\" by arrays (even if there are offsets)",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406868/comment/17438034",
                    "id": "17438034",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 11542\n[https://github.com/apache/arrow/pull/11542]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-11-03T12:42:17.852+0000",
                    "updated": "2021-11-03T12:42:17.852+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0vwc0:",
        "customfield_12314139": null
    }
}