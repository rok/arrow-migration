{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13233878",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13233878",
    "key": "ARROW-5358",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12345978",
                "id": "12345978",
                "description": "",
                "name": "0.15.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-10-05"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=csun",
            "name": "csun",
            "key": "csun",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=csun&avatarId=23340",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=csun&avatarId=23340",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=csun&avatarId=23340",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=csun&avatarId=23340"
            },
            "displayName": "Chao Sun",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333773",
                "id": "12333773",
                "name": "Rust"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=csun",
            "name": "csun",
            "key": "csun",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=csun&avatarId=23340",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=csun&avatarId=23340",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=csun&avatarId=23340",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=csun&avatarId=23340"
            },
            "displayName": "Chao Sun",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=csun",
            "name": "csun",
            "key": "csun",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=csun&avatarId=23340",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=csun&avatarId=23340",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=csun&avatarId=23340",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=csun&avatarId=23340"
            },
            "displayName": "Chao Sun",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 16800,
            "total": 16800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 16800,
            "total": 16800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-5358/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 29,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13233878/worklog/264410",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on pull request #4643: ARROW-5358: [Rust] Implement equality check for ArrayData and Array\nURL: https://github.com/apache/arrow/pull/4643\n \n \n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-21T07:13:10.571+0000",
                    "updated": "2019-06-21T07:13:10.571+0000",
                    "started": "2019-06-21T07:13:10.571+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "264410",
                    "issueId": "13233878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13233878/worklog/264702",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on issue #4643: ARROW-5358: [Rust] Implement equality check for ArrayData and Array\nURL: https://github.com/apache/arrow/pull/4643#issuecomment-504458157\n \n \n   cc @nevi-me @andygrove @paddyhoran @liurenjie1024 would you great if you can take a look.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-21T15:01:21.132+0000",
                    "updated": "2019-06-21T15:01:21.132+0000",
                    "started": "2019-06-21T15:01:21.131+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "264702",
                    "issueId": "13233878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13233878/worklog/265162",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liurenjie1024 commented on pull request #4643: ARROW-5358: [Rust] Implement equality check for ArrayData and Array\nURL: https://github.com/apache/arrow/pull/4643#discussion_r296431232\n \n \n\n ##########\n File path: rust/arrow/src/array_equal.rs\n ##########\n @@ -0,0 +1,751 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::array::*;\n+use crate::array_data::*;\n+use crate::datatypes::*;\n+use crate::util::bit_util;\n+\n+/// Trait for `Array` equality.\n+pub trait ArrayEqual {\n+    /// Returns true if this array is equal to the `other` array\n+    fn equals(&self, other: &dyn Array) -> bool;\n+\n+    /// Returns true if the range [start_idx, end_idx) is equal to\n+    /// [other_start_idx, other_start_idx + end_idx - start_idx) in the `other` array\n+    fn range_equals(\n+        &self,\n+        other: &dyn Array,\n+        start_idx: usize,\n+        end_idx: usize,\n+        other_start_idx: usize,\n+    ) -> bool;\n+}\n+\n+impl<T: ArrowPrimitiveType> ArrayEqual for PrimitiveArray<T> {\n+    default fn equals(&self, other: &dyn Array) -> bool {\n+        if !base_equal(&self.data(), &other.data()) {\n+            return false;\n+        }\n+\n+        let value_buf = self.data_ref().buffers()[0].clone();\n+        let other_value_buf = other.data_ref().buffers()[0].clone();\n+        let byte_width = T::get_bit_width() / 8;\n+\n+        if self.null_count() > 0 {\n+            let values = value_buf.data();\n \n Review comment:\n   For primitive types, maybe we can use the as_slice method I recently added for comparision?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-22T02:36:20.301+0000",
                    "updated": "2019-06-22T02:36:20.301+0000",
                    "started": "2019-06-22T02:36:20.300+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "265162",
                    "issueId": "13233878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13233878/worklog/265163",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liurenjie1024 commented on pull request #4643: ARROW-5358: [Rust] Implement equality check for ArrayData and Array\nURL: https://github.com/apache/arrow/pull/4643#discussion_r296431358\n \n \n\n ##########\n File path: rust/arrow/src/array_equal.rs\n ##########\n @@ -0,0 +1,751 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::array::*;\n+use crate::array_data::*;\n+use crate::datatypes::*;\n+use crate::util::bit_util;\n+\n+/// Trait for `Array` equality.\n+pub trait ArrayEqual {\n+    /// Returns true if this array is equal to the `other` array\n+    fn equals(&self, other: &dyn Array) -> bool;\n+\n+    /// Returns true if the range [start_idx, end_idx) is equal to\n+    /// [other_start_idx, other_start_idx + end_idx - start_idx) in the `other` array\n+    fn range_equals(\n+        &self,\n+        other: &dyn Array,\n+        start_idx: usize,\n+        end_idx: usize,\n+        other_start_idx: usize,\n+    ) -> bool;\n+}\n+\n+impl<T: ArrowPrimitiveType> ArrayEqual for PrimitiveArray<T> {\n+    default fn equals(&self, other: &dyn Array) -> bool {\n+        if !base_equal(&self.data(), &other.data()) {\n+            return false;\n+        }\n+\n+        let value_buf = self.data_ref().buffers()[0].clone();\n+        let other_value_buf = other.data_ref().buffers()[0].clone();\n+        let byte_width = T::get_bit_width() / 8;\n+\n+        if self.null_count() > 0 {\n+            let values = value_buf.data();\n+            let other_values = other_value_buf.data();\n+\n+            for i in 0..self.len() {\n+                if self.is_valid(i) {\n+                    let start = (i + self.offset()) * byte_width;\n+                    let data = &values[start..(start + byte_width)];\n+                    let other_start = (i + other.offset()) * byte_width;\n+                    let other_data =\n+                        &other_values[other_start..(other_start + byte_width)];\n+                    if data != other_data {\n+                        return false;\n+                    }\n+                }\n+            }\n+        } else {\n+            let start = self.offset() * byte_width;\n+            let other_start = other.offset() * byte_width;\n+            let len = self.len() * byte_width;\n+            let data = &value_buf.data()[start..(start + len)];\n+            let other_data = &other_value_buf.data()[other_start..(other_start + len)];\n+            if data != other_data {\n+                return false;\n+            }\n+        }\n+\n+        true\n+    }\n+\n+    default fn range_equals(\n+        &self,\n+        other: &dyn Array,\n+        start_idx: usize,\n+        end_idx: usize,\n+        other_start_idx: usize,\n+    ) -> bool {\n+        let other = other.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n \n Review comment:\n   Should we check validity of index range at beginning of method so that we can make error message clearer?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-22T02:36:20.323+0000",
                    "updated": "2019-06-22T02:36:20.323+0000",
                    "started": "2019-06-22T02:36:20.322+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "265163",
                    "issueId": "13233878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13233878/worklog/265164",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liurenjie1024 commented on pull request #4643: ARROW-5358: [Rust] Implement equality check for ArrayData and Array\nURL: https://github.com/apache/arrow/pull/4643#discussion_r296431111\n \n \n\n ##########\n File path: rust/arrow/src/array.rs\n ##########\n @@ -234,6 +235,42 @@ pub struct PrimitiveArray<T: ArrowPrimitiveType> {\n     raw_values: RawPtrBox<T::Native>,\n }\n \n+/// Common operations for primitive types, including numeric types and boolean type.\n+pub trait PrimitiveArrayOps<T: ArrowPrimitiveType> {\n+    fn values(&self) -> Buffer;\n+    fn value(&self, i: usize) -> T::Native;\n+}\n+\n+impl<T: ArrowPrimitiveType> PrimitiveArrayOps<T> for PrimitiveArray<T> {\n+    default fn values(&self) -> Buffer {\n+        unimplemented!()\n+    }\n+\n+    default fn value(&self, _: usize) -> T::Native {\n+        unimplemented!()\n+    }\n+}\n+\n+impl<T: ArrowNumericType> PrimitiveArrayOps<T> for PrimitiveArray<T> {\n+    fn values(&self) -> Buffer {\n+        self.values()\n+    }\n+\n+    fn value(&self, i: usize) -> T::Native {\n+        self.value(i)\n+    }\n+}\n+\n+impl PrimitiveArrayOps<BooleanType> for BooleanArray {\n+    fn values(&self) -> Buffer {\n+        self.values()\n \n Review comment:\n   The implementation of boolean type is same to numeric type, why we need another implementation block?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-22T02:36:20.824+0000",
                    "updated": "2019-06-22T02:36:20.824+0000",
                    "started": "2019-06-22T02:36:20.823+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "265164",
                    "issueId": "13233878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13233878/worklog/265165",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liurenjie1024 commented on pull request #4643: ARROW-5358: [Rust] Implement equality check for ArrayData and Array\nURL: https://github.com/apache/arrow/pull/4643#discussion_r296431188\n \n \n\n ##########\n File path: rust/arrow/src/array_equal.rs\n ##########\n @@ -0,0 +1,751 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::array::*;\n+use crate::array_data::*;\n+use crate::datatypes::*;\n+use crate::util::bit_util;\n+\n+/// Trait for `Array` equality.\n+pub trait ArrayEqual {\n+    /// Returns true if this array is equal to the `other` array\n+    fn equals(&self, other: &dyn Array) -> bool;\n \n Review comment:\n   Would it be better if we make ArrayEqual extend PartialEq? \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-22T02:36:21.228+0000",
                    "updated": "2019-06-22T02:36:21.228+0000",
                    "started": "2019-06-22T02:36:21.227+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "265165",
                    "issueId": "13233878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13233878/worklog/265166",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liurenjie1024 commented on pull request #4643: ARROW-5358: [Rust] Implement equality check for ArrayData and Array\nURL: https://github.com/apache/arrow/pull/4643#discussion_r296431158\n \n \n\n ##########\n File path: rust/arrow/src/array.rs\n ##########\n @@ -971,6 +1034,11 @@ impl StructArray {\n     pub fn column(&self, pos: usize) -> &ArrayRef {\n         &self.boxed_fields[pos]\n     }\n+\n+    /// Return the number of fields in this struct array\n+    pub fn num_columns(&self) -> usize {\n \n Review comment:\n   Maybe num_children is a better name?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-22T02:36:25.153+0000",
                    "updated": "2019-06-22T02:36:25.153+0000",
                    "started": "2019-06-22T02:36:25.153+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "265166",
                    "issueId": "13233878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13233878/worklog/265167",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liurenjie1024 commented on issue #4643: ARROW-5358: [Rust] Implement equality check for ArrayData and Array\nURL: https://github.com/apache/arrow/pull/4643#issuecomment-504619888\n \n \n   @sunchao This is a great PR. Just left some improvement suggestions.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-22T02:37:16.532+0000",
                    "updated": "2019-06-22T02:37:16.532+0000",
                    "started": "2019-06-22T02:37:16.531+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "265167",
                    "issueId": "13233878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13233878/worklog/265271",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "agrove-rms commented on pull request #4643: ARROW-5358: [Rust] Implement equality check for ArrayData and Array\nURL: https://github.com/apache/arrow/pull/4643#discussion_r296444996\n \n \n\n ##########\n File path: rust/arrow/src/array.rs\n ##########\n @@ -848,6 +901,16 @@ impl BinaryArray {\n         self.value_offset_at(i + 1) - self.value_offset_at(i)\n     }\n \n+    /// Returns a reference of the value offset buffer\n \n Review comment:\n   The comment says this is returning a reference, but the implementation is using `clone` and not returning a reference. This is confusing.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-22T12:59:19.762+0000",
                    "updated": "2019-06-22T12:59:19.762+0000",
                    "started": "2019-06-22T12:59:19.762+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "265271",
                    "issueId": "13233878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13233878/worklog/265272",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "agrove-rms commented on pull request #4643: ARROW-5358: [Rust] Implement equality check for ArrayData and Array\nURL: https://github.com/apache/arrow/pull/4643#discussion_r296445037\n \n \n\n ##########\n File path: rust/arrow/src/array_equal.rs\n ##########\n @@ -0,0 +1,751 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::array::*;\n+use crate::array_data::*;\n+use crate::datatypes::*;\n+use crate::util::bit_util;\n+\n+/// Trait for `Array` equality.\n+pub trait ArrayEqual {\n+    /// Returns true if this array is equal to the `other` array\n+    fn equals(&self, other: &dyn Array) -> bool;\n+\n+    /// Returns true if the range [start_idx, end_idx) is equal to\n+    /// [other_start_idx, other_start_idx + end_idx - start_idx) in the `other` array\n+    fn range_equals(\n+        &self,\n+        other: &dyn Array,\n+        start_idx: usize,\n+        end_idx: usize,\n+        other_start_idx: usize,\n+    ) -> bool;\n+}\n+\n+impl<T: ArrowPrimitiveType> ArrayEqual for PrimitiveArray<T> {\n+    default fn equals(&self, other: &dyn Array) -> bool {\n+        if !base_equal(&self.data(), &other.data()) {\n+            return false;\n+        }\n+\n+        let value_buf = self.data_ref().buffers()[0].clone();\n+        let other_value_buf = other.data_ref().buffers()[0].clone();\n+        let byte_width = T::get_bit_width() / 8;\n+\n+        if self.null_count() > 0 {\n+            let values = value_buf.data();\n+            let other_values = other_value_buf.data();\n+\n+            for i in 0..self.len() {\n+                if self.is_valid(i) {\n+                    let start = (i + self.offset()) * byte_width;\n+                    let data = &values[start..(start + byte_width)];\n+                    let other_start = (i + other.offset()) * byte_width;\n+                    let other_data =\n+                        &other_values[other_start..(other_start + byte_width)];\n+                    if data != other_data {\n+                        return false;\n+                    }\n+                }\n+            }\n+        } else {\n+            let start = self.offset() * byte_width;\n+            let other_start = other.offset() * byte_width;\n+            let len = self.len() * byte_width;\n+            let data = &value_buf.data()[start..(start + len)];\n+            let other_data = &other_value_buf.data()[other_start..(other_start + len)];\n+            if data != other_data {\n+                return false;\n+            }\n+        }\n+\n+        true\n+    }\n+\n+    default fn range_equals(\n+        &self,\n+        other: &dyn Array,\n+        start_idx: usize,\n+        end_idx: usize,\n+        other_start_idx: usize,\n+    ) -> bool {\n+        let other = other.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+\n+        let mut j = other_start_idx;\n+        for i in start_idx..end_idx {\n+            let is_null = self.is_null(i);\n+            let other_is_null = other.is_null(j);\n+            if is_null != other_is_null || (!is_null && self.value(i) != other.value(j)) {\n+                return false;\n+            }\n+            j += 1;\n+        }\n+\n+        true\n+    }\n+}\n+\n+impl ArrayEqual for BooleanArray {\n+    fn equals(&self, other: &dyn Array) -> bool {\n+        if !base_equal(&self.data(), &other.data()) {\n+            return false;\n+        }\n+\n+        let values = self.data_ref().buffers()[0].data();\n+        let other_values = other.data_ref().buffers()[0].data();\n+\n+        // TODO: we can do this more efficiently if all values are not-null\n+        for i in 0..self.len() {\n+            if self.is_valid(i) {\n+                if bit_util::get_bit(values, i + self.offset())\n+                    != bit_util::get_bit(other_values, i + other.offset())\n+                {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        true\n+    }\n+}\n+\n+impl<T: ArrowNumericType> PartialEq for PrimitiveArray<T> {\n+    fn eq(&self, other: &PrimitiveArray<T>) -> bool {\n+        self.equals(other)\n+    }\n+}\n+\n+impl ArrayEqual for ListArray {\n+    fn equals(&self, other: &dyn Array) -> bool {\n+        if !base_equal(&self.data(), &other.data()) {\n+            return false;\n+        }\n+\n+        let other = other.as_any().downcast_ref::<ListArray>().unwrap();\n+\n+        if !value_offset_equal(self, other) {\n+            return false;\n+        }\n+\n+        if !self.values().range_equals(\n+            &*other.values(),\n+            self.value_offset(0) as usize,\n+            self.value_offset(self.len()) as usize,\n+            other.value_offset(0) as usize,\n+        ) {\n+            return false;\n+        }\n+\n+        true\n+    }\n+\n+    fn range_equals(\n+        &self,\n+        other: &dyn Array,\n+        start_idx: usize,\n+        end_idx: usize,\n+        other_start_idx: usize,\n+    ) -> bool {\n+        let other = other.as_any().downcast_ref::<ListArray>().unwrap();\n+\n+        let mut j = other_start_idx;\n+        for i in start_idx..end_idx {\n+            let is_null = self.is_null(i);\n+            let other_is_null = other.is_null(j);\n+\n+            if is_null != other_is_null {\n+                return false;\n+            }\n+\n+            if is_null {\n+                continue;\n+            }\n+\n+            let start_offset = self.value_offset(i) as usize;\n+            let end_offset = self.value_offset(i + 1) as usize;\n+            let other_start_offset = other.value_offset(j) as usize;\n+            let other_end_offset = other.value_offset(j + 1) as usize;\n+\n+            if end_offset - start_offset != other_end_offset - other_start_offset {\n+                return false;\n+            }\n+\n+            if !self.values().range_equals(\n+                &*other.values(),\n+                start_offset,\n+                end_offset,\n+                other_start_offset,\n+            ) {\n+                return false;\n+            }\n+\n+            j += 1;\n+        }\n+\n+        true\n+    }\n+}\n+\n+impl ArrayEqual for BinaryArray {\n+    fn equals(&self, other: &dyn Array) -> bool {\n+        if !base_equal(&self.data(), &other.data()) {\n+            return false;\n+        }\n+\n+        let other = other.as_any().downcast_ref::<BinaryArray>().unwrap();\n+\n+        if !value_offset_equal(self, other) {\n+            return false;\n+        }\n+\n+        // TODO: handle null & length == 0 case?\n+\n+        let value_buf = self.value_data();\n+        let other_value_buf = other.value_data();\n+        let value_data = value_buf.data();\n+        let other_value_data = other_value_buf.data();\n+\n+        if self.null_count() == 0 {\n+            // No offset in both - just do memcmp\n+            if self.offset() == 0 && other.offset() == 0 {\n+                let len = self.value_offset(self.len()) as usize;\n+                return value_data[..len] == other_value_data[..len];\n+            } else {\n+                let start = self.value_offset(0) as usize;\n+                let other_start = other.value_offset(0) as usize;\n+                let len = (self.value_offset(self.len()) - self.value_offset(0)) as usize;\n+                return value_data[start..(start + len)]\n+                    == other_value_data[other_start..(other_start + len)];\n+            }\n+        } else {\n+            for i in 0..self.len() {\n+                if self.is_null(i) {\n+                    continue;\n+                }\n+\n+                let start = self.value_offset(i) as usize;\n+                let other_start = other.value_offset(i) as usize;\n+                let len = self.value_length(i) as usize;\n+                if value_data[start..(start + len)]\n+                    != other_value_data[other_start..(other_start + len)]\n+                {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        true\n+    }\n+\n+    fn range_equals(\n+        &self,\n+        other: &dyn Array,\n+        start_idx: usize,\n+        end_idx: usize,\n+        other_start_idx: usize,\n+    ) -> bool {\n+        let other = other.as_any().downcast_ref::<BinaryArray>().unwrap();\n+\n+        let mut j = other_start_idx;\n+        for i in start_idx..end_idx {\n+            let is_null = self.is_null(i);\n+            let other_is_null = other.is_null(j);\n+\n+            if is_null != other_is_null {\n+                return false;\n+            }\n+\n+            if is_null {\n+                continue;\n+            }\n+\n+            let start_offset = self.value_offset(i) as usize;\n+            let end_offset = self.value_offset(i + 1) as usize;\n+            let other_start_offset = other.value_offset(j) as usize;\n+            let other_end_offset = other.value_offset(j + 1) as usize;\n+\n+            if end_offset - start_offset != other_end_offset - other_start_offset {\n+                return false;\n+            }\n+\n+            let value_buf = self.value_data();\n+            let other_value_buf = other.value_data();\n+            let value_data = value_buf.data();\n+            let other_value_data = other_value_buf.data();\n+\n+            if end_offset - start_offset > 0 {\n+                let len = end_offset - start_offset;\n+                if value_data[start_offset..(start_offset + len)]\n+                    != other_value_data[other_start_offset..(other_start_offset + len)]\n+                {\n+                    return false;\n+                }\n+            }\n+\n+            j += 1;\n+        }\n+\n+        true\n+    }\n+}\n+\n+impl ArrayEqual for StructArray {\n+    fn equals(&self, other: &dyn Array) -> bool {\n+        if !base_equal(&self.data(), &other.data()) {\n+            return false;\n+        }\n+\n+        let other = other.as_any().downcast_ref::<StructArray>().unwrap();\n+\n+        for i in 0..self.len() {\n+            let is_null = self.is_null(i);\n+            let other_is_null = other.is_null(i);\n+\n+            if is_null != other_is_null {\n+                return false;\n+            }\n+\n+            if is_null {\n+                continue;\n+            }\n+            for j in 0..self.num_columns() {\n+                if !self.column(j).range_equals(&**other.column(j), i, i + 1, i) {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        true\n+    }\n+\n+    fn range_equals(\n+        &self,\n+        other: &dyn Array,\n+        start_idx: usize,\n+        end_idx: usize,\n+        other_start_idx: usize,\n+    ) -> bool {\n+        let other = other.as_any().downcast_ref::<StructArray>().unwrap();\n+\n+        let mut j = other_start_idx;\n+        for i in start_idx..end_idx {\n+            let is_null = self.is_null(i);\n+            let other_is_null = other.is_null(i);\n+\n+            if is_null != other_is_null {\n+                return false;\n+            }\n+\n+            if is_null {\n+                continue;\n+            }\n+            for k in 0..self.num_columns() {\n+                if !self.column(k).range_equals(&**other.column(k), i, i + 1, j) {\n+                    return false;\n+                }\n+            }\n+\n+            j += 1;\n+        }\n+\n+        true\n+    }\n+}\n+\n+// Compare if the common basic fields between the two arrays are equal\n+fn base_equal(this: &ArrayDataRef, other: &ArrayDataRef) -> bool {\n+    if this.data_type() != other.data_type() {\n+        return false;\n+    }\n+    if this.len != other.len {\n+        return false;\n+    }\n+    if this.null_count != other.null_count {\n+        return false;\n+    }\n+    if this.null_count > 0 {\n+        let null_bitmap = this.null_bitmap().as_ref().unwrap();\n+        let other_null_bitmap = other.null_bitmap().as_ref().unwrap();\n+        let null_buf = null_bitmap.bits.data();\n+        let other_null_buf = other_null_bitmap.bits.data();\n+        for i in 0..this.len() {\n+            if bit_util::get_bit(null_buf, i + this.offset())\n+                != bit_util::get_bit(other_null_buf, i + other.offset())\n+            {\n+                return false;\n+            }\n+        }\n+    }\n+    true\n+}\n+\n+// Compare if the value offsets are equal between the two list arrays\n+fn value_offset_equal<T: Array + ListArrayOps>(this: &T, other: &T) -> bool {\n+    // Check if offsets differ\n+    if this.offset() == 0 && other.offset() == 0 {\n+        let offset_data = &this.data_ref().buffers()[0];\n+        let other_offset_data = &other.data_ref().buffers()[0];\n+        return offset_data.data()[0..((this.len() + 1) * 4)]\n+            == other_offset_data.data()[0..((other.len() + 1) * 4)];\n+    }\n+\n+    // The expensive case\n+    for i in 0..this.len() + 1 {\n+        if this.value_offset_at(i) - this.value_offset_at(0)\n+            != other.value_offset_at(i) - other.value_offset_at(0)\n+        {\n+            return false;\n+        }\n+    }\n+\n+    true\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use crate::builder::{\n+        ArrayBuilder, BinaryBuilder, Int32Builder, ListBuilder, StructBuilder,\n+    };\n+\n+    #[test]\n+    fn test_primitive_equal() {\n+        let a = Int32Array::from(vec![1, 2, 3]);\n+        let b = Int32Array::from(vec![1, 2, 3]);\n+        assert!(a.equals(&b));\n+        assert!(b.equals(&a));\n+\n+        let b = Int32Array::from(vec![1, 2, 4]);\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        // Test the case where null_count > 0\n+\n+        let a = Int32Array::from(vec![Some(1), None, Some(2), Some(3)]);\n+        let b = Int32Array::from(vec![Some(1), None, Some(2), Some(3)]);\n+        assert!(a.equals(&b));\n+        assert!(b.equals(&a));\n+\n+        let b = Int32Array::from(vec![Some(1), None, None, Some(3)]);\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        let b = Int32Array::from(vec![Some(1), None, Some(2), Some(4)]);\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        // Test the case where offset != 0\n+\n+        let a_slice = a.slice(1, 2);\n+        let b_slice = b.slice(1, 2);\n+        assert!(a_slice.equals(&*b_slice));\n+        assert!(b_slice.equals(&*a_slice));\n+    }\n+\n+    #[test]\n+    fn test_boolean_equal() {\n+        let a = BooleanArray::from(vec![false, false, true]);\n+        let b = BooleanArray::from(vec![false, false, true]);\n+        assert!(a.equals(&b));\n+        assert!(b.equals(&a));\n+\n+        let b = BooleanArray::from(vec![false, false, false]);\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        // Test the case where null_count > 0\n+\n+        let a = BooleanArray::from(vec![Some(false), None, None, Some(true)]);\n+        let b = BooleanArray::from(vec![Some(false), None, None, Some(true)]);\n+        assert!(a.equals(&b));\n+        assert!(b.equals(&a));\n+\n+        let b = BooleanArray::from(vec![None, None, None, Some(true)]);\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        let b = BooleanArray::from(vec![Some(true), None, None, Some(true)]);\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        // Test the case where offset != 0\n+\n+        let a = BooleanArray::from(vec![false, true, false, true, false, false, true]);\n+        let b = BooleanArray::from(vec![false, false, false, true, false, true, true]);\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        let a_slice = a.slice(2, 3);\n+        let b_slice = b.slice(2, 3);\n+        assert!(a_slice.equals(&*b_slice));\n+        assert!(b_slice.equals(&*a_slice));\n+\n+        let a_slice = a.slice(3, 4);\n+        let b_slice = b.slice(3, 4);\n+        assert!(!a_slice.equals(&*b_slice));\n+        assert!(!b_slice.equals(&*a_slice));\n+    }\n+\n+    #[test]\n+    fn test_list_equal() {\n+        let mut a_builder = ListBuilder::new(Int32Builder::new(10));\n+        let mut b_builder = ListBuilder::new(Int32Builder::new(10));\n+\n+        a_builder.values().append_slice(&[1, 2, 3]).unwrap();\n+        a_builder.append(true).unwrap();\n+        a_builder.values().append_slice(&[4, 5]).unwrap();\n+        a_builder.append(true).unwrap();\n+\n+        b_builder.values().append_slice(&[1, 2, 3]).unwrap();\n+        b_builder.append(true).unwrap();\n+        b_builder.values().append_slice(&[4, 5]).unwrap();\n+        b_builder.append(true).unwrap();\n+\n+        let a = a_builder.finish();\n+        let b = b_builder.finish();\n+        assert!(a.equals(&b));\n+        assert!(b.equals(&a));\n+\n+        b_builder.values().append_slice(&[1, 2, 3]).unwrap();\n+        b_builder.append(true).unwrap();\n+        b_builder.values().append_slice(&[4, 5, 6]).unwrap();\n+        b_builder.append(true).unwrap();\n+        let b = b_builder.finish();\n+\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        // Test the case where null_count > 0\n+\n+        a_builder.values().append_slice(&[1, 2]).unwrap();\n+        a_builder.append(true).unwrap();\n+        a_builder.append(false).unwrap();\n+        a_builder.append(false).unwrap();\n+        a_builder.values().append_slice(&[3, 4]).unwrap();\n+        a_builder.append(true).unwrap();\n+        a_builder.append(false).unwrap();\n+        a_builder.append(false).unwrap();\n+\n+        b_builder.values().append_slice(&[1, 2]).unwrap();\n+        b_builder.append(true).unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.values().append_slice(&[3, 4]).unwrap();\n+        b_builder.append(true).unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.append(false).unwrap();\n+\n+        let a = a_builder.finish();\n+        let b = b_builder.finish();\n+        assert!(a.equals(&b));\n+        assert!(b.equals(&a));\n+\n+        b_builder.values().append_slice(&[1, 2]).unwrap();\n+        b_builder.append(true).unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.append(true).unwrap();\n+        b_builder.values().append_slice(&[3, 4]).unwrap();\n+        b_builder.append(true).unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.append(false).unwrap();\n+\n+        let b = b_builder.finish();\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        b_builder.values().append_slice(&[1, 2]).unwrap();\n+        b_builder.append(true).unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.values().append_slice(&[3, 4, 5]).unwrap();\n+        b_builder.append(true).unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.append(false).unwrap();\n+\n+        let b = b_builder.finish();\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        // Test the case where offset != 0\n+\n+        let a_slice = a.slice(0, 3);\n+        let b_slice = b.slice(0, 3);\n+        assert!(a_slice.equals(&*b_slice));\n+        assert!(b_slice.equals(&*a_slice));\n+\n+        let a_slice = a.slice(0, 5);\n+        let b_slice = b.slice(0, 5);\n+        assert!(!a_slice.equals(&*b_slice));\n+        assert!(!b_slice.equals(&*a_slice));\n+\n+        let a_slice = a.slice(4, 1);\n+        let b_slice = b.slice(4, 1);\n+        assert!(a_slice.equals(&*b_slice));\n+        assert!(b_slice.equals(&*a_slice));\n+    }\n+\n+    #[test]\n+    fn test_binary_equal() {\n+        let mut a_builder = BinaryBuilder::new(10);\n+        let mut b_builder = BinaryBuilder::new(10);\n+\n+        a_builder.append_string(\"hello\").unwrap();\n+        a_builder.append_string(\"world\").unwrap();\n+\n+        b_builder.append_string(\"hello\").unwrap();\n+        b_builder.append_string(\"world\").unwrap();\n+\n+        let a = a_builder.finish();\n+        let b = b_builder.finish();\n+        assert!(a.equals(&b));\n+        assert!(b.equals(&a));\n+\n+        b_builder.append_string(\"hello\").unwrap();\n+        b_builder.append_string(\"arrow\").unwrap();\n+        let b = b_builder.finish();\n+\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        // Test the case where null_count > 0\n+\n+        a_builder.append_string(\"hello\").unwrap();\n+        a_builder.append(false).unwrap();\n+        a_builder.append(false).unwrap();\n+        a_builder.append_string(\"world\").unwrap();\n+        a_builder.append(false).unwrap();\n+        a_builder.append(false).unwrap();\n+\n+        b_builder.append_string(\"hello\").unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.append_string(\"world\").unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.append(false).unwrap();\n+\n+        let a = a_builder.finish();\n+        let b = b_builder.finish();\n+        assert!(a.equals(&b));\n+        assert!(b.equals(&a));\n+\n+        b_builder.append_string(\"hello\").unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.append(true).unwrap();\n+        b_builder.append_string(\"world\").unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.append(false).unwrap();\n+\n+        let b = b_builder.finish();\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        b_builder.append_string(\"hello\").unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.append_string(\"arrow\").unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.append(false).unwrap();\n+\n+        let b = b_builder.finish();\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        // Test the case where offset != 0\n+\n+        let a_slice = a.slice(0, 3);\n+        let b_slice = b.slice(0, 3);\n+        assert!(a_slice.equals(&*b_slice));\n+        assert!(b_slice.equals(&*a_slice));\n+\n+        let a_slice = a.slice(0, 5);\n+        let b_slice = b.slice(0, 5);\n+        assert!(!a_slice.equals(&*b_slice));\n+        assert!(!b_slice.equals(&*a_slice));\n+\n+        let a_slice = a.slice(4, 1);\n+        let b_slice = b.slice(4, 1);\n+        assert!(a_slice.equals(&*b_slice));\n+        assert!(b_slice.equals(&*a_slice));\n+    }\n+\n+    #[test]\n+    fn test_struct_equal() {\n+        let string_builder = BinaryBuilder::new(5);\n+        let int_builder = Int32Builder::new(5);\n+\n+        let mut fields = Vec::new();\n+        let mut field_builders = Vec::new();\n+        fields.push(Field::new(\"f1\", DataType::Utf8, false));\n+        field_builders.push(Box::new(string_builder) as Box<ArrayBuilder>);\n+        fields.push(Field::new(\"f2\", DataType::Int32, false));\n+        field_builders.push(Box::new(int_builder) as Box<ArrayBuilder>);\n+\n+        let mut builder = StructBuilder::new(fields, field_builders);\n+\n+        let a = {\n \n Review comment:\n   There are two large repeated code blocks here that could be moved into a method\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-22T12:59:19.765+0000",
                    "updated": "2019-06-22T12:59:19.765+0000",
                    "started": "2019-06-22T12:59:19.764+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "265272",
                    "issueId": "13233878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13233878/worklog/265273",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "agrove-rms commented on pull request #4643: ARROW-5358: [Rust] Implement equality check for ArrayData and Array\nURL: https://github.com/apache/arrow/pull/4643#discussion_r296444968\n \n \n\n ##########\n File path: rust/arrow/src/array.rs\n ##########\n @@ -234,6 +235,42 @@ pub struct PrimitiveArray<T: ArrowPrimitiveType> {\n     raw_values: RawPtrBox<T::Native>,\n }\n \n+/// Common operations for primitive types, including numeric types and boolean type.\n+pub trait PrimitiveArrayOps<T: ArrowPrimitiveType> {\n+    fn values(&self) -> Buffer;\n+    fn value(&self, i: usize) -> T::Native;\n+}\n+\n+impl<T: ArrowPrimitiveType> PrimitiveArrayOps<T> for PrimitiveArray<T> {\n+    default fn values(&self) -> Buffer {\n+        unimplemented!()\n \n Review comment:\n   It would be good to have some comments here, explaining why we are using `unimplemented!()`\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-22T12:59:19.801+0000",
                    "updated": "2019-06-22T12:59:19.801+0000",
                    "started": "2019-06-22T12:59:19.800+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "265273",
                    "issueId": "13233878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13233878/worklog/265274",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "agrove-rms commented on pull request #4643: ARROW-5358: [Rust] Implement equality check for ArrayData and Array\nURL: https://github.com/apache/arrow/pull/4643#discussion_r296445047\n \n \n\n ##########\n File path: rust/arrow/src/array_equal.rs\n ##########\n @@ -0,0 +1,751 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::array::*;\n+use crate::array_data::*;\n+use crate::datatypes::*;\n+use crate::util::bit_util;\n+\n+/// Trait for `Array` equality.\n+pub trait ArrayEqual {\n+    /// Returns true if this array is equal to the `other` array\n+    fn equals(&self, other: &dyn Array) -> bool;\n+\n+    /// Returns true if the range [start_idx, end_idx) is equal to\n+    /// [other_start_idx, other_start_idx + end_idx - start_idx) in the `other` array\n+    fn range_equals(\n+        &self,\n+        other: &dyn Array,\n+        start_idx: usize,\n+        end_idx: usize,\n+        other_start_idx: usize,\n+    ) -> bool;\n+}\n+\n+impl<T: ArrowPrimitiveType> ArrayEqual for PrimitiveArray<T> {\n+    default fn equals(&self, other: &dyn Array) -> bool {\n+        if !base_equal(&self.data(), &other.data()) {\n+            return false;\n+        }\n+\n+        let value_buf = self.data_ref().buffers()[0].clone();\n+        let other_value_buf = other.data_ref().buffers()[0].clone();\n+        let byte_width = T::get_bit_width() / 8;\n+\n+        if self.null_count() > 0 {\n+            let values = value_buf.data();\n+            let other_values = other_value_buf.data();\n+\n+            for i in 0..self.len() {\n+                if self.is_valid(i) {\n+                    let start = (i + self.offset()) * byte_width;\n+                    let data = &values[start..(start + byte_width)];\n+                    let other_start = (i + other.offset()) * byte_width;\n+                    let other_data =\n+                        &other_values[other_start..(other_start + byte_width)];\n+                    if data != other_data {\n+                        return false;\n+                    }\n+                }\n+            }\n+        } else {\n+            let start = self.offset() * byte_width;\n+            let other_start = other.offset() * byte_width;\n+            let len = self.len() * byte_width;\n+            let data = &value_buf.data()[start..(start + len)];\n+            let other_data = &other_value_buf.data()[other_start..(other_start + len)];\n+            if data != other_data {\n+                return false;\n+            }\n+        }\n+\n+        true\n+    }\n+\n+    default fn range_equals(\n+        &self,\n+        other: &dyn Array,\n+        start_idx: usize,\n+        end_idx: usize,\n+        other_start_idx: usize,\n+    ) -> bool {\n+        let other = other.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+\n+        let mut j = other_start_idx;\n+        for i in start_idx..end_idx {\n+            let is_null = self.is_null(i);\n+            let other_is_null = other.is_null(j);\n+            if is_null != other_is_null || (!is_null && self.value(i) != other.value(j)) {\n+                return false;\n+            }\n+            j += 1;\n+        }\n+\n+        true\n+    }\n+}\n+\n+impl ArrayEqual for BooleanArray {\n+    fn equals(&self, other: &dyn Array) -> bool {\n+        if !base_equal(&self.data(), &other.data()) {\n+            return false;\n+        }\n+\n+        let values = self.data_ref().buffers()[0].data();\n+        let other_values = other.data_ref().buffers()[0].data();\n+\n+        // TODO: we can do this more efficiently if all values are not-null\n+        for i in 0..self.len() {\n+            if self.is_valid(i) {\n+                if bit_util::get_bit(values, i + self.offset())\n+                    != bit_util::get_bit(other_values, i + other.offset())\n+                {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        true\n+    }\n+}\n+\n+impl<T: ArrowNumericType> PartialEq for PrimitiveArray<T> {\n+    fn eq(&self, other: &PrimitiveArray<T>) -> bool {\n+        self.equals(other)\n+    }\n+}\n+\n+impl ArrayEqual for ListArray {\n+    fn equals(&self, other: &dyn Array) -> bool {\n+        if !base_equal(&self.data(), &other.data()) {\n+            return false;\n+        }\n+\n+        let other = other.as_any().downcast_ref::<ListArray>().unwrap();\n+\n+        if !value_offset_equal(self, other) {\n+            return false;\n+        }\n+\n+        if !self.values().range_equals(\n+            &*other.values(),\n+            self.value_offset(0) as usize,\n+            self.value_offset(self.len()) as usize,\n+            other.value_offset(0) as usize,\n+        ) {\n+            return false;\n+        }\n+\n+        true\n+    }\n+\n+    fn range_equals(\n+        &self,\n+        other: &dyn Array,\n+        start_idx: usize,\n+        end_idx: usize,\n+        other_start_idx: usize,\n+    ) -> bool {\n+        let other = other.as_any().downcast_ref::<ListArray>().unwrap();\n+\n+        let mut j = other_start_idx;\n+        for i in start_idx..end_idx {\n+            let is_null = self.is_null(i);\n+            let other_is_null = other.is_null(j);\n+\n+            if is_null != other_is_null {\n+                return false;\n+            }\n+\n+            if is_null {\n+                continue;\n+            }\n+\n+            let start_offset = self.value_offset(i) as usize;\n+            let end_offset = self.value_offset(i + 1) as usize;\n+            let other_start_offset = other.value_offset(j) as usize;\n+            let other_end_offset = other.value_offset(j + 1) as usize;\n+\n+            if end_offset - start_offset != other_end_offset - other_start_offset {\n+                return false;\n+            }\n+\n+            if !self.values().range_equals(\n+                &*other.values(),\n+                start_offset,\n+                end_offset,\n+                other_start_offset,\n+            ) {\n+                return false;\n+            }\n+\n+            j += 1;\n+        }\n+\n+        true\n+    }\n+}\n+\n+impl ArrayEqual for BinaryArray {\n+    fn equals(&self, other: &dyn Array) -> bool {\n+        if !base_equal(&self.data(), &other.data()) {\n+            return false;\n+        }\n+\n+        let other = other.as_any().downcast_ref::<BinaryArray>().unwrap();\n+\n+        if !value_offset_equal(self, other) {\n+            return false;\n+        }\n+\n+        // TODO: handle null & length == 0 case?\n+\n+        let value_buf = self.value_data();\n+        let other_value_buf = other.value_data();\n+        let value_data = value_buf.data();\n+        let other_value_data = other_value_buf.data();\n+\n+        if self.null_count() == 0 {\n+            // No offset in both - just do memcmp\n+            if self.offset() == 0 && other.offset() == 0 {\n+                let len = self.value_offset(self.len()) as usize;\n+                return value_data[..len] == other_value_data[..len];\n+            } else {\n+                let start = self.value_offset(0) as usize;\n+                let other_start = other.value_offset(0) as usize;\n+                let len = (self.value_offset(self.len()) - self.value_offset(0)) as usize;\n+                return value_data[start..(start + len)]\n+                    == other_value_data[other_start..(other_start + len)];\n+            }\n+        } else {\n+            for i in 0..self.len() {\n+                if self.is_null(i) {\n+                    continue;\n+                }\n+\n+                let start = self.value_offset(i) as usize;\n+                let other_start = other.value_offset(i) as usize;\n+                let len = self.value_length(i) as usize;\n+                if value_data[start..(start + len)]\n+                    != other_value_data[other_start..(other_start + len)]\n+                {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        true\n+    }\n+\n+    fn range_equals(\n+        &self,\n+        other: &dyn Array,\n+        start_idx: usize,\n+        end_idx: usize,\n+        other_start_idx: usize,\n+    ) -> bool {\n+        let other = other.as_any().downcast_ref::<BinaryArray>().unwrap();\n+\n+        let mut j = other_start_idx;\n+        for i in start_idx..end_idx {\n+            let is_null = self.is_null(i);\n+            let other_is_null = other.is_null(j);\n+\n+            if is_null != other_is_null {\n+                return false;\n+            }\n+\n+            if is_null {\n+                continue;\n+            }\n+\n+            let start_offset = self.value_offset(i) as usize;\n+            let end_offset = self.value_offset(i + 1) as usize;\n+            let other_start_offset = other.value_offset(j) as usize;\n+            let other_end_offset = other.value_offset(j + 1) as usize;\n+\n+            if end_offset - start_offset != other_end_offset - other_start_offset {\n+                return false;\n+            }\n+\n+            let value_buf = self.value_data();\n+            let other_value_buf = other.value_data();\n+            let value_data = value_buf.data();\n+            let other_value_data = other_value_buf.data();\n+\n+            if end_offset - start_offset > 0 {\n+                let len = end_offset - start_offset;\n+                if value_data[start_offset..(start_offset + len)]\n+                    != other_value_data[other_start_offset..(other_start_offset + len)]\n+                {\n+                    return false;\n+                }\n+            }\n+\n+            j += 1;\n+        }\n+\n+        true\n+    }\n+}\n+\n+impl ArrayEqual for StructArray {\n+    fn equals(&self, other: &dyn Array) -> bool {\n+        if !base_equal(&self.data(), &other.data()) {\n+            return false;\n+        }\n+\n+        let other = other.as_any().downcast_ref::<StructArray>().unwrap();\n+\n+        for i in 0..self.len() {\n+            let is_null = self.is_null(i);\n+            let other_is_null = other.is_null(i);\n+\n+            if is_null != other_is_null {\n+                return false;\n+            }\n+\n+            if is_null {\n+                continue;\n+            }\n+            for j in 0..self.num_columns() {\n+                if !self.column(j).range_equals(&**other.column(j), i, i + 1, i) {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        true\n+    }\n+\n+    fn range_equals(\n+        &self,\n+        other: &dyn Array,\n+        start_idx: usize,\n+        end_idx: usize,\n+        other_start_idx: usize,\n+    ) -> bool {\n+        let other = other.as_any().downcast_ref::<StructArray>().unwrap();\n+\n+        let mut j = other_start_idx;\n+        for i in start_idx..end_idx {\n+            let is_null = self.is_null(i);\n+            let other_is_null = other.is_null(i);\n+\n+            if is_null != other_is_null {\n+                return false;\n+            }\n+\n+            if is_null {\n+                continue;\n+            }\n+            for k in 0..self.num_columns() {\n+                if !self.column(k).range_equals(&**other.column(k), i, i + 1, j) {\n+                    return false;\n+                }\n+            }\n+\n+            j += 1;\n+        }\n+\n+        true\n+    }\n+}\n+\n+// Compare if the common basic fields between the two arrays are equal\n+fn base_equal(this: &ArrayDataRef, other: &ArrayDataRef) -> bool {\n+    if this.data_type() != other.data_type() {\n+        return false;\n+    }\n+    if this.len != other.len {\n+        return false;\n+    }\n+    if this.null_count != other.null_count {\n+        return false;\n+    }\n+    if this.null_count > 0 {\n+        let null_bitmap = this.null_bitmap().as_ref().unwrap();\n+        let other_null_bitmap = other.null_bitmap().as_ref().unwrap();\n+        let null_buf = null_bitmap.bits.data();\n+        let other_null_buf = other_null_bitmap.bits.data();\n+        for i in 0..this.len() {\n+            if bit_util::get_bit(null_buf, i + this.offset())\n+                != bit_util::get_bit(other_null_buf, i + other.offset())\n+            {\n+                return false;\n+            }\n+        }\n+    }\n+    true\n+}\n+\n+// Compare if the value offsets are equal between the two list arrays\n+fn value_offset_equal<T: Array + ListArrayOps>(this: &T, other: &T) -> bool {\n+    // Check if offsets differ\n+    if this.offset() == 0 && other.offset() == 0 {\n+        let offset_data = &this.data_ref().buffers()[0];\n+        let other_offset_data = &other.data_ref().buffers()[0];\n+        return offset_data.data()[0..((this.len() + 1) * 4)]\n+            == other_offset_data.data()[0..((other.len() + 1) * 4)];\n+    }\n+\n+    // The expensive case\n+    for i in 0..this.len() + 1 {\n+        if this.value_offset_at(i) - this.value_offset_at(0)\n+            != other.value_offset_at(i) - other.value_offset_at(0)\n+        {\n+            return false;\n+        }\n+    }\n+\n+    true\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use crate::builder::{\n+        ArrayBuilder, BinaryBuilder, Int32Builder, ListBuilder, StructBuilder,\n+    };\n+\n+    #[test]\n+    fn test_primitive_equal() {\n+        let a = Int32Array::from(vec![1, 2, 3]);\n+        let b = Int32Array::from(vec![1, 2, 3]);\n+        assert!(a.equals(&b));\n+        assert!(b.equals(&a));\n+\n+        let b = Int32Array::from(vec![1, 2, 4]);\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        // Test the case where null_count > 0\n+\n+        let a = Int32Array::from(vec![Some(1), None, Some(2), Some(3)]);\n+        let b = Int32Array::from(vec![Some(1), None, Some(2), Some(3)]);\n+        assert!(a.equals(&b));\n+        assert!(b.equals(&a));\n+\n+        let b = Int32Array::from(vec![Some(1), None, None, Some(3)]);\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        let b = Int32Array::from(vec![Some(1), None, Some(2), Some(4)]);\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        // Test the case where offset != 0\n+\n+        let a_slice = a.slice(1, 2);\n+        let b_slice = b.slice(1, 2);\n+        assert!(a_slice.equals(&*b_slice));\n+        assert!(b_slice.equals(&*a_slice));\n+    }\n+\n+    #[test]\n+    fn test_boolean_equal() {\n+        let a = BooleanArray::from(vec![false, false, true]);\n+        let b = BooleanArray::from(vec![false, false, true]);\n+        assert!(a.equals(&b));\n+        assert!(b.equals(&a));\n+\n+        let b = BooleanArray::from(vec![false, false, false]);\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        // Test the case where null_count > 0\n+\n+        let a = BooleanArray::from(vec![Some(false), None, None, Some(true)]);\n+        let b = BooleanArray::from(vec![Some(false), None, None, Some(true)]);\n+        assert!(a.equals(&b));\n+        assert!(b.equals(&a));\n+\n+        let b = BooleanArray::from(vec![None, None, None, Some(true)]);\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        let b = BooleanArray::from(vec![Some(true), None, None, Some(true)]);\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        // Test the case where offset != 0\n+\n+        let a = BooleanArray::from(vec![false, true, false, true, false, false, true]);\n+        let b = BooleanArray::from(vec![false, false, false, true, false, true, true]);\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        let a_slice = a.slice(2, 3);\n+        let b_slice = b.slice(2, 3);\n+        assert!(a_slice.equals(&*b_slice));\n+        assert!(b_slice.equals(&*a_slice));\n+\n+        let a_slice = a.slice(3, 4);\n+        let b_slice = b.slice(3, 4);\n+        assert!(!a_slice.equals(&*b_slice));\n+        assert!(!b_slice.equals(&*a_slice));\n+    }\n+\n+    #[test]\n+    fn test_list_equal() {\n+        let mut a_builder = ListBuilder::new(Int32Builder::new(10));\n+        let mut b_builder = ListBuilder::new(Int32Builder::new(10));\n+\n+        a_builder.values().append_slice(&[1, 2, 3]).unwrap();\n+        a_builder.append(true).unwrap();\n+        a_builder.values().append_slice(&[4, 5]).unwrap();\n+        a_builder.append(true).unwrap();\n+\n+        b_builder.values().append_slice(&[1, 2, 3]).unwrap();\n+        b_builder.append(true).unwrap();\n+        b_builder.values().append_slice(&[4, 5]).unwrap();\n+        b_builder.append(true).unwrap();\n+\n+        let a = a_builder.finish();\n+        let b = b_builder.finish();\n+        assert!(a.equals(&b));\n+        assert!(b.equals(&a));\n+\n+        b_builder.values().append_slice(&[1, 2, 3]).unwrap();\n+        b_builder.append(true).unwrap();\n+        b_builder.values().append_slice(&[4, 5, 6]).unwrap();\n+        b_builder.append(true).unwrap();\n+        let b = b_builder.finish();\n+\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        // Test the case where null_count > 0\n+\n+        a_builder.values().append_slice(&[1, 2]).unwrap();\n+        a_builder.append(true).unwrap();\n+        a_builder.append(false).unwrap();\n+        a_builder.append(false).unwrap();\n+        a_builder.values().append_slice(&[3, 4]).unwrap();\n+        a_builder.append(true).unwrap();\n+        a_builder.append(false).unwrap();\n+        a_builder.append(false).unwrap();\n+\n+        b_builder.values().append_slice(&[1, 2]).unwrap();\n+        b_builder.append(true).unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.values().append_slice(&[3, 4]).unwrap();\n+        b_builder.append(true).unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.append(false).unwrap();\n+\n+        let a = a_builder.finish();\n+        let b = b_builder.finish();\n+        assert!(a.equals(&b));\n+        assert!(b.equals(&a));\n+\n+        b_builder.values().append_slice(&[1, 2]).unwrap();\n+        b_builder.append(true).unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.append(true).unwrap();\n+        b_builder.values().append_slice(&[3, 4]).unwrap();\n+        b_builder.append(true).unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.append(false).unwrap();\n+\n+        let b = b_builder.finish();\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        b_builder.values().append_slice(&[1, 2]).unwrap();\n+        b_builder.append(true).unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.values().append_slice(&[3, 4, 5]).unwrap();\n+        b_builder.append(true).unwrap();\n+        b_builder.append(false).unwrap();\n+        b_builder.append(false).unwrap();\n+\n+        let b = b_builder.finish();\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        // Test the case where offset != 0\n+\n+        let a_slice = a.slice(0, 3);\n+        let b_slice = b.slice(0, 3);\n+        assert!(a_slice.equals(&*b_slice));\n+        assert!(b_slice.equals(&*a_slice));\n+\n+        let a_slice = a.slice(0, 5);\n+        let b_slice = b.slice(0, 5);\n+        assert!(!a_slice.equals(&*b_slice));\n+        assert!(!b_slice.equals(&*a_slice));\n+\n+        let a_slice = a.slice(4, 1);\n+        let b_slice = b.slice(4, 1);\n+        assert!(a_slice.equals(&*b_slice));\n+        assert!(b_slice.equals(&*a_slice));\n+    }\n+\n+    #[test]\n+    fn test_binary_equal() {\n+        let mut a_builder = BinaryBuilder::new(10);\n+        let mut b_builder = BinaryBuilder::new(10);\n+\n+        a_builder.append_string(\"hello\").unwrap();\n+        a_builder.append_string(\"world\").unwrap();\n+\n+        b_builder.append_string(\"hello\").unwrap();\n+        b_builder.append_string(\"world\").unwrap();\n+\n+        let a = a_builder.finish();\n+        let b = b_builder.finish();\n+        assert!(a.equals(&b));\n+        assert!(b.equals(&a));\n+\n+        b_builder.append_string(\"hello\").unwrap();\n+        b_builder.append_string(\"arrow\").unwrap();\n+        let b = b_builder.finish();\n+\n+        assert!(!a.equals(&b));\n+        assert!(!b.equals(&a));\n+\n+        // Test the case where null_count > 0\n+\n+        a_builder.append_string(\"hello\").unwrap();\n \n Review comment:\n   Repetitive code blocks that could be moved to a method\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-22T12:59:23.944+0000",
                    "updated": "2019-06-22T12:59:23.944+0000",
                    "started": "2019-06-22T12:59:23.943+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "265274",
                    "issueId": "13233878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13233878/worklog/265495",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on issue #4643: ARROW-5358: [Rust] Implement equality check for ArrayData and Array\nURL: https://github.com/apache/arrow/pull/4643#issuecomment-504847113\n \n \n   Hi @sunchao, I'm still going through this PR. I decided to rebase my `take` branch on this so I can give it a test drive. Primitives look great, and I like the `PrimitiveArrayOps`!\r\n   \r\n   I'm still busy with list arrays (struggling a bit). My struggle's that `array.equals(&other)` is currently not debug friendly. It's often easier to inspect primitive arrays to see their difference. With lists it's hard. Do you think it'd be possible to explore using debug assertions in test mode? Something like:\r\n   \r\n   ```rust\r\n   if cfg!(test) {\r\n       // debug mode\r\n   } else {\r\n       // no debug\r\n   }\r\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-24T03:52:08.997+0000",
                    "updated": "2019-06-24T03:52:08.997+0000",
                    "started": "2019-06-24T03:52:08.996+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "265495",
                    "issueId": "13233878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13233878/worklog/265501",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on pull request #4643: ARROW-5358: [Rust] Implement equality check for ArrayData and Array\nURL: https://github.com/apache/arrow/pull/4643#discussion_r296555046\n \n \n\n ##########\n File path: rust/arrow/src/array.rs\n ##########\n @@ -234,6 +235,42 @@ pub struct PrimitiveArray<T: ArrowPrimitiveType> {\n     raw_values: RawPtrBox<T::Native>,\n }\n \n+/// Common operations for primitive types, including numeric types and boolean type.\n+pub trait PrimitiveArrayOps<T: ArrowPrimitiveType> {\n+    fn values(&self) -> Buffer;\n+    fn value(&self, i: usize) -> T::Native;\n+}\n+\n+impl<T: ArrowPrimitiveType> PrimitiveArrayOps<T> for PrimitiveArray<T> {\n+    default fn values(&self) -> Buffer {\n+        unimplemented!()\n+    }\n+\n+    default fn value(&self, _: usize) -> T::Native {\n+        unimplemented!()\n+    }\n+}\n+\n+impl<T: ArrowNumericType> PrimitiveArrayOps<T> for PrimitiveArray<T> {\n+    fn values(&self) -> Buffer {\n+        self.values()\n+    }\n+\n+    fn value(&self, i: usize) -> T::Native {\n+        self.value(i)\n+    }\n+}\n+\n+impl PrimitiveArrayOps<BooleanType> for BooleanArray {\n+    fn values(&self) -> Buffer {\n+        self.values()\n \n Review comment:\n   This is because we implemented `PrimitiveArray` separately for `ArrowNumericType` and `BooleanType`. Even though they have the same method signature, we cannot access the method under the `PrimitiveArray` trait.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-24T05:19:36.207+0000",
                    "updated": "2019-06-24T05:19:36.207+0000",
                    "started": "2019-06-24T05:19:36.206+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "265501",
                    "issueId": "13233878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13233878/worklog/265504",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on pull request #4643: ARROW-5358: [Rust] Implement equality check for ArrayData and Array\nURL: https://github.com/apache/arrow/pull/4643#discussion_r296555383\n \n \n\n ##########\n File path: rust/arrow/src/array.rs\n ##########\n @@ -971,6 +1034,11 @@ impl StructArray {\n     pub fn column(&self, pos: usize) -> &ArrayRef {\n         &self.boxed_fields[pos]\n     }\n+\n+    /// Return the number of fields in this struct array\n+    pub fn num_columns(&self) -> usize {\n \n Review comment:\n   This is to be consistent with the previous `column` method. `num_children` might be a little confusing.\r\n   \r\n   I think a better term is `field` and `num_fields` because when we talk about struct we usually say \"struct fields`. However this requires changing the current `column` method.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-24T05:22:15.648+0000",
                    "updated": "2019-06-24T05:22:15.648+0000",
                    "started": "2019-06-24T05:22:15.647+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "265504",
                    "issueId": "13233878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13233878/worklog/265505",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on pull request #4643: ARROW-5358: [Rust] Implement equality check for ArrayData and Array\nURL: https://github.com/apache/arrow/pull/4643#discussion_r296555546\n \n \n\n ##########\n File path: rust/arrow/src/array_equal.rs\n ##########\n @@ -0,0 +1,751 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::array::*;\n+use crate::array_data::*;\n+use crate::datatypes::*;\n+use crate::util::bit_util;\n+\n+/// Trait for `Array` equality.\n+pub trait ArrayEqual {\n+    /// Returns true if this array is equal to the `other` array\n+    fn equals(&self, other: &dyn Array) -> bool;\n \n Review comment:\n   Yes I do plan to implement `PartialEq` using the existing `ArrayEqual` in a follow-up PR.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-24T05:23:29.143+0000",
                    "updated": "2019-06-24T05:23:29.143+0000",
                    "started": "2019-06-24T05:23:29.142+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "265505",
                    "issueId": "13233878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13233878/worklog/265508",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on pull request #4643: ARROW-5358: [Rust] Implement equality check for ArrayData and Array\nURL: https://github.com/apache/arrow/pull/4643#discussion_r296556581\n \n \n\n ##########\n File path: rust/arrow/src/array_equal.rs\n ##########\n @@ -0,0 +1,751 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::array::*;\n+use crate::array_data::*;\n+use crate::datatypes::*;\n+use crate::util::bit_util;\n+\n+/// Trait for `Array` equality.\n+pub trait ArrayEqual {\n+    /// Returns true if this array is equal to the `other` array\n+    fn equals(&self, other: &dyn Array) -> bool;\n+\n+    /// Returns true if the range [start_idx, end_idx) is equal to\n+    /// [other_start_idx, other_start_idx + end_idx - start_idx) in the `other` array\n+    fn range_equals(\n+        &self,\n+        other: &dyn Array,\n+        start_idx: usize,\n+        end_idx: usize,\n+        other_start_idx: usize,\n+    ) -> bool;\n+}\n+\n+impl<T: ArrowPrimitiveType> ArrayEqual for PrimitiveArray<T> {\n+    default fn equals(&self, other: &dyn Array) -> bool {\n+        if !base_equal(&self.data(), &other.data()) {\n+            return false;\n+        }\n+\n+        let value_buf = self.data_ref().buffers()[0].clone();\n+        let other_value_buf = other.data_ref().buffers()[0].clone();\n+        let byte_width = T::get_bit_width() / 8;\n+\n+        if self.null_count() > 0 {\n+            let values = value_buf.data();\n \n Review comment:\n   You mean `Buffer#typed_data`, right? the issue is that cannot handle `BooleanType` which is covered here.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-24T05:30:01.650+0000",
                    "updated": "2019-06-24T05:30:01.650+0000",
                    "started": "2019-06-24T05:30:01.649+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "265508",
                    "issueId": "13233878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13233878/worklog/265509",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on pull request #4643: ARROW-5358: [Rust] Implement equality check for ArrayData and Array\nURL: https://github.com/apache/arrow/pull/4643#discussion_r296557648\n \n \n\n ##########\n File path: rust/arrow/src/array_equal.rs\n ##########\n @@ -0,0 +1,751 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::array::*;\n+use crate::array_data::*;\n+use crate::datatypes::*;\n+use crate::util::bit_util;\n+\n+/// Trait for `Array` equality.\n+pub trait ArrayEqual {\n+    /// Returns true if this array is equal to the `other` array\n+    fn equals(&self, other: &dyn Array) -> bool;\n+\n+    /// Returns true if the range [start_idx, end_idx) is equal to\n+    /// [other_start_idx, other_start_idx + end_idx - start_idx) in the `other` array\n+    fn range_equals(\n+        &self,\n+        other: &dyn Array,\n+        start_idx: usize,\n+        end_idx: usize,\n+        other_start_idx: usize,\n+    ) -> bool;\n+}\n+\n+impl<T: ArrowPrimitiveType> ArrayEqual for PrimitiveArray<T> {\n+    default fn equals(&self, other: &dyn Array) -> bool {\n+        if !base_equal(&self.data(), &other.data()) {\n+            return false;\n+        }\n+\n+        let value_buf = self.data_ref().buffers()[0].clone();\n+        let other_value_buf = other.data_ref().buffers()[0].clone();\n+        let byte_width = T::get_bit_width() / 8;\n+\n+        if self.null_count() > 0 {\n+            let values = value_buf.data();\n+            let other_values = other_value_buf.data();\n+\n+            for i in 0..self.len() {\n+                if self.is_valid(i) {\n+                    let start = (i + self.offset()) * byte_width;\n+                    let data = &values[start..(start + byte_width)];\n+                    let other_start = (i + other.offset()) * byte_width;\n+                    let other_data =\n+                        &other_values[other_start..(other_start + byte_width)];\n+                    if data != other_data {\n+                        return false;\n+                    }\n+                }\n+            }\n+        } else {\n+            let start = self.offset() * byte_width;\n+            let other_start = other.offset() * byte_width;\n+            let len = self.len() * byte_width;\n+            let data = &value_buf.data()[start..(start + len)];\n+            let other_data = &other_value_buf.data()[other_start..(other_start + len)];\n+            if data != other_data {\n+                return false;\n+            }\n+        }\n+\n+        true\n+    }\n+\n+    default fn range_equals(\n+        &self,\n+        other: &dyn Array,\n+        start_idx: usize,\n+        end_idx: usize,\n+        other_start_idx: usize,\n+    ) -> bool {\n+        let other = other.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n \n Review comment:\n   Good idea. I think we don't need to do much for `start_idx` and `end_idx`, but for `other_start_idx` we may want to check if it is out of range.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-24T05:36:38.978+0000",
                    "updated": "2019-06-24T05:36:38.978+0000",
                    "started": "2019-06-24T05:36:38.977+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "265509",
                    "issueId": "13233878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13233878/worklog/265523",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on pull request #4643: ARROW-5358: [Rust] Implement equality check for ArrayData and Array\nURL: https://github.com/apache/arrow/pull/4643#discussion_r296560081\n \n \n\n ##########\n File path: rust/arrow/src/array.rs\n ##########\n @@ -848,6 +901,16 @@ impl BinaryArray {\n         self.value_offset_at(i + 1) - self.value_offset_at(i)\n     }\n \n+    /// Returns a reference of the value offset buffer\n \n Review comment:\n   I agree it is a little confusing. Let me change \"reference\" to \"clone\" to make it clearer.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-24T05:51:59.887+0000",
                    "updated": "2019-06-24T05:51:59.887+0000",
                    "started": "2019-06-24T05:51:59.887+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "265523",
                    "issueId": "13233878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13233878/worklog/265549",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on issue #4643: ARROW-5358: [Rust] Implement equality check for ArrayData and Array\nURL: https://github.com/apache/arrow/pull/4643#issuecomment-504886258\n \n \n   > Hi @sunchao, I'm still going through this PR. I decided to rebase my `take` branch on this so I can give it a test drive. Primitives look great, and I like the `PrimitiveArrayOps`!\r\n   > \r\n   > I'm still busy with list arrays (struggling a bit). My struggle's that `array.equals(&other)` is currently not debug friendly. It's often easier to inspect primitive arrays to see their difference. With lists it's hard. Do you think it'd be possible to explore using debug assertions in test mode? Something like:\r\n   > \r\n   > ```rust\r\n   > if cfg!(test) {\r\n   >     // debug mode\r\n   > } else {\r\n   >     // no debug\r\n   > }\r\n   > ```\r\n   \r\n   Not quite sure. How a debug assertion can help in this case? I was thinking that we may need some pretty-print for list and binary arrays so that we can do something like:\r\n   ```rust\r\n   assert!(array.equals(&other), \"ListArray {:?} does not equal to {:?}\", array, other);\r\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-24T07:06:34.529+0000",
                    "updated": "2019-06-24T07:06:34.529+0000",
                    "started": "2019-06-24T07:06:34.528+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "265549",
                    "issueId": "13233878"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 16800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@5dc5b38e[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@53952bc[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2e591c2[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@4d868f90[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5ee8cbd6[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@4c9807e8[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@62ddf438[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@1bde1dfc[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@370d32a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@fdb33eb[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2aa7a1c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@6970b648[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 16800,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Jul 01 20:01:11 UTC 2019",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2019-07-01T20:01:11.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-5358/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2019-05-16T23:38:02.000+0000",
        "updated": "2019-08-01T22:39:55.000+0000",
        "timeoriginalestimate": null,
        "description": "Currently {{Array}} doesn't implement the {{Eq}} trait. Although {{ArrayData}} derives from the {{PartialEq}} trait, the default implementation is not suitable here. Instead, we should implement customized equality comparison.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "4h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 16800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust] Implement equality check for ArrayData and Array",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13233878/comment/16876457",
                    "id": "16876457",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=csun",
                        "name": "csun",
                        "key": "csun",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=csun&avatarId=23340",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=csun&avatarId=23340",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=csun&avatarId=23340",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=csun&avatarId=23340"
                        },
                        "displayName": "Chao Sun",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Issue resolved by pull request 4643\n[https://github.com/apache/arrow/pull/4643]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=csun",
                        "name": "csun",
                        "key": "csun",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=csun&avatarId=23340",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=csun&avatarId=23340",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=csun&avatarId=23340",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=csun&avatarId=23340"
                        },
                        "displayName": "Chao Sun",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2019-07-01T20:01:11.473+0000",
                    "updated": "2019-07-01T20:01:11.473+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z02s7k:",
        "customfield_12314139": null
    }
}