{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13330181",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330181",
    "key": "ARROW-10143",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "aggregateprogress": {
            "progress": 15600,
            "total": 15600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 15600,
            "total": 15600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10143/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 26,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330181/worklog/513473",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou opened a new pull request #8703:\nURL: https://github.com/apache/arrow/pull/8703\n\n\n   ArrayEquals now defers to ArrayRangeEquals under the hood.\r\n   ArrayRangeEquals now allows passing an EqualOptions argument.\r\n   Also add ArrayRangeApproxEquals.\r\n   \r\n   Comparison speed is massively improved on many input types:\r\n   ```\r\n                                         benchmark            baseline           contender   change %                                                                                                                                                                               counters\r\n   26               ArrayRangeEqualsStruct/32768/0    6.338m items/sec  797.926m items/sec  12490.248                 {'run_name': 'ArrayRangeEqualsStruct/32768/0', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 135, 'null_percent': 0.0}\r\n   16              ArrayRangeEqualsBoolean/32768/0  839.237m items/sec   51.203b items/sec   6001.168              {'run_name': 'ArrayRangeEqualsBoolean/32768/0', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 17929, 'null_percent': 0.0}\r\n   28      ArrayRangeEqualsFixedSizeBinary/32768/0  369.542m items/sec   14.798b items/sec   3904.348       {'run_name': 'ArrayRangeEqualsFixedSizeBinary/32768/0', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 8130, 'null_percent': 0.0}\r\n   24           ArrayRangeEqualsStruct/32768/10000    6.251m items/sec  240.453m items/sec   3746.338            {'run_name': 'ArrayRangeEqualsStruct/32768/10000', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 134, 'null_percent': 0.01}\r\n   36               ArrayRangeEqualsStruct/32768/1  412.074m items/sec   13.733b items/sec   3232.616              {'run_name': 'ArrayRangeEqualsStruct/32768/1', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 8817, 'null_percent': 100.0}\r\n   9                ArrayRangeEqualsString/32768/0   67.419m items/sec    1.937b items/sec   2772.931                {'run_name': 'ArrayRangeEqualsString/32768/0', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 1441, 'null_percent': 0.0}\r\n   25          ArrayRangeEqualsListOfInt32/32768/1  524.231m items/sec   13.774b items/sec   2527.447        {'run_name': 'ArrayRangeEqualsListOfInt32/32768/1', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 11179, 'null_percent': 100.0}\r\n   44               ArrayRangeEqualsString/32768/1  577.902m items/sec   13.686b items/sec   2268.185             {'run_name': 'ArrayRangeEqualsString/32768/1', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 12328, 'null_percent': 100.0}\r\n   53      ArrayRangeEqualsFixedSizeBinary/32768/1  596.284m items/sec   13.140b items/sec   2103.587    {'run_name': 'ArrayRangeEqualsFixedSizeBinary/32768/1', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 12703, 'null_percent': 100.0}\r\n   11           ArrayRangeEqualsString/32768/10000   67.501m items/sec    1.382b items/sec   1947.876           {'run_name': 'ArrayRangeEqualsString/32768/10000', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 1442, 'null_percent': 0.01}\r\n   46          ArrayRangeEqualsListOfInt32/32768/0   42.696m items/sec  833.958m items/sec   1853.229            {'run_name': 'ArrayRangeEqualsListOfInt32/32768/0', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 911, 'null_percent': 0.0}\r\n   14              ArrayRangeEqualsBoolean/32768/1  698.866m items/sec   13.374b items/sec   1813.652            {'run_name': 'ArrayRangeEqualsBoolean/32768/1', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 14929, 'null_percent': 100.0}\r\n   38                ArrayRangeEqualsInt32/32768/1  835.824m items/sec   13.688b items/sec   1537.720              {'run_name': 'ArrayRangeEqualsInt32/32768/1', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 17818, 'null_percent': 100.0}\r\n   29  ArrayRangeEqualsFixedSizeBinary/32768/10000  278.025m items/sec    4.375b items/sec   1473.475  {'run_name': 'ArrayRangeEqualsFixedSizeBinary/32768/10000', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 5937, 'null_percent': 0.01}\r\n   17                ArrayRangeEqualsInt32/32768/0    2.104b items/sec   32.033b items/sec   1422.785                {'run_name': 'ArrayRangeEqualsInt32/32768/0', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 44741, 'null_percent': 0.0}\r\n   18              ArrayRangeEqualsFloat32/32768/1  838.934m items/sec   12.432b items/sec   1381.896            {'run_name': 'ArrayRangeEqualsFloat32/32768/1', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 17895, 'null_percent': 100.0}\r\n   19            ArrayRangeEqualsInt32/32768/10000  757.797m items/sec    6.848b items/sec    803.693           {'run_name': 'ArrayRangeEqualsInt32/32768/10000', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 16177, 'null_percent': 0.01}\r\n   15      ArrayRangeEqualsListOfInt32/32768/10000   28.438m items/sec  210.226m items/sec    639.253       {'run_name': 'ArrayRangeEqualsListOfInt32/32768/10000', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 606, 'null_percent': 0.01}\r\n   39          ArrayRangeEqualsFloat32/32768/10000  694.965m items/sec    4.706b items/sec    577.178         {'run_name': 'ArrayRangeEqualsFloat32/32768/10000', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 14833, 'null_percent': 0.01}\r\n   3           ArrayRangeEqualsBoolean/32768/10000  538.353m items/sec    2.968b items/sec    451.394         {'run_name': 'ArrayRangeEqualsBoolean/32768/10000', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 11475, 'null_percent': 0.01}\r\n   41              ArrayRangeEqualsFloat32/32768/0    2.036b items/sec   10.235b items/sec    402.761              {'run_name': 'ArrayRangeEqualsFloat32/32768/0', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 43978, 'null_percent': 0.0}\r\n   23             ArrayRangeEqualsStruct/32768/100    6.298m items/sec   26.042m items/sec    313.515               {'run_name': 'ArrayRangeEqualsStruct/32768/100', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 133, 'null_percent': 1.0}\r\n   1              ArrayRangeEqualsString/32768/100   68.074m items/sec  275.727m items/sec    305.039              {'run_name': 'ArrayRangeEqualsString/32768/100', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 1453, 'null_percent': 1.0}\r\n   42          ArrayRangeEqualsSparseUnion/32768/0   12.649m items/sec   38.360m items/sec    203.256            {'run_name': 'ArrayRangeEqualsSparseUnion/32768/0', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 274, 'null_percent': 0.0}\r\n   45           ArrayRangeEqualsDenseUnion/32768/0   12.995m items/sec   38.503m items/sec    196.287             {'run_name': 'ArrayRangeEqualsDenseUnion/32768/0', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 277, 'null_percent': 0.0}\r\n   7     ArrayRangeEqualsFixedSizeBinary/32768/100  274.991m items/sec  633.253m items/sec    130.281     {'run_name': 'ArrayRangeEqualsFixedSizeBinary/32768/100', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 5864, 'null_percent': 1.0}\r\n   13              ArrayRangeEqualsInt32/32768/100  729.634m items/sec    1.644b items/sec    125.256              {'run_name': 'ArrayRangeEqualsInt32/32768/100', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 15582, 'null_percent': 1.0}\r\n   12              ArrayRangeEqualsStruct/32768/10    6.948m items/sec   14.273m items/sec    105.427               {'run_name': 'ArrayRangeEqualsStruct/32768/10', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 147, 'null_percent': 10.0}\r\n   34               ArrayRangeEqualsStruct/32768/2   11.923m items/sec   23.845m items/sec     99.993                {'run_name': 'ArrayRangeEqualsStruct/32768/2', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 255, 'null_percent': 50.0}\r\n   10              ArrayRangeEqualsString/32768/10   73.461m items/sec  146.598m items/sec     99.558              {'run_name': 'ArrayRangeEqualsString/32768/10', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 1568, 'null_percent': 10.0}\r\n   48            ArrayRangeEqualsBoolean/32768/100  525.635m items/sec    1.026b items/sec     95.102            {'run_name': 'ArrayRangeEqualsBoolean/32768/100', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 11216, 'null_percent': 1.0}\r\n   21          ArrayRangeEqualsSparseUnion/32768/1   14.032m items/sec   26.225m items/sec     86.889          {'run_name': 'ArrayRangeEqualsSparseUnion/32768/1', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 300, 'null_percent': 100.0}\r\n   47          ArrayRangeEqualsSparseUnion/32768/2   12.643m items/sec   23.030m items/sec     82.160           {'run_name': 'ArrayRangeEqualsSparseUnion/32768/2', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 272, 'null_percent': 50.0}\r\n   43      ArrayRangeEqualsSparseUnion/32768/10000   12.596m items/sec   22.801m items/sec     81.018       {'run_name': 'ArrayRangeEqualsSparseUnion/32768/10000', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 264, 'null_percent': 0.01}\r\n   52         ArrayRangeEqualsSparseUnion/32768/10   12.717m items/sec   22.911m items/sec     80.168          {'run_name': 'ArrayRangeEqualsSparseUnion/32768/10', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 272, 'null_percent': 10.0}\r\n   0         ArrayRangeEqualsSparseUnion/32768/100   12.783m items/sec   22.714m items/sec     77.694          {'run_name': 'ArrayRangeEqualsSparseUnion/32768/100', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 275, 'null_percent': 1.0}\r\n   31           ArrayRangeEqualsDenseUnion/32768/1   14.509m items/sec   25.576m items/sec     76.279           {'run_name': 'ArrayRangeEqualsDenseUnion/32768/1', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 309, 'null_percent': 100.0}\r\n   20       ArrayRangeEqualsDenseUnion/32768/10000   13.193m items/sec   22.447m items/sec     70.152        {'run_name': 'ArrayRangeEqualsDenseUnion/32768/10000', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 280, 'null_percent': 0.01}\r\n   35         ArrayRangeEqualsDenseUnion/32768/100   13.204m items/sec   22.256m items/sec     68.561           {'run_name': 'ArrayRangeEqualsDenseUnion/32768/100', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 282, 'null_percent': 1.0}\r\n   40          ArrayRangeEqualsDenseUnion/32768/10   13.183m items/sec   22.191m items/sec     68.338           {'run_name': 'ArrayRangeEqualsDenseUnion/32768/10', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 279, 'null_percent': 10.0}\r\n   4            ArrayRangeEqualsDenseUnion/32768/2   13.148m items/sec   21.996m items/sec     67.297            {'run_name': 'ArrayRangeEqualsDenseUnion/32768/2', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 280, 'null_percent': 50.0}\r\n   22            ArrayRangeEqualsFloat32/32768/100  671.171m items/sec    1.097b items/sec     63.414            {'run_name': 'ArrayRangeEqualsFloat32/32768/100', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 14325, 'null_percent': 1.0}\r\n   30               ArrayRangeEqualsString/32768/2   94.060m items/sec  149.539m items/sec     58.983               {'run_name': 'ArrayRangeEqualsString/32768/2', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 2008, 'null_percent': 50.0}\r\n   37     ArrayRangeEqualsFixedSizeBinary/32768/10  250.975m items/sec  305.864m items/sec     21.870     {'run_name': 'ArrayRangeEqualsFixedSizeBinary/32768/10', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 5341, 'null_percent': 10.0}\r\n   32               ArrayRangeEqualsInt32/32768/10  607.891m items/sec  676.139m items/sec     11.227              {'run_name': 'ArrayRangeEqualsInt32/32768/10', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 12895, 'null_percent': 10.0}\r\n   8       ArrayRangeEqualsFixedSizeBinary/32768/2  187.404m items/sec  207.700m items/sec     10.830      {'run_name': 'ArrayRangeEqualsFixedSizeBinary/32768/2', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 3971, 'null_percent': 50.0}\r\n   49             ArrayRangeEqualsBoolean/32768/10  468.989m items/sec  518.521m items/sec     10.561             {'run_name': 'ArrayRangeEqualsBoolean/32768/10', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 9996, 'null_percent': 10.0}\r\n   5                 ArrayRangeEqualsInt32/32768/2  259.891m items/sec  270.547m items/sec      4.100                {'run_name': 'ArrayRangeEqualsInt32/32768/2', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 5505, 'null_percent': 50.0}\r\n   33              ArrayRangeEqualsFloat32/32768/2  262.994m items/sec  268.155m items/sec      1.962              {'run_name': 'ArrayRangeEqualsFloat32/32768/2', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 5580, 'null_percent': 50.0}\r\n   50             ArrayRangeEqualsFloat32/32768/10  577.200m items/sec  573.157m items/sec     -0.701            {'run_name': 'ArrayRangeEqualsFloat32/32768/10', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 12270, 'null_percent': 10.0}\r\n   2               ArrayRangeEqualsBoolean/32768/2  242.498m items/sec  230.947m items/sec     -4.763              {'run_name': 'ArrayRangeEqualsBoolean/32768/2', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 5152, 'null_percent': 50.0}\r\n   27        ArrayRangeEqualsListOfInt32/32768/100   28.080m items/sec   25.874m items/sec     -7.855          {'run_name': 'ArrayRangeEqualsListOfInt32/32768/100', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 598, 'null_percent': 1.0}\r\n   51          ArrayRangeEqualsListOfInt32/32768/2   18.613m items/sec   12.136m items/sec    -34.798           {'run_name': 'ArrayRangeEqualsListOfInt32/32768/2', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 397, 'null_percent': 50.0}\r\n   6          ArrayRangeEqualsListOfInt32/32768/10   26.194m items/sec   12.610m items/sec    -51.859          {'run_name': 'ArrayRangeEqualsListOfInt32/32768/10', 'run_type': 'iteration', 'repetitions': 0, 'repetition_index': 0, 'threads': 1, 'iterations': 560, 'null_percent': 10.0}\r\n   ```\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T10:01:12.516+0000",
                    "updated": "2020-11-18T10:01:12.516+0000",
                    "started": "2020-11-18T10:01:12.516+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513473",
                    "issueId": "13330181"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330181/worklog/513481",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8703:\nURL: https://github.com/apache/arrow/pull/8703#issuecomment-729584943\n\n\n   https://issues.apache.org/jira/browse/ARROW-10143\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T10:26:39.542+0000",
                    "updated": "2020-11-18T10:26:39.542+0000",
                    "started": "2020-11-18T10:26:39.542+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513481",
                    "issueId": "13330181"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330181/worklog/514082",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8703:\nURL: https://github.com/apache/arrow/pull/8703#discussion_r526854313\n\n\n\n##########\nFile path: cpp/src/arrow/ipc/feather_test.cc\n##########\n@@ -286,10 +286,13 @@ TEST_P(TestFeather, PrimitiveNullRoundTrip) {\n     std::vector<std::shared_ptr<Array>> expected_fields;\n     for (int i = 0; i < batch->num_columns(); ++i) {\n       ASSERT_EQ(batch->column_name(i), reader_->schema()->field(i)->name());\n-      StringArray str_values(batch->column(i)->length(), nullptr, nullptr,\n-                             batch->column(i)->null_bitmap(),\n-                             batch->column(i)->null_count());\n-      AssertArraysEqual(str_values, *result->column(i)->chunk(0));\n+      ASSERT_OK_AND_ASSIGN(auto expected, MakeArrayOfNull(utf8(), batch->num_rows()));\n+      AssertArraysEqual(*expected, *result->column(i)->chunk(0));\n+      //       StringArray str_values(batch->column(i)->length(), nullptr, nullptr,\n+      //                              batch->column(i)->null_bitmap(),\n+      //                              batch->column(i)->null_count());\n+      //       AssertArraysEqual(str_values, *result->column(i)->chunk(0),\n\nReview comment:\n       @wesm Is constructing a StringArray with null offsets and data supported (it's non-empty but all-nulls)?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-19T12:48:40.654+0000",
                    "updated": "2020-11-19T12:48:40.654+0000",
                    "started": "2020-11-19T12:48:40.654+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "514082",
                    "issueId": "13330181"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330181/worklog/514087",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #8703:\nURL: https://github.com/apache/arrow/pull/8703#issuecomment-730355163\n\n\n   Rebased.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-19T12:51:50.757+0000",
                    "updated": "2020-11-19T12:51:50.757+0000",
                    "started": "2020-11-19T12:51:50.757+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "514087",
                    "issueId": "13330181"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330181/worklog/514375",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on a change in pull request #8703:\nURL: https://github.com/apache/arrow/pull/8703#discussion_r527275663\n\n\n\n##########\nFile path: cpp/src/arrow/ipc/feather_test.cc\n##########\n@@ -286,10 +286,13 @@ TEST_P(TestFeather, PrimitiveNullRoundTrip) {\n     std::vector<std::shared_ptr<Array>> expected_fields;\n     for (int i = 0; i < batch->num_columns(); ++i) {\n       ASSERT_EQ(batch->column_name(i), reader_->schema()->field(i)->name());\n-      StringArray str_values(batch->column(i)->length(), nullptr, nullptr,\n-                             batch->column(i)->null_bitmap(),\n-                             batch->column(i)->null_count());\n-      AssertArraysEqual(str_values, *result->column(i)->chunk(0));\n+      ASSERT_OK_AND_ASSIGN(auto expected, MakeArrayOfNull(utf8(), batch->num_rows()));\n+      AssertArraysEqual(*expected, *result->column(i)->chunk(0));\n+      //       StringArray str_values(batch->column(i)->length(), nullptr, nullptr,\n+      //                              batch->column(i)->null_bitmap(),\n+      //                              batch->column(i)->null_count());\n+      //       AssertArraysEqual(str_values, *result->column(i)->chunk(0),\n\nReview comment:\n       I recall this question coming up in the past and I don't recall the outcome, @xhochy do you remember?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-19T23:37:53.369+0000",
                    "updated": "2020-11-19T23:37:53.369+0000",
                    "started": "2020-11-19T23:37:53.368+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "514375",
                    "issueId": "13330181"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330181/worklog/514894",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8703:\nURL: https://github.com/apache/arrow/pull/8703#discussion_r526259632\n\n\n\n##########\nFile path: cpp/src/arrow/ipc/feather_test.cc\n##########\n@@ -286,10 +286,13 @@ TEST_P(TestFeather, PrimitiveNullRoundTrip) {\n     std::vector<std::shared_ptr<Array>> expected_fields;\n     for (int i = 0; i < batch->num_columns(); ++i) {\n       ASSERT_EQ(batch->column_name(i), reader_->schema()->field(i)->name());\n-      StringArray str_values(batch->column(i)->length(), nullptr, nullptr,\n-                             batch->column(i)->null_bitmap(),\n-                             batch->column(i)->null_count());\n-      AssertArraysEqual(str_values, *result->column(i)->chunk(0));\n+      ASSERT_OK_AND_ASSIGN(auto expected, MakeArrayOfNull(utf8(), batch->num_rows()));\n+      AssertArraysEqual(*expected, *result->column(i)->chunk(0));\n+      //       StringArray str_values(batch->column(i)->length(), nullptr, nullptr,\n+      //                              batch->column(i)->null_bitmap(),\n+      //                              batch->column(i)->null_count());\n+      //       AssertArraysEqual(str_values, *result->column(i)->chunk(0),\n+      //       /*verbose=*/true);\n\nReview comment:\n       Looks like leftovers\r\n   ```suggestion\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/bit_run_reader.h\n##########\n@@ -162,5 +166,7 @@ class ARROW_EXPORT BitRunReader {\n using BitRunReader = BitRunReaderLinear;\n #endif\n \n+// TODO SetBitRunReader?\n+\n\nReview comment:\n       IIUC BitRunReader yields alternating set/unset BitRuns. Would SetBitRunReader yield only the set BitRuns?\n\n##########\nFile path: cpp/src/arrow/compare.cc\n##########\n@@ -49,700 +51,441 @@\n namespace arrow {\n \n using internal::BitmapEquals;\n+using internal::BitmapReader;\n+using internal::BitmapUInt64Reader;\n using internal::checked_cast;\n+using internal::OptionalBitBlockCounter;\n+using internal::OptionalBitmapEquals;\n \n // ----------------------------------------------------------------------\n // Public method implementations\n \n namespace {\n \n-// These helper functions assume we already checked the arrays have equal\n-// sizes and null bitmaps.\n+bool CompareArrayRanges(const ArrayData& left, const ArrayData& right,\n+                        int64_t left_start_idx, int64_t left_end_idx,\n+                        int64_t right_start_idx, const EqualOptions& options,\n+                        bool floating_approximate);\n \n-template <typename ArrowType, typename EqualityFunc>\n-inline bool BaseFloatingEquals(const NumericArray<ArrowType>& left,\n-                               const NumericArray<ArrowType>& right,\n-                               EqualityFunc&& equals) {\n-  using T = typename ArrowType::c_type;\n-\n-  const T* left_data = left.raw_values();\n-  const T* right_data = right.raw_values();\n-\n-  if (left.null_count() > 0) {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (left.IsNull(i)) continue;\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  } else {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingEquals(const NumericArray<ArrowType>& left,\n-                           const NumericArray<ArrowType>& right,\n-                           const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [](T x, T y) -> bool {\n-      return (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right,\n-                                         [](T x, T y) -> bool { return x == y; });\n-  }\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingApproxEquals(const NumericArray<ArrowType>& left,\n-                                 const NumericArray<ArrowType>& right,\n-                                 const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-  const T epsilon = static_cast<T>(opts.atol());\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y);\n-    });\n-  }\n-}\n-\n-// RangeEqualsVisitor assumes the range sizes are equal\n-\n-class RangeEqualsVisitor {\n+class RangeDataEqualsImpl {\n  public:\n-  RangeEqualsVisitor(const Array& right, int64_t left_start_idx, int64_t left_end_idx,\n-                     int64_t right_start_idx)\n-      : right_(right),\n+  // PRE-CONDITIONS:\n+  // - the types are equal\n+  // - the ranges are in bounds\n+  RangeDataEqualsImpl(const EqualOptions& options, bool floating_approximate,\n+                      const ArrayData& left, const ArrayData& right,\n+                      int64_t left_start_idx, int64_t right_start_idx,\n+                      int64_t range_length)\n+      : options_(options),\n+        floating_approximate_(floating_approximate),\n+        left_(left),\n+        right_(right),\n         left_start_idx_(left_start_idx),\n-        left_end_idx_(left_end_idx),\n         right_start_idx_(right_start_idx),\n+        range_length_(range_length),\n         result_(false) {}\n \n-  template <typename ArrayType>\n-  inline Status CompareValues(const ArrayType& left) {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i) ||\n-          (!is_null && left.Value(i) != right.Value(o_i))) {\n-        result_ = false;\n-        return Status::OK();\n+  bool Compare() {\n+    // Compare null bitmaps\n+    if (left_start_idx_ == 0 && right_start_idx_ == 0 && range_length_ == left_.length &&\n+        range_length_ == right_.length) {\n+      // If we're comparing entire arrays, we can first compare the cached null counts\n+      if (left_.GetNullCount() != right_.GetNullCount()) {\n+        return false;\n       }\n     }\n\nReview comment:\n       I'm not sure why this optimization only applies to entire arrays. Additionally, as currently stated it doesn't necessarily compare cached null counts.\r\n   \r\n   If we want to absolutely avoid accessing the null bitmap here, we'll need:\r\n   ```suggestion\r\n       // Compare null bitmaps\r\n       // Try to compare cached null counts first:\r\n       int64_t left_null_count = left_.null_count.load(), right_null_count = right_.null_count.load();\r\n       if (left_null_count != kUnknownNullCount && right_null_count != kUnknownNullCount &&\r\n           left_null_count != right_null_count) {\r\n         return false;\r\n       }\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compare.cc\n##########\n@@ -49,700 +51,441 @@\n namespace arrow {\n \n using internal::BitmapEquals;\n+using internal::BitmapReader;\n+using internal::BitmapUInt64Reader;\n using internal::checked_cast;\n+using internal::OptionalBitBlockCounter;\n+using internal::OptionalBitmapEquals;\n \n // ----------------------------------------------------------------------\n // Public method implementations\n \n namespace {\n \n-// These helper functions assume we already checked the arrays have equal\n-// sizes and null bitmaps.\n+bool CompareArrayRanges(const ArrayData& left, const ArrayData& right,\n+                        int64_t left_start_idx, int64_t left_end_idx,\n+                        int64_t right_start_idx, const EqualOptions& options,\n+                        bool floating_approximate);\n \n-template <typename ArrowType, typename EqualityFunc>\n-inline bool BaseFloatingEquals(const NumericArray<ArrowType>& left,\n-                               const NumericArray<ArrowType>& right,\n-                               EqualityFunc&& equals) {\n-  using T = typename ArrowType::c_type;\n-\n-  const T* left_data = left.raw_values();\n-  const T* right_data = right.raw_values();\n-\n-  if (left.null_count() > 0) {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (left.IsNull(i)) continue;\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  } else {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingEquals(const NumericArray<ArrowType>& left,\n-                           const NumericArray<ArrowType>& right,\n-                           const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [](T x, T y) -> bool {\n-      return (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right,\n-                                         [](T x, T y) -> bool { return x == y; });\n-  }\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingApproxEquals(const NumericArray<ArrowType>& left,\n-                                 const NumericArray<ArrowType>& right,\n-                                 const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-  const T epsilon = static_cast<T>(opts.atol());\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y);\n-    });\n-  }\n-}\n-\n-// RangeEqualsVisitor assumes the range sizes are equal\n-\n-class RangeEqualsVisitor {\n+class RangeDataEqualsImpl {\n  public:\n-  RangeEqualsVisitor(const Array& right, int64_t left_start_idx, int64_t left_end_idx,\n-                     int64_t right_start_idx)\n-      : right_(right),\n+  // PRE-CONDITIONS:\n+  // - the types are equal\n+  // - the ranges are in bounds\n+  RangeDataEqualsImpl(const EqualOptions& options, bool floating_approximate,\n+                      const ArrayData& left, const ArrayData& right,\n+                      int64_t left_start_idx, int64_t right_start_idx,\n+                      int64_t range_length)\n+      : options_(options),\n+        floating_approximate_(floating_approximate),\n+        left_(left),\n+        right_(right),\n         left_start_idx_(left_start_idx),\n-        left_end_idx_(left_end_idx),\n         right_start_idx_(right_start_idx),\n+        range_length_(range_length),\n         result_(false) {}\n \n-  template <typename ArrayType>\n-  inline Status CompareValues(const ArrayType& left) {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i) ||\n-          (!is_null && left.Value(i) != right.Value(o_i))) {\n-        result_ = false;\n-        return Status::OK();\n+  bool Compare() {\n+    // Compare null bitmaps\n+    if (left_start_idx_ == 0 && right_start_idx_ == 0 && range_length_ == left_.length &&\n+        range_length_ == right_.length) {\n+      // If we're comparing entire arrays, we can first compare the cached null counts\n+      if (left_.GetNullCount() != right_.GetNullCount()) {\n+        return false;\n       }\n     }\n-    result_ = true;\n-    return Status::OK();\n+    if (!OptionalBitmapEquals(left_.buffers[0], left_.offset + left_start_idx_,\n+                              right_.buffers[0], right_.offset + right_start_idx_,\n+                              range_length_)) {\n+      return false;\n+    }\n+    // Compare values\n+    return CompareWithType(*left_.type);\n   }\n \n-  template <typename ArrayType, typename CompareValuesFunc>\n-  bool CompareWithOffsets(const ArrayType& left,\n-                          CompareValuesFunc&& compare_values) const {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (is_null) continue;\n-      const auto begin_offset = left.value_offset(i);\n-      const auto end_offset = left.value_offset(i + 1);\n-      const auto right_begin_offset = right.value_offset(o_i);\n-      const auto right_end_offset = right.value_offset(o_i + 1);\n-      // Underlying can't be equal if the size isn't equal\n-      if (end_offset - begin_offset != right_end_offset - right_begin_offset) {\n-        return false;\n-      }\n-\n-      if (!compare_values(left, right, begin_offset, right_begin_offset,\n-                          end_offset - begin_offset)) {\n-        return false;\n-      }\n+  bool CompareWithType(const DataType& type) {\n+    result_ = true;\n+    if (range_length_ != 0) {\n+      ARROW_CHECK_OK(VisitTypeInline(type, this));\n     }\n-    return true;\n+    return result_;\n   }\n \n-  template <typename BinaryArrayType>\n-  bool CompareBinaryRange(const BinaryArrayType& left) const {\n-    using offset_type = typename BinaryArrayType::offset_type;\n+  Status Visit(const NullType&) { return Status::OK(); }\n \n-    auto compare_values = [](const BinaryArrayType& left, const BinaryArrayType& right,\n-                             offset_type left_offset, offset_type right_offset,\n-                             offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return std::memcmp(left.value_data()->data() + left_offset,\n-                         right.value_data()->data() + right_offset,\n-                         static_cast<size_t>(nvalues)) == 0;\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_primitive_ctype<TypeClass, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  template <typename ListArrayType>\n-  bool CompareLists(const ListArrayType& left) {\n-    using offset_type = typename ListArrayType::offset_type;\n-    const auto& right = checked_cast<const ListArrayType&>(right_);\n-    const std::shared_ptr<Array>& left_values = left.values();\n-    const std::shared_ptr<Array>& right_values = right.values();\n-\n-    auto compare_values = [&](const ListArrayType& left, const ListArrayType& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_values->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                      right_values);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n-  }\n-\n-  bool CompareMaps(const MapArray& left) {\n-    // We need a specific comparison helper for maps to avoid comparing\n-    // struct field names (which are indifferent for maps)\n-    using offset_type = typename MapArray::offset_type;\n-    const auto& right = checked_cast<const MapArray&>(right_);\n-    const auto left_keys = left.keys();\n-    const auto left_items = left.items();\n-    const auto right_keys = right.keys();\n-    const auto right_items = right.items();\n-\n-    auto compare_values = [&](const MapArray& left, const MapArray& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_keys->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                    right_keys) &&\n-             left_items->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                     right_items);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_t<is_temporal_type<TypeClass>::value, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  bool CompareStructs(const StructArray& left) {\n-    const auto& right = checked_cast<const StructArray&>(right_);\n-    bool equal_fields = true;\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      for (int j = 0; j < left.num_fields(); ++j) {\n-        // TODO: really we should be comparing stretches of non-null data rather\n-        // than looking at one value at a time.\n-        equal_fields = left.field(j)->RangeEquals(i, i + 1, o_i, right.field(j));\n-        if (!equal_fields) {\n-          return false;\n-        }\n-      }\n-    }\n-    return true;\n-  }\n-\n-  bool CompareUnions(const UnionArray& left) const {\n-    const auto& right = checked_cast<const UnionArray&>(right_);\n-\n-    const UnionMode::type union_mode = left.mode();\n-    if (union_mode != right.mode()) {\n-      return false;\n-    }\n-\n-    const auto& left_type = checked_cast<const UnionType&>(*left.type());\n-\n-    const std::vector<int>& child_ids = left_type.child_ids();\n-\n-    const int8_t* left_codes = left.raw_type_codes();\n-    const int8_t* right_codes = right.raw_type_codes();\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      if (left_codes[i] != right_codes[o_i]) {\n-        return false;\n-      }\n-\n-      auto child_num = child_ids[left_codes[i]];\n-\n-      // TODO(wesm): really we should be comparing stretches of non-null data\n-      // rather than looking at one value at a time.\n-      if (union_mode == UnionMode::SPARSE) {\n-        if (!left.field(child_num)->RangeEquals(i, i + 1, o_i, right.field(child_num))) {\n-          return false;\n+  Status Visit(const BooleanType&) {\n+    const uint8_t* left_bits = left_.GetValues<uint8_t>(1, 0);\n+    const uint8_t* right_bits = right_.GetValues<uint8_t>(1, 0);\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      if (length <= 8) {\n+        // Avoid the BitmapUInt64Reader overhead for very small runs\n+        for (int64_t j = i; j < i + length; ++j) {\n+          if (BitUtil::GetBit(left_bits, left_start_idx_ + left_.offset + j) !=\n+              BitUtil::GetBit(right_bits, right_start_idx_ + right_.offset + j)) {\n+            return false;\n+          }\n         }\n+        return true;\n       } else {\n-        const int32_t offset =\n-            checked_cast<const DenseUnionArray&>(left).raw_value_offsets()[i];\n-        const int32_t o_offset =\n-            checked_cast<const DenseUnionArray&>(right).raw_value_offsets()[o_i];\n-        if (!left.field(child_num)->RangeEquals(offset, offset + 1, o_offset,\n-                                                right.field(child_num))) {\n-          return false;\n+        BitmapUInt64Reader left_reader(left_bits, left_start_idx_ + left_.offset + i,\n+                                       length);\n+        BitmapUInt64Reader right_reader(right_bits, right_start_idx_ + right_.offset + i,\n+                                        length);\n+        while (left_reader.position() < length) {\n+          if (left_reader.NextWord() != right_reader.NextWord()) {\n+            return false;\n+          }\n         }\n+        DCHECK_EQ(right_reader.position(), length);\n       }\n-    }\n-    return true;\n-  }\n-\n-  Status Visit(const BinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n-    return Status::OK();\n-  }\n-\n-  Status Visit(const LargeBinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n+      return true;\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const FixedSizeBinaryArray& left) {\n-    const auto& right = checked_cast<const FixedSizeBinaryArray&>(right_);\n+  Status Visit(const FloatType& type) { return CompareFloating(type); }\n \n-    int32_t width = left.byte_width();\n+  Status Visit(const DoubleType& type) { return CompareFloating(type); }\n \n-    const uint8_t* left_data = nullptr;\n-    const uint8_t* right_data = nullptr;\n+  // Also matches StringType\n+  Status Visit(const BinaryType& type) { return CompareBinary(type); }\n \n-    if (left.values()) {\n-      left_data = left.raw_values();\n-    }\n+  // Also matches LargeStringType\n+  Status Visit(const LargeBinaryType& type) { return CompareBinary(type); }\n \n-    if (right.values()) {\n-      right_data = right.raw_values();\n-    }\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i)) {\n-        result_ = false;\n-        return Status::OK();\n-      }\n-      if (is_null) continue;\n+  Status Visit(const FixedSizeBinaryType& type) {\n+    const auto byte_width = type.byte_width();\n+    const uint8_t* left_data = left_.GetValues<uint8_t>(1, 0);\n+    const uint8_t* right_data = right_.GetValues<uint8_t>(1, 0);\n \n-      if (std::memcmp(left_data + width * i, right_data + width * o_i, width)) {\n-        result_ = false;\n-        return Status::OK();\n-      }\n+    if (left_data != nullptr && right_data != nullptr) {\n+      auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+        return memcmp(left_data + (left_start_idx_ + left_.offset + i) * byte_width,\n+                      right_data + (right_start_idx_ + right_.offset + i) * byte_width,\n+                      length * byte_width) == 0;\n+      };\n+      VisitValidRuns(compare_runs);\n+    } else {\n+      auto compare_runs = [&](int64_t i, int64_t length) -> bool { return true; };\n+      VisitValidRuns(compare_runs);\n     }\n-    result_ = true;\n     return Status::OK();\n   }\n \n-  Status Visit(const Decimal128Array& left) {\n-    return Visit(checked_cast<const FixedSizeBinaryArray&>(left));\n-  }\n+  // Also matches MapType\n+  Status Visit(const ListType& type) { return CompareList(type); }\n \n-  Status Visit(const Decimal256Array& left) {\n-    return Visit(checked_cast<const FixedSizeBinaryArray&>(left));\n-  }\n+  Status Visit(const LargeListType& type) { return CompareList(type); }\n \n-  Status Visit(const NullArray& left) {\n-    ARROW_UNUSED(left);\n-    result_ = true;\n-    return Status::OK();\n-  }\n-\n-  template <typename T>\n-  typename std::enable_if<std::is_base_of<PrimitiveArray, T>::value, Status>::type Visit(\n-      const T& left) {\n-    return CompareValues<T>(left);\n-  }\n+  Status Visit(const FixedSizeListType& type) {\n+    const auto list_size = type.list_size();\n+    const ArrayData& left_data = *left_.child_data[0];\n+    const ArrayData& right_data = *right_.child_data[0];\n \n-  Status Visit(const ListArray& left) {\n-    result_ = CompareLists(left);\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      RangeDataEqualsImpl impl(options_, floating_approximate_, left_data, right_data,\n+                               (left_start_idx_ + left_.offset + i) * list_size,\n+                               (right_start_idx_ + right_.offset + i) * list_size,\n+                               length * list_size);\n+      return impl.Compare();\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const LargeListArray& left) {\n-    result_ = CompareLists(left);\n-    return Status::OK();\n-  }\n+  Status Visit(const StructType& type) {\n+    const int32_t num_fields = type.num_fields();\n \n-  Status Visit(const FixedSizeListArray& left) {\n-    const auto& right = checked_cast<const FixedSizeListArray&>(right_);\n-    result_ = left.values()->RangeEquals(\n-        left.value_offset(left_start_idx_), left.value_offset(left_end_idx_),\n-        right.value_offset(right_start_idx_), right.values());\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      for (int32_t f = 0; f < num_fields; ++f) {\n+        RangeDataEqualsImpl impl(options_, floating_approximate_, *left_.child_data[f],\n+                                 *right_.child_data[f],\n+                                 left_start_idx_ + left_.offset + i,\n+                                 right_start_idx_ + right_.offset + i, length);\n+        if (!impl.Compare()) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const MapArray& left) {\n-    result_ = CompareMaps(left);\n-    return Status::OK();\n-  }\n+  Status Visit(const SparseUnionType& type) {\n+    const auto& child_ids = type.child_ids();\n+    const int8_t* left_codes = left_.GetValues<int8_t>(1);\n+    const int8_t* right_codes = right_.GetValues<int8_t>(1);\n \n-  Status Visit(const StructArray& left) {\n-    result_ = CompareStructs(left);\n+    VisitValidRuns([&](int64_t i, int64_t length) {\n\nReview comment:\n       Since unions don't have top level nulls is this worthwhile?\n\n##########\nFile path: cpp/src/arrow/array/diff.h\n##########\n@@ -59,6 +57,27 @@ ARROW_EXPORT\n Result<std::shared_ptr<StructArray>> Diff(const Array& base, const Array& target,\n                                           MemoryPool* pool = default_memory_pool());\n \n+/// \\brief Compare two array ranges, returning an edit script which expresses the\n+/// difference between them\n+///\n+/// Same as Diff(), but only the ranges defined by the given offsets and lengths\n+/// are compared.\n+///\n+/// \\param[in] base baseline for comparison\n+/// \\param[in] target an array of identical type to base whose elements differ from base's\n+/// \\param[in] base_offset the start offset of the range to consider inside `base`\n+/// \\param[in] base_length the length of the range to consider inside `base`\n+/// \\param[in] target_offset the start offset of the range to consider inside `target`\n+/// \\param[in] target_length the length of the range to consider inside `target`\n+/// \\param[in] pool memory to store the result will be allocated from this memory pool\n+/// \\return an edit script array which can be applied to base to produce target\n+ARROW_EXPORT\n+Result<std::shared_ptr<StructArray>> DiffRanges(const Array& base, const Array& target,\n\nReview comment:\n       Not really an objection, but: I'm not sure what this adds over applying the ranges to the base and target ArrayData then running Diff on those\n\n##########\nFile path: cpp/src/arrow/compare.cc\n##########\n@@ -49,700 +51,441 @@\n namespace arrow {\n \n using internal::BitmapEquals;\n+using internal::BitmapReader;\n+using internal::BitmapUInt64Reader;\n using internal::checked_cast;\n+using internal::OptionalBitBlockCounter;\n+using internal::OptionalBitmapEquals;\n \n // ----------------------------------------------------------------------\n // Public method implementations\n \n namespace {\n \n-// These helper functions assume we already checked the arrays have equal\n-// sizes and null bitmaps.\n+bool CompareArrayRanges(const ArrayData& left, const ArrayData& right,\n+                        int64_t left_start_idx, int64_t left_end_idx,\n+                        int64_t right_start_idx, const EqualOptions& options,\n+                        bool floating_approximate);\n \n-template <typename ArrowType, typename EqualityFunc>\n-inline bool BaseFloatingEquals(const NumericArray<ArrowType>& left,\n-                               const NumericArray<ArrowType>& right,\n-                               EqualityFunc&& equals) {\n-  using T = typename ArrowType::c_type;\n-\n-  const T* left_data = left.raw_values();\n-  const T* right_data = right.raw_values();\n-\n-  if (left.null_count() > 0) {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (left.IsNull(i)) continue;\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  } else {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingEquals(const NumericArray<ArrowType>& left,\n-                           const NumericArray<ArrowType>& right,\n-                           const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [](T x, T y) -> bool {\n-      return (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right,\n-                                         [](T x, T y) -> bool { return x == y; });\n-  }\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingApproxEquals(const NumericArray<ArrowType>& left,\n-                                 const NumericArray<ArrowType>& right,\n-                                 const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-  const T epsilon = static_cast<T>(opts.atol());\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y);\n-    });\n-  }\n-}\n-\n-// RangeEqualsVisitor assumes the range sizes are equal\n-\n-class RangeEqualsVisitor {\n+class RangeDataEqualsImpl {\n  public:\n-  RangeEqualsVisitor(const Array& right, int64_t left_start_idx, int64_t left_end_idx,\n-                     int64_t right_start_idx)\n-      : right_(right),\n+  // PRE-CONDITIONS:\n+  // - the types are equal\n+  // - the ranges are in bounds\n+  RangeDataEqualsImpl(const EqualOptions& options, bool floating_approximate,\n+                      const ArrayData& left, const ArrayData& right,\n+                      int64_t left_start_idx, int64_t right_start_idx,\n+                      int64_t range_length)\n+      : options_(options),\n+        floating_approximate_(floating_approximate),\n+        left_(left),\n+        right_(right),\n         left_start_idx_(left_start_idx),\n-        left_end_idx_(left_end_idx),\n         right_start_idx_(right_start_idx),\n+        range_length_(range_length),\n         result_(false) {}\n \n-  template <typename ArrayType>\n-  inline Status CompareValues(const ArrayType& left) {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i) ||\n-          (!is_null && left.Value(i) != right.Value(o_i))) {\n-        result_ = false;\n-        return Status::OK();\n+  bool Compare() {\n+    // Compare null bitmaps\n+    if (left_start_idx_ == 0 && right_start_idx_ == 0 && range_length_ == left_.length &&\n+        range_length_ == right_.length) {\n+      // If we're comparing entire arrays, we can first compare the cached null counts\n+      if (left_.GetNullCount() != right_.GetNullCount()) {\n+        return false;\n       }\n     }\n-    result_ = true;\n-    return Status::OK();\n+    if (!OptionalBitmapEquals(left_.buffers[0], left_.offset + left_start_idx_,\n+                              right_.buffers[0], right_.offset + right_start_idx_,\n+                              range_length_)) {\n+      return false;\n+    }\n+    // Compare values\n+    return CompareWithType(*left_.type);\n   }\n \n-  template <typename ArrayType, typename CompareValuesFunc>\n-  bool CompareWithOffsets(const ArrayType& left,\n-                          CompareValuesFunc&& compare_values) const {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (is_null) continue;\n-      const auto begin_offset = left.value_offset(i);\n-      const auto end_offset = left.value_offset(i + 1);\n-      const auto right_begin_offset = right.value_offset(o_i);\n-      const auto right_end_offset = right.value_offset(o_i + 1);\n-      // Underlying can't be equal if the size isn't equal\n-      if (end_offset - begin_offset != right_end_offset - right_begin_offset) {\n-        return false;\n-      }\n-\n-      if (!compare_values(left, right, begin_offset, right_begin_offset,\n-                          end_offset - begin_offset)) {\n-        return false;\n-      }\n+  bool CompareWithType(const DataType& type) {\n+    result_ = true;\n+    if (range_length_ != 0) {\n+      ARROW_CHECK_OK(VisitTypeInline(type, this));\n     }\n-    return true;\n+    return result_;\n   }\n \n-  template <typename BinaryArrayType>\n-  bool CompareBinaryRange(const BinaryArrayType& left) const {\n-    using offset_type = typename BinaryArrayType::offset_type;\n+  Status Visit(const NullType&) { return Status::OK(); }\n \n-    auto compare_values = [](const BinaryArrayType& left, const BinaryArrayType& right,\n-                             offset_type left_offset, offset_type right_offset,\n-                             offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return std::memcmp(left.value_data()->data() + left_offset,\n-                         right.value_data()->data() + right_offset,\n-                         static_cast<size_t>(nvalues)) == 0;\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_primitive_ctype<TypeClass, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  template <typename ListArrayType>\n-  bool CompareLists(const ListArrayType& left) {\n-    using offset_type = typename ListArrayType::offset_type;\n-    const auto& right = checked_cast<const ListArrayType&>(right_);\n-    const std::shared_ptr<Array>& left_values = left.values();\n-    const std::shared_ptr<Array>& right_values = right.values();\n-\n-    auto compare_values = [&](const ListArrayType& left, const ListArrayType& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_values->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                      right_values);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n-  }\n-\n-  bool CompareMaps(const MapArray& left) {\n-    // We need a specific comparison helper for maps to avoid comparing\n-    // struct field names (which are indifferent for maps)\n-    using offset_type = typename MapArray::offset_type;\n-    const auto& right = checked_cast<const MapArray&>(right_);\n-    const auto left_keys = left.keys();\n-    const auto left_items = left.items();\n-    const auto right_keys = right.keys();\n-    const auto right_items = right.items();\n-\n-    auto compare_values = [&](const MapArray& left, const MapArray& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_keys->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                    right_keys) &&\n-             left_items->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                     right_items);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_t<is_temporal_type<TypeClass>::value, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  bool CompareStructs(const StructArray& left) {\n-    const auto& right = checked_cast<const StructArray&>(right_);\n-    bool equal_fields = true;\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      for (int j = 0; j < left.num_fields(); ++j) {\n-        // TODO: really we should be comparing stretches of non-null data rather\n-        // than looking at one value at a time.\n-        equal_fields = left.field(j)->RangeEquals(i, i + 1, o_i, right.field(j));\n-        if (!equal_fields) {\n-          return false;\n-        }\n-      }\n-    }\n-    return true;\n-  }\n-\n-  bool CompareUnions(const UnionArray& left) const {\n-    const auto& right = checked_cast<const UnionArray&>(right_);\n-\n-    const UnionMode::type union_mode = left.mode();\n-    if (union_mode != right.mode()) {\n-      return false;\n-    }\n-\n-    const auto& left_type = checked_cast<const UnionType&>(*left.type());\n-\n-    const std::vector<int>& child_ids = left_type.child_ids();\n-\n-    const int8_t* left_codes = left.raw_type_codes();\n-    const int8_t* right_codes = right.raw_type_codes();\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      if (left_codes[i] != right_codes[o_i]) {\n-        return false;\n-      }\n-\n-      auto child_num = child_ids[left_codes[i]];\n-\n-      // TODO(wesm): really we should be comparing stretches of non-null data\n-      // rather than looking at one value at a time.\n-      if (union_mode == UnionMode::SPARSE) {\n-        if (!left.field(child_num)->RangeEquals(i, i + 1, o_i, right.field(child_num))) {\n-          return false;\n+  Status Visit(const BooleanType&) {\n+    const uint8_t* left_bits = left_.GetValues<uint8_t>(1, 0);\n+    const uint8_t* right_bits = right_.GetValues<uint8_t>(1, 0);\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      if (length <= 8) {\n+        // Avoid the BitmapUInt64Reader overhead for very small runs\n+        for (int64_t j = i; j < i + length; ++j) {\n+          if (BitUtil::GetBit(left_bits, left_start_idx_ + left_.offset + j) !=\n+              BitUtil::GetBit(right_bits, right_start_idx_ + right_.offset + j)) {\n+            return false;\n+          }\n         }\n+        return true;\n       } else {\n-        const int32_t offset =\n-            checked_cast<const DenseUnionArray&>(left).raw_value_offsets()[i];\n-        const int32_t o_offset =\n-            checked_cast<const DenseUnionArray&>(right).raw_value_offsets()[o_i];\n-        if (!left.field(child_num)->RangeEquals(offset, offset + 1, o_offset,\n-                                                right.field(child_num))) {\n-          return false;\n+        BitmapUInt64Reader left_reader(left_bits, left_start_idx_ + left_.offset + i,\n+                                       length);\n+        BitmapUInt64Reader right_reader(right_bits, right_start_idx_ + right_.offset + i,\n+                                        length);\n+        while (left_reader.position() < length) {\n+          if (left_reader.NextWord() != right_reader.NextWord()) {\n+            return false;\n+          }\n         }\n+        DCHECK_EQ(right_reader.position(), length);\n       }\n-    }\n-    return true;\n-  }\n-\n-  Status Visit(const BinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n-    return Status::OK();\n-  }\n-\n-  Status Visit(const LargeBinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n+      return true;\n+    };\n+    VisitValidRuns(compare_runs);\n\nReview comment:\n       This seems like a generally useful bitmap comparison utility. If it's faster than BitmapsEqual then maybe it could replace that function?\n\n##########\nFile path: cpp/src/arrow/compare.cc\n##########\n@@ -49,700 +51,441 @@\n namespace arrow {\n \n using internal::BitmapEquals;\n+using internal::BitmapReader;\n+using internal::BitmapUInt64Reader;\n using internal::checked_cast;\n+using internal::OptionalBitBlockCounter;\n+using internal::OptionalBitmapEquals;\n \n // ----------------------------------------------------------------------\n // Public method implementations\n \n namespace {\n \n-// These helper functions assume we already checked the arrays have equal\n-// sizes and null bitmaps.\n+bool CompareArrayRanges(const ArrayData& left, const ArrayData& right,\n+                        int64_t left_start_idx, int64_t left_end_idx,\n+                        int64_t right_start_idx, const EqualOptions& options,\n+                        bool floating_approximate);\n \n-template <typename ArrowType, typename EqualityFunc>\n-inline bool BaseFloatingEquals(const NumericArray<ArrowType>& left,\n-                               const NumericArray<ArrowType>& right,\n-                               EqualityFunc&& equals) {\n-  using T = typename ArrowType::c_type;\n-\n-  const T* left_data = left.raw_values();\n-  const T* right_data = right.raw_values();\n-\n-  if (left.null_count() > 0) {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (left.IsNull(i)) continue;\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  } else {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingEquals(const NumericArray<ArrowType>& left,\n-                           const NumericArray<ArrowType>& right,\n-                           const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [](T x, T y) -> bool {\n-      return (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right,\n-                                         [](T x, T y) -> bool { return x == y; });\n-  }\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingApproxEquals(const NumericArray<ArrowType>& left,\n-                                 const NumericArray<ArrowType>& right,\n-                                 const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-  const T epsilon = static_cast<T>(opts.atol());\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y);\n-    });\n-  }\n-}\n-\n-// RangeEqualsVisitor assumes the range sizes are equal\n-\n-class RangeEqualsVisitor {\n+class RangeDataEqualsImpl {\n  public:\n-  RangeEqualsVisitor(const Array& right, int64_t left_start_idx, int64_t left_end_idx,\n-                     int64_t right_start_idx)\n-      : right_(right),\n+  // PRE-CONDITIONS:\n+  // - the types are equal\n+  // - the ranges are in bounds\n+  RangeDataEqualsImpl(const EqualOptions& options, bool floating_approximate,\n+                      const ArrayData& left, const ArrayData& right,\n+                      int64_t left_start_idx, int64_t right_start_idx,\n+                      int64_t range_length)\n+      : options_(options),\n+        floating_approximate_(floating_approximate),\n+        left_(left),\n+        right_(right),\n         left_start_idx_(left_start_idx),\n-        left_end_idx_(left_end_idx),\n         right_start_idx_(right_start_idx),\n+        range_length_(range_length),\n         result_(false) {}\n \n-  template <typename ArrayType>\n-  inline Status CompareValues(const ArrayType& left) {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i) ||\n-          (!is_null && left.Value(i) != right.Value(o_i))) {\n-        result_ = false;\n-        return Status::OK();\n+  bool Compare() {\n+    // Compare null bitmaps\n+    if (left_start_idx_ == 0 && right_start_idx_ == 0 && range_length_ == left_.length &&\n+        range_length_ == right_.length) {\n+      // If we're comparing entire arrays, we can first compare the cached null counts\n+      if (left_.GetNullCount() != right_.GetNullCount()) {\n+        return false;\n       }\n     }\n-    result_ = true;\n-    return Status::OK();\n+    if (!OptionalBitmapEquals(left_.buffers[0], left_.offset + left_start_idx_,\n+                              right_.buffers[0], right_.offset + right_start_idx_,\n+                              range_length_)) {\n+      return false;\n+    }\n+    // Compare values\n+    return CompareWithType(*left_.type);\n   }\n \n-  template <typename ArrayType, typename CompareValuesFunc>\n-  bool CompareWithOffsets(const ArrayType& left,\n-                          CompareValuesFunc&& compare_values) const {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (is_null) continue;\n-      const auto begin_offset = left.value_offset(i);\n-      const auto end_offset = left.value_offset(i + 1);\n-      const auto right_begin_offset = right.value_offset(o_i);\n-      const auto right_end_offset = right.value_offset(o_i + 1);\n-      // Underlying can't be equal if the size isn't equal\n-      if (end_offset - begin_offset != right_end_offset - right_begin_offset) {\n-        return false;\n-      }\n-\n-      if (!compare_values(left, right, begin_offset, right_begin_offset,\n-                          end_offset - begin_offset)) {\n-        return false;\n-      }\n+  bool CompareWithType(const DataType& type) {\n+    result_ = true;\n+    if (range_length_ != 0) {\n+      ARROW_CHECK_OK(VisitTypeInline(type, this));\n     }\n-    return true;\n+    return result_;\n   }\n \n-  template <typename BinaryArrayType>\n-  bool CompareBinaryRange(const BinaryArrayType& left) const {\n-    using offset_type = typename BinaryArrayType::offset_type;\n+  Status Visit(const NullType&) { return Status::OK(); }\n \n-    auto compare_values = [](const BinaryArrayType& left, const BinaryArrayType& right,\n-                             offset_type left_offset, offset_type right_offset,\n-                             offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return std::memcmp(left.value_data()->data() + left_offset,\n-                         right.value_data()->data() + right_offset,\n-                         static_cast<size_t>(nvalues)) == 0;\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_primitive_ctype<TypeClass, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  template <typename ListArrayType>\n-  bool CompareLists(const ListArrayType& left) {\n-    using offset_type = typename ListArrayType::offset_type;\n-    const auto& right = checked_cast<const ListArrayType&>(right_);\n-    const std::shared_ptr<Array>& left_values = left.values();\n-    const std::shared_ptr<Array>& right_values = right.values();\n-\n-    auto compare_values = [&](const ListArrayType& left, const ListArrayType& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_values->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                      right_values);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n-  }\n-\n-  bool CompareMaps(const MapArray& left) {\n-    // We need a specific comparison helper for maps to avoid comparing\n-    // struct field names (which are indifferent for maps)\n-    using offset_type = typename MapArray::offset_type;\n-    const auto& right = checked_cast<const MapArray&>(right_);\n-    const auto left_keys = left.keys();\n-    const auto left_items = left.items();\n-    const auto right_keys = right.keys();\n-    const auto right_items = right.items();\n-\n-    auto compare_values = [&](const MapArray& left, const MapArray& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_keys->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                    right_keys) &&\n-             left_items->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                     right_items);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_t<is_temporal_type<TypeClass>::value, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  bool CompareStructs(const StructArray& left) {\n-    const auto& right = checked_cast<const StructArray&>(right_);\n-    bool equal_fields = true;\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      for (int j = 0; j < left.num_fields(); ++j) {\n-        // TODO: really we should be comparing stretches of non-null data rather\n-        // than looking at one value at a time.\n-        equal_fields = left.field(j)->RangeEquals(i, i + 1, o_i, right.field(j));\n-        if (!equal_fields) {\n-          return false;\n-        }\n-      }\n-    }\n-    return true;\n-  }\n-\n-  bool CompareUnions(const UnionArray& left) const {\n-    const auto& right = checked_cast<const UnionArray&>(right_);\n-\n-    const UnionMode::type union_mode = left.mode();\n-    if (union_mode != right.mode()) {\n-      return false;\n-    }\n-\n-    const auto& left_type = checked_cast<const UnionType&>(*left.type());\n-\n-    const std::vector<int>& child_ids = left_type.child_ids();\n-\n-    const int8_t* left_codes = left.raw_type_codes();\n-    const int8_t* right_codes = right.raw_type_codes();\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      if (left_codes[i] != right_codes[o_i]) {\n-        return false;\n-      }\n-\n-      auto child_num = child_ids[left_codes[i]];\n-\n-      // TODO(wesm): really we should be comparing stretches of non-null data\n-      // rather than looking at one value at a time.\n-      if (union_mode == UnionMode::SPARSE) {\n-        if (!left.field(child_num)->RangeEquals(i, i + 1, o_i, right.field(child_num))) {\n-          return false;\n+  Status Visit(const BooleanType&) {\n+    const uint8_t* left_bits = left_.GetValues<uint8_t>(1, 0);\n+    const uint8_t* right_bits = right_.GetValues<uint8_t>(1, 0);\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      if (length <= 8) {\n+        // Avoid the BitmapUInt64Reader overhead for very small runs\n+        for (int64_t j = i; j < i + length; ++j) {\n+          if (BitUtil::GetBit(left_bits, left_start_idx_ + left_.offset + j) !=\n+              BitUtil::GetBit(right_bits, right_start_idx_ + right_.offset + j)) {\n+            return false;\n+          }\n         }\n+        return true;\n       } else {\n-        const int32_t offset =\n-            checked_cast<const DenseUnionArray&>(left).raw_value_offsets()[i];\n-        const int32_t o_offset =\n-            checked_cast<const DenseUnionArray&>(right).raw_value_offsets()[o_i];\n-        if (!left.field(child_num)->RangeEquals(offset, offset + 1, o_offset,\n-                                                right.field(child_num))) {\n-          return false;\n+        BitmapUInt64Reader left_reader(left_bits, left_start_idx_ + left_.offset + i,\n+                                       length);\n+        BitmapUInt64Reader right_reader(right_bits, right_start_idx_ + right_.offset + i,\n+                                        length);\n+        while (left_reader.position() < length) {\n+          if (left_reader.NextWord() != right_reader.NextWord()) {\n+            return false;\n+          }\n         }\n+        DCHECK_EQ(right_reader.position(), length);\n       }\n-    }\n-    return true;\n-  }\n-\n-  Status Visit(const BinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n-    return Status::OK();\n-  }\n-\n-  Status Visit(const LargeBinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n+      return true;\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const FixedSizeBinaryArray& left) {\n-    const auto& right = checked_cast<const FixedSizeBinaryArray&>(right_);\n+  Status Visit(const FloatType& type) { return CompareFloating(type); }\n \n-    int32_t width = left.byte_width();\n+  Status Visit(const DoubleType& type) { return CompareFloating(type); }\n \n-    const uint8_t* left_data = nullptr;\n-    const uint8_t* right_data = nullptr;\n+  // Also matches StringType\n+  Status Visit(const BinaryType& type) { return CompareBinary(type); }\n \n-    if (left.values()) {\n-      left_data = left.raw_values();\n-    }\n+  // Also matches LargeStringType\n+  Status Visit(const LargeBinaryType& type) { return CompareBinary(type); }\n \n-    if (right.values()) {\n-      right_data = right.raw_values();\n-    }\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i)) {\n-        result_ = false;\n-        return Status::OK();\n-      }\n-      if (is_null) continue;\n+  Status Visit(const FixedSizeBinaryType& type) {\n+    const auto byte_width = type.byte_width();\n+    const uint8_t* left_data = left_.GetValues<uint8_t>(1, 0);\n+    const uint8_t* right_data = right_.GetValues<uint8_t>(1, 0);\n \n-      if (std::memcmp(left_data + width * i, right_data + width * o_i, width)) {\n-        result_ = false;\n-        return Status::OK();\n-      }\n+    if (left_data != nullptr && right_data != nullptr) {\n+      auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+        return memcmp(left_data + (left_start_idx_ + left_.offset + i) * byte_width,\n+                      right_data + (right_start_idx_ + right_.offset + i) * byte_width,\n+                      length * byte_width) == 0;\n+      };\n+      VisitValidRuns(compare_runs);\n+    } else {\n+      auto compare_runs = [&](int64_t i, int64_t length) -> bool { return true; };\n+      VisitValidRuns(compare_runs);\n     }\n-    result_ = true;\n     return Status::OK();\n   }\n \n-  Status Visit(const Decimal128Array& left) {\n-    return Visit(checked_cast<const FixedSizeBinaryArray&>(left));\n-  }\n+  // Also matches MapType\n+  Status Visit(const ListType& type) { return CompareList(type); }\n \n-  Status Visit(const Decimal256Array& left) {\n-    return Visit(checked_cast<const FixedSizeBinaryArray&>(left));\n-  }\n+  Status Visit(const LargeListType& type) { return CompareList(type); }\n \n-  Status Visit(const NullArray& left) {\n-    ARROW_UNUSED(left);\n-    result_ = true;\n-    return Status::OK();\n-  }\n-\n-  template <typename T>\n-  typename std::enable_if<std::is_base_of<PrimitiveArray, T>::value, Status>::type Visit(\n-      const T& left) {\n-    return CompareValues<T>(left);\n-  }\n+  Status Visit(const FixedSizeListType& type) {\n+    const auto list_size = type.list_size();\n+    const ArrayData& left_data = *left_.child_data[0];\n+    const ArrayData& right_data = *right_.child_data[0];\n \n-  Status Visit(const ListArray& left) {\n-    result_ = CompareLists(left);\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      RangeDataEqualsImpl impl(options_, floating_approximate_, left_data, right_data,\n+                               (left_start_idx_ + left_.offset + i) * list_size,\n+                               (right_start_idx_ + right_.offset + i) * list_size,\n+                               length * list_size);\n+      return impl.Compare();\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const LargeListArray& left) {\n-    result_ = CompareLists(left);\n-    return Status::OK();\n-  }\n+  Status Visit(const StructType& type) {\n+    const int32_t num_fields = type.num_fields();\n \n-  Status Visit(const FixedSizeListArray& left) {\n-    const auto& right = checked_cast<const FixedSizeListArray&>(right_);\n-    result_ = left.values()->RangeEquals(\n-        left.value_offset(left_start_idx_), left.value_offset(left_end_idx_),\n-        right.value_offset(right_start_idx_), right.values());\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      for (int32_t f = 0; f < num_fields; ++f) {\n+        RangeDataEqualsImpl impl(options_, floating_approximate_, *left_.child_data[f],\n+                                 *right_.child_data[f],\n+                                 left_start_idx_ + left_.offset + i,\n+                                 right_start_idx_ + right_.offset + i, length);\n+        if (!impl.Compare()) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const MapArray& left) {\n-    result_ = CompareMaps(left);\n-    return Status::OK();\n-  }\n+  Status Visit(const SparseUnionType& type) {\n+    const auto& child_ids = type.child_ids();\n+    const int8_t* left_codes = left_.GetValues<int8_t>(1);\n+    const int8_t* right_codes = right_.GetValues<int8_t>(1);\n \n-  Status Visit(const StructArray& left) {\n-    result_ = CompareStructs(left);\n+    VisitValidRuns([&](int64_t i, int64_t length) {\n+      for (int64_t j = i; j < i + length; ++j) {\n+        const auto type_id = left_codes[left_start_idx_ + j];\n+        if (type_id != right_codes[right_start_idx_ + j]) {\n+          return false;\n+        }\n+        const auto child_num = child_ids[type_id];\n+        // XXX can we instead detect runs of same-child union values?\n\nReview comment:\n       Interesting, this seems very doable:\r\n   - get next type_id of left and right\r\n   - early exit if not equal\r\n   - find length of run in left_codes\r\n   - find length of run in right_codes\r\n   - early exit if run lengths are not equal\r\n   - compare ranges of children\n\n##########\nFile path: cpp/src/arrow/compare.cc\n##########\n@@ -49,700 +51,441 @@\n namespace arrow {\n \n using internal::BitmapEquals;\n+using internal::BitmapReader;\n+using internal::BitmapUInt64Reader;\n using internal::checked_cast;\n+using internal::OptionalBitBlockCounter;\n+using internal::OptionalBitmapEquals;\n \n // ----------------------------------------------------------------------\n // Public method implementations\n \n namespace {\n \n-// These helper functions assume we already checked the arrays have equal\n-// sizes and null bitmaps.\n+bool CompareArrayRanges(const ArrayData& left, const ArrayData& right,\n+                        int64_t left_start_idx, int64_t left_end_idx,\n+                        int64_t right_start_idx, const EqualOptions& options,\n+                        bool floating_approximate);\n \n-template <typename ArrowType, typename EqualityFunc>\n-inline bool BaseFloatingEquals(const NumericArray<ArrowType>& left,\n-                               const NumericArray<ArrowType>& right,\n-                               EqualityFunc&& equals) {\n-  using T = typename ArrowType::c_type;\n-\n-  const T* left_data = left.raw_values();\n-  const T* right_data = right.raw_values();\n-\n-  if (left.null_count() > 0) {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (left.IsNull(i)) continue;\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  } else {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingEquals(const NumericArray<ArrowType>& left,\n-                           const NumericArray<ArrowType>& right,\n-                           const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [](T x, T y) -> bool {\n-      return (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right,\n-                                         [](T x, T y) -> bool { return x == y; });\n-  }\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingApproxEquals(const NumericArray<ArrowType>& left,\n-                                 const NumericArray<ArrowType>& right,\n-                                 const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-  const T epsilon = static_cast<T>(opts.atol());\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y);\n-    });\n-  }\n-}\n-\n-// RangeEqualsVisitor assumes the range sizes are equal\n-\n-class RangeEqualsVisitor {\n+class RangeDataEqualsImpl {\n  public:\n-  RangeEqualsVisitor(const Array& right, int64_t left_start_idx, int64_t left_end_idx,\n-                     int64_t right_start_idx)\n-      : right_(right),\n+  // PRE-CONDITIONS:\n+  // - the types are equal\n+  // - the ranges are in bounds\n+  RangeDataEqualsImpl(const EqualOptions& options, bool floating_approximate,\n+                      const ArrayData& left, const ArrayData& right,\n+                      int64_t left_start_idx, int64_t right_start_idx,\n+                      int64_t range_length)\n+      : options_(options),\n+        floating_approximate_(floating_approximate),\n+        left_(left),\n+        right_(right),\n         left_start_idx_(left_start_idx),\n-        left_end_idx_(left_end_idx),\n         right_start_idx_(right_start_idx),\n+        range_length_(range_length),\n         result_(false) {}\n \n-  template <typename ArrayType>\n-  inline Status CompareValues(const ArrayType& left) {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i) ||\n-          (!is_null && left.Value(i) != right.Value(o_i))) {\n-        result_ = false;\n-        return Status::OK();\n+  bool Compare() {\n+    // Compare null bitmaps\n+    if (left_start_idx_ == 0 && right_start_idx_ == 0 && range_length_ == left_.length &&\n+        range_length_ == right_.length) {\n+      // If we're comparing entire arrays, we can first compare the cached null counts\n+      if (left_.GetNullCount() != right_.GetNullCount()) {\n+        return false;\n       }\n     }\n-    result_ = true;\n-    return Status::OK();\n+    if (!OptionalBitmapEquals(left_.buffers[0], left_.offset + left_start_idx_,\n+                              right_.buffers[0], right_.offset + right_start_idx_,\n+                              range_length_)) {\n+      return false;\n+    }\n+    // Compare values\n+    return CompareWithType(*left_.type);\n   }\n \n-  template <typename ArrayType, typename CompareValuesFunc>\n-  bool CompareWithOffsets(const ArrayType& left,\n-                          CompareValuesFunc&& compare_values) const {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (is_null) continue;\n-      const auto begin_offset = left.value_offset(i);\n-      const auto end_offset = left.value_offset(i + 1);\n-      const auto right_begin_offset = right.value_offset(o_i);\n-      const auto right_end_offset = right.value_offset(o_i + 1);\n-      // Underlying can't be equal if the size isn't equal\n-      if (end_offset - begin_offset != right_end_offset - right_begin_offset) {\n-        return false;\n-      }\n-\n-      if (!compare_values(left, right, begin_offset, right_begin_offset,\n-                          end_offset - begin_offset)) {\n-        return false;\n-      }\n+  bool CompareWithType(const DataType& type) {\n+    result_ = true;\n+    if (range_length_ != 0) {\n+      ARROW_CHECK_OK(VisitTypeInline(type, this));\n     }\n-    return true;\n+    return result_;\n   }\n \n-  template <typename BinaryArrayType>\n-  bool CompareBinaryRange(const BinaryArrayType& left) const {\n-    using offset_type = typename BinaryArrayType::offset_type;\n+  Status Visit(const NullType&) { return Status::OK(); }\n \n-    auto compare_values = [](const BinaryArrayType& left, const BinaryArrayType& right,\n-                             offset_type left_offset, offset_type right_offset,\n-                             offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return std::memcmp(left.value_data()->data() + left_offset,\n-                         right.value_data()->data() + right_offset,\n-                         static_cast<size_t>(nvalues)) == 0;\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_primitive_ctype<TypeClass, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  template <typename ListArrayType>\n-  bool CompareLists(const ListArrayType& left) {\n-    using offset_type = typename ListArrayType::offset_type;\n-    const auto& right = checked_cast<const ListArrayType&>(right_);\n-    const std::shared_ptr<Array>& left_values = left.values();\n-    const std::shared_ptr<Array>& right_values = right.values();\n-\n-    auto compare_values = [&](const ListArrayType& left, const ListArrayType& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_values->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                      right_values);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n-  }\n-\n-  bool CompareMaps(const MapArray& left) {\n-    // We need a specific comparison helper for maps to avoid comparing\n-    // struct field names (which are indifferent for maps)\n-    using offset_type = typename MapArray::offset_type;\n-    const auto& right = checked_cast<const MapArray&>(right_);\n-    const auto left_keys = left.keys();\n-    const auto left_items = left.items();\n-    const auto right_keys = right.keys();\n-    const auto right_items = right.items();\n-\n-    auto compare_values = [&](const MapArray& left, const MapArray& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_keys->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                    right_keys) &&\n-             left_items->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                     right_items);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_t<is_temporal_type<TypeClass>::value, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  bool CompareStructs(const StructArray& left) {\n-    const auto& right = checked_cast<const StructArray&>(right_);\n-    bool equal_fields = true;\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      for (int j = 0; j < left.num_fields(); ++j) {\n-        // TODO: really we should be comparing stretches of non-null data rather\n-        // than looking at one value at a time.\n-        equal_fields = left.field(j)->RangeEquals(i, i + 1, o_i, right.field(j));\n-        if (!equal_fields) {\n-          return false;\n-        }\n-      }\n-    }\n-    return true;\n-  }\n-\n-  bool CompareUnions(const UnionArray& left) const {\n-    const auto& right = checked_cast<const UnionArray&>(right_);\n-\n-    const UnionMode::type union_mode = left.mode();\n-    if (union_mode != right.mode()) {\n-      return false;\n-    }\n-\n-    const auto& left_type = checked_cast<const UnionType&>(*left.type());\n-\n-    const std::vector<int>& child_ids = left_type.child_ids();\n-\n-    const int8_t* left_codes = left.raw_type_codes();\n-    const int8_t* right_codes = right.raw_type_codes();\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      if (left_codes[i] != right_codes[o_i]) {\n-        return false;\n-      }\n-\n-      auto child_num = child_ids[left_codes[i]];\n-\n-      // TODO(wesm): really we should be comparing stretches of non-null data\n-      // rather than looking at one value at a time.\n-      if (union_mode == UnionMode::SPARSE) {\n-        if (!left.field(child_num)->RangeEquals(i, i + 1, o_i, right.field(child_num))) {\n-          return false;\n+  Status Visit(const BooleanType&) {\n+    const uint8_t* left_bits = left_.GetValues<uint8_t>(1, 0);\n+    const uint8_t* right_bits = right_.GetValues<uint8_t>(1, 0);\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      if (length <= 8) {\n+        // Avoid the BitmapUInt64Reader overhead for very small runs\n+        for (int64_t j = i; j < i + length; ++j) {\n+          if (BitUtil::GetBit(left_bits, left_start_idx_ + left_.offset + j) !=\n+              BitUtil::GetBit(right_bits, right_start_idx_ + right_.offset + j)) {\n+            return false;\n+          }\n         }\n+        return true;\n       } else {\n-        const int32_t offset =\n-            checked_cast<const DenseUnionArray&>(left).raw_value_offsets()[i];\n-        const int32_t o_offset =\n-            checked_cast<const DenseUnionArray&>(right).raw_value_offsets()[o_i];\n-        if (!left.field(child_num)->RangeEquals(offset, offset + 1, o_offset,\n-                                                right.field(child_num))) {\n-          return false;\n+        BitmapUInt64Reader left_reader(left_bits, left_start_idx_ + left_.offset + i,\n+                                       length);\n+        BitmapUInt64Reader right_reader(right_bits, right_start_idx_ + right_.offset + i,\n+                                        length);\n+        while (left_reader.position() < length) {\n+          if (left_reader.NextWord() != right_reader.NextWord()) {\n+            return false;\n+          }\n         }\n+        DCHECK_EQ(right_reader.position(), length);\n       }\n-    }\n-    return true;\n-  }\n-\n-  Status Visit(const BinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n-    return Status::OK();\n-  }\n-\n-  Status Visit(const LargeBinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n+      return true;\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const FixedSizeBinaryArray& left) {\n-    const auto& right = checked_cast<const FixedSizeBinaryArray&>(right_);\n+  Status Visit(const FloatType& type) { return CompareFloating(type); }\n \n-    int32_t width = left.byte_width();\n+  Status Visit(const DoubleType& type) { return CompareFloating(type); }\n \n-    const uint8_t* left_data = nullptr;\n-    const uint8_t* right_data = nullptr;\n+  // Also matches StringType\n+  Status Visit(const BinaryType& type) { return CompareBinary(type); }\n \n-    if (left.values()) {\n-      left_data = left.raw_values();\n-    }\n+  // Also matches LargeStringType\n+  Status Visit(const LargeBinaryType& type) { return CompareBinary(type); }\n \n-    if (right.values()) {\n-      right_data = right.raw_values();\n-    }\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i)) {\n-        result_ = false;\n-        return Status::OK();\n-      }\n-      if (is_null) continue;\n+  Status Visit(const FixedSizeBinaryType& type) {\n+    const auto byte_width = type.byte_width();\n+    const uint8_t* left_data = left_.GetValues<uint8_t>(1, 0);\n+    const uint8_t* right_data = right_.GetValues<uint8_t>(1, 0);\n \n-      if (std::memcmp(left_data + width * i, right_data + width * o_i, width)) {\n-        result_ = false;\n-        return Status::OK();\n-      }\n+    if (left_data != nullptr && right_data != nullptr) {\n+      auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+        return memcmp(left_data + (left_start_idx_ + left_.offset + i) * byte_width,\n+                      right_data + (right_start_idx_ + right_.offset + i) * byte_width,\n+                      length * byte_width) == 0;\n+      };\n+      VisitValidRuns(compare_runs);\n+    } else {\n+      auto compare_runs = [&](int64_t i, int64_t length) -> bool { return true; };\n+      VisitValidRuns(compare_runs);\n     }\n-    result_ = true;\n     return Status::OK();\n   }\n \n-  Status Visit(const Decimal128Array& left) {\n-    return Visit(checked_cast<const FixedSizeBinaryArray&>(left));\n-  }\n+  // Also matches MapType\n+  Status Visit(const ListType& type) { return CompareList(type); }\n \n-  Status Visit(const Decimal256Array& left) {\n-    return Visit(checked_cast<const FixedSizeBinaryArray&>(left));\n-  }\n+  Status Visit(const LargeListType& type) { return CompareList(type); }\n \n-  Status Visit(const NullArray& left) {\n-    ARROW_UNUSED(left);\n-    result_ = true;\n-    return Status::OK();\n-  }\n-\n-  template <typename T>\n-  typename std::enable_if<std::is_base_of<PrimitiveArray, T>::value, Status>::type Visit(\n-      const T& left) {\n-    return CompareValues<T>(left);\n-  }\n+  Status Visit(const FixedSizeListType& type) {\n+    const auto list_size = type.list_size();\n+    const ArrayData& left_data = *left_.child_data[0];\n+    const ArrayData& right_data = *right_.child_data[0];\n \n-  Status Visit(const ListArray& left) {\n-    result_ = CompareLists(left);\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      RangeDataEqualsImpl impl(options_, floating_approximate_, left_data, right_data,\n+                               (left_start_idx_ + left_.offset + i) * list_size,\n+                               (right_start_idx_ + right_.offset + i) * list_size,\n+                               length * list_size);\n+      return impl.Compare();\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const LargeListArray& left) {\n-    result_ = CompareLists(left);\n-    return Status::OK();\n-  }\n+  Status Visit(const StructType& type) {\n+    const int32_t num_fields = type.num_fields();\n \n-  Status Visit(const FixedSizeListArray& left) {\n-    const auto& right = checked_cast<const FixedSizeListArray&>(right_);\n-    result_ = left.values()->RangeEquals(\n-        left.value_offset(left_start_idx_), left.value_offset(left_end_idx_),\n-        right.value_offset(right_start_idx_), right.values());\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      for (int32_t f = 0; f < num_fields; ++f) {\n+        RangeDataEqualsImpl impl(options_, floating_approximate_, *left_.child_data[f],\n+                                 *right_.child_data[f],\n+                                 left_start_idx_ + left_.offset + i,\n+                                 right_start_idx_ + right_.offset + i, length);\n+        if (!impl.Compare()) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const MapArray& left) {\n-    result_ = CompareMaps(left);\n-    return Status::OK();\n-  }\n+  Status Visit(const SparseUnionType& type) {\n+    const auto& child_ids = type.child_ids();\n+    const int8_t* left_codes = left_.GetValues<int8_t>(1);\n+    const int8_t* right_codes = right_.GetValues<int8_t>(1);\n \n-  Status Visit(const StructArray& left) {\n-    result_ = CompareStructs(left);\n+    VisitValidRuns([&](int64_t i, int64_t length) {\n+      for (int64_t j = i; j < i + length; ++j) {\n+        const auto type_id = left_codes[left_start_idx_ + j];\n+        if (type_id != right_codes[right_start_idx_ + j]) {\n+          return false;\n+        }\n+        const auto child_num = child_ids[type_id];\n+        // XXX can we instead detect runs of same-child union values?\n+        RangeDataEqualsImpl impl(\n+            options_, floating_approximate_, *left_.child_data[child_num],\n+            *right_.child_data[child_num], left_start_idx_ + left_.offset + j,\n+            right_start_idx_ + right_.offset + j, 1);\n+        if (!impl.Compare()) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    });\n     return Status::OK();\n   }\n \n-  Status Visit(const UnionArray& left) {\n-    result_ = CompareUnions(left);\n+  Status Visit(const DenseUnionType& type) {\n+    const auto& child_ids = type.child_ids();\n+    const int8_t* left_codes = left_.GetValues<int8_t>(1);\n+    const int8_t* right_codes = right_.GetValues<int8_t>(1);\n+    const int32_t* left_offsets = left_.GetValues<int32_t>(2);\n+    const int32_t* right_offsets = right_.GetValues<int32_t>(2);\n+\n+    VisitValidRuns([&](int64_t i, int64_t length) {\n+      for (int64_t j = i; j < i + length; ++j) {\n+        const auto type_id = left_codes[left_start_idx_ + j];\n+        if (type_id != right_codes[right_start_idx_ + j]) {\n+          return false;\n+        }\n+        const auto child_num = child_ids[type_id];\n+        RangeDataEqualsImpl impl(\n+            options_, floating_approximate_, *left_.child_data[child_num],\n+            *right_.child_data[child_num], left_offsets[left_start_idx_ + j],\n+            right_offsets[right_start_idx_ + j], 1);\n+        if (!impl.Compare()) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    });\n     return Status::OK();\n   }\n \n-  Status Visit(const DictionaryArray& left) {\n-    const auto& right = checked_cast<const DictionaryArray&>(right_);\n-    if (!left.dictionary()->Equals(right.dictionary())) {\n-      result_ = false;\n-      return Status::OK();\n+  Status Visit(const DictionaryType& type) {\n+    // Compare dictionaries\n+    result_ &= CompareArrayRanges(\n+        *left_.dictionary, *right_.dictionary,\n+        /*left_start_idx=*/0,\n+        /*left_end_idx=*/std::max(left_.dictionary->length, right_.dictionary->length),\n+        /*right_start_idx=*/0, options_, floating_approximate_);\n+    if (result_) {\n+      // Compare indices\n+      result_ &= CompareWithType(*type.index_type());\n     }\n-    result_ = left.indices()->RangeEquals(left_start_idx_, left_end_idx_,\n-                                          right_start_idx_, right.indices());\n     return Status::OK();\n   }\n \n-  Status Visit(const ExtensionArray& left) {\n-    result_ = (right_.type()->Equals(*left.type()) &&\n-               ArrayRangeEquals(*left.storage(),\n-                                *static_cast<const ExtensionArray&>(right_).storage(),\n-                                left_start_idx_, left_end_idx_, right_start_idx_));\n+  Status Visit(const ExtensionType& type) {\n+    // Compare storages\n+    result_ &= CompareWithType(*type.storage_type());\n     return Status::OK();\n   }\n \n-  bool result() const { return result_; }\n-\n  protected:\n-  const Array& right_;\n-  int64_t left_start_idx_;\n-  int64_t left_end_idx_;\n-  int64_t right_start_idx_;\n-\n-  bool result_;\n-};\n-\n-static bool IsEqualPrimitive(const PrimitiveArray& left, const PrimitiveArray& right) {\n-  const int byte_width = internal::GetByteWidth(*left.type());\n-\n-  const uint8_t* left_data = nullptr;\n-  const uint8_t* right_data = nullptr;\n-\n-  if (left.values()) {\n-    left_data = left.values()->data() + left.offset() * byte_width;\n+  template <typename TypeClass, typename CType = typename TypeClass::c_type>\n+  Status ComparePrimitive(const TypeClass&) {\n+    const CType* left_values = left_.GetValues<CType>(1);\n+    const CType* right_values = right_.GetValues<CType>(1);\n+    VisitValidRuns([&](int64_t i, int64_t length) {\n+      return memcmp(left_values + left_start_idx_ + i,\n+                    right_values + right_start_idx_ + i, length * sizeof(CType)) == 0;\n+    });\n+    return Status::OK();\n   }\n \n-  if (right.values()) {\n-    right_data = right.values()->data() + right.offset() * byte_width;\n-  }\n+  template <typename TypeClass>\n+  Status CompareFloating(const TypeClass&) {\n+    using T = typename TypeClass::c_type;\n+    const T* left_values = left_.GetValues<T>(1);\n+    const T* right_values = right_.GetValues<T>(1);\n \n-  if (byte_width == 0) {\n-    // Special case 0-width data, as the data pointers may be null\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (left.IsNull(i) != right.IsNull(i)) {\n-        return false;\n-      }\n-    }\n-    return true;\n-  } else if (left.null_count() > 0) {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      const bool left_null = left.IsNull(i);\n-      const bool right_null = right.IsNull(i);\n-      if (left_null != right_null) {\n-        return false;\n+    if (floating_approximate_) {\n+      const T epsilon = static_cast<T>(options_.atol());\n+      if (options_.nans_equal()) {\n+        VisitValues([&](int64_t i) {\n+          const T x = left_values[i + left_start_idx_];\n+          const T y = right_values[i + right_start_idx_];\n+          return (fabs(x - y) <= epsilon) || (x == y) || (std::isnan(x) && std::isnan(y));\n+        });\n+      } else {\n+        VisitValues([&](int64_t i) {\n+          const T x = left_values[i + left_start_idx_];\n+          const T y = right_values[i + right_start_idx_];\n+          return (fabs(x - y) <= epsilon) || (x == y);\n+        });\n       }\n-      if (!left_null && memcmp(left_data, right_data, byte_width) != 0) {\n-        return false;\n+    } else {\n+      if (options_.nans_equal()) {\n+        VisitValues([&](int64_t i) {\n+          const T x = left_values[i + left_start_idx_];\n+          const T y = right_values[i + right_start_idx_];\n+          return (x == y) || (std::isnan(x) && std::isnan(y));\n+        });\n+      } else {\n+        VisitValues([&](int64_t i) {\n+          const T x = left_values[i + left_start_idx_];\n+          const T y = right_values[i + right_start_idx_];\n+          return x == y;\n+        });\n       }\n-      left_data += byte_width;\n-      right_data += byte_width;\n     }\n-    return true;\n-  } else {\n-    auto number_of_bytes_to_compare = static_cast<size_t>(byte_width * left.length());\n-    return memcmp(left_data, right_data, number_of_bytes_to_compare) == 0;\n-  }\n-}\n-\n-// A bit confusing: ArrayEqualsVisitor inherits from RangeEqualsVisitor but\n-// doesn't share the same preconditions.\n-// When RangeEqualsVisitor is called, we only know the range sizes equal.\n-// When ArrayEqualsVisitor is called, we know the sizes and null bitmaps are equal.\n-\n-class ArrayEqualsVisitor : public RangeEqualsVisitor {\n- public:\n-  explicit ArrayEqualsVisitor(const Array& right, const EqualOptions& opts)\n-      : RangeEqualsVisitor(right, 0, right.length(), 0), opts_(opts) {}\n-\n-  Status Visit(const NullArray& left) {\n-    ARROW_UNUSED(left);\n-    result_ = true;\n     return Status::OK();\n   }\n \n-  Status Visit(const BooleanArray& left) {\n-    const auto& right = checked_cast<const BooleanArray&>(right_);\n+  template <typename TypeClass>\n+  Status CompareBinary(const TypeClass&) {\n+    const uint8_t* left_data = left_.GetValues<uint8_t>(2, 0);\n+    const uint8_t* right_data = right_.GetValues<uint8_t>(2, 0);\n \n-    if (left.null_count() > 0) {\n-      const uint8_t* left_data = left.values()->data();\n-      const uint8_t* right_data = right.values()->data();\n-\n-      for (int64_t i = 0; i < left.length(); ++i) {\n-        if (left.IsValid(i) && BitUtil::GetBit(left_data, i + left.offset()) !=\n-                                   BitUtil::GetBit(right_data, i + right.offset())) {\n-          result_ = false;\n-          return Status::OK();\n-        }\n-      }\n-      result_ = true;\n+    if (left_data != nullptr && right_data != nullptr) {\n+      const auto compare_ranges = [&](int64_t left_offset, int64_t right_offset,\n+                                      int64_t length) -> bool {\n+        return memcmp(left_data + left_offset, right_data + right_offset, length) == 0;\n+      };\n+      CompareWithOffsets<typename TypeClass::offset_type>(1, compare_ranges);\n     } else {\n-      result_ = BitmapEquals(left.values()->data(), left.offset(), right.values()->data(),\n-                             right.offset(), left.length());\n+      // One of the arrays is an array of empty strings and nulls.\n+      // We just need to compare the offsets.\n+      // (note we must not call memcmp() with null data pointers)\n+      const auto compare_ranges = [&](int64_t left_offset, int64_t right_offset,\n+                                      int64_t length) -> bool { return true; };\n+      CompareWithOffsets<typename TypeClass::offset_type>(1, compare_ranges);\n\nReview comment:\n       ```suggestion\r\n         CompareWithOffsets<typename TypeClass::offset_type>(1, [](...) { return true; });\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/bitmap_reader.h\n##########\n@@ -69,6 +69,77 @@ class BitmapReader {\n   int64_t bit_offset_;\n };\n \n+// XXX Cannot name it BitmapWordReader because the name is already used\n+// in bitmap_ops.cc\n\nReview comment:\n       There's a lot of duplication of logic under the heading of \"reading words from bitmaps\": VisitWords, BitmapWordReader, BitmapUInt64Reader. In a follow up it'd be handy to consolidate these and ensure they're rigorously benchmarked (or if there are compelling reasons not to consolidate then provide comments indicating when each should be preferred)\n\n##########\nFile path: cpp/src/arrow/util/bitmap.h\n##########\n@@ -110,8 +110,8 @@ class ARROW_EXPORT Bitmap : public util::ToStringOstreamable<Bitmap>,\n   ///\n   /// TODO(bkietz) allow for early termination\n   template <size_t N, typename Visitor,\n-            typename Word =\n-                typename internal::call_traits::argument_type<0, Visitor&&>::value_type>\n+            typename Word = typename std::decay<\n+                internal::call_traits::argument_type<0, Visitor&&>>::type::value_type>\n\nReview comment:\n       I don't think VisitWords is being used in this PR. IIUC this change would only apply if the visitor took a constant reference to the words array rather than just taking the words array?\n\n##########\nFile path: cpp/src/arrow/compare.cc\n##########\n@@ -49,700 +51,441 @@\n namespace arrow {\n \n using internal::BitmapEquals;\n+using internal::BitmapReader;\n+using internal::BitmapUInt64Reader;\n using internal::checked_cast;\n+using internal::OptionalBitBlockCounter;\n+using internal::OptionalBitmapEquals;\n \n // ----------------------------------------------------------------------\n // Public method implementations\n \n namespace {\n \n-// These helper functions assume we already checked the arrays have equal\n-// sizes and null bitmaps.\n+bool CompareArrayRanges(const ArrayData& left, const ArrayData& right,\n+                        int64_t left_start_idx, int64_t left_end_idx,\n+                        int64_t right_start_idx, const EqualOptions& options,\n+                        bool floating_approximate);\n \n-template <typename ArrowType, typename EqualityFunc>\n-inline bool BaseFloatingEquals(const NumericArray<ArrowType>& left,\n-                               const NumericArray<ArrowType>& right,\n-                               EqualityFunc&& equals) {\n-  using T = typename ArrowType::c_type;\n-\n-  const T* left_data = left.raw_values();\n-  const T* right_data = right.raw_values();\n-\n-  if (left.null_count() > 0) {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (left.IsNull(i)) continue;\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  } else {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingEquals(const NumericArray<ArrowType>& left,\n-                           const NumericArray<ArrowType>& right,\n-                           const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [](T x, T y) -> bool {\n-      return (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right,\n-                                         [](T x, T y) -> bool { return x == y; });\n-  }\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingApproxEquals(const NumericArray<ArrowType>& left,\n-                                 const NumericArray<ArrowType>& right,\n-                                 const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-  const T epsilon = static_cast<T>(opts.atol());\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y);\n-    });\n-  }\n-}\n-\n-// RangeEqualsVisitor assumes the range sizes are equal\n-\n-class RangeEqualsVisitor {\n+class RangeDataEqualsImpl {\n  public:\n-  RangeEqualsVisitor(const Array& right, int64_t left_start_idx, int64_t left_end_idx,\n-                     int64_t right_start_idx)\n-      : right_(right),\n+  // PRE-CONDITIONS:\n+  // - the types are equal\n+  // - the ranges are in bounds\n+  RangeDataEqualsImpl(const EqualOptions& options, bool floating_approximate,\n+                      const ArrayData& left, const ArrayData& right,\n+                      int64_t left_start_idx, int64_t right_start_idx,\n+                      int64_t range_length)\n+      : options_(options),\n+        floating_approximate_(floating_approximate),\n+        left_(left),\n+        right_(right),\n         left_start_idx_(left_start_idx),\n-        left_end_idx_(left_end_idx),\n         right_start_idx_(right_start_idx),\n+        range_length_(range_length),\n         result_(false) {}\n \n-  template <typename ArrayType>\n-  inline Status CompareValues(const ArrayType& left) {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i) ||\n-          (!is_null && left.Value(i) != right.Value(o_i))) {\n-        result_ = false;\n-        return Status::OK();\n+  bool Compare() {\n+    // Compare null bitmaps\n+    if (left_start_idx_ == 0 && right_start_idx_ == 0 && range_length_ == left_.length &&\n+        range_length_ == right_.length) {\n+      // If we're comparing entire arrays, we can first compare the cached null counts\n+      if (left_.GetNullCount() != right_.GetNullCount()) {\n+        return false;\n       }\n     }\n-    result_ = true;\n-    return Status::OK();\n+    if (!OptionalBitmapEquals(left_.buffers[0], left_.offset + left_start_idx_,\n+                              right_.buffers[0], right_.offset + right_start_idx_,\n+                              range_length_)) {\n+      return false;\n+    }\n+    // Compare values\n+    return CompareWithType(*left_.type);\n   }\n \n-  template <typename ArrayType, typename CompareValuesFunc>\n-  bool CompareWithOffsets(const ArrayType& left,\n-                          CompareValuesFunc&& compare_values) const {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (is_null) continue;\n-      const auto begin_offset = left.value_offset(i);\n-      const auto end_offset = left.value_offset(i + 1);\n-      const auto right_begin_offset = right.value_offset(o_i);\n-      const auto right_end_offset = right.value_offset(o_i + 1);\n-      // Underlying can't be equal if the size isn't equal\n-      if (end_offset - begin_offset != right_end_offset - right_begin_offset) {\n-        return false;\n-      }\n-\n-      if (!compare_values(left, right, begin_offset, right_begin_offset,\n-                          end_offset - begin_offset)) {\n-        return false;\n-      }\n+  bool CompareWithType(const DataType& type) {\n+    result_ = true;\n+    if (range_length_ != 0) {\n+      ARROW_CHECK_OK(VisitTypeInline(type, this));\n     }\n-    return true;\n+    return result_;\n   }\n \n-  template <typename BinaryArrayType>\n-  bool CompareBinaryRange(const BinaryArrayType& left) const {\n-    using offset_type = typename BinaryArrayType::offset_type;\n+  Status Visit(const NullType&) { return Status::OK(); }\n \n-    auto compare_values = [](const BinaryArrayType& left, const BinaryArrayType& right,\n-                             offset_type left_offset, offset_type right_offset,\n-                             offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return std::memcmp(left.value_data()->data() + left_offset,\n-                         right.value_data()->data() + right_offset,\n-                         static_cast<size_t>(nvalues)) == 0;\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_primitive_ctype<TypeClass, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  template <typename ListArrayType>\n-  bool CompareLists(const ListArrayType& left) {\n-    using offset_type = typename ListArrayType::offset_type;\n-    const auto& right = checked_cast<const ListArrayType&>(right_);\n-    const std::shared_ptr<Array>& left_values = left.values();\n-    const std::shared_ptr<Array>& right_values = right.values();\n-\n-    auto compare_values = [&](const ListArrayType& left, const ListArrayType& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_values->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                      right_values);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n-  }\n-\n-  bool CompareMaps(const MapArray& left) {\n-    // We need a specific comparison helper for maps to avoid comparing\n-    // struct field names (which are indifferent for maps)\n-    using offset_type = typename MapArray::offset_type;\n-    const auto& right = checked_cast<const MapArray&>(right_);\n-    const auto left_keys = left.keys();\n-    const auto left_items = left.items();\n-    const auto right_keys = right.keys();\n-    const auto right_items = right.items();\n-\n-    auto compare_values = [&](const MapArray& left, const MapArray& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_keys->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                    right_keys) &&\n-             left_items->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                     right_items);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_t<is_temporal_type<TypeClass>::value, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  bool CompareStructs(const StructArray& left) {\n-    const auto& right = checked_cast<const StructArray&>(right_);\n-    bool equal_fields = true;\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      for (int j = 0; j < left.num_fields(); ++j) {\n-        // TODO: really we should be comparing stretches of non-null data rather\n-        // than looking at one value at a time.\n-        equal_fields = left.field(j)->RangeEquals(i, i + 1, o_i, right.field(j));\n-        if (!equal_fields) {\n-          return false;\n-        }\n-      }\n-    }\n-    return true;\n-  }\n-\n-  bool CompareUnions(const UnionArray& left) const {\n-    const auto& right = checked_cast<const UnionArray&>(right_);\n-\n-    const UnionMode::type union_mode = left.mode();\n-    if (union_mode != right.mode()) {\n-      return false;\n-    }\n-\n-    const auto& left_type = checked_cast<const UnionType&>(*left.type());\n-\n-    const std::vector<int>& child_ids = left_type.child_ids();\n-\n-    const int8_t* left_codes = left.raw_type_codes();\n-    const int8_t* right_codes = right.raw_type_codes();\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      if (left_codes[i] != right_codes[o_i]) {\n-        return false;\n-      }\n-\n-      auto child_num = child_ids[left_codes[i]];\n-\n-      // TODO(wesm): really we should be comparing stretches of non-null data\n-      // rather than looking at one value at a time.\n-      if (union_mode == UnionMode::SPARSE) {\n-        if (!left.field(child_num)->RangeEquals(i, i + 1, o_i, right.field(child_num))) {\n-          return false;\n+  Status Visit(const BooleanType&) {\n+    const uint8_t* left_bits = left_.GetValues<uint8_t>(1, 0);\n+    const uint8_t* right_bits = right_.GetValues<uint8_t>(1, 0);\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      if (length <= 8) {\n+        // Avoid the BitmapUInt64Reader overhead for very small runs\n+        for (int64_t j = i; j < i + length; ++j) {\n+          if (BitUtil::GetBit(left_bits, left_start_idx_ + left_.offset + j) !=\n+              BitUtil::GetBit(right_bits, right_start_idx_ + right_.offset + j)) {\n+            return false;\n+          }\n         }\n+        return true;\n       } else {\n-        const int32_t offset =\n-            checked_cast<const DenseUnionArray&>(left).raw_value_offsets()[i];\n-        const int32_t o_offset =\n-            checked_cast<const DenseUnionArray&>(right).raw_value_offsets()[o_i];\n-        if (!left.field(child_num)->RangeEquals(offset, offset + 1, o_offset,\n-                                                right.field(child_num))) {\n-          return false;\n+        BitmapUInt64Reader left_reader(left_bits, left_start_idx_ + left_.offset + i,\n+                                       length);\n+        BitmapUInt64Reader right_reader(right_bits, right_start_idx_ + right_.offset + i,\n+                                        length);\n+        while (left_reader.position() < length) {\n+          if (left_reader.NextWord() != right_reader.NextWord()) {\n+            return false;\n+          }\n         }\n+        DCHECK_EQ(right_reader.position(), length);\n       }\n-    }\n-    return true;\n-  }\n-\n-  Status Visit(const BinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n-    return Status::OK();\n-  }\n-\n-  Status Visit(const LargeBinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n+      return true;\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const FixedSizeBinaryArray& left) {\n-    const auto& right = checked_cast<const FixedSizeBinaryArray&>(right_);\n+  Status Visit(const FloatType& type) { return CompareFloating(type); }\n \n-    int32_t width = left.byte_width();\n+  Status Visit(const DoubleType& type) { return CompareFloating(type); }\n \n-    const uint8_t* left_data = nullptr;\n-    const uint8_t* right_data = nullptr;\n+  // Also matches StringType\n+  Status Visit(const BinaryType& type) { return CompareBinary(type); }\n \n-    if (left.values()) {\n-      left_data = left.raw_values();\n-    }\n+  // Also matches LargeStringType\n+  Status Visit(const LargeBinaryType& type) { return CompareBinary(type); }\n \n-    if (right.values()) {\n-      right_data = right.raw_values();\n-    }\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i)) {\n-        result_ = false;\n-        return Status::OK();\n-      }\n-      if (is_null) continue;\n+  Status Visit(const FixedSizeBinaryType& type) {\n+    const auto byte_width = type.byte_width();\n+    const uint8_t* left_data = left_.GetValues<uint8_t>(1, 0);\n+    const uint8_t* right_data = right_.GetValues<uint8_t>(1, 0);\n \n-      if (std::memcmp(left_data + width * i, right_data + width * o_i, width)) {\n-        result_ = false;\n-        return Status::OK();\n-      }\n+    if (left_data != nullptr && right_data != nullptr) {\n+      auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+        return memcmp(left_data + (left_start_idx_ + left_.offset + i) * byte_width,\n+                      right_data + (right_start_idx_ + right_.offset + i) * byte_width,\n+                      length * byte_width) == 0;\n+      };\n+      VisitValidRuns(compare_runs);\n+    } else {\n+      auto compare_runs = [&](int64_t i, int64_t length) -> bool { return true; };\n+      VisitValidRuns(compare_runs);\n     }\n-    result_ = true;\n     return Status::OK();\n   }\n \n-  Status Visit(const Decimal128Array& left) {\n-    return Visit(checked_cast<const FixedSizeBinaryArray&>(left));\n-  }\n+  // Also matches MapType\n+  Status Visit(const ListType& type) { return CompareList(type); }\n \n-  Status Visit(const Decimal256Array& left) {\n-    return Visit(checked_cast<const FixedSizeBinaryArray&>(left));\n-  }\n+  Status Visit(const LargeListType& type) { return CompareList(type); }\n \n-  Status Visit(const NullArray& left) {\n-    ARROW_UNUSED(left);\n-    result_ = true;\n-    return Status::OK();\n-  }\n-\n-  template <typename T>\n-  typename std::enable_if<std::is_base_of<PrimitiveArray, T>::value, Status>::type Visit(\n-      const T& left) {\n-    return CompareValues<T>(left);\n-  }\n+  Status Visit(const FixedSizeListType& type) {\n+    const auto list_size = type.list_size();\n+    const ArrayData& left_data = *left_.child_data[0];\n+    const ArrayData& right_data = *right_.child_data[0];\n \n-  Status Visit(const ListArray& left) {\n-    result_ = CompareLists(left);\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      RangeDataEqualsImpl impl(options_, floating_approximate_, left_data, right_data,\n+                               (left_start_idx_ + left_.offset + i) * list_size,\n+                               (right_start_idx_ + right_.offset + i) * list_size,\n+                               length * list_size);\n+      return impl.Compare();\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const LargeListArray& left) {\n-    result_ = CompareLists(left);\n-    return Status::OK();\n-  }\n+  Status Visit(const StructType& type) {\n+    const int32_t num_fields = type.num_fields();\n \n-  Status Visit(const FixedSizeListArray& left) {\n-    const auto& right = checked_cast<const FixedSizeListArray&>(right_);\n-    result_ = left.values()->RangeEquals(\n-        left.value_offset(left_start_idx_), left.value_offset(left_end_idx_),\n-        right.value_offset(right_start_idx_), right.values());\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      for (int32_t f = 0; f < num_fields; ++f) {\n+        RangeDataEqualsImpl impl(options_, floating_approximate_, *left_.child_data[f],\n+                                 *right_.child_data[f],\n+                                 left_start_idx_ + left_.offset + i,\n+                                 right_start_idx_ + right_.offset + i, length);\n+        if (!impl.Compare()) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const MapArray& left) {\n-    result_ = CompareMaps(left);\n-    return Status::OK();\n-  }\n+  Status Visit(const SparseUnionType& type) {\n+    const auto& child_ids = type.child_ids();\n+    const int8_t* left_codes = left_.GetValues<int8_t>(1);\n+    const int8_t* right_codes = right_.GetValues<int8_t>(1);\n \n-  Status Visit(const StructArray& left) {\n-    result_ = CompareStructs(left);\n+    VisitValidRuns([&](int64_t i, int64_t length) {\n+      for (int64_t j = i; j < i + length; ++j) {\n+        const auto type_id = left_codes[left_start_idx_ + j];\n+        if (type_id != right_codes[right_start_idx_ + j]) {\n+          return false;\n+        }\n+        const auto child_num = child_ids[type_id];\n+        // XXX can we instead detect runs of same-child union values?\n+        RangeDataEqualsImpl impl(\n+            options_, floating_approximate_, *left_.child_data[child_num],\n+            *right_.child_data[child_num], left_start_idx_ + left_.offset + j,\n+            right_start_idx_ + right_.offset + j, 1);\n+        if (!impl.Compare()) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    });\n     return Status::OK();\n   }\n \n-  Status Visit(const UnionArray& left) {\n-    result_ = CompareUnions(left);\n+  Status Visit(const DenseUnionType& type) {\n+    const auto& child_ids = type.child_ids();\n+    const int8_t* left_codes = left_.GetValues<int8_t>(1);\n+    const int8_t* right_codes = right_.GetValues<int8_t>(1);\n+    const int32_t* left_offsets = left_.GetValues<int32_t>(2);\n+    const int32_t* right_offsets = right_.GetValues<int32_t>(2);\n+\n+    VisitValidRuns([&](int64_t i, int64_t length) {\n+      for (int64_t j = i; j < i + length; ++j) {\n+        const auto type_id = left_codes[left_start_idx_ + j];\n+        if (type_id != right_codes[right_start_idx_ + j]) {\n+          return false;\n+        }\n+        const auto child_num = child_ids[type_id];\n\nReview comment:\n       runs of type_id can still be used here, but ranges of children can't be directly compared due to the offsets. It's odd that we \"dereference\" offsets when comparing dense union arrays but we don't do the same with a dictionary array's indices\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-20T22:23:42.425+0000",
                    "updated": "2020-11-20T22:23:42.425+0000",
                    "started": "2020-11-20T22:23:42.424+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "514894",
                    "issueId": "13330181"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330181/worklog/515079",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8703:\nURL: https://github.com/apache/arrow/pull/8703#discussion_r528210366\n\n\n\n##########\nFile path: cpp/src/arrow/array/diff.h\n##########\n@@ -59,6 +57,27 @@ ARROW_EXPORT\n Result<std::shared_ptr<StructArray>> Diff(const Array& base, const Array& target,\n                                           MemoryPool* pool = default_memory_pool());\n \n+/// \\brief Compare two array ranges, returning an edit script which expresses the\n+/// difference between them\n+///\n+/// Same as Diff(), but only the ranges defined by the given offsets and lengths\n+/// are compared.\n+///\n+/// \\param[in] base baseline for comparison\n+/// \\param[in] target an array of identical type to base whose elements differ from base's\n+/// \\param[in] base_offset the start offset of the range to consider inside `base`\n+/// \\param[in] base_length the length of the range to consider inside `base`\n+/// \\param[in] target_offset the start offset of the range to consider inside `target`\n+/// \\param[in] target_length the length of the range to consider inside `target`\n+/// \\param[in] pool memory to store the result will be allocated from this memory pool\n+/// \\return an edit script array which can be applied to base to produce target\n+ARROW_EXPORT\n+Result<std::shared_ptr<StructArray>> DiffRanges(const Array& base, const Array& target,\n\nReview comment:\n       Hmm... well, there is a performance argument for avoiding slices, but I'm not sure it matters for diffing :-)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-21T15:48:30.253+0000",
                    "updated": "2020-11-21T15:48:30.253+0000",
                    "started": "2020-11-21T15:48:30.252+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515079",
                    "issueId": "13330181"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330181/worklog/515080",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8703:\nURL: https://github.com/apache/arrow/pull/8703#discussion_r528210378\n\n\n\n##########\nFile path: cpp/src/arrow/ipc/feather_test.cc\n##########\n@@ -286,10 +286,13 @@ TEST_P(TestFeather, PrimitiveNullRoundTrip) {\n     std::vector<std::shared_ptr<Array>> expected_fields;\n     for (int i = 0; i < batch->num_columns(); ++i) {\n       ASSERT_EQ(batch->column_name(i), reader_->schema()->field(i)->name());\n-      StringArray str_values(batch->column(i)->length(), nullptr, nullptr,\n-                             batch->column(i)->null_bitmap(),\n-                             batch->column(i)->null_count());\n-      AssertArraysEqual(str_values, *result->column(i)->chunk(0));\n+      ASSERT_OK_AND_ASSIGN(auto expected, MakeArrayOfNull(utf8(), batch->num_rows()));\n+      AssertArraysEqual(*expected, *result->column(i)->chunk(0));\n+      //       StringArray str_values(batch->column(i)->length(), nullptr, nullptr,\n+      //                              batch->column(i)->null_bitmap(),\n+      //                              batch->column(i)->null_count());\n+      //       AssertArraysEqual(str_values, *result->column(i)->chunk(0),\n+      //       /*verbose=*/true);\n\nReview comment:\n       Yes, I was waiting for an answer to the question above.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-21T15:48:43.186+0000",
                    "updated": "2020-11-21T15:48:43.186+0000",
                    "started": "2020-11-21T15:48:43.186+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515080",
                    "issueId": "13330181"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330181/worklog/515081",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8703:\nURL: https://github.com/apache/arrow/pull/8703#discussion_r528210425\n\n\n\n##########\nFile path: cpp/src/arrow/util/bit_run_reader.h\n##########\n@@ -162,5 +166,7 @@ class ARROW_EXPORT BitRunReader {\n using BitRunReader = BitRunReaderLinear;\n #endif\n \n+// TODO SetBitRunReader?\n+\n\nReview comment:\n       Yes, it would. That would make its logic much simpler and more easily optimized by the compiler (though, of course, numbers will be the final judge).\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-21T15:49:16.120+0000",
                    "updated": "2020-11-21T15:49:16.120+0000",
                    "started": "2020-11-21T15:49:16.120+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515081",
                    "issueId": "13330181"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330181/worklog/515082",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8703:\nURL: https://github.com/apache/arrow/pull/8703#discussion_r528210648\n\n\n\n##########\nFile path: cpp/src/arrow/util/bitmap.h\n##########\n@@ -110,8 +110,8 @@ class ARROW_EXPORT Bitmap : public util::ToStringOstreamable<Bitmap>,\n   ///\n   /// TODO(bkietz) allow for early termination\n   template <size_t N, typename Visitor,\n-            typename Word =\n-                typename internal::call_traits::argument_type<0, Visitor&&>::value_type>\n+            typename Word = typename std::decay<\n+                internal::call_traits::argument_type<0, Visitor&&>>::type::value_type>\n\nReview comment:\n       A previous version of this work used `VisitWords`, but it ended up exhibiting bad performance (`VisitWords` might be too complex for the compiler). Yes, this change is for the case where the visitor argument takes a `const& std::array<...>`. Perhaps there's no advantage in doing so, but it's better if it works anyway.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-21T15:50:50.960+0000",
                    "updated": "2020-11-21T15:50:50.960+0000",
                    "started": "2020-11-21T15:50:50.960+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515082",
                    "issueId": "13330181"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330181/worklog/515083",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8703:\nURL: https://github.com/apache/arrow/pull/8703#discussion_r528210676\n\n\n\n##########\nFile path: cpp/src/arrow/util/bitmap_reader.h\n##########\n@@ -69,6 +69,77 @@ class BitmapReader {\n   int64_t bit_offset_;\n };\n \n+// XXX Cannot name it BitmapWordReader because the name is already used\n+// in bitmap_ops.cc\n\nReview comment:\n       Yeah, I think that would be useful. I should open JIRAs for the various XXX and TODOs here.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-21T15:51:13.965+0000",
                    "updated": "2020-11-21T15:51:13.965+0000",
                    "started": "2020-11-21T15:51:13.965+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515083",
                    "issueId": "13330181"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330181/worklog/515084",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8703:\nURL: https://github.com/apache/arrow/pull/8703#discussion_r528210778\n\n\n\n##########\nFile path: cpp/src/arrow/compare.cc\n##########\n@@ -49,700 +51,441 @@\n namespace arrow {\n \n using internal::BitmapEquals;\n+using internal::BitmapReader;\n+using internal::BitmapUInt64Reader;\n using internal::checked_cast;\n+using internal::OptionalBitBlockCounter;\n+using internal::OptionalBitmapEquals;\n \n // ----------------------------------------------------------------------\n // Public method implementations\n \n namespace {\n \n-// These helper functions assume we already checked the arrays have equal\n-// sizes and null bitmaps.\n+bool CompareArrayRanges(const ArrayData& left, const ArrayData& right,\n+                        int64_t left_start_idx, int64_t left_end_idx,\n+                        int64_t right_start_idx, const EqualOptions& options,\n+                        bool floating_approximate);\n \n-template <typename ArrowType, typename EqualityFunc>\n-inline bool BaseFloatingEquals(const NumericArray<ArrowType>& left,\n-                               const NumericArray<ArrowType>& right,\n-                               EqualityFunc&& equals) {\n-  using T = typename ArrowType::c_type;\n-\n-  const T* left_data = left.raw_values();\n-  const T* right_data = right.raw_values();\n-\n-  if (left.null_count() > 0) {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (left.IsNull(i)) continue;\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  } else {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingEquals(const NumericArray<ArrowType>& left,\n-                           const NumericArray<ArrowType>& right,\n-                           const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [](T x, T y) -> bool {\n-      return (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right,\n-                                         [](T x, T y) -> bool { return x == y; });\n-  }\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingApproxEquals(const NumericArray<ArrowType>& left,\n-                                 const NumericArray<ArrowType>& right,\n-                                 const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-  const T epsilon = static_cast<T>(opts.atol());\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y);\n-    });\n-  }\n-}\n-\n-// RangeEqualsVisitor assumes the range sizes are equal\n-\n-class RangeEqualsVisitor {\n+class RangeDataEqualsImpl {\n  public:\n-  RangeEqualsVisitor(const Array& right, int64_t left_start_idx, int64_t left_end_idx,\n-                     int64_t right_start_idx)\n-      : right_(right),\n+  // PRE-CONDITIONS:\n+  // - the types are equal\n+  // - the ranges are in bounds\n+  RangeDataEqualsImpl(const EqualOptions& options, bool floating_approximate,\n+                      const ArrayData& left, const ArrayData& right,\n+                      int64_t left_start_idx, int64_t right_start_idx,\n+                      int64_t range_length)\n+      : options_(options),\n+        floating_approximate_(floating_approximate),\n+        left_(left),\n+        right_(right),\n         left_start_idx_(left_start_idx),\n-        left_end_idx_(left_end_idx),\n         right_start_idx_(right_start_idx),\n+        range_length_(range_length),\n         result_(false) {}\n \n-  template <typename ArrayType>\n-  inline Status CompareValues(const ArrayType& left) {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i) ||\n-          (!is_null && left.Value(i) != right.Value(o_i))) {\n-        result_ = false;\n-        return Status::OK();\n+  bool Compare() {\n+    // Compare null bitmaps\n+    if (left_start_idx_ == 0 && right_start_idx_ == 0 && range_length_ == left_.length &&\n+        range_length_ == right_.length) {\n+      // If we're comparing entire arrays, we can first compare the cached null counts\n+      if (left_.GetNullCount() != right_.GetNullCount()) {\n+        return false;\n       }\n     }\n\nReview comment:\n       It's ok to compute the null count, IMHO, it is often used for other tasks.\r\n   The reason why this heuristic only works for non-ranged arrays is that you could have two whole arrays with different null counts, but the compared ranges would still be equal.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-21T15:52:17.156+0000",
                    "updated": "2020-11-21T15:52:17.156+0000",
                    "started": "2020-11-21T15:52:17.156+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515084",
                    "issueId": "13330181"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330181/worklog/515085",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8703:\nURL: https://github.com/apache/arrow/pull/8703#discussion_r528210816\n\n\n\n##########\nFile path: cpp/src/arrow/compare.cc\n##########\n@@ -49,700 +51,441 @@\n namespace arrow {\n \n using internal::BitmapEquals;\n+using internal::BitmapReader;\n+using internal::BitmapUInt64Reader;\n using internal::checked_cast;\n+using internal::OptionalBitBlockCounter;\n+using internal::OptionalBitmapEquals;\n \n // ----------------------------------------------------------------------\n // Public method implementations\n \n namespace {\n \n-// These helper functions assume we already checked the arrays have equal\n-// sizes and null bitmaps.\n+bool CompareArrayRanges(const ArrayData& left, const ArrayData& right,\n+                        int64_t left_start_idx, int64_t left_end_idx,\n+                        int64_t right_start_idx, const EqualOptions& options,\n+                        bool floating_approximate);\n \n-template <typename ArrowType, typename EqualityFunc>\n-inline bool BaseFloatingEquals(const NumericArray<ArrowType>& left,\n-                               const NumericArray<ArrowType>& right,\n-                               EqualityFunc&& equals) {\n-  using T = typename ArrowType::c_type;\n-\n-  const T* left_data = left.raw_values();\n-  const T* right_data = right.raw_values();\n-\n-  if (left.null_count() > 0) {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (left.IsNull(i)) continue;\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  } else {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingEquals(const NumericArray<ArrowType>& left,\n-                           const NumericArray<ArrowType>& right,\n-                           const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [](T x, T y) -> bool {\n-      return (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right,\n-                                         [](T x, T y) -> bool { return x == y; });\n-  }\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingApproxEquals(const NumericArray<ArrowType>& left,\n-                                 const NumericArray<ArrowType>& right,\n-                                 const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-  const T epsilon = static_cast<T>(opts.atol());\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y);\n-    });\n-  }\n-}\n-\n-// RangeEqualsVisitor assumes the range sizes are equal\n-\n-class RangeEqualsVisitor {\n+class RangeDataEqualsImpl {\n  public:\n-  RangeEqualsVisitor(const Array& right, int64_t left_start_idx, int64_t left_end_idx,\n-                     int64_t right_start_idx)\n-      : right_(right),\n+  // PRE-CONDITIONS:\n+  // - the types are equal\n+  // - the ranges are in bounds\n+  RangeDataEqualsImpl(const EqualOptions& options, bool floating_approximate,\n+                      const ArrayData& left, const ArrayData& right,\n+                      int64_t left_start_idx, int64_t right_start_idx,\n+                      int64_t range_length)\n+      : options_(options),\n+        floating_approximate_(floating_approximate),\n+        left_(left),\n+        right_(right),\n         left_start_idx_(left_start_idx),\n-        left_end_idx_(left_end_idx),\n         right_start_idx_(right_start_idx),\n+        range_length_(range_length),\n         result_(false) {}\n \n-  template <typename ArrayType>\n-  inline Status CompareValues(const ArrayType& left) {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i) ||\n-          (!is_null && left.Value(i) != right.Value(o_i))) {\n-        result_ = false;\n-        return Status::OK();\n+  bool Compare() {\n+    // Compare null bitmaps\n+    if (left_start_idx_ == 0 && right_start_idx_ == 0 && range_length_ == left_.length &&\n+        range_length_ == right_.length) {\n+      // If we're comparing entire arrays, we can first compare the cached null counts\n+      if (left_.GetNullCount() != right_.GetNullCount()) {\n+        return false;\n       }\n     }\n-    result_ = true;\n-    return Status::OK();\n+    if (!OptionalBitmapEquals(left_.buffers[0], left_.offset + left_start_idx_,\n+                              right_.buffers[0], right_.offset + right_start_idx_,\n+                              range_length_)) {\n+      return false;\n+    }\n+    // Compare values\n+    return CompareWithType(*left_.type);\n   }\n \n-  template <typename ArrayType, typename CompareValuesFunc>\n-  bool CompareWithOffsets(const ArrayType& left,\n-                          CompareValuesFunc&& compare_values) const {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (is_null) continue;\n-      const auto begin_offset = left.value_offset(i);\n-      const auto end_offset = left.value_offset(i + 1);\n-      const auto right_begin_offset = right.value_offset(o_i);\n-      const auto right_end_offset = right.value_offset(o_i + 1);\n-      // Underlying can't be equal if the size isn't equal\n-      if (end_offset - begin_offset != right_end_offset - right_begin_offset) {\n-        return false;\n-      }\n-\n-      if (!compare_values(left, right, begin_offset, right_begin_offset,\n-                          end_offset - begin_offset)) {\n-        return false;\n-      }\n+  bool CompareWithType(const DataType& type) {\n+    result_ = true;\n+    if (range_length_ != 0) {\n+      ARROW_CHECK_OK(VisitTypeInline(type, this));\n     }\n-    return true;\n+    return result_;\n   }\n \n-  template <typename BinaryArrayType>\n-  bool CompareBinaryRange(const BinaryArrayType& left) const {\n-    using offset_type = typename BinaryArrayType::offset_type;\n+  Status Visit(const NullType&) { return Status::OK(); }\n \n-    auto compare_values = [](const BinaryArrayType& left, const BinaryArrayType& right,\n-                             offset_type left_offset, offset_type right_offset,\n-                             offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return std::memcmp(left.value_data()->data() + left_offset,\n-                         right.value_data()->data() + right_offset,\n-                         static_cast<size_t>(nvalues)) == 0;\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_primitive_ctype<TypeClass, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  template <typename ListArrayType>\n-  bool CompareLists(const ListArrayType& left) {\n-    using offset_type = typename ListArrayType::offset_type;\n-    const auto& right = checked_cast<const ListArrayType&>(right_);\n-    const std::shared_ptr<Array>& left_values = left.values();\n-    const std::shared_ptr<Array>& right_values = right.values();\n-\n-    auto compare_values = [&](const ListArrayType& left, const ListArrayType& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_values->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                      right_values);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n-  }\n-\n-  bool CompareMaps(const MapArray& left) {\n-    // We need a specific comparison helper for maps to avoid comparing\n-    // struct field names (which are indifferent for maps)\n-    using offset_type = typename MapArray::offset_type;\n-    const auto& right = checked_cast<const MapArray&>(right_);\n-    const auto left_keys = left.keys();\n-    const auto left_items = left.items();\n-    const auto right_keys = right.keys();\n-    const auto right_items = right.items();\n-\n-    auto compare_values = [&](const MapArray& left, const MapArray& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_keys->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                    right_keys) &&\n-             left_items->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                     right_items);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_t<is_temporal_type<TypeClass>::value, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  bool CompareStructs(const StructArray& left) {\n-    const auto& right = checked_cast<const StructArray&>(right_);\n-    bool equal_fields = true;\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      for (int j = 0; j < left.num_fields(); ++j) {\n-        // TODO: really we should be comparing stretches of non-null data rather\n-        // than looking at one value at a time.\n-        equal_fields = left.field(j)->RangeEquals(i, i + 1, o_i, right.field(j));\n-        if (!equal_fields) {\n-          return false;\n-        }\n-      }\n-    }\n-    return true;\n-  }\n-\n-  bool CompareUnions(const UnionArray& left) const {\n-    const auto& right = checked_cast<const UnionArray&>(right_);\n-\n-    const UnionMode::type union_mode = left.mode();\n-    if (union_mode != right.mode()) {\n-      return false;\n-    }\n-\n-    const auto& left_type = checked_cast<const UnionType&>(*left.type());\n-\n-    const std::vector<int>& child_ids = left_type.child_ids();\n-\n-    const int8_t* left_codes = left.raw_type_codes();\n-    const int8_t* right_codes = right.raw_type_codes();\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      if (left_codes[i] != right_codes[o_i]) {\n-        return false;\n-      }\n-\n-      auto child_num = child_ids[left_codes[i]];\n-\n-      // TODO(wesm): really we should be comparing stretches of non-null data\n-      // rather than looking at one value at a time.\n-      if (union_mode == UnionMode::SPARSE) {\n-        if (!left.field(child_num)->RangeEquals(i, i + 1, o_i, right.field(child_num))) {\n-          return false;\n+  Status Visit(const BooleanType&) {\n+    const uint8_t* left_bits = left_.GetValues<uint8_t>(1, 0);\n+    const uint8_t* right_bits = right_.GetValues<uint8_t>(1, 0);\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      if (length <= 8) {\n+        // Avoid the BitmapUInt64Reader overhead for very small runs\n+        for (int64_t j = i; j < i + length; ++j) {\n+          if (BitUtil::GetBit(left_bits, left_start_idx_ + left_.offset + j) !=\n+              BitUtil::GetBit(right_bits, right_start_idx_ + right_.offset + j)) {\n+            return false;\n+          }\n         }\n+        return true;\n       } else {\n-        const int32_t offset =\n-            checked_cast<const DenseUnionArray&>(left).raw_value_offsets()[i];\n-        const int32_t o_offset =\n-            checked_cast<const DenseUnionArray&>(right).raw_value_offsets()[o_i];\n-        if (!left.field(child_num)->RangeEquals(offset, offset + 1, o_offset,\n-                                                right.field(child_num))) {\n-          return false;\n+        BitmapUInt64Reader left_reader(left_bits, left_start_idx_ + left_.offset + i,\n+                                       length);\n+        BitmapUInt64Reader right_reader(right_bits, right_start_idx_ + right_.offset + i,\n+                                        length);\n+        while (left_reader.position() < length) {\n+          if (left_reader.NextWord() != right_reader.NextWord()) {\n+            return false;\n+          }\n         }\n+        DCHECK_EQ(right_reader.position(), length);\n       }\n-    }\n-    return true;\n-  }\n-\n-  Status Visit(const BinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n-    return Status::OK();\n-  }\n-\n-  Status Visit(const LargeBinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n+      return true;\n+    };\n+    VisitValidRuns(compare_runs);\n\nReview comment:\n       Will take a look.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-21T15:52:30.048+0000",
                    "updated": "2020-11-21T15:52:30.048+0000",
                    "started": "2020-11-21T15:52:30.047+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515085",
                    "issueId": "13330181"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330181/worklog/515087",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8703:\nURL: https://github.com/apache/arrow/pull/8703#discussion_r528210910\n\n\n\n##########\nFile path: cpp/src/arrow/compare.cc\n##########\n@@ -49,700 +51,441 @@\n namespace arrow {\n \n using internal::BitmapEquals;\n+using internal::BitmapReader;\n+using internal::BitmapUInt64Reader;\n using internal::checked_cast;\n+using internal::OptionalBitBlockCounter;\n+using internal::OptionalBitmapEquals;\n \n // ----------------------------------------------------------------------\n // Public method implementations\n \n namespace {\n \n-// These helper functions assume we already checked the arrays have equal\n-// sizes and null bitmaps.\n+bool CompareArrayRanges(const ArrayData& left, const ArrayData& right,\n+                        int64_t left_start_idx, int64_t left_end_idx,\n+                        int64_t right_start_idx, const EqualOptions& options,\n+                        bool floating_approximate);\n \n-template <typename ArrowType, typename EqualityFunc>\n-inline bool BaseFloatingEquals(const NumericArray<ArrowType>& left,\n-                               const NumericArray<ArrowType>& right,\n-                               EqualityFunc&& equals) {\n-  using T = typename ArrowType::c_type;\n-\n-  const T* left_data = left.raw_values();\n-  const T* right_data = right.raw_values();\n-\n-  if (left.null_count() > 0) {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (left.IsNull(i)) continue;\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  } else {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingEquals(const NumericArray<ArrowType>& left,\n-                           const NumericArray<ArrowType>& right,\n-                           const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [](T x, T y) -> bool {\n-      return (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right,\n-                                         [](T x, T y) -> bool { return x == y; });\n-  }\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingApproxEquals(const NumericArray<ArrowType>& left,\n-                                 const NumericArray<ArrowType>& right,\n-                                 const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-  const T epsilon = static_cast<T>(opts.atol());\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y);\n-    });\n-  }\n-}\n-\n-// RangeEqualsVisitor assumes the range sizes are equal\n-\n-class RangeEqualsVisitor {\n+class RangeDataEqualsImpl {\n  public:\n-  RangeEqualsVisitor(const Array& right, int64_t left_start_idx, int64_t left_end_idx,\n-                     int64_t right_start_idx)\n-      : right_(right),\n+  // PRE-CONDITIONS:\n+  // - the types are equal\n+  // - the ranges are in bounds\n+  RangeDataEqualsImpl(const EqualOptions& options, bool floating_approximate,\n+                      const ArrayData& left, const ArrayData& right,\n+                      int64_t left_start_idx, int64_t right_start_idx,\n+                      int64_t range_length)\n+      : options_(options),\n+        floating_approximate_(floating_approximate),\n+        left_(left),\n+        right_(right),\n         left_start_idx_(left_start_idx),\n-        left_end_idx_(left_end_idx),\n         right_start_idx_(right_start_idx),\n+        range_length_(range_length),\n         result_(false) {}\n \n-  template <typename ArrayType>\n-  inline Status CompareValues(const ArrayType& left) {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i) ||\n-          (!is_null && left.Value(i) != right.Value(o_i))) {\n-        result_ = false;\n-        return Status::OK();\n+  bool Compare() {\n+    // Compare null bitmaps\n+    if (left_start_idx_ == 0 && right_start_idx_ == 0 && range_length_ == left_.length &&\n+        range_length_ == right_.length) {\n+      // If we're comparing entire arrays, we can first compare the cached null counts\n+      if (left_.GetNullCount() != right_.GetNullCount()) {\n+        return false;\n       }\n     }\n-    result_ = true;\n-    return Status::OK();\n+    if (!OptionalBitmapEquals(left_.buffers[0], left_.offset + left_start_idx_,\n+                              right_.buffers[0], right_.offset + right_start_idx_,\n+                              range_length_)) {\n+      return false;\n+    }\n+    // Compare values\n+    return CompareWithType(*left_.type);\n   }\n \n-  template <typename ArrayType, typename CompareValuesFunc>\n-  bool CompareWithOffsets(const ArrayType& left,\n-                          CompareValuesFunc&& compare_values) const {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (is_null) continue;\n-      const auto begin_offset = left.value_offset(i);\n-      const auto end_offset = left.value_offset(i + 1);\n-      const auto right_begin_offset = right.value_offset(o_i);\n-      const auto right_end_offset = right.value_offset(o_i + 1);\n-      // Underlying can't be equal if the size isn't equal\n-      if (end_offset - begin_offset != right_end_offset - right_begin_offset) {\n-        return false;\n-      }\n-\n-      if (!compare_values(left, right, begin_offset, right_begin_offset,\n-                          end_offset - begin_offset)) {\n-        return false;\n-      }\n+  bool CompareWithType(const DataType& type) {\n+    result_ = true;\n+    if (range_length_ != 0) {\n+      ARROW_CHECK_OK(VisitTypeInline(type, this));\n     }\n-    return true;\n+    return result_;\n   }\n \n-  template <typename BinaryArrayType>\n-  bool CompareBinaryRange(const BinaryArrayType& left) const {\n-    using offset_type = typename BinaryArrayType::offset_type;\n+  Status Visit(const NullType&) { return Status::OK(); }\n \n-    auto compare_values = [](const BinaryArrayType& left, const BinaryArrayType& right,\n-                             offset_type left_offset, offset_type right_offset,\n-                             offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return std::memcmp(left.value_data()->data() + left_offset,\n-                         right.value_data()->data() + right_offset,\n-                         static_cast<size_t>(nvalues)) == 0;\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_primitive_ctype<TypeClass, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  template <typename ListArrayType>\n-  bool CompareLists(const ListArrayType& left) {\n-    using offset_type = typename ListArrayType::offset_type;\n-    const auto& right = checked_cast<const ListArrayType&>(right_);\n-    const std::shared_ptr<Array>& left_values = left.values();\n-    const std::shared_ptr<Array>& right_values = right.values();\n-\n-    auto compare_values = [&](const ListArrayType& left, const ListArrayType& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_values->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                      right_values);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n-  }\n-\n-  bool CompareMaps(const MapArray& left) {\n-    // We need a specific comparison helper for maps to avoid comparing\n-    // struct field names (which are indifferent for maps)\n-    using offset_type = typename MapArray::offset_type;\n-    const auto& right = checked_cast<const MapArray&>(right_);\n-    const auto left_keys = left.keys();\n-    const auto left_items = left.items();\n-    const auto right_keys = right.keys();\n-    const auto right_items = right.items();\n-\n-    auto compare_values = [&](const MapArray& left, const MapArray& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_keys->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                    right_keys) &&\n-             left_items->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                     right_items);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_t<is_temporal_type<TypeClass>::value, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  bool CompareStructs(const StructArray& left) {\n-    const auto& right = checked_cast<const StructArray&>(right_);\n-    bool equal_fields = true;\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      for (int j = 0; j < left.num_fields(); ++j) {\n-        // TODO: really we should be comparing stretches of non-null data rather\n-        // than looking at one value at a time.\n-        equal_fields = left.field(j)->RangeEquals(i, i + 1, o_i, right.field(j));\n-        if (!equal_fields) {\n-          return false;\n-        }\n-      }\n-    }\n-    return true;\n-  }\n-\n-  bool CompareUnions(const UnionArray& left) const {\n-    const auto& right = checked_cast<const UnionArray&>(right_);\n-\n-    const UnionMode::type union_mode = left.mode();\n-    if (union_mode != right.mode()) {\n-      return false;\n-    }\n-\n-    const auto& left_type = checked_cast<const UnionType&>(*left.type());\n-\n-    const std::vector<int>& child_ids = left_type.child_ids();\n-\n-    const int8_t* left_codes = left.raw_type_codes();\n-    const int8_t* right_codes = right.raw_type_codes();\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      if (left_codes[i] != right_codes[o_i]) {\n-        return false;\n-      }\n-\n-      auto child_num = child_ids[left_codes[i]];\n-\n-      // TODO(wesm): really we should be comparing stretches of non-null data\n-      // rather than looking at one value at a time.\n-      if (union_mode == UnionMode::SPARSE) {\n-        if (!left.field(child_num)->RangeEquals(i, i + 1, o_i, right.field(child_num))) {\n-          return false;\n+  Status Visit(const BooleanType&) {\n+    const uint8_t* left_bits = left_.GetValues<uint8_t>(1, 0);\n+    const uint8_t* right_bits = right_.GetValues<uint8_t>(1, 0);\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      if (length <= 8) {\n+        // Avoid the BitmapUInt64Reader overhead for very small runs\n+        for (int64_t j = i; j < i + length; ++j) {\n+          if (BitUtil::GetBit(left_bits, left_start_idx_ + left_.offset + j) !=\n+              BitUtil::GetBit(right_bits, right_start_idx_ + right_.offset + j)) {\n+            return false;\n+          }\n         }\n+        return true;\n       } else {\n-        const int32_t offset =\n-            checked_cast<const DenseUnionArray&>(left).raw_value_offsets()[i];\n-        const int32_t o_offset =\n-            checked_cast<const DenseUnionArray&>(right).raw_value_offsets()[o_i];\n-        if (!left.field(child_num)->RangeEquals(offset, offset + 1, o_offset,\n-                                                right.field(child_num))) {\n-          return false;\n+        BitmapUInt64Reader left_reader(left_bits, left_start_idx_ + left_.offset + i,\n+                                       length);\n+        BitmapUInt64Reader right_reader(right_bits, right_start_idx_ + right_.offset + i,\n+                                        length);\n+        while (left_reader.position() < length) {\n+          if (left_reader.NextWord() != right_reader.NextWord()) {\n+            return false;\n+          }\n         }\n+        DCHECK_EQ(right_reader.position(), length);\n       }\n-    }\n-    return true;\n-  }\n-\n-  Status Visit(const BinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n-    return Status::OK();\n-  }\n-\n-  Status Visit(const LargeBinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n+      return true;\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const FixedSizeBinaryArray& left) {\n-    const auto& right = checked_cast<const FixedSizeBinaryArray&>(right_);\n+  Status Visit(const FloatType& type) { return CompareFloating(type); }\n \n-    int32_t width = left.byte_width();\n+  Status Visit(const DoubleType& type) { return CompareFloating(type); }\n \n-    const uint8_t* left_data = nullptr;\n-    const uint8_t* right_data = nullptr;\n+  // Also matches StringType\n+  Status Visit(const BinaryType& type) { return CompareBinary(type); }\n \n-    if (left.values()) {\n-      left_data = left.raw_values();\n-    }\n+  // Also matches LargeStringType\n+  Status Visit(const LargeBinaryType& type) { return CompareBinary(type); }\n \n-    if (right.values()) {\n-      right_data = right.raw_values();\n-    }\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i)) {\n-        result_ = false;\n-        return Status::OK();\n-      }\n-      if (is_null) continue;\n+  Status Visit(const FixedSizeBinaryType& type) {\n+    const auto byte_width = type.byte_width();\n+    const uint8_t* left_data = left_.GetValues<uint8_t>(1, 0);\n+    const uint8_t* right_data = right_.GetValues<uint8_t>(1, 0);\n \n-      if (std::memcmp(left_data + width * i, right_data + width * o_i, width)) {\n-        result_ = false;\n-        return Status::OK();\n-      }\n+    if (left_data != nullptr && right_data != nullptr) {\n+      auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+        return memcmp(left_data + (left_start_idx_ + left_.offset + i) * byte_width,\n+                      right_data + (right_start_idx_ + right_.offset + i) * byte_width,\n+                      length * byte_width) == 0;\n+      };\n+      VisitValidRuns(compare_runs);\n+    } else {\n+      auto compare_runs = [&](int64_t i, int64_t length) -> bool { return true; };\n+      VisitValidRuns(compare_runs);\n     }\n-    result_ = true;\n     return Status::OK();\n   }\n \n-  Status Visit(const Decimal128Array& left) {\n-    return Visit(checked_cast<const FixedSizeBinaryArray&>(left));\n-  }\n+  // Also matches MapType\n+  Status Visit(const ListType& type) { return CompareList(type); }\n \n-  Status Visit(const Decimal256Array& left) {\n-    return Visit(checked_cast<const FixedSizeBinaryArray&>(left));\n-  }\n+  Status Visit(const LargeListType& type) { return CompareList(type); }\n \n-  Status Visit(const NullArray& left) {\n-    ARROW_UNUSED(left);\n-    result_ = true;\n-    return Status::OK();\n-  }\n-\n-  template <typename T>\n-  typename std::enable_if<std::is_base_of<PrimitiveArray, T>::value, Status>::type Visit(\n-      const T& left) {\n-    return CompareValues<T>(left);\n-  }\n+  Status Visit(const FixedSizeListType& type) {\n+    const auto list_size = type.list_size();\n+    const ArrayData& left_data = *left_.child_data[0];\n+    const ArrayData& right_data = *right_.child_data[0];\n \n-  Status Visit(const ListArray& left) {\n-    result_ = CompareLists(left);\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      RangeDataEqualsImpl impl(options_, floating_approximate_, left_data, right_data,\n+                               (left_start_idx_ + left_.offset + i) * list_size,\n+                               (right_start_idx_ + right_.offset + i) * list_size,\n+                               length * list_size);\n+      return impl.Compare();\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const LargeListArray& left) {\n-    result_ = CompareLists(left);\n-    return Status::OK();\n-  }\n+  Status Visit(const StructType& type) {\n+    const int32_t num_fields = type.num_fields();\n \n-  Status Visit(const FixedSizeListArray& left) {\n-    const auto& right = checked_cast<const FixedSizeListArray&>(right_);\n-    result_ = left.values()->RangeEquals(\n-        left.value_offset(left_start_idx_), left.value_offset(left_end_idx_),\n-        right.value_offset(right_start_idx_), right.values());\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      for (int32_t f = 0; f < num_fields; ++f) {\n+        RangeDataEqualsImpl impl(options_, floating_approximate_, *left_.child_data[f],\n+                                 *right_.child_data[f],\n+                                 left_start_idx_ + left_.offset + i,\n+                                 right_start_idx_ + right_.offset + i, length);\n+        if (!impl.Compare()) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const MapArray& left) {\n-    result_ = CompareMaps(left);\n-    return Status::OK();\n-  }\n+  Status Visit(const SparseUnionType& type) {\n+    const auto& child_ids = type.child_ids();\n+    const int8_t* left_codes = left_.GetValues<int8_t>(1);\n+    const int8_t* right_codes = right_.GetValues<int8_t>(1);\n \n-  Status Visit(const StructArray& left) {\n-    result_ = CompareStructs(left);\n+    VisitValidRuns([&](int64_t i, int64_t length) {\n\nReview comment:\n       Ha, I still occasionally forget about that :-)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-21T15:53:36.010+0000",
                    "updated": "2020-11-21T15:53:36.010+0000",
                    "started": "2020-11-21T15:53:36.010+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515087",
                    "issueId": "13330181"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330181/worklog/515088",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8703:\nURL: https://github.com/apache/arrow/pull/8703#discussion_r528211002\n\n\n\n##########\nFile path: cpp/src/arrow/compare.cc\n##########\n@@ -49,700 +51,441 @@\n namespace arrow {\n \n using internal::BitmapEquals;\n+using internal::BitmapReader;\n+using internal::BitmapUInt64Reader;\n using internal::checked_cast;\n+using internal::OptionalBitBlockCounter;\n+using internal::OptionalBitmapEquals;\n \n // ----------------------------------------------------------------------\n // Public method implementations\n \n namespace {\n \n-// These helper functions assume we already checked the arrays have equal\n-// sizes and null bitmaps.\n+bool CompareArrayRanges(const ArrayData& left, const ArrayData& right,\n+                        int64_t left_start_idx, int64_t left_end_idx,\n+                        int64_t right_start_idx, const EqualOptions& options,\n+                        bool floating_approximate);\n \n-template <typename ArrowType, typename EqualityFunc>\n-inline bool BaseFloatingEquals(const NumericArray<ArrowType>& left,\n-                               const NumericArray<ArrowType>& right,\n-                               EqualityFunc&& equals) {\n-  using T = typename ArrowType::c_type;\n-\n-  const T* left_data = left.raw_values();\n-  const T* right_data = right.raw_values();\n-\n-  if (left.null_count() > 0) {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (left.IsNull(i)) continue;\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  } else {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingEquals(const NumericArray<ArrowType>& left,\n-                           const NumericArray<ArrowType>& right,\n-                           const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [](T x, T y) -> bool {\n-      return (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right,\n-                                         [](T x, T y) -> bool { return x == y; });\n-  }\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingApproxEquals(const NumericArray<ArrowType>& left,\n-                                 const NumericArray<ArrowType>& right,\n-                                 const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-  const T epsilon = static_cast<T>(opts.atol());\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y);\n-    });\n-  }\n-}\n-\n-// RangeEqualsVisitor assumes the range sizes are equal\n-\n-class RangeEqualsVisitor {\n+class RangeDataEqualsImpl {\n  public:\n-  RangeEqualsVisitor(const Array& right, int64_t left_start_idx, int64_t left_end_idx,\n-                     int64_t right_start_idx)\n-      : right_(right),\n+  // PRE-CONDITIONS:\n+  // - the types are equal\n+  // - the ranges are in bounds\n+  RangeDataEqualsImpl(const EqualOptions& options, bool floating_approximate,\n+                      const ArrayData& left, const ArrayData& right,\n+                      int64_t left_start_idx, int64_t right_start_idx,\n+                      int64_t range_length)\n+      : options_(options),\n+        floating_approximate_(floating_approximate),\n+        left_(left),\n+        right_(right),\n         left_start_idx_(left_start_idx),\n-        left_end_idx_(left_end_idx),\n         right_start_idx_(right_start_idx),\n+        range_length_(range_length),\n         result_(false) {}\n \n-  template <typename ArrayType>\n-  inline Status CompareValues(const ArrayType& left) {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i) ||\n-          (!is_null && left.Value(i) != right.Value(o_i))) {\n-        result_ = false;\n-        return Status::OK();\n+  bool Compare() {\n+    // Compare null bitmaps\n+    if (left_start_idx_ == 0 && right_start_idx_ == 0 && range_length_ == left_.length &&\n+        range_length_ == right_.length) {\n+      // If we're comparing entire arrays, we can first compare the cached null counts\n+      if (left_.GetNullCount() != right_.GetNullCount()) {\n+        return false;\n       }\n     }\n-    result_ = true;\n-    return Status::OK();\n+    if (!OptionalBitmapEquals(left_.buffers[0], left_.offset + left_start_idx_,\n+                              right_.buffers[0], right_.offset + right_start_idx_,\n+                              range_length_)) {\n+      return false;\n+    }\n+    // Compare values\n+    return CompareWithType(*left_.type);\n   }\n \n-  template <typename ArrayType, typename CompareValuesFunc>\n-  bool CompareWithOffsets(const ArrayType& left,\n-                          CompareValuesFunc&& compare_values) const {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (is_null) continue;\n-      const auto begin_offset = left.value_offset(i);\n-      const auto end_offset = left.value_offset(i + 1);\n-      const auto right_begin_offset = right.value_offset(o_i);\n-      const auto right_end_offset = right.value_offset(o_i + 1);\n-      // Underlying can't be equal if the size isn't equal\n-      if (end_offset - begin_offset != right_end_offset - right_begin_offset) {\n-        return false;\n-      }\n-\n-      if (!compare_values(left, right, begin_offset, right_begin_offset,\n-                          end_offset - begin_offset)) {\n-        return false;\n-      }\n+  bool CompareWithType(const DataType& type) {\n+    result_ = true;\n+    if (range_length_ != 0) {\n+      ARROW_CHECK_OK(VisitTypeInline(type, this));\n     }\n-    return true;\n+    return result_;\n   }\n \n-  template <typename BinaryArrayType>\n-  bool CompareBinaryRange(const BinaryArrayType& left) const {\n-    using offset_type = typename BinaryArrayType::offset_type;\n+  Status Visit(const NullType&) { return Status::OK(); }\n \n-    auto compare_values = [](const BinaryArrayType& left, const BinaryArrayType& right,\n-                             offset_type left_offset, offset_type right_offset,\n-                             offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return std::memcmp(left.value_data()->data() + left_offset,\n-                         right.value_data()->data() + right_offset,\n-                         static_cast<size_t>(nvalues)) == 0;\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_primitive_ctype<TypeClass, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  template <typename ListArrayType>\n-  bool CompareLists(const ListArrayType& left) {\n-    using offset_type = typename ListArrayType::offset_type;\n-    const auto& right = checked_cast<const ListArrayType&>(right_);\n-    const std::shared_ptr<Array>& left_values = left.values();\n-    const std::shared_ptr<Array>& right_values = right.values();\n-\n-    auto compare_values = [&](const ListArrayType& left, const ListArrayType& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_values->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                      right_values);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n-  }\n-\n-  bool CompareMaps(const MapArray& left) {\n-    // We need a specific comparison helper for maps to avoid comparing\n-    // struct field names (which are indifferent for maps)\n-    using offset_type = typename MapArray::offset_type;\n-    const auto& right = checked_cast<const MapArray&>(right_);\n-    const auto left_keys = left.keys();\n-    const auto left_items = left.items();\n-    const auto right_keys = right.keys();\n-    const auto right_items = right.items();\n-\n-    auto compare_values = [&](const MapArray& left, const MapArray& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_keys->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                    right_keys) &&\n-             left_items->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                     right_items);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_t<is_temporal_type<TypeClass>::value, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  bool CompareStructs(const StructArray& left) {\n-    const auto& right = checked_cast<const StructArray&>(right_);\n-    bool equal_fields = true;\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      for (int j = 0; j < left.num_fields(); ++j) {\n-        // TODO: really we should be comparing stretches of non-null data rather\n-        // than looking at one value at a time.\n-        equal_fields = left.field(j)->RangeEquals(i, i + 1, o_i, right.field(j));\n-        if (!equal_fields) {\n-          return false;\n-        }\n-      }\n-    }\n-    return true;\n-  }\n-\n-  bool CompareUnions(const UnionArray& left) const {\n-    const auto& right = checked_cast<const UnionArray&>(right_);\n-\n-    const UnionMode::type union_mode = left.mode();\n-    if (union_mode != right.mode()) {\n-      return false;\n-    }\n-\n-    const auto& left_type = checked_cast<const UnionType&>(*left.type());\n-\n-    const std::vector<int>& child_ids = left_type.child_ids();\n-\n-    const int8_t* left_codes = left.raw_type_codes();\n-    const int8_t* right_codes = right.raw_type_codes();\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      if (left_codes[i] != right_codes[o_i]) {\n-        return false;\n-      }\n-\n-      auto child_num = child_ids[left_codes[i]];\n-\n-      // TODO(wesm): really we should be comparing stretches of non-null data\n-      // rather than looking at one value at a time.\n-      if (union_mode == UnionMode::SPARSE) {\n-        if (!left.field(child_num)->RangeEquals(i, i + 1, o_i, right.field(child_num))) {\n-          return false;\n+  Status Visit(const BooleanType&) {\n+    const uint8_t* left_bits = left_.GetValues<uint8_t>(1, 0);\n+    const uint8_t* right_bits = right_.GetValues<uint8_t>(1, 0);\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      if (length <= 8) {\n+        // Avoid the BitmapUInt64Reader overhead for very small runs\n+        for (int64_t j = i; j < i + length; ++j) {\n+          if (BitUtil::GetBit(left_bits, left_start_idx_ + left_.offset + j) !=\n+              BitUtil::GetBit(right_bits, right_start_idx_ + right_.offset + j)) {\n+            return false;\n+          }\n         }\n+        return true;\n       } else {\n-        const int32_t offset =\n-            checked_cast<const DenseUnionArray&>(left).raw_value_offsets()[i];\n-        const int32_t o_offset =\n-            checked_cast<const DenseUnionArray&>(right).raw_value_offsets()[o_i];\n-        if (!left.field(child_num)->RangeEquals(offset, offset + 1, o_offset,\n-                                                right.field(child_num))) {\n-          return false;\n+        BitmapUInt64Reader left_reader(left_bits, left_start_idx_ + left_.offset + i,\n+                                       length);\n+        BitmapUInt64Reader right_reader(right_bits, right_start_idx_ + right_.offset + i,\n+                                        length);\n+        while (left_reader.position() < length) {\n+          if (left_reader.NextWord() != right_reader.NextWord()) {\n+            return false;\n+          }\n         }\n+        DCHECK_EQ(right_reader.position(), length);\n       }\n-    }\n-    return true;\n-  }\n-\n-  Status Visit(const BinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n-    return Status::OK();\n-  }\n-\n-  Status Visit(const LargeBinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n+      return true;\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const FixedSizeBinaryArray& left) {\n-    const auto& right = checked_cast<const FixedSizeBinaryArray&>(right_);\n+  Status Visit(const FloatType& type) { return CompareFloating(type); }\n \n-    int32_t width = left.byte_width();\n+  Status Visit(const DoubleType& type) { return CompareFloating(type); }\n \n-    const uint8_t* left_data = nullptr;\n-    const uint8_t* right_data = nullptr;\n+  // Also matches StringType\n+  Status Visit(const BinaryType& type) { return CompareBinary(type); }\n \n-    if (left.values()) {\n-      left_data = left.raw_values();\n-    }\n+  // Also matches LargeStringType\n+  Status Visit(const LargeBinaryType& type) { return CompareBinary(type); }\n \n-    if (right.values()) {\n-      right_data = right.raw_values();\n-    }\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i)) {\n-        result_ = false;\n-        return Status::OK();\n-      }\n-      if (is_null) continue;\n+  Status Visit(const FixedSizeBinaryType& type) {\n+    const auto byte_width = type.byte_width();\n+    const uint8_t* left_data = left_.GetValues<uint8_t>(1, 0);\n+    const uint8_t* right_data = right_.GetValues<uint8_t>(1, 0);\n \n-      if (std::memcmp(left_data + width * i, right_data + width * o_i, width)) {\n-        result_ = false;\n-        return Status::OK();\n-      }\n+    if (left_data != nullptr && right_data != nullptr) {\n+      auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+        return memcmp(left_data + (left_start_idx_ + left_.offset + i) * byte_width,\n+                      right_data + (right_start_idx_ + right_.offset + i) * byte_width,\n+                      length * byte_width) == 0;\n+      };\n+      VisitValidRuns(compare_runs);\n+    } else {\n+      auto compare_runs = [&](int64_t i, int64_t length) -> bool { return true; };\n+      VisitValidRuns(compare_runs);\n     }\n-    result_ = true;\n     return Status::OK();\n   }\n \n-  Status Visit(const Decimal128Array& left) {\n-    return Visit(checked_cast<const FixedSizeBinaryArray&>(left));\n-  }\n+  // Also matches MapType\n+  Status Visit(const ListType& type) { return CompareList(type); }\n \n-  Status Visit(const Decimal256Array& left) {\n-    return Visit(checked_cast<const FixedSizeBinaryArray&>(left));\n-  }\n+  Status Visit(const LargeListType& type) { return CompareList(type); }\n \n-  Status Visit(const NullArray& left) {\n-    ARROW_UNUSED(left);\n-    result_ = true;\n-    return Status::OK();\n-  }\n-\n-  template <typename T>\n-  typename std::enable_if<std::is_base_of<PrimitiveArray, T>::value, Status>::type Visit(\n-      const T& left) {\n-    return CompareValues<T>(left);\n-  }\n+  Status Visit(const FixedSizeListType& type) {\n+    const auto list_size = type.list_size();\n+    const ArrayData& left_data = *left_.child_data[0];\n+    const ArrayData& right_data = *right_.child_data[0];\n \n-  Status Visit(const ListArray& left) {\n-    result_ = CompareLists(left);\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      RangeDataEqualsImpl impl(options_, floating_approximate_, left_data, right_data,\n+                               (left_start_idx_ + left_.offset + i) * list_size,\n+                               (right_start_idx_ + right_.offset + i) * list_size,\n+                               length * list_size);\n+      return impl.Compare();\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const LargeListArray& left) {\n-    result_ = CompareLists(left);\n-    return Status::OK();\n-  }\n+  Status Visit(const StructType& type) {\n+    const int32_t num_fields = type.num_fields();\n \n-  Status Visit(const FixedSizeListArray& left) {\n-    const auto& right = checked_cast<const FixedSizeListArray&>(right_);\n-    result_ = left.values()->RangeEquals(\n-        left.value_offset(left_start_idx_), left.value_offset(left_end_idx_),\n-        right.value_offset(right_start_idx_), right.values());\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      for (int32_t f = 0; f < num_fields; ++f) {\n+        RangeDataEqualsImpl impl(options_, floating_approximate_, *left_.child_data[f],\n+                                 *right_.child_data[f],\n+                                 left_start_idx_ + left_.offset + i,\n+                                 right_start_idx_ + right_.offset + i, length);\n+        if (!impl.Compare()) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const MapArray& left) {\n-    result_ = CompareMaps(left);\n-    return Status::OK();\n-  }\n+  Status Visit(const SparseUnionType& type) {\n+    const auto& child_ids = type.child_ids();\n+    const int8_t* left_codes = left_.GetValues<int8_t>(1);\n+    const int8_t* right_codes = right_.GetValues<int8_t>(1);\n \n-  Status Visit(const StructArray& left) {\n-    result_ = CompareStructs(left);\n+    VisitValidRuns([&](int64_t i, int64_t length) {\n+      for (int64_t j = i; j < i + length; ++j) {\n+        const auto type_id = left_codes[left_start_idx_ + j];\n+        if (type_id != right_codes[right_start_idx_ + j]) {\n+          return false;\n+        }\n+        const auto child_num = child_ids[type_id];\n+        // XXX can we instead detect runs of same-child union values?\n\nReview comment:\n       Right, though the question is whether this would improve or worsen common cases (I have no idea how unions are used in the wild).\r\n   In any case, this could be a separate low-priority JIRA (I don't think optimizing unions is in our current priorities).\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-21T15:54:42.148+0000",
                    "updated": "2020-11-21T15:54:42.148+0000",
                    "started": "2020-11-21T15:54:42.147+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515088",
                    "issueId": "13330181"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330181/worklog/515089",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8703:\nURL: https://github.com/apache/arrow/pull/8703#discussion_r528211150\n\n\n\n##########\nFile path: cpp/src/arrow/compare.cc\n##########\n@@ -49,700 +51,441 @@\n namespace arrow {\n \n using internal::BitmapEquals;\n+using internal::BitmapReader;\n+using internal::BitmapUInt64Reader;\n using internal::checked_cast;\n+using internal::OptionalBitBlockCounter;\n+using internal::OptionalBitmapEquals;\n \n // ----------------------------------------------------------------------\n // Public method implementations\n \n namespace {\n \n-// These helper functions assume we already checked the arrays have equal\n-// sizes and null bitmaps.\n+bool CompareArrayRanges(const ArrayData& left, const ArrayData& right,\n+                        int64_t left_start_idx, int64_t left_end_idx,\n+                        int64_t right_start_idx, const EqualOptions& options,\n+                        bool floating_approximate);\n \n-template <typename ArrowType, typename EqualityFunc>\n-inline bool BaseFloatingEquals(const NumericArray<ArrowType>& left,\n-                               const NumericArray<ArrowType>& right,\n-                               EqualityFunc&& equals) {\n-  using T = typename ArrowType::c_type;\n-\n-  const T* left_data = left.raw_values();\n-  const T* right_data = right.raw_values();\n-\n-  if (left.null_count() > 0) {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (left.IsNull(i)) continue;\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  } else {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingEquals(const NumericArray<ArrowType>& left,\n-                           const NumericArray<ArrowType>& right,\n-                           const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [](T x, T y) -> bool {\n-      return (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right,\n-                                         [](T x, T y) -> bool { return x == y; });\n-  }\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingApproxEquals(const NumericArray<ArrowType>& left,\n-                                 const NumericArray<ArrowType>& right,\n-                                 const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-  const T epsilon = static_cast<T>(opts.atol());\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y);\n-    });\n-  }\n-}\n-\n-// RangeEqualsVisitor assumes the range sizes are equal\n-\n-class RangeEqualsVisitor {\n+class RangeDataEqualsImpl {\n  public:\n-  RangeEqualsVisitor(const Array& right, int64_t left_start_idx, int64_t left_end_idx,\n-                     int64_t right_start_idx)\n-      : right_(right),\n+  // PRE-CONDITIONS:\n+  // - the types are equal\n+  // - the ranges are in bounds\n+  RangeDataEqualsImpl(const EqualOptions& options, bool floating_approximate,\n+                      const ArrayData& left, const ArrayData& right,\n+                      int64_t left_start_idx, int64_t right_start_idx,\n+                      int64_t range_length)\n+      : options_(options),\n+        floating_approximate_(floating_approximate),\n+        left_(left),\n+        right_(right),\n         left_start_idx_(left_start_idx),\n-        left_end_idx_(left_end_idx),\n         right_start_idx_(right_start_idx),\n+        range_length_(range_length),\n         result_(false) {}\n \n-  template <typename ArrayType>\n-  inline Status CompareValues(const ArrayType& left) {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i) ||\n-          (!is_null && left.Value(i) != right.Value(o_i))) {\n-        result_ = false;\n-        return Status::OK();\n+  bool Compare() {\n+    // Compare null bitmaps\n+    if (left_start_idx_ == 0 && right_start_idx_ == 0 && range_length_ == left_.length &&\n+        range_length_ == right_.length) {\n+      // If we're comparing entire arrays, we can first compare the cached null counts\n+      if (left_.GetNullCount() != right_.GetNullCount()) {\n+        return false;\n       }\n     }\n-    result_ = true;\n-    return Status::OK();\n+    if (!OptionalBitmapEquals(left_.buffers[0], left_.offset + left_start_idx_,\n+                              right_.buffers[0], right_.offset + right_start_idx_,\n+                              range_length_)) {\n+      return false;\n+    }\n+    // Compare values\n+    return CompareWithType(*left_.type);\n   }\n \n-  template <typename ArrayType, typename CompareValuesFunc>\n-  bool CompareWithOffsets(const ArrayType& left,\n-                          CompareValuesFunc&& compare_values) const {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (is_null) continue;\n-      const auto begin_offset = left.value_offset(i);\n-      const auto end_offset = left.value_offset(i + 1);\n-      const auto right_begin_offset = right.value_offset(o_i);\n-      const auto right_end_offset = right.value_offset(o_i + 1);\n-      // Underlying can't be equal if the size isn't equal\n-      if (end_offset - begin_offset != right_end_offset - right_begin_offset) {\n-        return false;\n-      }\n-\n-      if (!compare_values(left, right, begin_offset, right_begin_offset,\n-                          end_offset - begin_offset)) {\n-        return false;\n-      }\n+  bool CompareWithType(const DataType& type) {\n+    result_ = true;\n+    if (range_length_ != 0) {\n+      ARROW_CHECK_OK(VisitTypeInline(type, this));\n     }\n-    return true;\n+    return result_;\n   }\n \n-  template <typename BinaryArrayType>\n-  bool CompareBinaryRange(const BinaryArrayType& left) const {\n-    using offset_type = typename BinaryArrayType::offset_type;\n+  Status Visit(const NullType&) { return Status::OK(); }\n \n-    auto compare_values = [](const BinaryArrayType& left, const BinaryArrayType& right,\n-                             offset_type left_offset, offset_type right_offset,\n-                             offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return std::memcmp(left.value_data()->data() + left_offset,\n-                         right.value_data()->data() + right_offset,\n-                         static_cast<size_t>(nvalues)) == 0;\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_primitive_ctype<TypeClass, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  template <typename ListArrayType>\n-  bool CompareLists(const ListArrayType& left) {\n-    using offset_type = typename ListArrayType::offset_type;\n-    const auto& right = checked_cast<const ListArrayType&>(right_);\n-    const std::shared_ptr<Array>& left_values = left.values();\n-    const std::shared_ptr<Array>& right_values = right.values();\n-\n-    auto compare_values = [&](const ListArrayType& left, const ListArrayType& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_values->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                      right_values);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n-  }\n-\n-  bool CompareMaps(const MapArray& left) {\n-    // We need a specific comparison helper for maps to avoid comparing\n-    // struct field names (which are indifferent for maps)\n-    using offset_type = typename MapArray::offset_type;\n-    const auto& right = checked_cast<const MapArray&>(right_);\n-    const auto left_keys = left.keys();\n-    const auto left_items = left.items();\n-    const auto right_keys = right.keys();\n-    const auto right_items = right.items();\n-\n-    auto compare_values = [&](const MapArray& left, const MapArray& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_keys->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                    right_keys) &&\n-             left_items->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                     right_items);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_t<is_temporal_type<TypeClass>::value, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  bool CompareStructs(const StructArray& left) {\n-    const auto& right = checked_cast<const StructArray&>(right_);\n-    bool equal_fields = true;\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      for (int j = 0; j < left.num_fields(); ++j) {\n-        // TODO: really we should be comparing stretches of non-null data rather\n-        // than looking at one value at a time.\n-        equal_fields = left.field(j)->RangeEquals(i, i + 1, o_i, right.field(j));\n-        if (!equal_fields) {\n-          return false;\n-        }\n-      }\n-    }\n-    return true;\n-  }\n-\n-  bool CompareUnions(const UnionArray& left) const {\n-    const auto& right = checked_cast<const UnionArray&>(right_);\n-\n-    const UnionMode::type union_mode = left.mode();\n-    if (union_mode != right.mode()) {\n-      return false;\n-    }\n-\n-    const auto& left_type = checked_cast<const UnionType&>(*left.type());\n-\n-    const std::vector<int>& child_ids = left_type.child_ids();\n-\n-    const int8_t* left_codes = left.raw_type_codes();\n-    const int8_t* right_codes = right.raw_type_codes();\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      if (left_codes[i] != right_codes[o_i]) {\n-        return false;\n-      }\n-\n-      auto child_num = child_ids[left_codes[i]];\n-\n-      // TODO(wesm): really we should be comparing stretches of non-null data\n-      // rather than looking at one value at a time.\n-      if (union_mode == UnionMode::SPARSE) {\n-        if (!left.field(child_num)->RangeEquals(i, i + 1, o_i, right.field(child_num))) {\n-          return false;\n+  Status Visit(const BooleanType&) {\n+    const uint8_t* left_bits = left_.GetValues<uint8_t>(1, 0);\n+    const uint8_t* right_bits = right_.GetValues<uint8_t>(1, 0);\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      if (length <= 8) {\n+        // Avoid the BitmapUInt64Reader overhead for very small runs\n+        for (int64_t j = i; j < i + length; ++j) {\n+          if (BitUtil::GetBit(left_bits, left_start_idx_ + left_.offset + j) !=\n+              BitUtil::GetBit(right_bits, right_start_idx_ + right_.offset + j)) {\n+            return false;\n+          }\n         }\n+        return true;\n       } else {\n-        const int32_t offset =\n-            checked_cast<const DenseUnionArray&>(left).raw_value_offsets()[i];\n-        const int32_t o_offset =\n-            checked_cast<const DenseUnionArray&>(right).raw_value_offsets()[o_i];\n-        if (!left.field(child_num)->RangeEquals(offset, offset + 1, o_offset,\n-                                                right.field(child_num))) {\n-          return false;\n+        BitmapUInt64Reader left_reader(left_bits, left_start_idx_ + left_.offset + i,\n+                                       length);\n+        BitmapUInt64Reader right_reader(right_bits, right_start_idx_ + right_.offset + i,\n+                                        length);\n+        while (left_reader.position() < length) {\n+          if (left_reader.NextWord() != right_reader.NextWord()) {\n+            return false;\n+          }\n         }\n+        DCHECK_EQ(right_reader.position(), length);\n       }\n-    }\n-    return true;\n-  }\n-\n-  Status Visit(const BinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n-    return Status::OK();\n-  }\n-\n-  Status Visit(const LargeBinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n+      return true;\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const FixedSizeBinaryArray& left) {\n-    const auto& right = checked_cast<const FixedSizeBinaryArray&>(right_);\n+  Status Visit(const FloatType& type) { return CompareFloating(type); }\n \n-    int32_t width = left.byte_width();\n+  Status Visit(const DoubleType& type) { return CompareFloating(type); }\n \n-    const uint8_t* left_data = nullptr;\n-    const uint8_t* right_data = nullptr;\n+  // Also matches StringType\n+  Status Visit(const BinaryType& type) { return CompareBinary(type); }\n \n-    if (left.values()) {\n-      left_data = left.raw_values();\n-    }\n+  // Also matches LargeStringType\n+  Status Visit(const LargeBinaryType& type) { return CompareBinary(type); }\n \n-    if (right.values()) {\n-      right_data = right.raw_values();\n-    }\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i)) {\n-        result_ = false;\n-        return Status::OK();\n-      }\n-      if (is_null) continue;\n+  Status Visit(const FixedSizeBinaryType& type) {\n+    const auto byte_width = type.byte_width();\n+    const uint8_t* left_data = left_.GetValues<uint8_t>(1, 0);\n+    const uint8_t* right_data = right_.GetValues<uint8_t>(1, 0);\n \n-      if (std::memcmp(left_data + width * i, right_data + width * o_i, width)) {\n-        result_ = false;\n-        return Status::OK();\n-      }\n+    if (left_data != nullptr && right_data != nullptr) {\n+      auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+        return memcmp(left_data + (left_start_idx_ + left_.offset + i) * byte_width,\n+                      right_data + (right_start_idx_ + right_.offset + i) * byte_width,\n+                      length * byte_width) == 0;\n+      };\n+      VisitValidRuns(compare_runs);\n+    } else {\n+      auto compare_runs = [&](int64_t i, int64_t length) -> bool { return true; };\n+      VisitValidRuns(compare_runs);\n     }\n-    result_ = true;\n     return Status::OK();\n   }\n \n-  Status Visit(const Decimal128Array& left) {\n-    return Visit(checked_cast<const FixedSizeBinaryArray&>(left));\n-  }\n+  // Also matches MapType\n+  Status Visit(const ListType& type) { return CompareList(type); }\n \n-  Status Visit(const Decimal256Array& left) {\n-    return Visit(checked_cast<const FixedSizeBinaryArray&>(left));\n-  }\n+  Status Visit(const LargeListType& type) { return CompareList(type); }\n \n-  Status Visit(const NullArray& left) {\n-    ARROW_UNUSED(left);\n-    result_ = true;\n-    return Status::OK();\n-  }\n-\n-  template <typename T>\n-  typename std::enable_if<std::is_base_of<PrimitiveArray, T>::value, Status>::type Visit(\n-      const T& left) {\n-    return CompareValues<T>(left);\n-  }\n+  Status Visit(const FixedSizeListType& type) {\n+    const auto list_size = type.list_size();\n+    const ArrayData& left_data = *left_.child_data[0];\n+    const ArrayData& right_data = *right_.child_data[0];\n \n-  Status Visit(const ListArray& left) {\n-    result_ = CompareLists(left);\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      RangeDataEqualsImpl impl(options_, floating_approximate_, left_data, right_data,\n+                               (left_start_idx_ + left_.offset + i) * list_size,\n+                               (right_start_idx_ + right_.offset + i) * list_size,\n+                               length * list_size);\n+      return impl.Compare();\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const LargeListArray& left) {\n-    result_ = CompareLists(left);\n-    return Status::OK();\n-  }\n+  Status Visit(const StructType& type) {\n+    const int32_t num_fields = type.num_fields();\n \n-  Status Visit(const FixedSizeListArray& left) {\n-    const auto& right = checked_cast<const FixedSizeListArray&>(right_);\n-    result_ = left.values()->RangeEquals(\n-        left.value_offset(left_start_idx_), left.value_offset(left_end_idx_),\n-        right.value_offset(right_start_idx_), right.values());\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      for (int32_t f = 0; f < num_fields; ++f) {\n+        RangeDataEqualsImpl impl(options_, floating_approximate_, *left_.child_data[f],\n+                                 *right_.child_data[f],\n+                                 left_start_idx_ + left_.offset + i,\n+                                 right_start_idx_ + right_.offset + i, length);\n+        if (!impl.Compare()) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const MapArray& left) {\n-    result_ = CompareMaps(left);\n-    return Status::OK();\n-  }\n+  Status Visit(const SparseUnionType& type) {\n+    const auto& child_ids = type.child_ids();\n+    const int8_t* left_codes = left_.GetValues<int8_t>(1);\n+    const int8_t* right_codes = right_.GetValues<int8_t>(1);\n \n-  Status Visit(const StructArray& left) {\n-    result_ = CompareStructs(left);\n+    VisitValidRuns([&](int64_t i, int64_t length) {\n+      for (int64_t j = i; j < i + length; ++j) {\n+        const auto type_id = left_codes[left_start_idx_ + j];\n+        if (type_id != right_codes[right_start_idx_ + j]) {\n+          return false;\n+        }\n+        const auto child_num = child_ids[type_id];\n+        // XXX can we instead detect runs of same-child union values?\n+        RangeDataEqualsImpl impl(\n+            options_, floating_approximate_, *left_.child_data[child_num],\n+            *right_.child_data[child_num], left_start_idx_ + left_.offset + j,\n+            right_start_idx_ + right_.offset + j, 1);\n+        if (!impl.Compare()) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    });\n     return Status::OK();\n   }\n \n-  Status Visit(const UnionArray& left) {\n-    result_ = CompareUnions(left);\n+  Status Visit(const DenseUnionType& type) {\n+    const auto& child_ids = type.child_ids();\n+    const int8_t* left_codes = left_.GetValues<int8_t>(1);\n+    const int8_t* right_codes = right_.GetValues<int8_t>(1);\n+    const int32_t* left_offsets = left_.GetValues<int32_t>(2);\n+    const int32_t* right_offsets = right_.GetValues<int32_t>(2);\n+\n+    VisitValidRuns([&](int64_t i, int64_t length) {\n+      for (int64_t j = i; j < i + length; ++j) {\n+        const auto type_id = left_codes[left_start_idx_ + j];\n+        if (type_id != right_codes[right_start_idx_ + j]) {\n+          return false;\n+        }\n+        const auto child_num = child_ids[type_id];\n\nReview comment:\n       I kept the previous semantics of dictionary array comparison, that is: if the dictionaries themselves are unequal, the arrays are considered unequal even if the indices only refer to equal dictionary elements.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-21T15:55:45.227+0000",
                    "updated": "2020-11-21T15:55:45.227+0000",
                    "started": "2020-11-21T15:55:45.227+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515089",
                    "issueId": "13330181"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330181/worklog/515090",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8703:\nURL: https://github.com/apache/arrow/pull/8703#discussion_r528211187\n\n\n\n##########\nFile path: cpp/src/arrow/compare.cc\n##########\n@@ -49,700 +51,441 @@\n namespace arrow {\n \n using internal::BitmapEquals;\n+using internal::BitmapReader;\n+using internal::BitmapUInt64Reader;\n using internal::checked_cast;\n+using internal::OptionalBitBlockCounter;\n+using internal::OptionalBitmapEquals;\n \n // ----------------------------------------------------------------------\n // Public method implementations\n \n namespace {\n \n-// These helper functions assume we already checked the arrays have equal\n-// sizes and null bitmaps.\n+bool CompareArrayRanges(const ArrayData& left, const ArrayData& right,\n+                        int64_t left_start_idx, int64_t left_end_idx,\n+                        int64_t right_start_idx, const EqualOptions& options,\n+                        bool floating_approximate);\n \n-template <typename ArrowType, typename EqualityFunc>\n-inline bool BaseFloatingEquals(const NumericArray<ArrowType>& left,\n-                               const NumericArray<ArrowType>& right,\n-                               EqualityFunc&& equals) {\n-  using T = typename ArrowType::c_type;\n-\n-  const T* left_data = left.raw_values();\n-  const T* right_data = right.raw_values();\n-\n-  if (left.null_count() > 0) {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (left.IsNull(i)) continue;\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  } else {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingEquals(const NumericArray<ArrowType>& left,\n-                           const NumericArray<ArrowType>& right,\n-                           const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [](T x, T y) -> bool {\n-      return (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right,\n-                                         [](T x, T y) -> bool { return x == y; });\n-  }\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingApproxEquals(const NumericArray<ArrowType>& left,\n-                                 const NumericArray<ArrowType>& right,\n-                                 const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-  const T epsilon = static_cast<T>(opts.atol());\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y);\n-    });\n-  }\n-}\n-\n-// RangeEqualsVisitor assumes the range sizes are equal\n-\n-class RangeEqualsVisitor {\n+class RangeDataEqualsImpl {\n  public:\n-  RangeEqualsVisitor(const Array& right, int64_t left_start_idx, int64_t left_end_idx,\n-                     int64_t right_start_idx)\n-      : right_(right),\n+  // PRE-CONDITIONS:\n+  // - the types are equal\n+  // - the ranges are in bounds\n+  RangeDataEqualsImpl(const EqualOptions& options, bool floating_approximate,\n+                      const ArrayData& left, const ArrayData& right,\n+                      int64_t left_start_idx, int64_t right_start_idx,\n+                      int64_t range_length)\n+      : options_(options),\n+        floating_approximate_(floating_approximate),\n+        left_(left),\n+        right_(right),\n         left_start_idx_(left_start_idx),\n-        left_end_idx_(left_end_idx),\n         right_start_idx_(right_start_idx),\n+        range_length_(range_length),\n         result_(false) {}\n \n-  template <typename ArrayType>\n-  inline Status CompareValues(const ArrayType& left) {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i) ||\n-          (!is_null && left.Value(i) != right.Value(o_i))) {\n-        result_ = false;\n-        return Status::OK();\n+  bool Compare() {\n+    // Compare null bitmaps\n+    if (left_start_idx_ == 0 && right_start_idx_ == 0 && range_length_ == left_.length &&\n+        range_length_ == right_.length) {\n+      // If we're comparing entire arrays, we can first compare the cached null counts\n+      if (left_.GetNullCount() != right_.GetNullCount()) {\n+        return false;\n       }\n     }\n-    result_ = true;\n-    return Status::OK();\n+    if (!OptionalBitmapEquals(left_.buffers[0], left_.offset + left_start_idx_,\n+                              right_.buffers[0], right_.offset + right_start_idx_,\n+                              range_length_)) {\n+      return false;\n+    }\n+    // Compare values\n+    return CompareWithType(*left_.type);\n   }\n \n-  template <typename ArrayType, typename CompareValuesFunc>\n-  bool CompareWithOffsets(const ArrayType& left,\n-                          CompareValuesFunc&& compare_values) const {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (is_null) continue;\n-      const auto begin_offset = left.value_offset(i);\n-      const auto end_offset = left.value_offset(i + 1);\n-      const auto right_begin_offset = right.value_offset(o_i);\n-      const auto right_end_offset = right.value_offset(o_i + 1);\n-      // Underlying can't be equal if the size isn't equal\n-      if (end_offset - begin_offset != right_end_offset - right_begin_offset) {\n-        return false;\n-      }\n-\n-      if (!compare_values(left, right, begin_offset, right_begin_offset,\n-                          end_offset - begin_offset)) {\n-        return false;\n-      }\n+  bool CompareWithType(const DataType& type) {\n+    result_ = true;\n+    if (range_length_ != 0) {\n+      ARROW_CHECK_OK(VisitTypeInline(type, this));\n     }\n-    return true;\n+    return result_;\n   }\n \n-  template <typename BinaryArrayType>\n-  bool CompareBinaryRange(const BinaryArrayType& left) const {\n-    using offset_type = typename BinaryArrayType::offset_type;\n+  Status Visit(const NullType&) { return Status::OK(); }\n \n-    auto compare_values = [](const BinaryArrayType& left, const BinaryArrayType& right,\n-                             offset_type left_offset, offset_type right_offset,\n-                             offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return std::memcmp(left.value_data()->data() + left_offset,\n-                         right.value_data()->data() + right_offset,\n-                         static_cast<size_t>(nvalues)) == 0;\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_primitive_ctype<TypeClass, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  template <typename ListArrayType>\n-  bool CompareLists(const ListArrayType& left) {\n-    using offset_type = typename ListArrayType::offset_type;\n-    const auto& right = checked_cast<const ListArrayType&>(right_);\n-    const std::shared_ptr<Array>& left_values = left.values();\n-    const std::shared_ptr<Array>& right_values = right.values();\n-\n-    auto compare_values = [&](const ListArrayType& left, const ListArrayType& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_values->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                      right_values);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n-  }\n-\n-  bool CompareMaps(const MapArray& left) {\n-    // We need a specific comparison helper for maps to avoid comparing\n-    // struct field names (which are indifferent for maps)\n-    using offset_type = typename MapArray::offset_type;\n-    const auto& right = checked_cast<const MapArray&>(right_);\n-    const auto left_keys = left.keys();\n-    const auto left_items = left.items();\n-    const auto right_keys = right.keys();\n-    const auto right_items = right.items();\n-\n-    auto compare_values = [&](const MapArray& left, const MapArray& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_keys->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                    right_keys) &&\n-             left_items->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                     right_items);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_t<is_temporal_type<TypeClass>::value, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  bool CompareStructs(const StructArray& left) {\n-    const auto& right = checked_cast<const StructArray&>(right_);\n-    bool equal_fields = true;\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      for (int j = 0; j < left.num_fields(); ++j) {\n-        // TODO: really we should be comparing stretches of non-null data rather\n-        // than looking at one value at a time.\n-        equal_fields = left.field(j)->RangeEquals(i, i + 1, o_i, right.field(j));\n-        if (!equal_fields) {\n-          return false;\n-        }\n-      }\n-    }\n-    return true;\n-  }\n-\n-  bool CompareUnions(const UnionArray& left) const {\n-    const auto& right = checked_cast<const UnionArray&>(right_);\n-\n-    const UnionMode::type union_mode = left.mode();\n-    if (union_mode != right.mode()) {\n-      return false;\n-    }\n-\n-    const auto& left_type = checked_cast<const UnionType&>(*left.type());\n-\n-    const std::vector<int>& child_ids = left_type.child_ids();\n-\n-    const int8_t* left_codes = left.raw_type_codes();\n-    const int8_t* right_codes = right.raw_type_codes();\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      if (left_codes[i] != right_codes[o_i]) {\n-        return false;\n-      }\n-\n-      auto child_num = child_ids[left_codes[i]];\n-\n-      // TODO(wesm): really we should be comparing stretches of non-null data\n-      // rather than looking at one value at a time.\n-      if (union_mode == UnionMode::SPARSE) {\n-        if (!left.field(child_num)->RangeEquals(i, i + 1, o_i, right.field(child_num))) {\n-          return false;\n+  Status Visit(const BooleanType&) {\n+    const uint8_t* left_bits = left_.GetValues<uint8_t>(1, 0);\n+    const uint8_t* right_bits = right_.GetValues<uint8_t>(1, 0);\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      if (length <= 8) {\n+        // Avoid the BitmapUInt64Reader overhead for very small runs\n+        for (int64_t j = i; j < i + length; ++j) {\n+          if (BitUtil::GetBit(left_bits, left_start_idx_ + left_.offset + j) !=\n+              BitUtil::GetBit(right_bits, right_start_idx_ + right_.offset + j)) {\n+            return false;\n+          }\n         }\n+        return true;\n       } else {\n-        const int32_t offset =\n-            checked_cast<const DenseUnionArray&>(left).raw_value_offsets()[i];\n-        const int32_t o_offset =\n-            checked_cast<const DenseUnionArray&>(right).raw_value_offsets()[o_i];\n-        if (!left.field(child_num)->RangeEquals(offset, offset + 1, o_offset,\n-                                                right.field(child_num))) {\n-          return false;\n+        BitmapUInt64Reader left_reader(left_bits, left_start_idx_ + left_.offset + i,\n+                                       length);\n+        BitmapUInt64Reader right_reader(right_bits, right_start_idx_ + right_.offset + i,\n+                                        length);\n+        while (left_reader.position() < length) {\n+          if (left_reader.NextWord() != right_reader.NextWord()) {\n+            return false;\n+          }\n         }\n+        DCHECK_EQ(right_reader.position(), length);\n       }\n-    }\n-    return true;\n-  }\n-\n-  Status Visit(const BinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n-    return Status::OK();\n-  }\n-\n-  Status Visit(const LargeBinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n+      return true;\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const FixedSizeBinaryArray& left) {\n-    const auto& right = checked_cast<const FixedSizeBinaryArray&>(right_);\n+  Status Visit(const FloatType& type) { return CompareFloating(type); }\n \n-    int32_t width = left.byte_width();\n+  Status Visit(const DoubleType& type) { return CompareFloating(type); }\n \n-    const uint8_t* left_data = nullptr;\n-    const uint8_t* right_data = nullptr;\n+  // Also matches StringType\n+  Status Visit(const BinaryType& type) { return CompareBinary(type); }\n \n-    if (left.values()) {\n-      left_data = left.raw_values();\n-    }\n+  // Also matches LargeStringType\n+  Status Visit(const LargeBinaryType& type) { return CompareBinary(type); }\n \n-    if (right.values()) {\n-      right_data = right.raw_values();\n-    }\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i)) {\n-        result_ = false;\n-        return Status::OK();\n-      }\n-      if (is_null) continue;\n+  Status Visit(const FixedSizeBinaryType& type) {\n+    const auto byte_width = type.byte_width();\n+    const uint8_t* left_data = left_.GetValues<uint8_t>(1, 0);\n+    const uint8_t* right_data = right_.GetValues<uint8_t>(1, 0);\n \n-      if (std::memcmp(left_data + width * i, right_data + width * o_i, width)) {\n-        result_ = false;\n-        return Status::OK();\n-      }\n+    if (left_data != nullptr && right_data != nullptr) {\n+      auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+        return memcmp(left_data + (left_start_idx_ + left_.offset + i) * byte_width,\n+                      right_data + (right_start_idx_ + right_.offset + i) * byte_width,\n+                      length * byte_width) == 0;\n+      };\n+      VisitValidRuns(compare_runs);\n+    } else {\n+      auto compare_runs = [&](int64_t i, int64_t length) -> bool { return true; };\n+      VisitValidRuns(compare_runs);\n     }\n-    result_ = true;\n     return Status::OK();\n   }\n \n-  Status Visit(const Decimal128Array& left) {\n-    return Visit(checked_cast<const FixedSizeBinaryArray&>(left));\n-  }\n+  // Also matches MapType\n+  Status Visit(const ListType& type) { return CompareList(type); }\n \n-  Status Visit(const Decimal256Array& left) {\n-    return Visit(checked_cast<const FixedSizeBinaryArray&>(left));\n-  }\n+  Status Visit(const LargeListType& type) { return CompareList(type); }\n \n-  Status Visit(const NullArray& left) {\n-    ARROW_UNUSED(left);\n-    result_ = true;\n-    return Status::OK();\n-  }\n-\n-  template <typename T>\n-  typename std::enable_if<std::is_base_of<PrimitiveArray, T>::value, Status>::type Visit(\n-      const T& left) {\n-    return CompareValues<T>(left);\n-  }\n+  Status Visit(const FixedSizeListType& type) {\n+    const auto list_size = type.list_size();\n+    const ArrayData& left_data = *left_.child_data[0];\n+    const ArrayData& right_data = *right_.child_data[0];\n \n-  Status Visit(const ListArray& left) {\n-    result_ = CompareLists(left);\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      RangeDataEqualsImpl impl(options_, floating_approximate_, left_data, right_data,\n+                               (left_start_idx_ + left_.offset + i) * list_size,\n+                               (right_start_idx_ + right_.offset + i) * list_size,\n+                               length * list_size);\n+      return impl.Compare();\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const LargeListArray& left) {\n-    result_ = CompareLists(left);\n-    return Status::OK();\n-  }\n+  Status Visit(const StructType& type) {\n+    const int32_t num_fields = type.num_fields();\n \n-  Status Visit(const FixedSizeListArray& left) {\n-    const auto& right = checked_cast<const FixedSizeListArray&>(right_);\n-    result_ = left.values()->RangeEquals(\n-        left.value_offset(left_start_idx_), left.value_offset(left_end_idx_),\n-        right.value_offset(right_start_idx_), right.values());\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      for (int32_t f = 0; f < num_fields; ++f) {\n+        RangeDataEqualsImpl impl(options_, floating_approximate_, *left_.child_data[f],\n+                                 *right_.child_data[f],\n+                                 left_start_idx_ + left_.offset + i,\n+                                 right_start_idx_ + right_.offset + i, length);\n+        if (!impl.Compare()) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const MapArray& left) {\n-    result_ = CompareMaps(left);\n-    return Status::OK();\n-  }\n+  Status Visit(const SparseUnionType& type) {\n+    const auto& child_ids = type.child_ids();\n+    const int8_t* left_codes = left_.GetValues<int8_t>(1);\n+    const int8_t* right_codes = right_.GetValues<int8_t>(1);\n \n-  Status Visit(const StructArray& left) {\n-    result_ = CompareStructs(left);\n+    VisitValidRuns([&](int64_t i, int64_t length) {\n+      for (int64_t j = i; j < i + length; ++j) {\n+        const auto type_id = left_codes[left_start_idx_ + j];\n+        if (type_id != right_codes[right_start_idx_ + j]) {\n+          return false;\n+        }\n+        const auto child_num = child_ids[type_id];\n+        // XXX can we instead detect runs of same-child union values?\n+        RangeDataEqualsImpl impl(\n+            options_, floating_approximate_, *left_.child_data[child_num],\n+            *right_.child_data[child_num], left_start_idx_ + left_.offset + j,\n+            right_start_idx_ + right_.offset + j, 1);\n+        if (!impl.Compare()) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    });\n     return Status::OK();\n   }\n \n-  Status Visit(const UnionArray& left) {\n-    result_ = CompareUnions(left);\n+  Status Visit(const DenseUnionType& type) {\n+    const auto& child_ids = type.child_ids();\n+    const int8_t* left_codes = left_.GetValues<int8_t>(1);\n+    const int8_t* right_codes = right_.GetValues<int8_t>(1);\n+    const int32_t* left_offsets = left_.GetValues<int32_t>(2);\n+    const int32_t* right_offsets = right_.GetValues<int32_t>(2);\n+\n+    VisitValidRuns([&](int64_t i, int64_t length) {\n+      for (int64_t j = i; j < i + length; ++j) {\n+        const auto type_id = left_codes[left_start_idx_ + j];\n+        if (type_id != right_codes[right_start_idx_ + j]) {\n+          return false;\n+        }\n+        const auto child_num = child_ids[type_id];\n+        RangeDataEqualsImpl impl(\n+            options_, floating_approximate_, *left_.child_data[child_num],\n+            *right_.child_data[child_num], left_offsets[left_start_idx_ + j],\n+            right_offsets[right_start_idx_ + j], 1);\n+        if (!impl.Compare()) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    });\n     return Status::OK();\n   }\n \n-  Status Visit(const DictionaryArray& left) {\n-    const auto& right = checked_cast<const DictionaryArray&>(right_);\n-    if (!left.dictionary()->Equals(right.dictionary())) {\n-      result_ = false;\n-      return Status::OK();\n+  Status Visit(const DictionaryType& type) {\n+    // Compare dictionaries\n+    result_ &= CompareArrayRanges(\n+        *left_.dictionary, *right_.dictionary,\n+        /*left_start_idx=*/0,\n+        /*left_end_idx=*/std::max(left_.dictionary->length, right_.dictionary->length),\n+        /*right_start_idx=*/0, options_, floating_approximate_);\n+    if (result_) {\n+      // Compare indices\n+      result_ &= CompareWithType(*type.index_type());\n     }\n-    result_ = left.indices()->RangeEquals(left_start_idx_, left_end_idx_,\n-                                          right_start_idx_, right.indices());\n     return Status::OK();\n   }\n \n-  Status Visit(const ExtensionArray& left) {\n-    result_ = (right_.type()->Equals(*left.type()) &&\n-               ArrayRangeEquals(*left.storage(),\n-                                *static_cast<const ExtensionArray&>(right_).storage(),\n-                                left_start_idx_, left_end_idx_, right_start_idx_));\n+  Status Visit(const ExtensionType& type) {\n+    // Compare storages\n+    result_ &= CompareWithType(*type.storage_type());\n     return Status::OK();\n   }\n \n-  bool result() const { return result_; }\n-\n  protected:\n-  const Array& right_;\n-  int64_t left_start_idx_;\n-  int64_t left_end_idx_;\n-  int64_t right_start_idx_;\n-\n-  bool result_;\n-};\n-\n-static bool IsEqualPrimitive(const PrimitiveArray& left, const PrimitiveArray& right) {\n-  const int byte_width = internal::GetByteWidth(*left.type());\n-\n-  const uint8_t* left_data = nullptr;\n-  const uint8_t* right_data = nullptr;\n-\n-  if (left.values()) {\n-    left_data = left.values()->data() + left.offset() * byte_width;\n+  template <typename TypeClass, typename CType = typename TypeClass::c_type>\n+  Status ComparePrimitive(const TypeClass&) {\n+    const CType* left_values = left_.GetValues<CType>(1);\n+    const CType* right_values = right_.GetValues<CType>(1);\n+    VisitValidRuns([&](int64_t i, int64_t length) {\n+      return memcmp(left_values + left_start_idx_ + i,\n+                    right_values + right_start_idx_ + i, length * sizeof(CType)) == 0;\n+    });\n+    return Status::OK();\n   }\n \n-  if (right.values()) {\n-    right_data = right.values()->data() + right.offset() * byte_width;\n-  }\n+  template <typename TypeClass>\n+  Status CompareFloating(const TypeClass&) {\n+    using T = typename TypeClass::c_type;\n+    const T* left_values = left_.GetValues<T>(1);\n+    const T* right_values = right_.GetValues<T>(1);\n \n-  if (byte_width == 0) {\n-    // Special case 0-width data, as the data pointers may be null\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (left.IsNull(i) != right.IsNull(i)) {\n-        return false;\n-      }\n-    }\n-    return true;\n-  } else if (left.null_count() > 0) {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      const bool left_null = left.IsNull(i);\n-      const bool right_null = right.IsNull(i);\n-      if (left_null != right_null) {\n-        return false;\n+    if (floating_approximate_) {\n+      const T epsilon = static_cast<T>(options_.atol());\n+      if (options_.nans_equal()) {\n+        VisitValues([&](int64_t i) {\n+          const T x = left_values[i + left_start_idx_];\n+          const T y = right_values[i + right_start_idx_];\n+          return (fabs(x - y) <= epsilon) || (x == y) || (std::isnan(x) && std::isnan(y));\n+        });\n+      } else {\n+        VisitValues([&](int64_t i) {\n+          const T x = left_values[i + left_start_idx_];\n+          const T y = right_values[i + right_start_idx_];\n+          return (fabs(x - y) <= epsilon) || (x == y);\n+        });\n       }\n-      if (!left_null && memcmp(left_data, right_data, byte_width) != 0) {\n-        return false;\n+    } else {\n+      if (options_.nans_equal()) {\n+        VisitValues([&](int64_t i) {\n+          const T x = left_values[i + left_start_idx_];\n+          const T y = right_values[i + right_start_idx_];\n+          return (x == y) || (std::isnan(x) && std::isnan(y));\n+        });\n+      } else {\n+        VisitValues([&](int64_t i) {\n+          const T x = left_values[i + left_start_idx_];\n+          const T y = right_values[i + right_start_idx_];\n+          return x == y;\n+        });\n       }\n-      left_data += byte_width;\n-      right_data += byte_width;\n     }\n-    return true;\n-  } else {\n-    auto number_of_bytes_to_compare = static_cast<size_t>(byte_width * left.length());\n-    return memcmp(left_data, right_data, number_of_bytes_to_compare) == 0;\n-  }\n-}\n-\n-// A bit confusing: ArrayEqualsVisitor inherits from RangeEqualsVisitor but\n-// doesn't share the same preconditions.\n-// When RangeEqualsVisitor is called, we only know the range sizes equal.\n-// When ArrayEqualsVisitor is called, we know the sizes and null bitmaps are equal.\n-\n-class ArrayEqualsVisitor : public RangeEqualsVisitor {\n- public:\n-  explicit ArrayEqualsVisitor(const Array& right, const EqualOptions& opts)\n-      : RangeEqualsVisitor(right, 0, right.length(), 0), opts_(opts) {}\n-\n-  Status Visit(const NullArray& left) {\n-    ARROW_UNUSED(left);\n-    result_ = true;\n     return Status::OK();\n   }\n \n-  Status Visit(const BooleanArray& left) {\n-    const auto& right = checked_cast<const BooleanArray&>(right_);\n+  template <typename TypeClass>\n+  Status CompareBinary(const TypeClass&) {\n+    const uint8_t* left_data = left_.GetValues<uint8_t>(2, 0);\n+    const uint8_t* right_data = right_.GetValues<uint8_t>(2, 0);\n \n-    if (left.null_count() > 0) {\n-      const uint8_t* left_data = left.values()->data();\n-      const uint8_t* right_data = right.values()->data();\n-\n-      for (int64_t i = 0; i < left.length(); ++i) {\n-        if (left.IsValid(i) && BitUtil::GetBit(left_data, i + left.offset()) !=\n-                                   BitUtil::GetBit(right_data, i + right.offset())) {\n-          result_ = false;\n-          return Status::OK();\n-        }\n-      }\n-      result_ = true;\n+    if (left_data != nullptr && right_data != nullptr) {\n+      const auto compare_ranges = [&](int64_t left_offset, int64_t right_offset,\n+                                      int64_t length) -> bool {\n+        return memcmp(left_data + left_offset, right_data + right_offset, length) == 0;\n+      };\n+      CompareWithOffsets<typename TypeClass::offset_type>(1, compare_ranges);\n     } else {\n-      result_ = BitmapEquals(left.values()->data(), left.offset(), right.values()->data(),\n-                             right.offset(), left.length());\n+      // One of the arrays is an array of empty strings and nulls.\n+      // We just need to compare the offsets.\n+      // (note we must not call memcmp() with null data pointers)\n+      const auto compare_ranges = [&](int64_t left_offset, int64_t right_offset,\n+                                      int64_t length) -> bool { return true; };\n+      CompareWithOffsets<typename TypeClass::offset_type>(1, compare_ranges);\n\nReview comment:\n       Does this work in C++11? :-o\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-21T15:56:08.304+0000",
                    "updated": "2020-11-21T15:56:08.304+0000",
                    "started": "2020-11-21T15:56:08.304+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515090",
                    "issueId": "13330181"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330181/worklog/515091",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8703:\nURL: https://github.com/apache/arrow/pull/8703#discussion_r528210778\n\n\n\n##########\nFile path: cpp/src/arrow/compare.cc\n##########\n@@ -49,700 +51,441 @@\n namespace arrow {\n \n using internal::BitmapEquals;\n+using internal::BitmapReader;\n+using internal::BitmapUInt64Reader;\n using internal::checked_cast;\n+using internal::OptionalBitBlockCounter;\n+using internal::OptionalBitmapEquals;\n \n // ----------------------------------------------------------------------\n // Public method implementations\n \n namespace {\n \n-// These helper functions assume we already checked the arrays have equal\n-// sizes and null bitmaps.\n+bool CompareArrayRanges(const ArrayData& left, const ArrayData& right,\n+                        int64_t left_start_idx, int64_t left_end_idx,\n+                        int64_t right_start_idx, const EqualOptions& options,\n+                        bool floating_approximate);\n \n-template <typename ArrowType, typename EqualityFunc>\n-inline bool BaseFloatingEquals(const NumericArray<ArrowType>& left,\n-                               const NumericArray<ArrowType>& right,\n-                               EqualityFunc&& equals) {\n-  using T = typename ArrowType::c_type;\n-\n-  const T* left_data = left.raw_values();\n-  const T* right_data = right.raw_values();\n-\n-  if (left.null_count() > 0) {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (left.IsNull(i)) continue;\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  } else {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingEquals(const NumericArray<ArrowType>& left,\n-                           const NumericArray<ArrowType>& right,\n-                           const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [](T x, T y) -> bool {\n-      return (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right,\n-                                         [](T x, T y) -> bool { return x == y; });\n-  }\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingApproxEquals(const NumericArray<ArrowType>& left,\n-                                 const NumericArray<ArrowType>& right,\n-                                 const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-  const T epsilon = static_cast<T>(opts.atol());\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y);\n-    });\n-  }\n-}\n-\n-// RangeEqualsVisitor assumes the range sizes are equal\n-\n-class RangeEqualsVisitor {\n+class RangeDataEqualsImpl {\n  public:\n-  RangeEqualsVisitor(const Array& right, int64_t left_start_idx, int64_t left_end_idx,\n-                     int64_t right_start_idx)\n-      : right_(right),\n+  // PRE-CONDITIONS:\n+  // - the types are equal\n+  // - the ranges are in bounds\n+  RangeDataEqualsImpl(const EqualOptions& options, bool floating_approximate,\n+                      const ArrayData& left, const ArrayData& right,\n+                      int64_t left_start_idx, int64_t right_start_idx,\n+                      int64_t range_length)\n+      : options_(options),\n+        floating_approximate_(floating_approximate),\n+        left_(left),\n+        right_(right),\n         left_start_idx_(left_start_idx),\n-        left_end_idx_(left_end_idx),\n         right_start_idx_(right_start_idx),\n+        range_length_(range_length),\n         result_(false) {}\n \n-  template <typename ArrayType>\n-  inline Status CompareValues(const ArrayType& left) {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i) ||\n-          (!is_null && left.Value(i) != right.Value(o_i))) {\n-        result_ = false;\n-        return Status::OK();\n+  bool Compare() {\n+    // Compare null bitmaps\n+    if (left_start_idx_ == 0 && right_start_idx_ == 0 && range_length_ == left_.length &&\n+        range_length_ == right_.length) {\n+      // If we're comparing entire arrays, we can first compare the cached null counts\n+      if (left_.GetNullCount() != right_.GetNullCount()) {\n+        return false;\n       }\n     }\n\nReview comment:\n       It's ok to compute the null count, IMHO, the computed value is often re-used for other tasks.\r\n   The reason why this heuristic only works for non-ranged arrays is that you could have two whole arrays with different null counts, but the compared ranges would still be equal.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-21T15:57:11.356+0000",
                    "updated": "2020-11-21T15:57:11.356+0000",
                    "started": "2020-11-21T15:57:11.356+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515091",
                    "issueId": "13330181"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330181/worklog/515093",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8703:\nURL: https://github.com/apache/arrow/pull/8703#discussion_r528212877\n\n\n\n##########\nFile path: cpp/src/arrow/compare.cc\n##########\n@@ -49,700 +51,441 @@\n namespace arrow {\n \n using internal::BitmapEquals;\n+using internal::BitmapReader;\n+using internal::BitmapUInt64Reader;\n using internal::checked_cast;\n+using internal::OptionalBitBlockCounter;\n+using internal::OptionalBitmapEquals;\n \n // ----------------------------------------------------------------------\n // Public method implementations\n \n namespace {\n \n-// These helper functions assume we already checked the arrays have equal\n-// sizes and null bitmaps.\n+bool CompareArrayRanges(const ArrayData& left, const ArrayData& right,\n+                        int64_t left_start_idx, int64_t left_end_idx,\n+                        int64_t right_start_idx, const EqualOptions& options,\n+                        bool floating_approximate);\n \n-template <typename ArrowType, typename EqualityFunc>\n-inline bool BaseFloatingEquals(const NumericArray<ArrowType>& left,\n-                               const NumericArray<ArrowType>& right,\n-                               EqualityFunc&& equals) {\n-  using T = typename ArrowType::c_type;\n-\n-  const T* left_data = left.raw_values();\n-  const T* right_data = right.raw_values();\n-\n-  if (left.null_count() > 0) {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (left.IsNull(i)) continue;\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  } else {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingEquals(const NumericArray<ArrowType>& left,\n-                           const NumericArray<ArrowType>& right,\n-                           const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [](T x, T y) -> bool {\n-      return (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right,\n-                                         [](T x, T y) -> bool { return x == y; });\n-  }\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingApproxEquals(const NumericArray<ArrowType>& left,\n-                                 const NumericArray<ArrowType>& right,\n-                                 const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-  const T epsilon = static_cast<T>(opts.atol());\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y);\n-    });\n-  }\n-}\n-\n-// RangeEqualsVisitor assumes the range sizes are equal\n-\n-class RangeEqualsVisitor {\n+class RangeDataEqualsImpl {\n  public:\n-  RangeEqualsVisitor(const Array& right, int64_t left_start_idx, int64_t left_end_idx,\n-                     int64_t right_start_idx)\n-      : right_(right),\n+  // PRE-CONDITIONS:\n+  // - the types are equal\n+  // - the ranges are in bounds\n+  RangeDataEqualsImpl(const EqualOptions& options, bool floating_approximate,\n+                      const ArrayData& left, const ArrayData& right,\n+                      int64_t left_start_idx, int64_t right_start_idx,\n+                      int64_t range_length)\n+      : options_(options),\n+        floating_approximate_(floating_approximate),\n+        left_(left),\n+        right_(right),\n         left_start_idx_(left_start_idx),\n-        left_end_idx_(left_end_idx),\n         right_start_idx_(right_start_idx),\n+        range_length_(range_length),\n         result_(false) {}\n \n-  template <typename ArrayType>\n-  inline Status CompareValues(const ArrayType& left) {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i) ||\n-          (!is_null && left.Value(i) != right.Value(o_i))) {\n-        result_ = false;\n-        return Status::OK();\n+  bool Compare() {\n+    // Compare null bitmaps\n+    if (left_start_idx_ == 0 && right_start_idx_ == 0 && range_length_ == left_.length &&\n+        range_length_ == right_.length) {\n+      // If we're comparing entire arrays, we can first compare the cached null counts\n+      if (left_.GetNullCount() != right_.GetNullCount()) {\n+        return false;\n       }\n     }\n-    result_ = true;\n-    return Status::OK();\n+    if (!OptionalBitmapEquals(left_.buffers[0], left_.offset + left_start_idx_,\n+                              right_.buffers[0], right_.offset + right_start_idx_,\n+                              range_length_)) {\n+      return false;\n+    }\n+    // Compare values\n+    return CompareWithType(*left_.type);\n   }\n \n-  template <typename ArrayType, typename CompareValuesFunc>\n-  bool CompareWithOffsets(const ArrayType& left,\n-                          CompareValuesFunc&& compare_values) const {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (is_null) continue;\n-      const auto begin_offset = left.value_offset(i);\n-      const auto end_offset = left.value_offset(i + 1);\n-      const auto right_begin_offset = right.value_offset(o_i);\n-      const auto right_end_offset = right.value_offset(o_i + 1);\n-      // Underlying can't be equal if the size isn't equal\n-      if (end_offset - begin_offset != right_end_offset - right_begin_offset) {\n-        return false;\n-      }\n-\n-      if (!compare_values(left, right, begin_offset, right_begin_offset,\n-                          end_offset - begin_offset)) {\n-        return false;\n-      }\n+  bool CompareWithType(const DataType& type) {\n+    result_ = true;\n+    if (range_length_ != 0) {\n+      ARROW_CHECK_OK(VisitTypeInline(type, this));\n     }\n-    return true;\n+    return result_;\n   }\n \n-  template <typename BinaryArrayType>\n-  bool CompareBinaryRange(const BinaryArrayType& left) const {\n-    using offset_type = typename BinaryArrayType::offset_type;\n+  Status Visit(const NullType&) { return Status::OK(); }\n \n-    auto compare_values = [](const BinaryArrayType& left, const BinaryArrayType& right,\n-                             offset_type left_offset, offset_type right_offset,\n-                             offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return std::memcmp(left.value_data()->data() + left_offset,\n-                         right.value_data()->data() + right_offset,\n-                         static_cast<size_t>(nvalues)) == 0;\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_primitive_ctype<TypeClass, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  template <typename ListArrayType>\n-  bool CompareLists(const ListArrayType& left) {\n-    using offset_type = typename ListArrayType::offset_type;\n-    const auto& right = checked_cast<const ListArrayType&>(right_);\n-    const std::shared_ptr<Array>& left_values = left.values();\n-    const std::shared_ptr<Array>& right_values = right.values();\n-\n-    auto compare_values = [&](const ListArrayType& left, const ListArrayType& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_values->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                      right_values);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n-  }\n-\n-  bool CompareMaps(const MapArray& left) {\n-    // We need a specific comparison helper for maps to avoid comparing\n-    // struct field names (which are indifferent for maps)\n-    using offset_type = typename MapArray::offset_type;\n-    const auto& right = checked_cast<const MapArray&>(right_);\n-    const auto left_keys = left.keys();\n-    const auto left_items = left.items();\n-    const auto right_keys = right.keys();\n-    const auto right_items = right.items();\n-\n-    auto compare_values = [&](const MapArray& left, const MapArray& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_keys->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                    right_keys) &&\n-             left_items->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                     right_items);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_t<is_temporal_type<TypeClass>::value, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  bool CompareStructs(const StructArray& left) {\n-    const auto& right = checked_cast<const StructArray&>(right_);\n-    bool equal_fields = true;\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      for (int j = 0; j < left.num_fields(); ++j) {\n-        // TODO: really we should be comparing stretches of non-null data rather\n-        // than looking at one value at a time.\n-        equal_fields = left.field(j)->RangeEquals(i, i + 1, o_i, right.field(j));\n-        if (!equal_fields) {\n-          return false;\n-        }\n-      }\n-    }\n-    return true;\n-  }\n-\n-  bool CompareUnions(const UnionArray& left) const {\n-    const auto& right = checked_cast<const UnionArray&>(right_);\n-\n-    const UnionMode::type union_mode = left.mode();\n-    if (union_mode != right.mode()) {\n-      return false;\n-    }\n-\n-    const auto& left_type = checked_cast<const UnionType&>(*left.type());\n-\n-    const std::vector<int>& child_ids = left_type.child_ids();\n-\n-    const int8_t* left_codes = left.raw_type_codes();\n-    const int8_t* right_codes = right.raw_type_codes();\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      if (left_codes[i] != right_codes[o_i]) {\n-        return false;\n-      }\n-\n-      auto child_num = child_ids[left_codes[i]];\n-\n-      // TODO(wesm): really we should be comparing stretches of non-null data\n-      // rather than looking at one value at a time.\n-      if (union_mode == UnionMode::SPARSE) {\n-        if (!left.field(child_num)->RangeEquals(i, i + 1, o_i, right.field(child_num))) {\n-          return false;\n+  Status Visit(const BooleanType&) {\n+    const uint8_t* left_bits = left_.GetValues<uint8_t>(1, 0);\n+    const uint8_t* right_bits = right_.GetValues<uint8_t>(1, 0);\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      if (length <= 8) {\n+        // Avoid the BitmapUInt64Reader overhead for very small runs\n+        for (int64_t j = i; j < i + length; ++j) {\n+          if (BitUtil::GetBit(left_bits, left_start_idx_ + left_.offset + j) !=\n+              BitUtil::GetBit(right_bits, right_start_idx_ + right_.offset + j)) {\n+            return false;\n+          }\n         }\n+        return true;\n       } else {\n-        const int32_t offset =\n-            checked_cast<const DenseUnionArray&>(left).raw_value_offsets()[i];\n-        const int32_t o_offset =\n-            checked_cast<const DenseUnionArray&>(right).raw_value_offsets()[o_i];\n-        if (!left.field(child_num)->RangeEquals(offset, offset + 1, o_offset,\n-                                                right.field(child_num))) {\n-          return false;\n+        BitmapUInt64Reader left_reader(left_bits, left_start_idx_ + left_.offset + i,\n+                                       length);\n+        BitmapUInt64Reader right_reader(right_bits, right_start_idx_ + right_.offset + i,\n+                                        length);\n+        while (left_reader.position() < length) {\n+          if (left_reader.NextWord() != right_reader.NextWord()) {\n+            return false;\n+          }\n         }\n+        DCHECK_EQ(right_reader.position(), length);\n       }\n-    }\n-    return true;\n-  }\n-\n-  Status Visit(const BinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n-    return Status::OK();\n-  }\n-\n-  Status Visit(const LargeBinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n+      return true;\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const FixedSizeBinaryArray& left) {\n-    const auto& right = checked_cast<const FixedSizeBinaryArray&>(right_);\n+  Status Visit(const FloatType& type) { return CompareFloating(type); }\n \n-    int32_t width = left.byte_width();\n+  Status Visit(const DoubleType& type) { return CompareFloating(type); }\n \n-    const uint8_t* left_data = nullptr;\n-    const uint8_t* right_data = nullptr;\n+  // Also matches StringType\n+  Status Visit(const BinaryType& type) { return CompareBinary(type); }\n \n-    if (left.values()) {\n-      left_data = left.raw_values();\n-    }\n+  // Also matches LargeStringType\n+  Status Visit(const LargeBinaryType& type) { return CompareBinary(type); }\n \n-    if (right.values()) {\n-      right_data = right.raw_values();\n-    }\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i)) {\n-        result_ = false;\n-        return Status::OK();\n-      }\n-      if (is_null) continue;\n+  Status Visit(const FixedSizeBinaryType& type) {\n+    const auto byte_width = type.byte_width();\n+    const uint8_t* left_data = left_.GetValues<uint8_t>(1, 0);\n+    const uint8_t* right_data = right_.GetValues<uint8_t>(1, 0);\n \n-      if (std::memcmp(left_data + width * i, right_data + width * o_i, width)) {\n-        result_ = false;\n-        return Status::OK();\n-      }\n+    if (left_data != nullptr && right_data != nullptr) {\n+      auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+        return memcmp(left_data + (left_start_idx_ + left_.offset + i) * byte_width,\n+                      right_data + (right_start_idx_ + right_.offset + i) * byte_width,\n+                      length * byte_width) == 0;\n+      };\n+      VisitValidRuns(compare_runs);\n+    } else {\n+      auto compare_runs = [&](int64_t i, int64_t length) -> bool { return true; };\n+      VisitValidRuns(compare_runs);\n     }\n-    result_ = true;\n     return Status::OK();\n   }\n \n-  Status Visit(const Decimal128Array& left) {\n-    return Visit(checked_cast<const FixedSizeBinaryArray&>(left));\n-  }\n+  // Also matches MapType\n+  Status Visit(const ListType& type) { return CompareList(type); }\n \n-  Status Visit(const Decimal256Array& left) {\n-    return Visit(checked_cast<const FixedSizeBinaryArray&>(left));\n-  }\n+  Status Visit(const LargeListType& type) { return CompareList(type); }\n \n-  Status Visit(const NullArray& left) {\n-    ARROW_UNUSED(left);\n-    result_ = true;\n-    return Status::OK();\n-  }\n-\n-  template <typename T>\n-  typename std::enable_if<std::is_base_of<PrimitiveArray, T>::value, Status>::type Visit(\n-      const T& left) {\n-    return CompareValues<T>(left);\n-  }\n+  Status Visit(const FixedSizeListType& type) {\n+    const auto list_size = type.list_size();\n+    const ArrayData& left_data = *left_.child_data[0];\n+    const ArrayData& right_data = *right_.child_data[0];\n \n-  Status Visit(const ListArray& left) {\n-    result_ = CompareLists(left);\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      RangeDataEqualsImpl impl(options_, floating_approximate_, left_data, right_data,\n+                               (left_start_idx_ + left_.offset + i) * list_size,\n+                               (right_start_idx_ + right_.offset + i) * list_size,\n+                               length * list_size);\n+      return impl.Compare();\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const LargeListArray& left) {\n-    result_ = CompareLists(left);\n-    return Status::OK();\n-  }\n+  Status Visit(const StructType& type) {\n+    const int32_t num_fields = type.num_fields();\n \n-  Status Visit(const FixedSizeListArray& left) {\n-    const auto& right = checked_cast<const FixedSizeListArray&>(right_);\n-    result_ = left.values()->RangeEquals(\n-        left.value_offset(left_start_idx_), left.value_offset(left_end_idx_),\n-        right.value_offset(right_start_idx_), right.values());\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      for (int32_t f = 0; f < num_fields; ++f) {\n+        RangeDataEqualsImpl impl(options_, floating_approximate_, *left_.child_data[f],\n+                                 *right_.child_data[f],\n+                                 left_start_idx_ + left_.offset + i,\n+                                 right_start_idx_ + right_.offset + i, length);\n+        if (!impl.Compare()) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const MapArray& left) {\n-    result_ = CompareMaps(left);\n-    return Status::OK();\n-  }\n+  Status Visit(const SparseUnionType& type) {\n+    const auto& child_ids = type.child_ids();\n+    const int8_t* left_codes = left_.GetValues<int8_t>(1);\n+    const int8_t* right_codes = right_.GetValues<int8_t>(1);\n \n-  Status Visit(const StructArray& left) {\n-    result_ = CompareStructs(left);\n+    VisitValidRuns([&](int64_t i, int64_t length) {\n+      for (int64_t j = i; j < i + length; ++j) {\n+        const auto type_id = left_codes[left_start_idx_ + j];\n+        if (type_id != right_codes[right_start_idx_ + j]) {\n+          return false;\n+        }\n+        const auto child_num = child_ids[type_id];\n+        // XXX can we instead detect runs of same-child union values?\n+        RangeDataEqualsImpl impl(\n+            options_, floating_approximate_, *left_.child_data[child_num],\n+            *right_.child_data[child_num], left_start_idx_ + left_.offset + j,\n+            right_start_idx_ + right_.offset + j, 1);\n+        if (!impl.Compare()) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    });\n     return Status::OK();\n   }\n \n-  Status Visit(const UnionArray& left) {\n-    result_ = CompareUnions(left);\n+  Status Visit(const DenseUnionType& type) {\n+    const auto& child_ids = type.child_ids();\n+    const int8_t* left_codes = left_.GetValues<int8_t>(1);\n+    const int8_t* right_codes = right_.GetValues<int8_t>(1);\n+    const int32_t* left_offsets = left_.GetValues<int32_t>(2);\n+    const int32_t* right_offsets = right_.GetValues<int32_t>(2);\n+\n+    VisitValidRuns([&](int64_t i, int64_t length) {\n+      for (int64_t j = i; j < i + length; ++j) {\n+        const auto type_id = left_codes[left_start_idx_ + j];\n+        if (type_id != right_codes[right_start_idx_ + j]) {\n+          return false;\n+        }\n+        const auto child_num = child_ids[type_id];\n+        RangeDataEqualsImpl impl(\n+            options_, floating_approximate_, *left_.child_data[child_num],\n+            *right_.child_data[child_num], left_offsets[left_start_idx_ + j],\n+            right_offsets[right_start_idx_ + j], 1);\n+        if (!impl.Compare()) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    });\n     return Status::OK();\n   }\n \n-  Status Visit(const DictionaryArray& left) {\n-    const auto& right = checked_cast<const DictionaryArray&>(right_);\n-    if (!left.dictionary()->Equals(right.dictionary())) {\n-      result_ = false;\n-      return Status::OK();\n+  Status Visit(const DictionaryType& type) {\n+    // Compare dictionaries\n+    result_ &= CompareArrayRanges(\n+        *left_.dictionary, *right_.dictionary,\n+        /*left_start_idx=*/0,\n+        /*left_end_idx=*/std::max(left_.dictionary->length, right_.dictionary->length),\n+        /*right_start_idx=*/0, options_, floating_approximate_);\n+    if (result_) {\n+      // Compare indices\n+      result_ &= CompareWithType(*type.index_type());\n     }\n-    result_ = left.indices()->RangeEquals(left_start_idx_, left_end_idx_,\n-                                          right_start_idx_, right.indices());\n     return Status::OK();\n   }\n \n-  Status Visit(const ExtensionArray& left) {\n-    result_ = (right_.type()->Equals(*left.type()) &&\n-               ArrayRangeEquals(*left.storage(),\n-                                *static_cast<const ExtensionArray&>(right_).storage(),\n-                                left_start_idx_, left_end_idx_, right_start_idx_));\n+  Status Visit(const ExtensionType& type) {\n+    // Compare storages\n+    result_ &= CompareWithType(*type.storage_type());\n     return Status::OK();\n   }\n \n-  bool result() const { return result_; }\n-\n  protected:\n-  const Array& right_;\n-  int64_t left_start_idx_;\n-  int64_t left_end_idx_;\n-  int64_t right_start_idx_;\n-\n-  bool result_;\n-};\n-\n-static bool IsEqualPrimitive(const PrimitiveArray& left, const PrimitiveArray& right) {\n-  const int byte_width = internal::GetByteWidth(*left.type());\n-\n-  const uint8_t* left_data = nullptr;\n-  const uint8_t* right_data = nullptr;\n-\n-  if (left.values()) {\n-    left_data = left.values()->data() + left.offset() * byte_width;\n+  template <typename TypeClass, typename CType = typename TypeClass::c_type>\n+  Status ComparePrimitive(const TypeClass&) {\n+    const CType* left_values = left_.GetValues<CType>(1);\n+    const CType* right_values = right_.GetValues<CType>(1);\n+    VisitValidRuns([&](int64_t i, int64_t length) {\n+      return memcmp(left_values + left_start_idx_ + i,\n+                    right_values + right_start_idx_ + i, length * sizeof(CType)) == 0;\n+    });\n+    return Status::OK();\n   }\n \n-  if (right.values()) {\n-    right_data = right.values()->data() + right.offset() * byte_width;\n-  }\n+  template <typename TypeClass>\n+  Status CompareFloating(const TypeClass&) {\n+    using T = typename TypeClass::c_type;\n+    const T* left_values = left_.GetValues<T>(1);\n+    const T* right_values = right_.GetValues<T>(1);\n \n-  if (byte_width == 0) {\n-    // Special case 0-width data, as the data pointers may be null\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (left.IsNull(i) != right.IsNull(i)) {\n-        return false;\n-      }\n-    }\n-    return true;\n-  } else if (left.null_count() > 0) {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      const bool left_null = left.IsNull(i);\n-      const bool right_null = right.IsNull(i);\n-      if (left_null != right_null) {\n-        return false;\n+    if (floating_approximate_) {\n+      const T epsilon = static_cast<T>(options_.atol());\n+      if (options_.nans_equal()) {\n+        VisitValues([&](int64_t i) {\n+          const T x = left_values[i + left_start_idx_];\n+          const T y = right_values[i + right_start_idx_];\n+          return (fabs(x - y) <= epsilon) || (x == y) || (std::isnan(x) && std::isnan(y));\n+        });\n+      } else {\n+        VisitValues([&](int64_t i) {\n+          const T x = left_values[i + left_start_idx_];\n+          const T y = right_values[i + right_start_idx_];\n+          return (fabs(x - y) <= epsilon) || (x == y);\n+        });\n       }\n-      if (!left_null && memcmp(left_data, right_data, byte_width) != 0) {\n-        return false;\n+    } else {\n+      if (options_.nans_equal()) {\n+        VisitValues([&](int64_t i) {\n+          const T x = left_values[i + left_start_idx_];\n+          const T y = right_values[i + right_start_idx_];\n+          return (x == y) || (std::isnan(x) && std::isnan(y));\n+        });\n+      } else {\n+        VisitValues([&](int64_t i) {\n+          const T x = left_values[i + left_start_idx_];\n+          const T y = right_values[i + right_start_idx_];\n+          return x == y;\n+        });\n       }\n-      left_data += byte_width;\n-      right_data += byte_width;\n     }\n-    return true;\n-  } else {\n-    auto number_of_bytes_to_compare = static_cast<size_t>(byte_width * left.length());\n-    return memcmp(left_data, right_data, number_of_bytes_to_compare) == 0;\n-  }\n-}\n-\n-// A bit confusing: ArrayEqualsVisitor inherits from RangeEqualsVisitor but\n-// doesn't share the same preconditions.\n-// When RangeEqualsVisitor is called, we only know the range sizes equal.\n-// When ArrayEqualsVisitor is called, we know the sizes and null bitmaps are equal.\n-\n-class ArrayEqualsVisitor : public RangeEqualsVisitor {\n- public:\n-  explicit ArrayEqualsVisitor(const Array& right, const EqualOptions& opts)\n-      : RangeEqualsVisitor(right, 0, right.length(), 0), opts_(opts) {}\n-\n-  Status Visit(const NullArray& left) {\n-    ARROW_UNUSED(left);\n-    result_ = true;\n     return Status::OK();\n   }\n \n-  Status Visit(const BooleanArray& left) {\n-    const auto& right = checked_cast<const BooleanArray&>(right_);\n+  template <typename TypeClass>\n+  Status CompareBinary(const TypeClass&) {\n+    const uint8_t* left_data = left_.GetValues<uint8_t>(2, 0);\n+    const uint8_t* right_data = right_.GetValues<uint8_t>(2, 0);\n \n-    if (left.null_count() > 0) {\n-      const uint8_t* left_data = left.values()->data();\n-      const uint8_t* right_data = right.values()->data();\n-\n-      for (int64_t i = 0; i < left.length(); ++i) {\n-        if (left.IsValid(i) && BitUtil::GetBit(left_data, i + left.offset()) !=\n-                                   BitUtil::GetBit(right_data, i + right.offset())) {\n-          result_ = false;\n-          return Status::OK();\n-        }\n-      }\n-      result_ = true;\n+    if (left_data != nullptr && right_data != nullptr) {\n+      const auto compare_ranges = [&](int64_t left_offset, int64_t right_offset,\n+                                      int64_t length) -> bool {\n+        return memcmp(left_data + left_offset, right_data + right_offset, length) == 0;\n+      };\n+      CompareWithOffsets<typename TypeClass::offset_type>(1, compare_ranges);\n     } else {\n-      result_ = BitmapEquals(left.values()->data(), left.offset(), right.values()->data(),\n-                             right.offset(), left.length());\n+      // One of the arrays is an array of empty strings and nulls.\n+      // We just need to compare the offsets.\n+      // (note we must not call memcmp() with null data pointers)\n+      const auto compare_ranges = [&](int64_t left_offset, int64_t right_offset,\n+                                      int64_t length) -> bool { return true; };\n+      CompareWithOffsets<typename TypeClass::offset_type>(1, compare_ranges);\n\nReview comment:\n       Yes, `...` can be used to ignore any trivially constructible argument(s).\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-21T16:11:59.156+0000",
                    "updated": "2020-11-21T16:11:59.156+0000",
                    "started": "2020-11-21T16:11:59.156+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515093",
                    "issueId": "13330181"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330181/worklog/515094",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8703:\nURL: https://github.com/apache/arrow/pull/8703#discussion_r528213541\n\n\n\n##########\nFile path: cpp/src/arrow/compare.cc\n##########\n@@ -49,700 +51,441 @@\n namespace arrow {\n \n using internal::BitmapEquals;\n+using internal::BitmapReader;\n+using internal::BitmapUInt64Reader;\n using internal::checked_cast;\n+using internal::OptionalBitBlockCounter;\n+using internal::OptionalBitmapEquals;\n \n // ----------------------------------------------------------------------\n // Public method implementations\n \n namespace {\n \n-// These helper functions assume we already checked the arrays have equal\n-// sizes and null bitmaps.\n+bool CompareArrayRanges(const ArrayData& left, const ArrayData& right,\n+                        int64_t left_start_idx, int64_t left_end_idx,\n+                        int64_t right_start_idx, const EqualOptions& options,\n+                        bool floating_approximate);\n \n-template <typename ArrowType, typename EqualityFunc>\n-inline bool BaseFloatingEquals(const NumericArray<ArrowType>& left,\n-                               const NumericArray<ArrowType>& right,\n-                               EqualityFunc&& equals) {\n-  using T = typename ArrowType::c_type;\n-\n-  const T* left_data = left.raw_values();\n-  const T* right_data = right.raw_values();\n-\n-  if (left.null_count() > 0) {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (left.IsNull(i)) continue;\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  } else {\n-    for (int64_t i = 0; i < left.length(); ++i) {\n-      if (!equals(left_data[i], right_data[i])) {\n-        return false;\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingEquals(const NumericArray<ArrowType>& left,\n-                           const NumericArray<ArrowType>& right,\n-                           const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [](T x, T y) -> bool {\n-      return (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right,\n-                                         [](T x, T y) -> bool { return x == y; });\n-  }\n-}\n-\n-template <typename ArrowType>\n-inline bool FloatingApproxEquals(const NumericArray<ArrowType>& left,\n-                                 const NumericArray<ArrowType>& right,\n-                                 const EqualOptions& opts) {\n-  using T = typename ArrowType::c_type;\n-  const T epsilon = static_cast<T>(opts.atol());\n-\n-  if (opts.nans_equal()) {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y) || (std::isnan(x) && std::isnan(y));\n-    });\n-  } else {\n-    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n-      return (fabs(x - y) <= epsilon) || (x == y);\n-    });\n-  }\n-}\n-\n-// RangeEqualsVisitor assumes the range sizes are equal\n-\n-class RangeEqualsVisitor {\n+class RangeDataEqualsImpl {\n  public:\n-  RangeEqualsVisitor(const Array& right, int64_t left_start_idx, int64_t left_end_idx,\n-                     int64_t right_start_idx)\n-      : right_(right),\n+  // PRE-CONDITIONS:\n+  // - the types are equal\n+  // - the ranges are in bounds\n+  RangeDataEqualsImpl(const EqualOptions& options, bool floating_approximate,\n+                      const ArrayData& left, const ArrayData& right,\n+                      int64_t left_start_idx, int64_t right_start_idx,\n+                      int64_t range_length)\n+      : options_(options),\n+        floating_approximate_(floating_approximate),\n+        left_(left),\n+        right_(right),\n         left_start_idx_(left_start_idx),\n-        left_end_idx_(left_end_idx),\n         right_start_idx_(right_start_idx),\n+        range_length_(range_length),\n         result_(false) {}\n \n-  template <typename ArrayType>\n-  inline Status CompareValues(const ArrayType& left) {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i) ||\n-          (!is_null && left.Value(i) != right.Value(o_i))) {\n-        result_ = false;\n-        return Status::OK();\n+  bool Compare() {\n+    // Compare null bitmaps\n+    if (left_start_idx_ == 0 && right_start_idx_ == 0 && range_length_ == left_.length &&\n+        range_length_ == right_.length) {\n+      // If we're comparing entire arrays, we can first compare the cached null counts\n+      if (left_.GetNullCount() != right_.GetNullCount()) {\n+        return false;\n       }\n     }\n-    result_ = true;\n-    return Status::OK();\n+    if (!OptionalBitmapEquals(left_.buffers[0], left_.offset + left_start_idx_,\n+                              right_.buffers[0], right_.offset + right_start_idx_,\n+                              range_length_)) {\n+      return false;\n+    }\n+    // Compare values\n+    return CompareWithType(*left_.type);\n   }\n \n-  template <typename ArrayType, typename CompareValuesFunc>\n-  bool CompareWithOffsets(const ArrayType& left,\n-                          CompareValuesFunc&& compare_values) const {\n-    const auto& right = checked_cast<const ArrayType&>(right_);\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (is_null) continue;\n-      const auto begin_offset = left.value_offset(i);\n-      const auto end_offset = left.value_offset(i + 1);\n-      const auto right_begin_offset = right.value_offset(o_i);\n-      const auto right_end_offset = right.value_offset(o_i + 1);\n-      // Underlying can't be equal if the size isn't equal\n-      if (end_offset - begin_offset != right_end_offset - right_begin_offset) {\n-        return false;\n-      }\n-\n-      if (!compare_values(left, right, begin_offset, right_begin_offset,\n-                          end_offset - begin_offset)) {\n-        return false;\n-      }\n+  bool CompareWithType(const DataType& type) {\n+    result_ = true;\n+    if (range_length_ != 0) {\n+      ARROW_CHECK_OK(VisitTypeInline(type, this));\n     }\n-    return true;\n+    return result_;\n   }\n \n-  template <typename BinaryArrayType>\n-  bool CompareBinaryRange(const BinaryArrayType& left) const {\n-    using offset_type = typename BinaryArrayType::offset_type;\n+  Status Visit(const NullType&) { return Status::OK(); }\n \n-    auto compare_values = [](const BinaryArrayType& left, const BinaryArrayType& right,\n-                             offset_type left_offset, offset_type right_offset,\n-                             offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return std::memcmp(left.value_data()->data() + left_offset,\n-                         right.value_data()->data() + right_offset,\n-                         static_cast<size_t>(nvalues)) == 0;\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_primitive_ctype<TypeClass, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  template <typename ListArrayType>\n-  bool CompareLists(const ListArrayType& left) {\n-    using offset_type = typename ListArrayType::offset_type;\n-    const auto& right = checked_cast<const ListArrayType&>(right_);\n-    const std::shared_ptr<Array>& left_values = left.values();\n-    const std::shared_ptr<Array>& right_values = right.values();\n-\n-    auto compare_values = [&](const ListArrayType& left, const ListArrayType& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_values->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                      right_values);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n-  }\n-\n-  bool CompareMaps(const MapArray& left) {\n-    // We need a specific comparison helper for maps to avoid comparing\n-    // struct field names (which are indifferent for maps)\n-    using offset_type = typename MapArray::offset_type;\n-    const auto& right = checked_cast<const MapArray&>(right_);\n-    const auto left_keys = left.keys();\n-    const auto left_items = left.items();\n-    const auto right_keys = right.keys();\n-    const auto right_items = right.items();\n-\n-    auto compare_values = [&](const MapArray& left, const MapArray& right,\n-                              offset_type left_offset, offset_type right_offset,\n-                              offset_type nvalues) {\n-      if (nvalues == 0) {\n-        return true;\n-      }\n-      return left_keys->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                    right_keys) &&\n-             left_items->RangeEquals(left_offset, left_offset + nvalues, right_offset,\n-                                     right_items);\n-    };\n-    return CompareWithOffsets(left, compare_values);\n+  template <typename TypeClass>\n+  enable_if_t<is_temporal_type<TypeClass>::value, Status> Visit(const TypeClass& type) {\n+    return ComparePrimitive(type);\n   }\n \n-  bool CompareStructs(const StructArray& left) {\n-    const auto& right = checked_cast<const StructArray&>(right_);\n-    bool equal_fields = true;\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      for (int j = 0; j < left.num_fields(); ++j) {\n-        // TODO: really we should be comparing stretches of non-null data rather\n-        // than looking at one value at a time.\n-        equal_fields = left.field(j)->RangeEquals(i, i + 1, o_i, right.field(j));\n-        if (!equal_fields) {\n-          return false;\n-        }\n-      }\n-    }\n-    return true;\n-  }\n-\n-  bool CompareUnions(const UnionArray& left) const {\n-    const auto& right = checked_cast<const UnionArray&>(right_);\n-\n-    const UnionMode::type union_mode = left.mode();\n-    if (union_mode != right.mode()) {\n-      return false;\n-    }\n-\n-    const auto& left_type = checked_cast<const UnionType&>(*left.type());\n-\n-    const std::vector<int>& child_ids = left_type.child_ids();\n-\n-    const int8_t* left_codes = left.raw_type_codes();\n-    const int8_t* right_codes = right.raw_type_codes();\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      if (left.IsNull(i) != right.IsNull(o_i)) {\n-        return false;\n-      }\n-      if (left.IsNull(i)) continue;\n-      if (left_codes[i] != right_codes[o_i]) {\n-        return false;\n-      }\n-\n-      auto child_num = child_ids[left_codes[i]];\n-\n-      // TODO(wesm): really we should be comparing stretches of non-null data\n-      // rather than looking at one value at a time.\n-      if (union_mode == UnionMode::SPARSE) {\n-        if (!left.field(child_num)->RangeEquals(i, i + 1, o_i, right.field(child_num))) {\n-          return false;\n+  Status Visit(const BooleanType&) {\n+    const uint8_t* left_bits = left_.GetValues<uint8_t>(1, 0);\n+    const uint8_t* right_bits = right_.GetValues<uint8_t>(1, 0);\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      if (length <= 8) {\n+        // Avoid the BitmapUInt64Reader overhead for very small runs\n+        for (int64_t j = i; j < i + length; ++j) {\n+          if (BitUtil::GetBit(left_bits, left_start_idx_ + left_.offset + j) !=\n+              BitUtil::GetBit(right_bits, right_start_idx_ + right_.offset + j)) {\n+            return false;\n+          }\n         }\n+        return true;\n       } else {\n-        const int32_t offset =\n-            checked_cast<const DenseUnionArray&>(left).raw_value_offsets()[i];\n-        const int32_t o_offset =\n-            checked_cast<const DenseUnionArray&>(right).raw_value_offsets()[o_i];\n-        if (!left.field(child_num)->RangeEquals(offset, offset + 1, o_offset,\n-                                                right.field(child_num))) {\n-          return false;\n+        BitmapUInt64Reader left_reader(left_bits, left_start_idx_ + left_.offset + i,\n+                                       length);\n+        BitmapUInt64Reader right_reader(right_bits, right_start_idx_ + right_.offset + i,\n+                                        length);\n+        while (left_reader.position() < length) {\n+          if (left_reader.NextWord() != right_reader.NextWord()) {\n+            return false;\n+          }\n         }\n+        DCHECK_EQ(right_reader.position(), length);\n       }\n-    }\n-    return true;\n-  }\n-\n-  Status Visit(const BinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n-    return Status::OK();\n-  }\n-\n-  Status Visit(const LargeBinaryArray& left) {\n-    result_ = CompareBinaryRange(left);\n+      return true;\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const FixedSizeBinaryArray& left) {\n-    const auto& right = checked_cast<const FixedSizeBinaryArray&>(right_);\n+  Status Visit(const FloatType& type) { return CompareFloating(type); }\n \n-    int32_t width = left.byte_width();\n+  Status Visit(const DoubleType& type) { return CompareFloating(type); }\n \n-    const uint8_t* left_data = nullptr;\n-    const uint8_t* right_data = nullptr;\n+  // Also matches StringType\n+  Status Visit(const BinaryType& type) { return CompareBinary(type); }\n \n-    if (left.values()) {\n-      left_data = left.raw_values();\n-    }\n+  // Also matches LargeStringType\n+  Status Visit(const LargeBinaryType& type) { return CompareBinary(type); }\n \n-    if (right.values()) {\n-      right_data = right.raw_values();\n-    }\n-\n-    for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n-         ++i, ++o_i) {\n-      const bool is_null = left.IsNull(i);\n-      if (is_null != right.IsNull(o_i)) {\n-        result_ = false;\n-        return Status::OK();\n-      }\n-      if (is_null) continue;\n+  Status Visit(const FixedSizeBinaryType& type) {\n+    const auto byte_width = type.byte_width();\n+    const uint8_t* left_data = left_.GetValues<uint8_t>(1, 0);\n+    const uint8_t* right_data = right_.GetValues<uint8_t>(1, 0);\n \n-      if (std::memcmp(left_data + width * i, right_data + width * o_i, width)) {\n-        result_ = false;\n-        return Status::OK();\n-      }\n+    if (left_data != nullptr && right_data != nullptr) {\n+      auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+        return memcmp(left_data + (left_start_idx_ + left_.offset + i) * byte_width,\n+                      right_data + (right_start_idx_ + right_.offset + i) * byte_width,\n+                      length * byte_width) == 0;\n+      };\n+      VisitValidRuns(compare_runs);\n+    } else {\n+      auto compare_runs = [&](int64_t i, int64_t length) -> bool { return true; };\n+      VisitValidRuns(compare_runs);\n     }\n-    result_ = true;\n     return Status::OK();\n   }\n \n-  Status Visit(const Decimal128Array& left) {\n-    return Visit(checked_cast<const FixedSizeBinaryArray&>(left));\n-  }\n+  // Also matches MapType\n+  Status Visit(const ListType& type) { return CompareList(type); }\n \n-  Status Visit(const Decimal256Array& left) {\n-    return Visit(checked_cast<const FixedSizeBinaryArray&>(left));\n-  }\n+  Status Visit(const LargeListType& type) { return CompareList(type); }\n \n-  Status Visit(const NullArray& left) {\n-    ARROW_UNUSED(left);\n-    result_ = true;\n-    return Status::OK();\n-  }\n-\n-  template <typename T>\n-  typename std::enable_if<std::is_base_of<PrimitiveArray, T>::value, Status>::type Visit(\n-      const T& left) {\n-    return CompareValues<T>(left);\n-  }\n+  Status Visit(const FixedSizeListType& type) {\n+    const auto list_size = type.list_size();\n+    const ArrayData& left_data = *left_.child_data[0];\n+    const ArrayData& right_data = *right_.child_data[0];\n \n-  Status Visit(const ListArray& left) {\n-    result_ = CompareLists(left);\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      RangeDataEqualsImpl impl(options_, floating_approximate_, left_data, right_data,\n+                               (left_start_idx_ + left_.offset + i) * list_size,\n+                               (right_start_idx_ + right_.offset + i) * list_size,\n+                               length * list_size);\n+      return impl.Compare();\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const LargeListArray& left) {\n-    result_ = CompareLists(left);\n-    return Status::OK();\n-  }\n+  Status Visit(const StructType& type) {\n+    const int32_t num_fields = type.num_fields();\n \n-  Status Visit(const FixedSizeListArray& left) {\n-    const auto& right = checked_cast<const FixedSizeListArray&>(right_);\n-    result_ = left.values()->RangeEquals(\n-        left.value_offset(left_start_idx_), left.value_offset(left_end_idx_),\n-        right.value_offset(right_start_idx_), right.values());\n+    auto compare_runs = [&](int64_t i, int64_t length) -> bool {\n+      for (int32_t f = 0; f < num_fields; ++f) {\n+        RangeDataEqualsImpl impl(options_, floating_approximate_, *left_.child_data[f],\n+                                 *right_.child_data[f],\n+                                 left_start_idx_ + left_.offset + i,\n+                                 right_start_idx_ + right_.offset + i, length);\n+        if (!impl.Compare()) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    };\n+    VisitValidRuns(compare_runs);\n     return Status::OK();\n   }\n \n-  Status Visit(const MapArray& left) {\n-    result_ = CompareMaps(left);\n-    return Status::OK();\n-  }\n+  Status Visit(const SparseUnionType& type) {\n+    const auto& child_ids = type.child_ids();\n+    const int8_t* left_codes = left_.GetValues<int8_t>(1);\n+    const int8_t* right_codes = right_.GetValues<int8_t>(1);\n \n-  Status Visit(const StructArray& left) {\n-    result_ = CompareStructs(left);\n+    VisitValidRuns([&](int64_t i, int64_t length) {\n+      for (int64_t j = i; j < i + length; ++j) {\n+        const auto type_id = left_codes[left_start_idx_ + j];\n+        if (type_id != right_codes[right_start_idx_ + j]) {\n+          return false;\n+        }\n+        const auto child_num = child_ids[type_id];\n+        // XXX can we instead detect runs of same-child union values?\n+        RangeDataEqualsImpl impl(\n+            options_, floating_approximate_, *left_.child_data[child_num],\n+            *right_.child_data[child_num], left_start_idx_ + left_.offset + j,\n+            right_start_idx_ + right_.offset + j, 1);\n+        if (!impl.Compare()) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    });\n     return Status::OK();\n   }\n \n-  Status Visit(const UnionArray& left) {\n-    result_ = CompareUnions(left);\n+  Status Visit(const DenseUnionType& type) {\n+    const auto& child_ids = type.child_ids();\n+    const int8_t* left_codes = left_.GetValues<int8_t>(1);\n+    const int8_t* right_codes = right_.GetValues<int8_t>(1);\n+    const int32_t* left_offsets = left_.GetValues<int32_t>(2);\n+    const int32_t* right_offsets = right_.GetValues<int32_t>(2);\n+\n+    VisitValidRuns([&](int64_t i, int64_t length) {\n+      for (int64_t j = i; j < i + length; ++j) {\n+        const auto type_id = left_codes[left_start_idx_ + j];\n+        if (type_id != right_codes[right_start_idx_ + j]) {\n+          return false;\n+        }\n+        const auto child_num = child_ids[type_id];\n\nReview comment:\n       I see that you kept previous semantics, I was just noting that the difference is odd. I would have expected the two cases to be more symmetric and wondered if you could comment\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-21T16:18:03.332+0000",
                    "updated": "2020-11-21T16:18:03.332+0000",
                    "started": "2020-11-21T16:18:03.332+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515094",
                    "issueId": "13330181"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 15600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@14b4554b[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4a6b0971[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@566be98f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@44d952b2[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@734a4f57[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@c405a91[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5eefd07[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@b2c73ca[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2abda50f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@24a7e61b[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@56d3314d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@3e89ba7e[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 15600,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Nov 23 12:57:20 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-11-23T12:57:20.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10143/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2020-09-30T14:10:36.000+0000",
        "updated": "2020-11-23T13:56:45.000+0000",
        "timeoriginalestimate": null,
        "description": "Besides, the underlying implementations of ArrayEquals and ArrayRangeEquals should be shared (right now they are duplicated).",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "4h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 15600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] ArrayRangeEquals should accept EqualOptions",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330181/comment/17237348",
                    "id": "17237348",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 8703\n[https://github.com/apache/arrow/pull/8703]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2020-11-23T12:57:20.919+0000",
                    "updated": "2020-11-23T12:57:20.919+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0j1tk:",
        "customfield_12314139": null
    }
}