{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13340743",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340743",
    "key": "ARROW-10600",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351947",
                "id": "12351947",
                "description": "",
                "name": "10.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-10-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=zeroshade",
            "name": "zeroshade",
            "key": "zeroshade",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=zeroshade&avatarId=31230",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=zeroshade&avatarId=31230",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=zeroshade&avatarId=31230",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=zeroshade&avatarId=31230"
            },
            "displayName": "Matthew Topol",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333772",
                "id": "12333772",
                "name": "Go"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield",
            "name": "emkornfield",
            "key": "emkornfield",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield",
            "name": "emkornfield",
            "key": "emkornfield",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 10800,
            "total": 10800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 10800,
            "total": 10800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10600/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 18,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340743/worklog/797789",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13792:\nURL: https://github.com/apache/arrow/pull/13792#issuecomment-1204511729\n\n   https://issues.apache.org/jira/browse/ARROW-10600\n\n\n",
                    "created": "2022-08-03T21:39:02.591+0000",
                    "updated": "2022-08-03T21:39:02.591+0000",
                    "started": "2022-08-03T21:39:02.590+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "797789",
                    "issueId": "13340743"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340743/worklog/798089",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #13792:\nURL: https://github.com/apache/arrow/pull/13792#discussion_r937929132\n\n\n##########\ngo/arrow/decimal256/decimal256.go:\n##########\n@@ -0,0 +1,569 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package decimal256\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"math\"\n+\t\"math/big\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow/decimal128\"\n+\t\"github.com/apache/arrow/go/v10/arrow/internal/debug\"\n+)\n+\n+const (\n+\tMaxPrecision = 76\n+\tMaxScale     = 76\n+)\n+\n+type Num struct {\n+\t// arr[0] is the lowest bits, arr[3] is the highest bits\n+\tarr [4]uint64\n+}\n+\n+// New returns a new signed 256-bit integer value where x1 contains\n+// the highest bits with the rest of the values in order down to the\n+// lowest bits\n+//\n+//   ie: New(1, 2, 3, 4) returns with the elements in little-endian order\n+//       {4, 3, 2, 1} but each value is still represented as the native endianness\n+func New(x1, x2, x3, x4 uint64) Num {\n+\treturn Num{[4]uint64{x4, x3, x2, x1}}\n+}\n+\n+func (n Num) Array() [4]uint64 { return n.arr }\n+\n+func (n Num) LowBits() uint64 { return n.arr[0] }\n+\n+func FromDecimal128(n decimal128.Num) Num {\n+\tvar topBits uint64\n+\tif n.Sign() < 0 {\n+\t\ttopBits = math.MaxUint64\n+\t}\n+\treturn New(topBits, topBits, uint64(n.HighBits()), n.LowBits())\n+}\n+\n+func FromU64(v uint64) Num {\n+\treturn Num{[4]uint64{v, 0, 0, 0}}\n+}\n+\n+func FromI64(v int64) Num {\n+\tswitch {\n+\tcase v > 0:\n+\t\treturn New(0, 0, 0, uint64(v))\n+\tcase v < 0:\n+\t\treturn New(math.MaxUint64, math.MaxUint64, math.MaxUint64, uint64(v))\n+\tdefault:\n+\t\treturn Num{}\n+\t}\n+}\n+\n+func (n Num) Negate() Num {\n+\tvar carry uint64 = 1\n+\tfor i := range n.arr {\n+\t\tn.arr[i] = ^n.arr[i] + carry\n+\t\tif n.arr[i] != 0 {\n+\t\t\tcarry = 0\n+\t\t}\n+\t}\n+\treturn n\n+}\n+\n+func FromFloat32(v float32, prec, scale int32) (Num, error) {\n+\tdebug.Assert(prec > 0 && prec <= 76, \"invalid precision for converting to decimal256\")\n+\n+\tif math.IsInf(float64(v), 0) {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256\", v)\n+\t}\n+\n+\tif v < 0 {\n+\t\tdec, err := fromPositiveFloat32(-v, prec, scale)\n+\t\tif err != nil {\n+\t\t\treturn dec, err\n+\t\t}\n+\t\treturn dec.Negate(), nil\n+\t}\n+\treturn fromPositiveFloat32(v, prec, scale)\n+}\n+\n+func fromPositiveFloat32(v float32, prec, scale int32) (Num, error) {\n+\tvar pscale float32\n+\tif scale >= -76 && scale <= 76 {\n+\t\tpscale = float32PowersOfTen[scale+76]\n+\t} else {\n+\t\tpscale = float32(math.Pow10(int(scale)))\n+\t}\n+\n+\tv *= pscale\n+\tv = float32(math.RoundToEven(float64(v)))\n+\tmaxabs := float32PowersOfTen[prec+76]\n+\tif v <= -maxabs || v >= maxabs {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256(precision=%d, scale=%d): overflow\",\n+\t\t\tv, prec, scale)\n+\t}\n+\n+\tvar arr [4]float32\n+\tarr[3] = float32(math.Floor(math.Ldexp(float64(v), -192)))\n+\tv -= float32(math.Ldexp(float64(arr[3]), 192))\n+\tarr[2] = float32(math.Floor(math.Ldexp(float64(v), -128)))\n+\tv -= float32(math.Ldexp(float64(arr[2]), 128))\n+\tarr[1] = float32(math.Floor(math.Ldexp(float64(v), -64)))\n+\tv -= float32(math.Ldexp(float64(arr[1]), 64))\n+\tarr[0] = v\n+\n+\tdebug.Assert(arr[3] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[3] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\tdebug.Assert(arr[2] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[2] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\tdebug.Assert(arr[1] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[1] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\tdebug.Assert(arr[0] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[0] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\treturn Num{[4]uint64{uint64(arr[0]), uint64(arr[1]), uint64(arr[2]), uint64(arr[3])}}, nil\n+}\n+\n+func FromFloat64(v float64, prec, scale int32) (Num, error) {\n+\tdebug.Assert(prec > 0 && prec <= 76, \"invalid precision for converting to decimal256\")\n+\n+\tif math.IsInf(v, 0) {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256\", v)\n+\t}\n+\n+\tif v < 0 {\n+\t\tdec, err := fromPositiveFloat64(-v, prec, scale)\n+\t\tif err != nil {\n+\t\t\treturn dec, err\n+\t\t}\n+\t\treturn dec.Negate(), nil\n+\t}\n+\treturn fromPositiveFloat64(v, prec, scale)\n+}\n+\n+func fromPositiveFloat64(v float64, prec, scale int32) (Num, error) {\n+\tvar pscale float64\n+\tif scale >= -76 && scale <= 76 {\n+\t\tpscale = float64PowersOfTen[scale+76]\n+\t} else {\n+\t\tpscale = math.Pow10(int(scale))\n+\t}\n+\n+\tv *= pscale\n+\tv = math.RoundToEven(v)\n+\tmaxabs := float64PowersOfTen[prec+76]\n+\tif v <= -maxabs || v >= maxabs {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256(precision=%d, scale=%d): overflow\",\n+\t\t\tv, prec, scale)\n+\t}\n+\n+\tvar arr [4]float64\n+\tarr[3] = math.Floor(math.Ldexp(v, -192))\n+\tv -= math.Ldexp(arr[3], 192)\n+\tarr[2] = math.Floor(math.Ldexp(v, -128))\n+\tv -= math.Ldexp(arr[2], 128)\n+\tarr[1] = math.Floor(math.Ldexp(v, -64))\n+\tv -= math.Ldexp(arr[1], 64)\n+\tarr[0] = v\n+\n+\tdebug.Assert(arr[3] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[3] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\tdebug.Assert(arr[2] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[2] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\tdebug.Assert(arr[1] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[1] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\tdebug.Assert(arr[0] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[0] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\treturn Num{[4]uint64{uint64(arr[0]), uint64(arr[1]), uint64(arr[2]), uint64(arr[3])}}, nil\n+}\n+\n+func (n Num) tofloat32Positive(scale int32) float32 {\n+\tconst twoTo64 float32 = 1.8446744e+19\n\nReview Comment:\n   Here as well, it might be better to do the calculation in the float64 realm?\n\n\n\n##########\ngo/arrow/decimal256/decimal256.go:\n##########\n@@ -0,0 +1,569 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package decimal256\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"math\"\n+\t\"math/big\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow/decimal128\"\n+\t\"github.com/apache/arrow/go/v10/arrow/internal/debug\"\n+)\n+\n+const (\n+\tMaxPrecision = 76\n+\tMaxScale     = 76\n+)\n+\n+type Num struct {\n+\t// arr[0] is the lowest bits, arr[3] is the highest bits\n+\tarr [4]uint64\n+}\n+\n+// New returns a new signed 256-bit integer value where x1 contains\n+// the highest bits with the rest of the values in order down to the\n+// lowest bits\n+//\n+//   ie: New(1, 2, 3, 4) returns with the elements in little-endian order\n+//       {4, 3, 2, 1} but each value is still represented as the native endianness\n+func New(x1, x2, x3, x4 uint64) Num {\n+\treturn Num{[4]uint64{x4, x3, x2, x1}}\n+}\n+\n+func (n Num) Array() [4]uint64 { return n.arr }\n+\n+func (n Num) LowBits() uint64 { return n.arr[0] }\n+\n+func FromDecimal128(n decimal128.Num) Num {\n+\tvar topBits uint64\n+\tif n.Sign() < 0 {\n+\t\ttopBits = math.MaxUint64\n+\t}\n+\treturn New(topBits, topBits, uint64(n.HighBits()), n.LowBits())\n+}\n+\n+func FromU64(v uint64) Num {\n+\treturn Num{[4]uint64{v, 0, 0, 0}}\n+}\n+\n+func FromI64(v int64) Num {\n+\tswitch {\n+\tcase v > 0:\n+\t\treturn New(0, 0, 0, uint64(v))\n+\tcase v < 0:\n+\t\treturn New(math.MaxUint64, math.MaxUint64, math.MaxUint64, uint64(v))\n+\tdefault:\n+\t\treturn Num{}\n+\t}\n+}\n+\n+func (n Num) Negate() Num {\n+\tvar carry uint64 = 1\n+\tfor i := range n.arr {\n+\t\tn.arr[i] = ^n.arr[i] + carry\n+\t\tif n.arr[i] != 0 {\n+\t\t\tcarry = 0\n+\t\t}\n+\t}\n+\treturn n\n+}\n+\n+func FromFloat32(v float32, prec, scale int32) (Num, error) {\n+\tdebug.Assert(prec > 0 && prec <= 76, \"invalid precision for converting to decimal256\")\n+\n+\tif math.IsInf(float64(v), 0) {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256\", v)\n+\t}\n+\n+\tif v < 0 {\n+\t\tdec, err := fromPositiveFloat32(-v, prec, scale)\n+\t\tif err != nil {\n+\t\t\treturn dec, err\n+\t\t}\n+\t\treturn dec.Negate(), nil\n+\t}\n+\treturn fromPositiveFloat32(v, prec, scale)\n+}\n+\n+func fromPositiveFloat32(v float32, prec, scale int32) (Num, error) {\n+\tvar pscale float32\n+\tif scale >= -76 && scale <= 76 {\n+\t\tpscale = float32PowersOfTen[scale+76]\n\nReview Comment:\n   Wouldn't it be better to cast `v` to float64 and then call `fromPositive64`? You would 1) remove a lot of code 2) get better precision (`float32PowersOfTen` contains some zeros and infinities for very small or large scales)\n\n\n\n##########\ngo/arrow/decimal256/decimal256.go:\n##########\n@@ -0,0 +1,569 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package decimal256\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"math\"\n+\t\"math/big\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow/decimal128\"\n+\t\"github.com/apache/arrow/go/v10/arrow/internal/debug\"\n+)\n+\n+const (\n+\tMaxPrecision = 76\n+\tMaxScale     = 76\n+)\n+\n+type Num struct {\n+\t// arr[0] is the lowest bits, arr[3] is the highest bits\n+\tarr [4]uint64\n+}\n+\n+// New returns a new signed 256-bit integer value where x1 contains\n+// the highest bits with the rest of the values in order down to the\n+// lowest bits\n+//\n+//   ie: New(1, 2, 3, 4) returns with the elements in little-endian order\n+//       {4, 3, 2, 1} but each value is still represented as the native endianness\n+func New(x1, x2, x3, x4 uint64) Num {\n+\treturn Num{[4]uint64{x4, x3, x2, x1}}\n+}\n+\n+func (n Num) Array() [4]uint64 { return n.arr }\n+\n+func (n Num) LowBits() uint64 { return n.arr[0] }\n+\n+func FromDecimal128(n decimal128.Num) Num {\n+\tvar topBits uint64\n+\tif n.Sign() < 0 {\n+\t\ttopBits = math.MaxUint64\n+\t}\n+\treturn New(topBits, topBits, uint64(n.HighBits()), n.LowBits())\n+}\n+\n+func FromU64(v uint64) Num {\n+\treturn Num{[4]uint64{v, 0, 0, 0}}\n+}\n+\n+func FromI64(v int64) Num {\n+\tswitch {\n+\tcase v > 0:\n+\t\treturn New(0, 0, 0, uint64(v))\n+\tcase v < 0:\n+\t\treturn New(math.MaxUint64, math.MaxUint64, math.MaxUint64, uint64(v))\n+\tdefault:\n+\t\treturn Num{}\n+\t}\n+}\n+\n+func (n Num) Negate() Num {\n+\tvar carry uint64 = 1\n+\tfor i := range n.arr {\n+\t\tn.arr[i] = ^n.arr[i] + carry\n+\t\tif n.arr[i] != 0 {\n+\t\t\tcarry = 0\n+\t\t}\n+\t}\n+\treturn n\n+}\n+\n+func FromFloat32(v float32, prec, scale int32) (Num, error) {\n+\tdebug.Assert(prec > 0 && prec <= 76, \"invalid precision for converting to decimal256\")\n+\n+\tif math.IsInf(float64(v), 0) {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256\", v)\n+\t}\n+\n+\tif v < 0 {\n+\t\tdec, err := fromPositiveFloat32(-v, prec, scale)\n+\t\tif err != nil {\n+\t\t\treturn dec, err\n+\t\t}\n+\t\treturn dec.Negate(), nil\n+\t}\n+\treturn fromPositiveFloat32(v, prec, scale)\n+}\n+\n+func fromPositiveFloat32(v float32, prec, scale int32) (Num, error) {\n+\tvar pscale float32\n+\tif scale >= -76 && scale <= 76 {\n+\t\tpscale = float32PowersOfTen[scale+76]\n+\t} else {\n+\t\tpscale = float32(math.Pow10(int(scale)))\n+\t}\n+\n+\tv *= pscale\n+\tv = float32(math.RoundToEven(float64(v)))\n+\tmaxabs := float32PowersOfTen[prec+76]\n+\tif v <= -maxabs || v >= maxabs {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256(precision=%d, scale=%d): overflow\",\n+\t\t\tv, prec, scale)\n+\t}\n+\n+\tvar arr [4]float32\n+\tarr[3] = float32(math.Floor(math.Ldexp(float64(v), -192)))\n+\tv -= float32(math.Ldexp(float64(arr[3]), 192))\n+\tarr[2] = float32(math.Floor(math.Ldexp(float64(v), -128)))\n+\tv -= float32(math.Ldexp(float64(arr[2]), 128))\n+\tarr[1] = float32(math.Floor(math.Ldexp(float64(v), -64)))\n+\tv -= float32(math.Ldexp(float64(arr[1]), 64))\n+\tarr[0] = v\n+\n+\tdebug.Assert(arr[3] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[3] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\tdebug.Assert(arr[2] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[2] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\tdebug.Assert(arr[1] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[1] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\tdebug.Assert(arr[0] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[0] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\treturn Num{[4]uint64{uint64(arr[0]), uint64(arr[1]), uint64(arr[2]), uint64(arr[3])}}, nil\n+}\n+\n+func FromFloat64(v float64, prec, scale int32) (Num, error) {\n+\tdebug.Assert(prec > 0 && prec <= 76, \"invalid precision for converting to decimal256\")\n+\n+\tif math.IsInf(v, 0) {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256\", v)\n+\t}\n+\n+\tif v < 0 {\n+\t\tdec, err := fromPositiveFloat64(-v, prec, scale)\n+\t\tif err != nil {\n+\t\t\treturn dec, err\n+\t\t}\n+\t\treturn dec.Negate(), nil\n+\t}\n+\treturn fromPositiveFloat64(v, prec, scale)\n+}\n+\n+func fromPositiveFloat64(v float64, prec, scale int32) (Num, error) {\n+\tvar pscale float64\n+\tif scale >= -76 && scale <= 76 {\n+\t\tpscale = float64PowersOfTen[scale+76]\n+\t} else {\n+\t\tpscale = math.Pow10(int(scale))\n+\t}\n+\n+\tv *= pscale\n+\tv = math.RoundToEven(v)\n+\tmaxabs := float64PowersOfTen[prec+76]\n+\tif v <= -maxabs || v >= maxabs {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256(precision=%d, scale=%d): overflow\",\n+\t\t\tv, prec, scale)\n+\t}\n+\n+\tvar arr [4]float64\n+\tarr[3] = math.Floor(math.Ldexp(v, -192))\n+\tv -= math.Ldexp(arr[3], 192)\n+\tarr[2] = math.Floor(math.Ldexp(v, -128))\n+\tv -= math.Ldexp(arr[2], 128)\n+\tarr[1] = math.Floor(math.Ldexp(v, -64))\n+\tv -= math.Ldexp(arr[1], 64)\n+\tarr[0] = v\n+\n+\tdebug.Assert(arr[3] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[3] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\tdebug.Assert(arr[2] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[2] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\tdebug.Assert(arr[1] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[1] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\tdebug.Assert(arr[0] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[0] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\treturn Num{[4]uint64{uint64(arr[0]), uint64(arr[1]), uint64(arr[2]), uint64(arr[3])}}, nil\n+}\n+\n+func (n Num) tofloat32Positive(scale int32) float32 {\n+\tconst twoTo64 float32 = 1.8446744e+19\n+\tif n.arr[3] != 0 || n.arr[2] != 0 {\n+\t\treturn floatInf\n\nReview Comment:\n   The decimal256 might have a large integer value but with a scale that compensates...\n\n\n\n##########\ngo/arrow/datatype_fixedwidth.go:\n##########\n@@ -529,6 +529,26 @@ func (Decimal128Type) Layout() DataTypeLayout {\n \treturn DataTypeLayout{Buffers: []BufferSpec{SpecBitmap(), SpecFixedWidth(Decimal128SizeBytes)}}\n }\n \n+// Decimal128Type represents a fixed-size 128-bit decimal type.\n+type Decimal256Type struct {\n+\tPrecision int32\n+\tScale     int32\n+}\n+\n+func (*Decimal256Type) ID() Type      { return DECIMAL256 }\n+func (*Decimal256Type) Name() string  { return \"decimal256\" }\n+func (*Decimal256Type) BitWidth() int { return 256 }\n+func (t *Decimal256Type) String() string {\n+\treturn fmt.Sprintf(\"%s(%d, %d)\", t.Name(), t.Precision, t.Scale)\n+}\n+func (t *Decimal256Type) Fingerprint() string {\n+\treturn fmt.Sprintf(\"%s[%d,%d,%d]\", typeFingerprint(t), t.BitWidth(), t.Precision, t.Scale)\n+}\n+\n+func (Decimal256Type) Layout() DataTypeLayout {\n+\treturn DataTypeLayout{Buffers: []BufferSpec{SpecBitmap(), SpecFixedWidth(Decimal128SizeBytes)}}\n\nReview Comment:\n   Probably this needs to be fixed as follows?\r\n   ```suggestion\r\n   \treturn DataTypeLayout{Buffers: []BufferSpec{SpecBitmap(), SpecFixedWidth(Decimal256SizeBytes)}}\r\n   ```\n\n\n\n##########\ngo/arrow/scalar/scalar.go:\n##########\n@@ -297,6 +298,8 @@ func (s *Decimal128) CastTo(to arrow.DataType) (Scalar, error) {\n \tswitch to.ID() {\n \tcase arrow.DECIMAL128:\n \t\treturn NewDecimal128Scalar(s.Value, to), nil\n+\tcase arrow.DECIMAL256:\n+\t\treturn NewDecimal256Scalar(decimal256.FromDecimal128(s.Value), to), nil\n\nReview Comment:\n   Same as below: should take into account differences in scale or precision.\n\n\n\n##########\ngo/arrow/decimal256/decimal256.go:\n##########\n@@ -0,0 +1,569 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package decimal256\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"math\"\n+\t\"math/big\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow/decimal128\"\n+\t\"github.com/apache/arrow/go/v10/arrow/internal/debug\"\n+)\n+\n+const (\n+\tMaxPrecision = 76\n+\tMaxScale     = 76\n+)\n+\n+type Num struct {\n+\t// arr[0] is the lowest bits, arr[3] is the highest bits\n+\tarr [4]uint64\n+}\n+\n+// New returns a new signed 256-bit integer value where x1 contains\n+// the highest bits with the rest of the values in order down to the\n+// lowest bits\n+//\n+//   ie: New(1, 2, 3, 4) returns with the elements in little-endian order\n+//       {4, 3, 2, 1} but each value is still represented as the native endianness\n+func New(x1, x2, x3, x4 uint64) Num {\n+\treturn Num{[4]uint64{x4, x3, x2, x1}}\n+}\n+\n+func (n Num) Array() [4]uint64 { return n.arr }\n+\n+func (n Num) LowBits() uint64 { return n.arr[0] }\n+\n+func FromDecimal128(n decimal128.Num) Num {\n+\tvar topBits uint64\n+\tif n.Sign() < 0 {\n+\t\ttopBits = math.MaxUint64\n+\t}\n+\treturn New(topBits, topBits, uint64(n.HighBits()), n.LowBits())\n+}\n+\n+func FromU64(v uint64) Num {\n+\treturn Num{[4]uint64{v, 0, 0, 0}}\n+}\n+\n+func FromI64(v int64) Num {\n+\tswitch {\n+\tcase v > 0:\n+\t\treturn New(0, 0, 0, uint64(v))\n+\tcase v < 0:\n+\t\treturn New(math.MaxUint64, math.MaxUint64, math.MaxUint64, uint64(v))\n+\tdefault:\n+\t\treturn Num{}\n+\t}\n+}\n+\n+func (n Num) Negate() Num {\n+\tvar carry uint64 = 1\n+\tfor i := range n.arr {\n+\t\tn.arr[i] = ^n.arr[i] + carry\n+\t\tif n.arr[i] != 0 {\n+\t\t\tcarry = 0\n+\t\t}\n+\t}\n+\treturn n\n+}\n+\n+func FromFloat32(v float32, prec, scale int32) (Num, error) {\n+\tdebug.Assert(prec > 0 && prec <= 76, \"invalid precision for converting to decimal256\")\n+\n+\tif math.IsInf(float64(v), 0) {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256\", v)\n+\t}\n+\n+\tif v < 0 {\n+\t\tdec, err := fromPositiveFloat32(-v, prec, scale)\n+\t\tif err != nil {\n+\t\t\treturn dec, err\n+\t\t}\n+\t\treturn dec.Negate(), nil\n+\t}\n+\treturn fromPositiveFloat32(v, prec, scale)\n+}\n+\n+func fromPositiveFloat32(v float32, prec, scale int32) (Num, error) {\n+\tvar pscale float32\n+\tif scale >= -76 && scale <= 76 {\n+\t\tpscale = float32PowersOfTen[scale+76]\n+\t} else {\n+\t\tpscale = float32(math.Pow10(int(scale)))\n+\t}\n+\n+\tv *= pscale\n+\tv = float32(math.RoundToEven(float64(v)))\n+\tmaxabs := float32PowersOfTen[prec+76]\n+\tif v <= -maxabs || v >= maxabs {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256(precision=%d, scale=%d): overflow\",\n+\t\t\tv, prec, scale)\n+\t}\n+\n+\tvar arr [4]float32\n+\tarr[3] = float32(math.Floor(math.Ldexp(float64(v), -192)))\n+\tv -= float32(math.Ldexp(float64(arr[3]), 192))\n+\tarr[2] = float32(math.Floor(math.Ldexp(float64(v), -128)))\n+\tv -= float32(math.Ldexp(float64(arr[2]), 128))\n+\tarr[1] = float32(math.Floor(math.Ldexp(float64(v), -64)))\n+\tv -= float32(math.Ldexp(float64(arr[1]), 64))\n+\tarr[0] = v\n+\n+\tdebug.Assert(arr[3] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[3] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\tdebug.Assert(arr[2] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[2] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\tdebug.Assert(arr[1] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[1] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\tdebug.Assert(arr[0] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[0] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\treturn Num{[4]uint64{uint64(arr[0]), uint64(arr[1]), uint64(arr[2]), uint64(arr[3])}}, nil\n+}\n+\n+func FromFloat64(v float64, prec, scale int32) (Num, error) {\n+\tdebug.Assert(prec > 0 && prec <= 76, \"invalid precision for converting to decimal256\")\n+\n+\tif math.IsInf(v, 0) {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256\", v)\n+\t}\n+\n+\tif v < 0 {\n+\t\tdec, err := fromPositiveFloat64(-v, prec, scale)\n+\t\tif err != nil {\n+\t\t\treturn dec, err\n+\t\t}\n+\t\treturn dec.Negate(), nil\n+\t}\n+\treturn fromPositiveFloat64(v, prec, scale)\n+}\n+\n+func fromPositiveFloat64(v float64, prec, scale int32) (Num, error) {\n+\tvar pscale float64\n+\tif scale >= -76 && scale <= 76 {\n+\t\tpscale = float64PowersOfTen[scale+76]\n+\t} else {\n+\t\tpscale = math.Pow10(int(scale))\n+\t}\n+\n+\tv *= pscale\n+\tv = math.RoundToEven(v)\n+\tmaxabs := float64PowersOfTen[prec+76]\n+\tif v <= -maxabs || v >= maxabs {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256(precision=%d, scale=%d): overflow\",\n+\t\t\tv, prec, scale)\n+\t}\n+\n+\tvar arr [4]float64\n+\tarr[3] = math.Floor(math.Ldexp(v, -192))\n+\tv -= math.Ldexp(arr[3], 192)\n+\tarr[2] = math.Floor(math.Ldexp(v, -128))\n+\tv -= math.Ldexp(arr[2], 128)\n+\tarr[1] = math.Floor(math.Ldexp(v, -64))\n+\tv -= math.Ldexp(arr[1], 64)\n+\tarr[0] = v\n+\n+\tdebug.Assert(arr[3] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[3] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\tdebug.Assert(arr[2] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[2] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\tdebug.Assert(arr[1] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[1] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\tdebug.Assert(arr[0] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[0] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\treturn Num{[4]uint64{uint64(arr[0]), uint64(arr[1]), uint64(arr[2]), uint64(arr[3])}}, nil\n+}\n+\n+func (n Num) tofloat32Positive(scale int32) float32 {\n+\tconst twoTo64 float32 = 1.8446744e+19\n+\tif n.arr[3] != 0 || n.arr[2] != 0 {\n+\t\treturn floatInf\n+\t}\n+\tx := float32(n.arr[1]) * twoTo64\n+\tx += float32(n.arr[0])\n+\tif scale >= -76 && scale <= 76 {\n+\t\treturn x * float32PowersOfTen[-scale+76]\n+\t}\n+\n+\treturn x * float32(math.Pow10(-int(scale)))\n+}\n+\n+func (n Num) tofloat64Positive(scale int32) float64 {\n+\tconst (\n+\t\ttwoTo64  float64 = 1.8446744073709552e+19\n+\t\ttwoTo128 float64 = 3.402823669209385e+38\n+\t\ttwoTo192 float64 = 6.277101735386681e+57\n+\t)\n+\n+\tx := float64(n.arr[3]) * twoTo192\n+\tx += float64(n.arr[2]) * twoTo128\n+\tx += float64(n.arr[1]) * twoTo64\n+\tx += float64(n.arr[0])\n+\n+\tif scale >= -76 && scale <= 76 {\n+\t\treturn x * float64PowersOfTen[-scale+76]\n+\t}\n+\n+\treturn x * math.Pow10(-int(scale))\n+}\n+\n+func (n Num) ToFloat32(scale int32) float32 {\n+\tif n.Sign() < 0 {\n+\t\treturn -n.Negate().tofloat32Positive(scale)\n+\t}\n+\treturn n.tofloat32Positive(scale)\n+}\n+\n+func (n Num) ToFloat64(scale int32) float64 {\n+\tif n.Sign() < 0 {\n+\t\treturn -n.Negate().tofloat64Positive(scale)\n+\t}\n+\treturn n.tofloat64Positive(scale)\n+}\n+\n+func (n Num) Sign() int {\n+\tif n == (Num{}) {\n+\t\treturn 0\n+\t}\n+\treturn int(1 | (int64(n.arr[3]) >> 63))\n+}\n+\n+func FromBigInt(v *big.Int) (n Num) {\n+\tbitlen := v.BitLen()\n+\tif bitlen > 256 {\n\nReview Comment:\n   Shouldn't you account for the sign bit?\r\n   ```suggestion\r\n   \tif bitlen > 255 {\r\n   ```\n\n\n\n##########\ngo/arrow/decimal256/decimal256.go:\n##########\n@@ -0,0 +1,569 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package decimal256\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"math\"\n+\t\"math/big\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow/decimal128\"\n+\t\"github.com/apache/arrow/go/v10/arrow/internal/debug\"\n+)\n+\n+const (\n+\tMaxPrecision = 76\n+\tMaxScale     = 76\n+)\n+\n+type Num struct {\n+\t// arr[0] is the lowest bits, arr[3] is the highest bits\n+\tarr [4]uint64\n+}\n+\n+// New returns a new signed 256-bit integer value where x1 contains\n+// the highest bits with the rest of the values in order down to the\n+// lowest bits\n+//\n+//   ie: New(1, 2, 3, 4) returns with the elements in little-endian order\n+//       {4, 3, 2, 1} but each value is still represented as the native endianness\n+func New(x1, x2, x3, x4 uint64) Num {\n+\treturn Num{[4]uint64{x4, x3, x2, x1}}\n+}\n+\n+func (n Num) Array() [4]uint64 { return n.arr }\n+\n+func (n Num) LowBits() uint64 { return n.arr[0] }\n+\n+func FromDecimal128(n decimal128.Num) Num {\n+\tvar topBits uint64\n+\tif n.Sign() < 0 {\n+\t\ttopBits = math.MaxUint64\n+\t}\n+\treturn New(topBits, topBits, uint64(n.HighBits()), n.LowBits())\n+}\n+\n+func FromU64(v uint64) Num {\n+\treturn Num{[4]uint64{v, 0, 0, 0}}\n+}\n+\n+func FromI64(v int64) Num {\n+\tswitch {\n+\tcase v > 0:\n+\t\treturn New(0, 0, 0, uint64(v))\n+\tcase v < 0:\n+\t\treturn New(math.MaxUint64, math.MaxUint64, math.MaxUint64, uint64(v))\n+\tdefault:\n+\t\treturn Num{}\n+\t}\n+}\n+\n+func (n Num) Negate() Num {\n+\tvar carry uint64 = 1\n+\tfor i := range n.arr {\n+\t\tn.arr[i] = ^n.arr[i] + carry\n+\t\tif n.arr[i] != 0 {\n+\t\t\tcarry = 0\n+\t\t}\n+\t}\n+\treturn n\n+}\n+\n+func FromFloat32(v float32, prec, scale int32) (Num, error) {\n+\tdebug.Assert(prec > 0 && prec <= 76, \"invalid precision for converting to decimal256\")\n+\n+\tif math.IsInf(float64(v), 0) {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256\", v)\n+\t}\n+\n+\tif v < 0 {\n+\t\tdec, err := fromPositiveFloat32(-v, prec, scale)\n+\t\tif err != nil {\n+\t\t\treturn dec, err\n+\t\t}\n+\t\treturn dec.Negate(), nil\n+\t}\n+\treturn fromPositiveFloat32(v, prec, scale)\n+}\n+\n+func fromPositiveFloat32(v float32, prec, scale int32) (Num, error) {\n+\tvar pscale float32\n+\tif scale >= -76 && scale <= 76 {\n+\t\tpscale = float32PowersOfTen[scale+76]\n+\t} else {\n+\t\tpscale = float32(math.Pow10(int(scale)))\n+\t}\n+\n+\tv *= pscale\n+\tv = float32(math.RoundToEven(float64(v)))\n+\tmaxabs := float32PowersOfTen[prec+76]\n+\tif v <= -maxabs || v >= maxabs {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256(precision=%d, scale=%d): overflow\",\n+\t\t\tv, prec, scale)\n+\t}\n+\n+\tvar arr [4]float32\n+\tarr[3] = float32(math.Floor(math.Ldexp(float64(v), -192)))\n+\tv -= float32(math.Ldexp(float64(arr[3]), 192))\n+\tarr[2] = float32(math.Floor(math.Ldexp(float64(v), -128)))\n+\tv -= float32(math.Ldexp(float64(arr[2]), 128))\n+\tarr[1] = float32(math.Floor(math.Ldexp(float64(v), -64)))\n+\tv -= float32(math.Ldexp(float64(arr[1]), 64))\n+\tarr[0] = v\n+\n+\tdebug.Assert(arr[3] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[3] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\tdebug.Assert(arr[2] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[2] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\tdebug.Assert(arr[1] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[1] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\tdebug.Assert(arr[0] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[0] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\treturn Num{[4]uint64{uint64(arr[0]), uint64(arr[1]), uint64(arr[2]), uint64(arr[3])}}, nil\n+}\n+\n+func FromFloat64(v float64, prec, scale int32) (Num, error) {\n+\tdebug.Assert(prec > 0 && prec <= 76, \"invalid precision for converting to decimal256\")\n+\n+\tif math.IsInf(v, 0) {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256\", v)\n+\t}\n+\n+\tif v < 0 {\n+\t\tdec, err := fromPositiveFloat64(-v, prec, scale)\n+\t\tif err != nil {\n+\t\t\treturn dec, err\n+\t\t}\n+\t\treturn dec.Negate(), nil\n+\t}\n+\treturn fromPositiveFloat64(v, prec, scale)\n+}\n+\n+func fromPositiveFloat64(v float64, prec, scale int32) (Num, error) {\n+\tvar pscale float64\n+\tif scale >= -76 && scale <= 76 {\n+\t\tpscale = float64PowersOfTen[scale+76]\n+\t} else {\n+\t\tpscale = math.Pow10(int(scale))\n+\t}\n+\n+\tv *= pscale\n+\tv = math.RoundToEven(v)\n+\tmaxabs := float64PowersOfTen[prec+76]\n+\tif v <= -maxabs || v >= maxabs {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256(precision=%d, scale=%d): overflow\",\n+\t\t\tv, prec, scale)\n+\t}\n+\n+\tvar arr [4]float64\n+\tarr[3] = math.Floor(math.Ldexp(v, -192))\n+\tv -= math.Ldexp(arr[3], 192)\n+\tarr[2] = math.Floor(math.Ldexp(v, -128))\n+\tv -= math.Ldexp(arr[2], 128)\n+\tarr[1] = math.Floor(math.Ldexp(v, -64))\n+\tv -= math.Ldexp(arr[1], 64)\n+\tarr[0] = v\n+\n+\tdebug.Assert(arr[3] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[3] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\tdebug.Assert(arr[2] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[2] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\tdebug.Assert(arr[1] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[1] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\tdebug.Assert(arr[0] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[0] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\treturn Num{[4]uint64{uint64(arr[0]), uint64(arr[1]), uint64(arr[2]), uint64(arr[3])}}, nil\n+}\n+\n+func (n Num) tofloat32Positive(scale int32) float32 {\n+\tconst twoTo64 float32 = 1.8446744e+19\n+\tif n.arr[3] != 0 || n.arr[2] != 0 {\n+\t\treturn floatInf\n+\t}\n+\tx := float32(n.arr[1]) * twoTo64\n+\tx += float32(n.arr[0])\n+\tif scale >= -76 && scale <= 76 {\n+\t\treturn x * float32PowersOfTen[-scale+76]\n+\t}\n+\n+\treturn x * float32(math.Pow10(-int(scale)))\n+}\n+\n+func (n Num) tofloat64Positive(scale int32) float64 {\n+\tconst (\n+\t\ttwoTo64  float64 = 1.8446744073709552e+19\n+\t\ttwoTo128 float64 = 3.402823669209385e+38\n+\t\ttwoTo192 float64 = 6.277101735386681e+57\n+\t)\n+\n+\tx := float64(n.arr[3]) * twoTo192\n+\tx += float64(n.arr[2]) * twoTo128\n+\tx += float64(n.arr[1]) * twoTo64\n+\tx += float64(n.arr[0])\n+\n+\tif scale >= -76 && scale <= 76 {\n+\t\treturn x * float64PowersOfTen[-scale+76]\n+\t}\n+\n+\treturn x * math.Pow10(-int(scale))\n+}\n+\n+func (n Num) ToFloat32(scale int32) float32 {\n+\tif n.Sign() < 0 {\n+\t\treturn -n.Negate().tofloat32Positive(scale)\n+\t}\n+\treturn n.tofloat32Positive(scale)\n+}\n+\n+func (n Num) ToFloat64(scale int32) float64 {\n+\tif n.Sign() < 0 {\n+\t\treturn -n.Negate().tofloat64Positive(scale)\n+\t}\n+\treturn n.tofloat64Positive(scale)\n+}\n+\n+func (n Num) Sign() int {\n+\tif n == (Num{}) {\n+\t\treturn 0\n+\t}\n+\treturn int(1 | (int64(n.arr[3]) >> 63))\n\nReview Comment:\n   Is the purpose here to avoid branching? (otherwise why not a simple conditional?)\n\n\n\n##########\ngo/arrow/scalar/scalar.go:\n##########\n@@ -311,6 +314,50 @@ func NewDecimal128Scalar(val decimal128.Num, typ arrow.DataType) *Decimal128 {\n \treturn &Decimal128{scalar{typ, true}, val}\n }\n \n+type Decimal256 struct {\n+\tscalar\n+\tValue decimal256.Num\n+}\n+\n+func (s *Decimal256) value() interface{} { return s.Value }\n+\n+func (s *Decimal256) String() string {\n+\tif !s.Valid {\n+\t\treturn \"null\"\n+\t}\n+\tval, err := s.CastTo(arrow.BinaryTypes.String)\n+\tif err != nil {\n+\t\treturn \"...\"\n+\t}\n+\treturn string(val.(*String).Value.Bytes())\n+}\n+\n+func (s *Decimal256) equals(rhs Scalar) bool {\n+\treturn s.Value == rhs.(*Decimal256).Value\n+}\n+\n+func (s *Decimal256) CastTo(to arrow.DataType) (Scalar, error) {\n+\tif !s.Valid {\n+\t\treturn MakeNullScalar(to), nil\n+\t}\n+\n+\tswitch to.ID() {\n+\tcase arrow.DECIMAL256:\n+\t\treturn NewDecimal256Scalar(s.Value, to), nil\n\nReview Comment:\n   I think this is missing some casting of `s.Value` in case the scales don't match.\r\n   And even if the scales match, should probably check that the value still fits in the new precision.\n\n\n\n##########\ngo/arrow/array/decimal256_test.go:\n##########\n@@ -0,0 +1,179 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array_test\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/array\"\n+\t\"github.com/apache/arrow/go/v10/arrow/decimal256\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func TestNewDecimal256Builder(t *testing.T) {\n+\tmem := memory.NewCheckedAllocator(memory.NewGoAllocator())\n+\tdefer mem.AssertSize(t, 0)\n+\n+\tab := array.NewDecimal256Builder(mem, &arrow.Decimal256Type{Precision: 10, Scale: 1})\n+\tdefer ab.Release()\n+\n+\tab.Retain()\n+\tab.Release()\n+\n+\twant := []decimal256.Num{\n+\t\tdecimal256.New(1, 1, 1, 1),\n+\t\tdecimal256.New(2, 2, 2, 2),\n+\t\tdecimal256.New(3, 3, 3, 3),\n+\t\t{},\n+\t\tdecimal256.FromI64(-5),\n+\t\tdecimal256.FromI64(-6),\n+\t\t{},\n+\t\tdecimal256.FromI64(8),\n+\t\tdecimal256.FromI64(9),\n+\t\tdecimal256.FromI64(10),\n+\t}\n+\tvalids := []bool{true, true, true, false, true, true, false, true, true, true}\n+\n+\tfor i, valid := range valids {\n+\t\tswitch {\n+\t\tcase valid:\n+\t\t\tab.Append(want[i])\n+\t\tdefault:\n+\t\t\tab.AppendNull()\n+\t\t}\n+\t}\n+\n+\t// check state of builder before NewDecimal256Array\n+\tassert.Equal(t, 10, ab.Len(), \"unexpected Len()\")\n+\tassert.Equal(t, 2, ab.NullN(), \"unexpected NullN()\")\n+\n+\ta := ab.NewArray().(*array.Decimal256)\n+\ta.Retain()\n+\ta.Release()\n+\n+\t// check state of builder after NewDecimal256Array\n+\tassert.Zero(t, ab.Len(), \"unexpected ArrayBuilder.Len(), NewDecimal256Array did not reset state\")\n+\tassert.Zero(t, ab.Cap(), \"unexpected ArrayBuilder.Cap(), NewDecimal256Array did not reset state\")\n+\tassert.Zero(t, ab.NullN(), \"unexpected ArrayBuilder.NullN(), NewDecimal256Array did not reset state\")\n+\n+\t// check state of array\n+\tassert.Equal(t, 2, a.NullN(), \"unexpected null count\")\n+\n+\tassert.Equal(t, want, a.Values(), \"unexpected Decimal256Values\")\n+\tassert.Equal(t, []byte{0xb7}, a.NullBitmapBytes()[:1]) // 4 bytes due to minBuilderCapacity\n+\tassert.Len(t, a.Values(), 10, \"unexpected length of Decimal256Values\")\n+\n+\ta.Release()\n+\tab.Append(decimal256.FromI64(7))\n+\tab.Append(decimal256.FromI64(8))\n+\n+\ta = ab.NewDecimal256Array()\n+\n+\tassert.Equal(t, 0, a.NullN())\n+\tassert.Equal(t, []decimal256.Num{decimal256.FromI64(7), decimal256.FromI64(8)}, a.Values())\n+\tassert.Len(t, a.Values(), 2)\n\nReview Comment:\n   Is it possible to also test the byte size of the buffers here?\n\n\n\n##########\ngo/arrow/datatype_fixedwidth.go:\n##########\n@@ -529,6 +529,26 @@ func (Decimal128Type) Layout() DataTypeLayout {\n \treturn DataTypeLayout{Buffers: []BufferSpec{SpecBitmap(), SpecFixedWidth(Decimal128SizeBytes)}}\n }\n \n+// Decimal128Type represents a fixed-size 128-bit decimal type.\n\nReview Comment:\n   Obvious fix\r\n   ```suggestion\r\n   // Decimal256Type represents a fixed-size 256-bit decimal type.\r\n   ```\n\n\n\n",
                    "created": "2022-08-04T15:46:39.388+0000",
                    "updated": "2022-08-04T15:46:39.388+0000",
                    "started": "2022-08-04T15:46:39.387+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "798089",
                    "issueId": "13340743"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340743/worklog/798098",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #13792:\nURL: https://github.com/apache/arrow/pull/13792#discussion_r937990762\n\n\n##########\ngo/arrow/datatype_fixedwidth.go:\n##########\n@@ -529,6 +529,26 @@ func (Decimal128Type) Layout() DataTypeLayout {\n \treturn DataTypeLayout{Buffers: []BufferSpec{SpecBitmap(), SpecFixedWidth(Decimal128SizeBytes)}}\n }\n \n+// Decimal128Type represents a fixed-size 128-bit decimal type.\n\nReview Comment:\n   Gah! I missed one!\n\n\n\n",
                    "created": "2022-08-04T16:10:06.073+0000",
                    "updated": "2022-08-04T16:10:06.073+0000",
                    "started": "2022-08-04T16:10:06.072+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "798098",
                    "issueId": "13340743"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340743/worklog/798099",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #13792:\nURL: https://github.com/apache/arrow/pull/13792#discussion_r937997569\n\n\n##########\ngo/arrow/decimal256/decimal256.go:\n##########\n@@ -0,0 +1,569 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package decimal256\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"math\"\n+\t\"math/big\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow/decimal128\"\n+\t\"github.com/apache/arrow/go/v10/arrow/internal/debug\"\n+)\n+\n+const (\n+\tMaxPrecision = 76\n+\tMaxScale     = 76\n+)\n+\n+type Num struct {\n+\t// arr[0] is the lowest bits, arr[3] is the highest bits\n+\tarr [4]uint64\n+}\n+\n+// New returns a new signed 256-bit integer value where x1 contains\n+// the highest bits with the rest of the values in order down to the\n+// lowest bits\n+//\n+//   ie: New(1, 2, 3, 4) returns with the elements in little-endian order\n+//       {4, 3, 2, 1} but each value is still represented as the native endianness\n+func New(x1, x2, x3, x4 uint64) Num {\n+\treturn Num{[4]uint64{x4, x3, x2, x1}}\n+}\n+\n+func (n Num) Array() [4]uint64 { return n.arr }\n+\n+func (n Num) LowBits() uint64 { return n.arr[0] }\n+\n+func FromDecimal128(n decimal128.Num) Num {\n+\tvar topBits uint64\n+\tif n.Sign() < 0 {\n+\t\ttopBits = math.MaxUint64\n+\t}\n+\treturn New(topBits, topBits, uint64(n.HighBits()), n.LowBits())\n+}\n+\n+func FromU64(v uint64) Num {\n+\treturn Num{[4]uint64{v, 0, 0, 0}}\n+}\n+\n+func FromI64(v int64) Num {\n+\tswitch {\n+\tcase v > 0:\n+\t\treturn New(0, 0, 0, uint64(v))\n+\tcase v < 0:\n+\t\treturn New(math.MaxUint64, math.MaxUint64, math.MaxUint64, uint64(v))\n+\tdefault:\n+\t\treturn Num{}\n+\t}\n+}\n+\n+func (n Num) Negate() Num {\n+\tvar carry uint64 = 1\n+\tfor i := range n.arr {\n+\t\tn.arr[i] = ^n.arr[i] + carry\n+\t\tif n.arr[i] != 0 {\n+\t\t\tcarry = 0\n+\t\t}\n+\t}\n+\treturn n\n+}\n+\n+func FromFloat32(v float32, prec, scale int32) (Num, error) {\n+\tdebug.Assert(prec > 0 && prec <= 76, \"invalid precision for converting to decimal256\")\n+\n+\tif math.IsInf(float64(v), 0) {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256\", v)\n+\t}\n+\n+\tif v < 0 {\n+\t\tdec, err := fromPositiveFloat32(-v, prec, scale)\n+\t\tif err != nil {\n+\t\t\treturn dec, err\n+\t\t}\n+\t\treturn dec.Negate(), nil\n+\t}\n+\treturn fromPositiveFloat32(v, prec, scale)\n+}\n+\n+func fromPositiveFloat32(v float32, prec, scale int32) (Num, error) {\n+\tvar pscale float32\n+\tif scale >= -76 && scale <= 76 {\n+\t\tpscale = float32PowersOfTen[scale+76]\n\nReview Comment:\n   So i tried that originally when I was writing the `ToFloat` functionalities for decimal128 and found (*very*) small precision issues which I assumed would carry through to the `From` functions. though right now trying this locally I can't reproduce those precision issues, maybe it was a windows thing? I don't know. That said, given that those precision issues would be outside the bounds of what is considered even reasonable for a float, I agree with you that it's probably just easier/better to cast to float64 and use the `fromPositiveFloat64` / `tofloat64Positive` functions and remove the excess code. I'll go do that.\n\n\n\n",
                    "created": "2022-08-04T16:17:11.766+0000",
                    "updated": "2022-08-04T16:17:11.766+0000",
                    "started": "2022-08-04T16:17:11.766+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "798099",
                    "issueId": "13340743"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340743/worklog/798100",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #13792:\nURL: https://github.com/apache/arrow/pull/13792#discussion_r937998778\n\n\n##########\ngo/arrow/decimal256/decimal256.go:\n##########\n@@ -0,0 +1,569 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package decimal256\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"math\"\n+\t\"math/big\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow/decimal128\"\n+\t\"github.com/apache/arrow/go/v10/arrow/internal/debug\"\n+)\n+\n+const (\n+\tMaxPrecision = 76\n+\tMaxScale     = 76\n+)\n+\n+type Num struct {\n+\t// arr[0] is the lowest bits, arr[3] is the highest bits\n+\tarr [4]uint64\n+}\n+\n+// New returns a new signed 256-bit integer value where x1 contains\n+// the highest bits with the rest of the values in order down to the\n+// lowest bits\n+//\n+//   ie: New(1, 2, 3, 4) returns with the elements in little-endian order\n+//       {4, 3, 2, 1} but each value is still represented as the native endianness\n+func New(x1, x2, x3, x4 uint64) Num {\n+\treturn Num{[4]uint64{x4, x3, x2, x1}}\n+}\n+\n+func (n Num) Array() [4]uint64 { return n.arr }\n+\n+func (n Num) LowBits() uint64 { return n.arr[0] }\n+\n+func FromDecimal128(n decimal128.Num) Num {\n+\tvar topBits uint64\n+\tif n.Sign() < 0 {\n+\t\ttopBits = math.MaxUint64\n+\t}\n+\treturn New(topBits, topBits, uint64(n.HighBits()), n.LowBits())\n+}\n+\n+func FromU64(v uint64) Num {\n+\treturn Num{[4]uint64{v, 0, 0, 0}}\n+}\n+\n+func FromI64(v int64) Num {\n+\tswitch {\n+\tcase v > 0:\n+\t\treturn New(0, 0, 0, uint64(v))\n+\tcase v < 0:\n+\t\treturn New(math.MaxUint64, math.MaxUint64, math.MaxUint64, uint64(v))\n+\tdefault:\n+\t\treturn Num{}\n+\t}\n+}\n+\n+func (n Num) Negate() Num {\n+\tvar carry uint64 = 1\n+\tfor i := range n.arr {\n+\t\tn.arr[i] = ^n.arr[i] + carry\n+\t\tif n.arr[i] != 0 {\n+\t\t\tcarry = 0\n+\t\t}\n+\t}\n+\treturn n\n+}\n+\n+func FromFloat32(v float32, prec, scale int32) (Num, error) {\n+\tdebug.Assert(prec > 0 && prec <= 76, \"invalid precision for converting to decimal256\")\n+\n+\tif math.IsInf(float64(v), 0) {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256\", v)\n+\t}\n+\n+\tif v < 0 {\n+\t\tdec, err := fromPositiveFloat32(-v, prec, scale)\n+\t\tif err != nil {\n+\t\t\treturn dec, err\n+\t\t}\n+\t\treturn dec.Negate(), nil\n+\t}\n+\treturn fromPositiveFloat32(v, prec, scale)\n+}\n+\n+func fromPositiveFloat32(v float32, prec, scale int32) (Num, error) {\n+\tvar pscale float32\n+\tif scale >= -76 && scale <= 76 {\n+\t\tpscale = float32PowersOfTen[scale+76]\n+\t} else {\n+\t\tpscale = float32(math.Pow10(int(scale)))\n+\t}\n+\n+\tv *= pscale\n+\tv = float32(math.RoundToEven(float64(v)))\n+\tmaxabs := float32PowersOfTen[prec+76]\n+\tif v <= -maxabs || v >= maxabs {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256(precision=%d, scale=%d): overflow\",\n+\t\t\tv, prec, scale)\n+\t}\n+\n+\tvar arr [4]float32\n+\tarr[3] = float32(math.Floor(math.Ldexp(float64(v), -192)))\n+\tv -= float32(math.Ldexp(float64(arr[3]), 192))\n+\tarr[2] = float32(math.Floor(math.Ldexp(float64(v), -128)))\n+\tv -= float32(math.Ldexp(float64(arr[2]), 128))\n+\tarr[1] = float32(math.Floor(math.Ldexp(float64(v), -64)))\n+\tv -= float32(math.Ldexp(float64(arr[1]), 64))\n+\tarr[0] = v\n+\n+\tdebug.Assert(arr[3] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[3] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\tdebug.Assert(arr[2] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[2] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\tdebug.Assert(arr[1] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[1] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\tdebug.Assert(arr[0] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[0] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\treturn Num{[4]uint64{uint64(arr[0]), uint64(arr[1]), uint64(arr[2]), uint64(arr[3])}}, nil\n+}\n+\n+func FromFloat64(v float64, prec, scale int32) (Num, error) {\n+\tdebug.Assert(prec > 0 && prec <= 76, \"invalid precision for converting to decimal256\")\n+\n+\tif math.IsInf(v, 0) {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256\", v)\n+\t}\n+\n+\tif v < 0 {\n+\t\tdec, err := fromPositiveFloat64(-v, prec, scale)\n+\t\tif err != nil {\n+\t\t\treturn dec, err\n+\t\t}\n+\t\treturn dec.Negate(), nil\n+\t}\n+\treturn fromPositiveFloat64(v, prec, scale)\n+}\n+\n+func fromPositiveFloat64(v float64, prec, scale int32) (Num, error) {\n+\tvar pscale float64\n+\tif scale >= -76 && scale <= 76 {\n+\t\tpscale = float64PowersOfTen[scale+76]\n+\t} else {\n+\t\tpscale = math.Pow10(int(scale))\n+\t}\n+\n+\tv *= pscale\n+\tv = math.RoundToEven(v)\n+\tmaxabs := float64PowersOfTen[prec+76]\n+\tif v <= -maxabs || v >= maxabs {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256(precision=%d, scale=%d): overflow\",\n+\t\t\tv, prec, scale)\n+\t}\n+\n+\tvar arr [4]float64\n+\tarr[3] = math.Floor(math.Ldexp(v, -192))\n+\tv -= math.Ldexp(arr[3], 192)\n+\tarr[2] = math.Floor(math.Ldexp(v, -128))\n+\tv -= math.Ldexp(arr[2], 128)\n+\tarr[1] = math.Floor(math.Ldexp(v, -64))\n+\tv -= math.Ldexp(arr[1], 64)\n+\tarr[0] = v\n+\n+\tdebug.Assert(arr[3] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[3] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\tdebug.Assert(arr[2] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[2] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\tdebug.Assert(arr[1] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[1] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\tdebug.Assert(arr[0] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[0] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\treturn Num{[4]uint64{uint64(arr[0]), uint64(arr[1]), uint64(arr[2]), uint64(arr[3])}}, nil\n+}\n+\n+func (n Num) tofloat32Positive(scale int32) float32 {\n+\tconst twoTo64 float32 = 1.8446744e+19\n+\tif n.arr[3] != 0 || n.arr[2] != 0 {\n+\t\treturn floatInf\n+\t}\n+\tx := float32(n.arr[1]) * twoTo64\n+\tx += float32(n.arr[0])\n+\tif scale >= -76 && scale <= 76 {\n+\t\treturn x * float32PowersOfTen[-scale+76]\n+\t}\n+\n+\treturn x * float32(math.Pow10(-int(scale)))\n+}\n+\n+func (n Num) tofloat64Positive(scale int32) float64 {\n+\tconst (\n+\t\ttwoTo64  float64 = 1.8446744073709552e+19\n+\t\ttwoTo128 float64 = 3.402823669209385e+38\n+\t\ttwoTo192 float64 = 6.277101735386681e+57\n+\t)\n+\n+\tx := float64(n.arr[3]) * twoTo192\n+\tx += float64(n.arr[2]) * twoTo128\n+\tx += float64(n.arr[1]) * twoTo64\n+\tx += float64(n.arr[0])\n+\n+\tif scale >= -76 && scale <= 76 {\n+\t\treturn x * float64PowersOfTen[-scale+76]\n+\t}\n+\n+\treturn x * math.Pow10(-int(scale))\n+}\n+\n+func (n Num) ToFloat32(scale int32) float32 {\n+\tif n.Sign() < 0 {\n+\t\treturn -n.Negate().tofloat32Positive(scale)\n+\t}\n+\treturn n.tofloat32Positive(scale)\n+}\n+\n+func (n Num) ToFloat64(scale int32) float64 {\n+\tif n.Sign() < 0 {\n+\t\treturn -n.Negate().tofloat64Positive(scale)\n+\t}\n+\treturn n.tofloat64Positive(scale)\n+}\n+\n+func (n Num) Sign() int {\n+\tif n == (Num{}) {\n+\t\treturn 0\n+\t}\n+\treturn int(1 | (int64(n.arr[3]) >> 63))\n\nReview Comment:\n   yes, the purpose here was to minimize branching as this could be potentially called frequently. I actually pulled this from code in Go's internals\n\n\n\n",
                    "created": "2022-08-04T16:18:32.054+0000",
                    "updated": "2022-08-04T16:18:32.054+0000",
                    "started": "2022-08-04T16:18:32.053+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "798100",
                    "issueId": "13340743"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340743/worklog/798101",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #13792:\nURL: https://github.com/apache/arrow/pull/13792#discussion_r938000985\n\n\n##########\ngo/arrow/decimal256/decimal256.go:\n##########\n@@ -0,0 +1,569 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package decimal256\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"math\"\n+\t\"math/big\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow/decimal128\"\n+\t\"github.com/apache/arrow/go/v10/arrow/internal/debug\"\n+)\n+\n+const (\n+\tMaxPrecision = 76\n+\tMaxScale     = 76\n+)\n+\n+type Num struct {\n+\t// arr[0] is the lowest bits, arr[3] is the highest bits\n+\tarr [4]uint64\n+}\n+\n+// New returns a new signed 256-bit integer value where x1 contains\n+// the highest bits with the rest of the values in order down to the\n+// lowest bits\n+//\n+//   ie: New(1, 2, 3, 4) returns with the elements in little-endian order\n+//       {4, 3, 2, 1} but each value is still represented as the native endianness\n+func New(x1, x2, x3, x4 uint64) Num {\n+\treturn Num{[4]uint64{x4, x3, x2, x1}}\n+}\n+\n+func (n Num) Array() [4]uint64 { return n.arr }\n+\n+func (n Num) LowBits() uint64 { return n.arr[0] }\n+\n+func FromDecimal128(n decimal128.Num) Num {\n+\tvar topBits uint64\n+\tif n.Sign() < 0 {\n+\t\ttopBits = math.MaxUint64\n+\t}\n+\treturn New(topBits, topBits, uint64(n.HighBits()), n.LowBits())\n+}\n+\n+func FromU64(v uint64) Num {\n+\treturn Num{[4]uint64{v, 0, 0, 0}}\n+}\n+\n+func FromI64(v int64) Num {\n+\tswitch {\n+\tcase v > 0:\n+\t\treturn New(0, 0, 0, uint64(v))\n+\tcase v < 0:\n+\t\treturn New(math.MaxUint64, math.MaxUint64, math.MaxUint64, uint64(v))\n+\tdefault:\n+\t\treturn Num{}\n+\t}\n+}\n+\n+func (n Num) Negate() Num {\n+\tvar carry uint64 = 1\n+\tfor i := range n.arr {\n+\t\tn.arr[i] = ^n.arr[i] + carry\n+\t\tif n.arr[i] != 0 {\n+\t\t\tcarry = 0\n+\t\t}\n+\t}\n+\treturn n\n+}\n+\n+func FromFloat32(v float32, prec, scale int32) (Num, error) {\n+\tdebug.Assert(prec > 0 && prec <= 76, \"invalid precision for converting to decimal256\")\n+\n+\tif math.IsInf(float64(v), 0) {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256\", v)\n+\t}\n+\n+\tif v < 0 {\n+\t\tdec, err := fromPositiveFloat32(-v, prec, scale)\n+\t\tif err != nil {\n+\t\t\treturn dec, err\n+\t\t}\n+\t\treturn dec.Negate(), nil\n+\t}\n+\treturn fromPositiveFloat32(v, prec, scale)\n+}\n+\n+func fromPositiveFloat32(v float32, prec, scale int32) (Num, error) {\n+\tvar pscale float32\n+\tif scale >= -76 && scale <= 76 {\n+\t\tpscale = float32PowersOfTen[scale+76]\n+\t} else {\n+\t\tpscale = float32(math.Pow10(int(scale)))\n+\t}\n+\n+\tv *= pscale\n+\tv = float32(math.RoundToEven(float64(v)))\n+\tmaxabs := float32PowersOfTen[prec+76]\n+\tif v <= -maxabs || v >= maxabs {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256(precision=%d, scale=%d): overflow\",\n+\t\t\tv, prec, scale)\n+\t}\n+\n+\tvar arr [4]float32\n+\tarr[3] = float32(math.Floor(math.Ldexp(float64(v), -192)))\n+\tv -= float32(math.Ldexp(float64(arr[3]), 192))\n+\tarr[2] = float32(math.Floor(math.Ldexp(float64(v), -128)))\n+\tv -= float32(math.Ldexp(float64(arr[2]), 128))\n+\tarr[1] = float32(math.Floor(math.Ldexp(float64(v), -64)))\n+\tv -= float32(math.Ldexp(float64(arr[1]), 64))\n+\tarr[0] = v\n+\n+\tdebug.Assert(arr[3] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[3] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\tdebug.Assert(arr[2] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[2] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\tdebug.Assert(arr[1] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[1] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\tdebug.Assert(arr[0] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[0] < 1.8446744e+19, \"bad conversion float32 to decimal256\") // 2**64\n+\treturn Num{[4]uint64{uint64(arr[0]), uint64(arr[1]), uint64(arr[2]), uint64(arr[3])}}, nil\n+}\n+\n+func FromFloat64(v float64, prec, scale int32) (Num, error) {\n+\tdebug.Assert(prec > 0 && prec <= 76, \"invalid precision for converting to decimal256\")\n+\n+\tif math.IsInf(v, 0) {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256\", v)\n+\t}\n+\n+\tif v < 0 {\n+\t\tdec, err := fromPositiveFloat64(-v, prec, scale)\n+\t\tif err != nil {\n+\t\t\treturn dec, err\n+\t\t}\n+\t\treturn dec.Negate(), nil\n+\t}\n+\treturn fromPositiveFloat64(v, prec, scale)\n+}\n+\n+func fromPositiveFloat64(v float64, prec, scale int32) (Num, error) {\n+\tvar pscale float64\n+\tif scale >= -76 && scale <= 76 {\n+\t\tpscale = float64PowersOfTen[scale+76]\n+\t} else {\n+\t\tpscale = math.Pow10(int(scale))\n+\t}\n+\n+\tv *= pscale\n+\tv = math.RoundToEven(v)\n+\tmaxabs := float64PowersOfTen[prec+76]\n+\tif v <= -maxabs || v >= maxabs {\n+\t\treturn Num{}, fmt.Errorf(\"cannot convert %f to decimal256(precision=%d, scale=%d): overflow\",\n+\t\t\tv, prec, scale)\n+\t}\n+\n+\tvar arr [4]float64\n+\tarr[3] = math.Floor(math.Ldexp(v, -192))\n+\tv -= math.Ldexp(arr[3], 192)\n+\tarr[2] = math.Floor(math.Ldexp(v, -128))\n+\tv -= math.Ldexp(arr[2], 128)\n+\tarr[1] = math.Floor(math.Ldexp(v, -64))\n+\tv -= math.Ldexp(arr[1], 64)\n+\tarr[0] = v\n+\n+\tdebug.Assert(arr[3] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[3] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\tdebug.Assert(arr[2] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[2] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\tdebug.Assert(arr[1] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[1] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\tdebug.Assert(arr[0] >= 0, \"bad conversion float64 to decimal256\")\n+\tdebug.Assert(arr[0] < 1.8446744073709552e+19, \"bad conversion float64 to decimal256\") // 2**64\n+\treturn Num{[4]uint64{uint64(arr[0]), uint64(arr[1]), uint64(arr[2]), uint64(arr[3])}}, nil\n+}\n+\n+func (n Num) tofloat32Positive(scale int32) float32 {\n+\tconst twoTo64 float32 = 1.8446744e+19\n+\tif n.arr[3] != 0 || n.arr[2] != 0 {\n+\t\treturn floatInf\n+\t}\n+\tx := float32(n.arr[1]) * twoTo64\n+\tx += float32(n.arr[0])\n+\tif scale >= -76 && scale <= 76 {\n+\t\treturn x * float32PowersOfTen[-scale+76]\n+\t}\n+\n+\treturn x * float32(math.Pow10(-int(scale)))\n+}\n+\n+func (n Num) tofloat64Positive(scale int32) float64 {\n+\tconst (\n+\t\ttwoTo64  float64 = 1.8446744073709552e+19\n+\t\ttwoTo128 float64 = 3.402823669209385e+38\n+\t\ttwoTo192 float64 = 6.277101735386681e+57\n+\t)\n+\n+\tx := float64(n.arr[3]) * twoTo192\n+\tx += float64(n.arr[2]) * twoTo128\n+\tx += float64(n.arr[1]) * twoTo64\n+\tx += float64(n.arr[0])\n+\n+\tif scale >= -76 && scale <= 76 {\n+\t\treturn x * float64PowersOfTen[-scale+76]\n+\t}\n+\n+\treturn x * math.Pow10(-int(scale))\n+}\n+\n+func (n Num) ToFloat32(scale int32) float32 {\n+\tif n.Sign() < 0 {\n+\t\treturn -n.Negate().tofloat32Positive(scale)\n+\t}\n+\treturn n.tofloat32Positive(scale)\n+}\n+\n+func (n Num) ToFloat64(scale int32) float64 {\n+\tif n.Sign() < 0 {\n+\t\treturn -n.Negate().tofloat64Positive(scale)\n+\t}\n+\treturn n.tofloat64Positive(scale)\n+}\n+\n+func (n Num) Sign() int {\n+\tif n == (Num{}) {\n+\t\treturn 0\n+\t}\n+\treturn int(1 | (int64(n.arr[3]) >> 63))\n+}\n+\n+func FromBigInt(v *big.Int) (n Num) {\n+\tbitlen := v.BitLen()\n+\tif bitlen > 256 {\n\nReview Comment:\n   that's a good point. `big.Int` actually stores the sign as a separate bool with the value, so the `BitLen()` call wouldn't account for the sign bit already, I was assuming it would.\n\n\n\n",
                    "created": "2022-08-04T16:20:57.069+0000",
                    "updated": "2022-08-04T16:20:57.069+0000",
                    "started": "2022-08-04T16:20:57.069+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "798101",
                    "issueId": "13340743"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340743/worklog/798102",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #13792:\nURL: https://github.com/apache/arrow/pull/13792#discussion_r938003969\n\n\n##########\ngo/arrow/array/decimal256_test.go:\n##########\n@@ -0,0 +1,179 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array_test\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/array\"\n+\t\"github.com/apache/arrow/go/v10/arrow/decimal256\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func TestNewDecimal256Builder(t *testing.T) {\n+\tmem := memory.NewCheckedAllocator(memory.NewGoAllocator())\n+\tdefer mem.AssertSize(t, 0)\n+\n+\tab := array.NewDecimal256Builder(mem, &arrow.Decimal256Type{Precision: 10, Scale: 1})\n+\tdefer ab.Release()\n+\n+\tab.Retain()\n+\tab.Release()\n+\n+\twant := []decimal256.Num{\n+\t\tdecimal256.New(1, 1, 1, 1),\n+\t\tdecimal256.New(2, 2, 2, 2),\n+\t\tdecimal256.New(3, 3, 3, 3),\n+\t\t{},\n+\t\tdecimal256.FromI64(-5),\n+\t\tdecimal256.FromI64(-6),\n+\t\t{},\n+\t\tdecimal256.FromI64(8),\n+\t\tdecimal256.FromI64(9),\n+\t\tdecimal256.FromI64(10),\n+\t}\n+\tvalids := []bool{true, true, true, false, true, true, false, true, true, true}\n+\n+\tfor i, valid := range valids {\n+\t\tswitch {\n+\t\tcase valid:\n+\t\t\tab.Append(want[i])\n+\t\tdefault:\n+\t\t\tab.AppendNull()\n+\t\t}\n+\t}\n+\n+\t// check state of builder before NewDecimal256Array\n+\tassert.Equal(t, 10, ab.Len(), \"unexpected Len()\")\n+\tassert.Equal(t, 2, ab.NullN(), \"unexpected NullN()\")\n+\n+\ta := ab.NewArray().(*array.Decimal256)\n+\ta.Retain()\n+\ta.Release()\n+\n+\t// check state of builder after NewDecimal256Array\n+\tassert.Zero(t, ab.Len(), \"unexpected ArrayBuilder.Len(), NewDecimal256Array did not reset state\")\n+\tassert.Zero(t, ab.Cap(), \"unexpected ArrayBuilder.Cap(), NewDecimal256Array did not reset state\")\n+\tassert.Zero(t, ab.NullN(), \"unexpected ArrayBuilder.NullN(), NewDecimal256Array did not reset state\")\n+\n+\t// check state of array\n+\tassert.Equal(t, 2, a.NullN(), \"unexpected null count\")\n+\n+\tassert.Equal(t, want, a.Values(), \"unexpected Decimal256Values\")\n+\tassert.Equal(t, []byte{0xb7}, a.NullBitmapBytes()[:1]) // 4 bytes due to minBuilderCapacity\n+\tassert.Len(t, a.Values(), 10, \"unexpected length of Decimal256Values\")\n+\n+\ta.Release()\n+\tab.Append(decimal256.FromI64(7))\n+\tab.Append(decimal256.FromI64(8))\n+\n+\ta = ab.NewDecimal256Array()\n+\n+\tassert.Equal(t, 0, a.NullN())\n+\tassert.Equal(t, []decimal256.Num{decimal256.FromI64(7), decimal256.FromI64(8)}, a.Values())\n+\tassert.Len(t, a.Values(), 2)\n\nReview Comment:\n   yea that's easy to add.\n\n\n\n",
                    "created": "2022-08-04T16:24:07.171+0000",
                    "updated": "2022-08-04T16:24:07.171+0000",
                    "started": "2022-08-04T16:24:07.170+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "798102",
                    "issueId": "13340743"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340743/worklog/798107",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #13792:\nURL: https://github.com/apache/arrow/pull/13792#discussion_r938023186\n\n\n##########\ngo/arrow/array/decimal256_test.go:\n##########\n@@ -0,0 +1,179 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array_test\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/array\"\n+\t\"github.com/apache/arrow/go/v10/arrow/decimal256\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func TestNewDecimal256Builder(t *testing.T) {\n+\tmem := memory.NewCheckedAllocator(memory.NewGoAllocator())\n+\tdefer mem.AssertSize(t, 0)\n+\n+\tab := array.NewDecimal256Builder(mem, &arrow.Decimal256Type{Precision: 10, Scale: 1})\n+\tdefer ab.Release()\n+\n+\tab.Retain()\n+\tab.Release()\n+\n+\twant := []decimal256.Num{\n+\t\tdecimal256.New(1, 1, 1, 1),\n+\t\tdecimal256.New(2, 2, 2, 2),\n+\t\tdecimal256.New(3, 3, 3, 3),\n+\t\t{},\n+\t\tdecimal256.FromI64(-5),\n+\t\tdecimal256.FromI64(-6),\n+\t\t{},\n+\t\tdecimal256.FromI64(8),\n+\t\tdecimal256.FromI64(9),\n+\t\tdecimal256.FromI64(10),\n+\t}\n+\tvalids := []bool{true, true, true, false, true, true, false, true, true, true}\n+\n+\tfor i, valid := range valids {\n+\t\tswitch {\n+\t\tcase valid:\n+\t\t\tab.Append(want[i])\n+\t\tdefault:\n+\t\t\tab.AppendNull()\n+\t\t}\n+\t}\n+\n+\t// check state of builder before NewDecimal256Array\n+\tassert.Equal(t, 10, ab.Len(), \"unexpected Len()\")\n+\tassert.Equal(t, 2, ab.NullN(), \"unexpected NullN()\")\n+\n+\ta := ab.NewArray().(*array.Decimal256)\n+\ta.Retain()\n+\ta.Release()\n+\n+\t// check state of builder after NewDecimal256Array\n+\tassert.Zero(t, ab.Len(), \"unexpected ArrayBuilder.Len(), NewDecimal256Array did not reset state\")\n+\tassert.Zero(t, ab.Cap(), \"unexpected ArrayBuilder.Cap(), NewDecimal256Array did not reset state\")\n+\tassert.Zero(t, ab.NullN(), \"unexpected ArrayBuilder.NullN(), NewDecimal256Array did not reset state\")\n+\n+\t// check state of array\n+\tassert.Equal(t, 2, a.NullN(), \"unexpected null count\")\n+\n+\tassert.Equal(t, want, a.Values(), \"unexpected Decimal256Values\")\n+\tassert.Equal(t, []byte{0xb7}, a.NullBitmapBytes()[:1]) // 4 bytes due to minBuilderCapacity\n+\tassert.Len(t, a.Values(), 10, \"unexpected length of Decimal256Values\")\n+\n+\ta.Release()\n+\tab.Append(decimal256.FromI64(7))\n+\tab.Append(decimal256.FromI64(8))\n+\n+\ta = ab.NewDecimal256Array()\n+\n+\tassert.Equal(t, 0, a.NullN())\n+\tassert.Equal(t, []decimal256.Num{decimal256.FromI64(7), decimal256.FromI64(8)}, a.Values())\n+\tassert.Len(t, a.Values(), 2)\n\nReview Comment:\n   for reference, they *are* tested in the new tests I added in `decimal_test.go` but I'll also add those assertions here too.\n\n\n\n",
                    "created": "2022-08-04T16:37:33.433+0000",
                    "updated": "2022-08-04T16:37:33.433+0000",
                    "started": "2022-08-04T16:37:33.433+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "798107",
                    "issueId": "13340743"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340743/worklog/798111",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #13792:\nURL: https://github.com/apache/arrow/pull/13792#discussion_r938032356\n\n\n##########\ngo/arrow/scalar/scalar.go:\n##########\n@@ -311,6 +314,50 @@ func NewDecimal128Scalar(val decimal128.Num, typ arrow.DataType) *Decimal128 {\n \treturn &Decimal128{scalar{typ, true}, val}\n }\n \n+type Decimal256 struct {\n+\tscalar\n+\tValue decimal256.Num\n+}\n+\n+func (s *Decimal256) value() interface{} { return s.Value }\n+\n+func (s *Decimal256) String() string {\n+\tif !s.Valid {\n+\t\treturn \"null\"\n+\t}\n+\tval, err := s.CastTo(arrow.BinaryTypes.String)\n+\tif err != nil {\n+\t\treturn \"...\"\n+\t}\n+\treturn string(val.(*String).Value.Bytes())\n+}\n+\n+func (s *Decimal256) equals(rhs Scalar) bool {\n+\treturn s.Value == rhs.(*Decimal256).Value\n+}\n+\n+func (s *Decimal256) CastTo(to arrow.DataType) (Scalar, error) {\n+\tif !s.Valid {\n+\t\treturn MakeNullScalar(to), nil\n+\t}\n+\n+\tswitch to.ID() {\n+\tcase arrow.DECIMAL256:\n+\t\treturn NewDecimal256Scalar(s.Value, to), nil\n\nReview Comment:\n   fixed this, calling `Rescale` and `FitsInPrecision`\n\n\n\n",
                    "created": "2022-08-04T16:47:24.219+0000",
                    "updated": "2022-08-04T16:47:24.219+0000",
                    "started": "2022-08-04T16:47:24.219+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "798111",
                    "issueId": "13340743"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340743/worklog/798112",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #13792:\nURL: https://github.com/apache/arrow/pull/13792#discussion_r938032587\n\n\n##########\ngo/arrow/scalar/scalar.go:\n##########\n@@ -297,6 +298,8 @@ func (s *Decimal128) CastTo(to arrow.DataType) (Scalar, error) {\n \tswitch to.ID() {\n \tcase arrow.DECIMAL128:\n \t\treturn NewDecimal128Scalar(s.Value, to), nil\n+\tcase arrow.DECIMAL256:\n+\t\treturn NewDecimal256Scalar(decimal256.FromDecimal128(s.Value), to), nil\n\nReview Comment:\n   fixed calling `Rescale` and `FitsInPrecision`\n\n\n\n",
                    "created": "2022-08-04T16:47:39.413+0000",
                    "updated": "2022-08-04T16:47:39.413+0000",
                    "started": "2022-08-04T16:47:39.412+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "798112",
                    "issueId": "13340743"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340743/worklog/798158",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on PR #13792:\nURL: https://github.com/apache/arrow/pull/13792#issuecomment-1205701290\n\n   I'm gonna bug you again @wolfeidau to have a look as we still lack many Go developers here who can take a look at these. :smile: After this, the union PR and one more PR afterwards (implementing unions in the IPC handling) Go will officially support all of the Arrow data types!\n\n\n",
                    "created": "2022-08-04T19:49:50.877+0000",
                    "updated": "2022-08-04T19:49:50.877+0000",
                    "started": "2022-08-04T19:49:50.876+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "798158",
                    "issueId": "13340743"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340743/worklog/798275",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wolfeidau commented on code in PR #13792:\nURL: https://github.com/apache/arrow/pull/13792#discussion_r938457832\n\n\n##########\ngo/arrow/array/decimal256.go:\n##########\n@@ -0,0 +1,331 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"math\"\n+\t\"math/big\"\n+\t\"reflect\"\n+\t\"strings\"\n+\t\"sync/atomic\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/bitutil\"\n+\t\"github.com/apache/arrow/go/v10/arrow/decimal256\"\n+\t\"github.com/apache/arrow/go/v10/arrow/internal/debug\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"github.com/goccy/go-json\"\n+)\n+\n+// Decimal256 is a type that represents an immutable sequence of 256-bit decimal values.\n+type Decimal256 struct {\n+\tarray\n+\n+\tvalues []decimal256.Num\n+}\n+\n+func NewDecimal256Data(data arrow.ArrayData) *Decimal256 {\n+\ta := &Decimal256{}\n+\ta.refCount = 1\n+\ta.setData(data.(*Data))\n+\treturn a\n+}\n+\n+func (a *Decimal256) Value(i int) decimal256.Num { return a.values[i] }\n+\n+func (a *Decimal256) Values() []decimal256.Num { return a.values }\n+\n+func (a *Decimal256) String() string {\n+\to := new(strings.Builder)\n+\to.WriteString(\"[\")\n+\tfor i := 0; i < a.Len(); i++ {\n+\t\tif i > 0 {\n+\t\t\tfmt.Fprintf(o, \" \")\n+\t\t}\n+\t\tswitch {\n+\t\tcase a.IsNull(i):\n+\t\t\to.WriteString(\"(null)\")\n+\t\tdefault:\n+\t\t\tfmt.Fprintf(o, \"%v\", a.Value(i))\n+\t\t}\n+\t}\n+\to.WriteString(\"]\")\n+\treturn o.String()\n+}\n+\n+func (a *Decimal256) setData(data *Data) {\n+\ta.array.setData(data)\n+\tvals := data.buffers[1]\n+\tif vals != nil {\n+\t\ta.values = arrow.Decimal256Traits.CastFromBytes(vals.Bytes())\n+\t\tbeg := a.array.data.offset\n+\t\tend := beg + a.array.data.length\n+\t\ta.values = a.values[beg:end]\n+\t}\n+}\n+\n+func (a *Decimal256) getOneForMarshal(i int) interface{} {\n+\tif a.IsNull(i) {\n+\t\treturn nil\n+\t}\n+\n+\ttyp := a.DataType().(*arrow.Decimal256Type)\n+\tf := (&big.Float{}).SetInt(a.Value(i).BigInt())\n+\tf.Quo(f, big.NewFloat(math.Pow10(int(typ.Scale))))\n+\treturn f.Text('g', int(typ.Precision))\n+}\n+\n+func (a *Decimal256) MarshalJSON() ([]byte, error) {\n+\tvals := make([]interface{}, a.Len())\n+\tfor i := 0; i < a.Len(); i++ {\n+\t\tvals[i] = a.getOneForMarshal(i)\n+\t}\n+\treturn json.Marshal(vals)\n+}\n+\n+func arrayEqualDecimal256(left, right *Decimal256) bool {\n+\tfor i := 0; i < left.Len(); i++ {\n+\t\tif left.IsNull(i) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif left.Value(i) != right.Value(i) {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+type Decimal256Builder struct {\n+\tbuilder\n+\n+\tdtype   *arrow.Decimal256Type\n+\tdata    *memory.Buffer\n+\trawData []decimal256.Num\n+}\n+\n+func NewDecimal256Builder(mem memory.Allocator, dtype *arrow.Decimal256Type) *Decimal256Builder {\n+\treturn &Decimal256Builder{\n+\t\tbuilder: builder{refCount: 1, mem: mem},\n+\t\tdtype:   dtype,\n+\t}\n+}\n+\n+// Release decreases the reference count by 1.\n+// When the reference count goes to zero, the memory is freed.\n+func (b *Decimal256Builder) Release() {\n+\tdebug.Assert(atomic.LoadInt64(&b.refCount) > 0, \"too many releases\")\n+\n+\tif atomic.AddInt64(&b.refCount, -1) == 0 {\n+\t\tif b.nullBitmap != nil {\n+\t\t\tb.nullBitmap.Release()\n+\t\t\tb.nullBitmap = nil\n+\t\t}\n+\t\tif b.data != nil {\n+\t\t\tb.data.Release()\n+\t\t\tb.data = nil\n+\t\t\tb.rawData = nil\n+\t\t}\n+\t}\n+}\n+\n+func (b *Decimal256Builder) Append(v decimal256.Num) {\n+\tb.Reserve(1)\n+\tb.UnsafeAppend(v)\n+}\n+\n+func (b *Decimal256Builder) UnsafeAppend(v decimal256.Num) {\n+\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\tb.rawData[b.length] = v\n+\tb.length++\n+}\n+\n+func (b *Decimal256Builder) AppendNull() {\n+\tb.Reserve(1)\n+\tb.UnsafeAppendBoolToBitmap(false)\n+}\n+\n+func (b *Decimal256Builder) AppendEmptyValue() {\n+\tb.Append(decimal256.Num{})\n+}\n+\n+func (b *Decimal256Builder) UnsafeAppendBoolToBitmap(isValid bool) {\n+\tif isValid {\n+\t\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\t} else {\n+\t\tb.nulls++\n+\t}\n+\tb.length++\n+}\n+\n+// AppendValues will append the values in the v slice. The valid slice determines which values\n+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,\n+// all values in v are appended and considered valid.\n+func (b *Decimal256Builder) AppendValues(v []decimal256.Num, valid []bool) {\n+\tif len(v) != len(valid) && len(valid) != 0 {\n+\t\tpanic(\"len(v) != len(valid) && len(valid) != 0\")\n\nReview Comment:\n   Is this missing the convention i have seen with the message being prefixed by \"arrow: \"?\n\n\n\n",
                    "created": "2022-08-05T05:39:14.765+0000",
                    "updated": "2022-08-05T05:39:14.765+0000",
                    "started": "2022-08-05T05:39:14.765+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "798275",
                    "issueId": "13340743"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340743/worklog/798286",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on PR #13792:\nURL: https://github.com/apache/arrow/pull/13792#issuecomment-1206094557\n\n   There seem to be a lot of Go CI failures suddenly.\n\n\n",
                    "created": "2022-08-05T06:33:54.033+0000",
                    "updated": "2022-08-05T06:33:54.033+0000",
                    "started": "2022-08-05T06:33:54.032+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "798286",
                    "issueId": "13340743"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340743/worklog/798434",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on PR #13792:\nURL: https://github.com/apache/arrow/pull/13792#issuecomment-1206512940\n\n   @pitrou Yea, when I merged the Union type PR it added new requirements to the Builder types which I hadn't implemented in the `Decimal256Builder` so the build failed. I just had to add the new required interface methods to the `Decimal256Builder` and now all should be good.\n\n\n",
                    "created": "2022-08-05T14:21:09.314+0000",
                    "updated": "2022-08-05T14:21:09.314+0000",
                    "started": "2022-08-05T14:21:09.313+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "798434",
                    "issueId": "13340743"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340743/worklog/798435",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #13792:\nURL: https://github.com/apache/arrow/pull/13792#discussion_r938868506\n\n\n##########\ngo/arrow/array/decimal256.go:\n##########\n@@ -0,0 +1,331 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"math\"\n+\t\"math/big\"\n+\t\"reflect\"\n+\t\"strings\"\n+\t\"sync/atomic\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/bitutil\"\n+\t\"github.com/apache/arrow/go/v10/arrow/decimal256\"\n+\t\"github.com/apache/arrow/go/v10/arrow/internal/debug\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"github.com/goccy/go-json\"\n+)\n+\n+// Decimal256 is a type that represents an immutable sequence of 256-bit decimal values.\n+type Decimal256 struct {\n+\tarray\n+\n+\tvalues []decimal256.Num\n+}\n+\n+func NewDecimal256Data(data arrow.ArrayData) *Decimal256 {\n+\ta := &Decimal256{}\n+\ta.refCount = 1\n+\ta.setData(data.(*Data))\n+\treturn a\n+}\n+\n+func (a *Decimal256) Value(i int) decimal256.Num { return a.values[i] }\n+\n+func (a *Decimal256) Values() []decimal256.Num { return a.values }\n+\n+func (a *Decimal256) String() string {\n+\to := new(strings.Builder)\n+\to.WriteString(\"[\")\n+\tfor i := 0; i < a.Len(); i++ {\n+\t\tif i > 0 {\n+\t\t\tfmt.Fprintf(o, \" \")\n+\t\t}\n+\t\tswitch {\n+\t\tcase a.IsNull(i):\n+\t\t\to.WriteString(\"(null)\")\n+\t\tdefault:\n+\t\t\tfmt.Fprintf(o, \"%v\", a.Value(i))\n+\t\t}\n+\t}\n+\to.WriteString(\"]\")\n+\treturn o.String()\n+}\n+\n+func (a *Decimal256) setData(data *Data) {\n+\ta.array.setData(data)\n+\tvals := data.buffers[1]\n+\tif vals != nil {\n+\t\ta.values = arrow.Decimal256Traits.CastFromBytes(vals.Bytes())\n+\t\tbeg := a.array.data.offset\n+\t\tend := beg + a.array.data.length\n+\t\ta.values = a.values[beg:end]\n+\t}\n+}\n+\n+func (a *Decimal256) getOneForMarshal(i int) interface{} {\n+\tif a.IsNull(i) {\n+\t\treturn nil\n+\t}\n+\n+\ttyp := a.DataType().(*arrow.Decimal256Type)\n+\tf := (&big.Float{}).SetInt(a.Value(i).BigInt())\n+\tf.Quo(f, big.NewFloat(math.Pow10(int(typ.Scale))))\n+\treturn f.Text('g', int(typ.Precision))\n+}\n+\n+func (a *Decimal256) MarshalJSON() ([]byte, error) {\n+\tvals := make([]interface{}, a.Len())\n+\tfor i := 0; i < a.Len(); i++ {\n+\t\tvals[i] = a.getOneForMarshal(i)\n+\t}\n+\treturn json.Marshal(vals)\n+}\n+\n+func arrayEqualDecimal256(left, right *Decimal256) bool {\n+\tfor i := 0; i < left.Len(); i++ {\n+\t\tif left.IsNull(i) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif left.Value(i) != right.Value(i) {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+type Decimal256Builder struct {\n+\tbuilder\n+\n+\tdtype   *arrow.Decimal256Type\n+\tdata    *memory.Buffer\n+\trawData []decimal256.Num\n+}\n+\n+func NewDecimal256Builder(mem memory.Allocator, dtype *arrow.Decimal256Type) *Decimal256Builder {\n+\treturn &Decimal256Builder{\n+\t\tbuilder: builder{refCount: 1, mem: mem},\n+\t\tdtype:   dtype,\n+\t}\n+}\n+\n+// Release decreases the reference count by 1.\n+// When the reference count goes to zero, the memory is freed.\n+func (b *Decimal256Builder) Release() {\n+\tdebug.Assert(atomic.LoadInt64(&b.refCount) > 0, \"too many releases\")\n+\n+\tif atomic.AddInt64(&b.refCount, -1) == 0 {\n+\t\tif b.nullBitmap != nil {\n+\t\t\tb.nullBitmap.Release()\n+\t\t\tb.nullBitmap = nil\n+\t\t}\n+\t\tif b.data != nil {\n+\t\t\tb.data.Release()\n+\t\t\tb.data = nil\n+\t\t\tb.rawData = nil\n+\t\t}\n+\t}\n+}\n+\n+func (b *Decimal256Builder) Append(v decimal256.Num) {\n+\tb.Reserve(1)\n+\tb.UnsafeAppend(v)\n+}\n+\n+func (b *Decimal256Builder) UnsafeAppend(v decimal256.Num) {\n+\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\tb.rawData[b.length] = v\n+\tb.length++\n+}\n+\n+func (b *Decimal256Builder) AppendNull() {\n+\tb.Reserve(1)\n+\tb.UnsafeAppendBoolToBitmap(false)\n+}\n+\n+func (b *Decimal256Builder) AppendEmptyValue() {\n+\tb.Append(decimal256.Num{})\n+}\n+\n+func (b *Decimal256Builder) UnsafeAppendBoolToBitmap(isValid bool) {\n+\tif isValid {\n+\t\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\t} else {\n+\t\tb.nulls++\n+\t}\n+\tb.length++\n+}\n+\n+// AppendValues will append the values in the v slice. The valid slice determines which values\n+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,\n+// all values in v are appended and considered valid.\n+func (b *Decimal256Builder) AppendValues(v []decimal256.Num, valid []bool) {\n+\tif len(v) != len(valid) && len(valid) != 0 {\n+\t\tpanic(\"len(v) != len(valid) && len(valid) != 0\")\n\nReview Comment:\n   good point! I've added the prefixes.\r\n   \r\n   Thanks for the reviews! technically Go has better Type support than C++ now! Since C++ doesn't support Float16 lol!\n\n\n\n",
                    "created": "2022-08-05T14:22:04.540+0000",
                    "updated": "2022-08-05T14:22:04.540+0000",
                    "started": "2022-08-05T14:22:04.540+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "798435",
                    "issueId": "13340743"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340743/worklog/798474",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade merged PR #13792:\nURL: https://github.com/apache/arrow/pull/13792\n\n\n",
                    "created": "2022-08-05T16:28:04.791+0000",
                    "updated": "2022-08-05T16:28:04.791+0000",
                    "started": "2022-08-05T16:28:04.791+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "798474",
                    "issueId": "13340743"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340743/worklog/798520",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot commented on PR #13792:\nURL: https://github.com/apache/arrow/pull/13792#issuecomment-1206749253\n\n   Benchmark runs are scheduled for baseline = 6a3fb97a9a5ebd0316af050fec5cb4157d35f296 and contender = 6d1bc624454b8a83e5c90410b51c2718059c394b. 6d1bc624454b8a83e5c90410b51c2718059c394b is a master commit associated with this PR. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Finished :arrow_down:0.0% :arrow_up:0.0%] [ec2-t3-xlarge-us-east-2](https://conbench.ursa.dev/compare/runs/49383f8924664c0caf72b98f3363b7f3...1d0e917d6c4a4ac68f5cd3621ce1f9c9/)\n   [Failed :arrow_down:0.14% :arrow_up:0.71%] [test-mac-arm](https://conbench.ursa.dev/compare/runs/3e9b9289df0c4f23927b15a3378dc402...d41eb22b6e8441fa9147066907132fdd/)\n   [Finished :arrow_down:0.0% :arrow_up:0.0%] [ursa-i9-9960x](https://conbench.ursa.dev/compare/runs/ec561d0a7ff84acc96a62a5473166c46...cc01d11744a94365b4c9e143ce9bcb3f/)\n   [Finished :arrow_down:0.39% :arrow_up:0.92%] [ursa-thinkcentre-m75q](https://conbench.ursa.dev/compare/runs/c4dcc757e0a04beb9c9a8a8bfe63ed3c...b7243ba3067e406a894ec47255bbdc2a/)\n   Buildkite builds:\n   [Finished] [`6d1bc624` ec2-t3-xlarge-us-east-2](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ec2-t3-xlarge-us-east-2/builds/1260)\n   [Failed] [`6d1bc624` test-mac-arm](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-test-mac-arm/builds/1272)\n   [Finished] [`6d1bc624` ursa-i9-9960x](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-i9-9960x/builds/1255)\n   [Finished] [`6d1bc624` ursa-thinkcentre-m75q](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-thinkcentre-m75q/builds/1274)\n   [Finished] [`6a3fb97a` ec2-t3-xlarge-us-east-2](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ec2-t3-xlarge-us-east-2/builds/1259)\n   [Finished] [`6a3fb97a` test-mac-arm](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-test-mac-arm/builds/1271)\n   [Finished] [`6a3fb97a` ursa-i9-9960x](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-i9-9960x/builds/1254)\n   [Finished] [`6a3fb97a` ursa-thinkcentre-m75q](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-thinkcentre-m75q/builds/1273)\n   Supported benchmarks:\n   ec2-t3-xlarge-us-east-2: Supported benchmark langs: Python, R. Runs only benchmarks with cloud = True\n   test-mac-arm: Supported benchmark langs: C++, Python, R\n   ursa-i9-9960x: Supported benchmark langs: Python, R, JavaScript\n   ursa-thinkcentre-m75q: Supported benchmark langs: C++, Java\n   \n\n\n",
                    "created": "2022-08-05T18:41:42.301+0000",
                    "updated": "2022-08-05T18:41:42.301+0000",
                    "started": "2022-08-05T18:41:42.301+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "798520",
                    "issueId": "13340743"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340743/worklog/798521",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot commented on PR #13792:\nURL: https://github.com/apache/arrow/pull/13792#issuecomment-1206749395\n\n   ['Python', 'R'] benchmarks have high level of regressions.\n   [test-mac-arm](https://conbench.ursa.dev/compare/runs/3e9b9289df0c4f23927b15a3378dc402...d41eb22b6e8441fa9147066907132fdd/)\n   \n\n\n",
                    "created": "2022-08-05T18:41:56.511+0000",
                    "updated": "2022-08-05T18:41:56.511+0000",
                    "started": "2022-08-05T18:41:56.510+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "798521",
                    "issueId": "13340743"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 10800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@2ff0b613[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5a118cf6[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2539ee2e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@7319b043[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@79f90eba[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@6ab604a5[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@94df43[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@3e31ecba[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@f8cb918[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@55c50760[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@730db45c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@42e8d2bb[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 10800,
        "customfield_12312520": null,
        "customfield_12312521": "Fri Aug 05 16:28:05 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-08-05T16:28:05.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10600/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-11-16T04:11:18.000+0000",
        "updated": "2022-08-05T18:41:56.000+0000",
        "timeoriginalestimate": null,
        "description": "Decimal with 256 bit precision is now allowed in the spec with a basic implementation in Java and C++.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "3h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 10800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Go] Support Decimal256 type",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340743/comment/17575942",
                    "id": "17575942",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=zeroshade",
                        "name": "zeroshade",
                        "key": "zeroshade",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=zeroshade&avatarId=31230",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=zeroshade&avatarId=31230",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=zeroshade&avatarId=31230",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=zeroshade&avatarId=31230"
                        },
                        "displayName": "Matthew Topol",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 13792\n[https://github.com/apache/arrow/pull/13792]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=zeroshade",
                        "name": "zeroshade",
                        "key": "zeroshade",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=zeroshade&avatarId=31230",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=zeroshade&avatarId=31230",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=zeroshade&avatarId=31230",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=zeroshade&avatarId=31230"
                        },
                        "displayName": "Matthew Topol",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2022-08-05T16:28:05.672+0000",
                    "updated": "2022-08-05T16:28:05.672+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0km00:",
        "customfield_12314139": null
    }
}