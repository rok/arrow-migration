{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13182947",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182947",
    "key": "ARROW-3170",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12343066",
                "id": "12343066",
                "description": "",
                "name": "0.11.0",
                "archived": false,
                "released": true,
                "releaseDate": "2018-10-08"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 1800,
            "total": 1800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 1800,
            "total": 1800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3170/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 3,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182947/worklog/141043",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #2492: ARROW-3170: [C++] Experimental readahead spooler\nURL: https://github.com/apache/arrow/pull/2492#issuecomment-418521724\n \n \n   I opened ARROW-3170 as this is not exactly what is scoped there\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-09-04T21:19:56.155+0000",
                    "updated": "2018-09-04T21:19:56.155+0000",
                    "started": "2018-09-04T21:19:56.153+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "141043",
                    "issueId": "13182947"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182947/worklog/142026",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #2492: ARROW-3170: [C++] Experimental readahead spooler\nURL: https://github.com/apache/arrow/pull/2492#issuecomment-419316375\n \n \n   Anything more you wanted to do on this? Can merge otherwise\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-09-07T04:06:44.403+0000",
                    "updated": "2018-09-07T04:06:44.403+0000",
                    "started": "2018-09-07T04:06:44.402+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "142026",
                    "issueId": "13182947"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182947/worklog/142823",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou closed pull request #2492: ARROW-3170: [C++] Experimental readahead spooler\nURL: https://github.com/apache/arrow/pull/2492\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/cpp/src/arrow/CMakeLists.txt b/cpp/src/arrow/CMakeLists.txt\nindex b46f35c2c0..49373782e5 100644\n--- a/cpp/src/arrow/CMakeLists.txt\n+++ b/cpp/src/arrow/CMakeLists.txt\n@@ -34,6 +34,7 @@ set(ARROW_SRCS\n   io/file.cc\n   io/interfaces.cc\n   io/memory.cc\n+  io/readahead.cc\n \n   util/bit-util.cc\n   util/compression.cc\ndiff --git a/cpp/src/arrow/io/CMakeLists.txt b/cpp/src/arrow/io/CMakeLists.txt\nindex 65221d097f..ff6b8541dc 100644\n--- a/cpp/src/arrow/io/CMakeLists.txt\n+++ b/cpp/src/arrow/io/CMakeLists.txt\n@@ -26,6 +26,7 @@ if (ARROW_HDFS AND NOT ARROW_BOOST_HEADER_ONLY)\n endif()\n \n ADD_ARROW_TEST(io-memory-test)\n+ADD_ARROW_TEST(io-readahead-test)\n \n ADD_ARROW_BENCHMARK(io-file-benchmark)\n ADD_ARROW_BENCHMARK(io-memory-benchmark)\n@@ -38,4 +39,5 @@ install(FILES\n   hdfs.h\n   interfaces.h\n   memory.h\n+  readahead.h\n   DESTINATION \"${CMAKE_INSTALL_INCLUDEDIR}/arrow/io\")\ndiff --git a/cpp/src/arrow/io/io-readahead-test.cc b/cpp/src/arrow/io/io-readahead-test.cc\nnew file mode 100644\nindex 0000000000..fa0a138def\n--- /dev/null\n+++ b/cpp/src/arrow/io/io-readahead-test.cc\n@@ -0,0 +1,234 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <chrono>\n+#include <memory>\n+#include <string>\n+#include <thread>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/io/readahead.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/test-util.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+namespace arrow {\n+namespace io {\n+namespace internal {\n+\n+static void sleep_for(double seconds) {\n+  std::this_thread::sleep_for(\n+      std::chrono::nanoseconds(static_cast<int64_t>(seconds * 1e9)));\n+}\n+\n+static void busy_wait(double seconds, std::function<bool()> predicate) {\n+  const double period = 0.001;\n+  for (int i = 0; !predicate() && i * period < seconds; ++i) {\n+    sleep_for(period);\n+  }\n+}\n+\n+std::shared_ptr<BufferReader> DataReader(const std::string& data) {\n+  std::shared_ptr<Buffer> buffer;\n+  ABORT_NOT_OK(AllocateBuffer(data.length(), &buffer));\n+  memcpy(buffer->mutable_data(), data.data(), data.length());\n+  return std::make_shared<BufferReader>(std::move(buffer));\n+}\n+\n+static int64_t WaitForPosition(const RandomAccessFile& file, int64_t expected,\n+                               double seconds = 0.2) {\n+  int64_t pos = -1;\n+  busy_wait(seconds, [&]() -> bool {\n+    ABORT_NOT_OK(file.Tell(&pos));\n+    return pos >= expected;\n+  });\n+  return pos;\n+}\n+\n+static void AssertEventualPosition(const RandomAccessFile& file, int64_t expected) {\n+  int64_t pos = WaitForPosition(file, expected);\n+  ASSERT_EQ(pos, expected) << \"File didn't reach expected position\";\n+}\n+\n+static void AssertPosition(const RandomAccessFile& file, int64_t expected) {\n+  int64_t pos = -1;\n+  ABORT_NOT_OK(file.Tell(&pos));\n+  ASSERT_EQ(pos, expected) << \"File didn't reach expected position\";\n+}\n+\n+template <typename Expected>\n+static void AssertReadaheadBuffer(const ReadaheadBuffer& buf,\n+                                  std::set<int64_t> left_paddings,\n+                                  std::set<int64_t> right_paddings,\n+                                  const Expected& expected_data) {\n+  ASSERT_TRUE(left_paddings.count(buf.left_padding))\n+      << \"Left padding (\" << buf.left_padding << \") not amongst expected values\";\n+  ASSERT_TRUE(right_paddings.count(buf.right_padding))\n+      << \"Right padding (\" << buf.right_padding << \") not amongst expected values\";\n+  auto actual_data =\n+      SliceBuffer(buf.buffer, buf.left_padding,\n+                  buf.buffer->size() - buf.left_padding - buf.right_padding);\n+  AssertBufferEqual(*actual_data, expected_data);\n+}\n+\n+static void AssertReadaheadBufferEOF(const ReadaheadBuffer& buf) {\n+  ASSERT_EQ(buf.buffer.get(), nullptr) << \"Expected EOF signalled by null buffer pointer\";\n+}\n+\n+TEST(ReadaheadSpooler, BasicReads) {\n+  // Test basic reads\n+  auto data_reader = DataReader(\"0123456789\");\n+  ReadaheadSpooler spooler(data_reader, 2, 3);\n+  ReadaheadBuffer buf;\n+\n+  AssertEventualPosition(*data_reader, 3 * 2);\n+\n+  ASSERT_OK(spooler.Read(&buf));\n+  AssertReadaheadBuffer(buf, {0}, {0}, \"01\");\n+  AssertEventualPosition(*data_reader, 4 * 2);\n+  ASSERT_OK(spooler.Read(&buf));\n+  AssertReadaheadBuffer(buf, {0}, {0}, \"23\");\n+  AssertEventualPosition(*data_reader, 5 * 2);\n+  ASSERT_OK(spooler.Read(&buf));\n+  AssertReadaheadBuffer(buf, {0}, {0}, \"45\");\n+  ASSERT_OK(spooler.Read(&buf));\n+  AssertReadaheadBuffer(buf, {0}, {0}, \"67\");\n+  ASSERT_OK(spooler.Read(&buf));\n+  AssertReadaheadBuffer(buf, {0}, {0}, \"89\");\n+  ASSERT_OK(spooler.Read(&buf));\n+  AssertReadaheadBufferEOF(buf);\n+  ASSERT_OK(spooler.Read(&buf));\n+  AssertReadaheadBufferEOF(buf);\n+}\n+\n+TEST(ReadaheadSpooler, ShortReadAtEnd) {\n+  auto data_reader = DataReader(\"01234\");\n+  ReadaheadSpooler spooler(data_reader, 3, 2);\n+  ReadaheadBuffer buf;\n+\n+  AssertEventualPosition(*data_reader, 5);\n+\n+  ASSERT_OK(spooler.Read(&buf));\n+  AssertReadaheadBuffer(buf, {0}, {0}, \"012\");\n+  ASSERT_OK(spooler.Read(&buf));\n+  AssertReadaheadBuffer(buf, {0}, {0}, \"34\");\n+  ASSERT_OK(spooler.Read(&buf));\n+  AssertReadaheadBufferEOF(buf);\n+}\n+\n+TEST(ReadaheadSpooler, Close) {\n+  // Closing should stop reads\n+  auto data_reader = DataReader(\"0123456789\");\n+  ReadaheadSpooler spooler(data_reader, 2, 2);\n+  ReadaheadBuffer buf;\n+\n+  AssertEventualPosition(*data_reader, 2 * 2);\n+  ASSERT_OK(spooler.Close());\n+\n+  // XXX not sure this makes sense\n+  ASSERT_OK(spooler.Read(&buf));\n+  AssertReadaheadBuffer(buf, {0}, {0}, \"01\");\n+  ASSERT_OK(spooler.Read(&buf));\n+  AssertReadaheadBuffer(buf, {0}, {0}, \"23\");\n+  ASSERT_OK(spooler.Read(&buf));\n+  AssertReadaheadBufferEOF(buf);\n+  AssertPosition(*data_reader, 2 * 2);\n+\n+  // Idempotency\n+  ASSERT_OK(spooler.Close());\n+}\n+\n+TEST(ReadaheadSpooler, Paddings) {\n+  auto data_reader = DataReader(\"0123456789\");\n+  ReadaheadSpooler spooler(data_reader, 2, 2, 1 /* left_padding */,\n+                           4 /* right_padding */);\n+  ReadaheadBuffer buf;\n+\n+  AssertEventualPosition(*data_reader, 2 * 2);\n+  ASSERT_EQ(spooler.GetLeftPadding(), 1);\n+  ASSERT_EQ(spooler.GetRightPadding(), 4);\n+  spooler.SetLeftPadding(3);\n+  spooler.SetRightPadding(2);\n+  ASSERT_EQ(spooler.GetLeftPadding(), 3);\n+  ASSERT_EQ(spooler.GetRightPadding(), 2);\n+\n+  ASSERT_OK(spooler.Read(&buf));\n+  AssertReadaheadBuffer(buf, {1}, {4}, \"01\");\n+  ASSERT_OK(spooler.Read(&buf));\n+  AssertReadaheadBuffer(buf, {1}, {4}, \"23\");\n+  ASSERT_OK(spooler.Read(&buf));\n+  AssertReadaheadBuffer(buf, {3}, {2}, \"45\");\n+  ASSERT_OK(spooler.Read(&buf));\n+  AssertReadaheadBuffer(buf, {3}, {2}, \"67\");\n+  spooler.SetLeftPadding(4);\n+  ASSERT_OK(spooler.Read(&buf));\n+  AssertReadaheadBuffer(buf, {3, 4}, {2}, \"89\");\n+  ASSERT_OK(spooler.Read(&buf));\n+  AssertReadaheadBufferEOF(buf);\n+}\n+\n+TEST(ReadaheadSpooler, StressReads) {\n+  // NBYTES % READ_SIZE != 0 ensures a short read at end\n+#if defined(ARROW_VALGRIND)\n+  const int64_t NBYTES = 101;\n+#else\n+  const int64_t NBYTES = 50001;\n+#endif\n+  const int64_t READ_SIZE = 2;\n+\n+  std::shared_ptr<ResizableBuffer> data;\n+  ASSERT_OK(MakeRandomByteBuffer(NBYTES, default_memory_pool(), &data));\n+  auto data_reader = std::make_shared<BufferReader>(data);\n+\n+  ReadaheadSpooler spooler(data_reader, READ_SIZE, 7);\n+  int64_t pos = 0;\n+  std::vector<ReadaheadBuffer> readahead_buffers;\n+\n+  // Stress Read() calls while the background thread is reading ahead\n+  while (pos < NBYTES) {\n+    ReadaheadBuffer buf;\n+    ASSERT_OK(spooler.Read(&buf));\n+    ASSERT_NE(buf.buffer.get(), nullptr) << \"Got premature EOF at index \" << pos;\n+    pos += buf.buffer->size() - buf.left_padding - buf.right_padding;\n+    readahead_buffers.push_back(std::move(buf));\n+  }\n+  // At EOF\n+  {\n+    ReadaheadBuffer buf;\n+    ASSERT_OK(spooler.Read(&buf));\n+    AssertReadaheadBufferEOF(buf);\n+  }\n+\n+  pos = 0;\n+  for (const auto& buf : readahead_buffers) {\n+    auto expected_data = SliceBuffer(data, pos, std::min(READ_SIZE, NBYTES - pos));\n+    AssertReadaheadBuffer(buf, {0}, {0}, *expected_data);\n+    pos += expected_data->size();\n+  }\n+  // Got exactly the total bytes length\n+  ASSERT_EQ(pos, NBYTES);\n+}\n+\n+}  // namespace internal\n+}  // namespace io\n+}  // namespace arrow\ndiff --git a/cpp/src/arrow/io/readahead.cc b/cpp/src/arrow/io/readahead.cc\nnew file mode 100644\nindex 0000000000..c21e45d9e4\n--- /dev/null\n+++ b/cpp/src/arrow/io/readahead.cc\n@@ -0,0 +1,221 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/io/readahead.h\"\n+#include \"arrow/buffer.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/logging.h\"\n+\n+#include <condition_variable>\n+#include <cstring>\n+#include <deque>\n+#include <memory>\n+#include <mutex>\n+#include <string>\n+#include <thread>\n+#include <utility>\n+\n+namespace arrow {\n+namespace io {\n+namespace internal {\n+\n+// ----------------------------------------------------------------------\n+// ReadaheadSpooler implementation\n+\n+class ReadaheadSpooler::Impl {\n+ public:\n+  Impl(MemoryPool* pool, std::shared_ptr<InputStream> raw, int64_t read_size,\n+       int32_t readahead_queue_size, int64_t left_padding, int64_t right_padding)\n+      : pool_(pool),\n+        raw_(raw),\n+        read_size_(read_size),\n+        readahead_queue_size_(readahead_queue_size),\n+        left_padding_(left_padding),\n+        right_padding_(right_padding) {\n+    DCHECK_NE(raw, nullptr);\n+    DCHECK_GT(read_size, 0);\n+    DCHECK_GT(readahead_queue_size, 0);\n+    io_worker_ = std::thread([&]() { WorkerLoop(); });\n+  }\n+\n+  ~Impl() { ARROW_UNUSED(Close()); }\n+\n+  Status Close() {\n+    std::unique_lock<std::mutex> lock(mutex_);\n+    please_close_ = true;\n+    io_wakeup_.notify_one();\n+    // Wait for IO thread to finish\n+    if (io_worker_.joinable()) {\n+      lock.unlock();\n+      io_worker_.join();\n+      lock.lock();\n+    }\n+    return raw_->Close();\n+  }\n+\n+  Status Read(ReadaheadBuffer* out) {\n+    std::unique_lock<std::mutex> lock(mutex_);\n+    while (true) {\n+      // Drain queue before querying other flags\n+      if (buffer_queue_.size() > 0) {\n+        *out = std::move(buffer_queue_.front());\n+        DCHECK_NE(out->buffer, nullptr);\n+        buffer_queue_.pop_front();\n+        // Need to fill up queue again\n+        io_wakeup_.notify_one();\n+        return Status::OK();\n+      }\n+      if (!read_status_.ok()) {\n+        // Got a read error, bail out\n+        return read_status_;\n+      }\n+      if (eof_) {\n+        out->buffer.reset();\n+        return Status::OK();\n+      }\n+      // Readahead queue is empty and we're not closed yet, wait for more I/O\n+      io_progress_.wait(lock);\n+    }\n+  }\n+\n+  int64_t left_padding() {\n+    std::unique_lock<std::mutex> lock(mutex_);\n+    return left_padding_;\n+  }\n+\n+  void left_padding(int64_t size) {\n+    std::unique_lock<std::mutex> lock(mutex_);\n+    left_padding_ = size;\n+  }\n+\n+  int64_t right_padding() {\n+    std::unique_lock<std::mutex> lock(mutex_);\n+    return right_padding_;\n+  }\n+\n+  void right_padding(int64_t size) {\n+    std::unique_lock<std::mutex> lock(mutex_);\n+    right_padding_ = size;\n+  }\n+\n+ protected:\n+  // The background thread's main function\n+  void WorkerLoop() {\n+    std::unique_lock<std::mutex> lock(mutex_);\n+    Status st;\n+\n+    while (true) {\n+      if (please_close_) {\n+        goto eof;\n+      }\n+      // Fill up readahead queue until desired size\n+      while (buffer_queue_.size() < static_cast<size_t>(readahead_queue_size_)) {\n+        ReadaheadBuffer buf = {nullptr, left_padding_, right_padding_};\n+        lock.unlock();\n+        Status st = ReadOneBufferUnlocked(&buf);\n+        lock.lock();\n+        if (!st.ok()) {\n+          read_status_ = st;\n+          goto error;\n+        }\n+        // Close() could have been called while unlocked above\n+        if (please_close_) {\n+          goto eof;\n+        }\n+        // Got empty read?\n+        if (buf.buffer->size() == buf.left_padding + buf.right_padding) {\n+          goto eof;\n+        }\n+        buffer_queue_.push_back(std::move(buf));\n+        io_progress_.notify_one();\n+      }\n+      // Wait for Close() or Read() call\n+      io_wakeup_.wait(lock);\n+    }\n+  eof:\n+    eof_ = true;\n+  error:\n+    // Make sure any pending Read() doesn't block indefinitely\n+    io_progress_.notify_one();\n+  }\n+\n+  Status ReadOneBufferUnlocked(ReadaheadBuffer* buf) {\n+    // Note that left_padding_ and right_padding_ may be modified while unlocked\n+    std::shared_ptr<ResizableBuffer> buffer;\n+    int64_t bytes_read;\n+    RETURN_NOT_OK(AllocateResizableBuffer(\n+        pool_, read_size_ + buf->left_padding + buf->right_padding, &buffer));\n+    RETURN_NOT_OK(\n+        raw_->Read(read_size_, &bytes_read, buffer->mutable_data() + buf->left_padding));\n+    if (bytes_read < read_size_) {\n+      // Got a short read\n+      RETURN_NOT_OK(buffer->Resize(bytes_read + buf->left_padding + buf->right_padding));\n+    }\n+    // Zero padding areas\n+    memset(buffer->mutable_data(), 0, buf->left_padding);\n+    memset(buffer->mutable_data() + bytes_read + buf->left_padding, 0,\n+           buf->right_padding);\n+    buf->buffer = std::move(buffer);\n+    return Status::OK();\n+  }\n+\n+  MemoryPool* pool_;\n+  std::shared_ptr<InputStream> raw_;\n+  int64_t read_size_;\n+  int32_t readahead_queue_size_;\n+  int64_t left_padding_ = 0;\n+  int64_t right_padding_ = 0;\n+\n+  std::mutex mutex_;\n+  std::condition_variable io_wakeup_;\n+  std::condition_variable io_progress_;\n+  std::thread io_worker_;\n+  bool please_close_ = false;\n+  bool eof_ = false;\n+  std::deque<ReadaheadBuffer> buffer_queue_;\n+  Status read_status_;\n+};\n+\n+ReadaheadSpooler::ReadaheadSpooler(MemoryPool* pool, std::shared_ptr<InputStream> raw,\n+                                   int64_t read_size, int32_t readahead_queue_size,\n+                                   int64_t left_padding, int64_t right_padding)\n+    : impl_(new ReadaheadSpooler::Impl(pool, raw, read_size, readahead_queue_size,\n+                                       left_padding, right_padding)) {}\n+\n+ReadaheadSpooler::ReadaheadSpooler(std::shared_ptr<InputStream> raw, int64_t read_size,\n+                                   int32_t readahead_queue_size, int64_t left_padding,\n+                                   int64_t right_padding)\n+    : ReadaheadSpooler(default_memory_pool(), raw, read_size, readahead_queue_size,\n+                       left_padding, right_padding) {}\n+\n+int64_t ReadaheadSpooler::GetLeftPadding() { return impl_->left_padding(); }\n+\n+void ReadaheadSpooler::SetLeftPadding(int64_t size) { impl_->left_padding(size); }\n+\n+int64_t ReadaheadSpooler::GetRightPadding() { return impl_->right_padding(); }\n+\n+void ReadaheadSpooler::SetRightPadding(int64_t size) { impl_->right_padding(size); }\n+\n+Status ReadaheadSpooler::Close() { return impl_->Close(); }\n+\n+Status ReadaheadSpooler::Read(ReadaheadBuffer* out) { return impl_->Read(out); }\n+\n+ReadaheadSpooler::~ReadaheadSpooler() {}\n+\n+}  // namespace internal\n+}  // namespace io\n+}  // namespace arrow\ndiff --git a/cpp/src/arrow/io/readahead.h b/cpp/src/arrow/io/readahead.h\nnew file mode 100644\nindex 0000000000..d7ac509313\n--- /dev/null\n+++ b/cpp/src/arrow/io/readahead.h\n@@ -0,0 +1,96 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_IO_READAHEAD_H\n+#define ARROW_IO_READAHEAD_H\n+\n+#include <memory>\n+#include <string>\n+\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/util/visibility.h\"\n+\n+namespace arrow {\n+\n+class MemoryPool;\n+class ResizableBuffer;\n+class Status;\n+\n+namespace io {\n+namespace internal {\n+\n+struct ARROW_EXPORT ReadaheadBuffer {\n+  std::shared_ptr<ResizableBuffer> buffer;\n+  int64_t left_padding;\n+  int64_t right_padding;\n+};\n+\n+class ARROW_EXPORT ReadaheadSpooler {\n+ public:\n+  /// \\brief EXPERIMENTAL: Create a readahead spooler wrapping the given input stream.\n+  ///\n+  /// The spooler launches a background thread that reads up to a given number\n+  /// of fixed-size blocks in advance from the underlying stream.\n+  /// The buffers returned by Read() will be padded at the beginning and the end\n+  /// with the configured amount of (zeroed) bytes.\n+  ReadaheadSpooler(MemoryPool* pool, std::shared_ptr<InputStream> raw,\n+                   int64_t read_size = kDefaultReadSize, int32_t readahead_queue_size = 1,\n+                   int64_t left_padding = 0, int64_t right_padding = 0);\n+\n+  explicit ReadaheadSpooler(std::shared_ptr<InputStream> raw,\n+                            int64_t read_size = kDefaultReadSize,\n+                            int32_t readahead_queue_size = 1, int64_t left_padding = 0,\n+                            int64_t right_padding = 0);\n+\n+  ~ReadaheadSpooler();\n+\n+  /// Configure zero-padding at beginning and end of buffers (default 0 bytes).\n+  /// The buffers returned by Read() will be padded at the beginning and the end\n+  /// with the configured amount of (zeroed) bytes.\n+  /// Note that, as reading happens in background and in advance, changing the\n+  /// configured values might not affect Read() results immediately.\n+  int64_t GetLeftPadding();\n+  void SetLeftPadding(int64_t size);\n+\n+  int64_t GetRightPadding();\n+  void SetRightPadding(int64_t size);\n+\n+  /// \\brief Close the spooler.  This implicitly closes the underlying input stream.\n+  Status Close();\n+\n+  /// \\brief Read a buffer from the queue.\n+  ///\n+  /// If the buffer pointer in the ReadaheadBuffer is null, then EOF was\n+  /// reached and/or the spooler was explicitly closed.\n+  /// Otherwise, the buffer will contain at most read_size bytes in addition\n+  /// to the configured padding (short reads are possible at the end of a file).\n+  // How do we allow reusing the buffer in ReadaheadBuffer? perhaps by using\n+  // a caching memory pool?\n+  Status Read(ReadaheadBuffer* out);\n+\n+ private:\n+  static constexpr int64_t kDefaultReadSize = 1 << 20;  // 1 MB\n+\n+  class ARROW_NO_EXPORT Impl;\n+  std::unique_ptr<Impl> impl_;\n+};\n+\n+}  // namespace internal\n+}  // namespace io\n+}  // namespace arrow\n+\n+#endif  // ARROW_IO_READAHEAD_H\ndiff --git a/cpp/src/arrow/test-util.h b/cpp/src/arrow/test-util.h\nindex 13c6a6160f..dfc1ab5dcb 100644\n--- a/cpp/src/arrow/test-util.h\n+++ b/cpp/src/arrow/test-util.h\n@@ -330,13 +330,26 @@ void AssertChunkedEqual(const ChunkedArray& expected, const ChunkedArray& actual\n }\n \n void AssertBufferEqual(const Buffer& buffer, const std::vector<uint8_t>& expected) {\n-  ASSERT_EQ(buffer.size(), expected.size());\n+  ASSERT_EQ(buffer.size(), expected.size()) << \"Mismatching buffer size\";\n   const uint8_t* buffer_data = buffer.data();\n   for (size_t i = 0; i < expected.size(); ++i) {\n     ASSERT_EQ(buffer_data[i], expected[i]);\n   }\n }\n \n+void AssertBufferEqual(const Buffer& buffer, const std::string& expected) {\n+  ASSERT_EQ(buffer.size(), expected.length()) << \"Mismatching buffer size\";\n+  const uint8_t* buffer_data = buffer.data();\n+  for (size_t i = 0; i < expected.size(); ++i) {\n+    ASSERT_EQ(buffer_data[i], expected[i]);\n+  }\n+}\n+\n+void AssertBufferEqual(const Buffer& buffer, const Buffer& expected) {\n+  ASSERT_EQ(buffer.size(), expected.size()) << \"Mismatching buffer size\";\n+  ASSERT_TRUE(buffer.Equals(expected));\n+}\n+\n void PrintColumn(const Column& col, std::stringstream* ss) {\n   const ChunkedArray& carr = *col.data();\n   for (int i = 0; i < carr.num_chunks(); ++i) {\ndiff --git a/cpp/src/plasma/test/client_tests.cc b/cpp/src/plasma/test/client_tests.cc\nindex a2725a62aa..1ad60396af 100644\n--- a/cpp/src/plasma/test/client_tests.cc\n+++ b/cpp/src/plasma/test/client_tests.cc\n@@ -290,7 +290,7 @@ TEST_F(TestPlasmaStore, GetTest) {\n   {\n     auto metadata = object_buffers[0].metadata;\n     object_buffers.clear();\n-    ::arrow::AssertBufferEqual(*metadata, {42});\n+    ::arrow::AssertBufferEqual(*metadata, std::string{42});\n     ARROW_CHECK_OK(client_.FlushReleaseHistory());\n     EXPECT_TRUE(client_.IsInUse(object_id));\n   }\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-09-10T16:43:19.103+0000",
                    "updated": "2018-09-10T16:43:19.103+0000",
                    "started": "2018-09-10T16:43:19.103+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "142823",
                    "issueId": "13182947"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 1800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@4aedffd7[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1475941d[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@31908a08[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@97d255b[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@597ee987[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@7b9a9898[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4eef9d29[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@2e582e52[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@44c8cf[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@2fb5ce07[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1d01080d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@72c49f41[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 1800,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Sep 10 16:43:13 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-09-10T16:43:13.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3170/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2018-09-04T21:19:35.000+0000",
        "updated": "2018-09-10T16:43:26.000+0000",
        "timeoriginalestimate": null,
        "description": "This is closely related to ARROW-501",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "0.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 1800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Implement \"readahead spooler\" class for background input buffering",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182947/comment/16609485",
                    "id": "16609485",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 2492\n[https://github.com/apache/arrow/pull/2492]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2018-09-10T16:43:13.125+0000",
                    "updated": "2018-09-10T16:43:13.125+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|i3xq5b:",
        "customfield_12314139": null
    }
}