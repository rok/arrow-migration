{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13478296",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478296",
    "key": "ARROW-17509",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12352360",
                "id": "12352360",
                "description": "",
                "name": "11.0.0",
                "archived": false,
                "released": false
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 9600,
            "total": 9600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 9600,
            "total": 9600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-17509/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 16,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478296/worklog/820764",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace opened a new pull request, #14524:\nURL: https://github.com/apache/arrow/pull/14524\n\n   \u2026ire a call to End\r\n   \r\n   This call to end was a foot-gun because failing to call End on a scheduler would lead to deadlock.  This led to numerous situations where one would accidentally fail to call End because of some kind of error or exceptional behavior.\r\n   \r\n   Now the call to end is no longer required.  Schedulers are semantically divided (there aren't actually three different classes, just three different supported use cases) into three different types:\r\n   \r\n    * Destroy-when-done schedulers destroy themselves whenever they have finished running all of their tasks. These schedulers require an initial task to bootstrap the scheduler and then that task (and it's subtasks) can add more sub-tasks.  This is the simplest and most basic kind of scheduler and the top-level scheduler must always be this kind of scheduler.\r\n    * Peer schedulers will be ended when their parent scheduler runs out of tasks.  These are useful for sinks which get tasks on a push-driven basis and don't have all their tasks up front.  However, when the plan is done, we know for certain no more tasks will arrive.\r\n    * Eager peer schedulers are the same as peer schedulers but they might be eagerly ended before their parent scheduler is finished.  The file queue in the dataset writer is a good example.  It receives tasks in an ad-hoc fashion so it is a peer scheduler.  However, once we have written max_rows rows to a file we can end it early (no need to wait for the plan to finish).  However, if we forget to end it early (or fail to due so in some error scenario) it will still end when the plan ends.\n\n\n",
                    "created": "2022-10-26T23:03:06.310+0000",
                    "updated": "2022-10-26T23:03:06.310+0000",
                    "started": "2022-10-26T23:03:06.310+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "820764",
                    "issueId": "13478296"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478296/worklog/820765",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #14524:\nURL: https://github.com/apache/arrow/pull/14524#issuecomment-1292757069\n\n   https://issues.apache.org/jira/browse/ARROW-17509\n\n\n",
                    "created": "2022-10-26T23:03:46.758+0000",
                    "updated": "2022-10-26T23:03:46.758+0000",
                    "started": "2022-10-26T23:03:46.757+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "820765",
                    "issueId": "13478296"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478296/worklog/820766",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #14524:\nURL: https://github.com/apache/arrow/pull/14524#issuecomment-1292757084\n\n   :warning: Ticket **has not been started in JIRA**, please click 'Start Progress'.\n\n\n",
                    "created": "2022-10-26T23:03:48.499+0000",
                    "updated": "2022-10-26T23:03:48.499+0000",
                    "started": "2022-10-26T23:03:48.499+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "820766",
                    "issueId": "13478296"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478296/worklog/820767",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on PR #14524:\nURL: https://github.com/apache/arrow/pull/14524#issuecomment-1292759746\n\n   CC @save-buffer would appreciate a look\n\n\n",
                    "created": "2022-10-26T23:08:21.010+0000",
                    "updated": "2022-10-26T23:08:21.010+0000",
                    "started": "2022-10-26T23:08:21.009+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "820767",
                    "issueId": "13478296"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478296/worklog/821131",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #14524:\nURL: https://github.com/apache/arrow/pull/14524#discussion_r1007212828\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.cc:\n##########\n@@ -127,85 +127,89 @@ struct ExecPlanImpl : public ExecPlan {\n   }\n \n   Status StartProducing() {\n-    START_COMPUTE_SPAN(span_, \"ExecPlan\", {{\"plan\", ToString()}});\n-#ifdef ARROW_WITH_OPENTELEMETRY\n-    if (HasMetadata()) {\n-      auto pairs = metadata().get()->sorted_pairs();\n-      opentelemetry::nostd::shared_ptr<opentelemetry::trace::Span> span =\n-          ::arrow::internal::tracing::UnwrapSpan(span_.details.get());\n-      std::for_each(std::begin(pairs), std::end(pairs),\n-                    [span](std::pair<std::string, std::string> const& pair) {\n-                      span->SetAttribute(pair.first, pair.second);\n-                    });\n-    }\n-#endif\n     if (started_) {\n       return Status::Invalid(\"restarted ExecPlan\");\n     }\n-\n-    std::vector<Future<>> futures;\n-    for (auto& n : nodes_) {\n-      RETURN_NOT_OK(n->Init());\n-      futures.push_back(n->finished());\n-    }\n-\n-    AllFinished(futures).AddCallback([this](const Status& st) {\n-      error_st_ = st;\n-      EndTaskGroup();\n-    });\n-\n-    task_scheduler_->RegisterEnd();\n-    int num_threads = 1;\n-    bool sync_execution = true;\n-    if (auto executor = exec_context()->executor()) {\n-      num_threads = executor->GetCapacity();\n-      sync_execution = false;\n-    }\n-    RETURN_NOT_OK(task_scheduler_->StartScheduling(\n-        0 /* thread_index */,\n-        [this](std::function<Status(size_t)> fn) -> Status {\n-          return this->ScheduleTask(std::move(fn));\n-        },\n-        /*concurrent_tasks=*/2 * num_threads, sync_execution));\n-\n     started_ = true;\n-    // producers precede consumers\n-    sorted_nodes_ = TopoSort();\n-\n-    Status st = Status::OK();\n-\n-    using rev_it = std::reverse_iterator<NodeVector::iterator>;\n-    for (rev_it it(sorted_nodes_.end()), end(sorted_nodes_.begin()); it != end; ++it) {\n-      auto node = *it;\n \n-      EVENT(span_, \"StartProducing:\" + node->label(),\n-            {{\"node.label\", node->label()}, {\"node.kind_name\", node->kind_name()}});\n-      st = node->StartProducing();\n-      EVENT(span_, \"StartProducing:\" + node->label(), {{\"status\", st.ToString()}});\n-      if (!st.ok()) {\n-        // Stop nodes that successfully started, in reverse order\n-        stopped_ = true;\n-        StopProducingImpl(it.base(), sorted_nodes_.end());\n-        for (NodeVector::iterator fw_it = sorted_nodes_.begin(); fw_it != it.base();\n-             ++fw_it) {\n-          Future<> fut = (*fw_it)->finished();\n-          if (!fut.is_finished()) fut.MarkFinished();\n-        }\n-        return st;\n-      }\n-    }\n-    return st;\n-  }\n-\n-  void EndTaskGroup() {\n-    bool expected = false;\n-    if (group_ended_.compare_exchange_strong(expected, true)) {\n-      async_scheduler_->End();\n-      async_scheduler_->OnFinished().AddCallback([this](const Status& st) {\n-        MARK_SPAN(span_, error_st_ & st);\n-        END_SPAN(span_);\n-        finished_.MarkFinished(error_st_ & st);\n-      });\n+    // We call StartProducing on each of the nodes.  The source nodes should generally\n+    // start scheduling some tasks during this call.\n+    //\n+    // If no source node schedules any tasks (e.g. they do all their word synchronously as\n+    // part of StartProducing) then the plan may be finished before we return from this\n+    // call.\n+    Future<> scheduler_finished =\n+        util::AsyncTaskScheduler::Make([this](util::AsyncTaskScheduler* async_scheduler) {\n+          this->async_scheduler_ = async_scheduler;\n+          START_COMPUTE_SPAN(span_, \"ExecPlan\", {{\"plan\", ToString()}});\n+#ifdef ARROW_WITH_OPENTELEMETRY\n+          if (HasMetadata()) {\n+            auto pairs = metadata().get()->sorted_pairs();\n+            opentelemetry::nostd::shared_ptr<opentelemetry::trace::Span> span =\n+                ::arrow::internal::tracing::UnwrapSpan(span_.details.get());\n+            std::for_each(std::begin(pairs), std::end(pairs),\n+                          [span](std::pair<std::string, std::string> const& pair) {\n+                            span->SetAttribute(pair.first, pair.second);\n+                          });\n+          }\n+#endif\n+          // TODO(weston) The entire concept of ExecNode::finished() will hopefully go\n\nReview Comment:\n   yep my simplification PR gets rid of those finished futures.\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.cc:\n##########\n@@ -127,85 +127,89 @@ struct ExecPlanImpl : public ExecPlan {\n   }\n \n   Status StartProducing() {\n-    START_COMPUTE_SPAN(span_, \"ExecPlan\", {{\"plan\", ToString()}});\n-#ifdef ARROW_WITH_OPENTELEMETRY\n-    if (HasMetadata()) {\n-      auto pairs = metadata().get()->sorted_pairs();\n-      opentelemetry::nostd::shared_ptr<opentelemetry::trace::Span> span =\n-          ::arrow::internal::tracing::UnwrapSpan(span_.details.get());\n-      std::for_each(std::begin(pairs), std::end(pairs),\n-                    [span](std::pair<std::string, std::string> const& pair) {\n-                      span->SetAttribute(pair.first, pair.second);\n-                    });\n-    }\n-#endif\n     if (started_) {\n       return Status::Invalid(\"restarted ExecPlan\");\n     }\n-\n-    std::vector<Future<>> futures;\n-    for (auto& n : nodes_) {\n-      RETURN_NOT_OK(n->Init());\n-      futures.push_back(n->finished());\n-    }\n-\n-    AllFinished(futures).AddCallback([this](const Status& st) {\n-      error_st_ = st;\n-      EndTaskGroup();\n-    });\n-\n-    task_scheduler_->RegisterEnd();\n-    int num_threads = 1;\n-    bool sync_execution = true;\n-    if (auto executor = exec_context()->executor()) {\n-      num_threads = executor->GetCapacity();\n-      sync_execution = false;\n-    }\n-    RETURN_NOT_OK(task_scheduler_->StartScheduling(\n-        0 /* thread_index */,\n-        [this](std::function<Status(size_t)> fn) -> Status {\n-          return this->ScheduleTask(std::move(fn));\n-        },\n-        /*concurrent_tasks=*/2 * num_threads, sync_execution));\n-\n     started_ = true;\n-    // producers precede consumers\n-    sorted_nodes_ = TopoSort();\n-\n-    Status st = Status::OK();\n-\n-    using rev_it = std::reverse_iterator<NodeVector::iterator>;\n-    for (rev_it it(sorted_nodes_.end()), end(sorted_nodes_.begin()); it != end; ++it) {\n-      auto node = *it;\n \n-      EVENT(span_, \"StartProducing:\" + node->label(),\n-            {{\"node.label\", node->label()}, {\"node.kind_name\", node->kind_name()}});\n-      st = node->StartProducing();\n-      EVENT(span_, \"StartProducing:\" + node->label(), {{\"status\", st.ToString()}});\n-      if (!st.ok()) {\n-        // Stop nodes that successfully started, in reverse order\n-        stopped_ = true;\n-        StopProducingImpl(it.base(), sorted_nodes_.end());\n-        for (NodeVector::iterator fw_it = sorted_nodes_.begin(); fw_it != it.base();\n-             ++fw_it) {\n-          Future<> fut = (*fw_it)->finished();\n-          if (!fut.is_finished()) fut.MarkFinished();\n-        }\n-        return st;\n-      }\n-    }\n-    return st;\n-  }\n-\n-  void EndTaskGroup() {\n-    bool expected = false;\n-    if (group_ended_.compare_exchange_strong(expected, true)) {\n-      async_scheduler_->End();\n-      async_scheduler_->OnFinished().AddCallback([this](const Status& st) {\n-        MARK_SPAN(span_, error_st_ & st);\n-        END_SPAN(span_);\n-        finished_.MarkFinished(error_st_ & st);\n-      });\n+    // We call StartProducing on each of the nodes.  The source nodes should generally\n+    // start scheduling some tasks during this call.\n+    //\n+    // If no source node schedules any tasks (e.g. they do all their word synchronously as\n+    // part of StartProducing) then the plan may be finished before we return from this\n+    // call.\n+    Future<> scheduler_finished =\n+        util::AsyncTaskScheduler::Make([this](util::AsyncTaskScheduler* async_scheduler) {\n\nReview Comment:\n   Could we move this giant lambda into its own function? The extra layer of indentation is pretty confusing \n\n\n\n##########\ncpp/src/arrow/util/async_util.cc:\n##########\n@@ -108,30 +108,37 @@ class AlreadyFailedScheduler : public AsyncTaskScheduler {\n     std::ignore = std::move(finish_callback_)(failure_reason_);\n   }\n   bool AddTask(std::unique_ptr<Task> task) override { return false; }\n-  void End() override {\n-    Status::UnknownError(\"Do not call End on a sub-scheduler.\").Abort();\n-  }\n-  Future<> OnFinished() const override {\n-    Status::UnknownError(\n-        \"You should not rely on sub-scheduler's OnFinished.  Use a \"\n-        \"finished callback when creating the sub-scheduler instead\")\n-        .Abort();\n-  }\n-  std::shared_ptr<AsyncTaskScheduler> MakeSubScheduler(\n+  std::unique_ptr<AsyncTaskScheduler::Holder> MakeSubScheduler(\n+      FnOnce<Status(AsyncTaskScheduler*)> initial_task,\n\nReview Comment:\n   Could we guarantee that this `initial_task` gets run synchronously? I get why it's needed (the scheduler will end itself immediately after creation without it), but I would like the control flow for scheduling the initial tasks to be simple. We could make this function return a `Result<unique_ptr>` in case a node has a problem scheduling its initial tasks.\n\n\n\n",
                    "created": "2022-10-27T18:29:25.480+0000",
                    "updated": "2022-10-27T18:29:25.480+0000",
                    "started": "2022-10-27T18:29:25.480+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "821131",
                    "issueId": "13478296"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478296/worklog/821597",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on PR #14524:\nURL: https://github.com/apache/arrow/pull/14524#issuecomment-1295423847\n\n   > A different interface that could be simpler is to simply change the meaning of End to mean \"End when empty but allow adding more tasks\" instead of \"End when empty but disallow adding more tasks\".\r\n   \r\n   You are now allowed to add tasks after a scheduler is \"ended\".  The top-level scheduler basically starts \"ended\" (after the initial task runs).  If you don't use or need sub-schedulers then we have what you describe.\r\n   \r\n   However, there are some cases where we don't want a sub-scheduler to end even though it has run out of tasks.  For example, when writing to a file.  We want to close the file when all write tasks have finished.  However, we don't know, at the start, how many write tasks there will be, and we don't have all of them (sometimes InputReceived will add another write task and sometimes it won't, depends on partitioning).\r\n   \r\n   That being said, we still want to end the file writer no matter what when the plan itself is out of tasks.  At that point there is no possible way we could add more write tasks so the fact that it hasn't been ended is probably a bug or an error condition we don't explicitly handle and so we should just abort what we were doing and close the file.\n\n\n",
                    "created": "2022-10-28T20:18:03.689+0000",
                    "updated": "2022-10-28T20:18:03.689+0000",
                    "started": "2022-10-28T20:18:03.689+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "821597",
                    "issueId": "13478296"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478296/worklog/821598",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #14524:\nURL: https://github.com/apache/arrow/pull/14524#discussion_r1008434063\n\n\n##########\ncpp/src/arrow/util/async_util.cc:\n##########\n@@ -108,30 +108,37 @@ class AlreadyFailedScheduler : public AsyncTaskScheduler {\n     std::ignore = std::move(finish_callback_)(failure_reason_);\n   }\n   bool AddTask(std::unique_ptr<Task> task) override { return false; }\n-  void End() override {\n-    Status::UnknownError(\"Do not call End on a sub-scheduler.\").Abort();\n-  }\n-  Future<> OnFinished() const override {\n-    Status::UnknownError(\n-        \"You should not rely on sub-scheduler's OnFinished.  Use a \"\n-        \"finished callback when creating the sub-scheduler instead\")\n-        .Abort();\n-  }\n-  std::shared_ptr<AsyncTaskScheduler> MakeSubScheduler(\n+  std::unique_ptr<AsyncTaskScheduler::Holder> MakeSubScheduler(\n+      FnOnce<Status(AsyncTaskScheduler*)> initial_task,\n\nReview Comment:\n   Yes.  `initial_task` is always run synchronously as part of the call to `MakeSubScheduler` (so it should be safe, e.g. to use `[&]`).  Furthermore, when you add a task to a scheduler that does not have a throttle, the task submitter portion will always run synchronously as part of the call to `AddTask`.  I'll update the docs to make this clearer.\n\n\n\n",
                    "created": "2022-10-28T20:19:34.160+0000",
                    "updated": "2022-10-28T20:19:34.160+0000",
                    "started": "2022-10-28T20:19:34.159+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "821598",
                    "issueId": "13478296"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478296/worklog/822239",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on PR #14524:\nURL: https://github.com/apache/arrow/pull/14524#issuecomment-1298236528\n\n   - [ ] Reminder to myself to update the docs.  They still mention that you don't need to dispose the holder but you do need to do so.\r\n   - [ ] Create a follow-up PR to add deadlock detection\n\n\n",
                    "created": "2022-11-01T09:01:51.006+0000",
                    "updated": "2022-11-01T09:01:51.006+0000",
                    "started": "2022-11-01T09:01:51.005+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "822239",
                    "issueId": "13478296"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478296/worklog/824443",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on PR #14524:\nURL: https://github.com/apache/arrow/pull/14524#issuecomment-1308359622\n\n   I reworked everything again so the above comments aren't really valid.  I've reworked the PR description to reflect the new behavior.\n\n\n",
                    "created": "2022-11-09T08:04:13.559+0000",
                    "updated": "2022-11-09T08:04:13.559+0000",
                    "started": "2022-11-09T08:04:13.558+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "824443",
                    "issueId": "13478296"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478296/worklog/824648",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #14524:\nURL: https://github.com/apache/arrow/pull/14524#discussion_r1018083155\n\n\n##########\ncpp/src/arrow/util/async_util.h:\n##########\n@@ -48,50 +50,25 @@ namespace util {\n /// By default the scheduler will submit the task (execute the synchronous part) as\n /// soon as it is added, assuming the underlying thread pool hasn't terminated or the\n /// scheduler hasn't aborted.  In this mode, the scheduler is simply acting as\n-/// a task group (keeping track of the ongoing work).\n+/// a simple task group.\n ///\n-/// This can be used to provide structured concurrency for asynchronous development.\n-/// A task group created at a high level can be distributed amongst low level components\n-/// which register work to be completed.  The high level job can then wait for all work\n-/// to be completed before cleaning up.\n-///\n-/// A task scheduler must eventually be ended when all tasks have been added.  Once the\n-/// scheduler has been ended it is an error to add further tasks.  Note, it is not an\n-/// error to add additional tasks after a scheduler has aborted (though these tasks\n-/// will be ignored and never submitted).  The scheduler has a future which will complete\n-/// once the scheduler has been ended AND all remaining tasks have finished executing.\n-/// Ending a scheduler will NOT cause the scheduler to flush existing tasks.\n+/// A task scheduler starts with an initial task.  That task, and all subsequent tasks\n+/// are free to add subtasks.  Once all submitted tasks finsih the scheduler will\n\nReview Comment:\n   ```suggestion\r\n   /// are free to add subtasks.  Once all submitted tasks finish the scheduler will\r\n   ```\n\n\n\n##########\ncpp/src/arrow/util/async_util.cc:\n##########\n@@ -100,345 +119,323 @@ class FifoQueue : public AsyncTaskScheduler::Queue {\n \n class AlreadyFailedScheduler : public AsyncTaskScheduler {\n\nReview Comment:\n   Is this actually used anymore?\n\n\n\n##########\ncpp/src/arrow/util/async_util.h:\n##########\n@@ -145,206 +188,216 @@ class ARROW_EXPORT AsyncTaskScheduler {\n     /// acquired and the caller can proceed.  If a future is returned then the caller\n     /// should wait for the future to complete first.  When the returned future completes\n     /// the permits have NOT been acquired and the caller must call Acquire again\n+    ///\n+    /// \\param amt the number of permits to acquire\n     virtual std::optional<Future<>> TryAcquire(int amt) = 0;\n     /// Release amt permits\n     ///\n     /// This will possibly complete waiting futures and should probably not be\n     /// called while holding locks.\n+    ///\n+    /// \\param amt the number of permits to release\n     virtual void Release(int amt) = 0;\n \n     /// The size of the largest task that can run\n     ///\n     /// Incoming tasks will have their cost latched to this value to ensure\n-    /// they can still run (although they will generally be the only thing allowed to\n+    /// they can still run (although they will be the only thing allowed to\n     /// run at that time).\n     virtual int Capacity() = 0;\n+\n+    /// Pause the throttle\n+    ///\n+    /// Any tasks that have been submitted already will continue.  However, no new tasks\n+    /// will be run until the throttle is resumed.\n+    virtual void Pause() = 0;\n+    /// Resume the throttle\n+    ///\n+    /// Allows taks to be submitted again.  If there is a max_concurrent_cost limit then\n+    /// it will still apply.\n+    virtual void Resume() = 0;\n   };\n-  /// Create a throttle\n+\n+  /// Pause the throttle\n+  ///\n+  /// Any tasks that have been submitted already will continue.  However, no new tasks\n+  /// will be run until the throttle is resumed.\n+  virtual void Pause() = 0;\n+  /// Resume the throttle\n   ///\n-  /// This throttle is used to limit how many tasks can run at once.  The\n-  /// user should keep the throttle alive for the lifetime of the scheduler.\n-  /// The same throttle can be used in multiple schedulers.\n-  static std::unique_ptr<Throttle> MakeThrottle(int max_concurrent_cost);\n+  /// Allows taks to be submitted again.  If there is a max_concurrent_cost limit then\n+  /// it will still apply.\n+  virtual void Resume() = 0;\n \n-  /// Add a task to the scheduler\n+  /// Create a throttled view of a scheduler\n   ///\n-  /// If the scheduler is in an aborted state this call will return false and the task\n-  /// will never be run.  This is harmless and does not need to be guarded against.\n+  /// Tasks added via this view will be subjected to the throttle and, if the tasks cannot\n+  /// run immediately, will be placed into a queue.\n   ///\n-  /// If the scheduler is in an ended state then this call will cause an program abort.\n-  /// This represents a logic error in the program and should be avoidable.\n+  /// Using a throttled view after the underlying scheduler has finished is invalid.\n   ///\n-  /// If there are no limits on the number of concurrent tasks then the submit function\n-  /// will be run immediately.\n+  /// Although a shared_ptr is returned it should generally be assumed that the caller\n+  /// is being given exclusive ownership.  The shared_ptr is used to share the view with\n+  /// queued and submitted tasks and the lifetime of those is unpredictable.  It is\n+  /// important the caller keep the returned pointer alive for as long as they plan to add\n+  /// tasks to the view.\n   ///\n-  /// Otherwise, if there is a throttle, and it is full, then this task will be inserted\n-  /// into the scheduler's queue and submitted when there is space.\n+  /// \\param scheduler a scheduler to submit tasks to after throttling\n   ///\n-  /// The return value for this call can usually be ignored.  There is little harm in\n-  /// attempting to add tasks to an aborted scheduler.  It is only included for callers\n-  /// that want to avoid future task generation.\n+  /// This can be the root scheduler, another throttled scheduler, or a task group.  These\n+  /// are all composable.\n   ///\n-  /// \\return true if the task was submitted or queued, false if the task was ignored\n-  virtual bool AddTask(std::unique_ptr<Task> task) = 0;\n+  /// \\param max_concurrent_cost the maximum amount of cost allowed to run at any one time\n+  ///\n+  /// If a task is added that has a cost greater than max_concurrent_cost then its cost\n+  /// will be reduced to max_concurrent_cost so that it is still possible for the task to\n+  /// run.\n+  ///\n+  /// \\param queue the queue to use when tasks cannot be submitted\n+  ///\n+  /// By default a FIFO queue will be used.  However, a custom queue can be provided if\n+  /// some tasks have higher priority than other tasks.\n+  static std::shared_ptr<ThrottledAsyncTaskScheduler> Make(\n+      AsyncTaskScheduler* scheduler, int max_concurrent_cost,\n+      std::unique_ptr<Queue> queue = NULLPTR);\n \n-  /// Adds an async generator to the scheduler\n+  /// @brief Create a ThrottledAsyncTaskScheduler using a custom throttle\n   ///\n-  /// The async generator will be visited, one item at a time.  Submitting a task\n-  /// will consist of polling the generator for the next future.  The generator's future\n-  /// will then represent the task itself.\n+  /// \\see Make\n+  static std::shared_ptr<ThrottledAsyncTaskScheduler> MakeWithCustomThrottle(\n+      AsyncTaskScheduler* scheduler, std::unique_ptr<Throttle> throttle,\n+      std::unique_ptr<Queue> queue = NULLPTR);\n+};\n+\n+/// A utility to keep track of a collection of tasks\n+///\n+/// Often it is useful to keep track of some state that only needs to stay alive\n+/// for some small collection of tasks, or to perform some kind of final cleanup\n+/// when a collection of tasks is finished.\n+///\n+/// For example, when scanning, we need to keep the file reader alive while all scan\n+/// tasks run for a given file, and then we can gracefully close it when we finish the\n+/// file.\n+class ARROW_EXPORT AsyncTaskGroup : public AsyncTaskScheduler {\n+ public:\n+  /// Destructor for the task group\n   ///\n-  /// This visits the task serially without readahead.  If readahead or parallelism\n-  /// is desired then it should be added in the generator itself.\n+  /// The finish callback will not run until the task group is destroyed and all\n+  /// tasks are finished so you will generally want to eagerly call this at some point\n\nReview Comment:\n   \"eagerly call this\" meaning \"explicitly destroy the task group\"?\n\n\n\n##########\ncpp/src/arrow/util/async_util.h:\n##########\n@@ -145,206 +188,216 @@ class ARROW_EXPORT AsyncTaskScheduler {\n     /// acquired and the caller can proceed.  If a future is returned then the caller\n     /// should wait for the future to complete first.  When the returned future completes\n     /// the permits have NOT been acquired and the caller must call Acquire again\n+    ///\n+    /// \\param amt the number of permits to acquire\n     virtual std::optional<Future<>> TryAcquire(int amt) = 0;\n     /// Release amt permits\n     ///\n     /// This will possibly complete waiting futures and should probably not be\n     /// called while holding locks.\n+    ///\n+    /// \\param amt the number of permits to release\n     virtual void Release(int amt) = 0;\n \n     /// The size of the largest task that can run\n     ///\n     /// Incoming tasks will have their cost latched to this value to ensure\n-    /// they can still run (although they will generally be the only thing allowed to\n+    /// they can still run (although they will be the only thing allowed to\n     /// run at that time).\n     virtual int Capacity() = 0;\n+\n+    /// Pause the throttle\n+    ///\n+    /// Any tasks that have been submitted already will continue.  However, no new tasks\n+    /// will be run until the throttle is resumed.\n+    virtual void Pause() = 0;\n+    /// Resume the throttle\n+    ///\n+    /// Allows taks to be submitted again.  If there is a max_concurrent_cost limit then\n+    /// it will still apply.\n+    virtual void Resume() = 0;\n   };\n-  /// Create a throttle\n+\n+  /// Pause the throttle\n+  ///\n+  /// Any tasks that have been submitted already will continue.  However, no new tasks\n+  /// will be run until the throttle is resumed.\n+  virtual void Pause() = 0;\n+  /// Resume the throttle\n   ///\n-  /// This throttle is used to limit how many tasks can run at once.  The\n-  /// user should keep the throttle alive for the lifetime of the scheduler.\n-  /// The same throttle can be used in multiple schedulers.\n-  static std::unique_ptr<Throttle> MakeThrottle(int max_concurrent_cost);\n+  /// Allows taks to be submitted again.  If there is a max_concurrent_cost limit then\n+  /// it will still apply.\n+  virtual void Resume() = 0;\n \n-  /// Add a task to the scheduler\n+  /// Create a throttled view of a scheduler\n   ///\n-  /// If the scheduler is in an aborted state this call will return false and the task\n-  /// will never be run.  This is harmless and does not need to be guarded against.\n+  /// Tasks added via this view will be subjected to the throttle and, if the tasks cannot\n+  /// run immediately, will be placed into a queue.\n   ///\n-  /// If the scheduler is in an ended state then this call will cause an program abort.\n-  /// This represents a logic error in the program and should be avoidable.\n+  /// Using a throttled view after the underlying scheduler has finished is invalid.\n\nReview Comment:\n   nit, but it may be a little confusing/error-prone to have different API contracts for a subclass of the main API\n\n\n\n",
                    "created": "2022-11-09T15:59:52.186+0000",
                    "updated": "2022-11-09T15:59:52.186+0000",
                    "started": "2022-11-09T15:59:52.185+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "824648",
                    "issueId": "13478296"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478296/worklog/824760",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #14524:\nURL: https://github.com/apache/arrow/pull/14524#discussion_r1018410231\n\n\n##########\ncpp/src/arrow/util/async_util.h:\n##########\n@@ -145,206 +188,216 @@ class ARROW_EXPORT AsyncTaskScheduler {\n     /// acquired and the caller can proceed.  If a future is returned then the caller\n     /// should wait for the future to complete first.  When the returned future completes\n     /// the permits have NOT been acquired and the caller must call Acquire again\n+    ///\n+    /// \\param amt the number of permits to acquire\n     virtual std::optional<Future<>> TryAcquire(int amt) = 0;\n     /// Release amt permits\n     ///\n     /// This will possibly complete waiting futures and should probably not be\n     /// called while holding locks.\n+    ///\n+    /// \\param amt the number of permits to release\n     virtual void Release(int amt) = 0;\n \n     /// The size of the largest task that can run\n     ///\n     /// Incoming tasks will have their cost latched to this value to ensure\n-    /// they can still run (although they will generally be the only thing allowed to\n+    /// they can still run (although they will be the only thing allowed to\n     /// run at that time).\n     virtual int Capacity() = 0;\n+\n+    /// Pause the throttle\n+    ///\n+    /// Any tasks that have been submitted already will continue.  However, no new tasks\n+    /// will be run until the throttle is resumed.\n+    virtual void Pause() = 0;\n+    /// Resume the throttle\n+    ///\n+    /// Allows taks to be submitted again.  If there is a max_concurrent_cost limit then\n+    /// it will still apply.\n+    virtual void Resume() = 0;\n   };\n-  /// Create a throttle\n+\n+  /// Pause the throttle\n+  ///\n+  /// Any tasks that have been submitted already will continue.  However, no new tasks\n+  /// will be run until the throttle is resumed.\n+  virtual void Pause() = 0;\n+  /// Resume the throttle\n   ///\n-  /// This throttle is used to limit how many tasks can run at once.  The\n-  /// user should keep the throttle alive for the lifetime of the scheduler.\n-  /// The same throttle can be used in multiple schedulers.\n-  static std::unique_ptr<Throttle> MakeThrottle(int max_concurrent_cost);\n+  /// Allows taks to be submitted again.  If there is a max_concurrent_cost limit then\n+  /// it will still apply.\n+  virtual void Resume() = 0;\n \n-  /// Add a task to the scheduler\n+  /// Create a throttled view of a scheduler\n   ///\n-  /// If the scheduler is in an aborted state this call will return false and the task\n-  /// will never be run.  This is harmless and does not need to be guarded against.\n+  /// Tasks added via this view will be subjected to the throttle and, if the tasks cannot\n+  /// run immediately, will be placed into a queue.\n   ///\n-  /// If the scheduler is in an ended state then this call will cause an program abort.\n-  /// This represents a logic error in the program and should be avoidable.\n+  /// Using a throttled view after the underlying scheduler has finished is invalid.\n   ///\n-  /// If there are no limits on the number of concurrent tasks then the submit function\n-  /// will be run immediately.\n+  /// Although a shared_ptr is returned it should generally be assumed that the caller\n+  /// is being given exclusive ownership.  The shared_ptr is used to share the view with\n+  /// queued and submitted tasks and the lifetime of those is unpredictable.  It is\n+  /// important the caller keep the returned pointer alive for as long as they plan to add\n+  /// tasks to the view.\n   ///\n-  /// Otherwise, if there is a throttle, and it is full, then this task will be inserted\n-  /// into the scheduler's queue and submitted when there is space.\n+  /// \\param scheduler a scheduler to submit tasks to after throttling\n   ///\n-  /// The return value for this call can usually be ignored.  There is little harm in\n-  /// attempting to add tasks to an aborted scheduler.  It is only included for callers\n-  /// that want to avoid future task generation.\n+  /// This can be the root scheduler, another throttled scheduler, or a task group.  These\n+  /// are all composable.\n   ///\n-  /// \\return true if the task was submitted or queued, false if the task was ignored\n-  virtual bool AddTask(std::unique_ptr<Task> task) = 0;\n+  /// \\param max_concurrent_cost the maximum amount of cost allowed to run at any one time\n+  ///\n+  /// If a task is added that has a cost greater than max_concurrent_cost then its cost\n+  /// will be reduced to max_concurrent_cost so that it is still possible for the task to\n+  /// run.\n+  ///\n+  /// \\param queue the queue to use when tasks cannot be submitted\n+  ///\n+  /// By default a FIFO queue will be used.  However, a custom queue can be provided if\n+  /// some tasks have higher priority than other tasks.\n+  static std::shared_ptr<ThrottledAsyncTaskScheduler> Make(\n+      AsyncTaskScheduler* scheduler, int max_concurrent_cost,\n+      std::unique_ptr<Queue> queue = NULLPTR);\n \n-  /// Adds an async generator to the scheduler\n+  /// @brief Create a ThrottledAsyncTaskScheduler using a custom throttle\n   ///\n-  /// The async generator will be visited, one item at a time.  Submitting a task\n-  /// will consist of polling the generator for the next future.  The generator's future\n-  /// will then represent the task itself.\n+  /// \\see Make\n+  static std::shared_ptr<ThrottledAsyncTaskScheduler> MakeWithCustomThrottle(\n+      AsyncTaskScheduler* scheduler, std::unique_ptr<Throttle> throttle,\n+      std::unique_ptr<Queue> queue = NULLPTR);\n+};\n+\n+/// A utility to keep track of a collection of tasks\n+///\n+/// Often it is useful to keep track of some state that only needs to stay alive\n+/// for some small collection of tasks, or to perform some kind of final cleanup\n+/// when a collection of tasks is finished.\n+///\n+/// For example, when scanning, we need to keep the file reader alive while all scan\n+/// tasks run for a given file, and then we can gracefully close it when we finish the\n+/// file.\n+class ARROW_EXPORT AsyncTaskGroup : public AsyncTaskScheduler {\n+ public:\n+  /// Destructor for the task group\n   ///\n-  /// This visits the task serially without readahead.  If readahead or parallelism\n-  /// is desired then it should be added in the generator itself.\n+  /// The finish callback will not run until the task group is destroyed and all\n+  /// tasks are finished so you will generally want to eagerly call this at some point\n\nReview Comment:\n   Yes, good point.  This comment made more sense on an older iteration of the code.  I moved this paragraph to the `Make` call as that is the point where the unique_ptr is returned and made it clearer that the user should eagerly reset/destroy the unique_ptr.\n\n\n\n",
                    "created": "2022-11-09T21:01:33.265+0000",
                    "updated": "2022-11-09T21:01:33.265+0000",
                    "started": "2022-11-09T21:01:33.265+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "824760",
                    "issueId": "13478296"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478296/worklog/824762",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #14524:\nURL: https://github.com/apache/arrow/pull/14524#discussion_r1018414137\n\n\n##########\ncpp/src/arrow/util/async_util.h:\n##########\n@@ -145,206 +188,216 @@ class ARROW_EXPORT AsyncTaskScheduler {\n     /// acquired and the caller can proceed.  If a future is returned then the caller\n     /// should wait for the future to complete first.  When the returned future completes\n     /// the permits have NOT been acquired and the caller must call Acquire again\n+    ///\n+    /// \\param amt the number of permits to acquire\n     virtual std::optional<Future<>> TryAcquire(int amt) = 0;\n     /// Release amt permits\n     ///\n     /// This will possibly complete waiting futures and should probably not be\n     /// called while holding locks.\n+    ///\n+    /// \\param amt the number of permits to release\n     virtual void Release(int amt) = 0;\n \n     /// The size of the largest task that can run\n     ///\n     /// Incoming tasks will have their cost latched to this value to ensure\n-    /// they can still run (although they will generally be the only thing allowed to\n+    /// they can still run (although they will be the only thing allowed to\n     /// run at that time).\n     virtual int Capacity() = 0;\n+\n+    /// Pause the throttle\n+    ///\n+    /// Any tasks that have been submitted already will continue.  However, no new tasks\n+    /// will be run until the throttle is resumed.\n+    virtual void Pause() = 0;\n+    /// Resume the throttle\n+    ///\n+    /// Allows taks to be submitted again.  If there is a max_concurrent_cost limit then\n+    /// it will still apply.\n+    virtual void Resume() = 0;\n   };\n-  /// Create a throttle\n+\n+  /// Pause the throttle\n+  ///\n+  /// Any tasks that have been submitted already will continue.  However, no new tasks\n+  /// will be run until the throttle is resumed.\n+  virtual void Pause() = 0;\n+  /// Resume the throttle\n   ///\n-  /// This throttle is used to limit how many tasks can run at once.  The\n-  /// user should keep the throttle alive for the lifetime of the scheduler.\n-  /// The same throttle can be used in multiple schedulers.\n-  static std::unique_ptr<Throttle> MakeThrottle(int max_concurrent_cost);\n+  /// Allows taks to be submitted again.  If there is a max_concurrent_cost limit then\n+  /// it will still apply.\n+  virtual void Resume() = 0;\n \n-  /// Add a task to the scheduler\n+  /// Create a throttled view of a scheduler\n   ///\n-  /// If the scheduler is in an aborted state this call will return false and the task\n-  /// will never be run.  This is harmless and does not need to be guarded against.\n+  /// Tasks added via this view will be subjected to the throttle and, if the tasks cannot\n+  /// run immediately, will be placed into a queue.\n   ///\n-  /// If the scheduler is in an ended state then this call will cause an program abort.\n-  /// This represents a logic error in the program and should be avoidable.\n+  /// Using a throttled view after the underlying scheduler has finished is invalid.\n\nReview Comment:\n   I removed this sentence.  This is not a change in the API contracts.  For all schedulers it is safe to access the scheduler from within a task submitted to that scheduler (e.g. follow-up tasks).\r\n   \r\n   However, it is not safe to access a scheduler from a peer scheduler, though that concept doesn't have much meaning and adds confusion so probably doesn't need explanation.  For example, it would not be safe to add a task to the task group for file A from a task in the task group for file B, because file A might have finished before file B.\r\n   \r\n   The various returned pointers should make this fairly obvious (e.g. to do the above you would have to call `.get` on the `unique_ptr` returned when creating the task group for file A).\n\n\n\n",
                    "created": "2022-11-09T21:06:43.635+0000",
                    "updated": "2022-11-09T21:06:43.635+0000",
                    "started": "2022-11-09T21:06:43.635+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "824762",
                    "issueId": "13478296"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478296/worklog/824763",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #14524:\nURL: https://github.com/apache/arrow/pull/14524#discussion_r1018414412\n\n\n##########\ncpp/src/arrow/util/async_util.cc:\n##########\n@@ -100,345 +119,323 @@ class FifoQueue : public AsyncTaskScheduler::Queue {\n \n class AlreadyFailedScheduler : public AsyncTaskScheduler {\n\nReview Comment:\n   Nope, good catch.  Removed.\n\n\n\n",
                    "created": "2022-11-09T21:07:08.646+0000",
                    "updated": "2022-11-09T21:07:08.646+0000",
                    "started": "2022-11-09T21:07:08.646+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "824763",
                    "issueId": "13478296"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478296/worklog/824765",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #14524:\nURL: https://github.com/apache/arrow/pull/14524#discussion_r1018417571\n\n\n##########\ncpp/src/arrow/util/async_util.h:\n##########\n@@ -145,206 +188,216 @@ class ARROW_EXPORT AsyncTaskScheduler {\n     /// acquired and the caller can proceed.  If a future is returned then the caller\n     /// should wait for the future to complete first.  When the returned future completes\n     /// the permits have NOT been acquired and the caller must call Acquire again\n+    ///\n+    /// \\param amt the number of permits to acquire\n     virtual std::optional<Future<>> TryAcquire(int amt) = 0;\n     /// Release amt permits\n     ///\n     /// This will possibly complete waiting futures and should probably not be\n     /// called while holding locks.\n+    ///\n+    /// \\param amt the number of permits to release\n     virtual void Release(int amt) = 0;\n \n     /// The size of the largest task that can run\n     ///\n     /// Incoming tasks will have their cost latched to this value to ensure\n-    /// they can still run (although they will generally be the only thing allowed to\n+    /// they can still run (although they will be the only thing allowed to\n     /// run at that time).\n     virtual int Capacity() = 0;\n+\n+    /// Pause the throttle\n+    ///\n+    /// Any tasks that have been submitted already will continue.  However, no new tasks\n+    /// will be run until the throttle is resumed.\n+    virtual void Pause() = 0;\n+    /// Resume the throttle\n+    ///\n+    /// Allows taks to be submitted again.  If there is a max_concurrent_cost limit then\n+    /// it will still apply.\n+    virtual void Resume() = 0;\n   };\n-  /// Create a throttle\n+\n+  /// Pause the throttle\n+  ///\n+  /// Any tasks that have been submitted already will continue.  However, no new tasks\n+  /// will be run until the throttle is resumed.\n+  virtual void Pause() = 0;\n+  /// Resume the throttle\n   ///\n-  /// This throttle is used to limit how many tasks can run at once.  The\n-  /// user should keep the throttle alive for the lifetime of the scheduler.\n-  /// The same throttle can be used in multiple schedulers.\n-  static std::unique_ptr<Throttle> MakeThrottle(int max_concurrent_cost);\n+  /// Allows taks to be submitted again.  If there is a max_concurrent_cost limit then\n+  /// it will still apply.\n+  virtual void Resume() = 0;\n \n-  /// Add a task to the scheduler\n+  /// Create a throttled view of a scheduler\n   ///\n-  /// If the scheduler is in an aborted state this call will return false and the task\n-  /// will never be run.  This is harmless and does not need to be guarded against.\n+  /// Tasks added via this view will be subjected to the throttle and, if the tasks cannot\n+  /// run immediately, will be placed into a queue.\n   ///\n-  /// If the scheduler is in an ended state then this call will cause an program abort.\n-  /// This represents a logic error in the program and should be avoidable.\n+  /// Using a throttled view after the underlying scheduler has finished is invalid.\n\nReview Comment:\n   Sounds good to me, thanks!\n\n\n\n",
                    "created": "2022-11-09T21:11:34.000+0000",
                    "updated": "2022-11-09T21:11:34.000+0000",
                    "started": "2022-11-09T21:11:34.000+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "824765",
                    "issueId": "13478296"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478296/worklog/824786",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace merged PR #14524:\nURL: https://github.com/apache/arrow/pull/14524\n\n\n",
                    "created": "2022-11-09T23:45:06.940+0000",
                    "updated": "2022-11-09T23:45:06.940+0000",
                    "started": "2022-11-09T23:45:06.939+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "824786",
                    "issueId": "13478296"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478296/worklog/824931",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot commented on PR #14524:\nURL: https://github.com/apache/arrow/pull/14524#issuecomment-1310275960\n\n   Benchmark runs are scheduled for baseline = a590b00b7af552ec20a13c46c0d578b211bac0a0 and contender = 3da803db456536782e6ad1cd6cb4f5d08d6a5d6a. 3da803db456536782e6ad1cd6cb4f5d08d6a5d6a is a master commit associated with this PR. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Finished :arrow_down:0.0% :arrow_up:0.0%] [ec2-t3-xlarge-us-east-2](https://conbench.ursa.dev/compare/runs/5c9a7ca895b54babb73788a5974501a4...3db54def2f7940fbbcb59376fc0ef1b9/)\n   [Failed :arrow_down:0.58% :arrow_up:0.17%] [test-mac-arm](https://conbench.ursa.dev/compare/runs/8da766f13f4b47f989bc8cd65a425085...5225c941108040ba924c7a6ce8a3b711/)\n   [Finished :arrow_down:0.27% :arrow_up:0.0%] [ursa-i9-9960x](https://conbench.ursa.dev/compare/runs/f4724f99d73944548c7f7e5ef6c77f40...5dfb0a3e09be4d9e8e2a62e74956fda4/)\n   [Finished :arrow_down:1.06% :arrow_up:0.28%] [ursa-thinkcentre-m75q](https://conbench.ursa.dev/compare/runs/09c48a269abd48d7b833dda558db1da7...d22ccad69a474b5e82c840151567a2bf/)\n   Buildkite builds:\n   [Finished] [`3da803db` ec2-t3-xlarge-us-east-2](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ec2-t3-xlarge-us-east-2/builds/1844)\n   [Finished] [`3da803db` test-mac-arm](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-test-mac-arm/builds/1866)\n   [Finished] [`3da803db` ursa-i9-9960x](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-i9-9960x/builds/1832)\n   [Finished] [`3da803db` ursa-thinkcentre-m75q](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-thinkcentre-m75q/builds/1858)\n   [Finished] [`a590b00b` ec2-t3-xlarge-us-east-2](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ec2-t3-xlarge-us-east-2/builds/1843)\n   [Failed] [`a590b00b` test-mac-arm](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-test-mac-arm/builds/1865)\n   [Finished] [`a590b00b` ursa-i9-9960x](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-i9-9960x/builds/1831)\n   [Finished] [`a590b00b` ursa-thinkcentre-m75q](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-thinkcentre-m75q/builds/1857)\n   Supported benchmarks:\n   ec2-t3-xlarge-us-east-2: Supported benchmark langs: Python, R. Runs only benchmarks with cloud = True\n   test-mac-arm: Supported benchmark langs: C++, Python, R\n   ursa-i9-9960x: Supported benchmark langs: Python, R, JavaScript\n   ursa-thinkcentre-m75q: Supported benchmark langs: C++, Java\n   \n\n\n",
                    "created": "2022-11-10T13:22:38.927+0000",
                    "updated": "2022-11-10T13:22:38.927+0000",
                    "started": "2022-11-10T13:22:38.927+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "824931",
                    "issueId": "13478296"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 9600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@7a18619b[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@70a139bc[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@61c0bea2[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@18d517ff[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@f0b36d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@30697a8e[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@54b8f78f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@64e27808[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@618cc422[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@1aca7f97[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@95de7ce[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@7e08fcd5[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 9600,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Nov 09 23:45:09 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-11-09T23:45:09.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-17509/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2022-08-24T00:16:55.000+0000",
        "updated": "2022-11-10T13:22:39.000+0000",
        "timeoriginalestimate": null,
        "description": "Right now the AsyncScheduler requires that we call End.  This is to distinguish between a scheduler running out of tasks because it hit an idle period (in which case it shouldn't mark itself finished) and a scheduler running out of tasks because it is truly done (in which case it should mark itself finished).\r\n\r\nIt should be possible to require that scheduler tasks only be added by existing tasks.  When creating a scheduler one would supply an \"initial task\" to bootstrap the first set of tasks.  In this case we could get rid of the End method because the only time a scheduler will run out of tasks is when it is finished.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 9600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Simplify async scheduler by removing the need to call End",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478296/comment/17631335",
                    "id": "17631335",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Issue resolved by pull request 14524\n[https://github.com/apache/arrow/pull/14524]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-11-09T23:45:09.764+0000",
                    "updated": "2022-11-09T23:45:09.764+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z180cg:",
        "customfield_12314139": null
    }
}