{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13435157",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13435157",
    "key": "ARROW-16006",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351550",
                "id": "12351550",
                "name": "9.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-08-03"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12350591",
                "id": "12350591",
                "description": "",
                "name": "7.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-02-03"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12636096",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12636096",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13434628",
                    "key": "ARROW-15975",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13434628",
                    "fields": {
                        "summary": "[C++] Document VisitArrayInline and type traits",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=willjones127",
            "name": "willjones127",
            "key": "willjones127",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34058",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34058",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34058",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34058"
            },
            "displayName": "Will Jones",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=willjones127",
            "name": "willjones127",
            "key": "willjones127",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34058",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34058",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34058",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34058"
            },
            "displayName": "Will Jones",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=willjones127",
            "name": "willjones127",
            "key": "willjones127",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34058",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34058",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34058",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34058"
            },
            "displayName": "Will Jones",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 26400,
            "total": 26400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 26400,
            "total": 26400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-16006/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 44,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13435157/worklog/751817",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #12775:\nURL: https://github.com/apache/arrow/pull/12775#issuecomment-1086391509\n\n\n   https://issues.apache.org/jira/browse/ARROW-16006\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-04-01T22:43:30.404+0000",
                    "updated": "2022-04-01T22:43:30.404+0000",
                    "started": "2022-04-01T22:43:30.403+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "751817",
                    "issueId": "13435157"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13435157/worklog/764502",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wjones127 commented on PR #12775:\nURL: https://github.com/apache/arrow/pull/12775#issuecomment-1113764393\n\n   Not sure if this is related to the appveyor segfault, but some batch sizes produce a segfault:\r\n   \r\n   ```\r\n   # segfault for me\r\n   rapidjson-row-converter 1000 500\r\n   \r\n   # runs fine\r\n   rapidjson-row-converter 1000 800\r\n   ```\n\n\n",
                    "created": "2022-04-29T21:38:04.304+0000",
                    "updated": "2022-04-29T21:38:04.304+0000",
                    "started": "2022-04-29T21:38:04.304+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "764502",
                    "issueId": "13435157"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13435157/worklog/778165",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wjones127 commented on PR #12775:\nURL: https://github.com/apache/arrow/pull/12775#issuecomment-1146131971\n\n   Just rebased. CI failure is unrelated.\r\n   \r\n   @emkornfield @pitrou Would one of you be willing to review soon?\n\n\n",
                    "created": "2022-06-03T16:06:11.056+0000",
                    "updated": "2022-06-03T16:06:11.056+0000",
                    "started": "2022-06-03T16:06:11.056+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "778165",
                    "issueId": "13435157"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13435157/worklog/779909",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on PR #12775:\nURL: https://github.com/apache/arrow/pull/12775#issuecomment-1151043295\n\n   @wjones127 I don't know if that would be painful or not, but if not, would you like to submit the RecordBatchBuilder API changes in a separate PR that we can merge quickly?\n\n\n",
                    "created": "2022-06-09T12:11:58.871+0000",
                    "updated": "2022-06-09T12:11:58.871+0000",
                    "started": "2022-06-09T12:11:58.871+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "779909",
                    "issueId": "13435157"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13435157/worklog/779912",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #12775:\nURL: https://github.com/apache/arrow/pull/12775#discussion_r893427486\n\n\n##########\ncpp/src/arrow/row_conversion.h:\n##########\n@@ -0,0 +1,192 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/iterator.h\"\n+\n+namespace arrow {\n+\n+/// \\brief Base class for Arrow to row converter.\n+///\n+/// To use, specialize the conversion for a particular row type.\n\nReview Comment:\n   Hmm... so that means that for a given RowType I cannot implement two different converters (for different actual formats) because symbols would clash. That sounds a bit limiting.\n\n\n\n",
                    "created": "2022-06-09T12:14:30.834+0000",
                    "updated": "2022-06-09T12:14:30.834+0000",
                    "started": "2022-06-09T12:14:30.834+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "779912",
                    "issueId": "13435157"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13435157/worklog/779913",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on PR #12775:\nURL: https://github.com/apache/arrow/pull/12775#issuecomment-1151047537\n\n   I don't know what the exact requirements for this are, but if performance is not important then do note there are already conversion utilities in `stl.h` that go back and forth between `arrow::Table` and `std::vector<std::tuple<...>>`.\n\n\n",
                    "created": "2022-06-09T12:16:34.748+0000",
                    "updated": "2022-06-09T12:16:34.748+0000",
                    "started": "2022-06-09T12:16:34.748+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "779913",
                    "issueId": "13435157"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13435157/worklog/779919",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #12775:\nURL: https://github.com/apache/arrow/pull/12775#discussion_r893439001\n\n\n##########\ncpp/src/arrow/row_conversion.h:\n##########\n@@ -0,0 +1,192 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/iterator.h\"\n+\n+namespace arrow {\n+\n+/// \\brief Base class for Arrow to row converter.\n+///\n+/// To use, specialize the conversion for a particular row type.\n\nReview Comment:\n   Ah, I hadn't seen that you had to subclass in addition to specializing the class. My bad.\n\n\n\n",
                    "created": "2022-06-09T12:26:52.097+0000",
                    "updated": "2022-06-09T12:26:52.097+0000",
                    "started": "2022-06-09T12:26:52.097+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "779919",
                    "issueId": "13435157"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13435157/worklog/779923",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on PR #12775:\nURL: https://github.com/apache/arrow/pull/12775#issuecomment-1151059847\n\n   Generally I have mixed feelings about exposing and maintaing this API. On the one hand it can easy writing conversions a bit, on the other hand it doesn't really abstract the task a lot anyway (mostly it seems to translate between iterator <-> record batch sequence <-> table).\r\n   \r\n   Perhaps what we need is simpler ways of writing the translations mentioned above?\r\n   \r\n   cc @bkietz for opinions\n\n\n",
                    "created": "2022-06-09T12:29:48.050+0000",
                    "updated": "2022-06-09T12:29:48.050+0000",
                    "started": "2022-06-09T12:29:48.050+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "779923",
                    "issueId": "13435157"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13435157/worklog/780033",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wjones127 commented on PR #12775:\nURL: https://github.com/apache/arrow/pull/12775#issuecomment-1151339269\n\n   > I don't know what the exact requirements for this are, but if performance is not important then do note there are already conversion utilities in stl.h that go back and forth between arrow::Table and std::vector<std::tuple<...>>.\r\n   \r\n   One of the intended use case is designing performant connectors for NoSQL databases, who typically provide results as a vector or iterator of row / document objects. For example, DynamoDB's C++ SDK returns `Aws::Map<Aws::String, Aws::DynamoDB::Model::AttributeValue>`. Cassandra has a similar class. More generally, there are a lot of existing systems that work off of rows that an adopter of Arrow may need to connect to.\r\n   \r\n   Looking that the utilities in stl.h, one thing I haven't explored is whether `arrow::stl::ConversionTraits<T>` and `arrow::CTypeTraits<T>`.\r\n   \r\n   > Generally I have mixed feelings about exposing and maintaining this API. On the one hand it can ease writing conversions a bit, on the other hand it doesn't really abstract the task a lot anyway (mostly it seems to translate between iterator <-> record batch sequence <-> table).\r\n   \r\n   I agree that the new API doesn't do that much on the task; the translation it does between iterator, RB, and tables is mostly for convenience. The main thing it does is establish a pattern of converting one batch at a time, and potentially operating on a smaller batch size than a table is currently grouped in for cases where the inner conversion loops performs better with smaller batches.\r\n   \r\n   It's hard to make an API that general enough that handles most of the conversion; that's why most of this PR is an example demonstrating how to use Arrow's `VisitXInline` methods, type traits, and conversions to C types to implement row conversions. Those features make writing the row-conversions a lot easier, but they aren't well-documented for end users. If we think the new API doesn't add much, I could just fold its logic into the example and this could just be a docs PR \ud83e\udd37 .\r\n   \n\n\n",
                    "created": "2022-06-09T16:18:22.756+0000",
                    "updated": "2022-06-09T16:18:22.756+0000",
                    "started": "2022-06-09T16:18:22.755+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780033",
                    "issueId": "13435157"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13435157/worklog/780034",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wjones127 commented on PR #12775:\nURL: https://github.com/apache/arrow/pull/12775#issuecomment-1151339865\n\n   > @wjones127 I don't know if that would be painful or not, but if not, would you like to submit the RecordBatchBuilder API changes in a separate PR that we can merge quickly?\r\n   \r\n   Yes, I should do that. I was being lazy not making a separate PR.\n\n\n",
                    "created": "2022-06-09T16:19:00.475+0000",
                    "updated": "2022-06-09T16:19:00.475+0000",
                    "started": "2022-06-09T16:19:00.475+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780034",
                    "issueId": "13435157"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13435157/worklog/780036",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on PR #12775:\nURL: https://github.com/apache/arrow/pull/12775#issuecomment-1151341823\n\n   cc @lidavidm for opinions on the NoSQL connector use case.\n\n\n",
                    "created": "2022-06-09T16:21:14.155+0000",
                    "updated": "2022-06-09T16:21:14.155+0000",
                    "started": "2022-06-09T16:21:14.154+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780036",
                    "issueId": "13435157"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13435157/worklog/780089",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #12775:\nURL: https://github.com/apache/arrow/pull/12775#discussion_r893820377\n\n\n##########\ndocs/source/cpp/examples/row_columnar_conversion.rst:\n##########\n@@ -21,7 +21,98 @@\n Row to columnar conversion\n ==========================\n \n+Fixed Schemas\n+-------------\n+\n The following example converts an array of structs to a :class:`arrow::Table`\n instance, and then converts it back to the original array of structs.\n \n .. literalinclude:: ../../../../cpp/examples/arrow/row_wise_conversion_example.cc\n+\n+\n+Dynamic Schemas\n+---------------\n+\n+For schemas not known at compile time, implement an :class:`arrow::ToRowConverter`\n+or an :class:`arrow::FromRowConverter`.\n+The following example shows how to implement conversion between `rapidjson::Document`\n\nReview Comment:\n   ```suggestion\r\n   The following example shows how to implement conversion between ``rapidjson::Document``\r\n   ```\n\n\n\n##########\ncpp/examples/arrow/rapidjson_row_converter.cc:\n##########\n@@ -0,0 +1,590 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/result.h>\n+#include <arrow/table_builder.h>\n+#include <arrow/type_traits.h>\n+#include <arrow/util/iterator.h>\n+#include <arrow/util/logging.h>\n+#include <arrow/visit_array_inline.h>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <cassert>\n+#include <iostream>\n+#include <vector>\n+\n+// Transforming dynamic row data into Arrow data\n+// When building connectors to other data systems, it's common to receive data in\n+// row-based structures. While the row_wise_conversion_example.cc shows how to\n+// handle this conversion for fixed schemas, this example demonstrates how to\n+// writer converters for arbitrary schemas.\n+//\n+// As an example, this conversion is between Arrow and rapidjson::Documents.\n+//\n+// We use the following helpers and patterns here:\n+//  * arrow::ToRowConverter and arrow::FromRowConverter, which provide additional\n+//    conversion methods given a basic converter\n+//  * arrow::VisitArrayInline and arrow::VisitTypeInline for implementing a visitor\n+//    pattern with Arrow to handle different array types\n+//  * arrow::enable_if_primitive_ctype to create a template method that handles\n+//  * conversion for Arrow types that have corresponding C types (bool, integer,\n+//    float).\n+\n+rapidjson::Value kNullJsonSingleton = rapidjson::Value();\n+\n+/// \\brief Builder that holds state for a single conversion.\n+///\n+/// Implements Visit() methods for each type of Arrow Array that set the values\n+/// of the corresponding fields in each row.\n+class RowBatchBuilder {\n+ public:\n+  explicit RowBatchBuilder(int64_t num_rows) : field_(nullptr) {\n+    // Reserve all of the space required up-front to avoid unnecessary resizing\n+    rows_.reserve(num_rows);\n+\n+    for (int64_t i = 0; i < num_rows; ++i) {\n+      rows_.push_back(rapidjson::Document());\n+      rows_[i].SetObject();\n+    }\n+  }\n+\n+  /// \\brief Set which field to convert.\n+  void SetField(std::shared_ptr<arrow::Field> field) { field_ = std::move(field); }\n+\n+  /// \\brief Retrieve converted rows from builder.\n+  std::vector<rapidjson::Document> Rows() && { return std::move(rows_); }\n+\n+  // Default implementation\n+  arrow::Status Visit(const arrow::Array& array) {\n+    return arrow::Status::NotImplemented(\n+        \"Can not convert to json document for array of type \", array.type()->ToString());\n+  }\n+\n+  // Handles booleans, integers, floats\n+  template <typename ArrayType, typename DataClass = typename ArrayType::TypeClass>\n+  arrow::enable_if_primitive_ctype<DataClass, arrow::Status> Visit(\n+      const ArrayType& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, array.Value(i), rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StringArray& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        // StringArray.Value returns a string view\n+        auto value_view = array.Value(i);\n+        rapidjson::Value value;\n+        value.SetString(value_view.data(),\n+                        static_cast<rapidjson::SizeType>(value_view.size()),\n+                        rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, value, rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StructArray& array) {\n+    const arrow::StructType* type = array.struct_type();\n+\n+    RowBatchBuilder child_builder(rows_.size());\n+    for (int i = 0; i < type->num_fields(); ++i) {\n+      std::shared_ptr<arrow::Field> child_field = type->field(i);\n+      child_builder.SetField(std::move(child_field));\n+      ARROW_RETURN_NOT_OK(arrow::VisitArrayInline(*array.field(i).get(), &child_builder));\n+    }\n+    std::vector<rapidjson::Document> rows = std::move(child_builder).Rows();\n+\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        // Must copy value to new allocator\n+        rapidjson::Value row_val;\n+        row_val.CopyFrom(rows[i], rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, row_val, rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::ListArray& array) {\n+    // First create rows from values\n+    std::shared_ptr<arrow::Array> values = array.values();\n\nReview Comment:\n   While minor, I wonder why `BaseListArray::values` doesn't return `const Array&` or at least `const std::shared_ptr<Array>&`\u2026not that it should be a big deal here.\n\n\n\n##########\ncpp/examples/arrow/rapidjson_row_converter.cc:\n##########\n@@ -0,0 +1,590 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/result.h>\n+#include <arrow/table_builder.h>\n+#include <arrow/type_traits.h>\n+#include <arrow/util/iterator.h>\n+#include <arrow/util/logging.h>\n+#include <arrow/visit_array_inline.h>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <cassert>\n+#include <iostream>\n+#include <vector>\n+\n+// Transforming dynamic row data into Arrow data\n+// When building connectors to other data systems, it's common to receive data in\n+// row-based structures. While the row_wise_conversion_example.cc shows how to\n+// handle this conversion for fixed schemas, this example demonstrates how to\n+// writer converters for arbitrary schemas.\n+//\n+// As an example, this conversion is between Arrow and rapidjson::Documents.\n+//\n+// We use the following helpers and patterns here:\n+//  * arrow::ToRowConverter and arrow::FromRowConverter, which provide additional\n+//    conversion methods given a basic converter\n+//  * arrow::VisitArrayInline and arrow::VisitTypeInline for implementing a visitor\n+//    pattern with Arrow to handle different array types\n+//  * arrow::enable_if_primitive_ctype to create a template method that handles\n+//  * conversion for Arrow types that have corresponding C types (bool, integer,\n+//    float).\n+\n+rapidjson::Value kNullJsonSingleton = rapidjson::Value();\n+\n+/// \\brief Builder that holds state for a single conversion.\n+///\n+/// Implements Visit() methods for each type of Arrow Array that set the values\n+/// of the corresponding fields in each row.\n+class RowBatchBuilder {\n+ public:\n+  explicit RowBatchBuilder(int64_t num_rows) : field_(nullptr) {\n+    // Reserve all of the space required up-front to avoid unnecessary resizing\n+    rows_.reserve(num_rows);\n+\n+    for (int64_t i = 0; i < num_rows; ++i) {\n+      rows_.push_back(rapidjson::Document());\n+      rows_[i].SetObject();\n+    }\n+  }\n+\n+  /// \\brief Set which field to convert.\n+  void SetField(std::shared_ptr<arrow::Field> field) { field_ = std::move(field); }\n\nReview Comment:\n   and here, why not take say `const arrow::Field&` to avoid a shared_ptr copy? (though again, probably all of these don't add up to anything meaningful\u2026)\n\n\n\n##########\ncpp/examples/arrow/CMakeLists.txt:\n##########\n@@ -17,6 +17,8 @@\n \n add_arrow_example(row_wise_conversion_example)\n \n+add_arrow_example(rapidjson_row_converter)\n\nReview Comment:\n   wrap in `if(ARROW_JSON)`?\n\n\n\n##########\ncpp/examples/arrow/rapidjson_row_converter.cc:\n##########\n@@ -0,0 +1,590 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/result.h>\n+#include <arrow/table_builder.h>\n+#include <arrow/type_traits.h>\n+#include <arrow/util/iterator.h>\n+#include <arrow/util/logging.h>\n+#include <arrow/visit_array_inline.h>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <cassert>\n+#include <iostream>\n+#include <vector>\n+\n+// Transforming dynamic row data into Arrow data\n+// When building connectors to other data systems, it's common to receive data in\n+// row-based structures. While the row_wise_conversion_example.cc shows how to\n+// handle this conversion for fixed schemas, this example demonstrates how to\n+// writer converters for arbitrary schemas.\n+//\n+// As an example, this conversion is between Arrow and rapidjson::Documents.\n+//\n+// We use the following helpers and patterns here:\n+//  * arrow::ToRowConverter and arrow::FromRowConverter, which provide additional\n+//    conversion methods given a basic converter\n+//  * arrow::VisitArrayInline and arrow::VisitTypeInline for implementing a visitor\n+//    pattern with Arrow to handle different array types\n+//  * arrow::enable_if_primitive_ctype to create a template method that handles\n+//  * conversion for Arrow types that have corresponding C types (bool, integer,\n+//    float).\n+\n+rapidjson::Value kNullJsonSingleton = rapidjson::Value();\n+\n+/// \\brief Builder that holds state for a single conversion.\n+///\n+/// Implements Visit() methods for each type of Arrow Array that set the values\n+/// of the corresponding fields in each row.\n+class RowBatchBuilder {\n+ public:\n+  explicit RowBatchBuilder(int64_t num_rows) : field_(nullptr) {\n+    // Reserve all of the space required up-front to avoid unnecessary resizing\n+    rows_.reserve(num_rows);\n+\n+    for (int64_t i = 0; i < num_rows; ++i) {\n+      rows_.push_back(rapidjson::Document());\n+      rows_[i].SetObject();\n+    }\n+  }\n+\n+  /// \\brief Set which field to convert.\n+  void SetField(std::shared_ptr<arrow::Field> field) { field_ = std::move(field); }\n+\n+  /// \\brief Retrieve converted rows from builder.\n+  std::vector<rapidjson::Document> Rows() && { return std::move(rows_); }\n+\n+  // Default implementation\n+  arrow::Status Visit(const arrow::Array& array) {\n+    return arrow::Status::NotImplemented(\n+        \"Can not convert to json document for array of type \", array.type()->ToString());\n+  }\n+\n+  // Handles booleans, integers, floats\n+  template <typename ArrayType, typename DataClass = typename ArrayType::TypeClass>\n+  arrow::enable_if_primitive_ctype<DataClass, arrow::Status> Visit(\n+      const ArrayType& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, array.Value(i), rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StringArray& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        // StringArray.Value returns a string view\n+        auto value_view = array.Value(i);\n+        rapidjson::Value value;\n+        value.SetString(value_view.data(),\n+                        static_cast<rapidjson::SizeType>(value_view.size()),\n+                        rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, value, rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StructArray& array) {\n+    const arrow::StructType* type = array.struct_type();\n+\n+    RowBatchBuilder child_builder(rows_.size());\n+    for (int i = 0; i < type->num_fields(); ++i) {\n+      std::shared_ptr<arrow::Field> child_field = type->field(i);\n+      child_builder.SetField(std::move(child_field));\n+      ARROW_RETURN_NOT_OK(arrow::VisitArrayInline(*array.field(i).get(), &child_builder));\n+    }\n+    std::vector<rapidjson::Document> rows = std::move(child_builder).Rows();\n+\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        // Must copy value to new allocator\n+        rapidjson::Value row_val;\n+        row_val.CopyFrom(rows[i], rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, row_val, rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::ListArray& array) {\n+    // First create rows from values\n+    std::shared_ptr<arrow::Array> values = array.values();\n+    RowBatchBuilder child_builder(values->length());\n+    std::shared_ptr<arrow::Field> value_field = array.list_type()->value_field();\n+    std::string value_field_name = value_field->name();\n+    child_builder.SetField(value_field);\n+    ARROW_RETURN_NOT_OK(arrow::VisitArrayInline(*values.get(), &child_builder));\n+\n+    std::vector<rapidjson::Document> rows = std::move(child_builder).Rows();\n+\n+    int64_t values_i = 0;\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      rapidjson::Document::AllocatorType& allocator = rows_[i].GetAllocator();\n+      auto array_len = array.value_length(i);\n+\n+      rapidjson::Value value;\n+      value.SetArray();\n+      value.Reserve(array_len, allocator);\n+\n+      for (int64_t j = 0; j < array_len; ++j) {\n+        rapidjson::Value row_val;\n+        // Must copy value to new allocator\n+        row_val.CopyFrom(rows[values_i][value_field_name.c_str()], allocator);\n+        value.PushBack(row_val, allocator);\n+        ++values_i;\n+      }\n+\n+      rapidjson::Value str_key(field_->name().c_str(), allocator);\n+      rows_[i].AddMember(str_key, value, allocator);\n+    }\n+\n+    return arrow::Status::OK();\n+  }\n+\n+ private:\n+  std::shared_ptr<arrow::Field> field_;\n+  std::vector<rapidjson::Document> rows_;\n+};  // RowBatchBuilder\n+\n+class ArrowToDocumentConverter : public arrow::ToRowConverter<rapidjson::Document> {\n+ public:\n+  arrow::Result<std::vector<rapidjson::Document>> ConvertToVector(\n+      std::shared_ptr<arrow::RecordBatch> batch) override {\n+    RowBatchBuilder builder{batch->num_rows()};\n+\n+    for (int i = 0; i < batch->num_columns(); ++i) {\n+      builder.SetField(std::move(batch->schema()->field(i)));\n+      ARROW_RETURN_NOT_OK(arrow::VisitArrayInline(*batch->column(i).get(), &builder));\n+    }\n+\n+    return std::move(builder).Rows();\n+  }\n+};  // ArrowToDocumentConverter\n+\n+/// \\brief Iterator over rows values of a document for a given field\n+///\n+/// path and array_levels are used to address each field in a JSON document. As\n+/// an example, consider this JSON document:\n+/// {\n+///     \"x\": 3,                   // path: [\"x\"],             array_levels: 0\n+///     \"files\": [                // path: [\"files\"],         array_levels: 0\n+///         {                     // path: [\"files\"],         array_levels: 1\n+///             \"path\": \"my_str\", // path: [\"files\", \"path\"], array_levels: 1\n+///             \"sizes\": [        // path: [\"files\", \"size\"], array_levels: 1\n+///                 20,           // path: [\"files\", \"size\"], array_levels: 2\n+///                 22\n+///             ]\n+///         }\n+///     ]\n+/// },\n+class DocValuesIterator {\n+ public:\n+  /// \\param rows vector of rows\n+  /// \\param path field names to enter\n+  /// \\param array_levels number of arrays to enter\n+  DocValuesIterator(const std::vector<rapidjson::Document>& rows,\n+                    std::vector<std::string> path, int64_t array_levels)\n+      : rows(rows), path(std::move(path)), array_levels(array_levels) {}\n+\n+  const rapidjson::Value* NextArrayOrRow(const rapidjson::Value* value, size_t* path_i,\n+                                         int64_t* arr_i) {\n+    while (array_stack.size() > 0) {\n+      ArrayPosition& pos = array_stack.back();\n+      // Try to get next position in Array\n+      if (pos.index + 1 < pos.array_node->Size()) {\n+        ++pos.index;\n+        value = &(*pos.array_node)[pos.index];\n+        *path_i = pos.path_index;\n+        *arr_i = array_stack.size();\n+        return value;\n+      } else {\n+        array_stack.pop_back();\n+      }\n+    }\n+    ++row_i;\n+    if (row_i < rows.size()) {\n+      value = static_cast<const rapidjson::Value*>(&rows[row_i]);\n+    } else {\n+      value = nullptr;\n+    }\n+    *path_i = 0;\n+    *arr_i = 0;\n+    return value;\n+  }\n+\n+  arrow::Result<const rapidjson::Value*> Next() {\n+    const rapidjson::Value* value = nullptr;\n+    size_t path_i;\n+    int64_t arr_i;\n+    // Can either start at document or at last array level\n+    if (array_stack.size() > 0) {\n+      auto pos = array_stack.back();\n+      value = pos.array_node;\n+      path_i = pos.path_index;\n+      arr_i = array_stack.size() - 1;\n+    }\n+\n+    value = NextArrayOrRow(value, &path_i, &arr_i);\n+\n+    // Traverse to desired level (with possible backtracking as needed)\n+    while (path_i < path.size() || arr_i < array_levels) {\n+      if (value == nullptr) {\n+        return value;\n+      } else if (value->IsArray() && value->Size() > 0) {\n+        ArrayPosition pos;\n+        pos.array_node = value;\n+        pos.path_index = path_i;\n+        pos.index = 0;\n+        array_stack.push_back(pos);\n+\n+        value = &(*value)[0];\n+        ++arr_i;\n+      } else if (value->IsArray()) {\n+        // Empty array means we need to backtrack and go to next array or row\n+        value = NextArrayOrRow(value, &path_i, &arr_i);\n+      } else if (value->HasMember(path[path_i].c_str())) {\n+        value = &(*value)[path[path_i].c_str()];\n+        ++path_i;\n+      } else {\n+        return &kNullJsonSingleton;\n+      }\n+    }\n+\n+    // Return value\n+    return value;\n+  }\n+\n+ protected:\n+  const std::vector<rapidjson::Document>& rows;\n+  std::vector<std::string> path;\n+  int64_t array_levels;\n+  size_t row_i = -1;  // index of current row\n+\n+  // Info about array position for one array level in array stack\n+  struct ArrayPosition {\n+    const rapidjson::Value* array_node;\n+    int64_t path_index;\n+    rapidjson::SizeType index;\n+  };\n+  std::vector<ArrayPosition> array_stack;\n+};\n+\n+class JsonValueConverter {\n+ public:\n+  explicit JsonValueConverter(const std::vector<rapidjson::Document>& rows)\n+      : rows_(rows), array_levels_(0) {}\n+\n+  JsonValueConverter(const std::vector<rapidjson::Document>& rows,\n+                     const std::vector<std::string>& root_path, int64_t array_levels)\n+      : rows_(rows), root_path_(root_path), array_levels_(array_levels) {}\n+\n+  /// \\brief For field passed in, append corresponding values to builder\n+  arrow::Status Convert(const arrow::Field& field, arrow::ArrayBuilder* builder) {\n+    return Convert(field, field.name(), builder);\n+  }\n+\n+  /// \\brief For field passed in, append corresponding values to builder\n+  arrow::Status Convert(const arrow::Field& field, const std::string& field_name,\n+                        arrow::ArrayBuilder* builder) {\n+    field_name_ = field_name;\n+    builder_ = builder;\n+    ARROW_RETURN_NOT_OK(arrow::VisitTypeInline(*field.type().get(), this));\n+    return arrow::Status::OK();\n+  }\n+\n+  // Default implementation\n+  arrow::Status Visit(const arrow::DataType& type) {\n+    return arrow::Status::NotImplemented(\n+        \"Can not convert to json document for array of type \", type.ToString());\n+  }\n+\n+  arrow::Status Visit(const arrow::Int64Type& type) {\n+    arrow::Int64Builder* builder = static_cast<arrow::Int64Builder*>(builder_);\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      if (value->IsNull()) {\n+        ARROW_RETURN_NOT_OK(builder->AppendNull());\n+      } else {\n+        if (value->IsUint()) {\n+          ARROW_RETURN_NOT_OK(builder->Append(value->GetUint()));\n+        } else if (value->IsInt()) {\n+          ARROW_RETURN_NOT_OK(builder->Append(value->GetInt()));\n+        } else if (value->IsUint64()) {\n+          ARROW_RETURN_NOT_OK(builder->Append(value->GetUint64()));\n+        } else if (value->IsInt64()) {\n+          ARROW_RETURN_NOT_OK(builder->Append(value->GetInt64()));\n+        } else {\n+          return arrow::Status::Invalid(\"Value is not an integer\");\n+        }\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::DoubleType& type) {\n+    arrow::DoubleBuilder* builder = static_cast<arrow::DoubleBuilder*>(builder_);\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      if (value->IsNull()) {\n+        ARROW_RETURN_NOT_OK(builder->AppendNull());\n+      } else {\n+        ARROW_RETURN_NOT_OK(builder->Append(value->GetDouble()));\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StringType& type) {\n+    arrow::StringBuilder* builder = static_cast<arrow::StringBuilder*>(builder_);\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      if (value->IsNull()) {\n+        ARROW_RETURN_NOT_OK(builder->AppendNull());\n+      } else {\n+        ARROW_RETURN_NOT_OK(builder->Append(value->GetString()));\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::BooleanType& type) {\n+    arrow::BooleanBuilder* builder = static_cast<arrow::BooleanBuilder*>(builder_);\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      if (value->IsNull()) {\n+        ARROW_RETURN_NOT_OK(builder->AppendNull());\n+      } else {\n+        ARROW_RETURN_NOT_OK(builder->Append(value->GetBool()));\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StructType& type) {\n+    arrow::StructBuilder* builder = static_cast<arrow::StructBuilder*>(builder_);\n+\n+    std::vector<std::string> child_path(root_path_);\n+    if (field_name_.size() > 0) {\n+      child_path.push_back(field_name_);\n+    }\n+    auto child_converter = JsonValueConverter(rows_, child_path, array_levels_);\n+\n+    for (int i = 0; i < type.num_fields(); ++i) {\n+      std::shared_ptr<arrow::Field> child_field = type.field(i);\n+      std::shared_ptr<arrow::ArrayBuilder> child_builder = builder->child_builder(i);\n+\n+      ARROW_RETURN_NOT_OK(\n+          child_converter.Convert(*child_field.get(), child_builder.get()));\n+    }\n+\n+    // Make null bitmap\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      ARROW_RETURN_NOT_OK(builder->Append(!value->IsNull()));\n+    }\n+\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::ListType& type) {\n+    arrow::ListBuilder* builder = static_cast<arrow::ListBuilder*>(builder_);\n+\n+    // Values and offsets needs to be interleaved in ListBuilder, so first collect the\n+    // values\n+    std::unique_ptr<arrow::ArrayBuilder> tmp_value_builder;\n+    ARROW_ASSIGN_OR_RAISE(tmp_value_builder,\n+                          arrow::MakeBuilder(builder->value_builder()->type()));\n+    std::vector<std::string> child_path(root_path_);\n+    child_path.push_back(field_name_);\n+    auto child_converter = JsonValueConverter(rows_, child_path, array_levels_ + 1);\n+    ARROW_RETURN_NOT_OK(\n+        child_converter.Convert(*type.value_field().get(), \"\", tmp_value_builder.get()));\n+\n+    std::shared_ptr<arrow::Array> values_array;\n+    ARROW_RETURN_NOT_OK(tmp_value_builder->Finish(&values_array));\n+    std::shared_ptr<arrow::ArrayData> values_data = values_array->data();\n+\n+    arrow::ArrayBuilder* value_builder = builder->value_builder();\n+    int64_t offset = 0;\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      ARROW_RETURN_NOT_OK(builder->Append(!value->IsNull()));\n+      if (!value->IsNull() && value->Size() > 0) {\n+        ARROW_RETURN_NOT_OK(\n+            value_builder->AppendArraySlice(*values_data.get(), offset, value->Size()));\n+        offset += value->Size();\n+      }\n+    }\n+\n+    return arrow::Status::OK();\n+  }\n+\n+ protected:\n+  std::string field_name_;\n+  arrow::ArrayBuilder* builder_;\n+  const std::vector<rapidjson::Document>& rows_;\n+  std::vector<std::string> root_path_;\n+  int64_t array_levels_;\n+\n+  /// Return a flattened iterator over values at nested location\n+  arrow::Iterator<const rapidjson::Value*> FieldValues() {\n+    std::vector<std::string> path(root_path_);\n+    if (field_name_.size() > 0) {\n+      path.push_back(field_name_);\n+    }\n+    auto iter = DocValuesIterator(rows_, std::move(path), array_levels_);\n+    auto fn = [iter]() mutable -> arrow::Result<const rapidjson::Value*> {\n+      return iter.Next();\n+    };\n+\n+    return arrow::MakeFunctionIterator(fn);\n+  }\n+};  // JsonValueConverter\n+\n+class DocumentToArrowConverter : public arrow::FromRowConverter<rapidjson::Document> {\n+ public:\n+  explicit DocumentToArrowConverter(arrow::MemoryPool* pool) : pool_(pool) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::RecordBatch>> ConvertToRecordBatch(\n+      const std::vector<rapidjson::Document>& rows,\n+      std::shared_ptr<arrow::Schema> schema) override {\n+    std::unique_ptr<arrow::RecordBatchBuilder> batch_builder;\n+    ARROW_ASSIGN_OR_RAISE(batch_builder,\n+                          arrow::RecordBatchBuilder::Make(schema, pool_, rows.size()));\n+\n+    JsonValueConverter converter(rows);\n+    for (int i = 0; i < batch_builder->num_fields(); ++i) {\n+      std::shared_ptr<arrow::Field> field = schema->field(i);\n+      arrow::ArrayBuilder* builder = batch_builder->GetField(i);\n+      ARROW_RETURN_NOT_OK(converter.Convert(*field.get(), builder));\n+    }\n+\n+    std::shared_ptr<arrow::RecordBatch> batch;\n+    ARROW_ASSIGN_OR_RAISE(batch, batch_builder->Flush());\n+\n+    DCHECK_OK(batch->ValidateFull());\n+    return batch;\n+  }\n+\n+ protected:\n+  arrow::MemoryPool* pool_;\n+};  // DocumentToArrowConverter\n+\n+int main(int argc, char** argv) {\n+  // Get sizes\n+  int32_t num_rows = argc > 1 ? std::atoi(argv[1]) : 100;\n+  int32_t batch_size = argc > 2 ? std::atoi(argv[2]) : 100;\n+\n+  //(Doc section: Convert to Arrow)\n+  // Write JSON records\n+  std::vector<std::string> json_records = {\n+      R\"({\"pk\": 1, \"date_created\": \"2020-10-01\", \"data\": {\"deleted\": true, \"metrics\": [{\"key\": \"x\", \"value\": 1}]}})\",\n+      R\"({\"pk\": 2, \"date_created\": \"2020-10-03\", \"data\": {\"deleted\": false, \"metrics\": []}})\",\n+      R\"({\"pk\": 3, \"date_created\": \"2020-10-05\", \"data\": {\"deleted\": false, \"metrics\": [{\"key\": \"x\", \"value\": 33}, {\"key\": \"x\", \"value\": 42}]}})\"};\n+\n+  std::vector<rapidjson::Document> records;\n+  records.reserve(num_rows);\n+  for (int32_t i = 0; i < num_rows; ++i) {\n+    rapidjson::Document document;\n+    document.Parse(json_records[i % json_records.size()].c_str());\n+    records.push_back(std::move(document));\n+  }\n+  // for (const std::string& json : json_records) {\n+  //   rapidjson::Document document;\n+  //   document.Parse(json.c_str());\n+  //   records.push_back(std::move(document));\n+  // }\n+  for (const rapidjson::Document& doc : records) {\n+    rapidjson::StringBuffer sb;\n+    rapidjson::Writer<rapidjson::StringBuffer> writer(sb);\n+    // At batch_size >= 495, we segfault here:\n+    doc.Accept(writer);\n+    std::cout << sb.GetString() << std::endl;\n+  }\n+  auto tags_schema = arrow::list(arrow::struct_({\n+      arrow::field(\"key\", arrow::utf8()),\n+      arrow::field(\"value\", arrow::int64()),\n+  }));\n+  auto schema = arrow::schema(\n+      {arrow::field(\"pk\", arrow::int64()), arrow::field(\"date_created\", arrow::utf8()),\n+       arrow::field(\"data\", arrow::struct_({arrow::field(\"deleted\", arrow::boolean()),\n+                                            arrow::field(\"metrics\", tags_schema)}))});\n+\n+  // Create converter\n+  DocumentToArrowConverter to_arrow_converter(arrow::default_memory_pool());\n+\n+  // Convert records into a table\n+  arrow::Result<std::shared_ptr<arrow::Table>> table_result =\n+      to_arrow_converter.ConvertToTable(records, schema);\n+  std::shared_ptr<arrow::Table> table = std::move(table_result).ValueOrDie();\n\nReview Comment:\n   or, we could factor out a `Status Main()` that gets called from `int main`\n\n\n\n##########\ncpp/src/arrow/row_conversion.h:\n##########\n@@ -0,0 +1,192 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/iterator.h\"\n+\n+namespace arrow {\n+\n+/// \\brief Base class for Arrow to row converter.\n+///\n+/// To use, specialize the conversion for a particular row type.\n+///\n+/// \\tparam RowType type that contains a single row\n+/// \\tparam ContainerType optional alternative vector implementation\n+///\n+/// The derived conversion functions take a batch_size parameter that determines\n+/// how many rows convert at once. This allows you to do the conversion in smaller\n+/// batches.\n+template <typename RowType, template <typename...> class ContainerType = std::vector>\n+class ToRowConverter {\n+ public:\n+  /// \\brief Convert a record batch into a vector of rows.\n+  ///\n+  /// Implement this method in specialized classes to derive all other methods.\n+  ///\n+  /// \\param batch Record batch to convert\n+  /// \\return A vector of rows containing all data in batch\n+  virtual Result<ContainerType<RowType>> ConvertToVector(\n+      std::shared_ptr<RecordBatch> batch) = 0;\n+\n+  /// \\brief Convert a record batch into a vector of rows.\n+  ///\n+  /// \\param batch Record batch to convert\n+  /// \\param batch_size Number of rows to convert at once\n+  /// \\return A vector of rows containing all data in batch\n+  Result<ContainerType<RowType>> ConvertToVector(std::shared_ptr<RecordBatch> batch,\n+                                                 size_t batch_size) {\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Table> table,\n+                          Table::FromRecordBatches({batch}));\n+    return ConvertToVector(table, batch_size);\n\nReview Comment:\n   IMO, it's pointless to wrap in a table only to unwrap it right away\n\n\n\n##########\ncpp/src/arrow/row_conversion.h:\n##########\n@@ -0,0 +1,192 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/iterator.h\"\n+\n+namespace arrow {\n+\n+/// \\brief Base class for Arrow to row converter.\n+///\n+/// To use, specialize the conversion for a particular row type.\n+///\n+/// \\tparam RowType type that contains a single row\n+/// \\tparam ContainerType optional alternative vector implementation\n+///\n+/// The derived conversion functions take a batch_size parameter that determines\n+/// how many rows convert at once. This allows you to do the conversion in smaller\n+/// batches.\n+template <typename RowType, template <typename...> class ContainerType = std::vector>\n+class ToRowConverter {\n+ public:\n+  /// \\brief Convert a record batch into a vector of rows.\n+  ///\n+  /// Implement this method in specialized classes to derive all other methods.\n+  ///\n+  /// \\param batch Record batch to convert\n+  /// \\return A vector of rows containing all data in batch\n+  virtual Result<ContainerType<RowType>> ConvertToVector(\n+      std::shared_ptr<RecordBatch> batch) = 0;\n\nReview Comment:\n   Why not take `const RecordBatch&` or `const std::shared_ptr<RecordBatch>&`?\n\n\n\n##########\ncpp/examples/arrow/rapidjson_row_converter.cc:\n##########\n@@ -0,0 +1,590 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/result.h>\n+#include <arrow/table_builder.h>\n+#include <arrow/type_traits.h>\n+#include <arrow/util/iterator.h>\n+#include <arrow/util/logging.h>\n+#include <arrow/visit_array_inline.h>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <cassert>\n+#include <iostream>\n+#include <vector>\n+\n+// Transforming dynamic row data into Arrow data\n+// When building connectors to other data systems, it's common to receive data in\n+// row-based structures. While the row_wise_conversion_example.cc shows how to\n+// handle this conversion for fixed schemas, this example demonstrates how to\n+// writer converters for arbitrary schemas.\n+//\n+// As an example, this conversion is between Arrow and rapidjson::Documents.\n+//\n+// We use the following helpers and patterns here:\n+//  * arrow::ToRowConverter and arrow::FromRowConverter, which provide additional\n+//    conversion methods given a basic converter\n+//  * arrow::VisitArrayInline and arrow::VisitTypeInline for implementing a visitor\n+//    pattern with Arrow to handle different array types\n+//  * arrow::enable_if_primitive_ctype to create a template method that handles\n+//  * conversion for Arrow types that have corresponding C types (bool, integer,\n+//    float).\n+\n+rapidjson::Value kNullJsonSingleton = rapidjson::Value();\n+\n+/// \\brief Builder that holds state for a single conversion.\n+///\n+/// Implements Visit() methods for each type of Arrow Array that set the values\n+/// of the corresponding fields in each row.\n+class RowBatchBuilder {\n+ public:\n+  explicit RowBatchBuilder(int64_t num_rows) : field_(nullptr) {\n+    // Reserve all of the space required up-front to avoid unnecessary resizing\n+    rows_.reserve(num_rows);\n+\n+    for (int64_t i = 0; i < num_rows; ++i) {\n+      rows_.push_back(rapidjson::Document());\n+      rows_[i].SetObject();\n+    }\n+  }\n+\n+  /// \\brief Set which field to convert.\n+  void SetField(std::shared_ptr<arrow::Field> field) { field_ = std::move(field); }\n+\n+  /// \\brief Retrieve converted rows from builder.\n+  std::vector<rapidjson::Document> Rows() && { return std::move(rows_); }\n+\n+  // Default implementation\n+  arrow::Status Visit(const arrow::Array& array) {\n+    return arrow::Status::NotImplemented(\n+        \"Can not convert to json document for array of type \", array.type()->ToString());\n+  }\n+\n+  // Handles booleans, integers, floats\n+  template <typename ArrayType, typename DataClass = typename ArrayType::TypeClass>\n+  arrow::enable_if_primitive_ctype<DataClass, arrow::Status> Visit(\n+      const ArrayType& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, array.Value(i), rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StringArray& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        // StringArray.Value returns a string view\n+        auto value_view = array.Value(i);\n+        rapidjson::Value value;\n+        value.SetString(value_view.data(),\n+                        static_cast<rapidjson::SizeType>(value_view.size()),\n+                        rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, value, rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StructArray& array) {\n+    const arrow::StructType* type = array.struct_type();\n+\n+    RowBatchBuilder child_builder(rows_.size());\n+    for (int i = 0; i < type->num_fields(); ++i) {\n+      std::shared_ptr<arrow::Field> child_field = type->field(i);\n+      child_builder.SetField(std::move(child_field));\n+      ARROW_RETURN_NOT_OK(arrow::VisitArrayInline(*array.field(i).get(), &child_builder));\n+    }\n+    std::vector<rapidjson::Document> rows = std::move(child_builder).Rows();\n+\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        // Must copy value to new allocator\n+        rapidjson::Value row_val;\n+        row_val.CopyFrom(rows[i], rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, row_val, rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::ListArray& array) {\n+    // First create rows from values\n+    std::shared_ptr<arrow::Array> values = array.values();\n+    RowBatchBuilder child_builder(values->length());\n+    std::shared_ptr<arrow::Field> value_field = array.list_type()->value_field();\n+    std::string value_field_name = value_field->name();\n+    child_builder.SetField(value_field);\n+    ARROW_RETURN_NOT_OK(arrow::VisitArrayInline(*values.get(), &child_builder));\n+\n+    std::vector<rapidjson::Document> rows = std::move(child_builder).Rows();\n+\n+    int64_t values_i = 0;\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      rapidjson::Document::AllocatorType& allocator = rows_[i].GetAllocator();\n+      auto array_len = array.value_length(i);\n+\n+      rapidjson::Value value;\n+      value.SetArray();\n+      value.Reserve(array_len, allocator);\n+\n+      for (int64_t j = 0; j < array_len; ++j) {\n+        rapidjson::Value row_val;\n+        // Must copy value to new allocator\n+        row_val.CopyFrom(rows[values_i][value_field_name.c_str()], allocator);\n+        value.PushBack(row_val, allocator);\n+        ++values_i;\n+      }\n+\n+      rapidjson::Value str_key(field_->name().c_str(), allocator);\n+      rows_[i].AddMember(str_key, value, allocator);\n+    }\n+\n+    return arrow::Status::OK();\n+  }\n+\n+ private:\n+  std::shared_ptr<arrow::Field> field_;\n+  std::vector<rapidjson::Document> rows_;\n+};  // RowBatchBuilder\n+\n+class ArrowToDocumentConverter : public arrow::ToRowConverter<rapidjson::Document> {\n+ public:\n+  arrow::Result<std::vector<rapidjson::Document>> ConvertToVector(\n+      std::shared_ptr<arrow::RecordBatch> batch) override {\n+    RowBatchBuilder builder{batch->num_rows()};\n+\n+    for (int i = 0; i < batch->num_columns(); ++i) {\n+      builder.SetField(std::move(batch->schema()->field(i)));\n\nReview Comment:\n   nit: I don't think this `std::move` does anything here\n\n\n\n##########\ncpp/examples/arrow/rapidjson_row_converter.cc:\n##########\n@@ -0,0 +1,590 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/result.h>\n+#include <arrow/table_builder.h>\n+#include <arrow/type_traits.h>\n+#include <arrow/util/iterator.h>\n+#include <arrow/util/logging.h>\n+#include <arrow/visit_array_inline.h>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <cassert>\n+#include <iostream>\n+#include <vector>\n+\n+// Transforming dynamic row data into Arrow data\n+// When building connectors to other data systems, it's common to receive data in\n+// row-based structures. While the row_wise_conversion_example.cc shows how to\n+// handle this conversion for fixed schemas, this example demonstrates how to\n+// writer converters for arbitrary schemas.\n+//\n+// As an example, this conversion is between Arrow and rapidjson::Documents.\n+//\n+// We use the following helpers and patterns here:\n+//  * arrow::ToRowConverter and arrow::FromRowConverter, which provide additional\n+//    conversion methods given a basic converter\n+//  * arrow::VisitArrayInline and arrow::VisitTypeInline for implementing a visitor\n+//    pattern with Arrow to handle different array types\n+//  * arrow::enable_if_primitive_ctype to create a template method that handles\n+//  * conversion for Arrow types that have corresponding C types (bool, integer,\n+//    float).\n+\n+rapidjson::Value kNullJsonSingleton = rapidjson::Value();\n+\n+/// \\brief Builder that holds state for a single conversion.\n+///\n+/// Implements Visit() methods for each type of Arrow Array that set the values\n+/// of the corresponding fields in each row.\n+class RowBatchBuilder {\n+ public:\n+  explicit RowBatchBuilder(int64_t num_rows) : field_(nullptr) {\n+    // Reserve all of the space required up-front to avoid unnecessary resizing\n+    rows_.reserve(num_rows);\n+\n+    for (int64_t i = 0; i < num_rows; ++i) {\n+      rows_.push_back(rapidjson::Document());\n+      rows_[i].SetObject();\n+    }\n+  }\n+\n+  /// \\brief Set which field to convert.\n+  void SetField(std::shared_ptr<arrow::Field> field) { field_ = std::move(field); }\n+\n+  /// \\brief Retrieve converted rows from builder.\n+  std::vector<rapidjson::Document> Rows() && { return std::move(rows_); }\n+\n+  // Default implementation\n+  arrow::Status Visit(const arrow::Array& array) {\n+    return arrow::Status::NotImplemented(\n+        \"Can not convert to json document for array of type \", array.type()->ToString());\n+  }\n+\n+  // Handles booleans, integers, floats\n+  template <typename ArrayType, typename DataClass = typename ArrayType::TypeClass>\n+  arrow::enable_if_primitive_ctype<DataClass, arrow::Status> Visit(\n+      const ArrayType& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, array.Value(i), rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StringArray& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        // StringArray.Value returns a string view\n+        auto value_view = array.Value(i);\n+        rapidjson::Value value;\n+        value.SetString(value_view.data(),\n+                        static_cast<rapidjson::SizeType>(value_view.size()),\n+                        rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, value, rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StructArray& array) {\n+    const arrow::StructType* type = array.struct_type();\n+\n+    RowBatchBuilder child_builder(rows_.size());\n+    for (int i = 0; i < type->num_fields(); ++i) {\n+      std::shared_ptr<arrow::Field> child_field = type->field(i);\n+      child_builder.SetField(std::move(child_field));\n+      ARROW_RETURN_NOT_OK(arrow::VisitArrayInline(*array.field(i).get(), &child_builder));\n+    }\n+    std::vector<rapidjson::Document> rows = std::move(child_builder).Rows();\n+\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        // Must copy value to new allocator\n+        rapidjson::Value row_val;\n+        row_val.CopyFrom(rows[i], rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, row_val, rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::ListArray& array) {\n+    // First create rows from values\n+    std::shared_ptr<arrow::Array> values = array.values();\n+    RowBatchBuilder child_builder(values->length());\n+    std::shared_ptr<arrow::Field> value_field = array.list_type()->value_field();\n+    std::string value_field_name = value_field->name();\n+    child_builder.SetField(value_field);\n+    ARROW_RETURN_NOT_OK(arrow::VisitArrayInline(*values.get(), &child_builder));\n+\n+    std::vector<rapidjson::Document> rows = std::move(child_builder).Rows();\n+\n+    int64_t values_i = 0;\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      rapidjson::Document::AllocatorType& allocator = rows_[i].GetAllocator();\n\nReview Comment:\n   nit: can this be `const&`?\n\n\n\n##########\ncpp/examples/arrow/rapidjson_row_converter.cc:\n##########\n@@ -0,0 +1,590 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/result.h>\n+#include <arrow/table_builder.h>\n+#include <arrow/type_traits.h>\n+#include <arrow/util/iterator.h>\n+#include <arrow/util/logging.h>\n+#include <arrow/visit_array_inline.h>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <cassert>\n+#include <iostream>\n+#include <vector>\n+\n+// Transforming dynamic row data into Arrow data\n+// When building connectors to other data systems, it's common to receive data in\n+// row-based structures. While the row_wise_conversion_example.cc shows how to\n+// handle this conversion for fixed schemas, this example demonstrates how to\n+// writer converters for arbitrary schemas.\n+//\n+// As an example, this conversion is between Arrow and rapidjson::Documents.\n+//\n+// We use the following helpers and patterns here:\n+//  * arrow::ToRowConverter and arrow::FromRowConverter, which provide additional\n+//    conversion methods given a basic converter\n+//  * arrow::VisitArrayInline and arrow::VisitTypeInline for implementing a visitor\n+//    pattern with Arrow to handle different array types\n+//  * arrow::enable_if_primitive_ctype to create a template method that handles\n+//  * conversion for Arrow types that have corresponding C types (bool, integer,\n+//    float).\n+\n+rapidjson::Value kNullJsonSingleton = rapidjson::Value();\n+\n+/// \\brief Builder that holds state for a single conversion.\n+///\n+/// Implements Visit() methods for each type of Arrow Array that set the values\n+/// of the corresponding fields in each row.\n+class RowBatchBuilder {\n+ public:\n+  explicit RowBatchBuilder(int64_t num_rows) : field_(nullptr) {\n+    // Reserve all of the space required up-front to avoid unnecessary resizing\n+    rows_.reserve(num_rows);\n+\n+    for (int64_t i = 0; i < num_rows; ++i) {\n+      rows_.push_back(rapidjson::Document());\n+      rows_[i].SetObject();\n+    }\n+  }\n+\n+  /// \\brief Set which field to convert.\n+  void SetField(std::shared_ptr<arrow::Field> field) { field_ = std::move(field); }\n+\n+  /// \\brief Retrieve converted rows from builder.\n+  std::vector<rapidjson::Document> Rows() && { return std::move(rows_); }\n+\n+  // Default implementation\n+  arrow::Status Visit(const arrow::Array& array) {\n+    return arrow::Status::NotImplemented(\n+        \"Can not convert to json document for array of type \", array.type()->ToString());\n+  }\n+\n+  // Handles booleans, integers, floats\n+  template <typename ArrayType, typename DataClass = typename ArrayType::TypeClass>\n+  arrow::enable_if_primitive_ctype<DataClass, arrow::Status> Visit(\n+      const ArrayType& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, array.Value(i), rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StringArray& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        // StringArray.Value returns a string view\n+        auto value_view = array.Value(i);\n+        rapidjson::Value value;\n+        value.SetString(value_view.data(),\n+                        static_cast<rapidjson::SizeType>(value_view.size()),\n+                        rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, value, rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StructArray& array) {\n+    const arrow::StructType* type = array.struct_type();\n+\n+    RowBatchBuilder child_builder(rows_.size());\n+    for (int i = 0; i < type->num_fields(); ++i) {\n+      std::shared_ptr<arrow::Field> child_field = type->field(i);\n+      child_builder.SetField(std::move(child_field));\n+      ARROW_RETURN_NOT_OK(arrow::VisitArrayInline(*array.field(i).get(), &child_builder));\n+    }\n+    std::vector<rapidjson::Document> rows = std::move(child_builder).Rows();\n+\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        // Must copy value to new allocator\n+        rapidjson::Value row_val;\n+        row_val.CopyFrom(rows[i], rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, row_val, rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::ListArray& array) {\n+    // First create rows from values\n+    std::shared_ptr<arrow::Array> values = array.values();\n+    RowBatchBuilder child_builder(values->length());\n+    std::shared_ptr<arrow::Field> value_field = array.list_type()->value_field();\n+    std::string value_field_name = value_field->name();\n+    child_builder.SetField(value_field);\n+    ARROW_RETURN_NOT_OK(arrow::VisitArrayInline(*values.get(), &child_builder));\n+\n+    std::vector<rapidjson::Document> rows = std::move(child_builder).Rows();\n+\n+    int64_t values_i = 0;\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      rapidjson::Document::AllocatorType& allocator = rows_[i].GetAllocator();\n+      auto array_len = array.value_length(i);\n+\n+      rapidjson::Value value;\n+      value.SetArray();\n+      value.Reserve(array_len, allocator);\n+\n+      for (int64_t j = 0; j < array_len; ++j) {\n+        rapidjson::Value row_val;\n+        // Must copy value to new allocator\n+        row_val.CopyFrom(rows[values_i][value_field_name.c_str()], allocator);\n+        value.PushBack(row_val, allocator);\n+        ++values_i;\n+      }\n+\n+      rapidjson::Value str_key(field_->name().c_str(), allocator);\n+      rows_[i].AddMember(str_key, value, allocator);\n+    }\n+\n+    return arrow::Status::OK();\n+  }\n+\n+ private:\n+  std::shared_ptr<arrow::Field> field_;\n+  std::vector<rapidjson::Document> rows_;\n+};  // RowBatchBuilder\n+\n+class ArrowToDocumentConverter : public arrow::ToRowConverter<rapidjson::Document> {\n+ public:\n+  arrow::Result<std::vector<rapidjson::Document>> ConvertToVector(\n+      std::shared_ptr<arrow::RecordBatch> batch) override {\n+    RowBatchBuilder builder{batch->num_rows()};\n+\n+    for (int i = 0; i < batch->num_columns(); ++i) {\n+      builder.SetField(std::move(batch->schema()->field(i)));\n+      ARROW_RETURN_NOT_OK(arrow::VisitArrayInline(*batch->column(i).get(), &builder));\n+    }\n+\n+    return std::move(builder).Rows();\n+  }\n+};  // ArrowToDocumentConverter\n+\n+/// \\brief Iterator over rows values of a document for a given field\n+///\n+/// path and array_levels are used to address each field in a JSON document. As\n+/// an example, consider this JSON document:\n+/// {\n+///     \"x\": 3,                   // path: [\"x\"],             array_levels: 0\n+///     \"files\": [                // path: [\"files\"],         array_levels: 0\n+///         {                     // path: [\"files\"],         array_levels: 1\n+///             \"path\": \"my_str\", // path: [\"files\", \"path\"], array_levels: 1\n+///             \"sizes\": [        // path: [\"files\", \"size\"], array_levels: 1\n+///                 20,           // path: [\"files\", \"size\"], array_levels: 2\n+///                 22\n+///             ]\n+///         }\n+///     ]\n+/// },\n+class DocValuesIterator {\n+ public:\n+  /// \\param rows vector of rows\n+  /// \\param path field names to enter\n+  /// \\param array_levels number of arrays to enter\n+  DocValuesIterator(const std::vector<rapidjson::Document>& rows,\n+                    std::vector<std::string> path, int64_t array_levels)\n+      : rows(rows), path(std::move(path)), array_levels(array_levels) {}\n+\n+  const rapidjson::Value* NextArrayOrRow(const rapidjson::Value* value, size_t* path_i,\n+                                         int64_t* arr_i) {\n+    while (array_stack.size() > 0) {\n+      ArrayPosition& pos = array_stack.back();\n+      // Try to get next position in Array\n+      if (pos.index + 1 < pos.array_node->Size()) {\n+        ++pos.index;\n+        value = &(*pos.array_node)[pos.index];\n+        *path_i = pos.path_index;\n+        *arr_i = array_stack.size();\n+        return value;\n+      } else {\n+        array_stack.pop_back();\n+      }\n+    }\n+    ++row_i;\n+    if (row_i < rows.size()) {\n+      value = static_cast<const rapidjson::Value*>(&rows[row_i]);\n+    } else {\n+      value = nullptr;\n+    }\n+    *path_i = 0;\n+    *arr_i = 0;\n+    return value;\n+  }\n+\n+  arrow::Result<const rapidjson::Value*> Next() {\n+    const rapidjson::Value* value = nullptr;\n+    size_t path_i;\n+    int64_t arr_i;\n+    // Can either start at document or at last array level\n+    if (array_stack.size() > 0) {\n+      auto pos = array_stack.back();\n+      value = pos.array_node;\n+      path_i = pos.path_index;\n+      arr_i = array_stack.size() - 1;\n+    }\n+\n+    value = NextArrayOrRow(value, &path_i, &arr_i);\n+\n+    // Traverse to desired level (with possible backtracking as needed)\n+    while (path_i < path.size() || arr_i < array_levels) {\n+      if (value == nullptr) {\n+        return value;\n+      } else if (value->IsArray() && value->Size() > 0) {\n+        ArrayPosition pos;\n+        pos.array_node = value;\n+        pos.path_index = path_i;\n+        pos.index = 0;\n+        array_stack.push_back(pos);\n+\n+        value = &(*value)[0];\n+        ++arr_i;\n+      } else if (value->IsArray()) {\n+        // Empty array means we need to backtrack and go to next array or row\n+        value = NextArrayOrRow(value, &path_i, &arr_i);\n+      } else if (value->HasMember(path[path_i].c_str())) {\n+        value = &(*value)[path[path_i].c_str()];\n+        ++path_i;\n+      } else {\n+        return &kNullJsonSingleton;\n+      }\n+    }\n+\n+    // Return value\n+    return value;\n+  }\n+\n+ protected:\n+  const std::vector<rapidjson::Document>& rows;\n+  std::vector<std::string> path;\n+  int64_t array_levels;\n+  size_t row_i = -1;  // index of current row\n+\n+  // Info about array position for one array level in array stack\n+  struct ArrayPosition {\n+    const rapidjson::Value* array_node;\n+    int64_t path_index;\n+    rapidjson::SizeType index;\n+  };\n+  std::vector<ArrayPosition> array_stack;\n+};\n+\n+class JsonValueConverter {\n+ public:\n+  explicit JsonValueConverter(const std::vector<rapidjson::Document>& rows)\n+      : rows_(rows), array_levels_(0) {}\n+\n+  JsonValueConverter(const std::vector<rapidjson::Document>& rows,\n+                     const std::vector<std::string>& root_path, int64_t array_levels)\n+      : rows_(rows), root_path_(root_path), array_levels_(array_levels) {}\n+\n+  /// \\brief For field passed in, append corresponding values to builder\n+  arrow::Status Convert(const arrow::Field& field, arrow::ArrayBuilder* builder) {\n+    return Convert(field, field.name(), builder);\n+  }\n+\n+  /// \\brief For field passed in, append corresponding values to builder\n+  arrow::Status Convert(const arrow::Field& field, const std::string& field_name,\n+                        arrow::ArrayBuilder* builder) {\n+    field_name_ = field_name;\n+    builder_ = builder;\n+    ARROW_RETURN_NOT_OK(arrow::VisitTypeInline(*field.type().get(), this));\n+    return arrow::Status::OK();\n+  }\n+\n+  // Default implementation\n+  arrow::Status Visit(const arrow::DataType& type) {\n+    return arrow::Status::NotImplemented(\n+        \"Can not convert to json document for array of type \", type.ToString());\n+  }\n+\n+  arrow::Status Visit(const arrow::Int64Type& type) {\n+    arrow::Int64Builder* builder = static_cast<arrow::Int64Builder*>(builder_);\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      if (value->IsNull()) {\n+        ARROW_RETURN_NOT_OK(builder->AppendNull());\n+      } else {\n+        if (value->IsUint()) {\n+          ARROW_RETURN_NOT_OK(builder->Append(value->GetUint()));\n+        } else if (value->IsInt()) {\n+          ARROW_RETURN_NOT_OK(builder->Append(value->GetInt()));\n+        } else if (value->IsUint64()) {\n+          ARROW_RETURN_NOT_OK(builder->Append(value->GetUint64()));\n+        } else if (value->IsInt64()) {\n+          ARROW_RETURN_NOT_OK(builder->Append(value->GetInt64()));\n+        } else {\n+          return arrow::Status::Invalid(\"Value is not an integer\");\n+        }\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::DoubleType& type) {\n+    arrow::DoubleBuilder* builder = static_cast<arrow::DoubleBuilder*>(builder_);\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      if (value->IsNull()) {\n+        ARROW_RETURN_NOT_OK(builder->AppendNull());\n+      } else {\n+        ARROW_RETURN_NOT_OK(builder->Append(value->GetDouble()));\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StringType& type) {\n+    arrow::StringBuilder* builder = static_cast<arrow::StringBuilder*>(builder_);\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      if (value->IsNull()) {\n+        ARROW_RETURN_NOT_OK(builder->AppendNull());\n+      } else {\n+        ARROW_RETURN_NOT_OK(builder->Append(value->GetString()));\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::BooleanType& type) {\n+    arrow::BooleanBuilder* builder = static_cast<arrow::BooleanBuilder*>(builder_);\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      if (value->IsNull()) {\n+        ARROW_RETURN_NOT_OK(builder->AppendNull());\n+      } else {\n+        ARROW_RETURN_NOT_OK(builder->Append(value->GetBool()));\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StructType& type) {\n+    arrow::StructBuilder* builder = static_cast<arrow::StructBuilder*>(builder_);\n+\n+    std::vector<std::string> child_path(root_path_);\n+    if (field_name_.size() > 0) {\n+      child_path.push_back(field_name_);\n+    }\n+    auto child_converter = JsonValueConverter(rows_, child_path, array_levels_);\n+\n+    for (int i = 0; i < type.num_fields(); ++i) {\n+      std::shared_ptr<arrow::Field> child_field = type.field(i);\n+      std::shared_ptr<arrow::ArrayBuilder> child_builder = builder->child_builder(i);\n+\n+      ARROW_RETURN_NOT_OK(\n+          child_converter.Convert(*child_field.get(), child_builder.get()));\n+    }\n+\n+    // Make null bitmap\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      ARROW_RETURN_NOT_OK(builder->Append(!value->IsNull()));\n+    }\n+\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::ListType& type) {\n+    arrow::ListBuilder* builder = static_cast<arrow::ListBuilder*>(builder_);\n+\n+    // Values and offsets needs to be interleaved in ListBuilder, so first collect the\n+    // values\n+    std::unique_ptr<arrow::ArrayBuilder> tmp_value_builder;\n+    ARROW_ASSIGN_OR_RAISE(tmp_value_builder,\n+                          arrow::MakeBuilder(builder->value_builder()->type()));\n+    std::vector<std::string> child_path(root_path_);\n+    child_path.push_back(field_name_);\n+    auto child_converter = JsonValueConverter(rows_, child_path, array_levels_ + 1);\n+    ARROW_RETURN_NOT_OK(\n+        child_converter.Convert(*type.value_field().get(), \"\", tmp_value_builder.get()));\n+\n+    std::shared_ptr<arrow::Array> values_array;\n+    ARROW_RETURN_NOT_OK(tmp_value_builder->Finish(&values_array));\n+    std::shared_ptr<arrow::ArrayData> values_data = values_array->data();\n+\n+    arrow::ArrayBuilder* value_builder = builder->value_builder();\n+    int64_t offset = 0;\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      ARROW_RETURN_NOT_OK(builder->Append(!value->IsNull()));\n+      if (!value->IsNull() && value->Size() > 0) {\n+        ARROW_RETURN_NOT_OK(\n+            value_builder->AppendArraySlice(*values_data.get(), offset, value->Size()));\n+        offset += value->Size();\n+      }\n+    }\n+\n+    return arrow::Status::OK();\n+  }\n+\n+ protected:\n+  std::string field_name_;\n+  arrow::ArrayBuilder* builder_;\n+  const std::vector<rapidjson::Document>& rows_;\n+  std::vector<std::string> root_path_;\n+  int64_t array_levels_;\n+\n+  /// Return a flattened iterator over values at nested location\n+  arrow::Iterator<const rapidjson::Value*> FieldValues() {\n+    std::vector<std::string> path(root_path_);\n+    if (field_name_.size() > 0) {\n+      path.push_back(field_name_);\n+    }\n+    auto iter = DocValuesIterator(rows_, std::move(path), array_levels_);\n+    auto fn = [iter]() mutable -> arrow::Result<const rapidjson::Value*> {\n+      return iter.Next();\n+    };\n+\n+    return arrow::MakeFunctionIterator(fn);\n+  }\n+};  // JsonValueConverter\n+\n+class DocumentToArrowConverter : public arrow::FromRowConverter<rapidjson::Document> {\n+ public:\n+  explicit DocumentToArrowConverter(arrow::MemoryPool* pool) : pool_(pool) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::RecordBatch>> ConvertToRecordBatch(\n+      const std::vector<rapidjson::Document>& rows,\n+      std::shared_ptr<arrow::Schema> schema) override {\n+    std::unique_ptr<arrow::RecordBatchBuilder> batch_builder;\n+    ARROW_ASSIGN_OR_RAISE(batch_builder,\n+                          arrow::RecordBatchBuilder::Make(schema, pool_, rows.size()));\n+\n+    JsonValueConverter converter(rows);\n+    for (int i = 0; i < batch_builder->num_fields(); ++i) {\n+      std::shared_ptr<arrow::Field> field = schema->field(i);\n+      arrow::ArrayBuilder* builder = batch_builder->GetField(i);\n+      ARROW_RETURN_NOT_OK(converter.Convert(*field.get(), builder));\n+    }\n+\n+    std::shared_ptr<arrow::RecordBatch> batch;\n+    ARROW_ASSIGN_OR_RAISE(batch, batch_builder->Flush());\n+\n+    DCHECK_OK(batch->ValidateFull());\n+    return batch;\n+  }\n+\n+ protected:\n+  arrow::MemoryPool* pool_;\n+};  // DocumentToArrowConverter\n+\n+int main(int argc, char** argv) {\n+  // Get sizes\n+  int32_t num_rows = argc > 1 ? std::atoi(argv[1]) : 100;\n+  int32_t batch_size = argc > 2 ? std::atoi(argv[2]) : 100;\n+\n+  //(Doc section: Convert to Arrow)\n+  // Write JSON records\n+  std::vector<std::string> json_records = {\n+      R\"({\"pk\": 1, \"date_created\": \"2020-10-01\", \"data\": {\"deleted\": true, \"metrics\": [{\"key\": \"x\", \"value\": 1}]}})\",\n+      R\"({\"pk\": 2, \"date_created\": \"2020-10-03\", \"data\": {\"deleted\": false, \"metrics\": []}})\",\n+      R\"({\"pk\": 3, \"date_created\": \"2020-10-05\", \"data\": {\"deleted\": false, \"metrics\": [{\"key\": \"x\", \"value\": 33}, {\"key\": \"x\", \"value\": 42}]}})\"};\n+\n+  std::vector<rapidjson::Document> records;\n+  records.reserve(num_rows);\n+  for (int32_t i = 0; i < num_rows; ++i) {\n+    rapidjson::Document document;\n+    document.Parse(json_records[i % json_records.size()].c_str());\n+    records.push_back(std::move(document));\n+  }\n+  // for (const std::string& json : json_records) {\n+  //   rapidjson::Document document;\n+  //   document.Parse(json.c_str());\n+  //   records.push_back(std::move(document));\n+  // }\n\nReview Comment:\n   nit: commented code?\n\n\n\n##########\ncpp/examples/arrow/rapidjson_row_converter.cc:\n##########\n@@ -0,0 +1,590 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/result.h>\n+#include <arrow/table_builder.h>\n+#include <arrow/type_traits.h>\n+#include <arrow/util/iterator.h>\n+#include <arrow/util/logging.h>\n+#include <arrow/visit_array_inline.h>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <cassert>\n+#include <iostream>\n+#include <vector>\n+\n+// Transforming dynamic row data into Arrow data\n+// When building connectors to other data systems, it's common to receive data in\n+// row-based structures. While the row_wise_conversion_example.cc shows how to\n+// handle this conversion for fixed schemas, this example demonstrates how to\n+// writer converters for arbitrary schemas.\n+//\n+// As an example, this conversion is between Arrow and rapidjson::Documents.\n+//\n+// We use the following helpers and patterns here:\n+//  * arrow::ToRowConverter and arrow::FromRowConverter, which provide additional\n+//    conversion methods given a basic converter\n+//  * arrow::VisitArrayInline and arrow::VisitTypeInline for implementing a visitor\n+//    pattern with Arrow to handle different array types\n+//  * arrow::enable_if_primitive_ctype to create a template method that handles\n+//  * conversion for Arrow types that have corresponding C types (bool, integer,\n+//    float).\n+\n+rapidjson::Value kNullJsonSingleton = rapidjson::Value();\n+\n+/// \\brief Builder that holds state for a single conversion.\n+///\n+/// Implements Visit() methods for each type of Arrow Array that set the values\n+/// of the corresponding fields in each row.\n+class RowBatchBuilder {\n+ public:\n+  explicit RowBatchBuilder(int64_t num_rows) : field_(nullptr) {\n+    // Reserve all of the space required up-front to avoid unnecessary resizing\n+    rows_.reserve(num_rows);\n+\n+    for (int64_t i = 0; i < num_rows; ++i) {\n+      rows_.push_back(rapidjson::Document());\n+      rows_[i].SetObject();\n+    }\n+  }\n+\n+  /// \\brief Set which field to convert.\n+  void SetField(std::shared_ptr<arrow::Field> field) { field_ = std::move(field); }\n+\n+  /// \\brief Retrieve converted rows from builder.\n+  std::vector<rapidjson::Document> Rows() && { return std::move(rows_); }\n+\n+  // Default implementation\n+  arrow::Status Visit(const arrow::Array& array) {\n+    return arrow::Status::NotImplemented(\n+        \"Can not convert to json document for array of type \", array.type()->ToString());\n+  }\n+\n+  // Handles booleans, integers, floats\n+  template <typename ArrayType, typename DataClass = typename ArrayType::TypeClass>\n+  arrow::enable_if_primitive_ctype<DataClass, arrow::Status> Visit(\n+      const ArrayType& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, array.Value(i), rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StringArray& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        // StringArray.Value returns a string view\n+        auto value_view = array.Value(i);\n+        rapidjson::Value value;\n+        value.SetString(value_view.data(),\n+                        static_cast<rapidjson::SizeType>(value_view.size()),\n+                        rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, value, rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StructArray& array) {\n+    const arrow::StructType* type = array.struct_type();\n+\n+    RowBatchBuilder child_builder(rows_.size());\n+    for (int i = 0; i < type->num_fields(); ++i) {\n+      std::shared_ptr<arrow::Field> child_field = type->field(i);\n+      child_builder.SetField(std::move(child_field));\n+      ARROW_RETURN_NOT_OK(arrow::VisitArrayInline(*array.field(i).get(), &child_builder));\n+    }\n+    std::vector<rapidjson::Document> rows = std::move(child_builder).Rows();\n+\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        // Must copy value to new allocator\n+        rapidjson::Value row_val;\n+        row_val.CopyFrom(rows[i], rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, row_val, rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::ListArray& array) {\n+    // First create rows from values\n+    std::shared_ptr<arrow::Array> values = array.values();\n+    RowBatchBuilder child_builder(values->length());\n+    std::shared_ptr<arrow::Field> value_field = array.list_type()->value_field();\n+    std::string value_field_name = value_field->name();\n+    child_builder.SetField(value_field);\n+    ARROW_RETURN_NOT_OK(arrow::VisitArrayInline(*values.get(), &child_builder));\n+\n+    std::vector<rapidjson::Document> rows = std::move(child_builder).Rows();\n+\n+    int64_t values_i = 0;\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      rapidjson::Document::AllocatorType& allocator = rows_[i].GetAllocator();\n+      auto array_len = array.value_length(i);\n+\n+      rapidjson::Value value;\n+      value.SetArray();\n+      value.Reserve(array_len, allocator);\n+\n+      for (int64_t j = 0; j < array_len; ++j) {\n+        rapidjson::Value row_val;\n+        // Must copy value to new allocator\n+        row_val.CopyFrom(rows[values_i][value_field_name.c_str()], allocator);\n+        value.PushBack(row_val, allocator);\n+        ++values_i;\n+      }\n+\n+      rapidjson::Value str_key(field_->name().c_str(), allocator);\n+      rows_[i].AddMember(str_key, value, allocator);\n+    }\n+\n+    return arrow::Status::OK();\n+  }\n+\n+ private:\n+  std::shared_ptr<arrow::Field> field_;\n+  std::vector<rapidjson::Document> rows_;\n+};  // RowBatchBuilder\n+\n+class ArrowToDocumentConverter : public arrow::ToRowConverter<rapidjson::Document> {\n+ public:\n+  arrow::Result<std::vector<rapidjson::Document>> ConvertToVector(\n+      std::shared_ptr<arrow::RecordBatch> batch) override {\n+    RowBatchBuilder builder{batch->num_rows()};\n+\n+    for (int i = 0; i < batch->num_columns(); ++i) {\n+      builder.SetField(std::move(batch->schema()->field(i)));\n+      ARROW_RETURN_NOT_OK(arrow::VisitArrayInline(*batch->column(i).get(), &builder));\n+    }\n+\n+    return std::move(builder).Rows();\n+  }\n+};  // ArrowToDocumentConverter\n+\n+/// \\brief Iterator over rows values of a document for a given field\n+///\n+/// path and array_levels are used to address each field in a JSON document. As\n+/// an example, consider this JSON document:\n+/// {\n+///     \"x\": 3,                   // path: [\"x\"],             array_levels: 0\n+///     \"files\": [                // path: [\"files\"],         array_levels: 0\n+///         {                     // path: [\"files\"],         array_levels: 1\n+///             \"path\": \"my_str\", // path: [\"files\", \"path\"], array_levels: 1\n+///             \"sizes\": [        // path: [\"files\", \"size\"], array_levels: 1\n+///                 20,           // path: [\"files\", \"size\"], array_levels: 2\n+///                 22\n+///             ]\n+///         }\n+///     ]\n+/// },\n+class DocValuesIterator {\n+ public:\n+  /// \\param rows vector of rows\n+  /// \\param path field names to enter\n+  /// \\param array_levels number of arrays to enter\n+  DocValuesIterator(const std::vector<rapidjson::Document>& rows,\n+                    std::vector<std::string> path, int64_t array_levels)\n+      : rows(rows), path(std::move(path)), array_levels(array_levels) {}\n+\n+  const rapidjson::Value* NextArrayOrRow(const rapidjson::Value* value, size_t* path_i,\n+                                         int64_t* arr_i) {\n+    while (array_stack.size() > 0) {\n+      ArrayPosition& pos = array_stack.back();\n+      // Try to get next position in Array\n+      if (pos.index + 1 < pos.array_node->Size()) {\n+        ++pos.index;\n+        value = &(*pos.array_node)[pos.index];\n+        *path_i = pos.path_index;\n+        *arr_i = array_stack.size();\n+        return value;\n+      } else {\n+        array_stack.pop_back();\n+      }\n+    }\n+    ++row_i;\n+    if (row_i < rows.size()) {\n+      value = static_cast<const rapidjson::Value*>(&rows[row_i]);\n+    } else {\n+      value = nullptr;\n+    }\n+    *path_i = 0;\n+    *arr_i = 0;\n+    return value;\n+  }\n+\n+  arrow::Result<const rapidjson::Value*> Next() {\n+    const rapidjson::Value* value = nullptr;\n+    size_t path_i;\n+    int64_t arr_i;\n+    // Can either start at document or at last array level\n+    if (array_stack.size() > 0) {\n+      auto pos = array_stack.back();\n+      value = pos.array_node;\n+      path_i = pos.path_index;\n+      arr_i = array_stack.size() - 1;\n+    }\n+\n+    value = NextArrayOrRow(value, &path_i, &arr_i);\n+\n+    // Traverse to desired level (with possible backtracking as needed)\n+    while (path_i < path.size() || arr_i < array_levels) {\n+      if (value == nullptr) {\n+        return value;\n+      } else if (value->IsArray() && value->Size() > 0) {\n+        ArrayPosition pos;\n+        pos.array_node = value;\n+        pos.path_index = path_i;\n+        pos.index = 0;\n+        array_stack.push_back(pos);\n+\n+        value = &(*value)[0];\n+        ++arr_i;\n+      } else if (value->IsArray()) {\n+        // Empty array means we need to backtrack and go to next array or row\n+        value = NextArrayOrRow(value, &path_i, &arr_i);\n+      } else if (value->HasMember(path[path_i].c_str())) {\n+        value = &(*value)[path[path_i].c_str()];\n+        ++path_i;\n+      } else {\n+        return &kNullJsonSingleton;\n+      }\n+    }\n+\n+    // Return value\n+    return value;\n+  }\n+\n+ protected:\n+  const std::vector<rapidjson::Document>& rows;\n+  std::vector<std::string> path;\n+  int64_t array_levels;\n+  size_t row_i = -1;  // index of current row\n+\n+  // Info about array position for one array level in array stack\n+  struct ArrayPosition {\n+    const rapidjson::Value* array_node;\n+    int64_t path_index;\n+    rapidjson::SizeType index;\n+  };\n+  std::vector<ArrayPosition> array_stack;\n+};\n+\n+class JsonValueConverter {\n+ public:\n+  explicit JsonValueConverter(const std::vector<rapidjson::Document>& rows)\n+      : rows_(rows), array_levels_(0) {}\n+\n+  JsonValueConverter(const std::vector<rapidjson::Document>& rows,\n+                     const std::vector<std::string>& root_path, int64_t array_levels)\n+      : rows_(rows), root_path_(root_path), array_levels_(array_levels) {}\n+\n+  /// \\brief For field passed in, append corresponding values to builder\n+  arrow::Status Convert(const arrow::Field& field, arrow::ArrayBuilder* builder) {\n+    return Convert(field, field.name(), builder);\n+  }\n+\n+  /// \\brief For field passed in, append corresponding values to builder\n+  arrow::Status Convert(const arrow::Field& field, const std::string& field_name,\n+                        arrow::ArrayBuilder* builder) {\n+    field_name_ = field_name;\n+    builder_ = builder;\n+    ARROW_RETURN_NOT_OK(arrow::VisitTypeInline(*field.type().get(), this));\n+    return arrow::Status::OK();\n+  }\n+\n+  // Default implementation\n+  arrow::Status Visit(const arrow::DataType& type) {\n+    return arrow::Status::NotImplemented(\n+        \"Can not convert to json document for array of type \", type.ToString());\n\nReview Comment:\n   Cannot convert to Arrow array?\n\n\n\n##########\ncpp/examples/arrow/rapidjson_row_converter.cc:\n##########\n@@ -0,0 +1,590 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/result.h>\n+#include <arrow/table_builder.h>\n+#include <arrow/type_traits.h>\n+#include <arrow/util/iterator.h>\n+#include <arrow/util/logging.h>\n+#include <arrow/visit_array_inline.h>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <cassert>\n+#include <iostream>\n+#include <vector>\n+\n+// Transforming dynamic row data into Arrow data\n+// When building connectors to other data systems, it's common to receive data in\n+// row-based structures. While the row_wise_conversion_example.cc shows how to\n+// handle this conversion for fixed schemas, this example demonstrates how to\n+// writer converters for arbitrary schemas.\n+//\n+// As an example, this conversion is between Arrow and rapidjson::Documents.\n+//\n+// We use the following helpers and patterns here:\n+//  * arrow::ToRowConverter and arrow::FromRowConverter, which provide additional\n+//    conversion methods given a basic converter\n+//  * arrow::VisitArrayInline and arrow::VisitTypeInline for implementing a visitor\n+//    pattern with Arrow to handle different array types\n+//  * arrow::enable_if_primitive_ctype to create a template method that handles\n+//  * conversion for Arrow types that have corresponding C types (bool, integer,\n+//    float).\n+\n+rapidjson::Value kNullJsonSingleton = rapidjson::Value();\n+\n+/// \\brief Builder that holds state for a single conversion.\n+///\n+/// Implements Visit() methods for each type of Arrow Array that set the values\n+/// of the corresponding fields in each row.\n+class RowBatchBuilder {\n+ public:\n+  explicit RowBatchBuilder(int64_t num_rows) : field_(nullptr) {\n+    // Reserve all of the space required up-front to avoid unnecessary resizing\n+    rows_.reserve(num_rows);\n+\n+    for (int64_t i = 0; i < num_rows; ++i) {\n+      rows_.push_back(rapidjson::Document());\n+      rows_[i].SetObject();\n+    }\n+  }\n+\n+  /// \\brief Set which field to convert.\n+  void SetField(std::shared_ptr<arrow::Field> field) { field_ = std::move(field); }\n+\n+  /// \\brief Retrieve converted rows from builder.\n+  std::vector<rapidjson::Document> Rows() && { return std::move(rows_); }\n+\n+  // Default implementation\n+  arrow::Status Visit(const arrow::Array& array) {\n+    return arrow::Status::NotImplemented(\n+        \"Can not convert to json document for array of type \", array.type()->ToString());\n+  }\n+\n+  // Handles booleans, integers, floats\n+  template <typename ArrayType, typename DataClass = typename ArrayType::TypeClass>\n+  arrow::enable_if_primitive_ctype<DataClass, arrow::Status> Visit(\n+      const ArrayType& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, array.Value(i), rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StringArray& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        // StringArray.Value returns a string view\n+        auto value_view = array.Value(i);\n+        rapidjson::Value value;\n+        value.SetString(value_view.data(),\n+                        static_cast<rapidjson::SizeType>(value_view.size()),\n+                        rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, value, rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StructArray& array) {\n+    const arrow::StructType* type = array.struct_type();\n+\n+    RowBatchBuilder child_builder(rows_.size());\n+    for (int i = 0; i < type->num_fields(); ++i) {\n+      std::shared_ptr<arrow::Field> child_field = type->field(i);\n+      child_builder.SetField(std::move(child_field));\n+      ARROW_RETURN_NOT_OK(arrow::VisitArrayInline(*array.field(i).get(), &child_builder));\n+    }\n+    std::vector<rapidjson::Document> rows = std::move(child_builder).Rows();\n+\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        // Must copy value to new allocator\n+        rapidjson::Value row_val;\n+        row_val.CopyFrom(rows[i], rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, row_val, rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::ListArray& array) {\n+    // First create rows from values\n+    std::shared_ptr<arrow::Array> values = array.values();\n+    RowBatchBuilder child_builder(values->length());\n+    std::shared_ptr<arrow::Field> value_field = array.list_type()->value_field();\n+    std::string value_field_name = value_field->name();\n+    child_builder.SetField(value_field);\n+    ARROW_RETURN_NOT_OK(arrow::VisitArrayInline(*values.get(), &child_builder));\n+\n+    std::vector<rapidjson::Document> rows = std::move(child_builder).Rows();\n+\n+    int64_t values_i = 0;\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      rapidjson::Document::AllocatorType& allocator = rows_[i].GetAllocator();\n+      auto array_len = array.value_length(i);\n+\n+      rapidjson::Value value;\n+      value.SetArray();\n+      value.Reserve(array_len, allocator);\n+\n+      for (int64_t j = 0; j < array_len; ++j) {\n+        rapidjson::Value row_val;\n+        // Must copy value to new allocator\n+        row_val.CopyFrom(rows[values_i][value_field_name.c_str()], allocator);\n+        value.PushBack(row_val, allocator);\n+        ++values_i;\n+      }\n+\n+      rapidjson::Value str_key(field_->name().c_str(), allocator);\n+      rows_[i].AddMember(str_key, value, allocator);\n+    }\n+\n+    return arrow::Status::OK();\n+  }\n+\n+ private:\n+  std::shared_ptr<arrow::Field> field_;\n+  std::vector<rapidjson::Document> rows_;\n+};  // RowBatchBuilder\n+\n+class ArrowToDocumentConverter : public arrow::ToRowConverter<rapidjson::Document> {\n+ public:\n+  arrow::Result<std::vector<rapidjson::Document>> ConvertToVector(\n+      std::shared_ptr<arrow::RecordBatch> batch) override {\n+    RowBatchBuilder builder{batch->num_rows()};\n+\n+    for (int i = 0; i < batch->num_columns(); ++i) {\n+      builder.SetField(std::move(batch->schema()->field(i)));\n+      ARROW_RETURN_NOT_OK(arrow::VisitArrayInline(*batch->column(i).get(), &builder));\n+    }\n+\n+    return std::move(builder).Rows();\n+  }\n+};  // ArrowToDocumentConverter\n+\n+/// \\brief Iterator over rows values of a document for a given field\n+///\n+/// path and array_levels are used to address each field in a JSON document. As\n+/// an example, consider this JSON document:\n+/// {\n+///     \"x\": 3,                   // path: [\"x\"],             array_levels: 0\n+///     \"files\": [                // path: [\"files\"],         array_levels: 0\n+///         {                     // path: [\"files\"],         array_levels: 1\n+///             \"path\": \"my_str\", // path: [\"files\", \"path\"], array_levels: 1\n+///             \"sizes\": [        // path: [\"files\", \"size\"], array_levels: 1\n+///                 20,           // path: [\"files\", \"size\"], array_levels: 2\n+///                 22\n+///             ]\n+///         }\n+///     ]\n+/// },\n+class DocValuesIterator {\n+ public:\n+  /// \\param rows vector of rows\n+  /// \\param path field names to enter\n+  /// \\param array_levels number of arrays to enter\n+  DocValuesIterator(const std::vector<rapidjson::Document>& rows,\n+                    std::vector<std::string> path, int64_t array_levels)\n+      : rows(rows), path(std::move(path)), array_levels(array_levels) {}\n+\n+  const rapidjson::Value* NextArrayOrRow(const rapidjson::Value* value, size_t* path_i,\n+                                         int64_t* arr_i) {\n+    while (array_stack.size() > 0) {\n+      ArrayPosition& pos = array_stack.back();\n+      // Try to get next position in Array\n+      if (pos.index + 1 < pos.array_node->Size()) {\n+        ++pos.index;\n+        value = &(*pos.array_node)[pos.index];\n+        *path_i = pos.path_index;\n+        *arr_i = array_stack.size();\n+        return value;\n+      } else {\n+        array_stack.pop_back();\n+      }\n+    }\n+    ++row_i;\n+    if (row_i < rows.size()) {\n+      value = static_cast<const rapidjson::Value*>(&rows[row_i]);\n+    } else {\n+      value = nullptr;\n+    }\n+    *path_i = 0;\n+    *arr_i = 0;\n+    return value;\n+  }\n+\n+  arrow::Result<const rapidjson::Value*> Next() {\n+    const rapidjson::Value* value = nullptr;\n+    size_t path_i;\n+    int64_t arr_i;\n+    // Can either start at document or at last array level\n+    if (array_stack.size() > 0) {\n+      auto pos = array_stack.back();\n+      value = pos.array_node;\n+      path_i = pos.path_index;\n+      arr_i = array_stack.size() - 1;\n+    }\n+\n+    value = NextArrayOrRow(value, &path_i, &arr_i);\n+\n+    // Traverse to desired level (with possible backtracking as needed)\n+    while (path_i < path.size() || arr_i < array_levels) {\n+      if (value == nullptr) {\n+        return value;\n+      } else if (value->IsArray() && value->Size() > 0) {\n+        ArrayPosition pos;\n+        pos.array_node = value;\n+        pos.path_index = path_i;\n+        pos.index = 0;\n+        array_stack.push_back(pos);\n+\n+        value = &(*value)[0];\n+        ++arr_i;\n+      } else if (value->IsArray()) {\n+        // Empty array means we need to backtrack and go to next array or row\n+        value = NextArrayOrRow(value, &path_i, &arr_i);\n+      } else if (value->HasMember(path[path_i].c_str())) {\n+        value = &(*value)[path[path_i].c_str()];\n+        ++path_i;\n+      } else {\n+        return &kNullJsonSingleton;\n+      }\n+    }\n+\n+    // Return value\n+    return value;\n+  }\n+\n+ protected:\n+  const std::vector<rapidjson::Document>& rows;\n+  std::vector<std::string> path;\n+  int64_t array_levels;\n+  size_t row_i = -1;  // index of current row\n+\n+  // Info about array position for one array level in array stack\n+  struct ArrayPosition {\n+    const rapidjson::Value* array_node;\n+    int64_t path_index;\n+    rapidjson::SizeType index;\n+  };\n+  std::vector<ArrayPosition> array_stack;\n+};\n+\n+class JsonValueConverter {\n+ public:\n+  explicit JsonValueConverter(const std::vector<rapidjson::Document>& rows)\n+      : rows_(rows), array_levels_(0) {}\n+\n+  JsonValueConverter(const std::vector<rapidjson::Document>& rows,\n+                     const std::vector<std::string>& root_path, int64_t array_levels)\n+      : rows_(rows), root_path_(root_path), array_levels_(array_levels) {}\n+\n+  /// \\brief For field passed in, append corresponding values to builder\n+  arrow::Status Convert(const arrow::Field& field, arrow::ArrayBuilder* builder) {\n+    return Convert(field, field.name(), builder);\n+  }\n+\n+  /// \\brief For field passed in, append corresponding values to builder\n+  arrow::Status Convert(const arrow::Field& field, const std::string& field_name,\n+                        arrow::ArrayBuilder* builder) {\n+    field_name_ = field_name;\n+    builder_ = builder;\n+    ARROW_RETURN_NOT_OK(arrow::VisitTypeInline(*field.type().get(), this));\n+    return arrow::Status::OK();\n+  }\n+\n+  // Default implementation\n+  arrow::Status Visit(const arrow::DataType& type) {\n+    return arrow::Status::NotImplemented(\n+        \"Can not convert to json document for array of type \", type.ToString());\n+  }\n+\n+  arrow::Status Visit(const arrow::Int64Type& type) {\n+    arrow::Int64Builder* builder = static_cast<arrow::Int64Builder*>(builder_);\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      if (value->IsNull()) {\n+        ARROW_RETURN_NOT_OK(builder->AppendNull());\n+      } else {\n+        if (value->IsUint()) {\n+          ARROW_RETURN_NOT_OK(builder->Append(value->GetUint()));\n+        } else if (value->IsInt()) {\n+          ARROW_RETURN_NOT_OK(builder->Append(value->GetInt()));\n+        } else if (value->IsUint64()) {\n+          ARROW_RETURN_NOT_OK(builder->Append(value->GetUint64()));\n+        } else if (value->IsInt64()) {\n+          ARROW_RETURN_NOT_OK(builder->Append(value->GetInt64()));\n+        } else {\n+          return arrow::Status::Invalid(\"Value is not an integer\");\n+        }\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::DoubleType& type) {\n+    arrow::DoubleBuilder* builder = static_cast<arrow::DoubleBuilder*>(builder_);\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      if (value->IsNull()) {\n+        ARROW_RETURN_NOT_OK(builder->AppendNull());\n+      } else {\n+        ARROW_RETURN_NOT_OK(builder->Append(value->GetDouble()));\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StringType& type) {\n+    arrow::StringBuilder* builder = static_cast<arrow::StringBuilder*>(builder_);\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      if (value->IsNull()) {\n+        ARROW_RETURN_NOT_OK(builder->AppendNull());\n+      } else {\n+        ARROW_RETURN_NOT_OK(builder->Append(value->GetString()));\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::BooleanType& type) {\n+    arrow::BooleanBuilder* builder = static_cast<arrow::BooleanBuilder*>(builder_);\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      if (value->IsNull()) {\n+        ARROW_RETURN_NOT_OK(builder->AppendNull());\n+      } else {\n+        ARROW_RETURN_NOT_OK(builder->Append(value->GetBool()));\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StructType& type) {\n+    arrow::StructBuilder* builder = static_cast<arrow::StructBuilder*>(builder_);\n+\n+    std::vector<std::string> child_path(root_path_);\n+    if (field_name_.size() > 0) {\n+      child_path.push_back(field_name_);\n+    }\n+    auto child_converter = JsonValueConverter(rows_, child_path, array_levels_);\n+\n+    for (int i = 0; i < type.num_fields(); ++i) {\n+      std::shared_ptr<arrow::Field> child_field = type.field(i);\n+      std::shared_ptr<arrow::ArrayBuilder> child_builder = builder->child_builder(i);\n+\n+      ARROW_RETURN_NOT_OK(\n+          child_converter.Convert(*child_field.get(), child_builder.get()));\n+    }\n+\n+    // Make null bitmap\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      ARROW_RETURN_NOT_OK(builder->Append(!value->IsNull()));\n+    }\n+\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::ListType& type) {\n+    arrow::ListBuilder* builder = static_cast<arrow::ListBuilder*>(builder_);\n+\n+    // Values and offsets needs to be interleaved in ListBuilder, so first collect the\n+    // values\n+    std::unique_ptr<arrow::ArrayBuilder> tmp_value_builder;\n+    ARROW_ASSIGN_OR_RAISE(tmp_value_builder,\n+                          arrow::MakeBuilder(builder->value_builder()->type()));\n+    std::vector<std::string> child_path(root_path_);\n+    child_path.push_back(field_name_);\n+    auto child_converter = JsonValueConverter(rows_, child_path, array_levels_ + 1);\n+    ARROW_RETURN_NOT_OK(\n+        child_converter.Convert(*type.value_field().get(), \"\", tmp_value_builder.get()));\n+\n+    std::shared_ptr<arrow::Array> values_array;\n+    ARROW_RETURN_NOT_OK(tmp_value_builder->Finish(&values_array));\n+    std::shared_ptr<arrow::ArrayData> values_data = values_array->data();\n+\n+    arrow::ArrayBuilder* value_builder = builder->value_builder();\n+    int64_t offset = 0;\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      ARROW_RETURN_NOT_OK(builder->Append(!value->IsNull()));\n+      if (!value->IsNull() && value->Size() > 0) {\n+        ARROW_RETURN_NOT_OK(\n+            value_builder->AppendArraySlice(*values_data.get(), offset, value->Size()));\n+        offset += value->Size();\n+      }\n+    }\n+\n+    return arrow::Status::OK();\n+  }\n+\n+ protected:\n+  std::string field_name_;\n+  arrow::ArrayBuilder* builder_;\n+  const std::vector<rapidjson::Document>& rows_;\n+  std::vector<std::string> root_path_;\n+  int64_t array_levels_;\n+\n+  /// Return a flattened iterator over values at nested location\n+  arrow::Iterator<const rapidjson::Value*> FieldValues() {\n+    std::vector<std::string> path(root_path_);\n+    if (field_name_.size() > 0) {\n+      path.push_back(field_name_);\n+    }\n+    auto iter = DocValuesIterator(rows_, std::move(path), array_levels_);\n+    auto fn = [iter]() mutable -> arrow::Result<const rapidjson::Value*> {\n+      return iter.Next();\n+    };\n+\n+    return arrow::MakeFunctionIterator(fn);\n+  }\n+};  // JsonValueConverter\n+\n+class DocumentToArrowConverter : public arrow::FromRowConverter<rapidjson::Document> {\n+ public:\n+  explicit DocumentToArrowConverter(arrow::MemoryPool* pool) : pool_(pool) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::RecordBatch>> ConvertToRecordBatch(\n+      const std::vector<rapidjson::Document>& rows,\n+      std::shared_ptr<arrow::Schema> schema) override {\n+    std::unique_ptr<arrow::RecordBatchBuilder> batch_builder;\n+    ARROW_ASSIGN_OR_RAISE(batch_builder,\n+                          arrow::RecordBatchBuilder::Make(schema, pool_, rows.size()));\n+\n+    JsonValueConverter converter(rows);\n+    for (int i = 0; i < batch_builder->num_fields(); ++i) {\n+      std::shared_ptr<arrow::Field> field = schema->field(i);\n+      arrow::ArrayBuilder* builder = batch_builder->GetField(i);\n+      ARROW_RETURN_NOT_OK(converter.Convert(*field.get(), builder));\n+    }\n+\n+    std::shared_ptr<arrow::RecordBatch> batch;\n+    ARROW_ASSIGN_OR_RAISE(batch, batch_builder->Flush());\n+\n+    DCHECK_OK(batch->ValidateFull());\n+    return batch;\n+  }\n+\n+ protected:\n+  arrow::MemoryPool* pool_;\n+};  // DocumentToArrowConverter\n+\n+int main(int argc, char** argv) {\n+  // Get sizes\n+  int32_t num_rows = argc > 1 ? std::atoi(argv[1]) : 100;\n+  int32_t batch_size = argc > 2 ? std::atoi(argv[2]) : 100;\n+\n+  //(Doc section: Convert to Arrow)\n+  // Write JSON records\n+  std::vector<std::string> json_records = {\n+      R\"({\"pk\": 1, \"date_created\": \"2020-10-01\", \"data\": {\"deleted\": true, \"metrics\": [{\"key\": \"x\", \"value\": 1}]}})\",\n+      R\"({\"pk\": 2, \"date_created\": \"2020-10-03\", \"data\": {\"deleted\": false, \"metrics\": []}})\",\n+      R\"({\"pk\": 3, \"date_created\": \"2020-10-05\", \"data\": {\"deleted\": false, \"metrics\": [{\"key\": \"x\", \"value\": 33}, {\"key\": \"x\", \"value\": 42}]}})\"};\n+\n+  std::vector<rapidjson::Document> records;\n+  records.reserve(num_rows);\n+  for (int32_t i = 0; i < num_rows; ++i) {\n+    rapidjson::Document document;\n+    document.Parse(json_records[i % json_records.size()].c_str());\n+    records.push_back(std::move(document));\n+  }\n+  // for (const std::string& json : json_records) {\n+  //   rapidjson::Document document;\n+  //   document.Parse(json.c_str());\n+  //   records.push_back(std::move(document));\n+  // }\n+  for (const rapidjson::Document& doc : records) {\n+    rapidjson::StringBuffer sb;\n+    rapidjson::Writer<rapidjson::StringBuffer> writer(sb);\n+    // At batch_size >= 495, we segfault here:\n+    doc.Accept(writer);\n+    std::cout << sb.GetString() << std::endl;\n+  }\n+  auto tags_schema = arrow::list(arrow::struct_({\n+      arrow::field(\"key\", arrow::utf8()),\n+      arrow::field(\"value\", arrow::int64()),\n+  }));\n+  auto schema = arrow::schema(\n+      {arrow::field(\"pk\", arrow::int64()), arrow::field(\"date_created\", arrow::utf8()),\n+       arrow::field(\"data\", arrow::struct_({arrow::field(\"deleted\", arrow::boolean()),\n+                                            arrow::field(\"metrics\", tags_schema)}))});\n+\n+  // Create converter\n+  DocumentToArrowConverter to_arrow_converter(arrow::default_memory_pool());\n+\n+  // Convert records into a table\n+  arrow::Result<std::shared_ptr<arrow::Table>> table_result =\n+      to_arrow_converter.ConvertToTable(records, schema);\n+  std::shared_ptr<arrow::Table> table = std::move(table_result).ValueOrDie();\n\nReview Comment:\n   in this case why not just `table = *to_arrow_converter.ConvertToTable();`?\n\n\n\n##########\ncpp/examples/arrow/rapidjson_row_converter.cc:\n##########\n@@ -0,0 +1,590 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/result.h>\n+#include <arrow/table_builder.h>\n+#include <arrow/type_traits.h>\n+#include <arrow/util/iterator.h>\n+#include <arrow/util/logging.h>\n+#include <arrow/visit_array_inline.h>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <cassert>\n+#include <iostream>\n+#include <vector>\n+\n+// Transforming dynamic row data into Arrow data\n+// When building connectors to other data systems, it's common to receive data in\n+// row-based structures. While the row_wise_conversion_example.cc shows how to\n+// handle this conversion for fixed schemas, this example demonstrates how to\n+// writer converters for arbitrary schemas.\n+//\n+// As an example, this conversion is between Arrow and rapidjson::Documents.\n+//\n+// We use the following helpers and patterns here:\n+//  * arrow::ToRowConverter and arrow::FromRowConverter, which provide additional\n+//    conversion methods given a basic converter\n+//  * arrow::VisitArrayInline and arrow::VisitTypeInline for implementing a visitor\n+//    pattern with Arrow to handle different array types\n+//  * arrow::enable_if_primitive_ctype to create a template method that handles\n+//  * conversion for Arrow types that have corresponding C types (bool, integer,\n+//    float).\n+\n+rapidjson::Value kNullJsonSingleton = rapidjson::Value();\n+\n+/// \\brief Builder that holds state for a single conversion.\n+///\n+/// Implements Visit() methods for each type of Arrow Array that set the values\n+/// of the corresponding fields in each row.\n+class RowBatchBuilder {\n+ public:\n+  explicit RowBatchBuilder(int64_t num_rows) : field_(nullptr) {\n+    // Reserve all of the space required up-front to avoid unnecessary resizing\n+    rows_.reserve(num_rows);\n+\n+    for (int64_t i = 0; i < num_rows; ++i) {\n+      rows_.push_back(rapidjson::Document());\n+      rows_[i].SetObject();\n+    }\n+  }\n+\n+  /// \\brief Set which field to convert.\n+  void SetField(std::shared_ptr<arrow::Field> field) { field_ = std::move(field); }\n+\n+  /// \\brief Retrieve converted rows from builder.\n+  std::vector<rapidjson::Document> Rows() && { return std::move(rows_); }\n+\n+  // Default implementation\n+  arrow::Status Visit(const arrow::Array& array) {\n+    return arrow::Status::NotImplemented(\n+        \"Can not convert to json document for array of type \", array.type()->ToString());\n+  }\n+\n+  // Handles booleans, integers, floats\n+  template <typename ArrayType, typename DataClass = typename ArrayType::TypeClass>\n+  arrow::enable_if_primitive_ctype<DataClass, arrow::Status> Visit(\n+      const ArrayType& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, array.Value(i), rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StringArray& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        // StringArray.Value returns a string view\n+        auto value_view = array.Value(i);\n+        rapidjson::Value value;\n+        value.SetString(value_view.data(),\n+                        static_cast<rapidjson::SizeType>(value_view.size()),\n+                        rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, value, rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StructArray& array) {\n+    const arrow::StructType* type = array.struct_type();\n+\n+    RowBatchBuilder child_builder(rows_.size());\n+    for (int i = 0; i < type->num_fields(); ++i) {\n+      std::shared_ptr<arrow::Field> child_field = type->field(i);\n+      child_builder.SetField(std::move(child_field));\n+      ARROW_RETURN_NOT_OK(arrow::VisitArrayInline(*array.field(i).get(), &child_builder));\n+    }\n+    std::vector<rapidjson::Document> rows = std::move(child_builder).Rows();\n+\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        // Must copy value to new allocator\n+        rapidjson::Value row_val;\n+        row_val.CopyFrom(rows[i], rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, row_val, rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::ListArray& array) {\n+    // First create rows from values\n+    std::shared_ptr<arrow::Array> values = array.values();\n+    RowBatchBuilder child_builder(values->length());\n+    std::shared_ptr<arrow::Field> value_field = array.list_type()->value_field();\n+    std::string value_field_name = value_field->name();\n+    child_builder.SetField(value_field);\n+    ARROW_RETURN_NOT_OK(arrow::VisitArrayInline(*values.get(), &child_builder));\n+\n+    std::vector<rapidjson::Document> rows = std::move(child_builder).Rows();\n+\n+    int64_t values_i = 0;\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      rapidjson::Document::AllocatorType& allocator = rows_[i].GetAllocator();\n+      auto array_len = array.value_length(i);\n+\n+      rapidjson::Value value;\n+      value.SetArray();\n+      value.Reserve(array_len, allocator);\n+\n+      for (int64_t j = 0; j < array_len; ++j) {\n+        rapidjson::Value row_val;\n+        // Must copy value to new allocator\n+        row_val.CopyFrom(rows[values_i][value_field_name.c_str()], allocator);\n+        value.PushBack(row_val, allocator);\n+        ++values_i;\n+      }\n+\n+      rapidjson::Value str_key(field_->name().c_str(), allocator);\n+      rows_[i].AddMember(str_key, value, allocator);\n+    }\n+\n+    return arrow::Status::OK();\n+  }\n+\n+ private:\n+  std::shared_ptr<arrow::Field> field_;\n+  std::vector<rapidjson::Document> rows_;\n+};  // RowBatchBuilder\n+\n+class ArrowToDocumentConverter : public arrow::ToRowConverter<rapidjson::Document> {\n+ public:\n+  arrow::Result<std::vector<rapidjson::Document>> ConvertToVector(\n+      std::shared_ptr<arrow::RecordBatch> batch) override {\n+    RowBatchBuilder builder{batch->num_rows()};\n+\n+    for (int i = 0; i < batch->num_columns(); ++i) {\n+      builder.SetField(std::move(batch->schema()->field(i)));\n+      ARROW_RETURN_NOT_OK(arrow::VisitArrayInline(*batch->column(i).get(), &builder));\n+    }\n+\n+    return std::move(builder).Rows();\n+  }\n+};  // ArrowToDocumentConverter\n+\n+/// \\brief Iterator over rows values of a document for a given field\n+///\n+/// path and array_levels are used to address each field in a JSON document. As\n+/// an example, consider this JSON document:\n+/// {\n+///     \"x\": 3,                   // path: [\"x\"],             array_levels: 0\n+///     \"files\": [                // path: [\"files\"],         array_levels: 0\n+///         {                     // path: [\"files\"],         array_levels: 1\n+///             \"path\": \"my_str\", // path: [\"files\", \"path\"], array_levels: 1\n+///             \"sizes\": [        // path: [\"files\", \"size\"], array_levels: 1\n+///                 20,           // path: [\"files\", \"size\"], array_levels: 2\n+///                 22\n+///             ]\n+///         }\n+///     ]\n+/// },\n+class DocValuesIterator {\n+ public:\n+  /// \\param rows vector of rows\n+  /// \\param path field names to enter\n+  /// \\param array_levels number of arrays to enter\n+  DocValuesIterator(const std::vector<rapidjson::Document>& rows,\n+                    std::vector<std::string> path, int64_t array_levels)\n+      : rows(rows), path(std::move(path)), array_levels(array_levels) {}\n+\n+  const rapidjson::Value* NextArrayOrRow(const rapidjson::Value* value, size_t* path_i,\n+                                         int64_t* arr_i) {\n+    while (array_stack.size() > 0) {\n+      ArrayPosition& pos = array_stack.back();\n+      // Try to get next position in Array\n+      if (pos.index + 1 < pos.array_node->Size()) {\n+        ++pos.index;\n+        value = &(*pos.array_node)[pos.index];\n+        *path_i = pos.path_index;\n+        *arr_i = array_stack.size();\n+        return value;\n+      } else {\n+        array_stack.pop_back();\n+      }\n+    }\n+    ++row_i;\n+    if (row_i < rows.size()) {\n+      value = static_cast<const rapidjson::Value*>(&rows[row_i]);\n+    } else {\n+      value = nullptr;\n+    }\n+    *path_i = 0;\n+    *arr_i = 0;\n+    return value;\n+  }\n+\n+  arrow::Result<const rapidjson::Value*> Next() {\n+    const rapidjson::Value* value = nullptr;\n+    size_t path_i;\n+    int64_t arr_i;\n+    // Can either start at document or at last array level\n+    if (array_stack.size() > 0) {\n+      auto pos = array_stack.back();\n+      value = pos.array_node;\n+      path_i = pos.path_index;\n+      arr_i = array_stack.size() - 1;\n+    }\n+\n+    value = NextArrayOrRow(value, &path_i, &arr_i);\n+\n+    // Traverse to desired level (with possible backtracking as needed)\n+    while (path_i < path.size() || arr_i < array_levels) {\n+      if (value == nullptr) {\n+        return value;\n+      } else if (value->IsArray() && value->Size() > 0) {\n+        ArrayPosition pos;\n+        pos.array_node = value;\n+        pos.path_index = path_i;\n+        pos.index = 0;\n+        array_stack.push_back(pos);\n+\n+        value = &(*value)[0];\n+        ++arr_i;\n+      } else if (value->IsArray()) {\n+        // Empty array means we need to backtrack and go to next array or row\n+        value = NextArrayOrRow(value, &path_i, &arr_i);\n+      } else if (value->HasMember(path[path_i].c_str())) {\n+        value = &(*value)[path[path_i].c_str()];\n+        ++path_i;\n+      } else {\n+        return &kNullJsonSingleton;\n+      }\n+    }\n+\n+    // Return value\n+    return value;\n+  }\n+\n+ protected:\n+  const std::vector<rapidjson::Document>& rows;\n+  std::vector<std::string> path;\n+  int64_t array_levels;\n+  size_t row_i = -1;  // index of current row\n+\n+  // Info about array position for one array level in array stack\n+  struct ArrayPosition {\n+    const rapidjson::Value* array_node;\n+    int64_t path_index;\n+    rapidjson::SizeType index;\n+  };\n+  std::vector<ArrayPosition> array_stack;\n+};\n+\n+class JsonValueConverter {\n+ public:\n+  explicit JsonValueConverter(const std::vector<rapidjson::Document>& rows)\n+      : rows_(rows), array_levels_(0) {}\n+\n+  JsonValueConverter(const std::vector<rapidjson::Document>& rows,\n+                     const std::vector<std::string>& root_path, int64_t array_levels)\n+      : rows_(rows), root_path_(root_path), array_levels_(array_levels) {}\n+\n+  /// \\brief For field passed in, append corresponding values to builder\n+  arrow::Status Convert(const arrow::Field& field, arrow::ArrayBuilder* builder) {\n+    return Convert(field, field.name(), builder);\n+  }\n+\n+  /// \\brief For field passed in, append corresponding values to builder\n+  arrow::Status Convert(const arrow::Field& field, const std::string& field_name,\n+                        arrow::ArrayBuilder* builder) {\n+    field_name_ = field_name;\n+    builder_ = builder;\n+    ARROW_RETURN_NOT_OK(arrow::VisitTypeInline(*field.type().get(), this));\n+    return arrow::Status::OK();\n+  }\n+\n+  // Default implementation\n+  arrow::Status Visit(const arrow::DataType& type) {\n+    return arrow::Status::NotImplemented(\n+        \"Can not convert to json document for array of type \", type.ToString());\n+  }\n+\n+  arrow::Status Visit(const arrow::Int64Type& type) {\n+    arrow::Int64Builder* builder = static_cast<arrow::Int64Builder*>(builder_);\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      if (value->IsNull()) {\n+        ARROW_RETURN_NOT_OK(builder->AppendNull());\n+      } else {\n+        if (value->IsUint()) {\n+          ARROW_RETURN_NOT_OK(builder->Append(value->GetUint()));\n+        } else if (value->IsInt()) {\n+          ARROW_RETURN_NOT_OK(builder->Append(value->GetInt()));\n+        } else if (value->IsUint64()) {\n+          ARROW_RETURN_NOT_OK(builder->Append(value->GetUint64()));\n+        } else if (value->IsInt64()) {\n+          ARROW_RETURN_NOT_OK(builder->Append(value->GetInt64()));\n+        } else {\n+          return arrow::Status::Invalid(\"Value is not an integer\");\n+        }\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::DoubleType& type) {\n+    arrow::DoubleBuilder* builder = static_cast<arrow::DoubleBuilder*>(builder_);\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      if (value->IsNull()) {\n+        ARROW_RETURN_NOT_OK(builder->AppendNull());\n+      } else {\n+        ARROW_RETURN_NOT_OK(builder->Append(value->GetDouble()));\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StringType& type) {\n+    arrow::StringBuilder* builder = static_cast<arrow::StringBuilder*>(builder_);\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      if (value->IsNull()) {\n+        ARROW_RETURN_NOT_OK(builder->AppendNull());\n+      } else {\n+        ARROW_RETURN_NOT_OK(builder->Append(value->GetString()));\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::BooleanType& type) {\n+    arrow::BooleanBuilder* builder = static_cast<arrow::BooleanBuilder*>(builder_);\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      if (value->IsNull()) {\n+        ARROW_RETURN_NOT_OK(builder->AppendNull());\n+      } else {\n+        ARROW_RETURN_NOT_OK(builder->Append(value->GetBool()));\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StructType& type) {\n+    arrow::StructBuilder* builder = static_cast<arrow::StructBuilder*>(builder_);\n+\n+    std::vector<std::string> child_path(root_path_);\n+    if (field_name_.size() > 0) {\n+      child_path.push_back(field_name_);\n+    }\n+    auto child_converter = JsonValueConverter(rows_, child_path, array_levels_);\n+\n+    for (int i = 0; i < type.num_fields(); ++i) {\n+      std::shared_ptr<arrow::Field> child_field = type.field(i);\n+      std::shared_ptr<arrow::ArrayBuilder> child_builder = builder->child_builder(i);\n+\n+      ARROW_RETURN_NOT_OK(\n+          child_converter.Convert(*child_field.get(), child_builder.get()));\n+    }\n+\n+    // Make null bitmap\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      ARROW_RETURN_NOT_OK(builder->Append(!value->IsNull()));\n+    }\n+\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::ListType& type) {\n+    arrow::ListBuilder* builder = static_cast<arrow::ListBuilder*>(builder_);\n+\n+    // Values and offsets needs to be interleaved in ListBuilder, so first collect the\n+    // values\n+    std::unique_ptr<arrow::ArrayBuilder> tmp_value_builder;\n+    ARROW_ASSIGN_OR_RAISE(tmp_value_builder,\n+                          arrow::MakeBuilder(builder->value_builder()->type()));\n+    std::vector<std::string> child_path(root_path_);\n+    child_path.push_back(field_name_);\n+    auto child_converter = JsonValueConverter(rows_, child_path, array_levels_ + 1);\n+    ARROW_RETURN_NOT_OK(\n+        child_converter.Convert(*type.value_field().get(), \"\", tmp_value_builder.get()));\n+\n+    std::shared_ptr<arrow::Array> values_array;\n+    ARROW_RETURN_NOT_OK(tmp_value_builder->Finish(&values_array));\n+    std::shared_ptr<arrow::ArrayData> values_data = values_array->data();\n+\n+    arrow::ArrayBuilder* value_builder = builder->value_builder();\n+    int64_t offset = 0;\n+    for (const auto& maybe_value : FieldValues()) {\n+      ARROW_ASSIGN_OR_RAISE(auto value, maybe_value);\n+      ARROW_RETURN_NOT_OK(builder->Append(!value->IsNull()));\n+      if (!value->IsNull() && value->Size() > 0) {\n+        ARROW_RETURN_NOT_OK(\n+            value_builder->AppendArraySlice(*values_data.get(), offset, value->Size()));\n+        offset += value->Size();\n+      }\n+    }\n+\n+    return arrow::Status::OK();\n+  }\n+\n+ protected:\n+  std::string field_name_;\n+  arrow::ArrayBuilder* builder_;\n+  const std::vector<rapidjson::Document>& rows_;\n+  std::vector<std::string> root_path_;\n+  int64_t array_levels_;\n+\n+  /// Return a flattened iterator over values at nested location\n+  arrow::Iterator<const rapidjson::Value*> FieldValues() {\n+    std::vector<std::string> path(root_path_);\n+    if (field_name_.size() > 0) {\n+      path.push_back(field_name_);\n+    }\n+    auto iter = DocValuesIterator(rows_, std::move(path), array_levels_);\n+    auto fn = [iter]() mutable -> arrow::Result<const rapidjson::Value*> {\n+      return iter.Next();\n+    };\n+\n+    return arrow::MakeFunctionIterator(fn);\n+  }\n+};  // JsonValueConverter\n+\n+class DocumentToArrowConverter : public arrow::FromRowConverter<rapidjson::Document> {\n+ public:\n+  explicit DocumentToArrowConverter(arrow::MemoryPool* pool) : pool_(pool) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::RecordBatch>> ConvertToRecordBatch(\n+      const std::vector<rapidjson::Document>& rows,\n+      std::shared_ptr<arrow::Schema> schema) override {\n+    std::unique_ptr<arrow::RecordBatchBuilder> batch_builder;\n+    ARROW_ASSIGN_OR_RAISE(batch_builder,\n+                          arrow::RecordBatchBuilder::Make(schema, pool_, rows.size()));\n+\n+    JsonValueConverter converter(rows);\n+    for (int i = 0; i < batch_builder->num_fields(); ++i) {\n+      std::shared_ptr<arrow::Field> field = schema->field(i);\n+      arrow::ArrayBuilder* builder = batch_builder->GetField(i);\n+      ARROW_RETURN_NOT_OK(converter.Convert(*field.get(), builder));\n+    }\n+\n+    std::shared_ptr<arrow::RecordBatch> batch;\n+    ARROW_ASSIGN_OR_RAISE(batch, batch_builder->Flush());\n+\n+    DCHECK_OK(batch->ValidateFull());\n+    return batch;\n+  }\n+\n+ protected:\n+  arrow::MemoryPool* pool_;\n+};  // DocumentToArrowConverter\n+\n+int main(int argc, char** argv) {\n+  // Get sizes\n+  int32_t num_rows = argc > 1 ? std::atoi(argv[1]) : 100;\n+  int32_t batch_size = argc > 2 ? std::atoi(argv[2]) : 100;\n+\n+  //(Doc section: Convert to Arrow)\n+  // Write JSON records\n+  std::vector<std::string> json_records = {\n+      R\"({\"pk\": 1, \"date_created\": \"2020-10-01\", \"data\": {\"deleted\": true, \"metrics\": [{\"key\": \"x\", \"value\": 1}]}})\",\n+      R\"({\"pk\": 2, \"date_created\": \"2020-10-03\", \"data\": {\"deleted\": false, \"metrics\": []}})\",\n+      R\"({\"pk\": 3, \"date_created\": \"2020-10-05\", \"data\": {\"deleted\": false, \"metrics\": [{\"key\": \"x\", \"value\": 33}, {\"key\": \"x\", \"value\": 42}]}})\"};\n+\n+  std::vector<rapidjson::Document> records;\n+  records.reserve(num_rows);\n+  for (int32_t i = 0; i < num_rows; ++i) {\n+    rapidjson::Document document;\n+    document.Parse(json_records[i % json_records.size()].c_str());\n+    records.push_back(std::move(document));\n+  }\n+  // for (const std::string& json : json_records) {\n+  //   rapidjson::Document document;\n+  //   document.Parse(json.c_str());\n+  //   records.push_back(std::move(document));\n+  // }\n+  for (const rapidjson::Document& doc : records) {\n+    rapidjson::StringBuffer sb;\n+    rapidjson::Writer<rapidjson::StringBuffer> writer(sb);\n+    // At batch_size >= 495, we segfault here:\n\nReview Comment:\n   why? \n\n\n\n##########\ncpp/examples/arrow/CMakeLists.txt:\n##########\n@@ -17,6 +17,8 @@\n \n add_arrow_example(row_wise_conversion_example)\n \n+add_arrow_example(rapidjson_row_converter)\n\nReview Comment:\n   I'm also surprised you don't have to link to rapidjson explicitly\u2026\n\n\n\n",
                    "created": "2022-06-09T18:34:30.595+0000",
                    "updated": "2022-06-09T18:34:30.595+0000",
                    "started": "2022-06-09T18:34:30.595+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780089",
                    "issueId": "13435157"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13435157/worklog/780527",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on code in PR #12775:\nURL: https://github.com/apache/arrow/pull/12775#discussion_r895047946\n\n\n##########\nc_glib/arrow-glib/table-builder.cpp:\n##########\n@@ -155,11 +155,10 @@ garrow_record_batch_builder_new(GArrowSchema *schema, GError **error)\n {\n   auto arrow_schema = garrow_schema_get_raw(schema);\n   auto memory_pool = arrow::default_memory_pool();\n-  std::unique_ptr<arrow::RecordBatchBuilder> arrow_builder;\n-  auto status = arrow::RecordBatchBuilder::Make(arrow_schema,\n-                                                memory_pool,\n-                                                &arrow_builder);\n-  if (garrow_error_check(error, status, \"[record-batch-builder][new]\")) {\n+  auto builder_result = arrow::RecordBatchBuilder::Make(arrow_schema, memory_pool);\n+\n+  if (garrow::check(error, builder_result, \"[record-batch-builder][new]\")) {\n+    std::unique_ptr<arrow::RecordBatchBuilder> arrow_builder = std::move(builder_result).ValueOrDie();\n\nReview Comment:\n   nit: formatting, as is this change related?\n\n\n\n",
                    "created": "2022-06-11T17:16:24.350+0000",
                    "updated": "2022-06-11T17:16:24.350+0000",
                    "started": "2022-06-11T17:16:24.349+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780527",
                    "issueId": "13435157"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13435157/worklog/780528",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on code in PR #12775:\nURL: https://github.com/apache/arrow/pull/12775#discussion_r895048076\n\n\n##########\ncpp/examples/arrow/rapidjson_row_converter.cc:\n##########\n@@ -0,0 +1,590 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/result.h>\n+#include <arrow/table_builder.h>\n+#include <arrow/type_traits.h>\n+#include <arrow/util/iterator.h>\n+#include <arrow/util/logging.h>\n+#include <arrow/visit_array_inline.h>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <cassert>\n+#include <iostream>\n+#include <vector>\n+\n+// Transforming dynamic row data into Arrow data\n+// When building connectors to other data systems, it's common to receive data in\n+// row-based structures. While the row_wise_conversion_example.cc shows how to\n+// handle this conversion for fixed schemas, this example demonstrates how to\n+// writer converters for arbitrary schemas.\n+//\n+// As an example, this conversion is between Arrow and rapidjson::Documents.\n+//\n+// We use the following helpers and patterns here:\n+//  * arrow::ToRowConverter and arrow::FromRowConverter, which provide additional\n+//    conversion methods given a basic converter\n+//  * arrow::VisitArrayInline and arrow::VisitTypeInline for implementing a visitor\n+//    pattern with Arrow to handle different array types\n+//  * arrow::enable_if_primitive_ctype to create a template method that handles\n+//  * conversion for Arrow types that have corresponding C types (bool, integer,\n+//    float).\n+\n+rapidjson::Value kNullJsonSingleton = rapidjson::Value();\n\nReview Comment:\n   nit: make this const static?\n\n\n\n",
                    "created": "2022-06-11T17:17:39.662+0000",
                    "updated": "2022-06-11T17:17:39.662+0000",
                    "started": "2022-06-11T17:17:39.661+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780528",
                    "issueId": "13435157"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13435157/worklog/780529",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on code in PR #12775:\nURL: https://github.com/apache/arrow/pull/12775#discussion_r895048272\n\n\n##########\ncpp/examples/arrow/rapidjson_row_converter.cc:\n##########\n@@ -0,0 +1,590 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/result.h>\n+#include <arrow/table_builder.h>\n+#include <arrow/type_traits.h>\n+#include <arrow/util/iterator.h>\n+#include <arrow/util/logging.h>\n+#include <arrow/visit_array_inline.h>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <cassert>\n+#include <iostream>\n+#include <vector>\n+\n+// Transforming dynamic row data into Arrow data\n+// When building connectors to other data systems, it's common to receive data in\n+// row-based structures. While the row_wise_conversion_example.cc shows how to\n+// handle this conversion for fixed schemas, this example demonstrates how to\n+// writer converters for arbitrary schemas.\n+//\n+// As an example, this conversion is between Arrow and rapidjson::Documents.\n+//\n+// We use the following helpers and patterns here:\n+//  * arrow::ToRowConverter and arrow::FromRowConverter, which provide additional\n+//    conversion methods given a basic converter\n+//  * arrow::VisitArrayInline and arrow::VisitTypeInline for implementing a visitor\n+//    pattern with Arrow to handle different array types\n+//  * arrow::enable_if_primitive_ctype to create a template method that handles\n+//  * conversion for Arrow types that have corresponding C types (bool, integer,\n+//    float).\n+\n+rapidjson::Value kNullJsonSingleton = rapidjson::Value();\n+\n+/// \\brief Builder that holds state for a single conversion.\n+///\n+/// Implements Visit() methods for each type of Arrow Array that set the values\n+/// of the corresponding fields in each row.\n+class RowBatchBuilder {\n+ public:\n+  explicit RowBatchBuilder(int64_t num_rows) : field_(nullptr) {\n+    // Reserve all of the space required up-front to avoid unnecessary resizing\n+    rows_.reserve(num_rows);\n+\n+    for (int64_t i = 0; i < num_rows; ++i) {\n+      rows_.push_back(rapidjson::Document());\n+      rows_[i].SetObject();\n+    }\n+  }\n+\n+  /// \\brief Set which field to convert.\n+  void SetField(std::shared_ptr<arrow::Field> field) { field_ = std::move(field); }\n+\n+  /// \\brief Retrieve converted rows from builder.\n+  std::vector<rapidjson::Document> Rows() && { return std::move(rows_); }\n+\n+  // Default implementation\n+  arrow::Status Visit(const arrow::Array& array) {\n+    return arrow::Status::NotImplemented(\n+        \"Can not convert to json document for array of type \", array.type()->ToString());\n+  }\n+\n+  // Handles booleans, integers, floats\n+  template <typename ArrayType, typename DataClass = typename ArrayType::TypeClass>\n+  arrow::enable_if_primitive_ctype<DataClass, arrow::Status> Visit(\n+      const ArrayType& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n\nReview Comment:\n   nit: c_str,looks wrong here (what about unicode field names)\n\n\n\n",
                    "created": "2022-06-11T17:20:15.134+0000",
                    "updated": "2022-06-11T17:20:15.134+0000",
                    "started": "2022-06-11T17:20:15.134+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780529",
                    "issueId": "13435157"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13435157/worklog/780693",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on code in PR #12775:\nURL: https://github.com/apache/arrow/pull/12775#discussion_r895305905\n\n\n##########\ncpp/examples/arrow/rapidjson_row_converter.cc:\n##########\n@@ -0,0 +1,590 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/result.h>\n+#include <arrow/table_builder.h>\n+#include <arrow/type_traits.h>\n+#include <arrow/util/iterator.h>\n+#include <arrow/util/logging.h>\n+#include <arrow/visit_array_inline.h>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <cassert>\n+#include <iostream>\n+#include <vector>\n+\n+// Transforming dynamic row data into Arrow data\n+// When building connectors to other data systems, it's common to receive data in\n+// row-based structures. While the row_wise_conversion_example.cc shows how to\n+// handle this conversion for fixed schemas, this example demonstrates how to\n+// writer converters for arbitrary schemas.\n+//\n+// As an example, this conversion is between Arrow and rapidjson::Documents.\n+//\n+// We use the following helpers and patterns here:\n+//  * arrow::ToRowConverter and arrow::FromRowConverter, which provide additional\n+//    conversion methods given a basic converter\n+//  * arrow::VisitArrayInline and arrow::VisitTypeInline for implementing a visitor\n+//    pattern with Arrow to handle different array types\n+//  * arrow::enable_if_primitive_ctype to create a template method that handles\n+//  * conversion for Arrow types that have corresponding C types (bool, integer,\n+//    float).\n+\n+rapidjson::Value kNullJsonSingleton = rapidjson::Value();\n+\n+/// \\brief Builder that holds state for a single conversion.\n+///\n+/// Implements Visit() methods for each type of Arrow Array that set the values\n+/// of the corresponding fields in each row.\n+class RowBatchBuilder {\n+ public:\n+  explicit RowBatchBuilder(int64_t num_rows) : field_(nullptr) {\n+    // Reserve all of the space required up-front to avoid unnecessary resizing\n+    rows_.reserve(num_rows);\n+\n+    for (int64_t i = 0; i < num_rows; ++i) {\n+      rows_.push_back(rapidjson::Document());\n+      rows_[i].SetObject();\n+    }\n+  }\n+\n+  /// \\brief Set which field to convert.\n+  void SetField(std::shared_ptr<arrow::Field> field) { field_ = std::move(field); }\n+\n+  /// \\brief Retrieve converted rows from builder.\n+  std::vector<rapidjson::Document> Rows() && { return std::move(rows_); }\n+\n+  // Default implementation\n+  arrow::Status Visit(const arrow::Array& array) {\n+    return arrow::Status::NotImplemented(\n+        \"Can not convert to json document for array of type \", array.type()->ToString());\n+  }\n+\n+  // Handles booleans, integers, floats\n+  template <typename ArrayType, typename DataClass = typename ArrayType::TypeClass>\n+  arrow::enable_if_primitive_ctype<DataClass, arrow::Status> Visit(\n+      const ArrayType& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, array.Value(i), rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StringArray& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n\nReview Comment:\n   same comment about c_str.\n\n\n\n",
                    "created": "2022-06-13T03:53:05.245+0000",
                    "updated": "2022-06-13T03:53:05.245+0000",
                    "started": "2022-06-13T03:53:05.245+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780693",
                    "issueId": "13435157"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13435157/worklog/780694",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on code in PR #12775:\nURL: https://github.com/apache/arrow/pull/12775#discussion_r895306105\n\n\n##########\ncpp/examples/arrow/rapidjson_row_converter.cc:\n##########\n@@ -0,0 +1,590 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/result.h>\n+#include <arrow/table_builder.h>\n+#include <arrow/type_traits.h>\n+#include <arrow/util/iterator.h>\n+#include <arrow/util/logging.h>\n+#include <arrow/visit_array_inline.h>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <cassert>\n+#include <iostream>\n+#include <vector>\n+\n+// Transforming dynamic row data into Arrow data\n+// When building connectors to other data systems, it's common to receive data in\n+// row-based structures. While the row_wise_conversion_example.cc shows how to\n+// handle this conversion for fixed schemas, this example demonstrates how to\n+// writer converters for arbitrary schemas.\n+//\n+// As an example, this conversion is between Arrow and rapidjson::Documents.\n+//\n+// We use the following helpers and patterns here:\n+//  * arrow::ToRowConverter and arrow::FromRowConverter, which provide additional\n+//    conversion methods given a basic converter\n+//  * arrow::VisitArrayInline and arrow::VisitTypeInline for implementing a visitor\n+//    pattern with Arrow to handle different array types\n+//  * arrow::enable_if_primitive_ctype to create a template method that handles\n+//  * conversion for Arrow types that have corresponding C types (bool, integer,\n+//    float).\n+\n+rapidjson::Value kNullJsonSingleton = rapidjson::Value();\n+\n+/// \\brief Builder that holds state for a single conversion.\n+///\n+/// Implements Visit() methods for each type of Arrow Array that set the values\n+/// of the corresponding fields in each row.\n+class RowBatchBuilder {\n+ public:\n+  explicit RowBatchBuilder(int64_t num_rows) : field_(nullptr) {\n+    // Reserve all of the space required up-front to avoid unnecessary resizing\n+    rows_.reserve(num_rows);\n+\n+    for (int64_t i = 0; i < num_rows; ++i) {\n+      rows_.push_back(rapidjson::Document());\n+      rows_[i].SetObject();\n+    }\n+  }\n+\n+  /// \\brief Set which field to convert.\n+  void SetField(std::shared_ptr<arrow::Field> field) { field_ = std::move(field); }\n+\n+  /// \\brief Retrieve converted rows from builder.\n+  std::vector<rapidjson::Document> Rows() && { return std::move(rows_); }\n+\n+  // Default implementation\n+  arrow::Status Visit(const arrow::Array& array) {\n+    return arrow::Status::NotImplemented(\n+        \"Can not convert to json document for array of type \", array.type()->ToString());\n+  }\n+\n+  // Handles booleans, integers, floats\n+  template <typename ArrayType, typename DataClass = typename ArrayType::TypeClass>\n+  arrow::enable_if_primitive_ctype<DataClass, arrow::Status> Visit(\n+      const ArrayType& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, array.Value(i), rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StringArray& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        // StringArray.Value returns a string view\n\nReview Comment:\n   it seems it would be more succinct to spell out the type below then to have this comment.\n\n\n\n",
                    "created": "2022-06-13T03:53:55.410+0000",
                    "updated": "2022-06-13T03:53:55.410+0000",
                    "started": "2022-06-13T03:53:55.410+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780694",
                    "issueId": "13435157"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13435157/worklog/780695",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on code in PR #12775:\nURL: https://github.com/apache/arrow/pull/12775#discussion_r895306498\n\n\n##########\ncpp/examples/arrow/rapidjson_row_converter.cc:\n##########\n@@ -0,0 +1,590 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/result.h>\n+#include <arrow/table_builder.h>\n+#include <arrow/type_traits.h>\n+#include <arrow/util/iterator.h>\n+#include <arrow/util/logging.h>\n+#include <arrow/visit_array_inline.h>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <cassert>\n+#include <iostream>\n+#include <vector>\n+\n+// Transforming dynamic row data into Arrow data\n+// When building connectors to other data systems, it's common to receive data in\n+// row-based structures. While the row_wise_conversion_example.cc shows how to\n+// handle this conversion for fixed schemas, this example demonstrates how to\n+// writer converters for arbitrary schemas.\n+//\n+// As an example, this conversion is between Arrow and rapidjson::Documents.\n+//\n+// We use the following helpers and patterns here:\n+//  * arrow::ToRowConverter and arrow::FromRowConverter, which provide additional\n+//    conversion methods given a basic converter\n+//  * arrow::VisitArrayInline and arrow::VisitTypeInline for implementing a visitor\n+//    pattern with Arrow to handle different array types\n+//  * arrow::enable_if_primitive_ctype to create a template method that handles\n+//  * conversion for Arrow types that have corresponding C types (bool, integer,\n+//    float).\n+\n+rapidjson::Value kNullJsonSingleton = rapidjson::Value();\n+\n+/// \\brief Builder that holds state for a single conversion.\n+///\n+/// Implements Visit() methods for each type of Arrow Array that set the values\n+/// of the corresponding fields in each row.\n+class RowBatchBuilder {\n+ public:\n+  explicit RowBatchBuilder(int64_t num_rows) : field_(nullptr) {\n+    // Reserve all of the space required up-front to avoid unnecessary resizing\n+    rows_.reserve(num_rows);\n+\n+    for (int64_t i = 0; i < num_rows; ++i) {\n+      rows_.push_back(rapidjson::Document());\n+      rows_[i].SetObject();\n+    }\n+  }\n+\n+  /// \\brief Set which field to convert.\n+  void SetField(std::shared_ptr<arrow::Field> field) { field_ = std::move(field); }\n+\n+  /// \\brief Retrieve converted rows from builder.\n+  std::vector<rapidjson::Document> Rows() && { return std::move(rows_); }\n+\n+  // Default implementation\n+  arrow::Status Visit(const arrow::Array& array) {\n+    return arrow::Status::NotImplemented(\n+        \"Can not convert to json document for array of type \", array.type()->ToString());\n+  }\n+\n+  // Handles booleans, integers, floats\n+  template <typename ArrayType, typename DataClass = typename ArrayType::TypeClass>\n+  arrow::enable_if_primitive_ctype<DataClass, arrow::Status> Visit(\n+      const ArrayType& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, array.Value(i), rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StringArray& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        // StringArray.Value returns a string view\n+        auto value_view = array.Value(i);\n+        rapidjson::Value value;\n+        value.SetString(value_view.data(),\n+                        static_cast<rapidjson::SizeType>(value_view.size()),\n+                        rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, value, rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StructArray& array) {\n+    const arrow::StructType* type = array.struct_type();\n+\n+    RowBatchBuilder child_builder(rows_.size());\n\nReview Comment:\n   should this be based on array.size()?\n\n\n\n",
                    "created": "2022-06-13T03:55:20.719+0000",
                    "updated": "2022-06-13T03:55:20.719+0000",
                    "started": "2022-06-13T03:55:20.719+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780695",
                    "issueId": "13435157"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13435157/worklog/780696",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on code in PR #12775:\nURL: https://github.com/apache/arrow/pull/12775#discussion_r895306649\n\n\n##########\ncpp/examples/arrow/rapidjson_row_converter.cc:\n##########\n@@ -0,0 +1,590 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/result.h>\n+#include <arrow/table_builder.h>\n+#include <arrow/type_traits.h>\n+#include <arrow/util/iterator.h>\n+#include <arrow/util/logging.h>\n+#include <arrow/visit_array_inline.h>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <cassert>\n+#include <iostream>\n+#include <vector>\n+\n+// Transforming dynamic row data into Arrow data\n+// When building connectors to other data systems, it's common to receive data in\n+// row-based structures. While the row_wise_conversion_example.cc shows how to\n+// handle this conversion for fixed schemas, this example demonstrates how to\n+// writer converters for arbitrary schemas.\n+//\n+// As an example, this conversion is between Arrow and rapidjson::Documents.\n+//\n+// We use the following helpers and patterns here:\n+//  * arrow::ToRowConverter and arrow::FromRowConverter, which provide additional\n+//    conversion methods given a basic converter\n+//  * arrow::VisitArrayInline and arrow::VisitTypeInline for implementing a visitor\n+//    pattern with Arrow to handle different array types\n+//  * arrow::enable_if_primitive_ctype to create a template method that handles\n+//  * conversion for Arrow types that have corresponding C types (bool, integer,\n+//    float).\n+\n+rapidjson::Value kNullJsonSingleton = rapidjson::Value();\n+\n+/// \\brief Builder that holds state for a single conversion.\n+///\n+/// Implements Visit() methods for each type of Arrow Array that set the values\n+/// of the corresponding fields in each row.\n+class RowBatchBuilder {\n+ public:\n+  explicit RowBatchBuilder(int64_t num_rows) : field_(nullptr) {\n+    // Reserve all of the space required up-front to avoid unnecessary resizing\n+    rows_.reserve(num_rows);\n+\n+    for (int64_t i = 0; i < num_rows; ++i) {\n+      rows_.push_back(rapidjson::Document());\n+      rows_[i].SetObject();\n+    }\n+  }\n+\n+  /// \\brief Set which field to convert.\n+  void SetField(std::shared_ptr<arrow::Field> field) { field_ = std::move(field); }\n+\n+  /// \\brief Retrieve converted rows from builder.\n+  std::vector<rapidjson::Document> Rows() && { return std::move(rows_); }\n+\n+  // Default implementation\n+  arrow::Status Visit(const arrow::Array& array) {\n+    return arrow::Status::NotImplemented(\n+        \"Can not convert to json document for array of type \", array.type()->ToString());\n+  }\n+\n+  // Handles booleans, integers, floats\n+  template <typename ArrayType, typename DataClass = typename ArrayType::TypeClass>\n+  arrow::enable_if_primitive_ctype<DataClass, arrow::Status> Visit(\n+      const ArrayType& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, array.Value(i), rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StringArray& array) {\n+    for (int64_t i = 0; i < array.length(); ++i) {\n+      if (!array.IsNull(i)) {\n+        rapidjson::Value str_key(field_->name().c_str(), rows_[i].GetAllocator());\n+        // StringArray.Value returns a string view\n+        auto value_view = array.Value(i);\n+        rapidjson::Value value;\n+        value.SetString(value_view.data(),\n+                        static_cast<rapidjson::SizeType>(value_view.size()),\n+                        rows_[i].GetAllocator());\n+        rows_[i].AddMember(str_key, value, rows_[i].GetAllocator());\n+      }\n+    }\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Status Visit(const arrow::StructArray& array) {\n+    const arrow::StructType* type = array.struct_type();\n+\n+    RowBatchBuilder child_builder(rows_.size());\n\nReview Comment:\n   or is this saying only extract n_rows from the struct array?\n\n\n\n",
                    "created": "2022-06-13T03:55:50.629+0000",
                    "updated": "2022-06-13T03:55:50.629+0000",
                    "started": "2022-06-13T03:55:50.629+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780696",
                    "issueId": "13435157"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13435157/worklog/780734",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wjones127 commented on code in PR #12775:\nURL: https://github.com/apache/arrow/pull/12775#discussion_r895438582\n\n\n##########\nc_glib/arrow-glib/table-builder.cpp:\n##########\n@@ -155,11 +155,10 @@ garrow_record_batch_builder_new(GArrowSchema *schema, GError **error)\n {\n   auto arrow_schema = garrow_schema_get_raw(schema);\n   auto memory_pool = arrow::default_memory_pool();\n-  std::unique_ptr<arrow::RecordBatchBuilder> arrow_builder;\n-  auto status = arrow::RecordBatchBuilder::Make(arrow_schema,\n-                                                memory_pool,\n-                                                &arrow_builder);\n-  if (garrow_error_check(error, status, \"[record-batch-builder][new]\")) {\n+  auto builder_result = arrow::RecordBatchBuilder::Make(arrow_schema, memory_pool);\n+\n+  if (garrow::check(error, builder_result, \"[record-batch-builder][new]\")) {\n+    std::unique_ptr<arrow::RecordBatchBuilder> arrow_builder = std::move(builder_result).ValueOrDie();\n\nReview Comment:\n   It's not related. I've moved this change to #13356 and will rebase after that's merged.\n\n\n\n",
                    "created": "2022-06-13T08:07:30.517+0000",
                    "updated": "2022-06-13T08:07:30.517+0000",
                    "started": "2022-06-13T08:07:30.516+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780734",
                    "issueId": "13435157"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 26400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@2278e2f[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2508e9d1[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1b829b68[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@7926afa8[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7f88b29f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@bee702d[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@438f3e3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@482f5723[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@728918f3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@a9e6197[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@497a2ccc[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@7b5efc8f[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 26400,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Jul 06 11:52:37 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": [
            "C++"
        ],
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-07-06T11:52:37.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-16006/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2022-03-22T16:14:19.000+0000",
        "updated": "2022-07-06T11:52:37.000+0000",
        "timeoriginalestimate": null,
        "description": "Short version: Given a way to convert a vector of rows and a schema to a RecordBatch, we can derive methods for efficiently converting a vector of rows to a Table or even an iterator of rows to a Record Batch Reader. Similarly, we could go the other way: given a way to convert a RecordBatch to a vector of rows, we can derive methods for converting from Tables or RBRs.\r\n\r\nLong version: https://docs.google.com/document/d/174tldmQLMCvOtjxGtFPeoLBefyE1x26_xntwfSzDXFA/edit?usp=sharing",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "7h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 26400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Docs] Provide row conversion example for dynamic schemas",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13435157/comment/17563176",
                    "id": "17563176",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 12775\n[https://github.com/apache/arrow/pull/12775]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2022-07-06T11:52:37.382+0000",
                    "updated": "2022-07-06T11:52:37.382+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z10ps8:",
        "customfield_12314139": null
    }
}