{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13248477",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477",
    "key": "ARROW-6111",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12347769",
                "id": "12347769",
                "description": "",
                "name": "1.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-07-24"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/1",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/blocker.svg",
            "name": "Blocker",
            "id": "1"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12594453",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12594453",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "outwardIssue": {
                    "id": "13320034",
                    "key": "ARROW-9595",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13320034",
                    "fields": {
                        "summary": "[Java] DefaultVectorComparators does not have a comparator for BaseLargeVariableVector",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12585830",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12585830",
                "type": {
                    "id": "10001",
                    "name": "dependent",
                    "inward": "is depended upon by",
                    "outward": "depends upon",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10001"
                },
                "outwardIssue": {
                    "id": "13298332",
                    "key": "ARROW-8450",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13298332",
                    "fields": {
                        "summary": "[Integration][C++] Implement large list/binary/utf8 integration",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=fan_li_ya",
            "name": "fan_li_ya",
            "key": "fan_li_ya",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Liya Fan",
            "active": true,
            "timeZone": "Asia/Shanghai"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333774",
                "id": "12333774",
                "name": "Integration",
                "description": "Issues related to integration / compatibility tests between implementations"
            },
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328933",
                "id": "12328933",
                "name": "Java"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
            "name": "emkornfield@gmail.com",
            "key": "emkornfield@gmail.com",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
            "name": "emkornfield@gmail.com",
            "key": "emkornfield@gmail.com",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 31800,
            "total": 31800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 31800,
            "total": 31800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-6111/votes",
            "votes": 1,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 53,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/worklog/387331",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on pull request #6425: ARROW-6111: [Java] Support LargeVarChar and LargeBinary types\nURL: https://github.com/apache/arrow/pull/6425\n \n \n   These types of vectors are also variable width vectors. However, they have a offset width of 8, so the underlying data buffer can be over 2GB in size. \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-02-14T13:06:56.737+0000",
                    "updated": "2020-02-14T13:06:56.737+0000",
                    "started": "2020-02-14T13:06:56.736+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "387331",
                    "issueId": "13248477"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/worklog/387346",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on issue #6425: ARROW-6111: [Java] Support LargeVarChar and LargeBinary types\nURL: https://github.com/apache/arrow/pull/6425#issuecomment-586283528\n \n \n   https://issues.apache.org/jira/browse/ARROW-6111\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-02-14T13:16:46.144+0000",
                    "updated": "2020-02-14T13:16:46.144+0000",
                    "started": "2020-02-14T13:16:46.144+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "387346",
                    "issueId": "13248477"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/worklog/391526",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on issue #6425: ARROW-6111: [Java] Support LargeVarChar and LargeBinary types\nURL: https://github.com/apache/arrow/pull/6425#issuecomment-590178111\n \n \n   @siddharthteotia do you have time to review?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-02-24T06:03:36.190+0000",
                    "updated": "2020-02-24T06:03:36.190+0000",
                    "started": "2020-02-24T06:03:36.188+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "391526",
                    "issueId": "13248477"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/worklog/398929",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on issue #6425: ARROW-6111: [Java] Support LargeVarChar and LargeBinary types\nURL: https://github.com/apache/arrow/pull/6425#issuecomment-595600717\n \n \n   @BryanCutler if you have time to review it would be appreciated otherwise I can take a look soon.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-06T04:59:52.826+0000",
                    "updated": "2020-03-06T04:59:52.826+0000",
                    "started": "2020-03-06T04:59:52.825+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "398929",
                    "issueId": "13248477"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/worklog/398942",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "siddharthteotia commented on issue #6425: ARROW-6111: [Java] Support LargeVarChar and LargeBinary types\nURL: https://github.com/apache/arrow/pull/6425#issuecomment-595607603\n \n \n   I will review this tomorrow. Sorry for the delay. \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-06T05:31:32.586+0000",
                    "updated": "2020-03-06T05:31:32.586+0000",
                    "started": "2020-03-06T05:31:32.585+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "398942",
                    "issueId": "13248477"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/worklog/401218",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on issue #6425: ARROW-6111: [Java] Support LargeVarChar and LargeBinary types\nURL: https://github.com/apache/arrow/pull/6425#issuecomment-597453215\n \n \n   @siddharthteotia do you still intend to review?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-11T05:38:50.691+0000",
                    "updated": "2020-03-11T05:38:50.691+0000",
                    "started": "2020-03-11T05:38:50.691+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "401218",
                    "issueId": "13248477"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/worklog/401967",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "siddharthteotia commented on pull request #6425: ARROW-6111: [Java] Support LargeVarChar and LargeBinary types\nURL: https://github.com/apache/arrow/pull/6425#discussion_r391411240\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseLargeVariableWidthVector.java\n ##########\n @@ -0,0 +1,1361 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+/**\n+ * BaseLargeVariableWidthVector is a base class providing functionality for large strings/large bytes types.\n+ */\n+public abstract class BaseLargeVariableWidthVector extends BaseValueVector\n+    implements VariableWidthVector, FieldVector, VectorDefinitionSetter {\n+  private static final int DEFAULT_RECORD_BYTE_COUNT = 12;\n+  private static final int INITIAL_BYTE_COUNT = INITIAL_VALUE_ALLOCATION * DEFAULT_RECORD_BYTE_COUNT;\n+  private int lastValueCapacity;\n+  private long lastValueAllocationSizeInBytes;\n+\n+  /* protected members */\n+  public static final int OFFSET_WIDTH = 8; /* 8 byte unsigned int to track offsets */\n+  protected static final byte[] emptyByteArray = new byte[]{};\n+  protected ArrowBuf validityBuffer;\n+  protected ArrowBuf valueBuffer;\n+  protected ArrowBuf offsetBuffer;\n+  protected int valueCount;\n+  protected int lastSet;\n+  protected final Field field;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param field The field materialized by this vector.\n+   * @param allocator The allocator to use for creating/resizing buffers\n+   */\n+  public BaseLargeVariableWidthVector(Field field, final BufferAllocator allocator) {\n+    super(allocator);\n+    this.field = field;\n+    lastValueAllocationSizeInBytes = INITIAL_BYTE_COUNT;\n+    // -1 because we require one extra slot for the offset array.\n+    lastValueCapacity = INITIAL_VALUE_ALLOCATION - 1;\n+    valueCount = 0;\n+    lastSet = -1;\n+    offsetBuffer = allocator.getEmpty();\n+    validityBuffer = allocator.getEmpty();\n+    valueBuffer = allocator.getEmpty();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return field.getName();\n+  }\n+\n+  /**\n+   * Get buffer that manages the validity (NULL or NON-NULL nature) of\n+   * elements in the vector. Consider it as a buffer for internal bit vector\n+   * data structure.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  /**\n+   * Get the buffer that stores the data for elements in the vector.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    return valueBuffer;\n+  }\n+\n+  /**\n+   * buffer that stores the offsets for elements\n+   * in the vector. This operation is not supported for fixed-width vectors.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the offsets for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return offsetBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that manages the validity\n+   * (NULL or NON-NULL nature) of elements in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return validityBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the data for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getDataBufferAddress() {\n+    return valueBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   * @param valueCount desired number of elements in the vector\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount) {\n+    final long size = (long) valueCount * DEFAULT_RECORD_BYTE_COUNT;\n+    checkDataBufferSize(size);\n+    computeAndCheckOffsetsBufferSize(valueCount);\n+    lastValueAllocationSizeInBytes = size;\n+    lastValueCapacity = valueCount;\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   * @param valueCount desired number of elements in the vector\n+   * @param density average number of bytes per variable width element\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount, double density) {\n+    long size = Math.max((long)(valueCount * density), 1L);\n+    checkDataBufferSize(size);\n+    computeAndCheckOffsetsBufferSize(valueCount);\n+    lastValueAllocationSizeInBytes = size;\n+    lastValueCapacity = valueCount;\n+  }\n+\n+  /**\n+   * Get the density of this ListVector.\n+   * @return density\n+   */\n+  public double getDensity() {\n+    if (valueCount == 0) {\n+      return 0.0D;\n+    }\n+    final long startOffset = offsetBuffer.getLong(0);\n+    final long endOffset = offsetBuffer.getLong((long) valueCount * OFFSET_WIDTH);\n+    final double totalListSize = endOffset - startOffset;\n+    return totalListSize / valueCount;\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector.\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    final long offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n+    return capAtMaxInt(Math.min(offsetValueCapacity, getValidityBufferValueCapacity()));\n+  }\n+\n+  private long getValidityBufferValueCapacity() {\n+    return validityBuffer.capacity() * 8;\n+  }\n+\n+  private long getOffsetBufferValueCapacity() {\n+    return offsetBuffer.capacity() / OFFSET_WIDTH;\n+  }\n+\n+  /**\n+   * zero out the vector and the data in associated buffers.\n+   */\n+  public void zeroVector() {\n+    initValidityBuffer();\n+    initOffsetBuffer();\n+    valueBuffer.setZero(0, valueBuffer.capacity());\n+  }\n+\n+  /* zero out the validity buffer */\n+  private void initValidityBuffer() {\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+\n+  /* zero out the offset buffer */\n+  private void initOffsetBuffer() {\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+\n+  /**\n+   * Reset the vector to initial state. Same as {@link #zeroVector()}.\n+   * Note that this method doesn't release any memory.\n+   */\n+  public void reset() {\n+    zeroVector();\n+    lastSet = -1;\n+    valueCount = 0;\n+  }\n+\n+  /**\n+   * Close the vector and release the associated buffers.\n+   */\n+  @Override\n+  public void close() {\n+    clear();\n+  }\n+\n+  /**\n+   * Same as {@link #close()}.\n+   */\n+  @Override\n+  public void clear() {\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    valueBuffer = releaseBuffer(valueBuffer);\n+    offsetBuffer = releaseBuffer(offsetBuffer);\n+    lastSet = -1;\n+    valueCount = 0;\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Initialize the children in schema for this Field. This operation is a\n+   * NO-OP for scalar types since they don't have any children.\n+   * @param children the schema\n+   * @throws IllegalArgumentException if children is a non-empty list for scalar types.\n+   */\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (!children.isEmpty()) {\n+      throw new IllegalArgumentException(\"primitive type vector can not have children\");\n+    }\n+  }\n+\n+  /**\n+   * Get the inner child vectors.\n+   * @return list of child vectors for complex types, empty list for scalar vector types\n+   */\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return Collections.emptyList();\n+  }\n+\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+    ArrowBuf dataBuffer = ownBuffers.get(2);\n+\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = offBuffer.getReferenceManager().retain(offBuffer, allocator);\n+    valueBuffer.getReferenceManager().release();\n+    valueBuffer = dataBuffer.getReferenceManager().retain(dataBuffer, allocator);\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector.\n+   * @return the inner buffers.\n+   */\n+  public List<ArrowBuf> getFieldBuffers() {\n+    // before flight/IPC, we must bring the vector to a consistent state.\n+    // this is because, it is possible that the offset buffers of some trailing values\n+    // are not updated. this may cause some data in the data buffer being lost.\n+    // for details, please see TestValueVector#testUnloadVariableWidthVector.\n+    fillHoles(valueCount);\n+\n+    List<ArrowBuf> result = new ArrayList<>(3);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+    result.add(valueBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    valueBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+      valueBuffer.writerIndex(0);\n+    } else {\n+      final long lastDataOffset = getStartOffset(valueCount);\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((long) (valueCount + 1) * OFFSET_WIDTH);\n+      valueBuffer.writerIndex(lastDataOffset);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() {\n+    allocateNew(lastValueAllocationSizeInBytes, lastValueCapacity);\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector. See {@link #allocateNew(long, int)} for allocating memory for specific\n+   * number of elements in the vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  @Override\n+  public boolean allocateNewSafe() {\n+    try {\n+      allocateNew(lastValueAllocationSizeInBytes, lastValueCapacity);\n+      return true;\n+    } catch (Exception e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector to support storing at least the provided number of\n+   * elements in the vector. This method must be called prior to using the ValueVector.\n+   *\n+   * @param totalBytes desired total memory capacity\n+   * @param valueCount the desired number of elements in the vector\n+   * @throws org.apache.arrow.memory.OutOfMemoryException if memory allocation fails\n+   */\n+  @Override\n+  public void allocateNew(long totalBytes, int valueCount) {\n+    assert totalBytes >= 0;\n+\n+    checkDataBufferSize(totalBytes);\n+    computeAndCheckOffsetsBufferSize(valueCount);\n+\n+    /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(totalBytes, valueCount);\n+    } catch (Exception e) {\n+      clear();\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public void allocateNew(int valueCount) {\n+    allocateNew(lastValueAllocationSizeInBytes, valueCount);\n+  }\n+\n+  /* Check if the data buffer size is within bounds. */\n+  private void checkDataBufferSize(long size) {\n+    if (size > MAX_ALLOCATION_SIZE || size < 0) {\n+      throw new OversizedAllocationException(\"Memory required for vector \" +\n+          \" is (\" + size + \"), which is more than max allowed (\" + MAX_ALLOCATION_SIZE + \")\");\n+    }\n+  }\n+\n+  /*\n+   * Compute the buffer size required for 'valueCount' offsets and validity, and check if it's\n+   * within bounds.\n+   */\n+  private long computeAndCheckOffsetsBufferSize(int valueCount) {\n+    /* to track the end offset of last data element in vector, we need\n+     * an additional slot in offset buffer.\n+     */\n+    final long size = computeCombinedBufferSize(valueCount + 1, OFFSET_WIDTH);\n+    if (size > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Memory required for vector capacity \" +\n+          valueCount +\n+          \" is (\" + size + \"), which is more than max allowed (\" + MAX_ALLOCATION_SIZE + \")\");\n+    }\n+    return size;\n+  }\n+\n+  /* allocate the inner buffers */\n+  private void allocateBytes(final long valueBufferSize, final int valueCount) {\n+    /* allocate data buffer */\n+    long curSize = valueBufferSize;\n+    valueBuffer = allocator.buffer(curSize);\n+    valueBuffer.readerIndex(0);\n+\n+    /* allocate offset buffer and validity buffer */\n+    DataAndValidityBuffers buffers = allocFixedDataAndValidityBufs(valueCount + 1, OFFSET_WIDTH);\n+    offsetBuffer = buffers.getDataBuf();\n+    validityBuffer = buffers.getValidityBuf();\n+    initOffsetBuffer();\n+    initValidityBuffer();\n+\n+    lastValueCapacity = getValueCapacity();\n+    lastValueAllocationSizeInBytes = capAtMaxInt(valueBuffer.capacity());\n+  }\n+\n+  /* allocate offset buffer */\n+  private void allocateOffsetBuffer(final long size) {\n+    offsetBuffer = allocator.buffer(size);\n+    offsetBuffer.readerIndex(0);\n+    initOffsetBuffer();\n+  }\n+\n+  /* allocate validity buffer */\n+  private void allocateValidityBuffer(final long size) {\n+    validityBuffer = allocator.buffer(size);\n+    validityBuffer.readerIndex(0);\n+    initValidityBuffer();\n+  }\n+\n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  public void reAlloc() {\n+    reallocDataBuffer();\n+    reallocValidityAndOffsetBuffers();\n+  }\n+\n+  /**\n+   * Reallocate the data buffer. Data Buffer stores the actual data for\n+   * LARGEVARCHAR or LARGEVARBINARY elements in the vector. The behavior is to double\n+   * the size of buffer.\n+   * @throws OversizedAllocationException if the desired new size is more than\n+   *                                      max allowed\n+   * @throws OutOfMemoryException if the internal memory allocation fails\n+   */\n+  public void reallocDataBuffer() {\n+    final long currentBufferCapacity = valueBuffer.capacity();\n+    long newAllocationSize = currentBufferCapacity * 2;\n+    if (newAllocationSize == 0) {\n+      if (lastValueAllocationSizeInBytes > 0) {\n+        newAllocationSize = lastValueAllocationSizeInBytes;\n+      } else {\n+        newAllocationSize = INITIAL_BYTE_COUNT * 2;\n+      }\n+    }\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    checkDataBufferSize(newAllocationSize);\n+\n+    final ArrowBuf newBuf = allocator.buffer(newAllocationSize);\n+    newBuf.setBytes(0, valueBuffer, 0, currentBufferCapacity);\n+    valueBuffer.getReferenceManager().release();\n+    valueBuffer = newBuf;\n+    lastValueAllocationSizeInBytes = valueBuffer.capacity();\n+  }\n+\n+  /**\n+   * Reallocate the validity and offset buffers for this vector. Validity\n+   * buffer is used to track the NULL or NON-NULL nature of elements in\n+   * the vector and offset buffer is used to store the lengths of variable\n+   * width elements in the vector.\n+   *\n+   * <p>Note that data buffer for variable length vectors moves independent\n+   * of the companion validity and offset buffers. This is in\n+   * contrast to what we have for fixed width vectors.\n+   *\n+   * <p>So even though we may have setup an initial capacity of 1024\n+   * elements in the vector, it is quite possible\n+   * that we need to reAlloc() the data buffer when we are setting\n+   * the 5th element in the vector simply because previous\n+   * variable length elements have exhausted the buffer capacity.\n+   * However, we really don't need to reAlloc() validity and\n+   * offset buffers until we try to set the 1025th element\n+   * This is why we do a separate check for safe methods to\n+   * determine which buffer needs reallocation.\n+   * @throws OversizedAllocationException if the desired new size is more than\n+   *                                      max allowed\n+   * @throws OutOfMemoryException if the internal memory allocation fails\n+   */\n+  public void reallocValidityAndOffsetBuffers() {\n+    int targetOffsetCount = capAtMaxInt((offsetBuffer.capacity() / OFFSET_WIDTH) * 2);\n+    if (targetOffsetCount == 0) {\n+      if (lastValueCapacity > 0) {\n+        targetOffsetCount = (lastValueCapacity + 1);\n+      } else {\n+        targetOffsetCount = 2 * (INITIAL_VALUE_ALLOCATION + 1);\n+      }\n+    }\n+    computeAndCheckOffsetsBufferSize(targetOffsetCount);\n+\n+    DataAndValidityBuffers buffers = allocFixedDataAndValidityBufs(targetOffsetCount, OFFSET_WIDTH);\n+    final ArrowBuf newOffsetBuffer = buffers.getDataBuf();\n+    newOffsetBuffer.setBytes(0, offsetBuffer, 0, offsetBuffer.capacity());\n+    newOffsetBuffer.setZero(offsetBuffer.capacity(), newOffsetBuffer.capacity() - offsetBuffer.capacity());\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = newOffsetBuffer;\n+\n+    final ArrowBuf newValidityBuffer = buffers.getValidityBuf();\n+    newValidityBuffer.setBytes(0, validityBuffer, 0, validityBuffer.capacity());\n+    newValidityBuffer.setZero(validityBuffer.capacity(), newValidityBuffer.capacity() - validityBuffer.capacity());\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = newValidityBuffer;\n+\n+    lastValueCapacity = getValueCapacity();\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying data buffer.\n+   * @return number of bytes in the data buffer\n+   */\n+  @Override\n+  public int getByteCapacity() {\n+    return capAtMaxInt(valueBuffer.capacity());\n+  }\n+\n+  @Override\n+  public int sizeOfValueBuffer() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    return capAtMaxInt(offsetBuffer.getLong((long) valueCount * OFFSET_WIDTH));\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector.\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    return getBufferSizeFor(this.valueCount);\n+  }\n+\n+  /**\n+   * Get the potential buffer size for a particular number of records.\n+   * @param valueCount desired number of elements in the vector\n+   * @return estimated size of underlying buffers if the vector holds\n+   *         a given number of elements\n+   */\n+  @Override\n+  public int getBufferSizeFor(final int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+\n+    final long validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    final long offsetBufferSize = (long) (valueCount + 1) * OFFSET_WIDTH;\n+    /* get the end offset for this valueCount */\n+    final long dataBufferSize = offsetBuffer.getLong((long) valueCount * OFFSET_WIDTH);\n+    return capAtMaxInt(validityBufferSize + offsetBufferSize + dataBufferSize);\n+  }\n+\n+  /**\n+   * Get information about how this field is materialized.\n+   * @return the field corresponding to this vector\n+   */\n+  @Override\n+  public Field getField() {\n+    return field;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    final ArrowBuf[] buffers;\n+    setReaderAndWriterIndex();\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = new ArrowBuf[3];\n+      buffers[0] = validityBuffer;\n+      buffers[1] = offsetBuffer;\n+      buffers[2] = valueBuffer;\n+    }\n+    if (clear) {\n+      for (final ArrowBuf buffer : buffers) {\n+        buffer.getReferenceManager().retain();\n+      }\n+      clear();\n+    }\n+    return buffers;\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @param callBack not used\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return getTransferPair(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(BufferAllocator allocator) {\n+    return getTransferPair(getName(), allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  public abstract TransferPair getTransferPair(String ref, BufferAllocator allocator);\n+\n+  /**\n+   * Transfer this vector'data to another vector. The memory associated\n+   * with this vector is transferred to the allocator of target vector\n+   * for accounting and management purposes.\n+   * @param target destination vector for transfer\n+   */\n+  public void transferTo(BaseLargeVariableWidthVector target) {\n+    compareTypes(target, \"transferTo\");\n+    target.clear();\n+    target.validityBuffer = transferBuffer(validityBuffer, target.allocator);\n+    target.valueBuffer = transferBuffer(valueBuffer, target.allocator);\n+    target.offsetBuffer = transferBuffer(offsetBuffer, target.allocator);\n+    target.setLastSet(this.lastSet);\n+    if (this.valueCount > 0) {\n+      target.setValueCount(this.valueCount);\n+    }\n+    clear();\n+  }\n+\n+  /**\n+   * Slice this vector at desired index and length and transfer the\n+   * corresponding data to the target vector.\n+   * @param startIndex start position of the split in source vector.\n+   * @param length length of the split.\n+   * @param target destination vector\n+   */\n+  public void splitAndTransferTo(int startIndex, int length,\n+                                 BaseLargeVariableWidthVector target) {\n+    Preconditions.checkArgument(startIndex >= 0 && startIndex < valueCount,\n+        \"Invalid startIndex: %s\", startIndex);\n+    Preconditions.checkArgument(startIndex + length <= valueCount,\n+        \"Invalid length: %s\", length);\n+    compareTypes(target, \"splitAndTransferTo\");\n+    target.clear();\n+    splitAndTransferValidityBuffer(startIndex, length, target);\n+    splitAndTransferOffsetBuffer(startIndex, length, target);\n+    target.setLastSet(length - 1);\n+    if (length > 0) {\n+      target.setValueCount(length);\n+    }\n+  }\n+\n+  /**\n+   * Transfer the offsets along with data. Unlike the data buffer, we cannot simply\n+   * slice the offset buffer for split and transfer. The reason is that offsets\n+   * in the target vector have to be adjusted and made relative to the staring\n+   * offset in source vector from the start index of split. This is why, we\n+   * need to explicitly allocate the offset buffer and set the adjusted offsets\n+   * in the target vector.\n+   */\n+  private void splitAndTransferOffsetBuffer(int startIndex, int length, BaseLargeVariableWidthVector target) {\n+    final long start = offsetBuffer.getLong((long) startIndex * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((long) (startIndex + length) * OFFSET_WIDTH);\n+    final long dataLength = end - start;\n+    target.allocateOffsetBuffer((long) (length + 1) * OFFSET_WIDTH);\n+    for (int i = 0; i < length + 1; i++) {\n+      final long relativeSourceOffset = offsetBuffer.getLong((long) (startIndex + i) * OFFSET_WIDTH) - start;\n+      target.offsetBuffer.setLong((long) i * OFFSET_WIDTH, relativeSourceOffset);\n+    }\n+    final ArrowBuf slicedBuffer = valueBuffer.slice(start, dataLength);\n+    target.valueBuffer = transferBuffer(slicedBuffer, target.allocator);\n+  }\n+\n+  /*\n+   * Transfer the validity.\n+   */\n+  private void splitAndTransferValidityBuffer(int startIndex, int length,\n+                                              BaseLargeVariableWidthVector target) {\n+    int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+    int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+    int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+    int offset = startIndex % 8;\n+\n+    if (length > 0) {\n+      if (offset == 0) {\n+        // slice\n+        if (target.validityBuffer != null) {\n+          target.validityBuffer.getReferenceManager().release();\n+        }\n+        target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+        target.validityBuffer.getReferenceManager().retain();\n+      } else {\n+        /* Copy data\n+         * When the first bit starts from the middle of a byte (offset != 0),\n+         * copy data from src BitVector.\n+         * Each byte in the target is composed by a part in i-th byte,\n+         * another part in (i+1)-th byte.\n+         */\n+        target.allocateValidityBuffer(byteSizeTarget);\n+\n+        for (int i = 0; i < byteSizeTarget - 1; i++) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer, firstByteSource + i, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer, firstByteSource + i + 1, offset);\n+\n+          target.validityBuffer.setByte(i, (b1 + b2));\n+        }\n+        /* Copying the last piece is done in the following manner:\n+         * if the source vector has 1 or more bytes remaining, we copy\n+         * the last piece as a byte formed by shifting data\n+         * from the current byte and the next byte.\n+         *\n+         * if the source vector has no more bytes remaining\n+         * (we are at the last byte), we copy the last piece as a byte\n+         * by shifting data from the current byte.\n+         */\n+        if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+              firstByteSource + byteSizeTarget - 1, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer,\n+              firstByteSource + byteSizeTarget, offset);\n+\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+        } else {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+              firstByteSource + byteSizeTarget - 1, offset);\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+        }\n+      }\n+    }\n+  }\n+\n+\n+  /*----------------------------------------------------------------*\n+   |                                                                |\n+   |                common getters and setters                      |\n+   |                                                                |\n+   *----------------------------------------------------------------*/\n+\n+\n+  /**\n+   * Get the number of elements that are null in the vector.\n+   *\n+   * @return the number of null elements.\n+   */\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  /**\n+   * Check if the given index is within the current value capacity\n+   * of the vector.\n+   *\n+   * @param index  position to check\n+   * @return true if index is within the current value capacity\n+   */\n+  public boolean isSafe(int index) {\n \n Review comment:\n   shouldn't this be long?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-12T05:41:39.776+0000",
                    "updated": "2020-03-12T05:41:39.776+0000",
                    "started": "2020-03-12T05:41:39.776+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "401967",
                    "issueId": "13248477"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/worklog/401968",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "siddharthteotia commented on pull request #6425: ARROW-6111: [Java] Support LargeVarChar and LargeBinary types\nURL: https://github.com/apache/arrow/pull/6425#discussion_r391411462\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseLargeVariableWidthVector.java\n ##########\n @@ -0,0 +1,1361 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+/**\n+ * BaseLargeVariableWidthVector is a base class providing functionality for large strings/large bytes types.\n+ */\n+public abstract class BaseLargeVariableWidthVector extends BaseValueVector\n+    implements VariableWidthVector, FieldVector, VectorDefinitionSetter {\n+  private static final int DEFAULT_RECORD_BYTE_COUNT = 12;\n+  private static final int INITIAL_BYTE_COUNT = INITIAL_VALUE_ALLOCATION * DEFAULT_RECORD_BYTE_COUNT;\n+  private int lastValueCapacity;\n+  private long lastValueAllocationSizeInBytes;\n+\n+  /* protected members */\n+  public static final int OFFSET_WIDTH = 8; /* 8 byte unsigned int to track offsets */\n+  protected static final byte[] emptyByteArray = new byte[]{};\n+  protected ArrowBuf validityBuffer;\n+  protected ArrowBuf valueBuffer;\n+  protected ArrowBuf offsetBuffer;\n+  protected int valueCount;\n+  protected int lastSet;\n+  protected final Field field;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param field The field materialized by this vector.\n+   * @param allocator The allocator to use for creating/resizing buffers\n+   */\n+  public BaseLargeVariableWidthVector(Field field, final BufferAllocator allocator) {\n+    super(allocator);\n+    this.field = field;\n+    lastValueAllocationSizeInBytes = INITIAL_BYTE_COUNT;\n+    // -1 because we require one extra slot for the offset array.\n+    lastValueCapacity = INITIAL_VALUE_ALLOCATION - 1;\n+    valueCount = 0;\n+    lastSet = -1;\n+    offsetBuffer = allocator.getEmpty();\n+    validityBuffer = allocator.getEmpty();\n+    valueBuffer = allocator.getEmpty();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return field.getName();\n+  }\n+\n+  /**\n+   * Get buffer that manages the validity (NULL or NON-NULL nature) of\n+   * elements in the vector. Consider it as a buffer for internal bit vector\n+   * data structure.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  /**\n+   * Get the buffer that stores the data for elements in the vector.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    return valueBuffer;\n+  }\n+\n+  /**\n+   * buffer that stores the offsets for elements\n+   * in the vector. This operation is not supported for fixed-width vectors.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the offsets for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return offsetBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that manages the validity\n+   * (NULL or NON-NULL nature) of elements in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return validityBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the data for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getDataBufferAddress() {\n+    return valueBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   * @param valueCount desired number of elements in the vector\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount) {\n+    final long size = (long) valueCount * DEFAULT_RECORD_BYTE_COUNT;\n+    checkDataBufferSize(size);\n+    computeAndCheckOffsetsBufferSize(valueCount);\n+    lastValueAllocationSizeInBytes = size;\n+    lastValueCapacity = valueCount;\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   * @param valueCount desired number of elements in the vector\n+   * @param density average number of bytes per variable width element\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount, double density) {\n+    long size = Math.max((long)(valueCount * density), 1L);\n+    checkDataBufferSize(size);\n+    computeAndCheckOffsetsBufferSize(valueCount);\n+    lastValueAllocationSizeInBytes = size;\n+    lastValueCapacity = valueCount;\n+  }\n+\n+  /**\n+   * Get the density of this ListVector.\n+   * @return density\n+   */\n+  public double getDensity() {\n+    if (valueCount == 0) {\n+      return 0.0D;\n+    }\n+    final long startOffset = offsetBuffer.getLong(0);\n+    final long endOffset = offsetBuffer.getLong((long) valueCount * OFFSET_WIDTH);\n+    final double totalListSize = endOffset - startOffset;\n+    return totalListSize / valueCount;\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector.\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    final long offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n+    return capAtMaxInt(Math.min(offsetValueCapacity, getValidityBufferValueCapacity()));\n+  }\n+\n+  private long getValidityBufferValueCapacity() {\n+    return validityBuffer.capacity() * 8;\n+  }\n+\n+  private long getOffsetBufferValueCapacity() {\n+    return offsetBuffer.capacity() / OFFSET_WIDTH;\n+  }\n+\n+  /**\n+   * zero out the vector and the data in associated buffers.\n+   */\n+  public void zeroVector() {\n+    initValidityBuffer();\n+    initOffsetBuffer();\n+    valueBuffer.setZero(0, valueBuffer.capacity());\n+  }\n+\n+  /* zero out the validity buffer */\n+  private void initValidityBuffer() {\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+\n+  /* zero out the offset buffer */\n+  private void initOffsetBuffer() {\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+\n+  /**\n+   * Reset the vector to initial state. Same as {@link #zeroVector()}.\n+   * Note that this method doesn't release any memory.\n+   */\n+  public void reset() {\n+    zeroVector();\n+    lastSet = -1;\n+    valueCount = 0;\n+  }\n+\n+  /**\n+   * Close the vector and release the associated buffers.\n+   */\n+  @Override\n+  public void close() {\n+    clear();\n+  }\n+\n+  /**\n+   * Same as {@link #close()}.\n+   */\n+  @Override\n+  public void clear() {\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    valueBuffer = releaseBuffer(valueBuffer);\n+    offsetBuffer = releaseBuffer(offsetBuffer);\n+    lastSet = -1;\n+    valueCount = 0;\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Initialize the children in schema for this Field. This operation is a\n+   * NO-OP for scalar types since they don't have any children.\n+   * @param children the schema\n+   * @throws IllegalArgumentException if children is a non-empty list for scalar types.\n+   */\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (!children.isEmpty()) {\n+      throw new IllegalArgumentException(\"primitive type vector can not have children\");\n+    }\n+  }\n+\n+  /**\n+   * Get the inner child vectors.\n+   * @return list of child vectors for complex types, empty list for scalar vector types\n+   */\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return Collections.emptyList();\n+  }\n+\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+    ArrowBuf dataBuffer = ownBuffers.get(2);\n+\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = offBuffer.getReferenceManager().retain(offBuffer, allocator);\n+    valueBuffer.getReferenceManager().release();\n+    valueBuffer = dataBuffer.getReferenceManager().retain(dataBuffer, allocator);\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector.\n+   * @return the inner buffers.\n+   */\n+  public List<ArrowBuf> getFieldBuffers() {\n+    // before flight/IPC, we must bring the vector to a consistent state.\n+    // this is because, it is possible that the offset buffers of some trailing values\n+    // are not updated. this may cause some data in the data buffer being lost.\n+    // for details, please see TestValueVector#testUnloadVariableWidthVector.\n+    fillHoles(valueCount);\n+\n+    List<ArrowBuf> result = new ArrayList<>(3);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+    result.add(valueBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    valueBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+      valueBuffer.writerIndex(0);\n+    } else {\n+      final long lastDataOffset = getStartOffset(valueCount);\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((long) (valueCount + 1) * OFFSET_WIDTH);\n+      valueBuffer.writerIndex(lastDataOffset);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() {\n+    allocateNew(lastValueAllocationSizeInBytes, lastValueCapacity);\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector. See {@link #allocateNew(long, int)} for allocating memory for specific\n+   * number of elements in the vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  @Override\n+  public boolean allocateNewSafe() {\n+    try {\n+      allocateNew(lastValueAllocationSizeInBytes, lastValueCapacity);\n+      return true;\n+    } catch (Exception e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector to support storing at least the provided number of\n+   * elements in the vector. This method must be called prior to using the ValueVector.\n+   *\n+   * @param totalBytes desired total memory capacity\n+   * @param valueCount the desired number of elements in the vector\n+   * @throws org.apache.arrow.memory.OutOfMemoryException if memory allocation fails\n+   */\n+  @Override\n+  public void allocateNew(long totalBytes, int valueCount) {\n+    assert totalBytes >= 0;\n+\n+    checkDataBufferSize(totalBytes);\n+    computeAndCheckOffsetsBufferSize(valueCount);\n+\n+    /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(totalBytes, valueCount);\n+    } catch (Exception e) {\n+      clear();\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public void allocateNew(int valueCount) {\n+    allocateNew(lastValueAllocationSizeInBytes, valueCount);\n+  }\n+\n+  /* Check if the data buffer size is within bounds. */\n+  private void checkDataBufferSize(long size) {\n+    if (size > MAX_ALLOCATION_SIZE || size < 0) {\n+      throw new OversizedAllocationException(\"Memory required for vector \" +\n+          \" is (\" + size + \"), which is more than max allowed (\" + MAX_ALLOCATION_SIZE + \")\");\n+    }\n+  }\n+\n+  /*\n+   * Compute the buffer size required for 'valueCount' offsets and validity, and check if it's\n+   * within bounds.\n+   */\n+  private long computeAndCheckOffsetsBufferSize(int valueCount) {\n+    /* to track the end offset of last data element in vector, we need\n+     * an additional slot in offset buffer.\n+     */\n+    final long size = computeCombinedBufferSize(valueCount + 1, OFFSET_WIDTH);\n+    if (size > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Memory required for vector capacity \" +\n+          valueCount +\n+          \" is (\" + size + \"), which is more than max allowed (\" + MAX_ALLOCATION_SIZE + \")\");\n+    }\n+    return size;\n+  }\n+\n+  /* allocate the inner buffers */\n+  private void allocateBytes(final long valueBufferSize, final int valueCount) {\n+    /* allocate data buffer */\n+    long curSize = valueBufferSize;\n+    valueBuffer = allocator.buffer(curSize);\n+    valueBuffer.readerIndex(0);\n+\n+    /* allocate offset buffer and validity buffer */\n+    DataAndValidityBuffers buffers = allocFixedDataAndValidityBufs(valueCount + 1, OFFSET_WIDTH);\n+    offsetBuffer = buffers.getDataBuf();\n+    validityBuffer = buffers.getValidityBuf();\n+    initOffsetBuffer();\n+    initValidityBuffer();\n+\n+    lastValueCapacity = getValueCapacity();\n+    lastValueAllocationSizeInBytes = capAtMaxInt(valueBuffer.capacity());\n+  }\n+\n+  /* allocate offset buffer */\n+  private void allocateOffsetBuffer(final long size) {\n+    offsetBuffer = allocator.buffer(size);\n+    offsetBuffer.readerIndex(0);\n+    initOffsetBuffer();\n+  }\n+\n+  /* allocate validity buffer */\n+  private void allocateValidityBuffer(final long size) {\n+    validityBuffer = allocator.buffer(size);\n+    validityBuffer.readerIndex(0);\n+    initValidityBuffer();\n+  }\n+\n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  public void reAlloc() {\n+    reallocDataBuffer();\n+    reallocValidityAndOffsetBuffers();\n+  }\n+\n+  /**\n+   * Reallocate the data buffer. Data Buffer stores the actual data for\n+   * LARGEVARCHAR or LARGEVARBINARY elements in the vector. The behavior is to double\n+   * the size of buffer.\n+   * @throws OversizedAllocationException if the desired new size is more than\n+   *                                      max allowed\n+   * @throws OutOfMemoryException if the internal memory allocation fails\n+   */\n+  public void reallocDataBuffer() {\n+    final long currentBufferCapacity = valueBuffer.capacity();\n+    long newAllocationSize = currentBufferCapacity * 2;\n+    if (newAllocationSize == 0) {\n+      if (lastValueAllocationSizeInBytes > 0) {\n+        newAllocationSize = lastValueAllocationSizeInBytes;\n+      } else {\n+        newAllocationSize = INITIAL_BYTE_COUNT * 2;\n+      }\n+    }\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    checkDataBufferSize(newAllocationSize);\n+\n+    final ArrowBuf newBuf = allocator.buffer(newAllocationSize);\n+    newBuf.setBytes(0, valueBuffer, 0, currentBufferCapacity);\n+    valueBuffer.getReferenceManager().release();\n+    valueBuffer = newBuf;\n+    lastValueAllocationSizeInBytes = valueBuffer.capacity();\n+  }\n+\n+  /**\n+   * Reallocate the validity and offset buffers for this vector. Validity\n+   * buffer is used to track the NULL or NON-NULL nature of elements in\n+   * the vector and offset buffer is used to store the lengths of variable\n+   * width elements in the vector.\n+   *\n+   * <p>Note that data buffer for variable length vectors moves independent\n+   * of the companion validity and offset buffers. This is in\n+   * contrast to what we have for fixed width vectors.\n+   *\n+   * <p>So even though we may have setup an initial capacity of 1024\n+   * elements in the vector, it is quite possible\n+   * that we need to reAlloc() the data buffer when we are setting\n+   * the 5th element in the vector simply because previous\n+   * variable length elements have exhausted the buffer capacity.\n+   * However, we really don't need to reAlloc() validity and\n+   * offset buffers until we try to set the 1025th element\n+   * This is why we do a separate check for safe methods to\n+   * determine which buffer needs reallocation.\n+   * @throws OversizedAllocationException if the desired new size is more than\n+   *                                      max allowed\n+   * @throws OutOfMemoryException if the internal memory allocation fails\n+   */\n+  public void reallocValidityAndOffsetBuffers() {\n+    int targetOffsetCount = capAtMaxInt((offsetBuffer.capacity() / OFFSET_WIDTH) * 2);\n+    if (targetOffsetCount == 0) {\n+      if (lastValueCapacity > 0) {\n+        targetOffsetCount = (lastValueCapacity + 1);\n+      } else {\n+        targetOffsetCount = 2 * (INITIAL_VALUE_ALLOCATION + 1);\n+      }\n+    }\n+    computeAndCheckOffsetsBufferSize(targetOffsetCount);\n+\n+    DataAndValidityBuffers buffers = allocFixedDataAndValidityBufs(targetOffsetCount, OFFSET_WIDTH);\n+    final ArrowBuf newOffsetBuffer = buffers.getDataBuf();\n+    newOffsetBuffer.setBytes(0, offsetBuffer, 0, offsetBuffer.capacity());\n+    newOffsetBuffer.setZero(offsetBuffer.capacity(), newOffsetBuffer.capacity() - offsetBuffer.capacity());\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = newOffsetBuffer;\n+\n+    final ArrowBuf newValidityBuffer = buffers.getValidityBuf();\n+    newValidityBuffer.setBytes(0, validityBuffer, 0, validityBuffer.capacity());\n+    newValidityBuffer.setZero(validityBuffer.capacity(), newValidityBuffer.capacity() - validityBuffer.capacity());\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = newValidityBuffer;\n+\n+    lastValueCapacity = getValueCapacity();\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying data buffer.\n+   * @return number of bytes in the data buffer\n+   */\n+  @Override\n+  public int getByteCapacity() {\n+    return capAtMaxInt(valueBuffer.capacity());\n+  }\n+\n+  @Override\n+  public int sizeOfValueBuffer() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    return capAtMaxInt(offsetBuffer.getLong((long) valueCount * OFFSET_WIDTH));\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector.\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    return getBufferSizeFor(this.valueCount);\n+  }\n+\n+  /**\n+   * Get the potential buffer size for a particular number of records.\n+   * @param valueCount desired number of elements in the vector\n+   * @return estimated size of underlying buffers if the vector holds\n+   *         a given number of elements\n+   */\n+  @Override\n+  public int getBufferSizeFor(final int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+\n+    final long validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    final long offsetBufferSize = (long) (valueCount + 1) * OFFSET_WIDTH;\n+    /* get the end offset for this valueCount */\n+    final long dataBufferSize = offsetBuffer.getLong((long) valueCount * OFFSET_WIDTH);\n+    return capAtMaxInt(validityBufferSize + offsetBufferSize + dataBufferSize);\n+  }\n+\n+  /**\n+   * Get information about how this field is materialized.\n+   * @return the field corresponding to this vector\n+   */\n+  @Override\n+  public Field getField() {\n+    return field;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    final ArrowBuf[] buffers;\n+    setReaderAndWriterIndex();\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = new ArrowBuf[3];\n+      buffers[0] = validityBuffer;\n+      buffers[1] = offsetBuffer;\n+      buffers[2] = valueBuffer;\n+    }\n+    if (clear) {\n+      for (final ArrowBuf buffer : buffers) {\n+        buffer.getReferenceManager().retain();\n+      }\n+      clear();\n+    }\n+    return buffers;\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @param callBack not used\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return getTransferPair(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(BufferAllocator allocator) {\n+    return getTransferPair(getName(), allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  public abstract TransferPair getTransferPair(String ref, BufferAllocator allocator);\n+\n+  /**\n+   * Transfer this vector'data to another vector. The memory associated\n+   * with this vector is transferred to the allocator of target vector\n+   * for accounting and management purposes.\n+   * @param target destination vector for transfer\n+   */\n+  public void transferTo(BaseLargeVariableWidthVector target) {\n+    compareTypes(target, \"transferTo\");\n+    target.clear();\n+    target.validityBuffer = transferBuffer(validityBuffer, target.allocator);\n+    target.valueBuffer = transferBuffer(valueBuffer, target.allocator);\n+    target.offsetBuffer = transferBuffer(offsetBuffer, target.allocator);\n+    target.setLastSet(this.lastSet);\n+    if (this.valueCount > 0) {\n+      target.setValueCount(this.valueCount);\n+    }\n+    clear();\n+  }\n+\n+  /**\n+   * Slice this vector at desired index and length and transfer the\n+   * corresponding data to the target vector.\n+   * @param startIndex start position of the split in source vector.\n+   * @param length length of the split.\n+   * @param target destination vector\n+   */\n+  public void splitAndTransferTo(int startIndex, int length,\n+                                 BaseLargeVariableWidthVector target) {\n+    Preconditions.checkArgument(startIndex >= 0 && startIndex < valueCount,\n+        \"Invalid startIndex: %s\", startIndex);\n+    Preconditions.checkArgument(startIndex + length <= valueCount,\n+        \"Invalid length: %s\", length);\n+    compareTypes(target, \"splitAndTransferTo\");\n+    target.clear();\n+    splitAndTransferValidityBuffer(startIndex, length, target);\n+    splitAndTransferOffsetBuffer(startIndex, length, target);\n+    target.setLastSet(length - 1);\n+    if (length > 0) {\n+      target.setValueCount(length);\n+    }\n+  }\n+\n+  /**\n+   * Transfer the offsets along with data. Unlike the data buffer, we cannot simply\n+   * slice the offset buffer for split and transfer. The reason is that offsets\n+   * in the target vector have to be adjusted and made relative to the staring\n+   * offset in source vector from the start index of split. This is why, we\n+   * need to explicitly allocate the offset buffer and set the adjusted offsets\n+   * in the target vector.\n+   */\n+  private void splitAndTransferOffsetBuffer(int startIndex, int length, BaseLargeVariableWidthVector target) {\n+    final long start = offsetBuffer.getLong((long) startIndex * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((long) (startIndex + length) * OFFSET_WIDTH);\n+    final long dataLength = end - start;\n+    target.allocateOffsetBuffer((long) (length + 1) * OFFSET_WIDTH);\n+    for (int i = 0; i < length + 1; i++) {\n+      final long relativeSourceOffset = offsetBuffer.getLong((long) (startIndex + i) * OFFSET_WIDTH) - start;\n+      target.offsetBuffer.setLong((long) i * OFFSET_WIDTH, relativeSourceOffset);\n+    }\n+    final ArrowBuf slicedBuffer = valueBuffer.slice(start, dataLength);\n+    target.valueBuffer = transferBuffer(slicedBuffer, target.allocator);\n+  }\n+\n+  /*\n+   * Transfer the validity.\n+   */\n+  private void splitAndTransferValidityBuffer(int startIndex, int length,\n+                                              BaseLargeVariableWidthVector target) {\n+    int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+    int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+    int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+    int offset = startIndex % 8;\n+\n+    if (length > 0) {\n+      if (offset == 0) {\n+        // slice\n+        if (target.validityBuffer != null) {\n+          target.validityBuffer.getReferenceManager().release();\n+        }\n+        target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+        target.validityBuffer.getReferenceManager().retain();\n+      } else {\n+        /* Copy data\n+         * When the first bit starts from the middle of a byte (offset != 0),\n+         * copy data from src BitVector.\n+         * Each byte in the target is composed by a part in i-th byte,\n+         * another part in (i+1)-th byte.\n+         */\n+        target.allocateValidityBuffer(byteSizeTarget);\n+\n+        for (int i = 0; i < byteSizeTarget - 1; i++) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer, firstByteSource + i, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer, firstByteSource + i + 1, offset);\n+\n+          target.validityBuffer.setByte(i, (b1 + b2));\n+        }\n+        /* Copying the last piece is done in the following manner:\n+         * if the source vector has 1 or more bytes remaining, we copy\n+         * the last piece as a byte formed by shifting data\n+         * from the current byte and the next byte.\n+         *\n+         * if the source vector has no more bytes remaining\n+         * (we are at the last byte), we copy the last piece as a byte\n+         * by shifting data from the current byte.\n+         */\n+        if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+              firstByteSource + byteSizeTarget - 1, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer,\n+              firstByteSource + byteSizeTarget, offset);\n+\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+        } else {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+              firstByteSource + byteSizeTarget - 1, offset);\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+        }\n+      }\n+    }\n+  }\n+\n+\n+  /*----------------------------------------------------------------*\n+   |                                                                |\n+   |                common getters and setters                      |\n+   |                                                                |\n+   *----------------------------------------------------------------*/\n+\n+\n+  /**\n+   * Get the number of elements that are null in the vector.\n+   *\n+   * @return the number of null elements.\n+   */\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  /**\n+   * Check if the given index is within the current value capacity\n+   * of the vector.\n+   *\n+   * @param index  position to check\n+   * @return true if index is within the current value capacity\n+   */\n+  public boolean isSafe(int index) {\n \n Review comment:\n   My bad -- It's the offset that has to be long, not this index since this is for the number of values.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-12T05:42:34.495+0000",
                    "updated": "2020-03-12T05:42:34.495+0000",
                    "started": "2020-03-12T05:42:34.495+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "401968",
                    "issueId": "13248477"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/worklog/401970",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "siddharthteotia commented on pull request #6425: ARROW-6111: [Java] Support LargeVarChar and LargeBinary types\nURL: https://github.com/apache/arrow/pull/6425#discussion_r391411895\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseLargeVariableWidthVector.java\n ##########\n @@ -0,0 +1,1361 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+/**\n+ * BaseLargeVariableWidthVector is a base class providing functionality for large strings/large bytes types.\n+ */\n+public abstract class BaseLargeVariableWidthVector extends BaseValueVector\n \n Review comment:\n   Does it make sense for this to extend BaseVariableWidthVector?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-12T05:44:28.281+0000",
                    "updated": "2020-03-12T05:44:28.281+0000",
                    "started": "2020-03-12T05:44:28.281+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "401970",
                    "issueId": "13248477"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/worklog/401971",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "siddharthteotia commented on pull request #6425: ARROW-6111: [Java] Support LargeVarChar and LargeBinary types\nURL: https://github.com/apache/arrow/pull/6425#discussion_r391412172\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseLargeVariableWidthVector.java\n ##########\n @@ -0,0 +1,1361 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+/**\n+ * BaseLargeVariableWidthVector is a base class providing functionality for large strings/large bytes types.\n+ */\n+public abstract class BaseLargeVariableWidthVector extends BaseValueVector\n \n Review comment:\n   We might be able to reuse quite some functionality. However, generally in Arrow we have been okay with some code duplication to avoid the performance overhead of having a deep inheritance hierarchy. So may be the current approach is fine. Just wondering if we evaluated this.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-12T05:45:47.113+0000",
                    "updated": "2020-03-12T05:45:47.113+0000",
                    "started": "2020-03-12T05:45:47.113+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "401971",
                    "issueId": "13248477"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/worklog/402011",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on pull request #6425: ARROW-6111: [Java] Support LargeVarChar and LargeBinary types\nURL: https://github.com/apache/arrow/pull/6425#discussion_r391444002\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseLargeVariableWidthVector.java\n ##########\n @@ -0,0 +1,1361 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+/**\n+ * BaseLargeVariableWidthVector is a base class providing functionality for large strings/large bytes types.\n+ */\n+public abstract class BaseLargeVariableWidthVector extends BaseValueVector\n+    implements VariableWidthVector, FieldVector, VectorDefinitionSetter {\n+  private static final int DEFAULT_RECORD_BYTE_COUNT = 12;\n+  private static final int INITIAL_BYTE_COUNT = INITIAL_VALUE_ALLOCATION * DEFAULT_RECORD_BYTE_COUNT;\n+  private int lastValueCapacity;\n+  private long lastValueAllocationSizeInBytes;\n+\n+  /* protected members */\n+  public static final int OFFSET_WIDTH = 8; /* 8 byte unsigned int to track offsets */\n+  protected static final byte[] emptyByteArray = new byte[]{};\n+  protected ArrowBuf validityBuffer;\n+  protected ArrowBuf valueBuffer;\n+  protected ArrowBuf offsetBuffer;\n+  protected int valueCount;\n+  protected int lastSet;\n+  protected final Field field;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param field The field materialized by this vector.\n+   * @param allocator The allocator to use for creating/resizing buffers\n+   */\n+  public BaseLargeVariableWidthVector(Field field, final BufferAllocator allocator) {\n+    super(allocator);\n+    this.field = field;\n+    lastValueAllocationSizeInBytes = INITIAL_BYTE_COUNT;\n+    // -1 because we require one extra slot for the offset array.\n+    lastValueCapacity = INITIAL_VALUE_ALLOCATION - 1;\n+    valueCount = 0;\n+    lastSet = -1;\n+    offsetBuffer = allocator.getEmpty();\n+    validityBuffer = allocator.getEmpty();\n+    valueBuffer = allocator.getEmpty();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return field.getName();\n+  }\n+\n+  /**\n+   * Get buffer that manages the validity (NULL or NON-NULL nature) of\n+   * elements in the vector. Consider it as a buffer for internal bit vector\n+   * data structure.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  /**\n+   * Get the buffer that stores the data for elements in the vector.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    return valueBuffer;\n+  }\n+\n+  /**\n+   * buffer that stores the offsets for elements\n+   * in the vector. This operation is not supported for fixed-width vectors.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the offsets for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return offsetBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that manages the validity\n+   * (NULL or NON-NULL nature) of elements in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return validityBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the data for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getDataBufferAddress() {\n+    return valueBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   * @param valueCount desired number of elements in the vector\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount) {\n+    final long size = (long) valueCount * DEFAULT_RECORD_BYTE_COUNT;\n+    checkDataBufferSize(size);\n+    computeAndCheckOffsetsBufferSize(valueCount);\n+    lastValueAllocationSizeInBytes = size;\n+    lastValueCapacity = valueCount;\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   * @param valueCount desired number of elements in the vector\n+   * @param density average number of bytes per variable width element\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount, double density) {\n+    long size = Math.max((long)(valueCount * density), 1L);\n+    checkDataBufferSize(size);\n+    computeAndCheckOffsetsBufferSize(valueCount);\n+    lastValueAllocationSizeInBytes = size;\n+    lastValueCapacity = valueCount;\n+  }\n+\n+  /**\n+   * Get the density of this ListVector.\n+   * @return density\n+   */\n+  public double getDensity() {\n+    if (valueCount == 0) {\n+      return 0.0D;\n+    }\n+    final long startOffset = offsetBuffer.getLong(0);\n+    final long endOffset = offsetBuffer.getLong((long) valueCount * OFFSET_WIDTH);\n+    final double totalListSize = endOffset - startOffset;\n+    return totalListSize / valueCount;\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector.\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    final long offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n+    return capAtMaxInt(Math.min(offsetValueCapacity, getValidityBufferValueCapacity()));\n+  }\n+\n+  private long getValidityBufferValueCapacity() {\n+    return validityBuffer.capacity() * 8;\n+  }\n+\n+  private long getOffsetBufferValueCapacity() {\n+    return offsetBuffer.capacity() / OFFSET_WIDTH;\n+  }\n+\n+  /**\n+   * zero out the vector and the data in associated buffers.\n+   */\n+  public void zeroVector() {\n+    initValidityBuffer();\n+    initOffsetBuffer();\n+    valueBuffer.setZero(0, valueBuffer.capacity());\n+  }\n+\n+  /* zero out the validity buffer */\n+  private void initValidityBuffer() {\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+\n+  /* zero out the offset buffer */\n+  private void initOffsetBuffer() {\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+\n+  /**\n+   * Reset the vector to initial state. Same as {@link #zeroVector()}.\n+   * Note that this method doesn't release any memory.\n+   */\n+  public void reset() {\n+    zeroVector();\n+    lastSet = -1;\n+    valueCount = 0;\n+  }\n+\n+  /**\n+   * Close the vector and release the associated buffers.\n+   */\n+  @Override\n+  public void close() {\n+    clear();\n+  }\n+\n+  /**\n+   * Same as {@link #close()}.\n+   */\n+  @Override\n+  public void clear() {\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    valueBuffer = releaseBuffer(valueBuffer);\n+    offsetBuffer = releaseBuffer(offsetBuffer);\n+    lastSet = -1;\n+    valueCount = 0;\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Initialize the children in schema for this Field. This operation is a\n+   * NO-OP for scalar types since they don't have any children.\n+   * @param children the schema\n+   * @throws IllegalArgumentException if children is a non-empty list for scalar types.\n+   */\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (!children.isEmpty()) {\n+      throw new IllegalArgumentException(\"primitive type vector can not have children\");\n+    }\n+  }\n+\n+  /**\n+   * Get the inner child vectors.\n+   * @return list of child vectors for complex types, empty list for scalar vector types\n+   */\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return Collections.emptyList();\n+  }\n+\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+    ArrowBuf dataBuffer = ownBuffers.get(2);\n+\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = offBuffer.getReferenceManager().retain(offBuffer, allocator);\n+    valueBuffer.getReferenceManager().release();\n+    valueBuffer = dataBuffer.getReferenceManager().retain(dataBuffer, allocator);\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector.\n+   * @return the inner buffers.\n+   */\n+  public List<ArrowBuf> getFieldBuffers() {\n+    // before flight/IPC, we must bring the vector to a consistent state.\n+    // this is because, it is possible that the offset buffers of some trailing values\n+    // are not updated. this may cause some data in the data buffer being lost.\n+    // for details, please see TestValueVector#testUnloadVariableWidthVector.\n+    fillHoles(valueCount);\n+\n+    List<ArrowBuf> result = new ArrayList<>(3);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+    result.add(valueBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    valueBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+      valueBuffer.writerIndex(0);\n+    } else {\n+      final long lastDataOffset = getStartOffset(valueCount);\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((long) (valueCount + 1) * OFFSET_WIDTH);\n+      valueBuffer.writerIndex(lastDataOffset);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() {\n+    allocateNew(lastValueAllocationSizeInBytes, lastValueCapacity);\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector. See {@link #allocateNew(long, int)} for allocating memory for specific\n+   * number of elements in the vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  @Override\n+  public boolean allocateNewSafe() {\n+    try {\n+      allocateNew(lastValueAllocationSizeInBytes, lastValueCapacity);\n+      return true;\n+    } catch (Exception e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector to support storing at least the provided number of\n+   * elements in the vector. This method must be called prior to using the ValueVector.\n+   *\n+   * @param totalBytes desired total memory capacity\n+   * @param valueCount the desired number of elements in the vector\n+   * @throws org.apache.arrow.memory.OutOfMemoryException if memory allocation fails\n+   */\n+  @Override\n+  public void allocateNew(long totalBytes, int valueCount) {\n+    assert totalBytes >= 0;\n+\n+    checkDataBufferSize(totalBytes);\n+    computeAndCheckOffsetsBufferSize(valueCount);\n+\n+    /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(totalBytes, valueCount);\n+    } catch (Exception e) {\n+      clear();\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public void allocateNew(int valueCount) {\n+    allocateNew(lastValueAllocationSizeInBytes, valueCount);\n+  }\n+\n+  /* Check if the data buffer size is within bounds. */\n+  private void checkDataBufferSize(long size) {\n+    if (size > MAX_ALLOCATION_SIZE || size < 0) {\n+      throw new OversizedAllocationException(\"Memory required for vector \" +\n+          \" is (\" + size + \"), which is more than max allowed (\" + MAX_ALLOCATION_SIZE + \")\");\n+    }\n+  }\n+\n+  /*\n+   * Compute the buffer size required for 'valueCount' offsets and validity, and check if it's\n+   * within bounds.\n+   */\n+  private long computeAndCheckOffsetsBufferSize(int valueCount) {\n+    /* to track the end offset of last data element in vector, we need\n+     * an additional slot in offset buffer.\n+     */\n+    final long size = computeCombinedBufferSize(valueCount + 1, OFFSET_WIDTH);\n+    if (size > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Memory required for vector capacity \" +\n+          valueCount +\n+          \" is (\" + size + \"), which is more than max allowed (\" + MAX_ALLOCATION_SIZE + \")\");\n+    }\n+    return size;\n+  }\n+\n+  /* allocate the inner buffers */\n+  private void allocateBytes(final long valueBufferSize, final int valueCount) {\n+    /* allocate data buffer */\n+    long curSize = valueBufferSize;\n+    valueBuffer = allocator.buffer(curSize);\n+    valueBuffer.readerIndex(0);\n+\n+    /* allocate offset buffer and validity buffer */\n+    DataAndValidityBuffers buffers = allocFixedDataAndValidityBufs(valueCount + 1, OFFSET_WIDTH);\n+    offsetBuffer = buffers.getDataBuf();\n+    validityBuffer = buffers.getValidityBuf();\n+    initOffsetBuffer();\n+    initValidityBuffer();\n+\n+    lastValueCapacity = getValueCapacity();\n+    lastValueAllocationSizeInBytes = capAtMaxInt(valueBuffer.capacity());\n+  }\n+\n+  /* allocate offset buffer */\n+  private void allocateOffsetBuffer(final long size) {\n+    offsetBuffer = allocator.buffer(size);\n+    offsetBuffer.readerIndex(0);\n+    initOffsetBuffer();\n+  }\n+\n+  /* allocate validity buffer */\n+  private void allocateValidityBuffer(final long size) {\n+    validityBuffer = allocator.buffer(size);\n+    validityBuffer.readerIndex(0);\n+    initValidityBuffer();\n+  }\n+\n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  public void reAlloc() {\n+    reallocDataBuffer();\n+    reallocValidityAndOffsetBuffers();\n+  }\n+\n+  /**\n+   * Reallocate the data buffer. Data Buffer stores the actual data for\n+   * LARGEVARCHAR or LARGEVARBINARY elements in the vector. The behavior is to double\n+   * the size of buffer.\n+   * @throws OversizedAllocationException if the desired new size is more than\n+   *                                      max allowed\n+   * @throws OutOfMemoryException if the internal memory allocation fails\n+   */\n+  public void reallocDataBuffer() {\n+    final long currentBufferCapacity = valueBuffer.capacity();\n+    long newAllocationSize = currentBufferCapacity * 2;\n+    if (newAllocationSize == 0) {\n+      if (lastValueAllocationSizeInBytes > 0) {\n+        newAllocationSize = lastValueAllocationSizeInBytes;\n+      } else {\n+        newAllocationSize = INITIAL_BYTE_COUNT * 2;\n+      }\n+    }\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    checkDataBufferSize(newAllocationSize);\n+\n+    final ArrowBuf newBuf = allocator.buffer(newAllocationSize);\n+    newBuf.setBytes(0, valueBuffer, 0, currentBufferCapacity);\n+    valueBuffer.getReferenceManager().release();\n+    valueBuffer = newBuf;\n+    lastValueAllocationSizeInBytes = valueBuffer.capacity();\n+  }\n+\n+  /**\n+   * Reallocate the validity and offset buffers for this vector. Validity\n+   * buffer is used to track the NULL or NON-NULL nature of elements in\n+   * the vector and offset buffer is used to store the lengths of variable\n+   * width elements in the vector.\n+   *\n+   * <p>Note that data buffer for variable length vectors moves independent\n+   * of the companion validity and offset buffers. This is in\n+   * contrast to what we have for fixed width vectors.\n+   *\n+   * <p>So even though we may have setup an initial capacity of 1024\n+   * elements in the vector, it is quite possible\n+   * that we need to reAlloc() the data buffer when we are setting\n+   * the 5th element in the vector simply because previous\n+   * variable length elements have exhausted the buffer capacity.\n+   * However, we really don't need to reAlloc() validity and\n+   * offset buffers until we try to set the 1025th element\n+   * This is why we do a separate check for safe methods to\n+   * determine which buffer needs reallocation.\n+   * @throws OversizedAllocationException if the desired new size is more than\n+   *                                      max allowed\n+   * @throws OutOfMemoryException if the internal memory allocation fails\n+   */\n+  public void reallocValidityAndOffsetBuffers() {\n+    int targetOffsetCount = capAtMaxInt((offsetBuffer.capacity() / OFFSET_WIDTH) * 2);\n+    if (targetOffsetCount == 0) {\n+      if (lastValueCapacity > 0) {\n+        targetOffsetCount = (lastValueCapacity + 1);\n+      } else {\n+        targetOffsetCount = 2 * (INITIAL_VALUE_ALLOCATION + 1);\n+      }\n+    }\n+    computeAndCheckOffsetsBufferSize(targetOffsetCount);\n+\n+    DataAndValidityBuffers buffers = allocFixedDataAndValidityBufs(targetOffsetCount, OFFSET_WIDTH);\n+    final ArrowBuf newOffsetBuffer = buffers.getDataBuf();\n+    newOffsetBuffer.setBytes(0, offsetBuffer, 0, offsetBuffer.capacity());\n+    newOffsetBuffer.setZero(offsetBuffer.capacity(), newOffsetBuffer.capacity() - offsetBuffer.capacity());\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = newOffsetBuffer;\n+\n+    final ArrowBuf newValidityBuffer = buffers.getValidityBuf();\n+    newValidityBuffer.setBytes(0, validityBuffer, 0, validityBuffer.capacity());\n+    newValidityBuffer.setZero(validityBuffer.capacity(), newValidityBuffer.capacity() - validityBuffer.capacity());\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = newValidityBuffer;\n+\n+    lastValueCapacity = getValueCapacity();\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying data buffer.\n+   * @return number of bytes in the data buffer\n+   */\n+  @Override\n+  public int getByteCapacity() {\n+    return capAtMaxInt(valueBuffer.capacity());\n+  }\n+\n+  @Override\n+  public int sizeOfValueBuffer() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    return capAtMaxInt(offsetBuffer.getLong((long) valueCount * OFFSET_WIDTH));\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector.\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    return getBufferSizeFor(this.valueCount);\n+  }\n+\n+  /**\n+   * Get the potential buffer size for a particular number of records.\n+   * @param valueCount desired number of elements in the vector\n+   * @return estimated size of underlying buffers if the vector holds\n+   *         a given number of elements\n+   */\n+  @Override\n+  public int getBufferSizeFor(final int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+\n+    final long validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    final long offsetBufferSize = (long) (valueCount + 1) * OFFSET_WIDTH;\n+    /* get the end offset for this valueCount */\n+    final long dataBufferSize = offsetBuffer.getLong((long) valueCount * OFFSET_WIDTH);\n+    return capAtMaxInt(validityBufferSize + offsetBufferSize + dataBufferSize);\n+  }\n+\n+  /**\n+   * Get information about how this field is materialized.\n+   * @return the field corresponding to this vector\n+   */\n+  @Override\n+  public Field getField() {\n+    return field;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    final ArrowBuf[] buffers;\n+    setReaderAndWriterIndex();\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = new ArrowBuf[3];\n+      buffers[0] = validityBuffer;\n+      buffers[1] = offsetBuffer;\n+      buffers[2] = valueBuffer;\n+    }\n+    if (clear) {\n+      for (final ArrowBuf buffer : buffers) {\n+        buffer.getReferenceManager().retain();\n+      }\n+      clear();\n+    }\n+    return buffers;\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @param callBack not used\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return getTransferPair(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(BufferAllocator allocator) {\n+    return getTransferPair(getName(), allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  public abstract TransferPair getTransferPair(String ref, BufferAllocator allocator);\n+\n+  /**\n+   * Transfer this vector'data to another vector. The memory associated\n+   * with this vector is transferred to the allocator of target vector\n+   * for accounting and management purposes.\n+   * @param target destination vector for transfer\n+   */\n+  public void transferTo(BaseLargeVariableWidthVector target) {\n+    compareTypes(target, \"transferTo\");\n+    target.clear();\n+    target.validityBuffer = transferBuffer(validityBuffer, target.allocator);\n+    target.valueBuffer = transferBuffer(valueBuffer, target.allocator);\n+    target.offsetBuffer = transferBuffer(offsetBuffer, target.allocator);\n+    target.setLastSet(this.lastSet);\n+    if (this.valueCount > 0) {\n+      target.setValueCount(this.valueCount);\n+    }\n+    clear();\n+  }\n+\n+  /**\n+   * Slice this vector at desired index and length and transfer the\n+   * corresponding data to the target vector.\n+   * @param startIndex start position of the split in source vector.\n+   * @param length length of the split.\n+   * @param target destination vector\n+   */\n+  public void splitAndTransferTo(int startIndex, int length,\n+                                 BaseLargeVariableWidthVector target) {\n+    Preconditions.checkArgument(startIndex >= 0 && startIndex < valueCount,\n+        \"Invalid startIndex: %s\", startIndex);\n+    Preconditions.checkArgument(startIndex + length <= valueCount,\n+        \"Invalid length: %s\", length);\n+    compareTypes(target, \"splitAndTransferTo\");\n+    target.clear();\n+    splitAndTransferValidityBuffer(startIndex, length, target);\n+    splitAndTransferOffsetBuffer(startIndex, length, target);\n+    target.setLastSet(length - 1);\n+    if (length > 0) {\n+      target.setValueCount(length);\n+    }\n+  }\n+\n+  /**\n+   * Transfer the offsets along with data. Unlike the data buffer, we cannot simply\n+   * slice the offset buffer for split and transfer. The reason is that offsets\n+   * in the target vector have to be adjusted and made relative to the staring\n+   * offset in source vector from the start index of split. This is why, we\n+   * need to explicitly allocate the offset buffer and set the adjusted offsets\n+   * in the target vector.\n+   */\n+  private void splitAndTransferOffsetBuffer(int startIndex, int length, BaseLargeVariableWidthVector target) {\n+    final long start = offsetBuffer.getLong((long) startIndex * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((long) (startIndex + length) * OFFSET_WIDTH);\n+    final long dataLength = end - start;\n+    target.allocateOffsetBuffer((long) (length + 1) * OFFSET_WIDTH);\n+    for (int i = 0; i < length + 1; i++) {\n+      final long relativeSourceOffset = offsetBuffer.getLong((long) (startIndex + i) * OFFSET_WIDTH) - start;\n+      target.offsetBuffer.setLong((long) i * OFFSET_WIDTH, relativeSourceOffset);\n+    }\n+    final ArrowBuf slicedBuffer = valueBuffer.slice(start, dataLength);\n+    target.valueBuffer = transferBuffer(slicedBuffer, target.allocator);\n+  }\n+\n+  /*\n+   * Transfer the validity.\n+   */\n+  private void splitAndTransferValidityBuffer(int startIndex, int length,\n+                                              BaseLargeVariableWidthVector target) {\n+    int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+    int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+    int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+    int offset = startIndex % 8;\n+\n+    if (length > 0) {\n+      if (offset == 0) {\n+        // slice\n+        if (target.validityBuffer != null) {\n+          target.validityBuffer.getReferenceManager().release();\n+        }\n+        target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+        target.validityBuffer.getReferenceManager().retain();\n+      } else {\n+        /* Copy data\n+         * When the first bit starts from the middle of a byte (offset != 0),\n+         * copy data from src BitVector.\n+         * Each byte in the target is composed by a part in i-th byte,\n+         * another part in (i+1)-th byte.\n+         */\n+        target.allocateValidityBuffer(byteSizeTarget);\n+\n+        for (int i = 0; i < byteSizeTarget - 1; i++) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer, firstByteSource + i, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer, firstByteSource + i + 1, offset);\n+\n+          target.validityBuffer.setByte(i, (b1 + b2));\n+        }\n+        /* Copying the last piece is done in the following manner:\n+         * if the source vector has 1 or more bytes remaining, we copy\n+         * the last piece as a byte formed by shifting data\n+         * from the current byte and the next byte.\n+         *\n+         * if the source vector has no more bytes remaining\n+         * (we are at the last byte), we copy the last piece as a byte\n+         * by shifting data from the current byte.\n+         */\n+        if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+              firstByteSource + byteSizeTarget - 1, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer,\n+              firstByteSource + byteSizeTarget, offset);\n+\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+        } else {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+              firstByteSource + byteSizeTarget - 1, offset);\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+        }\n+      }\n+    }\n+  }\n+\n+\n+  /*----------------------------------------------------------------*\n+   |                                                                |\n+   |                common getters and setters                      |\n+   |                                                                |\n+   *----------------------------------------------------------------*/\n+\n+\n+  /**\n+   * Get the number of elements that are null in the vector.\n+   *\n+   * @return the number of null elements.\n+   */\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  /**\n+   * Check if the given index is within the current value capacity\n+   * of the vector.\n+   *\n+   * @param index  position to check\n+   * @return true if index is within the current value capacity\n+   */\n+  public boolean isSafe(int index) {\n \n Review comment:\n   @siddharthdave Thanks for a lot your attention. Currently, we are using int32 for all vector indices, and int64 for all ArrowBuf indices. \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-12T07:38:48.640+0000",
                    "updated": "2020-03-12T07:38:48.640+0000",
                    "started": "2020-03-12T07:38:48.640+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "402011",
                    "issueId": "13248477"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/worklog/402016",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on pull request #6425: ARROW-6111: [Java] Support LargeVarChar and LargeBinary types\nURL: https://github.com/apache/arrow/pull/6425#discussion_r391449320\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseLargeVariableWidthVector.java\n ##########\n @@ -0,0 +1,1361 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+/**\n+ * BaseLargeVariableWidthVector is a base class providing functionality for large strings/large bytes types.\n+ */\n+public abstract class BaseLargeVariableWidthVector extends BaseValueVector\n \n Review comment:\n   Good question.\r\n   We choose to have a separate BaseLargeVariableWidthVector class after careful thoughts and evaluations.\r\n   \r\n   It appears that BaseVariableWidthVector and BaseLargeVariableWidthVector have many similarities. However, they are different in details, and the differences cannot be overcome by method overriding/overloading.\r\n   \r\n   For example, in BaseVariableWidthVector, we have\r\n   \r\n   protected final int getStartOffset(int index)\r\n   \r\n   while in BaseLargeVariableWidthVector, we have\r\n   \r\n   protected final long getStartOffset(int index)\r\n   \r\n   These two methods differ only in return type, so we cannot use method overloading/overriding.\r\n   \r\n   Another concern is performance. For example, `handleSafe` is a performance critical operation, because it may be called in each setSafe method. So it is declared as a final method. If we share the same base class, we must provide two implementations for `handleSafe`, and it will no longer be fianl. This may lead to performance degradation. \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-12T07:53:12.423+0000",
                    "updated": "2020-03-12T07:53:12.423+0000",
                    "started": "2020-03-12T07:53:12.423+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "402016",
                    "issueId": "13248477"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/worklog/402017",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on pull request #6425: ARROW-6111: [Java] Support LargeVarChar and LargeBinary types\nURL: https://github.com/apache/arrow/pull/6425#discussion_r391444002\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseLargeVariableWidthVector.java\n ##########\n @@ -0,0 +1,1361 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+/**\n+ * BaseLargeVariableWidthVector is a base class providing functionality for large strings/large bytes types.\n+ */\n+public abstract class BaseLargeVariableWidthVector extends BaseValueVector\n+    implements VariableWidthVector, FieldVector, VectorDefinitionSetter {\n+  private static final int DEFAULT_RECORD_BYTE_COUNT = 12;\n+  private static final int INITIAL_BYTE_COUNT = INITIAL_VALUE_ALLOCATION * DEFAULT_RECORD_BYTE_COUNT;\n+  private int lastValueCapacity;\n+  private long lastValueAllocationSizeInBytes;\n+\n+  /* protected members */\n+  public static final int OFFSET_WIDTH = 8; /* 8 byte unsigned int to track offsets */\n+  protected static final byte[] emptyByteArray = new byte[]{};\n+  protected ArrowBuf validityBuffer;\n+  protected ArrowBuf valueBuffer;\n+  protected ArrowBuf offsetBuffer;\n+  protected int valueCount;\n+  protected int lastSet;\n+  protected final Field field;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param field The field materialized by this vector.\n+   * @param allocator The allocator to use for creating/resizing buffers\n+   */\n+  public BaseLargeVariableWidthVector(Field field, final BufferAllocator allocator) {\n+    super(allocator);\n+    this.field = field;\n+    lastValueAllocationSizeInBytes = INITIAL_BYTE_COUNT;\n+    // -1 because we require one extra slot for the offset array.\n+    lastValueCapacity = INITIAL_VALUE_ALLOCATION - 1;\n+    valueCount = 0;\n+    lastSet = -1;\n+    offsetBuffer = allocator.getEmpty();\n+    validityBuffer = allocator.getEmpty();\n+    valueBuffer = allocator.getEmpty();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return field.getName();\n+  }\n+\n+  /**\n+   * Get buffer that manages the validity (NULL or NON-NULL nature) of\n+   * elements in the vector. Consider it as a buffer for internal bit vector\n+   * data structure.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  /**\n+   * Get the buffer that stores the data for elements in the vector.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    return valueBuffer;\n+  }\n+\n+  /**\n+   * buffer that stores the offsets for elements\n+   * in the vector. This operation is not supported for fixed-width vectors.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the offsets for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return offsetBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that manages the validity\n+   * (NULL or NON-NULL nature) of elements in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return validityBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the data for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getDataBufferAddress() {\n+    return valueBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   * @param valueCount desired number of elements in the vector\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount) {\n+    final long size = (long) valueCount * DEFAULT_RECORD_BYTE_COUNT;\n+    checkDataBufferSize(size);\n+    computeAndCheckOffsetsBufferSize(valueCount);\n+    lastValueAllocationSizeInBytes = size;\n+    lastValueCapacity = valueCount;\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   * @param valueCount desired number of elements in the vector\n+   * @param density average number of bytes per variable width element\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount, double density) {\n+    long size = Math.max((long)(valueCount * density), 1L);\n+    checkDataBufferSize(size);\n+    computeAndCheckOffsetsBufferSize(valueCount);\n+    lastValueAllocationSizeInBytes = size;\n+    lastValueCapacity = valueCount;\n+  }\n+\n+  /**\n+   * Get the density of this ListVector.\n+   * @return density\n+   */\n+  public double getDensity() {\n+    if (valueCount == 0) {\n+      return 0.0D;\n+    }\n+    final long startOffset = offsetBuffer.getLong(0);\n+    final long endOffset = offsetBuffer.getLong((long) valueCount * OFFSET_WIDTH);\n+    final double totalListSize = endOffset - startOffset;\n+    return totalListSize / valueCount;\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector.\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    final long offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n+    return capAtMaxInt(Math.min(offsetValueCapacity, getValidityBufferValueCapacity()));\n+  }\n+\n+  private long getValidityBufferValueCapacity() {\n+    return validityBuffer.capacity() * 8;\n+  }\n+\n+  private long getOffsetBufferValueCapacity() {\n+    return offsetBuffer.capacity() / OFFSET_WIDTH;\n+  }\n+\n+  /**\n+   * zero out the vector and the data in associated buffers.\n+   */\n+  public void zeroVector() {\n+    initValidityBuffer();\n+    initOffsetBuffer();\n+    valueBuffer.setZero(0, valueBuffer.capacity());\n+  }\n+\n+  /* zero out the validity buffer */\n+  private void initValidityBuffer() {\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+\n+  /* zero out the offset buffer */\n+  private void initOffsetBuffer() {\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+\n+  /**\n+   * Reset the vector to initial state. Same as {@link #zeroVector()}.\n+   * Note that this method doesn't release any memory.\n+   */\n+  public void reset() {\n+    zeroVector();\n+    lastSet = -1;\n+    valueCount = 0;\n+  }\n+\n+  /**\n+   * Close the vector and release the associated buffers.\n+   */\n+  @Override\n+  public void close() {\n+    clear();\n+  }\n+\n+  /**\n+   * Same as {@link #close()}.\n+   */\n+  @Override\n+  public void clear() {\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    valueBuffer = releaseBuffer(valueBuffer);\n+    offsetBuffer = releaseBuffer(offsetBuffer);\n+    lastSet = -1;\n+    valueCount = 0;\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Initialize the children in schema for this Field. This operation is a\n+   * NO-OP for scalar types since they don't have any children.\n+   * @param children the schema\n+   * @throws IllegalArgumentException if children is a non-empty list for scalar types.\n+   */\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (!children.isEmpty()) {\n+      throw new IllegalArgumentException(\"primitive type vector can not have children\");\n+    }\n+  }\n+\n+  /**\n+   * Get the inner child vectors.\n+   * @return list of child vectors for complex types, empty list for scalar vector types\n+   */\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return Collections.emptyList();\n+  }\n+\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+    ArrowBuf dataBuffer = ownBuffers.get(2);\n+\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = offBuffer.getReferenceManager().retain(offBuffer, allocator);\n+    valueBuffer.getReferenceManager().release();\n+    valueBuffer = dataBuffer.getReferenceManager().retain(dataBuffer, allocator);\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector.\n+   * @return the inner buffers.\n+   */\n+  public List<ArrowBuf> getFieldBuffers() {\n+    // before flight/IPC, we must bring the vector to a consistent state.\n+    // this is because, it is possible that the offset buffers of some trailing values\n+    // are not updated. this may cause some data in the data buffer being lost.\n+    // for details, please see TestValueVector#testUnloadVariableWidthVector.\n+    fillHoles(valueCount);\n+\n+    List<ArrowBuf> result = new ArrayList<>(3);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+    result.add(valueBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    valueBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+      valueBuffer.writerIndex(0);\n+    } else {\n+      final long lastDataOffset = getStartOffset(valueCount);\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((long) (valueCount + 1) * OFFSET_WIDTH);\n+      valueBuffer.writerIndex(lastDataOffset);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() {\n+    allocateNew(lastValueAllocationSizeInBytes, lastValueCapacity);\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector. See {@link #allocateNew(long, int)} for allocating memory for specific\n+   * number of elements in the vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  @Override\n+  public boolean allocateNewSafe() {\n+    try {\n+      allocateNew(lastValueAllocationSizeInBytes, lastValueCapacity);\n+      return true;\n+    } catch (Exception e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector to support storing at least the provided number of\n+   * elements in the vector. This method must be called prior to using the ValueVector.\n+   *\n+   * @param totalBytes desired total memory capacity\n+   * @param valueCount the desired number of elements in the vector\n+   * @throws org.apache.arrow.memory.OutOfMemoryException if memory allocation fails\n+   */\n+  @Override\n+  public void allocateNew(long totalBytes, int valueCount) {\n+    assert totalBytes >= 0;\n+\n+    checkDataBufferSize(totalBytes);\n+    computeAndCheckOffsetsBufferSize(valueCount);\n+\n+    /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(totalBytes, valueCount);\n+    } catch (Exception e) {\n+      clear();\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public void allocateNew(int valueCount) {\n+    allocateNew(lastValueAllocationSizeInBytes, valueCount);\n+  }\n+\n+  /* Check if the data buffer size is within bounds. */\n+  private void checkDataBufferSize(long size) {\n+    if (size > MAX_ALLOCATION_SIZE || size < 0) {\n+      throw new OversizedAllocationException(\"Memory required for vector \" +\n+          \" is (\" + size + \"), which is more than max allowed (\" + MAX_ALLOCATION_SIZE + \")\");\n+    }\n+  }\n+\n+  /*\n+   * Compute the buffer size required for 'valueCount' offsets and validity, and check if it's\n+   * within bounds.\n+   */\n+  private long computeAndCheckOffsetsBufferSize(int valueCount) {\n+    /* to track the end offset of last data element in vector, we need\n+     * an additional slot in offset buffer.\n+     */\n+    final long size = computeCombinedBufferSize(valueCount + 1, OFFSET_WIDTH);\n+    if (size > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Memory required for vector capacity \" +\n+          valueCount +\n+          \" is (\" + size + \"), which is more than max allowed (\" + MAX_ALLOCATION_SIZE + \")\");\n+    }\n+    return size;\n+  }\n+\n+  /* allocate the inner buffers */\n+  private void allocateBytes(final long valueBufferSize, final int valueCount) {\n+    /* allocate data buffer */\n+    long curSize = valueBufferSize;\n+    valueBuffer = allocator.buffer(curSize);\n+    valueBuffer.readerIndex(0);\n+\n+    /* allocate offset buffer and validity buffer */\n+    DataAndValidityBuffers buffers = allocFixedDataAndValidityBufs(valueCount + 1, OFFSET_WIDTH);\n+    offsetBuffer = buffers.getDataBuf();\n+    validityBuffer = buffers.getValidityBuf();\n+    initOffsetBuffer();\n+    initValidityBuffer();\n+\n+    lastValueCapacity = getValueCapacity();\n+    lastValueAllocationSizeInBytes = capAtMaxInt(valueBuffer.capacity());\n+  }\n+\n+  /* allocate offset buffer */\n+  private void allocateOffsetBuffer(final long size) {\n+    offsetBuffer = allocator.buffer(size);\n+    offsetBuffer.readerIndex(0);\n+    initOffsetBuffer();\n+  }\n+\n+  /* allocate validity buffer */\n+  private void allocateValidityBuffer(final long size) {\n+    validityBuffer = allocator.buffer(size);\n+    validityBuffer.readerIndex(0);\n+    initValidityBuffer();\n+  }\n+\n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  public void reAlloc() {\n+    reallocDataBuffer();\n+    reallocValidityAndOffsetBuffers();\n+  }\n+\n+  /**\n+   * Reallocate the data buffer. Data Buffer stores the actual data for\n+   * LARGEVARCHAR or LARGEVARBINARY elements in the vector. The behavior is to double\n+   * the size of buffer.\n+   * @throws OversizedAllocationException if the desired new size is more than\n+   *                                      max allowed\n+   * @throws OutOfMemoryException if the internal memory allocation fails\n+   */\n+  public void reallocDataBuffer() {\n+    final long currentBufferCapacity = valueBuffer.capacity();\n+    long newAllocationSize = currentBufferCapacity * 2;\n+    if (newAllocationSize == 0) {\n+      if (lastValueAllocationSizeInBytes > 0) {\n+        newAllocationSize = lastValueAllocationSizeInBytes;\n+      } else {\n+        newAllocationSize = INITIAL_BYTE_COUNT * 2;\n+      }\n+    }\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    checkDataBufferSize(newAllocationSize);\n+\n+    final ArrowBuf newBuf = allocator.buffer(newAllocationSize);\n+    newBuf.setBytes(0, valueBuffer, 0, currentBufferCapacity);\n+    valueBuffer.getReferenceManager().release();\n+    valueBuffer = newBuf;\n+    lastValueAllocationSizeInBytes = valueBuffer.capacity();\n+  }\n+\n+  /**\n+   * Reallocate the validity and offset buffers for this vector. Validity\n+   * buffer is used to track the NULL or NON-NULL nature of elements in\n+   * the vector and offset buffer is used to store the lengths of variable\n+   * width elements in the vector.\n+   *\n+   * <p>Note that data buffer for variable length vectors moves independent\n+   * of the companion validity and offset buffers. This is in\n+   * contrast to what we have for fixed width vectors.\n+   *\n+   * <p>So even though we may have setup an initial capacity of 1024\n+   * elements in the vector, it is quite possible\n+   * that we need to reAlloc() the data buffer when we are setting\n+   * the 5th element in the vector simply because previous\n+   * variable length elements have exhausted the buffer capacity.\n+   * However, we really don't need to reAlloc() validity and\n+   * offset buffers until we try to set the 1025th element\n+   * This is why we do a separate check for safe methods to\n+   * determine which buffer needs reallocation.\n+   * @throws OversizedAllocationException if the desired new size is more than\n+   *                                      max allowed\n+   * @throws OutOfMemoryException if the internal memory allocation fails\n+   */\n+  public void reallocValidityAndOffsetBuffers() {\n+    int targetOffsetCount = capAtMaxInt((offsetBuffer.capacity() / OFFSET_WIDTH) * 2);\n+    if (targetOffsetCount == 0) {\n+      if (lastValueCapacity > 0) {\n+        targetOffsetCount = (lastValueCapacity + 1);\n+      } else {\n+        targetOffsetCount = 2 * (INITIAL_VALUE_ALLOCATION + 1);\n+      }\n+    }\n+    computeAndCheckOffsetsBufferSize(targetOffsetCount);\n+\n+    DataAndValidityBuffers buffers = allocFixedDataAndValidityBufs(targetOffsetCount, OFFSET_WIDTH);\n+    final ArrowBuf newOffsetBuffer = buffers.getDataBuf();\n+    newOffsetBuffer.setBytes(0, offsetBuffer, 0, offsetBuffer.capacity());\n+    newOffsetBuffer.setZero(offsetBuffer.capacity(), newOffsetBuffer.capacity() - offsetBuffer.capacity());\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = newOffsetBuffer;\n+\n+    final ArrowBuf newValidityBuffer = buffers.getValidityBuf();\n+    newValidityBuffer.setBytes(0, validityBuffer, 0, validityBuffer.capacity());\n+    newValidityBuffer.setZero(validityBuffer.capacity(), newValidityBuffer.capacity() - validityBuffer.capacity());\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = newValidityBuffer;\n+\n+    lastValueCapacity = getValueCapacity();\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying data buffer.\n+   * @return number of bytes in the data buffer\n+   */\n+  @Override\n+  public int getByteCapacity() {\n+    return capAtMaxInt(valueBuffer.capacity());\n+  }\n+\n+  @Override\n+  public int sizeOfValueBuffer() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    return capAtMaxInt(offsetBuffer.getLong((long) valueCount * OFFSET_WIDTH));\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector.\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    return getBufferSizeFor(this.valueCount);\n+  }\n+\n+  /**\n+   * Get the potential buffer size for a particular number of records.\n+   * @param valueCount desired number of elements in the vector\n+   * @return estimated size of underlying buffers if the vector holds\n+   *         a given number of elements\n+   */\n+  @Override\n+  public int getBufferSizeFor(final int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+\n+    final long validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    final long offsetBufferSize = (long) (valueCount + 1) * OFFSET_WIDTH;\n+    /* get the end offset for this valueCount */\n+    final long dataBufferSize = offsetBuffer.getLong((long) valueCount * OFFSET_WIDTH);\n+    return capAtMaxInt(validityBufferSize + offsetBufferSize + dataBufferSize);\n+  }\n+\n+  /**\n+   * Get information about how this field is materialized.\n+   * @return the field corresponding to this vector\n+   */\n+  @Override\n+  public Field getField() {\n+    return field;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    final ArrowBuf[] buffers;\n+    setReaderAndWriterIndex();\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = new ArrowBuf[3];\n+      buffers[0] = validityBuffer;\n+      buffers[1] = offsetBuffer;\n+      buffers[2] = valueBuffer;\n+    }\n+    if (clear) {\n+      for (final ArrowBuf buffer : buffers) {\n+        buffer.getReferenceManager().retain();\n+      }\n+      clear();\n+    }\n+    return buffers;\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @param callBack not used\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return getTransferPair(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(BufferAllocator allocator) {\n+    return getTransferPair(getName(), allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  public abstract TransferPair getTransferPair(String ref, BufferAllocator allocator);\n+\n+  /**\n+   * Transfer this vector'data to another vector. The memory associated\n+   * with this vector is transferred to the allocator of target vector\n+   * for accounting and management purposes.\n+   * @param target destination vector for transfer\n+   */\n+  public void transferTo(BaseLargeVariableWidthVector target) {\n+    compareTypes(target, \"transferTo\");\n+    target.clear();\n+    target.validityBuffer = transferBuffer(validityBuffer, target.allocator);\n+    target.valueBuffer = transferBuffer(valueBuffer, target.allocator);\n+    target.offsetBuffer = transferBuffer(offsetBuffer, target.allocator);\n+    target.setLastSet(this.lastSet);\n+    if (this.valueCount > 0) {\n+      target.setValueCount(this.valueCount);\n+    }\n+    clear();\n+  }\n+\n+  /**\n+   * Slice this vector at desired index and length and transfer the\n+   * corresponding data to the target vector.\n+   * @param startIndex start position of the split in source vector.\n+   * @param length length of the split.\n+   * @param target destination vector\n+   */\n+  public void splitAndTransferTo(int startIndex, int length,\n+                                 BaseLargeVariableWidthVector target) {\n+    Preconditions.checkArgument(startIndex >= 0 && startIndex < valueCount,\n+        \"Invalid startIndex: %s\", startIndex);\n+    Preconditions.checkArgument(startIndex + length <= valueCount,\n+        \"Invalid length: %s\", length);\n+    compareTypes(target, \"splitAndTransferTo\");\n+    target.clear();\n+    splitAndTransferValidityBuffer(startIndex, length, target);\n+    splitAndTransferOffsetBuffer(startIndex, length, target);\n+    target.setLastSet(length - 1);\n+    if (length > 0) {\n+      target.setValueCount(length);\n+    }\n+  }\n+\n+  /**\n+   * Transfer the offsets along with data. Unlike the data buffer, we cannot simply\n+   * slice the offset buffer for split and transfer. The reason is that offsets\n+   * in the target vector have to be adjusted and made relative to the staring\n+   * offset in source vector from the start index of split. This is why, we\n+   * need to explicitly allocate the offset buffer and set the adjusted offsets\n+   * in the target vector.\n+   */\n+  private void splitAndTransferOffsetBuffer(int startIndex, int length, BaseLargeVariableWidthVector target) {\n+    final long start = offsetBuffer.getLong((long) startIndex * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((long) (startIndex + length) * OFFSET_WIDTH);\n+    final long dataLength = end - start;\n+    target.allocateOffsetBuffer((long) (length + 1) * OFFSET_WIDTH);\n+    for (int i = 0; i < length + 1; i++) {\n+      final long relativeSourceOffset = offsetBuffer.getLong((long) (startIndex + i) * OFFSET_WIDTH) - start;\n+      target.offsetBuffer.setLong((long) i * OFFSET_WIDTH, relativeSourceOffset);\n+    }\n+    final ArrowBuf slicedBuffer = valueBuffer.slice(start, dataLength);\n+    target.valueBuffer = transferBuffer(slicedBuffer, target.allocator);\n+  }\n+\n+  /*\n+   * Transfer the validity.\n+   */\n+  private void splitAndTransferValidityBuffer(int startIndex, int length,\n+                                              BaseLargeVariableWidthVector target) {\n+    int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+    int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+    int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+    int offset = startIndex % 8;\n+\n+    if (length > 0) {\n+      if (offset == 0) {\n+        // slice\n+        if (target.validityBuffer != null) {\n+          target.validityBuffer.getReferenceManager().release();\n+        }\n+        target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+        target.validityBuffer.getReferenceManager().retain();\n+      } else {\n+        /* Copy data\n+         * When the first bit starts from the middle of a byte (offset != 0),\n+         * copy data from src BitVector.\n+         * Each byte in the target is composed by a part in i-th byte,\n+         * another part in (i+1)-th byte.\n+         */\n+        target.allocateValidityBuffer(byteSizeTarget);\n+\n+        for (int i = 0; i < byteSizeTarget - 1; i++) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer, firstByteSource + i, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer, firstByteSource + i + 1, offset);\n+\n+          target.validityBuffer.setByte(i, (b1 + b2));\n+        }\n+        /* Copying the last piece is done in the following manner:\n+         * if the source vector has 1 or more bytes remaining, we copy\n+         * the last piece as a byte formed by shifting data\n+         * from the current byte and the next byte.\n+         *\n+         * if the source vector has no more bytes remaining\n+         * (we are at the last byte), we copy the last piece as a byte\n+         * by shifting data from the current byte.\n+         */\n+        if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+              firstByteSource + byteSizeTarget - 1, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer,\n+              firstByteSource + byteSizeTarget, offset);\n+\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+        } else {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+              firstByteSource + byteSizeTarget - 1, offset);\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+        }\n+      }\n+    }\n+  }\n+\n+\n+  /*----------------------------------------------------------------*\n+   |                                                                |\n+   |                common getters and setters                      |\n+   |                                                                |\n+   *----------------------------------------------------------------*/\n+\n+\n+  /**\n+   * Get the number of elements that are null in the vector.\n+   *\n+   * @return the number of null elements.\n+   */\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  /**\n+   * Check if the given index is within the current value capacity\n+   * of the vector.\n+   *\n+   * @param index  position to check\n+   * @return true if index is within the current value capacity\n+   */\n+  public boolean isSafe(int index) {\n \n Review comment:\n   @siddharthdave Thanks a lot for your attention. Currently, we are using int32 for all vector indices, and int64 for all ArrowBuf indices. \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-12T07:53:47.007+0000",
                    "updated": "2020-03-12T07:53:47.007+0000",
                    "started": "2020-03-12T07:53:47.006+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "402017",
                    "issueId": "13248477"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/worklog/402018",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on pull request #6425: ARROW-6111: [Java] Support LargeVarChar and LargeBinary types\nURL: https://github.com/apache/arrow/pull/6425#discussion_r391449320\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseLargeVariableWidthVector.java\n ##########\n @@ -0,0 +1,1361 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+/**\n+ * BaseLargeVariableWidthVector is a base class providing functionality for large strings/large bytes types.\n+ */\n+public abstract class BaseLargeVariableWidthVector extends BaseValueVector\n \n Review comment:\n   Good question.\r\n   We choose to have a separate BaseLargeVariableWidthVector class after careful thoughts and evaluations.\r\n   \r\n   It appears that BaseVariableWidthVector and BaseLargeVariableWidthVector have many similarities. However, they are different in details, and the differences cannot be overcome by method overriding/overloading.\r\n   \r\n   For example, in BaseVariableWidthVector, we have\r\n   \r\n   protected final int getStartOffset(int index)\r\n   \r\n   while in BaseLargeVariableWidthVector, we have\r\n   \r\n   protected final long getStartOffset(int index)\r\n   \r\n   These two methods differ only in return type, so we cannot use method overloading/overriding.\r\n   \r\n   Another concern is performance. For example, `handleSafe` is a performance critical operation, because it may be called in each setSafe method call. So it is declared as a final method. If we share the same base class (BaseVariableWidthVector), we must provide two implementations for `handleSafe`, and it will be virtual instead of being final. This may lead to performance degradation. \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-12T07:56:21.975+0000",
                    "updated": "2020-03-12T07:56:21.975+0000",
                    "started": "2020-03-12T07:56:21.975+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "402018",
                    "issueId": "13248477"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/worklog/419475",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson commented on issue #6425: ARROW-6111: [Java] Support LargeVarChar and LargeBinary types\nURL: https://github.com/apache/arrow/pull/6425#issuecomment-611591872\n \n \n   @liyafan82 what's the status of this? Are you intending to get this into 0.17?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-09T15:29:43.412+0000",
                    "updated": "2020-04-09T15:29:43.412+0000",
                    "started": "2020-04-09T15:29:43.412+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "419475",
                    "issueId": "13248477"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/worklog/420000",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on issue #6425: ARROW-6111: [Java] Support LargeVarChar and LargeBinary types\nURL: https://github.com/apache/arrow/pull/6425#issuecomment-611869824\n \n \n   > @liyafan82 what's the status of this? Are you intending to get this into 0.17?\r\n   \r\n   @nealrichardson Thanks for your attention. \r\n   This PR is being reviewed. I am not sure if the reviewing process can finish in time. \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-10T04:16:51.037+0000",
                    "updated": "2020-04-10T04:16:51.037+0000",
                    "started": "2020-04-10T04:16:51.037+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "420000",
                    "issueId": "13248477"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/worklog/420007",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on issue #6425: ARROW-6111: [Java] Support LargeVarChar and LargeBinary types\nURL: https://github.com/apache/arrow/pull/6425#issuecomment-611872238\n \n \n   @siddharthteotia Do you have any comments to this PR?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-10T04:28:44.283+0000",
                    "updated": "2020-04-10T04:28:44.283+0000",
                    "started": "2020-04-10T04:28:44.283+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "420007",
                    "issueId": "13248477"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/worklog/420008",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on issue #6425: ARROW-6111: [Java] Support LargeVarChar and LargeBinary types\nURL: https://github.com/apache/arrow/pull/6425#issuecomment-611872238\n \n \n   @siddharthteotia Do you have any more comments to this PR?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-10T04:30:57.755+0000",
                    "updated": "2020-04-10T04:30:57.755+0000",
                    "started": "2020-04-10T04:30:57.755+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "420008",
                    "issueId": "13248477"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/worklog/423069",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on pull request #6425: ARROW-6111: [Java] Support LargeVarChar and LargeBinary types\nURL: https://github.com/apache/arrow/pull/6425#discussion_r391444002\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseLargeVariableWidthVector.java\n ##########\n @@ -0,0 +1,1361 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+/**\n+ * BaseLargeVariableWidthVector is a base class providing functionality for large strings/large bytes types.\n+ */\n+public abstract class BaseLargeVariableWidthVector extends BaseValueVector\n+    implements VariableWidthVector, FieldVector, VectorDefinitionSetter {\n+  private static final int DEFAULT_RECORD_BYTE_COUNT = 12;\n+  private static final int INITIAL_BYTE_COUNT = INITIAL_VALUE_ALLOCATION * DEFAULT_RECORD_BYTE_COUNT;\n+  private int lastValueCapacity;\n+  private long lastValueAllocationSizeInBytes;\n+\n+  /* protected members */\n+  public static final int OFFSET_WIDTH = 8; /* 8 byte unsigned int to track offsets */\n+  protected static final byte[] emptyByteArray = new byte[]{};\n+  protected ArrowBuf validityBuffer;\n+  protected ArrowBuf valueBuffer;\n+  protected ArrowBuf offsetBuffer;\n+  protected int valueCount;\n+  protected int lastSet;\n+  protected final Field field;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param field The field materialized by this vector.\n+   * @param allocator The allocator to use for creating/resizing buffers\n+   */\n+  public BaseLargeVariableWidthVector(Field field, final BufferAllocator allocator) {\n+    super(allocator);\n+    this.field = field;\n+    lastValueAllocationSizeInBytes = INITIAL_BYTE_COUNT;\n+    // -1 because we require one extra slot for the offset array.\n+    lastValueCapacity = INITIAL_VALUE_ALLOCATION - 1;\n+    valueCount = 0;\n+    lastSet = -1;\n+    offsetBuffer = allocator.getEmpty();\n+    validityBuffer = allocator.getEmpty();\n+    valueBuffer = allocator.getEmpty();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return field.getName();\n+  }\n+\n+  /**\n+   * Get buffer that manages the validity (NULL or NON-NULL nature) of\n+   * elements in the vector. Consider it as a buffer for internal bit vector\n+   * data structure.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  /**\n+   * Get the buffer that stores the data for elements in the vector.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    return valueBuffer;\n+  }\n+\n+  /**\n+   * buffer that stores the offsets for elements\n+   * in the vector. This operation is not supported for fixed-width vectors.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the offsets for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return offsetBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that manages the validity\n+   * (NULL or NON-NULL nature) of elements in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return validityBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the data for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getDataBufferAddress() {\n+    return valueBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   * @param valueCount desired number of elements in the vector\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount) {\n+    final long size = (long) valueCount * DEFAULT_RECORD_BYTE_COUNT;\n+    checkDataBufferSize(size);\n+    computeAndCheckOffsetsBufferSize(valueCount);\n+    lastValueAllocationSizeInBytes = size;\n+    lastValueCapacity = valueCount;\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   * @param valueCount desired number of elements in the vector\n+   * @param density average number of bytes per variable width element\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount, double density) {\n+    long size = Math.max((long)(valueCount * density), 1L);\n+    checkDataBufferSize(size);\n+    computeAndCheckOffsetsBufferSize(valueCount);\n+    lastValueAllocationSizeInBytes = size;\n+    lastValueCapacity = valueCount;\n+  }\n+\n+  /**\n+   * Get the density of this ListVector.\n+   * @return density\n+   */\n+  public double getDensity() {\n+    if (valueCount == 0) {\n+      return 0.0D;\n+    }\n+    final long startOffset = offsetBuffer.getLong(0);\n+    final long endOffset = offsetBuffer.getLong((long) valueCount * OFFSET_WIDTH);\n+    final double totalListSize = endOffset - startOffset;\n+    return totalListSize / valueCount;\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector.\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    final long offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n+    return capAtMaxInt(Math.min(offsetValueCapacity, getValidityBufferValueCapacity()));\n+  }\n+\n+  private long getValidityBufferValueCapacity() {\n+    return validityBuffer.capacity() * 8;\n+  }\n+\n+  private long getOffsetBufferValueCapacity() {\n+    return offsetBuffer.capacity() / OFFSET_WIDTH;\n+  }\n+\n+  /**\n+   * zero out the vector and the data in associated buffers.\n+   */\n+  public void zeroVector() {\n+    initValidityBuffer();\n+    initOffsetBuffer();\n+    valueBuffer.setZero(0, valueBuffer.capacity());\n+  }\n+\n+  /* zero out the validity buffer */\n+  private void initValidityBuffer() {\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+\n+  /* zero out the offset buffer */\n+  private void initOffsetBuffer() {\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+\n+  /**\n+   * Reset the vector to initial state. Same as {@link #zeroVector()}.\n+   * Note that this method doesn't release any memory.\n+   */\n+  public void reset() {\n+    zeroVector();\n+    lastSet = -1;\n+    valueCount = 0;\n+  }\n+\n+  /**\n+   * Close the vector and release the associated buffers.\n+   */\n+  @Override\n+  public void close() {\n+    clear();\n+  }\n+\n+  /**\n+   * Same as {@link #close()}.\n+   */\n+  @Override\n+  public void clear() {\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    valueBuffer = releaseBuffer(valueBuffer);\n+    offsetBuffer = releaseBuffer(offsetBuffer);\n+    lastSet = -1;\n+    valueCount = 0;\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Initialize the children in schema for this Field. This operation is a\n+   * NO-OP for scalar types since they don't have any children.\n+   * @param children the schema\n+   * @throws IllegalArgumentException if children is a non-empty list for scalar types.\n+   */\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (!children.isEmpty()) {\n+      throw new IllegalArgumentException(\"primitive type vector can not have children\");\n+    }\n+  }\n+\n+  /**\n+   * Get the inner child vectors.\n+   * @return list of child vectors for complex types, empty list for scalar vector types\n+   */\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return Collections.emptyList();\n+  }\n+\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+    ArrowBuf dataBuffer = ownBuffers.get(2);\n+\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = offBuffer.getReferenceManager().retain(offBuffer, allocator);\n+    valueBuffer.getReferenceManager().release();\n+    valueBuffer = dataBuffer.getReferenceManager().retain(dataBuffer, allocator);\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector.\n+   * @return the inner buffers.\n+   */\n+  public List<ArrowBuf> getFieldBuffers() {\n+    // before flight/IPC, we must bring the vector to a consistent state.\n+    // this is because, it is possible that the offset buffers of some trailing values\n+    // are not updated. this may cause some data in the data buffer being lost.\n+    // for details, please see TestValueVector#testUnloadVariableWidthVector.\n+    fillHoles(valueCount);\n+\n+    List<ArrowBuf> result = new ArrayList<>(3);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+    result.add(valueBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    valueBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+      valueBuffer.writerIndex(0);\n+    } else {\n+      final long lastDataOffset = getStartOffset(valueCount);\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((long) (valueCount + 1) * OFFSET_WIDTH);\n+      valueBuffer.writerIndex(lastDataOffset);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() {\n+    allocateNew(lastValueAllocationSizeInBytes, lastValueCapacity);\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector. See {@link #allocateNew(long, int)} for allocating memory for specific\n+   * number of elements in the vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  @Override\n+  public boolean allocateNewSafe() {\n+    try {\n+      allocateNew(lastValueAllocationSizeInBytes, lastValueCapacity);\n+      return true;\n+    } catch (Exception e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector to support storing at least the provided number of\n+   * elements in the vector. This method must be called prior to using the ValueVector.\n+   *\n+   * @param totalBytes desired total memory capacity\n+   * @param valueCount the desired number of elements in the vector\n+   * @throws org.apache.arrow.memory.OutOfMemoryException if memory allocation fails\n+   */\n+  @Override\n+  public void allocateNew(long totalBytes, int valueCount) {\n+    assert totalBytes >= 0;\n+\n+    checkDataBufferSize(totalBytes);\n+    computeAndCheckOffsetsBufferSize(valueCount);\n+\n+    /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(totalBytes, valueCount);\n+    } catch (Exception e) {\n+      clear();\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public void allocateNew(int valueCount) {\n+    allocateNew(lastValueAllocationSizeInBytes, valueCount);\n+  }\n+\n+  /* Check if the data buffer size is within bounds. */\n+  private void checkDataBufferSize(long size) {\n+    if (size > MAX_ALLOCATION_SIZE || size < 0) {\n+      throw new OversizedAllocationException(\"Memory required for vector \" +\n+          \" is (\" + size + \"), which is more than max allowed (\" + MAX_ALLOCATION_SIZE + \")\");\n+    }\n+  }\n+\n+  /*\n+   * Compute the buffer size required for 'valueCount' offsets and validity, and check if it's\n+   * within bounds.\n+   */\n+  private long computeAndCheckOffsetsBufferSize(int valueCount) {\n+    /* to track the end offset of last data element in vector, we need\n+     * an additional slot in offset buffer.\n+     */\n+    final long size = computeCombinedBufferSize(valueCount + 1, OFFSET_WIDTH);\n+    if (size > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Memory required for vector capacity \" +\n+          valueCount +\n+          \" is (\" + size + \"), which is more than max allowed (\" + MAX_ALLOCATION_SIZE + \")\");\n+    }\n+    return size;\n+  }\n+\n+  /* allocate the inner buffers */\n+  private void allocateBytes(final long valueBufferSize, final int valueCount) {\n+    /* allocate data buffer */\n+    long curSize = valueBufferSize;\n+    valueBuffer = allocator.buffer(curSize);\n+    valueBuffer.readerIndex(0);\n+\n+    /* allocate offset buffer and validity buffer */\n+    DataAndValidityBuffers buffers = allocFixedDataAndValidityBufs(valueCount + 1, OFFSET_WIDTH);\n+    offsetBuffer = buffers.getDataBuf();\n+    validityBuffer = buffers.getValidityBuf();\n+    initOffsetBuffer();\n+    initValidityBuffer();\n+\n+    lastValueCapacity = getValueCapacity();\n+    lastValueAllocationSizeInBytes = capAtMaxInt(valueBuffer.capacity());\n+  }\n+\n+  /* allocate offset buffer */\n+  private void allocateOffsetBuffer(final long size) {\n+    offsetBuffer = allocator.buffer(size);\n+    offsetBuffer.readerIndex(0);\n+    initOffsetBuffer();\n+  }\n+\n+  /* allocate validity buffer */\n+  private void allocateValidityBuffer(final long size) {\n+    validityBuffer = allocator.buffer(size);\n+    validityBuffer.readerIndex(0);\n+    initValidityBuffer();\n+  }\n+\n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  public void reAlloc() {\n+    reallocDataBuffer();\n+    reallocValidityAndOffsetBuffers();\n+  }\n+\n+  /**\n+   * Reallocate the data buffer. Data Buffer stores the actual data for\n+   * LARGEVARCHAR or LARGEVARBINARY elements in the vector. The behavior is to double\n+   * the size of buffer.\n+   * @throws OversizedAllocationException if the desired new size is more than\n+   *                                      max allowed\n+   * @throws OutOfMemoryException if the internal memory allocation fails\n+   */\n+  public void reallocDataBuffer() {\n+    final long currentBufferCapacity = valueBuffer.capacity();\n+    long newAllocationSize = currentBufferCapacity * 2;\n+    if (newAllocationSize == 0) {\n+      if (lastValueAllocationSizeInBytes > 0) {\n+        newAllocationSize = lastValueAllocationSizeInBytes;\n+      } else {\n+        newAllocationSize = INITIAL_BYTE_COUNT * 2;\n+      }\n+    }\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    checkDataBufferSize(newAllocationSize);\n+\n+    final ArrowBuf newBuf = allocator.buffer(newAllocationSize);\n+    newBuf.setBytes(0, valueBuffer, 0, currentBufferCapacity);\n+    valueBuffer.getReferenceManager().release();\n+    valueBuffer = newBuf;\n+    lastValueAllocationSizeInBytes = valueBuffer.capacity();\n+  }\n+\n+  /**\n+   * Reallocate the validity and offset buffers for this vector. Validity\n+   * buffer is used to track the NULL or NON-NULL nature of elements in\n+   * the vector and offset buffer is used to store the lengths of variable\n+   * width elements in the vector.\n+   *\n+   * <p>Note that data buffer for variable length vectors moves independent\n+   * of the companion validity and offset buffers. This is in\n+   * contrast to what we have for fixed width vectors.\n+   *\n+   * <p>So even though we may have setup an initial capacity of 1024\n+   * elements in the vector, it is quite possible\n+   * that we need to reAlloc() the data buffer when we are setting\n+   * the 5th element in the vector simply because previous\n+   * variable length elements have exhausted the buffer capacity.\n+   * However, we really don't need to reAlloc() validity and\n+   * offset buffers until we try to set the 1025th element\n+   * This is why we do a separate check for safe methods to\n+   * determine which buffer needs reallocation.\n+   * @throws OversizedAllocationException if the desired new size is more than\n+   *                                      max allowed\n+   * @throws OutOfMemoryException if the internal memory allocation fails\n+   */\n+  public void reallocValidityAndOffsetBuffers() {\n+    int targetOffsetCount = capAtMaxInt((offsetBuffer.capacity() / OFFSET_WIDTH) * 2);\n+    if (targetOffsetCount == 0) {\n+      if (lastValueCapacity > 0) {\n+        targetOffsetCount = (lastValueCapacity + 1);\n+      } else {\n+        targetOffsetCount = 2 * (INITIAL_VALUE_ALLOCATION + 1);\n+      }\n+    }\n+    computeAndCheckOffsetsBufferSize(targetOffsetCount);\n+\n+    DataAndValidityBuffers buffers = allocFixedDataAndValidityBufs(targetOffsetCount, OFFSET_WIDTH);\n+    final ArrowBuf newOffsetBuffer = buffers.getDataBuf();\n+    newOffsetBuffer.setBytes(0, offsetBuffer, 0, offsetBuffer.capacity());\n+    newOffsetBuffer.setZero(offsetBuffer.capacity(), newOffsetBuffer.capacity() - offsetBuffer.capacity());\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = newOffsetBuffer;\n+\n+    final ArrowBuf newValidityBuffer = buffers.getValidityBuf();\n+    newValidityBuffer.setBytes(0, validityBuffer, 0, validityBuffer.capacity());\n+    newValidityBuffer.setZero(validityBuffer.capacity(), newValidityBuffer.capacity() - validityBuffer.capacity());\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = newValidityBuffer;\n+\n+    lastValueCapacity = getValueCapacity();\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying data buffer.\n+   * @return number of bytes in the data buffer\n+   */\n+  @Override\n+  public int getByteCapacity() {\n+    return capAtMaxInt(valueBuffer.capacity());\n+  }\n+\n+  @Override\n+  public int sizeOfValueBuffer() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    return capAtMaxInt(offsetBuffer.getLong((long) valueCount * OFFSET_WIDTH));\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector.\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    return getBufferSizeFor(this.valueCount);\n+  }\n+\n+  /**\n+   * Get the potential buffer size for a particular number of records.\n+   * @param valueCount desired number of elements in the vector\n+   * @return estimated size of underlying buffers if the vector holds\n+   *         a given number of elements\n+   */\n+  @Override\n+  public int getBufferSizeFor(final int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+\n+    final long validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    final long offsetBufferSize = (long) (valueCount + 1) * OFFSET_WIDTH;\n+    /* get the end offset for this valueCount */\n+    final long dataBufferSize = offsetBuffer.getLong((long) valueCount * OFFSET_WIDTH);\n+    return capAtMaxInt(validityBufferSize + offsetBufferSize + dataBufferSize);\n+  }\n+\n+  /**\n+   * Get information about how this field is materialized.\n+   * @return the field corresponding to this vector\n+   */\n+  @Override\n+  public Field getField() {\n+    return field;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    final ArrowBuf[] buffers;\n+    setReaderAndWriterIndex();\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = new ArrowBuf[3];\n+      buffers[0] = validityBuffer;\n+      buffers[1] = offsetBuffer;\n+      buffers[2] = valueBuffer;\n+    }\n+    if (clear) {\n+      for (final ArrowBuf buffer : buffers) {\n+        buffer.getReferenceManager().retain();\n+      }\n+      clear();\n+    }\n+    return buffers;\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @param callBack not used\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return getTransferPair(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(BufferAllocator allocator) {\n+    return getTransferPair(getName(), allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  public abstract TransferPair getTransferPair(String ref, BufferAllocator allocator);\n+\n+  /**\n+   * Transfer this vector'data to another vector. The memory associated\n+   * with this vector is transferred to the allocator of target vector\n+   * for accounting and management purposes.\n+   * @param target destination vector for transfer\n+   */\n+  public void transferTo(BaseLargeVariableWidthVector target) {\n+    compareTypes(target, \"transferTo\");\n+    target.clear();\n+    target.validityBuffer = transferBuffer(validityBuffer, target.allocator);\n+    target.valueBuffer = transferBuffer(valueBuffer, target.allocator);\n+    target.offsetBuffer = transferBuffer(offsetBuffer, target.allocator);\n+    target.setLastSet(this.lastSet);\n+    if (this.valueCount > 0) {\n+      target.setValueCount(this.valueCount);\n+    }\n+    clear();\n+  }\n+\n+  /**\n+   * Slice this vector at desired index and length and transfer the\n+   * corresponding data to the target vector.\n+   * @param startIndex start position of the split in source vector.\n+   * @param length length of the split.\n+   * @param target destination vector\n+   */\n+  public void splitAndTransferTo(int startIndex, int length,\n+                                 BaseLargeVariableWidthVector target) {\n+    Preconditions.checkArgument(startIndex >= 0 && startIndex < valueCount,\n+        \"Invalid startIndex: %s\", startIndex);\n+    Preconditions.checkArgument(startIndex + length <= valueCount,\n+        \"Invalid length: %s\", length);\n+    compareTypes(target, \"splitAndTransferTo\");\n+    target.clear();\n+    splitAndTransferValidityBuffer(startIndex, length, target);\n+    splitAndTransferOffsetBuffer(startIndex, length, target);\n+    target.setLastSet(length - 1);\n+    if (length > 0) {\n+      target.setValueCount(length);\n+    }\n+  }\n+\n+  /**\n+   * Transfer the offsets along with data. Unlike the data buffer, we cannot simply\n+   * slice the offset buffer for split and transfer. The reason is that offsets\n+   * in the target vector have to be adjusted and made relative to the staring\n+   * offset in source vector from the start index of split. This is why, we\n+   * need to explicitly allocate the offset buffer and set the adjusted offsets\n+   * in the target vector.\n+   */\n+  private void splitAndTransferOffsetBuffer(int startIndex, int length, BaseLargeVariableWidthVector target) {\n+    final long start = offsetBuffer.getLong((long) startIndex * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((long) (startIndex + length) * OFFSET_WIDTH);\n+    final long dataLength = end - start;\n+    target.allocateOffsetBuffer((long) (length + 1) * OFFSET_WIDTH);\n+    for (int i = 0; i < length + 1; i++) {\n+      final long relativeSourceOffset = offsetBuffer.getLong((long) (startIndex + i) * OFFSET_WIDTH) - start;\n+      target.offsetBuffer.setLong((long) i * OFFSET_WIDTH, relativeSourceOffset);\n+    }\n+    final ArrowBuf slicedBuffer = valueBuffer.slice(start, dataLength);\n+    target.valueBuffer = transferBuffer(slicedBuffer, target.allocator);\n+  }\n+\n+  /*\n+   * Transfer the validity.\n+   */\n+  private void splitAndTransferValidityBuffer(int startIndex, int length,\n+                                              BaseLargeVariableWidthVector target) {\n+    int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+    int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+    int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+    int offset = startIndex % 8;\n+\n+    if (length > 0) {\n+      if (offset == 0) {\n+        // slice\n+        if (target.validityBuffer != null) {\n+          target.validityBuffer.getReferenceManager().release();\n+        }\n+        target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+        target.validityBuffer.getReferenceManager().retain();\n+      } else {\n+        /* Copy data\n+         * When the first bit starts from the middle of a byte (offset != 0),\n+         * copy data from src BitVector.\n+         * Each byte in the target is composed by a part in i-th byte,\n+         * another part in (i+1)-th byte.\n+         */\n+        target.allocateValidityBuffer(byteSizeTarget);\n+\n+        for (int i = 0; i < byteSizeTarget - 1; i++) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer, firstByteSource + i, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer, firstByteSource + i + 1, offset);\n+\n+          target.validityBuffer.setByte(i, (b1 + b2));\n+        }\n+        /* Copying the last piece is done in the following manner:\n+         * if the source vector has 1 or more bytes remaining, we copy\n+         * the last piece as a byte formed by shifting data\n+         * from the current byte and the next byte.\n+         *\n+         * if the source vector has no more bytes remaining\n+         * (we are at the last byte), we copy the last piece as a byte\n+         * by shifting data from the current byte.\n+         */\n+        if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+              firstByteSource + byteSizeTarget - 1, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer,\n+              firstByteSource + byteSizeTarget, offset);\n+\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+        } else {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+              firstByteSource + byteSizeTarget - 1, offset);\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+        }\n+      }\n+    }\n+  }\n+\n+\n+  /*----------------------------------------------------------------*\n+   |                                                                |\n+   |                common getters and setters                      |\n+   |                                                                |\n+   *----------------------------------------------------------------*/\n+\n+\n+  /**\n+   * Get the number of elements that are null in the vector.\n+   *\n+   * @return the number of null elements.\n+   */\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  /**\n+   * Check if the given index is within the current value capacity\n+   * of the vector.\n+   *\n+   * @param index  position to check\n+   * @return true if index is within the current value capacity\n+   */\n+  public boolean isSafe(int index) {\n \n Review comment:\n   @siddharththeotia Thanks a lot for your attention. Currently, we are using int32 for all vector indices, and int64 for all ArrowBuf indices. \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-15T21:01:53.688+0000",
                    "updated": "2020-04-15T21:01:53.688+0000",
                    "started": "2020-04-15T21:01:53.688+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "423069",
                    "issueId": "13248477"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/worklog/423070",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on pull request #6425: ARROW-6111: [Java] Support LargeVarChar and LargeBinary types\nURL: https://github.com/apache/arrow/pull/6425#discussion_r391444002\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseLargeVariableWidthVector.java\n ##########\n @@ -0,0 +1,1361 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+/**\n+ * BaseLargeVariableWidthVector is a base class providing functionality for large strings/large bytes types.\n+ */\n+public abstract class BaseLargeVariableWidthVector extends BaseValueVector\n+    implements VariableWidthVector, FieldVector, VectorDefinitionSetter {\n+  private static final int DEFAULT_RECORD_BYTE_COUNT = 12;\n+  private static final int INITIAL_BYTE_COUNT = INITIAL_VALUE_ALLOCATION * DEFAULT_RECORD_BYTE_COUNT;\n+  private int lastValueCapacity;\n+  private long lastValueAllocationSizeInBytes;\n+\n+  /* protected members */\n+  public static final int OFFSET_WIDTH = 8; /* 8 byte unsigned int to track offsets */\n+  protected static final byte[] emptyByteArray = new byte[]{};\n+  protected ArrowBuf validityBuffer;\n+  protected ArrowBuf valueBuffer;\n+  protected ArrowBuf offsetBuffer;\n+  protected int valueCount;\n+  protected int lastSet;\n+  protected final Field field;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param field The field materialized by this vector.\n+   * @param allocator The allocator to use for creating/resizing buffers\n+   */\n+  public BaseLargeVariableWidthVector(Field field, final BufferAllocator allocator) {\n+    super(allocator);\n+    this.field = field;\n+    lastValueAllocationSizeInBytes = INITIAL_BYTE_COUNT;\n+    // -1 because we require one extra slot for the offset array.\n+    lastValueCapacity = INITIAL_VALUE_ALLOCATION - 1;\n+    valueCount = 0;\n+    lastSet = -1;\n+    offsetBuffer = allocator.getEmpty();\n+    validityBuffer = allocator.getEmpty();\n+    valueBuffer = allocator.getEmpty();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return field.getName();\n+  }\n+\n+  /**\n+   * Get buffer that manages the validity (NULL or NON-NULL nature) of\n+   * elements in the vector. Consider it as a buffer for internal bit vector\n+   * data structure.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  /**\n+   * Get the buffer that stores the data for elements in the vector.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    return valueBuffer;\n+  }\n+\n+  /**\n+   * buffer that stores the offsets for elements\n+   * in the vector. This operation is not supported for fixed-width vectors.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the offsets for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return offsetBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that manages the validity\n+   * (NULL or NON-NULL nature) of elements in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return validityBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the data for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getDataBufferAddress() {\n+    return valueBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   * @param valueCount desired number of elements in the vector\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount) {\n+    final long size = (long) valueCount * DEFAULT_RECORD_BYTE_COUNT;\n+    checkDataBufferSize(size);\n+    computeAndCheckOffsetsBufferSize(valueCount);\n+    lastValueAllocationSizeInBytes = size;\n+    lastValueCapacity = valueCount;\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   * @param valueCount desired number of elements in the vector\n+   * @param density average number of bytes per variable width element\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount, double density) {\n+    long size = Math.max((long)(valueCount * density), 1L);\n+    checkDataBufferSize(size);\n+    computeAndCheckOffsetsBufferSize(valueCount);\n+    lastValueAllocationSizeInBytes = size;\n+    lastValueCapacity = valueCount;\n+  }\n+\n+  /**\n+   * Get the density of this ListVector.\n+   * @return density\n+   */\n+  public double getDensity() {\n+    if (valueCount == 0) {\n+      return 0.0D;\n+    }\n+    final long startOffset = offsetBuffer.getLong(0);\n+    final long endOffset = offsetBuffer.getLong((long) valueCount * OFFSET_WIDTH);\n+    final double totalListSize = endOffset - startOffset;\n+    return totalListSize / valueCount;\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector.\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    final long offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n+    return capAtMaxInt(Math.min(offsetValueCapacity, getValidityBufferValueCapacity()));\n+  }\n+\n+  private long getValidityBufferValueCapacity() {\n+    return validityBuffer.capacity() * 8;\n+  }\n+\n+  private long getOffsetBufferValueCapacity() {\n+    return offsetBuffer.capacity() / OFFSET_WIDTH;\n+  }\n+\n+  /**\n+   * zero out the vector and the data in associated buffers.\n+   */\n+  public void zeroVector() {\n+    initValidityBuffer();\n+    initOffsetBuffer();\n+    valueBuffer.setZero(0, valueBuffer.capacity());\n+  }\n+\n+  /* zero out the validity buffer */\n+  private void initValidityBuffer() {\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+\n+  /* zero out the offset buffer */\n+  private void initOffsetBuffer() {\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+\n+  /**\n+   * Reset the vector to initial state. Same as {@link #zeroVector()}.\n+   * Note that this method doesn't release any memory.\n+   */\n+  public void reset() {\n+    zeroVector();\n+    lastSet = -1;\n+    valueCount = 0;\n+  }\n+\n+  /**\n+   * Close the vector and release the associated buffers.\n+   */\n+  @Override\n+  public void close() {\n+    clear();\n+  }\n+\n+  /**\n+   * Same as {@link #close()}.\n+   */\n+  @Override\n+  public void clear() {\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    valueBuffer = releaseBuffer(valueBuffer);\n+    offsetBuffer = releaseBuffer(offsetBuffer);\n+    lastSet = -1;\n+    valueCount = 0;\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Initialize the children in schema for this Field. This operation is a\n+   * NO-OP for scalar types since they don't have any children.\n+   * @param children the schema\n+   * @throws IllegalArgumentException if children is a non-empty list for scalar types.\n+   */\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (!children.isEmpty()) {\n+      throw new IllegalArgumentException(\"primitive type vector can not have children\");\n+    }\n+  }\n+\n+  /**\n+   * Get the inner child vectors.\n+   * @return list of child vectors for complex types, empty list for scalar vector types\n+   */\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return Collections.emptyList();\n+  }\n+\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+    ArrowBuf dataBuffer = ownBuffers.get(2);\n+\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = offBuffer.getReferenceManager().retain(offBuffer, allocator);\n+    valueBuffer.getReferenceManager().release();\n+    valueBuffer = dataBuffer.getReferenceManager().retain(dataBuffer, allocator);\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector.\n+   * @return the inner buffers.\n+   */\n+  public List<ArrowBuf> getFieldBuffers() {\n+    // before flight/IPC, we must bring the vector to a consistent state.\n+    // this is because, it is possible that the offset buffers of some trailing values\n+    // are not updated. this may cause some data in the data buffer being lost.\n+    // for details, please see TestValueVector#testUnloadVariableWidthVector.\n+    fillHoles(valueCount);\n+\n+    List<ArrowBuf> result = new ArrayList<>(3);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+    result.add(valueBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    valueBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+      valueBuffer.writerIndex(0);\n+    } else {\n+      final long lastDataOffset = getStartOffset(valueCount);\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((long) (valueCount + 1) * OFFSET_WIDTH);\n+      valueBuffer.writerIndex(lastDataOffset);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() {\n+    allocateNew(lastValueAllocationSizeInBytes, lastValueCapacity);\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector. See {@link #allocateNew(long, int)} for allocating memory for specific\n+   * number of elements in the vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  @Override\n+  public boolean allocateNewSafe() {\n+    try {\n+      allocateNew(lastValueAllocationSizeInBytes, lastValueCapacity);\n+      return true;\n+    } catch (Exception e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector to support storing at least the provided number of\n+   * elements in the vector. This method must be called prior to using the ValueVector.\n+   *\n+   * @param totalBytes desired total memory capacity\n+   * @param valueCount the desired number of elements in the vector\n+   * @throws org.apache.arrow.memory.OutOfMemoryException if memory allocation fails\n+   */\n+  @Override\n+  public void allocateNew(long totalBytes, int valueCount) {\n+    assert totalBytes >= 0;\n+\n+    checkDataBufferSize(totalBytes);\n+    computeAndCheckOffsetsBufferSize(valueCount);\n+\n+    /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(totalBytes, valueCount);\n+    } catch (Exception e) {\n+      clear();\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public void allocateNew(int valueCount) {\n+    allocateNew(lastValueAllocationSizeInBytes, valueCount);\n+  }\n+\n+  /* Check if the data buffer size is within bounds. */\n+  private void checkDataBufferSize(long size) {\n+    if (size > MAX_ALLOCATION_SIZE || size < 0) {\n+      throw new OversizedAllocationException(\"Memory required for vector \" +\n+          \" is (\" + size + \"), which is more than max allowed (\" + MAX_ALLOCATION_SIZE + \")\");\n+    }\n+  }\n+\n+  /*\n+   * Compute the buffer size required for 'valueCount' offsets and validity, and check if it's\n+   * within bounds.\n+   */\n+  private long computeAndCheckOffsetsBufferSize(int valueCount) {\n+    /* to track the end offset of last data element in vector, we need\n+     * an additional slot in offset buffer.\n+     */\n+    final long size = computeCombinedBufferSize(valueCount + 1, OFFSET_WIDTH);\n+    if (size > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Memory required for vector capacity \" +\n+          valueCount +\n+          \" is (\" + size + \"), which is more than max allowed (\" + MAX_ALLOCATION_SIZE + \")\");\n+    }\n+    return size;\n+  }\n+\n+  /* allocate the inner buffers */\n+  private void allocateBytes(final long valueBufferSize, final int valueCount) {\n+    /* allocate data buffer */\n+    long curSize = valueBufferSize;\n+    valueBuffer = allocator.buffer(curSize);\n+    valueBuffer.readerIndex(0);\n+\n+    /* allocate offset buffer and validity buffer */\n+    DataAndValidityBuffers buffers = allocFixedDataAndValidityBufs(valueCount + 1, OFFSET_WIDTH);\n+    offsetBuffer = buffers.getDataBuf();\n+    validityBuffer = buffers.getValidityBuf();\n+    initOffsetBuffer();\n+    initValidityBuffer();\n+\n+    lastValueCapacity = getValueCapacity();\n+    lastValueAllocationSizeInBytes = capAtMaxInt(valueBuffer.capacity());\n+  }\n+\n+  /* allocate offset buffer */\n+  private void allocateOffsetBuffer(final long size) {\n+    offsetBuffer = allocator.buffer(size);\n+    offsetBuffer.readerIndex(0);\n+    initOffsetBuffer();\n+  }\n+\n+  /* allocate validity buffer */\n+  private void allocateValidityBuffer(final long size) {\n+    validityBuffer = allocator.buffer(size);\n+    validityBuffer.readerIndex(0);\n+    initValidityBuffer();\n+  }\n+\n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  public void reAlloc() {\n+    reallocDataBuffer();\n+    reallocValidityAndOffsetBuffers();\n+  }\n+\n+  /**\n+   * Reallocate the data buffer. Data Buffer stores the actual data for\n+   * LARGEVARCHAR or LARGEVARBINARY elements in the vector. The behavior is to double\n+   * the size of buffer.\n+   * @throws OversizedAllocationException if the desired new size is more than\n+   *                                      max allowed\n+   * @throws OutOfMemoryException if the internal memory allocation fails\n+   */\n+  public void reallocDataBuffer() {\n+    final long currentBufferCapacity = valueBuffer.capacity();\n+    long newAllocationSize = currentBufferCapacity * 2;\n+    if (newAllocationSize == 0) {\n+      if (lastValueAllocationSizeInBytes > 0) {\n+        newAllocationSize = lastValueAllocationSizeInBytes;\n+      } else {\n+        newAllocationSize = INITIAL_BYTE_COUNT * 2;\n+      }\n+    }\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    checkDataBufferSize(newAllocationSize);\n+\n+    final ArrowBuf newBuf = allocator.buffer(newAllocationSize);\n+    newBuf.setBytes(0, valueBuffer, 0, currentBufferCapacity);\n+    valueBuffer.getReferenceManager().release();\n+    valueBuffer = newBuf;\n+    lastValueAllocationSizeInBytes = valueBuffer.capacity();\n+  }\n+\n+  /**\n+   * Reallocate the validity and offset buffers for this vector. Validity\n+   * buffer is used to track the NULL or NON-NULL nature of elements in\n+   * the vector and offset buffer is used to store the lengths of variable\n+   * width elements in the vector.\n+   *\n+   * <p>Note that data buffer for variable length vectors moves independent\n+   * of the companion validity and offset buffers. This is in\n+   * contrast to what we have for fixed width vectors.\n+   *\n+   * <p>So even though we may have setup an initial capacity of 1024\n+   * elements in the vector, it is quite possible\n+   * that we need to reAlloc() the data buffer when we are setting\n+   * the 5th element in the vector simply because previous\n+   * variable length elements have exhausted the buffer capacity.\n+   * However, we really don't need to reAlloc() validity and\n+   * offset buffers until we try to set the 1025th element\n+   * This is why we do a separate check for safe methods to\n+   * determine which buffer needs reallocation.\n+   * @throws OversizedAllocationException if the desired new size is more than\n+   *                                      max allowed\n+   * @throws OutOfMemoryException if the internal memory allocation fails\n+   */\n+  public void reallocValidityAndOffsetBuffers() {\n+    int targetOffsetCount = capAtMaxInt((offsetBuffer.capacity() / OFFSET_WIDTH) * 2);\n+    if (targetOffsetCount == 0) {\n+      if (lastValueCapacity > 0) {\n+        targetOffsetCount = (lastValueCapacity + 1);\n+      } else {\n+        targetOffsetCount = 2 * (INITIAL_VALUE_ALLOCATION + 1);\n+      }\n+    }\n+    computeAndCheckOffsetsBufferSize(targetOffsetCount);\n+\n+    DataAndValidityBuffers buffers = allocFixedDataAndValidityBufs(targetOffsetCount, OFFSET_WIDTH);\n+    final ArrowBuf newOffsetBuffer = buffers.getDataBuf();\n+    newOffsetBuffer.setBytes(0, offsetBuffer, 0, offsetBuffer.capacity());\n+    newOffsetBuffer.setZero(offsetBuffer.capacity(), newOffsetBuffer.capacity() - offsetBuffer.capacity());\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = newOffsetBuffer;\n+\n+    final ArrowBuf newValidityBuffer = buffers.getValidityBuf();\n+    newValidityBuffer.setBytes(0, validityBuffer, 0, validityBuffer.capacity());\n+    newValidityBuffer.setZero(validityBuffer.capacity(), newValidityBuffer.capacity() - validityBuffer.capacity());\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = newValidityBuffer;\n+\n+    lastValueCapacity = getValueCapacity();\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying data buffer.\n+   * @return number of bytes in the data buffer\n+   */\n+  @Override\n+  public int getByteCapacity() {\n+    return capAtMaxInt(valueBuffer.capacity());\n+  }\n+\n+  @Override\n+  public int sizeOfValueBuffer() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    return capAtMaxInt(offsetBuffer.getLong((long) valueCount * OFFSET_WIDTH));\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector.\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    return getBufferSizeFor(this.valueCount);\n+  }\n+\n+  /**\n+   * Get the potential buffer size for a particular number of records.\n+   * @param valueCount desired number of elements in the vector\n+   * @return estimated size of underlying buffers if the vector holds\n+   *         a given number of elements\n+   */\n+  @Override\n+  public int getBufferSizeFor(final int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+\n+    final long validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    final long offsetBufferSize = (long) (valueCount + 1) * OFFSET_WIDTH;\n+    /* get the end offset for this valueCount */\n+    final long dataBufferSize = offsetBuffer.getLong((long) valueCount * OFFSET_WIDTH);\n+    return capAtMaxInt(validityBufferSize + offsetBufferSize + dataBufferSize);\n+  }\n+\n+  /**\n+   * Get information about how this field is materialized.\n+   * @return the field corresponding to this vector\n+   */\n+  @Override\n+  public Field getField() {\n+    return field;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    final ArrowBuf[] buffers;\n+    setReaderAndWriterIndex();\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = new ArrowBuf[3];\n+      buffers[0] = validityBuffer;\n+      buffers[1] = offsetBuffer;\n+      buffers[2] = valueBuffer;\n+    }\n+    if (clear) {\n+      for (final ArrowBuf buffer : buffers) {\n+        buffer.getReferenceManager().retain();\n+      }\n+      clear();\n+    }\n+    return buffers;\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @param callBack not used\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return getTransferPair(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(BufferAllocator allocator) {\n+    return getTransferPair(getName(), allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  public abstract TransferPair getTransferPair(String ref, BufferAllocator allocator);\n+\n+  /**\n+   * Transfer this vector'data to another vector. The memory associated\n+   * with this vector is transferred to the allocator of target vector\n+   * for accounting and management purposes.\n+   * @param target destination vector for transfer\n+   */\n+  public void transferTo(BaseLargeVariableWidthVector target) {\n+    compareTypes(target, \"transferTo\");\n+    target.clear();\n+    target.validityBuffer = transferBuffer(validityBuffer, target.allocator);\n+    target.valueBuffer = transferBuffer(valueBuffer, target.allocator);\n+    target.offsetBuffer = transferBuffer(offsetBuffer, target.allocator);\n+    target.setLastSet(this.lastSet);\n+    if (this.valueCount > 0) {\n+      target.setValueCount(this.valueCount);\n+    }\n+    clear();\n+  }\n+\n+  /**\n+   * Slice this vector at desired index and length and transfer the\n+   * corresponding data to the target vector.\n+   * @param startIndex start position of the split in source vector.\n+   * @param length length of the split.\n+   * @param target destination vector\n+   */\n+  public void splitAndTransferTo(int startIndex, int length,\n+                                 BaseLargeVariableWidthVector target) {\n+    Preconditions.checkArgument(startIndex >= 0 && startIndex < valueCount,\n+        \"Invalid startIndex: %s\", startIndex);\n+    Preconditions.checkArgument(startIndex + length <= valueCount,\n+        \"Invalid length: %s\", length);\n+    compareTypes(target, \"splitAndTransferTo\");\n+    target.clear();\n+    splitAndTransferValidityBuffer(startIndex, length, target);\n+    splitAndTransferOffsetBuffer(startIndex, length, target);\n+    target.setLastSet(length - 1);\n+    if (length > 0) {\n+      target.setValueCount(length);\n+    }\n+  }\n+\n+  /**\n+   * Transfer the offsets along with data. Unlike the data buffer, we cannot simply\n+   * slice the offset buffer for split and transfer. The reason is that offsets\n+   * in the target vector have to be adjusted and made relative to the staring\n+   * offset in source vector from the start index of split. This is why, we\n+   * need to explicitly allocate the offset buffer and set the adjusted offsets\n+   * in the target vector.\n+   */\n+  private void splitAndTransferOffsetBuffer(int startIndex, int length, BaseLargeVariableWidthVector target) {\n+    final long start = offsetBuffer.getLong((long) startIndex * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((long) (startIndex + length) * OFFSET_WIDTH);\n+    final long dataLength = end - start;\n+    target.allocateOffsetBuffer((long) (length + 1) * OFFSET_WIDTH);\n+    for (int i = 0; i < length + 1; i++) {\n+      final long relativeSourceOffset = offsetBuffer.getLong((long) (startIndex + i) * OFFSET_WIDTH) - start;\n+      target.offsetBuffer.setLong((long) i * OFFSET_WIDTH, relativeSourceOffset);\n+    }\n+    final ArrowBuf slicedBuffer = valueBuffer.slice(start, dataLength);\n+    target.valueBuffer = transferBuffer(slicedBuffer, target.allocator);\n+  }\n+\n+  /*\n+   * Transfer the validity.\n+   */\n+  private void splitAndTransferValidityBuffer(int startIndex, int length,\n+                                              BaseLargeVariableWidthVector target) {\n+    int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+    int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+    int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+    int offset = startIndex % 8;\n+\n+    if (length > 0) {\n+      if (offset == 0) {\n+        // slice\n+        if (target.validityBuffer != null) {\n+          target.validityBuffer.getReferenceManager().release();\n+        }\n+        target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+        target.validityBuffer.getReferenceManager().retain();\n+      } else {\n+        /* Copy data\n+         * When the first bit starts from the middle of a byte (offset != 0),\n+         * copy data from src BitVector.\n+         * Each byte in the target is composed by a part in i-th byte,\n+         * another part in (i+1)-th byte.\n+         */\n+        target.allocateValidityBuffer(byteSizeTarget);\n+\n+        for (int i = 0; i < byteSizeTarget - 1; i++) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer, firstByteSource + i, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer, firstByteSource + i + 1, offset);\n+\n+          target.validityBuffer.setByte(i, (b1 + b2));\n+        }\n+        /* Copying the last piece is done in the following manner:\n+         * if the source vector has 1 or more bytes remaining, we copy\n+         * the last piece as a byte formed by shifting data\n+         * from the current byte and the next byte.\n+         *\n+         * if the source vector has no more bytes remaining\n+         * (we are at the last byte), we copy the last piece as a byte\n+         * by shifting data from the current byte.\n+         */\n+        if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+              firstByteSource + byteSizeTarget - 1, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer,\n+              firstByteSource + byteSizeTarget, offset);\n+\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+        } else {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+              firstByteSource + byteSizeTarget - 1, offset);\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+        }\n+      }\n+    }\n+  }\n+\n+\n+  /*----------------------------------------------------------------*\n+   |                                                                |\n+   |                common getters and setters                      |\n+   |                                                                |\n+   *----------------------------------------------------------------*/\n+\n+\n+  /**\n+   * Get the number of elements that are null in the vector.\n+   *\n+   * @return the number of null elements.\n+   */\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  /**\n+   * Check if the given index is within the current value capacity\n+   * of the vector.\n+   *\n+   * @param index  position to check\n+   * @return true if index is within the current value capacity\n+   */\n+  public boolean isSafe(int index) {\n \n Review comment:\n   @siddharthteotia Thanks a lot for your attention. Currently, we are using int32 for all vector indices, and int64 for all ArrowBuf indices. \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-15T21:02:04.657+0000",
                    "updated": "2020-04-15T21:02:04.657+0000",
                    "started": "2020-04-15T21:02:04.657+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "423070",
                    "issueId": "13248477"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 31800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@71794c77[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@37478e49[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@16b87376[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@1d86822e[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1c5f3da0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@7de5cdc5[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@281332cc[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@1ad5212[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@64faddba[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@37a2af05[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6967e6f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@6dc0916d[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 31800,
        "customfield_12312520": null,
        "customfield_12312521": "Wed May 27 21:54:22 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-05-27T21:54:22.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-6111/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2019-08-02T03:42:50.000+0000",
        "updated": "2020-07-29T19:21:54.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "8h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 31800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Java] Support LargeVarChar and LargeBinary types and add integration test with C++",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/comment/16898527",
                    "id": "16898527",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=tianchen92",
                        "name": "tianchen92",
                        "key": "tianchen92",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=tianchen92&avatarId=40800",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tianchen92&avatarId=40800",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tianchen92&avatarId=40800",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tianchen92&avatarId=40800"
                        },
                        "displayName": "Ji Liu",
                        "active": true,
                        "timeZone": "Asia/Gaza"
                    },
                    "body": "[~emkornfield@gmail.com] Any more description? ",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=tianchen92",
                        "name": "tianchen92",
                        "key": "tianchen92",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=tianchen92&avatarId=40800",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tianchen92&avatarId=40800",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tianchen92&avatarId=40800",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tianchen92&avatarId=40800"
                        },
                        "displayName": "Ji Liu",
                        "active": true,
                        "timeZone": "Asia/Gaza"
                    },
                    "created": "2019-08-02T03:48:45.745+0000",
                    "updated": "2019-08-02T03:48:45.745+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/comment/16898533",
                    "id": "16898533",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
                        "name": "emkornfield@gmail.com",
                        "key": "emkornfield@gmail.com",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Micah Kornfield",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "[~tianchen92] Please hold off on this\u00a0until\u00a0ARROW-6112 is either approved or we decide we don't want to do it.\u00a0 I was thinking of doing this myself, since I've already done most of the work for LargeList and the changes are similar, but we can figure out division of work after details of ARROW-6112 are worked out..\u00a0\u00a0ARROW-750 has the details on the new types.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
                        "name": "emkornfield@gmail.com",
                        "key": "emkornfield@gmail.com",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Micah Kornfield",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2019-08-02T03:56:36.803+0000",
                    "updated": "2019-08-02T03:56:36.803+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/comment/16898536",
                    "id": "16898536",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=tianchen92",
                        "name": "tianchen92",
                        "key": "tianchen92",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=tianchen92&avatarId=40800",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tianchen92&avatarId=40800",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tianchen92&avatarId=40800",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tianchen92&avatarId=40800"
                        },
                        "displayName": "Ji Liu",
                        "active": true,
                        "timeZone": "Asia/Gaza"
                    },
                    "body": "Sure, Feel free to take this yourself, IMO, just saw this was unassigned. :)\r\nAlso I would like to help if needed.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=tianchen92",
                        "name": "tianchen92",
                        "key": "tianchen92",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=tianchen92&avatarId=40800",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tianchen92&avatarId=40800",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tianchen92&avatarId=40800",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tianchen92&avatarId=40800"
                        },
                        "displayName": "Ji Liu",
                        "active": true,
                        "timeZone": "Asia/Gaza"
                    },
                    "created": "2019-08-02T04:02:08.185+0000",
                    "updated": "2019-08-02T04:02:56.273+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/comment/17028700",
                    "id": "17028700",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=fan_li_ya",
                        "name": "fan_li_ya",
                        "key": "fan_li_ya",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Liya Fan",
                        "active": true,
                        "timeZone": "Asia/Shanghai"
                    },
                    "body": "As a follow up for ARROW-7610, we need these vectors for cases when the buffer size exceeds 2GB. ",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=fan_li_ya",
                        "name": "fan_li_ya",
                        "key": "fan_li_ya",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Liya Fan",
                        "active": true,
                        "timeZone": "Asia/Shanghai"
                    },
                    "created": "2020-02-03T06:56:12.828+0000",
                    "updated": "2020-02-03T06:56:12.828+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248477/comment/17118134",
                    "id": "17118134",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
                        "name": "bryanc",
                        "key": "bryanc",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
                        },
                        "displayName": "Bryan Cutler",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Issue resolved by pull request 6425\n[https://github.com/apache/arrow/pull/6425]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
                        "name": "bryanc",
                        "key": "bryanc",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
                        },
                        "displayName": "Bryan Cutler",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2020-05-27T21:54:22.073+0000",
                    "updated": "2020-05-27T21:54:22.073+0000"
                }
            ],
            "maxResults": 5,
            "total": 5,
            "startAt": 0
        },
        "customfield_12311820": "0|z059jk:",
        "customfield_12314139": null
    }
}