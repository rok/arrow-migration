{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13195653",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13195653",
    "key": "ARROW-3687",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12343858",
                "id": "12343858",
                "description": "",
                "name": "0.12.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-01-20"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
            "name": "Minor",
            "id": "4"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=paddyhoran",
            "name": "paddyhoran",
            "key": "paddyhoran",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Paddy Horan",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333773",
                "id": "12333773",
                "name": "Rust"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=paddyhoran",
            "name": "paddyhoran",
            "key": "paddyhoran",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Paddy Horan",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=paddyhoran",
            "name": "paddyhoran",
            "key": "paddyhoran",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Paddy Horan",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 5400,
            "total": 5400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 5400,
            "total": 5400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3687/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 9,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13195653/worklog/173377",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paddyhoran opened a new pull request #3142: ARROW-3687: [Rust] Anything measuring array slots should be `usize`\nURL: https://github.com/apache/arrow/pull/3142\n \n \n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-10T03:31:27.346+0000",
                    "updated": "2018-12-10T03:31:27.346+0000",
                    "started": "2018-12-10T03:31:27.346+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "173377",
                    "issueId": "13195653"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13195653/worklog/173535",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on issue #3142: ARROW-3687: [Rust] Anything measuring array slots should be `usize`\nURL: https://github.com/apache/arrow/pull/3142#issuecomment-445792266\n \n \n   Because this brakes backward compatibility scheduling it to `0.13` release is reasonable. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-10T12:02:39.938+0000",
                    "updated": "2018-12-10T12:02:39.938+0000",
                    "started": "2018-12-10T12:02:39.938+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "173535",
                    "issueId": "13195653"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13195653/worklog/173551",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "crepererum commented on issue #3142: ARROW-3687: [Rust] Anything measuring array slots should be `usize`\nURL: https://github.com/apache/arrow/pull/3142#issuecomment-445812377\n \n \n   +1\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-10T13:20:14.691+0000",
                    "updated": "2018-12-10T13:20:14.691+0000",
                    "started": "2018-12-10T13:20:14.691+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "173551",
                    "issueId": "13195653"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13195653/worklog/173552",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #3142: ARROW-3687: [Rust] Anything measuring array slots should be `usize`\nURL: https://github.com/apache/arrow/pull/3142#issuecomment-445812560\n \n \n   Do we need to preserve backwards compatibility in the Rust library yet? \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-10T13:20:50.477+0000",
                    "updated": "2018-12-10T13:20:50.477+0000",
                    "started": "2018-12-10T13:20:50.476+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "173552",
                    "issueId": "13195653"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13195653/worklog/173565",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "crepererum commented on issue #3142: ARROW-3687: [Rust] Anything measuring array slots should be `usize`\nURL: https://github.com/apache/arrow/pull/3142#issuecomment-445817083\n \n \n   @wesm I don't think so, since we're still making many changes to the library and (IMHO) it's still somewhat in the design phase. Also, there are [no public consumers yet](https://crates.io/crates/arrow/reverse_dependencies).\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-10T13:36:30.992+0000",
                    "updated": "2018-12-10T13:36:30.992+0000",
                    "started": "2018-12-10T13:36:30.991+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "173565",
                    "issueId": "13195653"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13195653/worklog/173572",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on issue #3142: ARROW-3687: [Rust] Anything measuring array slots should be `usize`\nURL: https://github.com/apache/arrow/pull/3142#issuecomment-445818973\n \n \n   Cool! So re-schedule to `0.12`?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-10T13:42:22.875+0000",
                    "updated": "2018-12-10T13:42:22.875+0000",
                    "started": "2018-12-10T13:42:22.874+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "173572",
                    "issueId": "13195653"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13195653/worklog/173581",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on issue #3142: ARROW-3687: [Rust] Anything measuring array slots should be `usize`\nURL: https://github.com/apache/arrow/pull/3142#issuecomment-445820492\n \n \n   I would like to see this in 0.12\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-10T13:47:16.388+0000",
                    "updated": "2018-12-10T13:47:16.388+0000",
                    "started": "2018-12-10T13:47:16.388+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "173581",
                    "issueId": "13195653"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13195653/worklog/173646",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on issue #3142: ARROW-3687: [Rust] Anything measuring array slots should be `usize`\nURL: https://github.com/apache/arrow/pull/3142#issuecomment-445856186\n \n \n   Then merging it!\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-10T15:29:19.288+0000",
                    "updated": "2018-12-10T15:29:19.288+0000",
                    "started": "2018-12-10T15:29:19.288+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "173646",
                    "issueId": "13195653"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13195653/worklog/173648",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs closed pull request #3142: ARROW-3687: [Rust] Anything measuring array slots should be `usize`\nURL: https://github.com/apache/arrow/pull/3142\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/rust/src/array.rs b/rust/src/array.rs\nindex ca1d2a5cdb..51bc8d993c 100644\n--- a/rust/src/array.rs\n+++ b/rust/src/array.rs\n@@ -47,27 +47,27 @@ pub trait Array: Send + Sync {\n     }\n \n     /// Returns the length (i.e., number of elements) of this array\n-    fn len(&self) -> i64 {\n+    fn len(&self) -> usize {\n         self.data().len()\n     }\n \n     /// Returns the offset of this array\n-    fn offset(&self) -> i64 {\n+    fn offset(&self) -> usize {\n         self.data().offset()\n     }\n \n     /// Returns whether the element at index `i` is null\n-    fn is_null(&self, i: i64) -> bool {\n+    fn is_null(&self, i: usize) -> bool {\n         self.data().is_null(i)\n     }\n \n     /// Returns whether the element at index `i` is not null\n-    fn is_valid(&self, i: i64) -> bool {\n+    fn is_valid(&self, i: usize) -> bool {\n         self.data().is_valid(i)\n     }\n \n     /// Returns the total number of nulls in this array\n-    fn null_count(&self) -> i64 {\n+    fn null_count(&self) -> usize {\n         self.data().null_count()\n     }\n }\n@@ -158,7 +158,7 @@ impl<T: ArrowPrimitiveType> Array for PrimitiveArray<T> {\n /// Implementation for primitive arrays with numeric types.\n /// Boolean arrays are bit-packed and so implemented separately.\n impl<T: ArrowNumericType> PrimitiveArray<T> {\n-    pub fn new(length: i64, values: Buffer, null_count: i64, offset: i64) -> Self {\n+    pub fn new(length: usize, values: Buffer, null_count: usize, offset: usize) -> Self {\n         let array_data = ArrayData::builder(T::get_data_type())\n             .len(length)\n             .add_buffer(values)\n@@ -176,7 +176,7 @@ impl<T: ArrowNumericType> PrimitiveArray<T> {\n     }\n \n     /// Returns the length of this array\n-    pub fn len(&self) -> i64 {\n+    pub fn len(&self) -> usize {\n         self.data.len()\n     }\n \n@@ -188,16 +188,16 @@ impl<T: ArrowNumericType> PrimitiveArray<T> {\n     /// Returns the primitive value at index `i`.\n     ///\n     /// Note this doesn't do any bound checking, for performance reason.\n-    pub fn value(&self, i: i64) -> T::Native {\n+    pub fn value(&self, i: usize) -> T::Native {\n         unsafe { *(self.raw_values().offset(i as isize)) }\n     }\n \n     /// Returns a slice for the given offset and length\n     ///\n     /// Note this doesn't do any bound checking, for performance reason.\n-    pub fn value_slice(&self, offset: i64, len: i64) -> &[T::Native] {\n-        let raw = unsafe { std::slice::from_raw_parts(self.raw_values(), self.len() as usize) };\n-        &raw[offset as usize..offset as usize + len as usize]\n+    pub fn value_slice(&self, offset: usize, len: usize) -> &[T::Native] {\n+        let raw = unsafe { std::slice::from_raw_parts(self.raw_values(), self.len()) };\n+        &raw[offset..offset + len]\n     }\n \n     /// Returns the minimum value in the array, according to the natural order.\n@@ -220,7 +220,7 @@ impl<T: ArrowNumericType> PrimitiveArray<T> {\n             if data.is_null(i) {\n                 continue;\n             }\n-            let m = self.value(i as i64);\n+            let m = self.value(i);\n             match n {\n                 None => n = Some(m),\n                 Some(nn) => {\n@@ -234,14 +234,14 @@ impl<T: ArrowNumericType> PrimitiveArray<T> {\n     }\n \n     // Returns a new primitive array builder\n-    pub fn builder(capacity: i64) -> PrimitiveArrayBuilder<T> {\n+    pub fn builder(capacity: usize) -> PrimitiveArrayBuilder<T> {\n         PrimitiveArrayBuilder::<T>::new(capacity)\n     }\n }\n \n /// Specific implementation for Boolean arrays due to bit-packing\n impl PrimitiveArray<BooleanType> {\n-    pub fn new(length: i64, values: Buffer, null_count: i64, offset: i64) -> Self {\n+    pub fn new(length: usize, values: Buffer, null_count: usize, offset: usize) -> Self {\n         let array_data = ArrayData::builder(DataType::Boolean)\n             .len(length)\n             .add_buffer(values)\n@@ -259,14 +259,14 @@ impl PrimitiveArray<BooleanType> {\n     }\n \n     /// Returns the boolean value at index `i`.\n-    pub fn value(&self, i: i64) -> bool {\n+    pub fn value(&self, i: usize) -> bool {\n         let offset = i + self.offset();\n         assert!(offset < self.data.len());\n-        unsafe { bit_util::get_bit_raw(self.raw_values.get() as *const u8, offset as usize) }\n+        unsafe { bit_util::get_bit_raw(self.raw_values.get() as *const u8, offset) }\n     }\n \n     // Returns a new primitive array builder\n-    pub fn builder(capacity: i64) -> BooleanBuilder {\n+    pub fn builder(capacity: usize) -> BooleanBuilder {\n         BooleanBuilder::new(capacity)\n     }\n }\n@@ -279,7 +279,7 @@ macro_rules! def_numeric_from_vec {\n         impl From<Vec<$native_ty>> for PrimitiveArray<$ty> {\n             fn from(data: Vec<$native_ty>) -> Self {\n                 let array_data = ArrayData::builder($ty_id)\n-                    .len(data.len() as i64)\n+                    .len(data.len())\n                     .add_buffer(Buffer::from(data.to_byte_slice()))\n                     .build();\n                 PrimitiveArray::from(array_data)\n@@ -290,7 +290,7 @@ macro_rules! def_numeric_from_vec {\n         impl From<Vec<Option<$native_ty>>> for PrimitiveArray<$ty> {\n             fn from(data: Vec<Option<$native_ty>>) -> Self {\n                 let data_len = data.len();\n-                let num_bytes = bit_util::ceil(data_len as i64, 8) as usize;\n+                let num_bytes = bit_util::ceil(data_len, 8);\n                 let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n                 let mut val_buf = MutableBuffer::new(data_len * mem::size_of::<$native_ty>());\n \n@@ -310,7 +310,7 @@ macro_rules! def_numeric_from_vec {\n                 }\n \n                 let array_data = ArrayData::builder($ty_id)\n-                    .len(data_len as i64)\n+                    .len(data_len)\n                     .add_buffer(val_buf.freeze())\n                     .null_bit_buffer(null_buf.freeze())\n                     .build();\n@@ -334,7 +334,7 @@ def_numeric_from_vec!(Float64Type, f64, DataType::Float64);\n /// Constructs a boolean array from a vector. Should only be used for testing.\n impl From<Vec<bool>> for BooleanArray {\n     fn from(data: Vec<bool>) -> Self {\n-        let num_byte = bit_util::ceil(data.len() as i64, 8) as usize;\n+        let num_byte = bit_util::ceil(data.len(), 8);\n         let mut mut_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n         {\n             let mut_slice = mut_buf.data_mut();\n@@ -345,7 +345,7 @@ impl From<Vec<bool>> for BooleanArray {\n             }\n         }\n         let array_data = ArrayData::builder(DataType::Boolean)\n-            .len(data.len() as i64)\n+            .len(data.len())\n             .add_buffer(mut_buf.freeze())\n             .build();\n         BooleanArray::from(array_data)\n@@ -354,8 +354,8 @@ impl From<Vec<bool>> for BooleanArray {\n \n impl From<Vec<Option<bool>>> for BooleanArray {\n     fn from(data: Vec<Option<bool>>) -> Self {\n-        let data_len = data.len() as i64;\n-        let num_byte = bit_util::ceil(data_len, 8) as usize;\n+        let data_len = data.len();\n+        let num_byte = bit_util::ceil(data_len, 8);\n         let mut null_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n         let mut val_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n \n@@ -425,7 +425,7 @@ impl ListArray {\n     ///\n     /// Note this doesn't do any bound checking, for performance reason.\n     #[inline]\n-    pub fn value_offset(&self, i: i64) -> i32 {\n+    pub fn value_offset(&self, i: usize) -> i32 {\n         self.value_offset_at(self.data.offset() + i)\n     }\n \n@@ -433,13 +433,13 @@ impl ListArray {\n     ///\n     /// Note this doesn't do any bound checking, for performance reason.\n     #[inline]\n-    pub fn value_length(&self, mut i: i64) -> i32 {\n+    pub fn value_length(&self, mut i: usize) -> i32 {\n         i += self.data.offset();\n         self.value_offset_at(i + 1) - self.value_offset_at(i)\n     }\n \n     #[inline]\n-    fn value_offset_at(&self, i: i64) -> i32 {\n+    fn value_offset_at(&self, i: usize) -> i32 {\n         unsafe { *self.value_offsets.get().offset(i as isize) }\n     }\n }\n@@ -503,11 +503,8 @@ pub struct BinaryArray {\n \n impl BinaryArray {\n     /// Returns the element at index `i` as a byte slice.\n-    pub fn get_value(&self, i: i64) -> &[u8] {\n-        assert!(\n-            i >= 0 && i < self.data.len(),\n-            \"BinaryArray out of bounds access\"\n-        );\n+    pub fn get_value(&self, i: usize) -> &[u8] {\n+        assert!(i < self.data.len(), \"BinaryArray out of bounds access\");\n         let offset = i.checked_add(self.data.offset()).unwrap();\n         unsafe {\n             let pos = self.value_offset_at(offset);\n@@ -521,7 +518,7 @@ impl BinaryArray {\n     /// Returns the element at index `i` as a string.\n     ///\n     /// Note this doesn't do any bound checking, for performance reason.\n-    pub fn get_string(&self, i: i64) -> String {\n+    pub fn get_string(&self, i: usize) -> String {\n         let slice = self.get_value(i);\n         unsafe { String::from_utf8_unchecked(Vec::from(slice)) }\n     }\n@@ -530,7 +527,7 @@ impl BinaryArray {\n     ///\n     /// Note this doesn't do any bound checking, for performance reason.\n     #[inline]\n-    pub fn value_offset(&self, i: i64) -> i32 {\n+    pub fn value_offset(&self, i: usize) -> i32 {\n         self.value_offset_at(self.data.offset() + i)\n     }\n \n@@ -538,13 +535,13 @@ impl BinaryArray {\n     ///\n     /// Note this doesn't do any bound checking, for performance reason.\n     #[inline]\n-    pub fn value_length(&self, mut i: i64) -> i32 {\n+    pub fn value_length(&self, mut i: usize) -> i32 {\n         i += self.data.offset();\n         self.value_offset_at(i + 1) - self.value_offset_at(i)\n     }\n \n     #[inline]\n-    fn value_offset_at(&self, i: i64) -> i32 {\n+    fn value_offset_at(&self, i: usize) -> i32 {\n         unsafe { *self.value_offsets.get().offset(i as isize) }\n     }\n }\n@@ -582,7 +579,7 @@ impl<'a> From<Vec<&'a str>> for BinaryArray {\n             values.extend_from_slice(s.as_bytes());\n         }\n         let array_data = ArrayData::builder(DataType::Utf8)\n-            .len(v.len() as i64)\n+            .len(v.len())\n             .add_buffer(Buffer::from(offsets.to_byte_slice()))\n             .add_buffer(Buffer::from(&values[..]))\n             .build();\n@@ -664,7 +661,7 @@ impl Array for StructArray {\n     }\n \n     /// Returns the length (i.e., number of elements) of this array\n-    fn len(&self) -> i64 {\n+    fn len(&self) -> usize {\n         self.boxed_fields[0].len()\n     }\n }\n@@ -876,8 +873,8 @@ mod tests {\n         assert_eq!(6, list_array.value_offset(2));\n         assert_eq!(2, list_array.value_length(2));\n         for i in 0..3 {\n-            assert!(list_array.is_valid(i as i64));\n-            assert!(!list_array.is_null(i as i64));\n+            assert!(list_array.is_valid(i));\n+            assert!(!list_array.is_null(i));\n         }\n \n         // Now test with a non-zero offset\n@@ -991,8 +988,8 @@ mod tests {\n         assert_eq!(5, binary_array.value_offset(2));\n         assert_eq!(7, binary_array.value_length(2));\n         for i in 0..3 {\n-            assert!(binary_array.is_valid(i as i64));\n-            assert!(!binary_array.is_null(i as i64));\n+            assert!(binary_array.is_valid(i));\n+            assert!(!binary_array.is_null(i));\n         }\n \n         // Test binary array with offset\ndiff --git a/rust/src/array_data.rs b/rust/src/array_data.rs\nindex b288d4a804..36a817ee57 100644\n--- a/rust/src/array_data.rs\n+++ b/rust/src/array_data.rs\n@@ -31,13 +31,13 @@ pub struct ArrayData {\n     data_type: DataType,\n \n     /// The number of elements in this array data\n-    len: i64,\n+    len: usize,\n \n     /// The number of null elements in this array data\n-    null_count: i64,\n+    null_count: usize,\n \n     /// The offset into this array data\n-    offset: i64,\n+    offset: usize,\n \n     /// The buffers for this array data. Note that depending on the array types, this\n     /// could hold different kinds of buffers (e.g., value buffer, value offset buffer)\n@@ -54,25 +54,28 @@ pub struct ArrayData {\n }\n \n pub type ArrayDataRef = Arc<ArrayData>;\n-pub const UNKNOWN_NULL_COUNT: i64 = -1;\n \n impl ArrayData {\n     pub fn new(\n         data_type: DataType,\n-        len: i64,\n-        mut null_count: i64,\n+        len: usize,\n+        null_count: Option<usize>,\n         null_bit_buffer: Option<Buffer>,\n-        offset: i64,\n+        offset: usize,\n         buffers: Vec<Buffer>,\n         child_data: Vec<ArrayDataRef>,\n     ) -> Self {\n-        if null_count < 0 {\n-            null_count = if let Some(ref buf) = null_bit_buffer {\n-                len - bit_util::count_set_bits_offset(buf.data(), offset as usize)\n-            } else {\n-                0\n-            };\n-        }\n+        let null_count = match null_count {\n+            None => {\n+                if let Some(ref buf) = null_bit_buffer {\n+                    len.checked_sub(bit_util::count_set_bits_offset(buf.data(), offset))\n+                        .unwrap()\n+                } else {\n+                    0\n+                }\n+            }\n+            Some(null_count) => null_count,\n+        };\n         let null_bitmap = null_bit_buffer.map(Bitmap::from);\n         Self {\n             data_type,\n@@ -106,7 +109,7 @@ impl ArrayData {\n     }\n \n     /// Returns whether the element at index `i` is null\n-    pub fn is_null(&self, i: i64) -> bool {\n+    pub fn is_null(&self, i: usize) -> bool {\n         if let Some(ref b) = self.null_bitmap {\n             return !b.is_set(i);\n         }\n@@ -119,7 +122,7 @@ impl ArrayData {\n     }\n \n     /// Returns whether the element at index `i` is not null\n-    pub fn is_valid(&self, i: i64) -> bool {\n+    pub fn is_valid(&self, i: usize) -> bool {\n         if let Some(ref b) = self.null_bitmap {\n             return b.is_set(i);\n         }\n@@ -127,17 +130,17 @@ impl ArrayData {\n     }\n \n     /// Returns the length (i.e., number of elements) of this array\n-    pub fn len(&self) -> i64 {\n+    pub fn len(&self) -> usize {\n         self.len\n     }\n \n     /// Returns the offset of this array\n-    pub fn offset(&self) -> i64 {\n+    pub fn offset(&self) -> usize {\n         self.offset\n     }\n \n     /// Returns the total number of nulls in this array\n-    pub fn null_count(&self) -> i64 {\n+    pub fn null_count(&self) -> usize {\n         self.null_count\n     }\n }\n@@ -145,10 +148,10 @@ impl ArrayData {\n /// Builder for `ArrayData` type\n pub struct ArrayDataBuilder {\n     data_type: DataType,\n-    len: i64,\n-    null_count: i64,\n+    len: usize,\n+    null_count: Option<usize>,\n     null_bit_buffer: Option<Buffer>,\n-    offset: i64,\n+    offset: usize,\n     buffers: Vec<Buffer>,\n     child_data: Vec<ArrayDataRef>,\n }\n@@ -158,7 +161,7 @@ impl ArrayDataBuilder {\n         Self {\n             data_type,\n             len: 0,\n-            null_count: UNKNOWN_NULL_COUNT,\n+            null_count: None,\n             null_bit_buffer: None,\n             offset: 0,\n             buffers: vec![],\n@@ -166,13 +169,13 @@ impl ArrayDataBuilder {\n         }\n     }\n \n-    pub fn len(mut self, n: i64) -> Self {\n+    pub fn len(mut self, n: usize) -> Self {\n         self.len = n;\n         self\n     }\n \n-    pub fn null_count(mut self, n: i64) -> Self {\n-        self.null_count = n;\n+    pub fn null_count(mut self, n: usize) -> Self {\n+        self.null_count = Some(n);\n         self\n     }\n \n@@ -181,7 +184,7 @@ impl ArrayDataBuilder {\n         self\n     }\n \n-    pub fn offset(mut self, n: i64) -> Self {\n+    pub fn offset(mut self, n: usize) -> Self {\n         self.offset = n;\n         self\n     }\n@@ -230,7 +233,7 @@ mod tests {\n \n     #[test]\n     fn test_new() {\n-        let arr_data = ArrayData::new(DataType::Boolean, 10, 1, None, 2, vec![], vec![]);\n+        let arr_data = ArrayData::new(DataType::Boolean, 10, Some(1), None, 2, vec![], vec![]);\n         assert_eq!(10, arr_data.len());\n         assert_eq!(1, arr_data.null_count());\n         assert_eq!(2, arr_data.offset());\n@@ -244,7 +247,7 @@ mod tests {\n         let child_arr_data = Arc::new(ArrayData::new(\n             DataType::Int32,\n             10,\n-            0,\n+            Some(0),\n             None,\n             0,\n             vec![],\ndiff --git a/rust/src/bitmap.rs b/rust/src/bitmap.rs\nindex 742fac5587..3d5a77f78a 100644\n--- a/rust/src/bitmap.rs\n+++ b/rust/src/bitmap.rs\n@@ -45,9 +45,9 @@ impl Bitmap {\n         self.bits.len()\n     }\n \n-    pub fn is_set(&self, i: i64) -> bool {\n-        assert!(i < (self.bits.len() << 3) as i64);\n-        unsafe { bit_util::get_bit_raw(self.bits.raw_data(), i as usize) }\n+    pub fn is_set(&self, i: usize) -> bool {\n+        assert!(i < (self.bits.len() << 3));\n+        unsafe { bit_util::get_bit_raw(self.bits.raw_data(), i) }\n     }\n }\n \ndiff --git a/rust/src/buffer.rs b/rust/src/buffer.rs\nindex 4b7d2a0d3c..b9c159f338 100644\n--- a/rust/src/buffer.rs\n+++ b/rust/src/buffer.rs\n@@ -49,7 +49,7 @@ impl PartialEq for BufferData {\n         if self.len != other.len {\n             return false;\n         }\n-        unsafe { memory::memcmp(self.ptr, other.ptr, self.len as usize) == 0 }\n+        unsafe { memory::memcmp(self.ptr, other.ptr, self.len) == 0 }\n     }\n }\n \n@@ -73,7 +73,7 @@ impl Buffer {\n \n     /// Returns the number of bytes in the buffer\n     pub fn len(&self) -> usize {\n-        self.data.len - self.offset as usize\n+        self.data.len - self.offset\n     }\n \n     /// Returns whether the buffer is empty.\n@@ -128,7 +128,7 @@ impl<T: AsRef<[u8]>> From<T> for Buffer {\n         // allocate aligned memory buffer\n         let slice = p.as_ref();\n         let len = slice.len() * mem::size_of::<u8>();\n-        let buffer = memory::allocate_aligned((len) as i64).unwrap();\n+        let buffer = memory::allocate_aligned(len).unwrap();\n         unsafe {\n             memory::memcpy(buffer, slice.as_ptr(), len);\n         }\n@@ -151,12 +151,12 @@ pub struct MutableBuffer {\n impl MutableBuffer {\n     /// Allocate a new mutable buffer with initial capacity to be `capacity`.\n     pub fn new(capacity: usize) -> Self {\n-        let new_capacity = bit_util::round_upto_multiple_of_64(capacity as i64);\n+        let new_capacity = bit_util::round_upto_multiple_of_64(capacity);\n         let ptr = memory::allocate_aligned(new_capacity).unwrap();\n         Self {\n             data: ptr,\n             len: 0,\n-            capacity: new_capacity as usize,\n+            capacity: new_capacity,\n         }\n     }\n \n@@ -193,8 +193,8 @@ impl MutableBuffer {\n     /// Returns the new capacity for this buffer.\n     pub fn reserve(&mut self, capacity: usize) -> Result<usize> {\n         if capacity > self.capacity {\n-            let new_capacity = bit_util::round_upto_multiple_of_64(capacity as i64);\n-            let new_capacity = cmp::max(new_capacity, self.capacity as i64 * 2) as usize;\n+            let new_capacity = bit_util::round_upto_multiple_of_64(capacity);\n+            let new_capacity = cmp::max(new_capacity, self.capacity * 2);\n             let new_data = memory::reallocate(self.capacity, new_capacity, self.data)?;\n             self.data = new_data as *mut u8;\n             self.capacity = new_capacity;\n@@ -213,7 +213,7 @@ impl MutableBuffer {\n         if new_len > self.len {\n             self.reserve(new_len)?;\n         } else {\n-            let new_capacity = bit_util::round_upto_multiple_of_64(new_len as i64) as usize;\n+            let new_capacity = bit_util::round_upto_multiple_of_64(new_len);\n             if new_capacity < self.capacity {\n                 let new_data = memory::reallocate(self.capacity, new_capacity, self.data)?;\n                 self.data = new_data as *mut u8;\n@@ -287,7 +287,7 @@ impl PartialEq for MutableBuffer {\n         if self.len != other.len {\n             return false;\n         }\n-        unsafe { memory::memcmp(self.data, other.data, self.len as usize) == 0 }\n+        unsafe { memory::memcmp(self.data, other.data, self.len) == 0 }\n     }\n }\n \ndiff --git a/rust/src/builder.rs b/rust/src/builder.rs\nindex 2cbdce0c85..fc781ffa50 100644\n--- a/rust/src/builder.rs\n+++ b/rust/src/builder.rs\n@@ -33,7 +33,7 @@ use crate::util::bit_util;\n /// Buffer builder with zero-copy build method\n pub struct BufferBuilder<T: ArrowPrimitiveType> {\n     buffer: MutableBuffer,\n-    len: i64,\n+    len: usize,\n     _marker: PhantomData<T>,\n }\n \n@@ -53,11 +53,11 @@ pub type Float64BufferBuilder = BufferBuilder<Float64Type>;\n // numeric types and boolean types, while still be able to call methods on buffer builder\n // with generic primitive type.\n pub trait BufferBuilderTrait<T: ArrowPrimitiveType> {\n-    fn new(capacity: i64) -> Self;\n-    fn len(&self) -> i64;\n-    fn capacity(&self) -> i64;\n-    fn advance(&mut self, i: i64) -> Result<()>;\n-    fn reserve(&mut self, n: i64) -> Result<()>;\n+    fn new(capacity: usize) -> Self;\n+    fn len(&self) -> usize;\n+    fn capacity(&self) -> usize;\n+    fn advance(&mut self, i: usize) -> Result<()>;\n+    fn reserve(&mut self, n: usize) -> Result<()>;\n     fn push(&mut self, v: T::Native) -> Result<()>;\n     fn push_slice(&mut self, slice: &[T::Native]) -> Result<()>;\n     fn finish(self) -> Buffer;\n@@ -65,8 +65,8 @@ pub trait BufferBuilderTrait<T: ArrowPrimitiveType> {\n \n impl<T: ArrowPrimitiveType> BufferBuilderTrait<T> for BufferBuilder<T> {\n     /// Creates a builder with a fixed initial capacity\n-    default fn new(capacity: i64) -> Self {\n-        let buffer = MutableBuffer::new(capacity as usize * mem::size_of::<T::Native>());\n+    default fn new(capacity: usize) -> Self {\n+        let buffer = MutableBuffer::new(capacity * mem::size_of::<T::Native>());\n         Self {\n             buffer,\n             len: 0,\n@@ -75,28 +75,28 @@ impl<T: ArrowPrimitiveType> BufferBuilderTrait<T> for BufferBuilder<T> {\n     }\n \n     /// Returns the number of array elements (slots) in the builder\n-    fn len(&self) -> i64 {\n+    fn len(&self) -> usize {\n         self.len\n     }\n \n     /// Returns the current capacity of the builder (number of elements)\n-    fn capacity(&self) -> i64 {\n+    fn capacity(&self) -> usize {\n         let bit_capacity = self.buffer.capacity() * 8;\n-        (bit_capacity / T::get_bit_width()) as i64\n+        (bit_capacity / T::get_bit_width())\n     }\n \n     // Advances the `len` of the underlying `Buffer` by `i` slots of type T\n-    default fn advance(&mut self, i: i64) -> Result<()> {\n-        let new_buffer_len = (self.len + i) as usize * mem::size_of::<T::Native>();\n+    default fn advance(&mut self, i: usize) -> Result<()> {\n+        let new_buffer_len = (self.len + i) * mem::size_of::<T::Native>();\n         self.buffer.resize(new_buffer_len)?;\n         self.len += i;\n         Ok(())\n     }\n \n     /// Reserves memory for `n` elements of type `T`.\n-    default fn reserve(&mut self, n: i64) -> Result<()> {\n+    default fn reserve(&mut self, n: usize) -> Result<()> {\n         let new_capacity = self.len + n;\n-        let byte_capacity = mem::size_of::<T::Native>() * new_capacity as usize;\n+        let byte_capacity = mem::size_of::<T::Native>() * new_capacity;\n         self.buffer.reserve(byte_capacity)?;\n         Ok(())\n     }\n@@ -109,7 +109,7 @@ impl<T: ArrowPrimitiveType> BufferBuilderTrait<T> for BufferBuilder<T> {\n \n     /// Pushes a slice of type `T`, growing the internal buffer as needed.\n     default fn push_slice(&mut self, slice: &[T::Native]) -> Result<()> {\n-        let array_slots = slice.len() as i64;\n+        let array_slots = slice.len();\n         self.reserve(array_slots)?;\n         self.write_bytes(slice.to_byte_slice(), array_slots)\n     }\n@@ -124,7 +124,7 @@ impl<T: ArrowPrimitiveType> BufferBuilder<T> {\n     /// Writes a byte slice to the underlying buffer and updates the `len`, i.e. the number array\n     /// elements in the builder.  Also, converts the `io::Result` required by the `Write` trait\n     /// to the Arrow `Result` type.\n-    fn write_bytes(&mut self, bytes: &[u8], len_added: i64) -> Result<()> {\n+    fn write_bytes(&mut self, bytes: &[u8], len_added: usize) -> Result<()> {\n         let write_result = self.buffer.write(bytes);\n         // `io::Result` has many options one of which we use, so pattern matching is overkill here\n         if write_result.is_err() {\n@@ -140,9 +140,9 @@ impl<T: ArrowPrimitiveType> BufferBuilder<T> {\n \n impl BufferBuilderTrait<BooleanType> for BufferBuilder<BooleanType> {\n     /// Creates a builder with a fixed initial capacity.\n-    fn new(capacity: i64) -> Self {\n+    fn new(capacity: usize) -> Self {\n         let byte_capacity = bit_util::ceil(capacity, 8);\n-        let actual_capacity = bit_util::round_upto_multiple_of_64(byte_capacity) as usize;\n+        let actual_capacity = bit_util::round_upto_multiple_of_64(byte_capacity);\n         let mut buffer = MutableBuffer::new(actual_capacity);\n         buffer.set_null_bits(0, actual_capacity);\n         Self {\n@@ -153,9 +153,9 @@ impl BufferBuilderTrait<BooleanType> for BufferBuilder<BooleanType> {\n     }\n \n     // Advances the `len` of the underlying `Buffer` by `i` slots of type T\n-    fn advance(&mut self, i: i64) -> Result<()> {\n+    fn advance(&mut self, i: usize) -> Result<()> {\n         let new_buffer_len = bit_util::ceil(self.len + i, 8);\n-        self.buffer.resize(new_buffer_len as usize)?;\n+        self.buffer.resize(new_buffer_len)?;\n         self.len += i;\n         Ok(())\n     }\n@@ -167,7 +167,7 @@ impl BufferBuilderTrait<BooleanType> for BufferBuilder<BooleanType> {\n             // For performance the `len` of the buffer is not updated on each push but\n             // is updated in the `freeze` method instead.\n             unsafe {\n-                bit_util::set_bit_raw(self.buffer.raw_data() as *mut u8, (self.len) as usize);\n+                bit_util::set_bit_raw(self.buffer.raw_data() as *mut u8, self.len);\n             }\n         }\n         self.len += 1;\n@@ -184,10 +184,10 @@ impl BufferBuilderTrait<BooleanType> for BufferBuilder<BooleanType> {\n     }\n \n     /// Reserves memory for `n` elements of type `T`.\n-    fn reserve(&mut self, n: i64) -> Result<()> {\n+    fn reserve(&mut self, n: usize) -> Result<()> {\n         let new_capacity = self.len + n;\n         if new_capacity > self.capacity() {\n-            let new_byte_capacity = bit_util::ceil(new_capacity, 8) as usize;\n+            let new_byte_capacity = bit_util::ceil(new_capacity, 8);\n             let existing_capacity = self.buffer.capacity();\n             let new_capacity = self.buffer.reserve(new_byte_capacity)?;\n             self.buffer\n@@ -199,7 +199,7 @@ impl BufferBuilderTrait<BooleanType> for BufferBuilder<BooleanType> {\n     /// Consumes this and returns an immutable `Buffer`.\n     fn finish(mut self) -> Buffer {\n         // `push` does not update the buffer's `len` so do it before `freeze` is called.\n-        let new_buffer_len = bit_util::ceil(self.len, 8) as usize;\n+        let new_buffer_len = bit_util::ceil(self.len, 8);\n         debug_assert!(new_buffer_len >= self.buffer.len());\n         self.buffer.resize(new_buffer_len).unwrap();\n         self.buffer.freeze()\n@@ -216,7 +216,7 @@ pub trait ArrayBuilder {\n     fn into_any(self) -> Box<Any>;\n \n     /// Returns the number of array slots in the builder\n-    fn len(&self) -> i64;\n+    fn len(&self) -> usize;\n \n     /// Builds the array\n     fn finish(self) -> Self::ArrayType;\n@@ -250,7 +250,7 @@ impl<T: ArrowPrimitiveType> ArrayBuilder for PrimitiveArrayBuilder<T> {\n     }\n \n     /// Returns the number of array slots in the builder\n-    fn len(&self) -> i64 {\n+    fn len(&self) -> usize {\n         self.values_builder.len\n     }\n \n@@ -270,7 +270,7 @@ impl<T: ArrowPrimitiveType> ArrayBuilder for PrimitiveArrayBuilder<T> {\n \n impl<T: ArrowPrimitiveType> PrimitiveArrayBuilder<T> {\n     /// Creates a new primitive array builder\n-    pub fn new(capacity: i64) -> Self {\n+    pub fn new(capacity: usize) -> Self {\n         Self {\n             values_builder: BufferBuilder::<T>::new(capacity),\n             bitmap_builder: BooleanBufferBuilder::new(capacity),\n@@ -278,7 +278,7 @@ impl<T: ArrowPrimitiveType> PrimitiveArrayBuilder<T> {\n     }\n \n     /// Returns the capacity of this builder measured in slots of type `T`\n-    pub fn capacity(&self) -> i64 {\n+    pub fn capacity(&self) -> usize {\n         self.values_builder.capacity()\n     }\n \n@@ -318,7 +318,7 @@ pub struct ListArrayBuilder<T: ArrayBuilder> {\n     offsets_builder: Int32BufferBuilder,\n     bitmap_builder: BooleanBufferBuilder,\n     values_builder: T,\n-    len: i64,\n+    len: usize,\n }\n \n impl<T: ArrayBuilder> ListArrayBuilder<T> {\n@@ -348,7 +348,7 @@ where\n     }\n \n     /// Returns the number of array slots in the builder\n-    fn len(&self) -> i64 {\n+    fn len(&self) -> usize {\n         self.len\n     }\n \n@@ -410,7 +410,7 @@ impl ArrayBuilder for BinaryArrayBuilder {\n     }\n \n     /// Returns the number of array slots in the builder\n-    fn len(&self) -> i64 {\n+    fn len(&self) -> usize {\n         self.builder.len()\n     }\n \n@@ -422,7 +422,7 @@ impl ArrayBuilder for BinaryArrayBuilder {\n \n impl BinaryArrayBuilder {\n     /// Creates a new `BinaryArrayBuilder`, `capacity` is the number of bytes in the values array\n-    pub fn new(capacity: i64) -> Self {\n+    pub fn new(capacity: usize) -> Self {\n         let values_builder = UInt8Builder::new(capacity);\n         Self {\n             builder: ListArrayBuilder::new(values_builder),\n@@ -736,8 +736,8 @@ mod tests {\n         assert_eq!(6, list_array.value_offset(2));\n         assert_eq!(2, list_array.value_length(2));\n         for i in 0..3 {\n-            assert!(list_array.is_valid(i as i64));\n-            assert!(!list_array.is_null(i as i64));\n+            assert!(list_array.is_valid(i));\n+            assert!(!list_array.is_null(i));\n         }\n     }\n \ndiff --git a/rust/src/csv/reader.rs b/rust/src/csv/reader.rs\nindex 697ace653b..956408e4a4 100644\n--- a/rust/src/csv/reader.rs\n+++ b/rust/src/csv/reader.rs\n@@ -44,13 +44,15 @@ use std::fs::File;\n use std::io::BufReader;\n use std::sync::Arc;\n \n+use csv as csv_crate;\n+\n use crate::array::{ArrayRef, BinaryArray};\n use crate::builder::*;\n use crate::datatypes::*;\n use crate::error::{ArrowError, Result};\n use crate::record_batch::RecordBatch;\n \n-use csv_crate::{StringRecord, StringRecordsIntoIter};\n+use self::csv_crate::{StringRecord, StringRecordsIntoIter};\n \n /// CSV file reader\n pub struct Reader {\n@@ -91,7 +93,7 @@ fn build_primitive_array<T: ArrowPrimitiveType>(\n     rows: &[StringRecord],\n     col_idx: &usize,\n ) -> Result<ArrayRef> {\n-    let mut builder = PrimitiveArrayBuilder::<T>::new(rows.len() as i64);\n+    let mut builder = PrimitiveArrayBuilder::<T>::new(rows.len());\n     for row_index in 0..rows.len() {\n         match rows[row_index].get(*col_idx) {\n             Some(s) if s.len() > 0 => match s.parse::<T::Native>() {\n@@ -161,7 +163,7 @@ impl Reader {\n                     &DataType::Float32 => build_primitive_array::<Float32Type>(rows, i),\n                     &DataType::Float64 => build_primitive_array::<Float64Type>(rows, i),\n                     &DataType::Utf8 => {\n-                        let values_builder: UInt8Builder = UInt8Builder::new(rows.len() as i64);\n+                        let values_builder: UInt8Builder = UInt8Builder::new(rows.len());\n                         let mut list_builder = ListArrayBuilder::new(values_builder);\n                         for row_index in 0..rows.len() {\n                             match rows[row_index].get(*i) {\ndiff --git a/rust/src/memory.rs b/rust/src/memory.rs\nindex 193eff12d6..763cb48f50 100644\n--- a/rust/src/memory.rs\n+++ b/rust/src/memory.rs\n@@ -31,7 +31,7 @@ extern \"C\" {\n }\n \n #[cfg(windows)]\n-pub fn allocate_aligned(size: i64) -> Result<*mut u8> {\n+pub fn allocate_aligned(size: usize) -> Result<*mut u8> {\n     let page = unsafe { _aligned_malloc(size as libc::size_t, ALIGNMENT as libc::size_t) };\n     match page {\n         0 => Err(ArrowError::MemoryError(\n@@ -42,10 +42,10 @@ pub fn allocate_aligned(size: i64) -> Result<*mut u8> {\n }\n \n #[cfg(not(windows))]\n-pub fn allocate_aligned(size: i64) -> Result<*mut u8> {\n+pub fn allocate_aligned(size: usize) -> Result<*mut u8> {\n     unsafe {\n         let mut page: *mut libc::c_void = mem::uninitialized();\n-        let result = libc::posix_memalign(&mut page, ALIGNMENT, size as usize);\n+        let result = libc::posix_memalign(&mut page, ALIGNMENT, size);\n         match result {\n             0 => Ok(mem::transmute::<*mut libc::c_void, *mut u8>(page)),\n             _ => Err(ArrowError::MemoryError(\n@@ -72,7 +72,7 @@ pub fn free_aligned(p: *const u8) {\n pub fn reallocate(old_size: usize, new_size: usize, pointer: *const u8) -> Result<*const u8> {\n     unsafe {\n         let old_src = mem::transmute::<*const u8, *mut libc::c_void>(pointer);\n-        let result = allocate_aligned(new_size as i64)?;\n+        let result = allocate_aligned(new_size)?;\n         let dst = mem::transmute::<*const u8, *mut libc::c_void>(result);\n         libc::memcpy(dst, old_src, cmp::min(old_size, new_size));\n         free_aligned(pointer);\ndiff --git a/rust/src/record_batch.rs b/rust/src/record_batch.rs\nindex 4cb5c8e7db..2666770460 100644\n--- a/rust/src/record_batch.rs\n+++ b/rust/src/record_batch.rs\n@@ -52,7 +52,7 @@ impl RecordBatch {\n         self.columns.len()\n     }\n \n-    pub fn num_rows(&self) -> i64 {\n+    pub fn num_rows(&self) -> usize {\n         self.columns[0].data().len()\n     }\n \ndiff --git a/rust/src/tensor.rs b/rust/src/tensor.rs\nindex ec56aeb4cc..175b68d81f 100644\n--- a/rust/src/tensor.rs\n+++ b/rust/src/tensor.rs\n@@ -23,30 +23,30 @@ use crate::buffer::Buffer;\n use crate::datatypes::*;\n \n /// Computes the strides required assuming a row major memory layout\n-fn compute_row_major_strides<T: ArrowPrimitiveType>(shape: &Vec<i64>) -> Vec<i64> {\n+fn compute_row_major_strides<T: ArrowPrimitiveType>(shape: &Vec<usize>) -> Vec<usize> {\n     let mut remaining_bytes = mem::size_of::<T::Native>();\n     for i in shape {\n         remaining_bytes = remaining_bytes\n-            .checked_mul(*i as usize)\n+            .checked_mul(*i)\n             .expect(\"Overflow occurred when computing row major strides.\");\n     }\n \n-    let mut strides = Vec::<i64>::new();\n+    let mut strides = Vec::<usize>::new();\n     for i in shape {\n-        remaining_bytes /= *i as usize;\n-        strides.push(remaining_bytes as i64);\n+        remaining_bytes /= *i;\n+        strides.push(remaining_bytes);\n     }\n     strides\n }\n \n /// Computes the strides required assuming a column major memory layout\n-fn compute_column_major_strides<T: ArrowPrimitiveType>(shape: &Vec<i64>) -> Vec<i64> {\n+fn compute_column_major_strides<T: ArrowPrimitiveType>(shape: &Vec<usize>) -> Vec<usize> {\n     let mut remaining_bytes = mem::size_of::<T::Native>();\n-    let mut strides = Vec::<i64>::new();\n+    let mut strides = Vec::<usize>::new();\n     for i in shape {\n-        strides.push(remaining_bytes as i64);\n+        strides.push(remaining_bytes);\n         remaining_bytes = remaining_bytes\n-            .checked_mul(*i as usize)\n+            .checked_mul(*i)\n             .expect(\"Overflow occurred when computing column major strides.\");\n     }\n     strides\n@@ -56,8 +56,8 @@ fn compute_column_major_strides<T: ArrowPrimitiveType>(shape: &Vec<i64>) -> Vec<\n pub struct Tensor<'a, T: ArrowPrimitiveType> {\n     data_type: DataType,\n     buffer: Buffer,\n-    shape: Option<Vec<i64>>,\n-    strides: Option<Vec<i64>>,\n+    shape: Option<Vec<usize>>,\n+    strides: Option<Vec<usize>>,\n     names: Option<Vec<&'a str>>,\n     _marker: PhantomData<T>,\n }\n@@ -78,8 +78,8 @@ impl<'a, T: ArrowPrimitiveType> Tensor<'a, T> {\n     /// Creates a new `Tensor`\n     pub fn new(\n         buffer: Buffer,\n-        shape: Option<Vec<i64>>,\n-        strides: Option<Vec<i64>>,\n+        shape: Option<Vec<usize>>,\n+        strides: Option<Vec<usize>>,\n         names: Option<Vec<&'a str>>,\n     ) -> Self {\n         match &shape {\n@@ -122,7 +122,7 @@ impl<'a, T: ArrowPrimitiveType> Tensor<'a, T> {\n     /// Creates a new Tensor using row major memory layout\n     pub fn new_row_major(\n         buffer: Buffer,\n-        shape: Option<Vec<i64>>,\n+        shape: Option<Vec<usize>>,\n         names: Option<Vec<&'a str>>,\n     ) -> Self {\n         let strides = match &shape {\n@@ -135,7 +135,7 @@ impl<'a, T: ArrowPrimitiveType> Tensor<'a, T> {\n     /// Creates a new Tensor using column major memory layout\n     pub fn new_column_major(\n         buffer: Buffer,\n-        shape: Option<Vec<i64>>,\n+        shape: Option<Vec<usize>>,\n         names: Option<Vec<&'a str>>,\n     ) -> Self {\n         let strides = match &shape {\n@@ -151,7 +151,7 @@ impl<'a, T: ArrowPrimitiveType> Tensor<'a, T> {\n     }\n \n     /// The sizes of the dimensions\n-    pub fn shape(&self) -> Option<&Vec<i64>> {\n+    pub fn shape(&self) -> Option<&Vec<usize>> {\n         self.shape.as_ref()\n     }\n \n@@ -161,7 +161,7 @@ impl<'a, T: ArrowPrimitiveType> Tensor<'a, T> {\n     }\n \n     /// The number of bytes between elements in each dimension\n-    pub fn strides(&self) -> Option<&Vec<i64>> {\n+    pub fn strides(&self) -> Option<&Vec<usize>> {\n         self.strides.as_ref()\n     }\n \n@@ -171,24 +171,24 @@ impl<'a, T: ArrowPrimitiveType> Tensor<'a, T> {\n     }\n \n     /// The number of dimensions\n-    pub fn ndim(&self) -> i64 {\n+    pub fn ndim(&self) -> usize {\n         match &self.shape {\n             None => 0,\n-            Some(v) => v.len() as i64,\n+            Some(v) => v.len(),\n         }\n     }\n \n     /// The name of dimension i\n-    pub fn dim_name(&self, i: i64) -> Option<&'a str> {\n+    pub fn dim_name(&self, i: usize) -> Option<&'a str> {\n         match &self.names {\n             None => None,\n-            Some(ref names) => Some(&names[i as usize]),\n+            Some(ref names) => Some(&names[i]),\n         }\n     }\n \n     /// The total number of elements in the `Tensor`\n-    pub fn size(&self) -> i64 {\n-        (self.buffer.len() / mem::size_of::<T::Native>()) as i64\n+    pub fn size(&self) -> usize {\n+        (self.buffer.len() / mem::size_of::<T::Native>())\n     }\n \n     /// Indicates if the data is laid out contiguously in memory\n@@ -223,15 +223,15 @@ mod tests {\n     fn test_compute_row_major_strides() {\n         assert_eq!(\n             vec![48, 8],\n-            compute_row_major_strides::<Int64Type>(&vec![4_i64, 6])\n+            compute_row_major_strides::<Int64Type>(&vec![4_usize, 6])\n         );\n         assert_eq!(\n             vec![24, 4],\n-            compute_row_major_strides::<Int32Type>(&vec![4_i64, 6])\n+            compute_row_major_strides::<Int32Type>(&vec![4_usize, 6])\n         );\n         assert_eq!(\n             vec![6, 1],\n-            compute_row_major_strides::<Int8Type>(&vec![4_i64, 6])\n+            compute_row_major_strides::<Int8Type>(&vec![4_usize, 6])\n         );\n     }\n \n@@ -239,15 +239,15 @@ mod tests {\n     fn test_compute_column_major_strides() {\n         assert_eq!(\n             vec![8, 32],\n-            compute_column_major_strides::<Int64Type>(&vec![4_i64, 6])\n+            compute_column_major_strides::<Int64Type>(&vec![4_usize, 6])\n         );\n         assert_eq!(\n             vec![4, 16],\n-            compute_column_major_strides::<Int32Type>(&vec![4_i64, 6])\n+            compute_column_major_strides::<Int32Type>(&vec![4_usize, 6])\n         );\n         assert_eq!(\n             vec![1, 4],\n-            compute_column_major_strides::<Int8Type>(&vec![4_i64, 6])\n+            compute_column_major_strides::<Int8Type>(&vec![4_usize, 6])\n         );\n     }\n \n@@ -283,7 +283,7 @@ mod tests {\n         let buf = builder.finish();\n         let tensor = Int32Tensor::new(buf, Some(vec![2, 8]), None, None);\n         assert_eq!(16, tensor.size());\n-        assert_eq!(Some(vec![2_i64, 8]).as_ref(), tensor.shape());\n+        assert_eq!(Some(vec![2_usize, 8]).as_ref(), tensor.shape());\n         assert_eq!(None, tensor.strides());\n         assert_eq!(2, tensor.ndim());\n         assert_eq!(None, tensor.names());\n@@ -298,8 +298,8 @@ mod tests {\n         let buf = builder.finish();\n         let tensor = Int32Tensor::new_row_major(buf, Some(vec![2, 8]), None);\n         assert_eq!(16, tensor.size());\n-        assert_eq!(Some(vec![2_i64, 8]).as_ref(), tensor.shape());\n-        assert_eq!(Some(vec![32_i64, 4]).as_ref(), tensor.strides());\n+        assert_eq!(Some(vec![2_usize, 8]).as_ref(), tensor.shape());\n+        assert_eq!(Some(vec![32_usize, 4]).as_ref(), tensor.strides());\n         assert_eq!(None, tensor.names());\n         assert_eq!(2, tensor.ndim());\n         assert_eq!(true, tensor.is_row_major());\n@@ -316,8 +316,8 @@ mod tests {\n         let buf = builder.finish();\n         let tensor = Int32Tensor::new_column_major(buf, Some(vec![2, 8]), None);\n         assert_eq!(16, tensor.size());\n-        assert_eq!(Some(vec![2_i64, 8]).as_ref(), tensor.shape());\n-        assert_eq!(Some(vec![4_i64, 8]).as_ref(), tensor.strides());\n+        assert_eq!(Some(vec![2_usize, 8]).as_ref(), tensor.shape());\n+        assert_eq!(Some(vec![4_usize, 8]).as_ref(), tensor.strides());\n         assert_eq!(None, tensor.names());\n         assert_eq!(2, tensor.ndim());\n         assert_eq!(false, tensor.is_row_major());\n@@ -335,8 +335,8 @@ mod tests {\n         let names = vec![\"Dim 1\", \"Dim 2\"];\n         let tensor = Int64Tensor::new_column_major(buf, Some(vec![2, 4]), Some(names));\n         assert_eq!(8, tensor.size());\n-        assert_eq!(Some(vec![2_i64, 4]).as_ref(), tensor.shape());\n-        assert_eq!(Some(vec![8_i64, 16]).as_ref(), tensor.strides());\n+        assert_eq!(Some(vec![2_usize, 4]).as_ref(), tensor.shape());\n+        assert_eq!(Some(vec![8_usize, 16]).as_ref(), tensor.strides());\n         assert_eq!(\"Dim 1\", tensor.dim_name(0).unwrap());\n         assert_eq!(\"Dim 2\", tensor.dim_name(1).unwrap());\n         assert_eq!(2, tensor.ndim());\ndiff --git a/rust/src/util/bit_util.rs b/rust/src/util/bit_util.rs\nindex da6d10d269..3f7f4cb573 100644\n--- a/rust/src/util/bit_util.rs\n+++ b/rust/src/util/bit_util.rs\n@@ -30,13 +30,13 @@ static POPCOUNT_TABLE: [u8; 256] = [\n \n /// Returns the nearest number that is `>=` than `num` and is a multiple of 64\n #[inline]\n-pub fn round_upto_multiple_of_64(num: i64) -> i64 {\n+pub fn round_upto_multiple_of_64(num: usize) -> usize {\n     round_upto_power_of_2(num, 64)\n }\n \n /// Returns the nearest multiple of `factor` that is `>=` than `num`. Here `factor` must\n /// be a power of 2.\n-fn round_upto_power_of_2(num: i64, factor: i64) -> i64 {\n+fn round_upto_power_of_2(num: usize, factor: usize) -> usize {\n     debug_assert!(factor > 0 && (factor & (factor - 1)) == 0);\n     (num + (factor - 1)) & !(factor - 1)\n }\n@@ -73,20 +73,20 @@ pub unsafe fn set_bit_raw(data: *mut u8, i: usize) {\n \n /// Returns the number of 1-bits in `data`\n #[inline]\n-pub fn count_set_bits(data: &[u8]) -> i64 {\n-    let mut count: i64 = 0;\n+pub fn count_set_bits(data: &[u8]) -> usize {\n+    let mut count: usize = 0;\n     for u in data {\n-        count += POPCOUNT_TABLE[*u as usize] as i64;\n+        count += POPCOUNT_TABLE[*u as usize] as usize;\n     }\n     count\n }\n \n /// Returns the number of 1-bits in `data`, starting from `offset`.\n #[inline]\n-pub fn count_set_bits_offset(data: &[u8], offset: usize) -> i64 {\n+pub fn count_set_bits_offset(data: &[u8], offset: usize) -> usize {\n     debug_assert!(offset <= (data.len() << 3));\n \n-    let start_byte_pos = (offset >> 3) as usize;\n+    let start_byte_pos = offset >> 3;\n     let start_bit_pos = offset & 7;\n \n     if start_bit_pos == 0 {\n@@ -95,7 +95,7 @@ pub fn count_set_bits_offset(data: &[u8], offset: usize) -> i64 {\n         let mut result = 0;\n         result += count_set_bits(&data[start_byte_pos + 1..]);\n         for i in start_bit_pos..8 {\n-            if get_bit(&data[start_byte_pos..start_byte_pos + 1], i as usize) {\n+            if get_bit(&data[start_byte_pos..start_byte_pos + 1], i) {\n                 result += 1;\n             }\n         }\n@@ -105,7 +105,7 @@ pub fn count_set_bits_offset(data: &[u8], offset: usize) -> i64 {\n \n /// Returns the ceil of `value`/`divisor`\n #[inline]\n-pub fn ceil(value: i64, divisor: i64) -> i64 {\n+pub fn ceil(value: usize, divisor: usize) -> usize {\n     let mut result = value / divisor;\n     if value % divisor != 0 {\n         result += 1\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-10T15:30:52.034+0000",
                    "updated": "2018-12-10T15:30:52.034+0000",
                    "started": "2018-12-10T15:30:52.034+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "173648",
                    "issueId": "13195653"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
            "id": "1",
            "description": "A problem which impairs or prevents the functions of the product.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
            "name": "Bug",
            "subtask": false,
            "avatarId": 21133
        },
        "timespent": 5400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@417b6894[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@46701e8e[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1d43724e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@5b018b06[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@746c1710[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@47963586[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@41c1fe38[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@16cf14bd[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@28f55e3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@74c37a31[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3abd6aaf[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@54b9ebb9[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 5400,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Dec 10 15:30:41 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-12-10T15:30:41.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3687/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2018-11-01T12:42:23.000+0000",
        "updated": "2018-12-10T15:30:52.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "1.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 5400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust] Anything measuring array slots should be `usize`",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13195653/comment/16714925",
                    "id": "16714925",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kszucs",
                        "name": "kszucs",
                        "key": "kszucs",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Krisztian Szucs",
                        "active": true,
                        "timeZone": "Europe/Budapest"
                    },
                    "body": "Issue resolved by pull request 3142\n[https://github.com/apache/arrow/pull/3142]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kszucs",
                        "name": "kszucs",
                        "key": "kszucs",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Krisztian Szucs",
                        "active": true,
                        "timeZone": "Europe/Budapest"
                    },
                    "created": "2018-12-10T15:30:41.956+0000",
                    "updated": "2018-12-10T15:30:41.956+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|s000vs:",
        "customfield_12314139": null
    }
}