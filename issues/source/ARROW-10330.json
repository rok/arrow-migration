{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13335839",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335839",
    "key": "ARROW-10330",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=velvia",
            "name": "velvia",
            "key": "velvia",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Evan Chan",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12335005",
                "id": "12335005",
                "name": "Rust - DataFusion"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=velvia",
            "name": "velvia",
            "key": "velvia",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Evan Chan",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=velvia",
            "name": "velvia",
            "key": "velvia",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Evan Chan",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 33600,
            "total": 33600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 33600,
            "total": 33600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10330/votes",
            "votes": 1,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 56,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335839/worklog/512679",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "velvia opened a new pull request #8688:\nURL: https://github.com/apache/arrow/pull/8688\n\n\n   This PR implements the NULLIF() SQL function in DataFusion.  It is implemented as a BuiltInScalarFunction, with a boolean kernel at the core which creates a new array with a modified null bitmap from the original array, based on the result of a boolean expression.   When an input data item is equal to the right side in NULLIF(), then the item's nullity becomes set in the output array.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-17T00:26:34.556+0000",
                    "updated": "2020-11-17T00:26:34.556+0000",
                    "started": "2020-11-17T00:26:34.556+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "512679",
                    "issueId": "13335839"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335839/worklog/512680",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "velvia commented on pull request #8688:\nURL: https://github.com/apache/arrow/pull/8688#issuecomment-728504277\n\n\n   @andygrove @nevi-me would love to hear your feedback on this....  this addition has been useful to us internally.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-17T00:28:08.187+0000",
                    "updated": "2020-11-17T00:28:08.187+0000",
                    "started": "2020-11-17T00:28:08.187+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "512680",
                    "issueId": "13335839"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335839/worklog/512689",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8688:\nURL: https://github.com/apache/arrow/pull/8688#issuecomment-728568531\n\n\n   https://issues.apache.org/jira/browse/ARROW-10330\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-17T00:55:03.641+0000",
                    "updated": "2020-11-17T00:55:03.641+0000",
                    "started": "2020-11-17T00:55:03.641+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "512689",
                    "issueId": "13335839"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335839/worklog/512737",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8688:\nURL: https://github.com/apache/arrow/pull/8688#discussion_r524889515\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/boolean.rs\n##########\n@@ -149,6 +150,64 @@ pub fn is_not_null(input: &ArrayRef) -> Result<BooleanArray> {\n     Ok(BooleanArray::from(Arc::new(data)))\n }\n \n+/// Copies original array, setting null bit to true if a secondary comparison boolean array is set to true.\n+/// Typically used to implement NULLIF.\n+pub fn nullif<T>(\n+    left: &PrimitiveArray<T>,\n\nReview comment:\n       If I understood correctly, because we only use `left.data()`, if we replace `PrimitiveArray<T>` by `impl Array` and remove the generic `T`, this is generalized for all data types. :)\r\n   \r\n   Note that this will not address this in DataFusion, as it seems that we can only compute comparison boolean arrays from primitives atm.\n\n##########\nFile path: rust/datafusion/src/physical_plan/expressions.rs\n##########\n@@ -2604,6 +2678,61 @@ mod tests {\n         )\n     }\n \n+    #[test]\n+    #[rustfmt::skip]\n+    fn nullif_int32() -> Result<()> {\n+        let schema = Schema::new(vec![Field::new(\"a\", DataType::Int32, false)]);\n+        let a = Int32Array::from(vec![Some(1), Some(2), None, None, Some(3), None, None, Some(4), Some(5)]);\n+        let a = Arc::new(a);\n+        let a_len = a.len();\n+        let batch = RecordBatch::try_new(Arc::new(schema.clone()), vec![a.clone()])?;\n+\n+        let literal_expr = lit(ScalarValue::Int32(Some(2)));\n+        let lit_array = literal_expr.evaluate(&batch)?;\n+\n+        let result = nullif_func(&[a.clone(), lit_array])?;\n+\n+        // Results should be: Some(1), None, None, None, Some(3), None\n+        assert_eq!(result.len(), a_len);\n+\n+        let result = result\n+            .as_any()\n+            .downcast_ref::<Int32Array>()\n+            .expect(\"failed to downcast to Int32Array\");\n+\n+        assert_eq!(1, result.value(0));\n+        assert_eq!(true, result.is_null(1));    // 2==2, slot 1 turned into null\n+        assert_eq!(true, result.is_null(2));\n+        assert_eq!(true, result.is_null(3));\n+        assert_eq!(3, result.value(4));\n+        assert_eq!(true, result.is_null(5));\n+        assert_eq!(true, result.is_null(6));\n+        assert_eq!(5, result.value(8));\n+        Ok(())\n\nReview comment:\n       Same here: easier to debug if there is a single `assert_eq`, as we can see the whole array in the message.\n\n##########\nFile path: rust/datafusion/src/physical_plan/expressions.rs\n##########\n@@ -2604,6 +2678,61 @@ mod tests {\n         )\n     }\n \n+    #[test]\n+    #[rustfmt::skip]\n\nReview comment:\n       why `skip`?\n\n##########\nFile path: rust/datafusion/src/physical_plan/expressions.rs\n##########\n@@ -2604,6 +2678,61 @@ mod tests {\n         )\n     }\n \n+    #[test]\n+    #[rustfmt::skip]\n+    fn nullif_int32() -> Result<()> {\n+        let schema = Schema::new(vec![Field::new(\"a\", DataType::Int32, false)]);\n+        let a = Int32Array::from(vec![Some(1), Some(2), None, None, Some(3), None, None, Some(4), Some(5)]);\n+        let a = Arc::new(a);\n+        let a_len = a.len();\n+        let batch = RecordBatch::try_new(Arc::new(schema.clone()), vec![a.clone()])?;\n+\n+        let literal_expr = lit(ScalarValue::Int32(Some(2)));\n+        let lit_array = literal_expr.evaluate(&batch)?;\n+\n+        let result = nullif_func(&[a.clone(), lit_array])?;\n+\n+        // Results should be: Some(1), None, None, None, Some(3), None\n+        assert_eq!(result.len(), a_len);\n+\n+        let result = result\n+            .as_any()\n+            .downcast_ref::<Int32Array>()\n+            .expect(\"failed to downcast to Int32Array\");\n+\n+        assert_eq!(1, result.value(0));\n+        assert_eq!(true, result.is_null(1));    // 2==2, slot 1 turned into null\n+        assert_eq!(true, result.is_null(2));\n+        assert_eq!(true, result.is_null(3));\n+        assert_eq!(3, result.value(4));\n+        assert_eq!(true, result.is_null(5));\n+        assert_eq!(true, result.is_null(6));\n+        assert_eq!(5, result.value(8));\n+        Ok(())\n+    }\n+\n+    #[test]\n+    #[rustfmt::skip]\n+    // Ensure that arrays with no nulls can also invoke NULLIF() correctly\n+    fn nullif_int32_nonulls() -> Result<()> {\n+        let schema = Schema::new(vec![Field::new(\"a\", DataType::Int32, false)]);\n+        let a = Int32Array::from(vec![1, 3, 10, 7, 8, 1, 2, 4, 5]);\n+        let a = Arc::new(a);\n+        let a_len = a.len();\n+        let batch = RecordBatch::try_new(Arc::new(schema.clone()), vec![a.clone()])?;\n+\n+        let literal_expr = lit(ScalarValue::Int32(Some(1)));\n+        let lit_array = literal_expr.evaluate(&batch)?;\n\nReview comment:\n       I think that this can be simplified to `let lit_array = Int32Array::from(vec![1; a.len()]);`.\n\n##########\nFile path: rust/datafusion/src/physical_plan/expressions.rs\n##########\n@@ -2604,6 +2678,61 @@ mod tests {\n         )\n     }\n \n+    #[test]\n+    #[rustfmt::skip]\n+    fn nullif_int32() -> Result<()> {\n+        let schema = Schema::new(vec![Field::new(\"a\", DataType::Int32, false)]);\n+        let a = Int32Array::from(vec![Some(1), Some(2), None, None, Some(3), None, None, Some(4), Some(5)]);\n+        let a = Arc::new(a);\n+        let a_len = a.len();\n+        let batch = RecordBatch::try_new(Arc::new(schema.clone()), vec![a.clone()])?;\n+\n+        let literal_expr = lit(ScalarValue::Int32(Some(2)));\n+        let lit_array = literal_expr.evaluate(&batch)?;\n+\n+        let result = nullif_func(&[a.clone(), lit_array])?;\n+\n+        // Results should be: Some(1), None, None, None, Some(3), None\n\nReview comment:\n       This suggests using `let expected = UInt32::from(vec![Some(1), None, None, None, Some(3), None]);`\n\n##########\nFile path: rust/datafusion/tests/sql.rs\n##########\n@@ -508,6 +508,26 @@ async fn csv_query_avg_multi_batch() -> Result<()> {\n     Ok(())\n }\n \n+#[tokio::test]\n+async fn csv_query_nullif_divide_by_0() -> Result<()> {\n+    let mut ctx = ExecutionContext::new();\n+    register_aggregate_csv(&mut ctx)?;\n+    let sql = \"SELECT c8/nullif(c7, 0) FROM aggregate_test_100\";\n+    let actual: Vec<_> = execute(&mut ctx, sql)\n+        .await\n+        .iter()\n+        .map(|x| x[0].clone())\n+        .collect();\n+    let actual = actual.join(\"\\n\");\n+    let expected = \"1722\\n92\\n46\\n679\\n165\\n146\\n149\\n93\\n2211\\n6495\\n307\\n139\\n253\\n123\\n21\\n84\\n98\\n13\\n230\\n\\\n+       277\\n1\\n986\\n414\\n144\\n210\\n0\\n172\\n165\\n25\\n97\\n335\\n558\\n350\\n369\\n511\\n245\\n345\\n8\\n139\\n55\\n318\\n2614\\n\\\n+       1792\\n16\\n345\\n123\\n176\\n1171\\n20\\n199\\n147\\n115\\n335\\n23\\n847\\n94\\n315\\n391\\n176\\n282\\n459\\n197\\n978\\n281\\n\\\n+       27\\n26\\n281\\n8124\\n3\\n430\\n510\\n61\\n67\\n17\\n1601\\n362\\n202\\n50\\n10\\n346\\n258\\n664\\nNULL\\n22\\n164\\n448\\n365\\n\\\n+       1640\\n671\\n203\\n2087\\n10060\\n1015\\n913\\n9840\\n16\\n496\\n264\\n38\\n1\";\n+    assert_eq!(expected, actual);\n+    Ok(())\n+}\n\nReview comment:\n       What do you think if we run against a controlled dataset instead of `aggregate_test_100`? I can't tell whether `expected` is correct. Wouldn't it make it easier if we use something like the `query_not` test is doing, on which it creates a temporary table and runs against that?\n\n##########\nFile path: rust/arrow/src/compute/kernels/boolean.rs\n##########\n@@ -457,4 +516,20 @@ mod tests {\n         assert_eq!(true, res.value(2));\n         assert_eq!(false, res.value(3));\n     }\n+\n+    #[test]\n+    fn test_nullif_int_array() {\n+        let a = Int32Array::from(vec![Some(15), None, Some(8), Some(1), Some(9)]);\n+        let comp =\n+            BooleanArray::from(vec![Some(false), None, Some(true), Some(false), None]);\n+        let res = nullif(&a, &comp).unwrap();\n+\n+        assert_eq!(15, res.value(0));\n+        assert_eq!(true, res.is_null(1));\n+        assert_eq!(true, res.is_null(2)); // comp true, slot 2 turned into null\n+        assert_eq!(1, res.value(3));\n+        // Even though comp array / right is null, should still pass through original value\n+        assert_eq!(9, res.value(4));\n+        assert_eq!(false, res.is_null(4)); // comp true, slot 2 turned into null\n\nReview comment:\n       ```suggestion\r\n           let expected = Int32Array::from(vec![\r\n               Some(15),\r\n               None,\r\n               None, // comp true, slot 2 turned into null\r\n               Some(1),\r\n               // Even though comp array / right is null, should still pass through original value\r\n               // comp true, slot 2 turned into null\r\n               Some(9),\r\n           ]);\r\n           \r\n           assert_eq!(expected, res)\r\n   ```\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-17T05:44:40.991+0000",
                    "updated": "2020-11-17T05:44:40.991+0000",
                    "started": "2020-11-17T05:44:40.991+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "512737",
                    "issueId": "13335839"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335839/worklog/512819",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vertexclique commented on a change in pull request #8688:\nURL: https://github.com/apache/arrow/pull/8688#discussion_r525058248\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/expressions.rs\n##########\n@@ -1385,6 +1385,80 @@ pub fn binary(\n     Ok(Arc::new(BinaryExpr::new(l, op, r)))\n }\n \n+/// Invoke a compute kernel on a primitive array and a Boolean Array\n+macro_rules! compute_bool_array_op {\n+    ($LEFT:expr, $RIGHT:expr, $OP:ident, $DT:ident) => {{\n+        let ll = $LEFT\n+            .as_any()\n+            .downcast_ref::<$DT>()\n+            .expect(\"compute_op failed to downcast array\");\n+        let rr = $RIGHT\n+            .as_any()\n+            .downcast_ref::<BooleanArray>()\n+            .expect(\"compute_op failed to downcast array\");\n+        Ok(Arc::new($OP(&ll, &rr)?))\n+    }};\n+}\n+\n+/// Binary op between primitive and boolean arrays\n+macro_rules! primitive_bool_array_op {\n+    ($LEFT:expr, $RIGHT:expr, $OP:ident) => {{\n+        match $LEFT.data_type() {\n+            DataType::Int8 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int8Array),\n+            DataType::Int16 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int16Array),\n+            DataType::Int32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int32Array),\n+            DataType::Int64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int64Array),\n+            DataType::UInt8 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt8Array),\n+            DataType::UInt16 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt16Array),\n+            DataType::UInt32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt32Array),\n+            DataType::UInt64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt64Array),\n+            DataType::Float32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Float32Array),\n+            DataType::Float64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Float64Array),\n+            other => Err(DataFusionError::Internal(format!(\n+                \"Unsupported data type {:?} for NULLIF/primitive/boolean operator\",\n+                other\n+            ))),\n+        }\n+    }};\n+}\n+\n+///\n+/// Implements NULLIF(expr1, expr2)\n+/// Args: 0 - left expr is any array\n+///       1 - if the left is equal to this expr2, then the result is NULL, otherwise left value is passed.\n+///\n+pub fn nullif_func(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    if args.len() != 2 {\n+        return Err(DataFusionError::Internal(format!(\n+            \"{:?} args were supplied but NULLIF takes exactly two args\",\n+            args.len(),\n+        )));\n+    }\n+\n+    // Get args0 == args1 evaluated and produce a boolean array\n+    let cond_array = binary_array_op!(args[0], args[1], eq)?;\n+\n+    // Now, invoke nullif on the result\n+    primitive_bool_array_op!(args[0], *cond_array, nullif)\n+}\n+\n+/// Currently supported types by the nullif function.\n+/// The order of these types correspond to the order on which coercion applies\n+/// This should thus be from least informative to most informative\n+pub static SUPPORTED_NULLIF_TYPES: &'static [DataType] = &[\n+    DataType::Boolean,\n+    DataType::UInt8,\n+    DataType::UInt16,\n+    DataType::UInt32,\n+    DataType::UInt64,\n+    DataType::Int8,\n+    DataType::Int16,\n+    DataType::Int32,\n+    DataType::Int64,\n+    DataType::Float32,\n+    DataType::Float64,\n+];\n\nReview comment:\n       Better to make these trait bounds with a good comment about how these are selected. I didn't understand:\r\n   > /// The order of these types correspond to the order on which coercion applies\r\n   \r\n   Can you explain it?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-17T10:48:05.829+0000",
                    "updated": "2020-11-17T10:48:05.829+0000",
                    "started": "2020-11-17T10:48:05.829+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "512819",
                    "issueId": "13335839"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335839/worklog/512823",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8688:\nURL: https://github.com/apache/arrow/pull/8688#discussion_r525066482\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/expressions.rs\n##########\n@@ -1385,6 +1385,80 @@ pub fn binary(\n     Ok(Arc::new(BinaryExpr::new(l, op, r)))\n }\n \n+/// Invoke a compute kernel on a primitive array and a Boolean Array\n+macro_rules! compute_bool_array_op {\n+    ($LEFT:expr, $RIGHT:expr, $OP:ident, $DT:ident) => {{\n+        let ll = $LEFT\n+            .as_any()\n+            .downcast_ref::<$DT>()\n+            .expect(\"compute_op failed to downcast array\");\n+        let rr = $RIGHT\n+            .as_any()\n+            .downcast_ref::<BooleanArray>()\n+            .expect(\"compute_op failed to downcast array\");\n+        Ok(Arc::new($OP(&ll, &rr)?))\n+    }};\n+}\n+\n+/// Binary op between primitive and boolean arrays\n+macro_rules! primitive_bool_array_op {\n+    ($LEFT:expr, $RIGHT:expr, $OP:ident) => {{\n+        match $LEFT.data_type() {\n+            DataType::Int8 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int8Array),\n+            DataType::Int16 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int16Array),\n+            DataType::Int32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int32Array),\n+            DataType::Int64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int64Array),\n+            DataType::UInt8 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt8Array),\n+            DataType::UInt16 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt16Array),\n+            DataType::UInt32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt32Array),\n+            DataType::UInt64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt64Array),\n+            DataType::Float32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Float32Array),\n+            DataType::Float64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Float64Array),\n+            other => Err(DataFusionError::Internal(format!(\n+                \"Unsupported data type {:?} for NULLIF/primitive/boolean operator\",\n+                other\n+            ))),\n+        }\n+    }};\n+}\n+\n+///\n+/// Implements NULLIF(expr1, expr2)\n+/// Args: 0 - left expr is any array\n+///       1 - if the left is equal to this expr2, then the result is NULL, otherwise left value is passed.\n+///\n+pub fn nullif_func(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    if args.len() != 2 {\n+        return Err(DataFusionError::Internal(format!(\n+            \"{:?} args were supplied but NULLIF takes exactly two args\",\n+            args.len(),\n+        )));\n+    }\n+\n+    // Get args0 == args1 evaluated and produce a boolean array\n+    let cond_array = binary_array_op!(args[0], args[1], eq)?;\n+\n+    // Now, invoke nullif on the result\n+    primitive_bool_array_op!(args[0], *cond_array, nullif)\n+}\n+\n+/// Currently supported types by the nullif function.\n+/// The order of these types correspond to the order on which coercion applies\n+/// This should thus be from least informative to most informative\n+pub static SUPPORTED_NULLIF_TYPES: &'static [DataType] = &[\n+    DataType::Boolean,\n+    DataType::UInt8,\n+    DataType::UInt16,\n+    DataType::UInt32,\n+    DataType::UInt64,\n+    DataType::Int8,\n+    DataType::Int16,\n+    DataType::Int32,\n+    DataType::Int64,\n+    DataType::Float32,\n+    DataType::Float64,\n+];\n\nReview comment:\n       > Better to make these trait bounds with a good comment about how these are selected\r\n   \r\n   AFAIK these cannot be trait bounds because logical and physical planning are dynamically typed. \r\n   \r\n   In this case, this is enumerating all valid types that can be (dynamically) passed to the function. If someone tries to call this function with e.g. a `ListArray`, the logical planner will error with a description that this function does not support that type.\r\n   \r\n   The order here matters because when a function is planned to be called with type `X` that is not supported by the function, the physical planner will try to (lossless) cast that type to a valid type for that functions, and it does so in the order of this array. In general these should be ordered from less informative to most informative, as to guarantee that the execution uses the smallest supported type (when casting is required).\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-17T11:00:24.647+0000",
                    "updated": "2020-11-17T11:00:24.647+0000",
                    "started": "2020-11-17T11:00:24.647+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "512823",
                    "issueId": "13335839"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335839/worklog/512825",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8688:\nURL: https://github.com/apache/arrow/pull/8688#discussion_r525066482\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/expressions.rs\n##########\n@@ -1385,6 +1385,80 @@ pub fn binary(\n     Ok(Arc::new(BinaryExpr::new(l, op, r)))\n }\n \n+/// Invoke a compute kernel on a primitive array and a Boolean Array\n+macro_rules! compute_bool_array_op {\n+    ($LEFT:expr, $RIGHT:expr, $OP:ident, $DT:ident) => {{\n+        let ll = $LEFT\n+            .as_any()\n+            .downcast_ref::<$DT>()\n+            .expect(\"compute_op failed to downcast array\");\n+        let rr = $RIGHT\n+            .as_any()\n+            .downcast_ref::<BooleanArray>()\n+            .expect(\"compute_op failed to downcast array\");\n+        Ok(Arc::new($OP(&ll, &rr)?))\n+    }};\n+}\n+\n+/// Binary op between primitive and boolean arrays\n+macro_rules! primitive_bool_array_op {\n+    ($LEFT:expr, $RIGHT:expr, $OP:ident) => {{\n+        match $LEFT.data_type() {\n+            DataType::Int8 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int8Array),\n+            DataType::Int16 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int16Array),\n+            DataType::Int32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int32Array),\n+            DataType::Int64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int64Array),\n+            DataType::UInt8 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt8Array),\n+            DataType::UInt16 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt16Array),\n+            DataType::UInt32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt32Array),\n+            DataType::UInt64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt64Array),\n+            DataType::Float32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Float32Array),\n+            DataType::Float64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Float64Array),\n+            other => Err(DataFusionError::Internal(format!(\n+                \"Unsupported data type {:?} for NULLIF/primitive/boolean operator\",\n+                other\n+            ))),\n+        }\n+    }};\n+}\n+\n+///\n+/// Implements NULLIF(expr1, expr2)\n+/// Args: 0 - left expr is any array\n+///       1 - if the left is equal to this expr2, then the result is NULL, otherwise left value is passed.\n+///\n+pub fn nullif_func(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    if args.len() != 2 {\n+        return Err(DataFusionError::Internal(format!(\n+            \"{:?} args were supplied but NULLIF takes exactly two args\",\n+            args.len(),\n+        )));\n+    }\n+\n+    // Get args0 == args1 evaluated and produce a boolean array\n+    let cond_array = binary_array_op!(args[0], args[1], eq)?;\n+\n+    // Now, invoke nullif on the result\n+    primitive_bool_array_op!(args[0], *cond_array, nullif)\n+}\n+\n+/// Currently supported types by the nullif function.\n+/// The order of these types correspond to the order on which coercion applies\n+/// This should thus be from least informative to most informative\n+pub static SUPPORTED_NULLIF_TYPES: &'static [DataType] = &[\n+    DataType::Boolean,\n+    DataType::UInt8,\n+    DataType::UInt16,\n+    DataType::UInt32,\n+    DataType::UInt64,\n+    DataType::Int8,\n+    DataType::Int16,\n+    DataType::Int32,\n+    DataType::Int64,\n+    DataType::Float32,\n+    DataType::Float64,\n+];\n\nReview comment:\n       > Better to make these trait bounds with a good comment about how these are selected\r\n   \r\n   AFAIK these cannot be trait bounds because logical and physical planning is dynamically typed. \r\n   \r\n   In this case, this is enumerating all valid types that can be (dynamically) passed to the function. If someone tries to call this function with e.g. a `ListArray`, the logical planner will error with a description that this function does not support that type.\r\n   \r\n   The order here matters because when a function is planned to be called with type `X` that is not supported by the function, the physical planner will try to (lossless) cast that type to a valid type for that functions, and it does so in the order of this array. In general these should be ordered from less informative to most informative, as to guarantee that the execution uses the smallest supported type (when casting is required).\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-17T11:01:22.366+0000",
                    "updated": "2020-11-17T11:01:22.366+0000",
                    "started": "2020-11-17T11:01:22.366+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "512825",
                    "issueId": "13335839"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335839/worklog/512827",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8688:\nURL: https://github.com/apache/arrow/pull/8688#discussion_r525066482\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/expressions.rs\n##########\n@@ -1385,6 +1385,80 @@ pub fn binary(\n     Ok(Arc::new(BinaryExpr::new(l, op, r)))\n }\n \n+/// Invoke a compute kernel on a primitive array and a Boolean Array\n+macro_rules! compute_bool_array_op {\n+    ($LEFT:expr, $RIGHT:expr, $OP:ident, $DT:ident) => {{\n+        let ll = $LEFT\n+            .as_any()\n+            .downcast_ref::<$DT>()\n+            .expect(\"compute_op failed to downcast array\");\n+        let rr = $RIGHT\n+            .as_any()\n+            .downcast_ref::<BooleanArray>()\n+            .expect(\"compute_op failed to downcast array\");\n+        Ok(Arc::new($OP(&ll, &rr)?))\n+    }};\n+}\n+\n+/// Binary op between primitive and boolean arrays\n+macro_rules! primitive_bool_array_op {\n+    ($LEFT:expr, $RIGHT:expr, $OP:ident) => {{\n+        match $LEFT.data_type() {\n+            DataType::Int8 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int8Array),\n+            DataType::Int16 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int16Array),\n+            DataType::Int32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int32Array),\n+            DataType::Int64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int64Array),\n+            DataType::UInt8 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt8Array),\n+            DataType::UInt16 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt16Array),\n+            DataType::UInt32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt32Array),\n+            DataType::UInt64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt64Array),\n+            DataType::Float32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Float32Array),\n+            DataType::Float64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Float64Array),\n+            other => Err(DataFusionError::Internal(format!(\n+                \"Unsupported data type {:?} for NULLIF/primitive/boolean operator\",\n+                other\n+            ))),\n+        }\n+    }};\n+}\n+\n+///\n+/// Implements NULLIF(expr1, expr2)\n+/// Args: 0 - left expr is any array\n+///       1 - if the left is equal to this expr2, then the result is NULL, otherwise left value is passed.\n+///\n+pub fn nullif_func(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    if args.len() != 2 {\n+        return Err(DataFusionError::Internal(format!(\n+            \"{:?} args were supplied but NULLIF takes exactly two args\",\n+            args.len(),\n+        )));\n+    }\n+\n+    // Get args0 == args1 evaluated and produce a boolean array\n+    let cond_array = binary_array_op!(args[0], args[1], eq)?;\n+\n+    // Now, invoke nullif on the result\n+    primitive_bool_array_op!(args[0], *cond_array, nullif)\n+}\n+\n+/// Currently supported types by the nullif function.\n+/// The order of these types correspond to the order on which coercion applies\n+/// This should thus be from least informative to most informative\n+pub static SUPPORTED_NULLIF_TYPES: &'static [DataType] = &[\n+    DataType::Boolean,\n+    DataType::UInt8,\n+    DataType::UInt16,\n+    DataType::UInt32,\n+    DataType::UInt64,\n+    DataType::Int8,\n+    DataType::Int16,\n+    DataType::Int32,\n+    DataType::Int64,\n+    DataType::Float32,\n+    DataType::Float64,\n+];\n\nReview comment:\n       > Better to make these trait bounds with a good comment about how these are selected\r\n   \r\n   AFAIK these cannot be trait bounds because logical and physical planning is dynamically typed. \r\n   \r\n   In this case, this is enumerating all valid types that can be (dynamically) passed to the function. If someone tries to call this function with e.g. a `ListArray`, the logical planner will error with a description that this function does not support that type.\r\n   \r\n   The order here matters because when a function is planned to be called with type `X` that is not supported by the function, the physical planner will try to (lossless) cast that type to a valid type for that functions, and it does so in the order of this array. In general these should be ordered from fastest to slowest (in the eyes of the implementation), so that the cast chooses the type with the fastest implementation.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-17T11:03:11.364+0000",
                    "updated": "2020-11-17T11:03:11.364+0000",
                    "started": "2020-11-17T11:03:11.363+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "512827",
                    "issueId": "13335839"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335839/worklog/512833",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vertexclique commented on a change in pull request #8688:\nURL: https://github.com/apache/arrow/pull/8688#discussion_r525076153\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/expressions.rs\n##########\n@@ -1385,6 +1385,80 @@ pub fn binary(\n     Ok(Arc::new(BinaryExpr::new(l, op, r)))\n }\n \n+/// Invoke a compute kernel on a primitive array and a Boolean Array\n+macro_rules! compute_bool_array_op {\n+    ($LEFT:expr, $RIGHT:expr, $OP:ident, $DT:ident) => {{\n+        let ll = $LEFT\n+            .as_any()\n+            .downcast_ref::<$DT>()\n+            .expect(\"compute_op failed to downcast array\");\n+        let rr = $RIGHT\n+            .as_any()\n+            .downcast_ref::<BooleanArray>()\n+            .expect(\"compute_op failed to downcast array\");\n+        Ok(Arc::new($OP(&ll, &rr)?))\n+    }};\n+}\n+\n+/// Binary op between primitive and boolean arrays\n+macro_rules! primitive_bool_array_op {\n+    ($LEFT:expr, $RIGHT:expr, $OP:ident) => {{\n+        match $LEFT.data_type() {\n+            DataType::Int8 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int8Array),\n+            DataType::Int16 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int16Array),\n+            DataType::Int32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int32Array),\n+            DataType::Int64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int64Array),\n+            DataType::UInt8 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt8Array),\n+            DataType::UInt16 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt16Array),\n+            DataType::UInt32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt32Array),\n+            DataType::UInt64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt64Array),\n+            DataType::Float32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Float32Array),\n+            DataType::Float64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Float64Array),\n+            other => Err(DataFusionError::Internal(format!(\n+                \"Unsupported data type {:?} for NULLIF/primitive/boolean operator\",\n+                other\n+            ))),\n+        }\n+    }};\n+}\n+\n+///\n+/// Implements NULLIF(expr1, expr2)\n+/// Args: 0 - left expr is any array\n+///       1 - if the left is equal to this expr2, then the result is NULL, otherwise left value is passed.\n+///\n+pub fn nullif_func(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    if args.len() != 2 {\n+        return Err(DataFusionError::Internal(format!(\n+            \"{:?} args were supplied but NULLIF takes exactly two args\",\n+            args.len(),\n+        )));\n+    }\n+\n+    // Get args0 == args1 evaluated and produce a boolean array\n+    let cond_array = binary_array_op!(args[0], args[1], eq)?;\n+\n+    // Now, invoke nullif on the result\n+    primitive_bool_array_op!(args[0], *cond_array, nullif)\n+}\n+\n+/// Currently supported types by the nullif function.\n+/// The order of these types correspond to the order on which coercion applies\n+/// This should thus be from least informative to most informative\n+pub static SUPPORTED_NULLIF_TYPES: &'static [DataType] = &[\n+    DataType::Boolean,\n+    DataType::UInt8,\n+    DataType::UInt16,\n+    DataType::UInt32,\n+    DataType::UInt64,\n+    DataType::Int8,\n+    DataType::Int16,\n+    DataType::Int32,\n+    DataType::Int64,\n+    DataType::Float32,\n+    DataType::Float64,\n+];\n\nReview comment:\n       Oh, I see, in our private project at work, I have used type algebra definitions to not do these. For now, this can go like how it is, but later I can open a type algebra pr to convert all these to castability.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-17T11:16:50.504+0000",
                    "updated": "2020-11-17T11:16:50.504+0000",
                    "started": "2020-11-17T11:16:50.504+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "512833",
                    "issueId": "13335839"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335839/worklog/512844",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8688:\nURL: https://github.com/apache/arrow/pull/8688#discussion_r525084383\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/expressions.rs\n##########\n@@ -1385,6 +1385,80 @@ pub fn binary(\n     Ok(Arc::new(BinaryExpr::new(l, op, r)))\n }\n \n+/// Invoke a compute kernel on a primitive array and a Boolean Array\n+macro_rules! compute_bool_array_op {\n+    ($LEFT:expr, $RIGHT:expr, $OP:ident, $DT:ident) => {{\n+        let ll = $LEFT\n+            .as_any()\n+            .downcast_ref::<$DT>()\n+            .expect(\"compute_op failed to downcast array\");\n+        let rr = $RIGHT\n+            .as_any()\n+            .downcast_ref::<BooleanArray>()\n+            .expect(\"compute_op failed to downcast array\");\n+        Ok(Arc::new($OP(&ll, &rr)?))\n+    }};\n+}\n+\n+/// Binary op between primitive and boolean arrays\n+macro_rules! primitive_bool_array_op {\n+    ($LEFT:expr, $RIGHT:expr, $OP:ident) => {{\n+        match $LEFT.data_type() {\n+            DataType::Int8 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int8Array),\n+            DataType::Int16 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int16Array),\n+            DataType::Int32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int32Array),\n+            DataType::Int64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int64Array),\n+            DataType::UInt8 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt8Array),\n+            DataType::UInt16 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt16Array),\n+            DataType::UInt32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt32Array),\n+            DataType::UInt64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt64Array),\n+            DataType::Float32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Float32Array),\n+            DataType::Float64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Float64Array),\n+            other => Err(DataFusionError::Internal(format!(\n+                \"Unsupported data type {:?} for NULLIF/primitive/boolean operator\",\n+                other\n+            ))),\n+        }\n+    }};\n+}\n+\n+///\n+/// Implements NULLIF(expr1, expr2)\n+/// Args: 0 - left expr is any array\n+///       1 - if the left is equal to this expr2, then the result is NULL, otherwise left value is passed.\n+///\n+pub fn nullif_func(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    if args.len() != 2 {\n+        return Err(DataFusionError::Internal(format!(\n+            \"{:?} args were supplied but NULLIF takes exactly two args\",\n+            args.len(),\n+        )));\n+    }\n+\n+    // Get args0 == args1 evaluated and produce a boolean array\n+    let cond_array = binary_array_op!(args[0], args[1], eq)?;\n+\n+    // Now, invoke nullif on the result\n+    primitive_bool_array_op!(args[0], *cond_array, nullif)\n+}\n+\n+/// Currently supported types by the nullif function.\n+/// The order of these types correspond to the order on which coercion applies\n+/// This should thus be from least informative to most informative\n+pub static SUPPORTED_NULLIF_TYPES: &'static [DataType] = &[\n+    DataType::Boolean,\n+    DataType::UInt8,\n+    DataType::UInt16,\n+    DataType::UInt32,\n+    DataType::UInt64,\n+    DataType::Int8,\n+    DataType::Int16,\n+    DataType::Int32,\n+    DataType::Int64,\n+    DataType::Float32,\n+    DataType::Float64,\n+];\n\nReview comment:\n       That is interesting. I would be interested in knowing what is the issue with the current implementation and why type algebra definitions should be used instead. Could first introduce a proposal with the design e.g. on a google docs, before the PR? In DataFusion we have been doing that for larger changes to avoiding committing to an implementation before some general agreement.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-17T11:31:26.433+0000",
                    "updated": "2020-11-17T11:31:26.433+0000",
                    "started": "2020-11-17T11:31:26.433+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "512844",
                    "issueId": "13335839"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335839/worklog/512845",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8688:\nURL: https://github.com/apache/arrow/pull/8688#discussion_r525084383\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/expressions.rs\n##########\n@@ -1385,6 +1385,80 @@ pub fn binary(\n     Ok(Arc::new(BinaryExpr::new(l, op, r)))\n }\n \n+/// Invoke a compute kernel on a primitive array and a Boolean Array\n+macro_rules! compute_bool_array_op {\n+    ($LEFT:expr, $RIGHT:expr, $OP:ident, $DT:ident) => {{\n+        let ll = $LEFT\n+            .as_any()\n+            .downcast_ref::<$DT>()\n+            .expect(\"compute_op failed to downcast array\");\n+        let rr = $RIGHT\n+            .as_any()\n+            .downcast_ref::<BooleanArray>()\n+            .expect(\"compute_op failed to downcast array\");\n+        Ok(Arc::new($OP(&ll, &rr)?))\n+    }};\n+}\n+\n+/// Binary op between primitive and boolean arrays\n+macro_rules! primitive_bool_array_op {\n+    ($LEFT:expr, $RIGHT:expr, $OP:ident) => {{\n+        match $LEFT.data_type() {\n+            DataType::Int8 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int8Array),\n+            DataType::Int16 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int16Array),\n+            DataType::Int32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int32Array),\n+            DataType::Int64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int64Array),\n+            DataType::UInt8 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt8Array),\n+            DataType::UInt16 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt16Array),\n+            DataType::UInt32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt32Array),\n+            DataType::UInt64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt64Array),\n+            DataType::Float32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Float32Array),\n+            DataType::Float64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Float64Array),\n+            other => Err(DataFusionError::Internal(format!(\n+                \"Unsupported data type {:?} for NULLIF/primitive/boolean operator\",\n+                other\n+            ))),\n+        }\n+    }};\n+}\n+\n+///\n+/// Implements NULLIF(expr1, expr2)\n+/// Args: 0 - left expr is any array\n+///       1 - if the left is equal to this expr2, then the result is NULL, otherwise left value is passed.\n+///\n+pub fn nullif_func(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    if args.len() != 2 {\n+        return Err(DataFusionError::Internal(format!(\n+            \"{:?} args were supplied but NULLIF takes exactly two args\",\n+            args.len(),\n+        )));\n+    }\n+\n+    // Get args0 == args1 evaluated and produce a boolean array\n+    let cond_array = binary_array_op!(args[0], args[1], eq)?;\n+\n+    // Now, invoke nullif on the result\n+    primitive_bool_array_op!(args[0], *cond_array, nullif)\n+}\n+\n+/// Currently supported types by the nullif function.\n+/// The order of these types correspond to the order on which coercion applies\n+/// This should thus be from least informative to most informative\n+pub static SUPPORTED_NULLIF_TYPES: &'static [DataType] = &[\n+    DataType::Boolean,\n+    DataType::UInt8,\n+    DataType::UInt16,\n+    DataType::UInt32,\n+    DataType::UInt64,\n+    DataType::Int8,\n+    DataType::Int16,\n+    DataType::Int32,\n+    DataType::Int64,\n+    DataType::Float32,\n+    DataType::Float64,\n+];\n\nReview comment:\n       That is interesting. I would be interested in knowing what is the issue with the current implementation and why type algebra definitions should be used instead. Could you first introduce a proposal with the design e.g. on a google docs, before the PR? In DataFusion we have been doing that for larger changes to avoiding committing to an implementation before some general agreement.\n\n##########\nFile path: rust/datafusion/src/physical_plan/expressions.rs\n##########\n@@ -1385,6 +1385,80 @@ pub fn binary(\n     Ok(Arc::new(BinaryExpr::new(l, op, r)))\n }\n \n+/// Invoke a compute kernel on a primitive array and a Boolean Array\n+macro_rules! compute_bool_array_op {\n+    ($LEFT:expr, $RIGHT:expr, $OP:ident, $DT:ident) => {{\n+        let ll = $LEFT\n+            .as_any()\n+            .downcast_ref::<$DT>()\n+            .expect(\"compute_op failed to downcast array\");\n+        let rr = $RIGHT\n+            .as_any()\n+            .downcast_ref::<BooleanArray>()\n+            .expect(\"compute_op failed to downcast array\");\n+        Ok(Arc::new($OP(&ll, &rr)?))\n+    }};\n+}\n+\n+/// Binary op between primitive and boolean arrays\n+macro_rules! primitive_bool_array_op {\n+    ($LEFT:expr, $RIGHT:expr, $OP:ident) => {{\n+        match $LEFT.data_type() {\n+            DataType::Int8 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int8Array),\n+            DataType::Int16 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int16Array),\n+            DataType::Int32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int32Array),\n+            DataType::Int64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int64Array),\n+            DataType::UInt8 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt8Array),\n+            DataType::UInt16 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt16Array),\n+            DataType::UInt32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt32Array),\n+            DataType::UInt64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt64Array),\n+            DataType::Float32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Float32Array),\n+            DataType::Float64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Float64Array),\n+            other => Err(DataFusionError::Internal(format!(\n+                \"Unsupported data type {:?} for NULLIF/primitive/boolean operator\",\n+                other\n+            ))),\n+        }\n+    }};\n+}\n+\n+///\n+/// Implements NULLIF(expr1, expr2)\n+/// Args: 0 - left expr is any array\n+///       1 - if the left is equal to this expr2, then the result is NULL, otherwise left value is passed.\n+///\n+pub fn nullif_func(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    if args.len() != 2 {\n+        return Err(DataFusionError::Internal(format!(\n+            \"{:?} args were supplied but NULLIF takes exactly two args\",\n+            args.len(),\n+        )));\n+    }\n+\n+    // Get args0 == args1 evaluated and produce a boolean array\n+    let cond_array = binary_array_op!(args[0], args[1], eq)?;\n+\n+    // Now, invoke nullif on the result\n+    primitive_bool_array_op!(args[0], *cond_array, nullif)\n+}\n+\n+/// Currently supported types by the nullif function.\n+/// The order of these types correspond to the order on which coercion applies\n+/// This should thus be from least informative to most informative\n+pub static SUPPORTED_NULLIF_TYPES: &'static [DataType] = &[\n+    DataType::Boolean,\n+    DataType::UInt8,\n+    DataType::UInt16,\n+    DataType::UInt32,\n+    DataType::UInt64,\n+    DataType::Int8,\n+    DataType::Int16,\n+    DataType::Int32,\n+    DataType::Int64,\n+    DataType::Float32,\n+    DataType::Float64,\n+];\n\nReview comment:\n       That is interesting. I would be interested in knowing what is the issue with the current implementation and why type algebra definitions should be used instead. Could you first introduce a proposal with the design e.g. on a google docs, before the PR? In DataFusion we have been doing that for larger changes to avoid committing to an implementation before some general agreement.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-17T11:31:59.496+0000",
                    "updated": "2020-11-17T11:31:59.496+0000",
                    "started": "2020-11-17T11:31:59.496+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "512845",
                    "issueId": "13335839"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335839/worklog/512846",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vertexclique commented on a change in pull request #8688:\nURL: https://github.com/apache/arrow/pull/8688#discussion_r525085824\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/expressions.rs\n##########\n@@ -1385,6 +1385,80 @@ pub fn binary(\n     Ok(Arc::new(BinaryExpr::new(l, op, r)))\n }\n \n+/// Invoke a compute kernel on a primitive array and a Boolean Array\n+macro_rules! compute_bool_array_op {\n+    ($LEFT:expr, $RIGHT:expr, $OP:ident, $DT:ident) => {{\n+        let ll = $LEFT\n+            .as_any()\n+            .downcast_ref::<$DT>()\n+            .expect(\"compute_op failed to downcast array\");\n+        let rr = $RIGHT\n+            .as_any()\n+            .downcast_ref::<BooleanArray>()\n+            .expect(\"compute_op failed to downcast array\");\n+        Ok(Arc::new($OP(&ll, &rr)?))\n+    }};\n+}\n+\n+/// Binary op between primitive and boolean arrays\n+macro_rules! primitive_bool_array_op {\n+    ($LEFT:expr, $RIGHT:expr, $OP:ident) => {{\n+        match $LEFT.data_type() {\n+            DataType::Int8 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int8Array),\n+            DataType::Int16 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int16Array),\n+            DataType::Int32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int32Array),\n+            DataType::Int64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Int64Array),\n+            DataType::UInt8 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt8Array),\n+            DataType::UInt16 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt16Array),\n+            DataType::UInt32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt32Array),\n+            DataType::UInt64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, UInt64Array),\n+            DataType::Float32 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Float32Array),\n+            DataType::Float64 => compute_bool_array_op!($LEFT, $RIGHT, $OP, Float64Array),\n+            other => Err(DataFusionError::Internal(format!(\n+                \"Unsupported data type {:?} for NULLIF/primitive/boolean operator\",\n+                other\n+            ))),\n+        }\n+    }};\n+}\n+\n+///\n+/// Implements NULLIF(expr1, expr2)\n+/// Args: 0 - left expr is any array\n+///       1 - if the left is equal to this expr2, then the result is NULL, otherwise left value is passed.\n+///\n+pub fn nullif_func(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    if args.len() != 2 {\n+        return Err(DataFusionError::Internal(format!(\n+            \"{:?} args were supplied but NULLIF takes exactly two args\",\n+            args.len(),\n+        )));\n+    }\n+\n+    // Get args0 == args1 evaluated and produce a boolean array\n+    let cond_array = binary_array_op!(args[0], args[1], eq)?;\n+\n+    // Now, invoke nullif on the result\n+    primitive_bool_array_op!(args[0], *cond_array, nullif)\n+}\n+\n+/// Currently supported types by the nullif function.\n+/// The order of these types correspond to the order on which coercion applies\n+/// This should thus be from least informative to most informative\n+pub static SUPPORTED_NULLIF_TYPES: &'static [DataType] = &[\n+    DataType::Boolean,\n+    DataType::UInt8,\n+    DataType::UInt16,\n+    DataType::UInt32,\n+    DataType::UInt64,\n+    DataType::Int8,\n+    DataType::Int16,\n+    DataType::Int32,\n+    DataType::Int64,\n+    DataType::Float32,\n+    DataType::Float64,\n+];\n\nReview comment:\n       Oh definitely will do, give me some time to wrap my head up.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-17T11:34:04.786+0000",
                    "updated": "2020-11-17T11:34:04.786+0000",
                    "started": "2020-11-17T11:34:04.786+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "512846",
                    "issueId": "13335839"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335839/worklog/513245",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "velvia commented on a change in pull request #8688:\nURL: https://github.com/apache/arrow/pull/8688#discussion_r525610462\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/boolean.rs\n##########\n@@ -149,6 +150,64 @@ pub fn is_not_null(input: &ArrayRef) -> Result<BooleanArray> {\n     Ok(BooleanArray::from(Arc::new(data)))\n }\n \n+/// Copies original array, setting null bit to true if a secondary comparison boolean array is set to true.\n+/// Typically used to implement NULLIF.\n+pub fn nullif<T>(\n+    left: &PrimitiveArray<T>,\n\nReview comment:\n       Hmmm, I'm trying this, but the return type becomes more complicated....    and as you pointed out, it doesn't help in the end. :-p\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T00:15:34.526+0000",
                    "updated": "2020-11-18T00:15:34.526+0000",
                    "started": "2020-11-18T00:15:34.526+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513245",
                    "issueId": "13335839"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335839/worklog/513247",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "velvia commented on a change in pull request #8688:\nURL: https://github.com/apache/arrow/pull/8688#discussion_r525618283\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/boolean.rs\n##########\n@@ -457,4 +516,20 @@ mod tests {\n         assert_eq!(true, res.value(2));\n         assert_eq!(false, res.value(3));\n     }\n+\n+    #[test]\n+    fn test_nullif_int_array() {\n+        let a = Int32Array::from(vec![Some(15), None, Some(8), Some(1), Some(9)]);\n+        let comp =\n+            BooleanArray::from(vec![Some(false), None, Some(true), Some(false), None]);\n+        let res = nullif(&a, &comp).unwrap();\n+\n+        assert_eq!(15, res.value(0));\n+        assert_eq!(true, res.is_null(1));\n+        assert_eq!(true, res.is_null(2)); // comp true, slot 2 turned into null\n+        assert_eq!(1, res.value(3));\n+        // Even though comp array / right is null, should still pass through original value\n+        assert_eq!(9, res.value(4));\n+        assert_eq!(false, res.is_null(4)); // comp true, slot 2 turned into null\n\nReview comment:\n       So looks like the problem with the above is somehow the equality test fails:\r\n   \r\n   ```\r\n   thread 'compute::kernels::boolean::tests::test_nullif_int_array' panicked at 'assertion failed: `(left == right)`\r\n     left: `PrimitiveArray<Int32>\r\n   [\r\n     15,\r\n     null,\r\n     null,\r\n     1,\r\n     9,\r\n   ]`,\r\n    right: `PrimitiveArray<Int32>\r\n   [\r\n     15,\r\n     null,\r\n     null,\r\n     1,\r\n     9,\r\n   ]`', arrow/src/compute/kernels/boolean.rs:537:9\r\n   ```\r\n   \r\n   My guess is that the equality test compares the data() elements, and the data buffer elements for the null ones are not identical, even though it should not matter (null elements should just check the null bitmap).\r\n   \r\n   Some possibilities:\r\n   - Create a different equality method, maybe a test Trait like `SemanticallyEqual` or something\r\n   - revert back to the old way of testing these arrays\r\n   ???\r\n   @jorgecarleitao \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T00:37:38.079+0000",
                    "updated": "2020-11-18T00:37:38.079+0000",
                    "started": "2020-11-18T00:37:38.079+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513247",
                    "issueId": "13335839"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335839/worklog/513249",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "velvia commented on a change in pull request #8688:\nURL: https://github.com/apache/arrow/pull/8688#discussion_r525618710\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/expressions.rs\n##########\n@@ -2604,6 +2678,61 @@ mod tests {\n         )\n     }\n \n+    #[test]\n+    #[rustfmt::skip]\n\nReview comment:\n       No real reason.... I've removed it\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T00:38:57.463+0000",
                    "updated": "2020-11-18T00:38:57.463+0000",
                    "started": "2020-11-18T00:38:57.463+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513249",
                    "issueId": "13335839"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335839/worklog/513259",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "velvia commented on a change in pull request #8688:\nURL: https://github.com/apache/arrow/pull/8688#discussion_r525621412\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/expressions.rs\n##########\n@@ -2604,6 +2678,61 @@ mod tests {\n         )\n     }\n \n+    #[test]\n+    #[rustfmt::skip]\n+    fn nullif_int32() -> Result<()> {\n+        let schema = Schema::new(vec![Field::new(\"a\", DataType::Int32, false)]);\n+        let a = Int32Array::from(vec![Some(1), Some(2), None, None, Some(3), None, None, Some(4), Some(5)]);\n+        let a = Arc::new(a);\n+        let a_len = a.len();\n+        let batch = RecordBatch::try_new(Arc::new(schema.clone()), vec![a.clone()])?;\n+\n+        let literal_expr = lit(ScalarValue::Int32(Some(2)));\n+        let lit_array = literal_expr.evaluate(&batch)?;\n+\n+        let result = nullif_func(&[a.clone(), lit_array])?;\n+\n+        // Results should be: Some(1), None, None, None, Some(3), None\n+        assert_eq!(result.len(), a_len);\n+\n+        let result = result\n+            .as_any()\n+            .downcast_ref::<Int32Array>()\n+            .expect(\"failed to downcast to Int32Array\");\n+\n+        assert_eq!(1, result.value(0));\n+        assert_eq!(true, result.is_null(1));    // 2==2, slot 1 turned into null\n+        assert_eq!(true, result.is_null(2));\n+        assert_eq!(true, result.is_null(3));\n+        assert_eq!(3, result.value(4));\n+        assert_eq!(true, result.is_null(5));\n+        assert_eq!(true, result.is_null(6));\n+        assert_eq!(5, result.value(8));\n+        Ok(())\n\nReview comment:\n       \ud83d\udc4d \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T00:46:43.107+0000",
                    "updated": "2020-11-18T00:46:43.107+0000",
                    "started": "2020-11-18T00:46:43.107+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513259",
                    "issueId": "13335839"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335839/worklog/513260",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "velvia commented on a change in pull request #8688:\nURL: https://github.com/apache/arrow/pull/8688#discussion_r525621539\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/boolean.rs\n##########\n@@ -457,4 +516,20 @@ mod tests {\n         assert_eq!(true, res.value(2));\n         assert_eq!(false, res.value(3));\n     }\n+\n+    #[test]\n+    fn test_nullif_int_array() {\n+        let a = Int32Array::from(vec![Some(15), None, Some(8), Some(1), Some(9)]);\n+        let comp =\n+            BooleanArray::from(vec![Some(false), None, Some(true), Some(false), None]);\n+        let res = nullif(&a, &comp).unwrap();\n+\n+        assert_eq!(15, res.value(0));\n+        assert_eq!(true, res.is_null(1));\n+        assert_eq!(true, res.is_null(2)); // comp true, slot 2 turned into null\n+        assert_eq!(1, res.value(3));\n+        // Even though comp array / right is null, should still pass through original value\n+        assert_eq!(9, res.value(4));\n+        assert_eq!(false, res.is_null(4)); // comp true, slot 2 turned into null\n\nReview comment:\n       Actually I'm going to borrow `assert_array_eq` from the expressions.rs test.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T00:47:06.244+0000",
                    "updated": "2020-11-18T00:47:06.244+0000",
                    "started": "2020-11-18T00:47:06.244+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513260",
                    "issueId": "13335839"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335839/worklog/513261",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "velvia commented on a change in pull request #8688:\nURL: https://github.com/apache/arrow/pull/8688#discussion_r525621811\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/expressions.rs\n##########\n@@ -2604,6 +2678,61 @@ mod tests {\n         )\n     }\n \n+    #[test]\n+    #[rustfmt::skip]\n+    fn nullif_int32() -> Result<()> {\n+        let schema = Schema::new(vec![Field::new(\"a\", DataType::Int32, false)]);\n+        let a = Int32Array::from(vec![Some(1), Some(2), None, None, Some(3), None, None, Some(4), Some(5)]);\n+        let a = Arc::new(a);\n+        let a_len = a.len();\n+        let batch = RecordBatch::try_new(Arc::new(schema.clone()), vec![a.clone()])?;\n+\n+        let literal_expr = lit(ScalarValue::Int32(Some(2)));\n+        let lit_array = literal_expr.evaluate(&batch)?;\n+\n+        let result = nullif_func(&[a.clone(), lit_array])?;\n+\n+        // Results should be: Some(1), None, None, None, Some(3), None\n+        assert_eq!(result.len(), a_len);\n+\n+        let result = result\n+            .as_any()\n+            .downcast_ref::<Int32Array>()\n+            .expect(\"failed to downcast to Int32Array\");\n+\n+        assert_eq!(1, result.value(0));\n+        assert_eq!(true, result.is_null(1));    // 2==2, slot 1 turned into null\n+        assert_eq!(true, result.is_null(2));\n+        assert_eq!(true, result.is_null(3));\n+        assert_eq!(3, result.value(4));\n+        assert_eq!(true, result.is_null(5));\n+        assert_eq!(true, result.is_null(6));\n+        assert_eq!(5, result.value(8));\n+        Ok(())\n+    }\n+\n+    #[test]\n+    #[rustfmt::skip]\n+    // Ensure that arrays with no nulls can also invoke NULLIF() correctly\n+    fn nullif_int32_nonulls() -> Result<()> {\n+        let schema = Schema::new(vec![Field::new(\"a\", DataType::Int32, false)]);\n+        let a = Int32Array::from(vec![1, 3, 10, 7, 8, 1, 2, 4, 5]);\n+        let a = Arc::new(a);\n+        let a_len = a.len();\n+        let batch = RecordBatch::try_new(Arc::new(schema.clone()), vec![a.clone()])?;\n+\n+        let literal_expr = lit(ScalarValue::Int32(Some(1)));\n+        let lit_array = literal_expr.evaluate(&batch)?;\n\nReview comment:\n       \ud83d\udc4d \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T00:47:59.893+0000",
                    "updated": "2020-11-18T00:47:59.893+0000",
                    "started": "2020-11-18T00:47:59.892+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513261",
                    "issueId": "13335839"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335839/worklog/513360",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8688:\nURL: https://github.com/apache/arrow/pull/8688#discussion_r525818191\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/boolean.rs\n##########\n@@ -457,4 +517,42 @@ mod tests {\n         assert_eq!(true, res.value(2));\n         assert_eq!(false, res.value(3));\n     }\n+\n+    fn assert_array_eq<T: ArrowNumericType>(\n+        expected: PrimitiveArray<T>,\n+        actual: ArrayRef,\n+    ) {\n+        let actual = actual\n+            .as_any()\n+            .downcast_ref::<PrimitiveArray<T>>()\n+            .expect(\"Actual array should unwrap to type of expected array\");\n+\n+        for i in 0..expected.len() {\n+            if expected.is_null(i) {\n+                assert!(actual.is_null(i));\n+            } else {\n+                assert_eq!(expected.value(i), actual.value(i));\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_nullif_int_array() {\n+        let a = Int32Array::from(vec![Some(15), None, Some(8), Some(1), Some(9)]);\n+        let comp =\n+            BooleanArray::from(vec![Some(false), None, Some(true), Some(false), None]);\n+        let res = nullif(&a, &comp).unwrap();\n+\n+        let expected = Int32Array::from(vec![\n+            Some(15),\n+            None,\n+            None, // comp true, slot 2 turned into null\n+            Some(1),\n+            // Even though comp array / right is null, should still pass through original value\n+            // comp true, slot 2 turned into null\n+            Some(9),\n+        ]);\n+\n+        assert_array_eq::<Int32Type>(expected, Arc::new(res));\n\nReview comment:\n       Thanks for your changes, @velvia \r\n   \r\n   If `assert_eq!` is complaining, then we need to investigate why, because that is our canonical way of proving that two arrays are equal.\r\n   \r\n   I think that the issue that `assert_eq` is flagging is that the function `nullif` is returning an arrow array that is out of spec: the `null_count` is equal to the number of elements (due to `Some(left.len()))`), but the actual null count of that array is 2. The array equality takes into account that number (something that `assert_array_eq` does not).\r\n   \r\n   For reference, the way I use to check for these is to debug print the data:\r\n   \r\n   ```rust\r\n   println!(\"{:?}\", expected.data());\r\n   println!(\"{:?}\", result.data());\r\n   ```\r\n   \n\n##########\nFile path: rust/arrow/src/compute/kernels/boolean.rs\n##########\n@@ -457,4 +517,42 @@ mod tests {\n         assert_eq!(true, res.value(2));\n         assert_eq!(false, res.value(3));\n     }\n+\n+    fn assert_array_eq<T: ArrowNumericType>(\n+        expected: PrimitiveArray<T>,\n+        actual: ArrayRef,\n+    ) {\n+        let actual = actual\n+            .as_any()\n+            .downcast_ref::<PrimitiveArray<T>>()\n+            .expect(\"Actual array should unwrap to type of expected array\");\n+\n+        for i in 0..expected.len() {\n+            if expected.is_null(i) {\n+                assert!(actual.is_null(i));\n+            } else {\n+                assert_eq!(expected.value(i), actual.value(i));\n+            }\n+        }\n+    }\n+\n\nReview comment:\n       I wrote the following test with arrays with an offset, as they are typical sources of errors, but I was unable to make it pass (even after fixing the null count):\r\n   \r\n   ```rust\r\n       #[test]\r\n       fn test_nullif_int_array_offset() {\r\n           let a = Int32Array::from(vec![None, Some(15), Some(8), Some(1), Some(9)]);\r\n           let a = a.slice(1, 3); // Some(15), Some(8), Some(1)\r\n           let comp =\r\n               BooleanArray::from(vec![Some(false), Some(false), Some(false), None, Some(true), Some(false), None]);\r\n           let comp = comp.slice(2, 3); // Some(false), None, Some(true)\r\n           let comp = comp.as_any().downcast_ref::<BooleanArray>().unwrap();\r\n           let res = nullif(a.as_ref(), comp).unwrap();\r\n   \r\n           let expected = Arc::new(Int32Array::from(vec![\r\n               Some(15), // False => keep it\r\n               Some(8), // None => keep it\r\n               None, // true => None\r\n           ])) as ArrayRef;\r\n           assert_eq!(&expected, &res)\r\n       }\r\n   ```\r\n   \r\n   Do you know what happens when the arrays have offsets?\r\n   \n\n##########\nFile path: rust/arrow/src/compute/kernels/boolean.rs\n##########\n@@ -149,6 +150,64 @@ pub fn is_not_null(input: &ArrayRef) -> Result<BooleanArray> {\n     Ok(BooleanArray::from(Arc::new(data)))\n }\n \n+/// Copies original array, setting null bit to true if a secondary comparison boolean array is set to true.\n+/// Typically used to implement NULLIF.\n+pub fn nullif<T>(\n+    left: &PrimitiveArray<T>,\n\nReview comment:\n       I think that it would help because on the `arrow` crate this would be a complete implementation. There are people that use `arrow` (but not DataFusion), that would still benefit.\r\n   \r\n   The following would work (I tested it locally :)), if you have the energy:\r\n   \r\n   ```rust\r\n   pub fn nullif(\r\n       left: &impl Array,\r\n       right: &BooleanArray,\r\n   ) -> Result<ArrayRef>\r\n   ...\r\n   \r\n       // Construct new array with same values but modified null bitmap\r\n       let data = ArrayData::new(\r\n           left.data_type().clone(),\r\n           left.len(),\r\n           None, // Note how I am using `None` here, to make `new` compute the number.\r\n           modified_null_buffer,\r\n           left.offset(),\r\n           left_data.buffers().to_vec(),\r\n           left_data.child_data().to_vec(),\r\n       );\r\n       Ok(make_array(Arc::new(data)))\r\n   ```\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T05:43:42.092+0000",
                    "updated": "2020-11-18T05:43:42.092+0000",
                    "started": "2020-11-18T05:43:42.091+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513360",
                    "issueId": "13335839"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335839/worklog/513705",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "velvia commented on a change in pull request #8688:\nURL: https://github.com/apache/arrow/pull/8688#discussion_r526344874\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/boolean.rs\n##########\n@@ -457,4 +517,42 @@ mod tests {\n         assert_eq!(true, res.value(2));\n         assert_eq!(false, res.value(3));\n     }\n+\n+    fn assert_array_eq<T: ArrowNumericType>(\n+        expected: PrimitiveArray<T>,\n+        actual: ArrayRef,\n+    ) {\n+        let actual = actual\n+            .as_any()\n+            .downcast_ref::<PrimitiveArray<T>>()\n+            .expect(\"Actual array should unwrap to type of expected array\");\n+\n+        for i in 0..expected.len() {\n+            if expected.is_null(i) {\n+                assert!(actual.is_null(i));\n+            } else {\n+                assert_eq!(expected.value(i), actual.value(i));\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_nullif_int_array() {\n+        let a = Int32Array::from(vec![Some(15), None, Some(8), Some(1), Some(9)]);\n+        let comp =\n+            BooleanArray::from(vec![Some(false), None, Some(true), Some(false), None]);\n+        let res = nullif(&a, &comp).unwrap();\n+\n+        let expected = Int32Array::from(vec![\n+            Some(15),\n+            None,\n+            None, // comp true, slot 2 turned into null\n+            Some(1),\n+            // Even though comp array / right is null, should still pass through original value\n+            // comp true, slot 2 turned into null\n+            Some(9),\n+        ]);\n+\n+        assert_array_eq::<Int32Type>(expected, Arc::new(res));\n\nReview comment:\n       How is the null_count derived?  Shouldn't it look at the nullity bitmap?  If it is actually checking that the data is zero, then we'd need to modify the array data as part of the nullif() implementation, which would be more expensive and possibly hard to do in a generic way, no?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T18:59:47.762+0000",
                    "updated": "2020-11-18T18:59:47.762+0000",
                    "started": "2020-11-18T18:59:47.762+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513705",
                    "issueId": "13335839"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 33600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@72640fad[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@364518b2[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1cbab4e6[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@224af4b[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3ece0205[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@7e60b8ed[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@37343e43[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@10cd8119[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5e5d772f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@25010bd9[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@33d1ff1c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@4f686536[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 33600,
        "customfield_12312520": null,
        "customfield_12312521": "Fri Nov 27 20:51:44 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-11-27T20:51:44.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10330/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2020-10-17T00:39:33.000+0000",
        "updated": "2020-12-24T19:08:00.000+0000",
        "timeoriginalestimate": null,
        "description": "Here is the common definition of NULLIF() function:\r\n\r\n[https://www.w3schools.com/sql/func_sqlserver_nullif.asp]\r\n\r\n\u00a0\r\n\r\nAmong other uses, it is used to protect denominators from divide by 0 errors.\r\n\r\nWe have implemented it at UrbanLogiq and would like to contribute this back.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "9h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 33600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust][Datafusion] Implement nullif() function for DataFusion",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335839/comment/17215738",
                    "id": "17215738",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
                        "name": "jorgecarleitao",
                        "key": "jorgecarleitao",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
                        },
                        "displayName": "Jorge Leit\u00e3o",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Good idea. (y)\r\n\r\nI moved this to 3.0.0 to not block the 2.0.0 release.\r\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
                        "name": "jorgecarleitao",
                        "key": "jorgecarleitao",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
                        },
                        "displayName": "Jorge Leit\u00e3o",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2020-10-17T04:11:07.775+0000",
                    "updated": "2020-10-17T04:11:07.775+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335839/comment/17239839",
                    "id": "17239839",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
                        "name": "nevi_me",
                        "key": "nevi_me",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
                        },
                        "displayName": "Neville Dipale",
                        "active": true,
                        "timeZone": "Africa/Johannesburg"
                    },
                    "body": "Issue resolved by pull request 8688\n[https://github.com/apache/arrow/pull/8688]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
                        "name": "nevi_me",
                        "key": "nevi_me",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
                        },
                        "displayName": "Neville Dipale",
                        "active": true,
                        "timeZone": "Africa/Johannesburg"
                    },
                    "created": "2020-11-27T20:51:44.651+0000",
                    "updated": "2020-11-27T20:51:44.651+0000"
                }
            ],
            "maxResults": 2,
            "total": 2,
            "startAt": 0
        },
        "customfield_12311820": "0|z0jrrs:",
        "customfield_12314139": null
    }
}