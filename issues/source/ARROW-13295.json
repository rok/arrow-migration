{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13388690",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13388690",
    "key": "ARROW-13295",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12350323",
                "id": "12350323",
                "description": "",
                "name": "6.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-10-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "kernel",
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12619290",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12619290",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "inwardIssue": {
                    "id": "13389644",
                    "key": "ARROW-13339",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13389644",
                    "fields": {
                        "summary": "[C++] Implement hash_aggregate kernels (umbrella issue)",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 12600,
            "total": 12600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 12600,
            "total": 12600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13295/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 21,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13388690/worklog/627202",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm opened a new pull request #10792:\nURL: https://github.com/apache/arrow/pull/10792\n\n\n   Note these don't use pairwise summation and so may be prone to precision issues.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-23T14:09:07.320+0000",
                    "updated": "2021-07-23T14:09:07.320+0000",
                    "started": "2021-07-23T14:09:07.320+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "627202",
                    "issueId": "13388690"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13388690/worklog/627203",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10792:\nURL: https://github.com/apache/arrow/pull/10792#issuecomment-885665761\n\n\n   https://issues.apache.org/jira/browse/ARROW-13295\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-23T14:09:20.936+0000",
                    "updated": "2021-07-23T14:09:20.936+0000",
                    "started": "2021-07-23T14:09:20.936+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "627203",
                    "issueId": "13388690"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13388690/worklog/627753",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #10792:\nURL: https://github.com/apache/arrow/pull/10792#discussion_r676583689\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1005,6 +1007,325 @@ struct GroupedSumFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// Mean implementation\n+\n+template <typename Type>\n+struct GroupedMeanImpl : public GroupedSumImpl<Type> {\n+  Result<Datum> Finalize() override {\n+    using SumType = typename GroupedSumImpl<Type>::SumType;\n+    std::shared_ptr<Buffer> null_bitmap;\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> values,\n+                          AllocateBuffer(num_groups_ * sizeof(double), pool_));\n+    int64_t null_count = 0;\n+\n+    const int64_t* counts = reinterpret_cast<const int64_t*>(counts_.data());\n+    const auto* sums = reinterpret_cast<const SumType*>(sums_.data());\n+    double* means = reinterpret_cast<double*>(values->mutable_data());\n+    for (int64_t i = 0; i < num_groups_; ++i) {\n+      if (counts[i] > 0) {\n+        means[i] = static_cast<double>(sums[i] / counts[i]);\n\nReview comment:\n       Should it be `static_cast<double>(sums[i]) / counts[i]`?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1005,6 +1007,325 @@ struct GroupedSumFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// Mean implementation\n+\n+template <typename Type>\n+struct GroupedMeanImpl : public GroupedSumImpl<Type> {\n+  Result<Datum> Finalize() override {\n+    using SumType = typename GroupedSumImpl<Type>::SumType;\n+    std::shared_ptr<Buffer> null_bitmap;\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> values,\n+                          AllocateBuffer(num_groups_ * sizeof(double), pool_));\n+    int64_t null_count = 0;\n+\n+    const int64_t* counts = reinterpret_cast<const int64_t*>(counts_.data());\n+    const auto* sums = reinterpret_cast<const SumType*>(sums_.data());\n+    double* means = reinterpret_cast<double*>(values->mutable_data());\n+    for (int64_t i = 0; i < num_groups_; ++i) {\n+      if (counts[i] > 0) {\n+        means[i] = static_cast<double>(sums[i] / counts[i]);\n+        continue;\n+      }\n+      means[i] = 0;\n+\n+      if (null_bitmap == nullptr) {\n+        ARROW_ASSIGN_OR_RAISE(null_bitmap, AllocateBitmap(num_groups_, pool_));\n+        BitUtil::SetBitsTo(null_bitmap->mutable_data(), 0, num_groups_, true);\n+      }\n+\n+      null_count += 1;\n+      BitUtil::SetBitTo(null_bitmap->mutable_data(), i, false);\n+    }\n+\n+    return ArrayData::Make(float64(), num_groups_,\n+                           {std::move(null_bitmap), std::move(values)}, null_count);\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override { return float64(); }\n+\n+  using GroupedSumImpl<Type>::num_groups_;\n+  using GroupedSumImpl<Type>::pool_;\n+  using GroupedSumImpl<Type>::counts_;\n+  using GroupedSumImpl<Type>::sums_;\n+};\n+\n+struct GroupedMeanFactory {\n+  template <typename T, typename AccType = typename FindAccumulatorType<T>::Type>\n+  Status Visit(const T&) {\n+    kernel = MakeKernel(std::move(argument_type), HashAggregateInit<GroupedMeanImpl<T>>);\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const HalfFloatType& type) {\n+    return Status::NotImplemented(\"Computing mean of type \", type);\n+  }\n+\n+  Status Visit(const DataType& type) {\n+    return Status::NotImplemented(\"Computing mean of type \", type);\n+  }\n+\n+  static Result<HashAggregateKernel> Make(const std::shared_ptr<DataType>& type) {\n+    GroupedMeanFactory factory;\n+    factory.argument_type = InputType::Array(type);\n+    RETURN_NOT_OK(VisitTypeInline(*type, &factory));\n+    return std::move(factory.kernel);\n+  }\n+\n+  HashAggregateKernel kernel;\n+  InputType argument_type;\n+};\n+\n+// Variance/Stdev implementation\n+\n+using arrow::internal::int128_t;\n+\n+template <typename Type>\n+struct GroupedVarStdImpl : public GroupedAggregator {\n+  using CType = typename Type::c_type;\n+\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    options_ = *checked_cast<const VarianceOptions*>(options);\n+    ctx_ = ctx;\n+    pool_ = ctx->memory_pool();\n+    counts_ = BufferBuilder(pool_);\n+    means_ = BufferBuilder(pool_);\n+    m2s_ = BufferBuilder(pool_);\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    RETURN_NOT_OK(counts_.Append(added_groups * sizeof(int64_t), 0));\n+    RETURN_NOT_OK(means_.Append(added_groups * sizeof(double), 0));\n+    RETURN_NOT_OK(m2s_.Append(added_groups * sizeof(double), 0));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override { return ConsumeImpl(batch); }\n+\n+  // float/double/int64: calculate `m2` (sum((X-mean)^2)) with `two pass algorithm`\n+  // (see aggregate_var_std.cc)\n+  template <typename T = Type>\n+  enable_if_t<is_floating_type<T>::value || (sizeof(CType) > 4), Status> ConsumeImpl(\n+      const ExecBatch& batch) {\n+    using SumType =\n+        typename std::conditional<is_floating_type<T>::value, double, int128_t>::type;\n+\n+    int64_t* counts = reinterpret_cast<int64_t*>(counts_.mutable_data());\n+    double* means = reinterpret_cast<double*>(means_.mutable_data());\n+    double* m2s = reinterpret_cast<double*>(m2s_.mutable_data());\n\nReview comment:\n       Will these buffers always 8 bytes aligned?\r\n   Not a real issue. Just to satisfy ubsan.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-26T13:51:44.039+0000",
                    "updated": "2021-07-26T13:51:44.039+0000",
                    "started": "2021-07-26T13:51:44.039+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "627753",
                    "issueId": "13388690"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13388690/worklog/627771",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #10792:\nURL: https://github.com/apache/arrow/pull/10792#discussion_r676614903\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1005,6 +1007,325 @@ struct GroupedSumFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// Mean implementation\n+\n+template <typename Type>\n+struct GroupedMeanImpl : public GroupedSumImpl<Type> {\n+  Result<Datum> Finalize() override {\n+    using SumType = typename GroupedSumImpl<Type>::SumType;\n+    std::shared_ptr<Buffer> null_bitmap;\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> values,\n+                          AllocateBuffer(num_groups_ * sizeof(double), pool_));\n+    int64_t null_count = 0;\n+\n+    const int64_t* counts = reinterpret_cast<const int64_t*>(counts_.data());\n+    const auto* sums = reinterpret_cast<const SumType*>(sums_.data());\n+    double* means = reinterpret_cast<double*>(values->mutable_data());\n+    for (int64_t i = 0; i < num_groups_; ++i) {\n+      if (counts[i] > 0) {\n+        means[i] = static_cast<double>(sums[i] / counts[i]);\n+        continue;\n+      }\n+      means[i] = 0;\n+\n+      if (null_bitmap == nullptr) {\n+        ARROW_ASSIGN_OR_RAISE(null_bitmap, AllocateBitmap(num_groups_, pool_));\n+        BitUtil::SetBitsTo(null_bitmap->mutable_data(), 0, num_groups_, true);\n+      }\n+\n+      null_count += 1;\n+      BitUtil::SetBitTo(null_bitmap->mutable_data(), i, false);\n+    }\n+\n+    return ArrayData::Make(float64(), num_groups_,\n+                           {std::move(null_bitmap), std::move(values)}, null_count);\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override { return float64(); }\n+\n+  using GroupedSumImpl<Type>::num_groups_;\n+  using GroupedSumImpl<Type>::pool_;\n+  using GroupedSumImpl<Type>::counts_;\n+  using GroupedSumImpl<Type>::sums_;\n+};\n+\n+struct GroupedMeanFactory {\n+  template <typename T, typename AccType = typename FindAccumulatorType<T>::Type>\n+  Status Visit(const T&) {\n+    kernel = MakeKernel(std::move(argument_type), HashAggregateInit<GroupedMeanImpl<T>>);\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const HalfFloatType& type) {\n+    return Status::NotImplemented(\"Computing mean of type \", type);\n+  }\n+\n+  Status Visit(const DataType& type) {\n+    return Status::NotImplemented(\"Computing mean of type \", type);\n+  }\n+\n+  static Result<HashAggregateKernel> Make(const std::shared_ptr<DataType>& type) {\n+    GroupedMeanFactory factory;\n+    factory.argument_type = InputType::Array(type);\n+    RETURN_NOT_OK(VisitTypeInline(*type, &factory));\n+    return std::move(factory.kernel);\n+  }\n+\n+  HashAggregateKernel kernel;\n+  InputType argument_type;\n+};\n+\n+// Variance/Stdev implementation\n+\n+using arrow::internal::int128_t;\n+\n+template <typename Type>\n+struct GroupedVarStdImpl : public GroupedAggregator {\n+  using CType = typename Type::c_type;\n+\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    options_ = *checked_cast<const VarianceOptions*>(options);\n+    ctx_ = ctx;\n+    pool_ = ctx->memory_pool();\n+    counts_ = BufferBuilder(pool_);\n+    means_ = BufferBuilder(pool_);\n+    m2s_ = BufferBuilder(pool_);\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    RETURN_NOT_OK(counts_.Append(added_groups * sizeof(int64_t), 0));\n+    RETURN_NOT_OK(means_.Append(added_groups * sizeof(double), 0));\n+    RETURN_NOT_OK(m2s_.Append(added_groups * sizeof(double), 0));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override { return ConsumeImpl(batch); }\n+\n+  // float/double/int64: calculate `m2` (sum((X-mean)^2)) with `two pass algorithm`\n+  // (see aggregate_var_std.cc)\n+  template <typename T = Type>\n+  enable_if_t<is_floating_type<T>::value || (sizeof(CType) > 4), Status> ConsumeImpl(\n+      const ExecBatch& batch) {\n+    using SumType =\n+        typename std::conditional<is_floating_type<T>::value, double, int128_t>::type;\n+\n+    int64_t* counts = reinterpret_cast<int64_t*>(counts_.mutable_data());\n+    double* means = reinterpret_cast<double*>(means_.mutable_data());\n+    double* m2s = reinterpret_cast<double*>(m2s_.mutable_data());\n+\n+    // XXX this uses naive summation; we should switch to pairwise summation as was\n+    // done for the scalar aggregate kernel in ARROW-11567\n\nReview comment:\n       Should there be the same comment in `GroupedSumImpl`?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate_test.cc\n##########\n@@ -653,6 +653,137 @@ TEST(GroupBy, SumOnly) {\n   }\n }\n \n+TEST(GroupBy, MeanOnly) {\n+  for (bool use_threads : {true, false}) {\n+    SCOPED_TRACE(use_threads ? \"parallel/merged\" : \"serial\");\n+\n+    auto table =\n+        TableFromJSON(schema({field(\"argument\", float64()), field(\"key\", int64())}), {R\"([\n+    [1.0,   1],\n+    [null,  1]\n+                        ])\",\n+                                                                                      R\"([\n+    [0.0,   2],\n+    [null,  3],\n+    [4.0,   null],\n+    [3.25,  1],\n+    [0.125, 2]\n+                        ])\",\n+                                                                                      R\"([\n+    [-0.25, 2],\n+    [0.75,  null],\n+    [null,  3]\n+                        ])\"});\n+\n+    ASSERT_OK_AND_ASSIGN(Datum aggregated_and_grouped,\n+                         internal::GroupBy({table->GetColumnByName(\"argument\")},\n+                                           {table->GetColumnByName(\"key\")},\n+                                           {\n+                                               {\"hash_mean\", nullptr},\n+                                           },\n+                                           use_threads));\n+    SortBy({\"key_0\"}, &aggregated_and_grouped);\n+\n+    AssertDatumsApproxEqual(ArrayFromJSON(struct_({\n+                                              field(\"hash_mean\", float64()),\n+                                              field(\"key_0\", int64()),\n+                                          }),\n+                                          R\"([\n+    [2.125,   1],\n+    [-0.041666666666666664, 2],\n+    [null,   3],\n+    [2.375,   null]\n+  ])\"),\n+                            aggregated_and_grouped,\n+                            /*verbose=*/true);\n+  }\n+}\n+\n+TEST(GroupBy, VarianceAndStddev) {\n+  auto batch = RecordBatchFromJSON(\n+      schema({field(\"argument\", int32()), field(\"key\", int64())}), R\"([\n+    [1,   1],\n+    [null,  1],\n+    [0,   2],\n+    [null,  3],\n+    [4,   null],\n+    [3,  1],\n+    [0, 2],\n+    [-1, 2],\n+    [1,  null],\n+    [null,  3]\n+  ])\");\n+\n+  ASSERT_OK_AND_ASSIGN(Datum aggregated_and_grouped,\n+                       internal::GroupBy(\n+                           {\n+                               batch->GetColumnByName(\"argument\"),\n+                               batch->GetColumnByName(\"argument\"),\n+                           },\n+                           {\n+                               batch->GetColumnByName(\"key\"),\n+                           },\n+                           {\n+                               {\"hash_variance\", nullptr},\n+                               {\"hash_stddev\", nullptr},\n+                           }));\n+\n+  AssertDatumsApproxEqual(ArrayFromJSON(struct_({\n+                                            field(\"hash_variance\", float64()),\n+                                            field(\"hash_stddev\", float64()),\n+                                            field(\"key_0\", int64()),\n+                                        }),\n+                                        R\"([\n+    [1.0,                 1.0,                1],\n+    [0.22222222222222224, 0.4714045207910317, 2],\n+    [null,                null,               3],\n+    [2.25,                1.5,                null]\n+  ])\"),\n+                          aggregated_and_grouped,\n+                          /*verbose=*/true);\n+\n+  batch = RecordBatchFromJSON(\n+      schema({field(\"argument\", float64()), field(\"key\", int64())}), R\"([\n+    [1.0,   1],\n+    [null,  1],\n+    [0.0,   2],\n+    [null,  3],\n+    [4.0,   null],\n+    [3.0,  1],\n+    [0.0, 2],\n+    [-1.0, 2],\n+    [1.0,  null],\n+    [null,  3]\n+  ])\");\n+\n+  ASSERT_OK_AND_ASSIGN(aggregated_and_grouped, internal::GroupBy(\n+                                                   {\n+                                                       batch->GetColumnByName(\"argument\"),\n+                                                       batch->GetColumnByName(\"argument\"),\n+                                                   },\n+                                                   {\n+                                                       batch->GetColumnByName(\"key\"),\n+                                                   },\n+                                                   {\n+                                                       {\"hash_variance\", nullptr},\n+                                                       {\"hash_stddev\", nullptr},\n+                                                   }));\n+\n+  AssertDatumsApproxEqual(ArrayFromJSON(struct_({\n+                                            field(\"hash_variance\", float64()),\n+                                            field(\"hash_stddev\", float64()),\n+                                            field(\"key_0\", int64()),\n+                                        }),\n+                                        R\"([\n+    [1.0,                 1.0,                1],\n+    [0.22222222222222224, 0.4714045207910317, 2],\n+    [null,                null,               3],\n+    [2.25,                1.5,                null]\n+  ])\"),\n+                          aggregated_and_grouped,\n+                          /*verbose=*/true);\n+}\n+\n\nReview comment:\n       These tests are unfortunately verbose, but perhaps you could add nevertheless another test with a different `ddof` (and one group with an insufficient number of non-null values)?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1005,6 +1007,325 @@ struct GroupedSumFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// Mean implementation\n+\n+template <typename Type>\n+struct GroupedMeanImpl : public GroupedSumImpl<Type> {\n+  Result<Datum> Finalize() override {\n+    using SumType = typename GroupedSumImpl<Type>::SumType;\n+    std::shared_ptr<Buffer> null_bitmap;\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> values,\n+                          AllocateBuffer(num_groups_ * sizeof(double), pool_));\n+    int64_t null_count = 0;\n+\n+    const int64_t* counts = reinterpret_cast<const int64_t*>(counts_.data());\n+    const auto* sums = reinterpret_cast<const SumType*>(sums_.data());\n+    double* means = reinterpret_cast<double*>(values->mutable_data());\n+    for (int64_t i = 0; i < num_groups_; ++i) {\n+      if (counts[i] > 0) {\n+        means[i] = static_cast<double>(sums[i] / counts[i]);\n+        continue;\n+      }\n+      means[i] = 0;\n+\n+      if (null_bitmap == nullptr) {\n+        ARROW_ASSIGN_OR_RAISE(null_bitmap, AllocateBitmap(num_groups_, pool_));\n+        BitUtil::SetBitsTo(null_bitmap->mutable_data(), 0, num_groups_, true);\n+      }\n+\n+      null_count += 1;\n+      BitUtil::SetBitTo(null_bitmap->mutable_data(), i, false);\n+    }\n+\n+    return ArrayData::Make(float64(), num_groups_,\n+                           {std::move(null_bitmap), std::move(values)}, null_count);\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override { return float64(); }\n+\n+  using GroupedSumImpl<Type>::num_groups_;\n+  using GroupedSumImpl<Type>::pool_;\n+  using GroupedSumImpl<Type>::counts_;\n+  using GroupedSumImpl<Type>::sums_;\n+};\n+\n+struct GroupedMeanFactory {\n+  template <typename T, typename AccType = typename FindAccumulatorType<T>::Type>\n+  Status Visit(const T&) {\n+    kernel = MakeKernel(std::move(argument_type), HashAggregateInit<GroupedMeanImpl<T>>);\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const HalfFloatType& type) {\n+    return Status::NotImplemented(\"Computing mean of type \", type);\n+  }\n+\n+  Status Visit(const DataType& type) {\n+    return Status::NotImplemented(\"Computing mean of type \", type);\n+  }\n+\n+  static Result<HashAggregateKernel> Make(const std::shared_ptr<DataType>& type) {\n+    GroupedMeanFactory factory;\n+    factory.argument_type = InputType::Array(type);\n+    RETURN_NOT_OK(VisitTypeInline(*type, &factory));\n+    return std::move(factory.kernel);\n+  }\n+\n+  HashAggregateKernel kernel;\n+  InputType argument_type;\n+};\n+\n+// Variance/Stdev implementation\n+\n+using arrow::internal::int128_t;\n+\n+template <typename Type>\n+struct GroupedVarStdImpl : public GroupedAggregator {\n+  using CType = typename Type::c_type;\n+\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    options_ = *checked_cast<const VarianceOptions*>(options);\n+    ctx_ = ctx;\n+    pool_ = ctx->memory_pool();\n+    counts_ = BufferBuilder(pool_);\n+    means_ = BufferBuilder(pool_);\n+    m2s_ = BufferBuilder(pool_);\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    RETURN_NOT_OK(counts_.Append(added_groups * sizeof(int64_t), 0));\n+    RETURN_NOT_OK(means_.Append(added_groups * sizeof(double), 0));\n+    RETURN_NOT_OK(m2s_.Append(added_groups * sizeof(double), 0));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override { return ConsumeImpl(batch); }\n+\n+  // float/double/int64: calculate `m2` (sum((X-mean)^2)) with `two pass algorithm`\n+  // (see aggregate_var_std.cc)\n+  template <typename T = Type>\n+  enable_if_t<is_floating_type<T>::value || (sizeof(CType) > 4), Status> ConsumeImpl(\n+      const ExecBatch& batch) {\n+    using SumType =\n+        typename std::conditional<is_floating_type<T>::value, double, int128_t>::type;\n+\n+    int64_t* counts = reinterpret_cast<int64_t*>(counts_.mutable_data());\n+    double* means = reinterpret_cast<double*>(means_.mutable_data());\n+    double* m2s = reinterpret_cast<double*>(m2s_.mutable_data());\n+\n+    // XXX this uses naive summation; we should switch to pairwise summation as was\n+    // done for the scalar aggregate kernel in ARROW-11567\n+    std::vector<SumType> sums(num_groups_);\n+    auto g = batch[1].array()->GetValues<uint32_t>(1);\n+    VisitArrayDataInline<Type>(\n+        *batch[0].array(),\n+        [&](typename TypeTraits<Type>::CType value) {\n+          sums[*g] += value;\n+          counts[*g] += 1;\n+          ++g;\n+        },\n+        [&] { ++g; });\n+\n+    for (int64_t i = 0; i < num_groups_; i++) {\n+      means[i] = static_cast<double>(sums[i]) / counts[i];\n+    }\n+\n+    g = batch[1].array()->GetValues<uint32_t>(1);\n+    VisitArrayDataInline<Type>(\n+        *batch[0].array(),\n+        [&](typename TypeTraits<Type>::CType value) {\n+          const double v = static_cast<double>(value);\n+          m2s[*g] += (v - means[*g]) * (v - means[*g]);\n+          ++g;\n+        },\n+        [&] { ++g; });\n+\n+    return Status::OK();\n+  }\n+\n+  // int32/16/8: textbook one pass algorithm with integer arithmetic (see\n+  // aggregate_var_std.cc)\n+  template <typename T = Type>\n+  enable_if_t<is_integer_type<T>::value && (sizeof(CType) <= 4), Status> ConsumeImpl(\n+      const ExecBatch& batch) {\n+    // max number of elements that sum will not overflow int64 (2Gi int32 elements)\n+    // for uint32:    0 <= sum < 2^63 (int64 >= 0)\n+    // for int32: -2^62 <= sum < 2^62\n+    constexpr int64_t max_length = 1ULL << (63 - sizeof(CType) * 8);\n+\n+    const auto& array = *batch[0].array();\n+    const auto g = batch[1].array()->GetValues<uint32_t>(1);\n+\n+    std::vector<int64_t> sum(num_groups_);\n+    std::vector<int128_t> square_sum(num_groups_);\n+\n+    ARROW_ASSIGN_OR_RAISE(auto mapping,\n+                          AllocateBuffer(num_groups_ * sizeof(uint32_t), pool_));\n+    for (uint32_t i = 0; static_cast<int64_t>(i) < num_groups_; i++) {\n+      reinterpret_cast<uint32_t*>(mapping->mutable_data())[i] = i;\n+    }\n+    ArrayData group_id_mapping(uint32(), num_groups_, {nullptr, std::move(mapping)},\n+                               /*null_count=*/0);\n+\n+    const CType* values = array.GetValues<CType>(1);\n+\n+    for (int64_t start_index = 0; start_index < batch.length; start_index += max_length) {\n+      // process in chunks that overflow will never happen\n+\n+      // reset state\n+      std::fill(sum.begin(), sum.end(), 0);\n+      std::fill(square_sum.begin(), square_sum.end(), 0);\n+      GroupedVarStdImpl<Type> state;\n+      RETURN_NOT_OK(state.Init(ctx_, &options_));\n+      RETURN_NOT_OK(state.Resize(num_groups_));\n+      int64_t* other_counts = reinterpret_cast<int64_t*>(state.counts_.mutable_data());\n+      double* other_means = reinterpret_cast<double*>(state.means_.mutable_data());\n+      double* other_m2s = reinterpret_cast<double*>(state.m2s_.mutable_data());\n+\n+      arrow::internal::VisitSetBitRunsVoid(\n+          array.buffers[0], array.offset + start_index,\n+          std::min(max_length, batch.length - start_index),\n+          [&](int64_t pos, int64_t len) {\n+            for (int64_t i = 0; i < len; ++i) {\n+              const int64_t index = start_index + pos + i;\n+              const auto value = values[index];\n+              sum[g[index]] += value;\n+              square_sum[g[index]] += static_cast<uint64_t>(value) * value;\n+              other_counts[g[index]]++;\n+            }\n+          });\n+\n+      for (int64_t i = 0; i < num_groups_; i++) {\n+        if (other_counts[i] == 0) continue;\n+\n+        const double mean = static_cast<double>(sum[i]) / other_counts[i];\n+        // calculate m2 = square_sum - sum * sum / count\n+        // decompose `sum * sum / count` into integers and fractions\n+        const int128_t sum_square = static_cast<int128_t>(sum[i]) * sum[i];\n+        const int128_t integers = sum_square / other_counts[i];\n+        const double fractions =\n+            static_cast<double>(sum_square % other_counts[i]) / other_counts[i];\n+        const double m2 = static_cast<double>(square_sum[i] - integers) - fractions;\n+\n+        other_means[i] = mean;\n+        other_m2s[i] = m2;\n+      }\n+      RETURN_NOT_OK(this->Merge(std::move(state), group_id_mapping));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    // Combine m2 from two chunks (see aggregate_var_std.cc)\n+    auto other = checked_cast<GroupedVarStdImpl*>(&raw_other);\n+\n+    auto counts = reinterpret_cast<int64_t*>(counts_.mutable_data());\n+    auto means = reinterpret_cast<double*>(means_.mutable_data());\n+    auto m2s = reinterpret_cast<double*>(m2s_.mutable_data());\n+\n+    const auto* other_counts = reinterpret_cast<const int64_t*>(other->counts_.data());\n+    const auto* other_means = reinterpret_cast<const double*>(other->means_.data());\n+    const auto* other_m2s = reinterpret_cast<const double*>(other->m2s_.data());\n+\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (int64_t other_g = 0; other_g < group_id_mapping.length; ++other_g, ++g) {\n+      if (other_counts[other_g] == 0) continue;\n+      const double mean =\n+          (means[*g] * counts[*g] + other_means[other_g] * other_counts[other_g]) /\n+          (counts[*g] + other_counts[other_g]);\n+      m2s[*g] += other_m2s[other_g] +\n+                 counts[*g] * (means[*g] - mean) * (means[*g] - mean) +\n+                 other_counts[other_g] * (other_means[other_g] - mean) *\n+                     (other_means[other_g] - mean);\n+      counts[*g] += other_counts[other_g];\n+      means[*g] = mean;\n+    }\n\nReview comment:\n       A pity this is duplicating the existing math from the scalar aggregate kernel.\r\n   \r\n   How would you feel about factoring the underlying math in a simple `VarStdOp<ArrowType>` that you would feed values to? You would have one `VarStdOp` in the scalar aggregate kernel and `num_groups_` ones in the hash aggregate kernel.\r\n   \r\n   That might be a bit different performance-wise because you would have an array-of-structures `std::vector<VarStdOp>` rather than a structure-of-arrays of the current three `BufferBuilder`, but I'm not sure it's really important here.\r\n   \r\n   OTOH, `Consume` would not really benefit because the scalar aggregate kernel uses pairwise-summation for floating-point input.\r\n   \r\n   cc @bkietz for advice\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1005,6 +1007,325 @@ struct GroupedSumFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// Mean implementation\n+\n+template <typename Type>\n+struct GroupedMeanImpl : public GroupedSumImpl<Type> {\n+  Result<Datum> Finalize() override {\n+    using SumType = typename GroupedSumImpl<Type>::SumType;\n+    std::shared_ptr<Buffer> null_bitmap;\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> values,\n+                          AllocateBuffer(num_groups_ * sizeof(double), pool_));\n+    int64_t null_count = 0;\n+\n+    const int64_t* counts = reinterpret_cast<const int64_t*>(counts_.data());\n+    const auto* sums = reinterpret_cast<const SumType*>(sums_.data());\n+    double* means = reinterpret_cast<double*>(values->mutable_data());\n+    for (int64_t i = 0; i < num_groups_; ++i) {\n+      if (counts[i] > 0) {\n+        means[i] = static_cast<double>(sums[i] / counts[i]);\n+        continue;\n+      }\n+      means[i] = 0;\n+\n+      if (null_bitmap == nullptr) {\n+        ARROW_ASSIGN_OR_RAISE(null_bitmap, AllocateBitmap(num_groups_, pool_));\n+        BitUtil::SetBitsTo(null_bitmap->mutable_data(), 0, num_groups_, true);\n+      }\n+\n+      null_count += 1;\n+      BitUtil::SetBitTo(null_bitmap->mutable_data(), i, false);\n+    }\n+\n+    return ArrayData::Make(float64(), num_groups_,\n+                           {std::move(null_bitmap), std::move(values)}, null_count);\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override { return float64(); }\n+\n+  using GroupedSumImpl<Type>::num_groups_;\n+  using GroupedSumImpl<Type>::pool_;\n+  using GroupedSumImpl<Type>::counts_;\n+  using GroupedSumImpl<Type>::sums_;\n+};\n+\n+struct GroupedMeanFactory {\n+  template <typename T, typename AccType = typename FindAccumulatorType<T>::Type>\n+  Status Visit(const T&) {\n+    kernel = MakeKernel(std::move(argument_type), HashAggregateInit<GroupedMeanImpl<T>>);\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const HalfFloatType& type) {\n+    return Status::NotImplemented(\"Computing mean of type \", type);\n+  }\n+\n+  Status Visit(const DataType& type) {\n+    return Status::NotImplemented(\"Computing mean of type \", type);\n+  }\n+\n+  static Result<HashAggregateKernel> Make(const std::shared_ptr<DataType>& type) {\n+    GroupedMeanFactory factory;\n+    factory.argument_type = InputType::Array(type);\n+    RETURN_NOT_OK(VisitTypeInline(*type, &factory));\n+    return std::move(factory.kernel);\n+  }\n+\n+  HashAggregateKernel kernel;\n+  InputType argument_type;\n+};\n+\n+// Variance/Stdev implementation\n+\n+using arrow::internal::int128_t;\n+\n+template <typename Type>\n+struct GroupedVarStdImpl : public GroupedAggregator {\n+  using CType = typename Type::c_type;\n+\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    options_ = *checked_cast<const VarianceOptions*>(options);\n+    ctx_ = ctx;\n+    pool_ = ctx->memory_pool();\n+    counts_ = BufferBuilder(pool_);\n+    means_ = BufferBuilder(pool_);\n+    m2s_ = BufferBuilder(pool_);\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    RETURN_NOT_OK(counts_.Append(added_groups * sizeof(int64_t), 0));\n+    RETURN_NOT_OK(means_.Append(added_groups * sizeof(double), 0));\n+    RETURN_NOT_OK(m2s_.Append(added_groups * sizeof(double), 0));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override { return ConsumeImpl(batch); }\n+\n+  // float/double/int64: calculate `m2` (sum((X-mean)^2)) with `two pass algorithm`\n+  // (see aggregate_var_std.cc)\n+  template <typename T = Type>\n+  enable_if_t<is_floating_type<T>::value || (sizeof(CType) > 4), Status> ConsumeImpl(\n+      const ExecBatch& batch) {\n+    using SumType =\n+        typename std::conditional<is_floating_type<T>::value, double, int128_t>::type;\n+\n+    int64_t* counts = reinterpret_cast<int64_t*>(counts_.mutable_data());\n+    double* means = reinterpret_cast<double*>(means_.mutable_data());\n+    double* m2s = reinterpret_cast<double*>(m2s_.mutable_data());\n+\n+    // XXX this uses naive summation; we should switch to pairwise summation as was\n+    // done for the scalar aggregate kernel in ARROW-11567\n+    std::vector<SumType> sums(num_groups_);\n+    auto g = batch[1].array()->GetValues<uint32_t>(1);\n+    VisitArrayDataInline<Type>(\n+        *batch[0].array(),\n+        [&](typename TypeTraits<Type>::CType value) {\n+          sums[*g] += value;\n+          counts[*g] += 1;\n+          ++g;\n+        },\n+        [&] { ++g; });\n+\n+    for (int64_t i = 0; i < num_groups_; i++) {\n+      means[i] = static_cast<double>(sums[i]) / counts[i];\n+    }\n+\n+    g = batch[1].array()->GetValues<uint32_t>(1);\n+    VisitArrayDataInline<Type>(\n+        *batch[0].array(),\n+        [&](typename TypeTraits<Type>::CType value) {\n+          const double v = static_cast<double>(value);\n+          m2s[*g] += (v - means[*g]) * (v - means[*g]);\n+          ++g;\n+        },\n+        [&] { ++g; });\n+\n+    return Status::OK();\n+  }\n+\n+  // int32/16/8: textbook one pass algorithm with integer arithmetic (see\n+  // aggregate_var_std.cc)\n+  template <typename T = Type>\n+  enable_if_t<is_integer_type<T>::value && (sizeof(CType) <= 4), Status> ConsumeImpl(\n+      const ExecBatch& batch) {\n+    // max number of elements that sum will not overflow int64 (2Gi int32 elements)\n+    // for uint32:    0 <= sum < 2^63 (int64 >= 0)\n+    // for int32: -2^62 <= sum < 2^62\n+    constexpr int64_t max_length = 1ULL << (63 - sizeof(CType) * 8);\n+\n+    const auto& array = *batch[0].array();\n+    const auto g = batch[1].array()->GetValues<uint32_t>(1);\n+\n+    std::vector<int64_t> sum(num_groups_);\n+    std::vector<int128_t> square_sum(num_groups_);\n+\n+    ARROW_ASSIGN_OR_RAISE(auto mapping,\n+                          AllocateBuffer(num_groups_ * sizeof(uint32_t), pool_));\n+    for (uint32_t i = 0; static_cast<int64_t>(i) < num_groups_; i++) {\n+      reinterpret_cast<uint32_t*>(mapping->mutable_data())[i] = i;\n+    }\n+    ArrayData group_id_mapping(uint32(), num_groups_, {nullptr, std::move(mapping)},\n+                               /*null_count=*/0);\n+\n+    const CType* values = array.GetValues<CType>(1);\n+\n+    for (int64_t start_index = 0; start_index < batch.length; start_index += max_length) {\n+      // process in chunks that overflow will never happen\n+\n+      // reset state\n+      std::fill(sum.begin(), sum.end(), 0);\n+      std::fill(square_sum.begin(), square_sum.end(), 0);\n+      GroupedVarStdImpl<Type> state;\n+      RETURN_NOT_OK(state.Init(ctx_, &options_));\n+      RETURN_NOT_OK(state.Resize(num_groups_));\n+      int64_t* other_counts = reinterpret_cast<int64_t*>(state.counts_.mutable_data());\n+      double* other_means = reinterpret_cast<double*>(state.means_.mutable_data());\n+      double* other_m2s = reinterpret_cast<double*>(state.m2s_.mutable_data());\n+\n+      arrow::internal::VisitSetBitRunsVoid(\n+          array.buffers[0], array.offset + start_index,\n+          std::min(max_length, batch.length - start_index),\n+          [&](int64_t pos, int64_t len) {\n+            for (int64_t i = 0; i < len; ++i) {\n+              const int64_t index = start_index + pos + i;\n+              const auto value = values[index];\n+              sum[g[index]] += value;\n+              square_sum[g[index]] += static_cast<uint64_t>(value) * value;\n+              other_counts[g[index]]++;\n+            }\n+          });\n+\n+      for (int64_t i = 0; i < num_groups_; i++) {\n+        if (other_counts[i] == 0) continue;\n+\n+        const double mean = static_cast<double>(sum[i]) / other_counts[i];\n+        // calculate m2 = square_sum - sum * sum / count\n+        // decompose `sum * sum / count` into integers and fractions\n+        const int128_t sum_square = static_cast<int128_t>(sum[i]) * sum[i];\n+        const int128_t integers = sum_square / other_counts[i];\n+        const double fractions =\n+            static_cast<double>(sum_square % other_counts[i]) / other_counts[i];\n+        const double m2 = static_cast<double>(square_sum[i] - integers) - fractions;\n+\n+        other_means[i] = mean;\n+        other_m2s[i] = m2;\n+      }\n+      RETURN_NOT_OK(this->Merge(std::move(state), group_id_mapping));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    // Combine m2 from two chunks (see aggregate_var_std.cc)\n+    auto other = checked_cast<GroupedVarStdImpl*>(&raw_other);\n+\n+    auto counts = reinterpret_cast<int64_t*>(counts_.mutable_data());\n+    auto means = reinterpret_cast<double*>(means_.mutable_data());\n+    auto m2s = reinterpret_cast<double*>(m2s_.mutable_data());\n+\n+    const auto* other_counts = reinterpret_cast<const int64_t*>(other->counts_.data());\n+    const auto* other_means = reinterpret_cast<const double*>(other->means_.data());\n+    const auto* other_m2s = reinterpret_cast<const double*>(other->m2s_.data());\n+\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (int64_t other_g = 0; other_g < group_id_mapping.length; ++other_g, ++g) {\n+      if (other_counts[other_g] == 0) continue;\n+      const double mean =\n+          (means[*g] * counts[*g] + other_means[other_g] * other_counts[other_g]) /\n+          (counts[*g] + other_counts[other_g]);\n+      m2s[*g] += other_m2s[other_g] +\n+                 counts[*g] * (means[*g] - mean) * (means[*g] - mean) +\n+                 other_counts[other_g] * (other_means[other_g] - mean) *\n+                     (other_means[other_g] - mean);\n+      counts[*g] += other_counts[other_g];\n+      means[*g] = mean;\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    std::shared_ptr<Buffer> null_bitmap;\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> values,\n+                          AllocateBuffer(num_groups_ * sizeof(double), pool_));\n+    int64_t null_count = 0;\n+\n+    double* results = reinterpret_cast<double*>(values->mutable_data());\n+    const int64_t* counts = reinterpret_cast<const int64_t*>(counts_.data());\n+    const double* m2s = reinterpret_cast<const double*>(m2s_.data());\n+    for (int64_t i = 0; i < num_groups_; ++i) {\n+      if (counts[i] > options_.ddof) {\n+        const double variance = m2s[i] / (counts[i] - options_.ddof);\n+        results[i] = result_type_ == VarOrStd::Var ? variance : std::sqrt(variance);\n+        continue;\n+      }\n+\n+      results[i] = 0;\n+      if (null_bitmap == nullptr) {\n+        ARROW_ASSIGN_OR_RAISE(null_bitmap, AllocateBitmap(num_groups_, pool_));\n+        BitUtil::SetBitsTo(null_bitmap->mutable_data(), 0, num_groups_, true);\n+      }\n+\n+      null_count += 1;\n+      BitUtil::SetBitTo(null_bitmap->mutable_data(), i, false);\n+    }\n+\n+    return ArrayData::Make(float64(), num_groups_,\n+                           {std::move(null_bitmap), std::move(values)}, null_count);\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override { return float64(); }\n+\n+  VarOrStd result_type_;\n+  VarianceOptions options_;\n+  int64_t num_groups_ = 0;\n+  // m2 = count * s2 = sum((X-mean)^2)\n+  BufferBuilder counts_, means_, m2s_;\n+  ExecContext* ctx_;\n+  MemoryPool* pool_;\n+};\n+\n+template <typename T, VarOrStd result_type>\n+Result<std::unique_ptr<KernelState>> VarStdInit(KernelContext* ctx,\n+                                                const KernelInitArgs& args) {\n+  auto impl = ::arrow::internal::make_unique<GroupedVarStdImpl<T>>();\n+  impl->result_type_ = result_type;\n+  RETURN_NOT_OK(impl->Init(ctx->exec_context(), args.options));\n+  return std::move(impl);\n+}\n+\n+template <VarOrStd result_type>\n+struct GroupedVarStdFactory {\n+  template <typename T, typename Enable = enable_if_t<is_integer_type<T>::value ||\n+                                                      is_floating_type<T>::value>>\n+  Status Visit(const T&) {\n+    kernel = MakeKernel(std::move(argument_type), VarStdInit<T, result_type>);\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const HalfFloatType& type) {\n+    return Status::NotImplemented(\"Summing data of type \", type);\n+  }\n+\n+  Status Visit(const DataType& type) {\n+    return Status::NotImplemented(\"Summing data of type \", type);\n\nReview comment:\n       The error message should be updated for this operation.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-26T14:12:01.644+0000",
                    "updated": "2021-07-26T14:12:01.644+0000",
                    "started": "2021-07-26T14:12:01.644+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "627771",
                    "issueId": "13388690"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13388690/worklog/627774",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #10792:\nURL: https://github.com/apache/arrow/pull/10792#discussion_r676645072\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1005,6 +1007,325 @@ struct GroupedSumFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// Mean implementation\n+\n+template <typename Type>\n+struct GroupedMeanImpl : public GroupedSumImpl<Type> {\n+  Result<Datum> Finalize() override {\n+    using SumType = typename GroupedSumImpl<Type>::SumType;\n+    std::shared_ptr<Buffer> null_bitmap;\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> values,\n+                          AllocateBuffer(num_groups_ * sizeof(double), pool_));\n+    int64_t null_count = 0;\n+\n+    const int64_t* counts = reinterpret_cast<const int64_t*>(counts_.data());\n+    const auto* sums = reinterpret_cast<const SumType*>(sums_.data());\n+    double* means = reinterpret_cast<double*>(values->mutable_data());\n+    for (int64_t i = 0; i < num_groups_; ++i) {\n+      if (counts[i] > 0) {\n+        means[i] = static_cast<double>(sums[i] / counts[i]);\n+        continue;\n+      }\n+      means[i] = 0;\n+\n+      if (null_bitmap == nullptr) {\n+        ARROW_ASSIGN_OR_RAISE(null_bitmap, AllocateBitmap(num_groups_, pool_));\n+        BitUtil::SetBitsTo(null_bitmap->mutable_data(), 0, num_groups_, true);\n+      }\n+\n+      null_count += 1;\n+      BitUtil::SetBitTo(null_bitmap->mutable_data(), i, false);\n+    }\n+\n+    return ArrayData::Make(float64(), num_groups_,\n+                           {std::move(null_bitmap), std::move(values)}, null_count);\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override { return float64(); }\n+\n+  using GroupedSumImpl<Type>::num_groups_;\n+  using GroupedSumImpl<Type>::pool_;\n+  using GroupedSumImpl<Type>::counts_;\n+  using GroupedSumImpl<Type>::sums_;\n+};\n+\n+struct GroupedMeanFactory {\n+  template <typename T, typename AccType = typename FindAccumulatorType<T>::Type>\n+  Status Visit(const T&) {\n+    kernel = MakeKernel(std::move(argument_type), HashAggregateInit<GroupedMeanImpl<T>>);\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const HalfFloatType& type) {\n+    return Status::NotImplemented(\"Computing mean of type \", type);\n+  }\n+\n+  Status Visit(const DataType& type) {\n+    return Status::NotImplemented(\"Computing mean of type \", type);\n+  }\n+\n+  static Result<HashAggregateKernel> Make(const std::shared_ptr<DataType>& type) {\n+    GroupedMeanFactory factory;\n+    factory.argument_type = InputType::Array(type);\n+    RETURN_NOT_OK(VisitTypeInline(*type, &factory));\n+    return std::move(factory.kernel);\n+  }\n+\n+  HashAggregateKernel kernel;\n+  InputType argument_type;\n+};\n+\n+// Variance/Stdev implementation\n+\n+using arrow::internal::int128_t;\n+\n+template <typename Type>\n+struct GroupedVarStdImpl : public GroupedAggregator {\n+  using CType = typename Type::c_type;\n+\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    options_ = *checked_cast<const VarianceOptions*>(options);\n+    ctx_ = ctx;\n+    pool_ = ctx->memory_pool();\n+    counts_ = BufferBuilder(pool_);\n+    means_ = BufferBuilder(pool_);\n+    m2s_ = BufferBuilder(pool_);\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    RETURN_NOT_OK(counts_.Append(added_groups * sizeof(int64_t), 0));\n+    RETURN_NOT_OK(means_.Append(added_groups * sizeof(double), 0));\n+    RETURN_NOT_OK(m2s_.Append(added_groups * sizeof(double), 0));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override { return ConsumeImpl(batch); }\n+\n+  // float/double/int64: calculate `m2` (sum((X-mean)^2)) with `two pass algorithm`\n+  // (see aggregate_var_std.cc)\n+  template <typename T = Type>\n+  enable_if_t<is_floating_type<T>::value || (sizeof(CType) > 4), Status> ConsumeImpl(\n+      const ExecBatch& batch) {\n+    using SumType =\n+        typename std::conditional<is_floating_type<T>::value, double, int128_t>::type;\n+\n+    int64_t* counts = reinterpret_cast<int64_t*>(counts_.mutable_data());\n+    double* means = reinterpret_cast<double*>(means_.mutable_data());\n+    double* m2s = reinterpret_cast<double*>(m2s_.mutable_data());\n+\n+    // XXX this uses naive summation; we should switch to pairwise summation as was\n+    // done for the scalar aggregate kernel in ARROW-11567\n+    std::vector<SumType> sums(num_groups_);\n+    auto g = batch[1].array()->GetValues<uint32_t>(1);\n+    VisitArrayDataInline<Type>(\n+        *batch[0].array(),\n+        [&](typename TypeTraits<Type>::CType value) {\n+          sums[*g] += value;\n+          counts[*g] += 1;\n+          ++g;\n+        },\n+        [&] { ++g; });\n+\n+    for (int64_t i = 0; i < num_groups_; i++) {\n+      means[i] = static_cast<double>(sums[i]) / counts[i];\n+    }\n+\n+    g = batch[1].array()->GetValues<uint32_t>(1);\n+    VisitArrayDataInline<Type>(\n+        *batch[0].array(),\n+        [&](typename TypeTraits<Type>::CType value) {\n+          const double v = static_cast<double>(value);\n+          m2s[*g] += (v - means[*g]) * (v - means[*g]);\n+          ++g;\n+        },\n+        [&] { ++g; });\n+\n+    return Status::OK();\n+  }\n+\n+  // int32/16/8: textbook one pass algorithm with integer arithmetic (see\n+  // aggregate_var_std.cc)\n+  template <typename T = Type>\n+  enable_if_t<is_integer_type<T>::value && (sizeof(CType) <= 4), Status> ConsumeImpl(\n+      const ExecBatch& batch) {\n+    // max number of elements that sum will not overflow int64 (2Gi int32 elements)\n+    // for uint32:    0 <= sum < 2^63 (int64 >= 0)\n+    // for int32: -2^62 <= sum < 2^62\n+    constexpr int64_t max_length = 1ULL << (63 - sizeof(CType) * 8);\n+\n+    const auto& array = *batch[0].array();\n+    const auto g = batch[1].array()->GetValues<uint32_t>(1);\n+\n+    std::vector<int64_t> sum(num_groups_);\n+    std::vector<int128_t> square_sum(num_groups_);\n+\n+    ARROW_ASSIGN_OR_RAISE(auto mapping,\n+                          AllocateBuffer(num_groups_ * sizeof(uint32_t), pool_));\n+    for (uint32_t i = 0; static_cast<int64_t>(i) < num_groups_; i++) {\n+      reinterpret_cast<uint32_t*>(mapping->mutable_data())[i] = i;\n+    }\n+    ArrayData group_id_mapping(uint32(), num_groups_, {nullptr, std::move(mapping)},\n+                               /*null_count=*/0);\n+\n+    const CType* values = array.GetValues<CType>(1);\n+\n+    for (int64_t start_index = 0; start_index < batch.length; start_index += max_length) {\n+      // process in chunks that overflow will never happen\n+\n+      // reset state\n+      std::fill(sum.begin(), sum.end(), 0);\n+      std::fill(square_sum.begin(), square_sum.end(), 0);\n+      GroupedVarStdImpl<Type> state;\n+      RETURN_NOT_OK(state.Init(ctx_, &options_));\n+      RETURN_NOT_OK(state.Resize(num_groups_));\n+      int64_t* other_counts = reinterpret_cast<int64_t*>(state.counts_.mutable_data());\n+      double* other_means = reinterpret_cast<double*>(state.means_.mutable_data());\n+      double* other_m2s = reinterpret_cast<double*>(state.m2s_.mutable_data());\n+\n+      arrow::internal::VisitSetBitRunsVoid(\n+          array.buffers[0], array.offset + start_index,\n+          std::min(max_length, batch.length - start_index),\n+          [&](int64_t pos, int64_t len) {\n+            for (int64_t i = 0; i < len; ++i) {\n+              const int64_t index = start_index + pos + i;\n+              const auto value = values[index];\n+              sum[g[index]] += value;\n+              square_sum[g[index]] += static_cast<uint64_t>(value) * value;\n+              other_counts[g[index]]++;\n+            }\n+          });\n+\n+      for (int64_t i = 0; i < num_groups_; i++) {\n+        if (other_counts[i] == 0) continue;\n+\n+        const double mean = static_cast<double>(sum[i]) / other_counts[i];\n+        // calculate m2 = square_sum - sum * sum / count\n+        // decompose `sum * sum / count` into integers and fractions\n+        const int128_t sum_square = static_cast<int128_t>(sum[i]) * sum[i];\n+        const int128_t integers = sum_square / other_counts[i];\n+        const double fractions =\n+            static_cast<double>(sum_square % other_counts[i]) / other_counts[i];\n+        const double m2 = static_cast<double>(square_sum[i] - integers) - fractions;\n+\n+        other_means[i] = mean;\n+        other_m2s[i] = m2;\n+      }\n+      RETURN_NOT_OK(this->Merge(std::move(state), group_id_mapping));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    // Combine m2 from two chunks (see aggregate_var_std.cc)\n+    auto other = checked_cast<GroupedVarStdImpl*>(&raw_other);\n+\n+    auto counts = reinterpret_cast<int64_t*>(counts_.mutable_data());\n+    auto means = reinterpret_cast<double*>(means_.mutable_data());\n+    auto m2s = reinterpret_cast<double*>(m2s_.mutable_data());\n+\n+    const auto* other_counts = reinterpret_cast<const int64_t*>(other->counts_.data());\n+    const auto* other_means = reinterpret_cast<const double*>(other->means_.data());\n+    const auto* other_m2s = reinterpret_cast<const double*>(other->m2s_.data());\n+\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (int64_t other_g = 0; other_g < group_id_mapping.length; ++other_g, ++g) {\n+      if (other_counts[other_g] == 0) continue;\n+      const double mean =\n+          (means[*g] * counts[*g] + other_means[other_g] * other_counts[other_g]) /\n+          (counts[*g] + other_counts[other_g]);\n+      m2s[*g] += other_m2s[other_g] +\n+                 counts[*g] * (means[*g] - mean) * (means[*g] - mean) +\n+                 other_counts[other_g] * (other_means[other_g] - mean) *\n+                     (other_means[other_g] - mean);\n+      counts[*g] += other_counts[other_g];\n+      means[*g] = mean;\n+    }\n\nReview comment:\n       Also @cyb70289 \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-26T14:15:45.566+0000",
                    "updated": "2021-07-26T14:15:45.566+0000",
                    "started": "2021-07-26T14:15:45.565+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "627774",
                    "issueId": "13388690"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13388690/worklog/627807",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10792:\nURL: https://github.com/apache/arrow/pull/10792#discussion_r676687330\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1005,6 +1007,325 @@ struct GroupedSumFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// Mean implementation\n+\n+template <typename Type>\n+struct GroupedMeanImpl : public GroupedSumImpl<Type> {\n+  Result<Datum> Finalize() override {\n+    using SumType = typename GroupedSumImpl<Type>::SumType;\n+    std::shared_ptr<Buffer> null_bitmap;\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> values,\n+                          AllocateBuffer(num_groups_ * sizeof(double), pool_));\n+    int64_t null_count = 0;\n+\n+    const int64_t* counts = reinterpret_cast<const int64_t*>(counts_.data());\n+    const auto* sums = reinterpret_cast<const SumType*>(sums_.data());\n+    double* means = reinterpret_cast<double*>(values->mutable_data());\n+    for (int64_t i = 0; i < num_groups_; ++i) {\n+      if (counts[i] > 0) {\n+        means[i] = static_cast<double>(sums[i] / counts[i]);\n+        continue;\n+      }\n+      means[i] = 0;\n+\n+      if (null_bitmap == nullptr) {\n+        ARROW_ASSIGN_OR_RAISE(null_bitmap, AllocateBitmap(num_groups_, pool_));\n+        BitUtil::SetBitsTo(null_bitmap->mutable_data(), 0, num_groups_, true);\n+      }\n+\n+      null_count += 1;\n+      BitUtil::SetBitTo(null_bitmap->mutable_data(), i, false);\n+    }\n+\n+    return ArrayData::Make(float64(), num_groups_,\n+                           {std::move(null_bitmap), std::move(values)}, null_count);\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override { return float64(); }\n+\n+  using GroupedSumImpl<Type>::num_groups_;\n+  using GroupedSumImpl<Type>::pool_;\n+  using GroupedSumImpl<Type>::counts_;\n+  using GroupedSumImpl<Type>::sums_;\n+};\n+\n+struct GroupedMeanFactory {\n+  template <typename T, typename AccType = typename FindAccumulatorType<T>::Type>\n+  Status Visit(const T&) {\n+    kernel = MakeKernel(std::move(argument_type), HashAggregateInit<GroupedMeanImpl<T>>);\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const HalfFloatType& type) {\n+    return Status::NotImplemented(\"Computing mean of type \", type);\n+  }\n+\n+  Status Visit(const DataType& type) {\n+    return Status::NotImplemented(\"Computing mean of type \", type);\n+  }\n+\n+  static Result<HashAggregateKernel> Make(const std::shared_ptr<DataType>& type) {\n+    GroupedMeanFactory factory;\n+    factory.argument_type = InputType::Array(type);\n+    RETURN_NOT_OK(VisitTypeInline(*type, &factory));\n+    return std::move(factory.kernel);\n+  }\n+\n+  HashAggregateKernel kernel;\n+  InputType argument_type;\n+};\n+\n+// Variance/Stdev implementation\n+\n+using arrow::internal::int128_t;\n+\n+template <typename Type>\n+struct GroupedVarStdImpl : public GroupedAggregator {\n+  using CType = typename Type::c_type;\n+\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    options_ = *checked_cast<const VarianceOptions*>(options);\n+    ctx_ = ctx;\n+    pool_ = ctx->memory_pool();\n+    counts_ = BufferBuilder(pool_);\n+    means_ = BufferBuilder(pool_);\n+    m2s_ = BufferBuilder(pool_);\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    RETURN_NOT_OK(counts_.Append(added_groups * sizeof(int64_t), 0));\n+    RETURN_NOT_OK(means_.Append(added_groups * sizeof(double), 0));\n+    RETURN_NOT_OK(m2s_.Append(added_groups * sizeof(double), 0));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override { return ConsumeImpl(batch); }\n+\n+  // float/double/int64: calculate `m2` (sum((X-mean)^2)) with `two pass algorithm`\n+  // (see aggregate_var_std.cc)\n+  template <typename T = Type>\n+  enable_if_t<is_floating_type<T>::value || (sizeof(CType) > 4), Status> ConsumeImpl(\n+      const ExecBatch& batch) {\n+    using SumType =\n+        typename std::conditional<is_floating_type<T>::value, double, int128_t>::type;\n+\n+    int64_t* counts = reinterpret_cast<int64_t*>(counts_.mutable_data());\n+    double* means = reinterpret_cast<double*>(means_.mutable_data());\n+    double* m2s = reinterpret_cast<double*>(m2s_.mutable_data());\n+\n+    // XXX this uses naive summation; we should switch to pairwise summation as was\n+    // done for the scalar aggregate kernel in ARROW-11567\n+    std::vector<SumType> sums(num_groups_);\n+    auto g = batch[1].array()->GetValues<uint32_t>(1);\n+    VisitArrayDataInline<Type>(\n+        *batch[0].array(),\n+        [&](typename TypeTraits<Type>::CType value) {\n+          sums[*g] += value;\n+          counts[*g] += 1;\n+          ++g;\n+        },\n+        [&] { ++g; });\n+\n+    for (int64_t i = 0; i < num_groups_; i++) {\n+      means[i] = static_cast<double>(sums[i]) / counts[i];\n+    }\n+\n+    g = batch[1].array()->GetValues<uint32_t>(1);\n+    VisitArrayDataInline<Type>(\n+        *batch[0].array(),\n+        [&](typename TypeTraits<Type>::CType value) {\n+          const double v = static_cast<double>(value);\n+          m2s[*g] += (v - means[*g]) * (v - means[*g]);\n+          ++g;\n+        },\n+        [&] { ++g; });\n+\n+    return Status::OK();\n+  }\n+\n+  // int32/16/8: textbook one pass algorithm with integer arithmetic (see\n+  // aggregate_var_std.cc)\n+  template <typename T = Type>\n+  enable_if_t<is_integer_type<T>::value && (sizeof(CType) <= 4), Status> ConsumeImpl(\n+      const ExecBatch& batch) {\n+    // max number of elements that sum will not overflow int64 (2Gi int32 elements)\n+    // for uint32:    0 <= sum < 2^63 (int64 >= 0)\n+    // for int32: -2^62 <= sum < 2^62\n+    constexpr int64_t max_length = 1ULL << (63 - sizeof(CType) * 8);\n+\n+    const auto& array = *batch[0].array();\n+    const auto g = batch[1].array()->GetValues<uint32_t>(1);\n+\n+    std::vector<int64_t> sum(num_groups_);\n+    std::vector<int128_t> square_sum(num_groups_);\n+\n+    ARROW_ASSIGN_OR_RAISE(auto mapping,\n+                          AllocateBuffer(num_groups_ * sizeof(uint32_t), pool_));\n+    for (uint32_t i = 0; static_cast<int64_t>(i) < num_groups_; i++) {\n+      reinterpret_cast<uint32_t*>(mapping->mutable_data())[i] = i;\n+    }\n+    ArrayData group_id_mapping(uint32(), num_groups_, {nullptr, std::move(mapping)},\n+                               /*null_count=*/0);\n+\n+    const CType* values = array.GetValues<CType>(1);\n+\n+    for (int64_t start_index = 0; start_index < batch.length; start_index += max_length) {\n+      // process in chunks that overflow will never happen\n+\n+      // reset state\n+      std::fill(sum.begin(), sum.end(), 0);\n+      std::fill(square_sum.begin(), square_sum.end(), 0);\n+      GroupedVarStdImpl<Type> state;\n+      RETURN_NOT_OK(state.Init(ctx_, &options_));\n+      RETURN_NOT_OK(state.Resize(num_groups_));\n+      int64_t* other_counts = reinterpret_cast<int64_t*>(state.counts_.mutable_data());\n+      double* other_means = reinterpret_cast<double*>(state.means_.mutable_data());\n+      double* other_m2s = reinterpret_cast<double*>(state.m2s_.mutable_data());\n+\n+      arrow::internal::VisitSetBitRunsVoid(\n+          array.buffers[0], array.offset + start_index,\n+          std::min(max_length, batch.length - start_index),\n+          [&](int64_t pos, int64_t len) {\n+            for (int64_t i = 0; i < len; ++i) {\n+              const int64_t index = start_index + pos + i;\n+              const auto value = values[index];\n+              sum[g[index]] += value;\n+              square_sum[g[index]] += static_cast<uint64_t>(value) * value;\n+              other_counts[g[index]]++;\n+            }\n+          });\n+\n+      for (int64_t i = 0; i < num_groups_; i++) {\n+        if (other_counts[i] == 0) continue;\n+\n+        const double mean = static_cast<double>(sum[i]) / other_counts[i];\n+        // calculate m2 = square_sum - sum * sum / count\n+        // decompose `sum * sum / count` into integers and fractions\n+        const int128_t sum_square = static_cast<int128_t>(sum[i]) * sum[i];\n+        const int128_t integers = sum_square / other_counts[i];\n+        const double fractions =\n+            static_cast<double>(sum_square % other_counts[i]) / other_counts[i];\n+        const double m2 = static_cast<double>(square_sum[i] - integers) - fractions;\n+\n+        other_means[i] = mean;\n+        other_m2s[i] = m2;\n+      }\n+      RETURN_NOT_OK(this->Merge(std::move(state), group_id_mapping));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    // Combine m2 from two chunks (see aggregate_var_std.cc)\n+    auto other = checked_cast<GroupedVarStdImpl*>(&raw_other);\n+\n+    auto counts = reinterpret_cast<int64_t*>(counts_.mutable_data());\n+    auto means = reinterpret_cast<double*>(means_.mutable_data());\n+    auto m2s = reinterpret_cast<double*>(m2s_.mutable_data());\n+\n+    const auto* other_counts = reinterpret_cast<const int64_t*>(other->counts_.data());\n+    const auto* other_means = reinterpret_cast<const double*>(other->means_.data());\n+    const auto* other_m2s = reinterpret_cast<const double*>(other->m2s_.data());\n+\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (int64_t other_g = 0; other_g < group_id_mapping.length; ++other_g, ++g) {\n+      if (other_counts[other_g] == 0) continue;\n+      const double mean =\n+          (means[*g] * counts[*g] + other_means[other_g] * other_counts[other_g]) /\n+          (counts[*g] + other_counts[other_g]);\n+      m2s[*g] += other_m2s[other_g] +\n+                 counts[*g] * (means[*g] - mean) * (means[*g] - mean) +\n+                 other_counts[other_g] * (other_means[other_g] - mean) *\n+                     (other_means[other_g] - mean);\n+      counts[*g] += other_counts[other_g];\n+      means[*g] = mean;\n+    }\n\nReview comment:\n       Another option that Ben's mentioned would be to treat scalar aggregation as a hash aggregation with one group, though then we should immediately tackle the pairwise summation issue.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-26T15:00:45.977+0000",
                    "updated": "2021-07-26T15:00:45.977+0000",
                    "started": "2021-07-26T15:00:45.977+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "627807",
                    "issueId": "13388690"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13388690/worklog/627811",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10792:\nURL: https://github.com/apache/arrow/pull/10792#discussion_r676693009\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1005,6 +1007,325 @@ struct GroupedSumFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// Mean implementation\n+\n+template <typename Type>\n+struct GroupedMeanImpl : public GroupedSumImpl<Type> {\n+  Result<Datum> Finalize() override {\n+    using SumType = typename GroupedSumImpl<Type>::SumType;\n+    std::shared_ptr<Buffer> null_bitmap;\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> values,\n+                          AllocateBuffer(num_groups_ * sizeof(double), pool_));\n+    int64_t null_count = 0;\n+\n+    const int64_t* counts = reinterpret_cast<const int64_t*>(counts_.data());\n+    const auto* sums = reinterpret_cast<const SumType*>(sums_.data());\n+    double* means = reinterpret_cast<double*>(values->mutable_data());\n+    for (int64_t i = 0; i < num_groups_; ++i) {\n+      if (counts[i] > 0) {\n+        means[i] = static_cast<double>(sums[i] / counts[i]);\n+        continue;\n+      }\n+      means[i] = 0;\n+\n+      if (null_bitmap == nullptr) {\n+        ARROW_ASSIGN_OR_RAISE(null_bitmap, AllocateBitmap(num_groups_, pool_));\n+        BitUtil::SetBitsTo(null_bitmap->mutable_data(), 0, num_groups_, true);\n+      }\n+\n+      null_count += 1;\n+      BitUtil::SetBitTo(null_bitmap->mutable_data(), i, false);\n+    }\n+\n+    return ArrayData::Make(float64(), num_groups_,\n+                           {std::move(null_bitmap), std::move(values)}, null_count);\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override { return float64(); }\n+\n+  using GroupedSumImpl<Type>::num_groups_;\n+  using GroupedSumImpl<Type>::pool_;\n+  using GroupedSumImpl<Type>::counts_;\n+  using GroupedSumImpl<Type>::sums_;\n+};\n+\n+struct GroupedMeanFactory {\n+  template <typename T, typename AccType = typename FindAccumulatorType<T>::Type>\n+  Status Visit(const T&) {\n+    kernel = MakeKernel(std::move(argument_type), HashAggregateInit<GroupedMeanImpl<T>>);\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const HalfFloatType& type) {\n+    return Status::NotImplemented(\"Computing mean of type \", type);\n+  }\n+\n+  Status Visit(const DataType& type) {\n+    return Status::NotImplemented(\"Computing mean of type \", type);\n+  }\n+\n+  static Result<HashAggregateKernel> Make(const std::shared_ptr<DataType>& type) {\n+    GroupedMeanFactory factory;\n+    factory.argument_type = InputType::Array(type);\n+    RETURN_NOT_OK(VisitTypeInline(*type, &factory));\n+    return std::move(factory.kernel);\n+  }\n+\n+  HashAggregateKernel kernel;\n+  InputType argument_type;\n+};\n+\n+// Variance/Stdev implementation\n+\n+using arrow::internal::int128_t;\n+\n+template <typename Type>\n+struct GroupedVarStdImpl : public GroupedAggregator {\n+  using CType = typename Type::c_type;\n+\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    options_ = *checked_cast<const VarianceOptions*>(options);\n+    ctx_ = ctx;\n+    pool_ = ctx->memory_pool();\n+    counts_ = BufferBuilder(pool_);\n+    means_ = BufferBuilder(pool_);\n+    m2s_ = BufferBuilder(pool_);\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    RETURN_NOT_OK(counts_.Append(added_groups * sizeof(int64_t), 0));\n+    RETURN_NOT_OK(means_.Append(added_groups * sizeof(double), 0));\n+    RETURN_NOT_OK(m2s_.Append(added_groups * sizeof(double), 0));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override { return ConsumeImpl(batch); }\n+\n+  // float/double/int64: calculate `m2` (sum((X-mean)^2)) with `two pass algorithm`\n+  // (see aggregate_var_std.cc)\n+  template <typename T = Type>\n+  enable_if_t<is_floating_type<T>::value || (sizeof(CType) > 4), Status> ConsumeImpl(\n+      const ExecBatch& batch) {\n+    using SumType =\n+        typename std::conditional<is_floating_type<T>::value, double, int128_t>::type;\n+\n+    int64_t* counts = reinterpret_cast<int64_t*>(counts_.mutable_data());\n+    double* means = reinterpret_cast<double*>(means_.mutable_data());\n+    double* m2s = reinterpret_cast<double*>(m2s_.mutable_data());\n\nReview comment:\n       These use BufferBuilder which defer to the allocator, which should give us aligned allocations (and the builder additionally pads allocations).\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-26T15:07:08.015+0000",
                    "updated": "2021-07-26T15:07:08.015+0000",
                    "started": "2021-07-26T15:07:08.015+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "627811",
                    "issueId": "13388690"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13388690/worklog/627937",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10792:\nURL: https://github.com/apache/arrow/pull/10792#discussion_r676867859\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1005,6 +1007,325 @@ struct GroupedSumFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// Mean implementation\n+\n+template <typename Type>\n+struct GroupedMeanImpl : public GroupedSumImpl<Type> {\n+  Result<Datum> Finalize() override {\n+    using SumType = typename GroupedSumImpl<Type>::SumType;\n+    std::shared_ptr<Buffer> null_bitmap;\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> values,\n+                          AllocateBuffer(num_groups_ * sizeof(double), pool_));\n+    int64_t null_count = 0;\n+\n+    const int64_t* counts = reinterpret_cast<const int64_t*>(counts_.data());\n+    const auto* sums = reinterpret_cast<const SumType*>(sums_.data());\n+    double* means = reinterpret_cast<double*>(values->mutable_data());\n+    for (int64_t i = 0; i < num_groups_; ++i) {\n+      if (counts[i] > 0) {\n+        means[i] = static_cast<double>(sums[i] / counts[i]);\n+        continue;\n+      }\n+      means[i] = 0;\n+\n+      if (null_bitmap == nullptr) {\n+        ARROW_ASSIGN_OR_RAISE(null_bitmap, AllocateBitmap(num_groups_, pool_));\n+        BitUtil::SetBitsTo(null_bitmap->mutable_data(), 0, num_groups_, true);\n+      }\n+\n+      null_count += 1;\n+      BitUtil::SetBitTo(null_bitmap->mutable_data(), i, false);\n+    }\n+\n+    return ArrayData::Make(float64(), num_groups_,\n+                           {std::move(null_bitmap), std::move(values)}, null_count);\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override { return float64(); }\n+\n+  using GroupedSumImpl<Type>::num_groups_;\n+  using GroupedSumImpl<Type>::pool_;\n+  using GroupedSumImpl<Type>::counts_;\n+  using GroupedSumImpl<Type>::sums_;\n+};\n+\n+struct GroupedMeanFactory {\n+  template <typename T, typename AccType = typename FindAccumulatorType<T>::Type>\n+  Status Visit(const T&) {\n+    kernel = MakeKernel(std::move(argument_type), HashAggregateInit<GroupedMeanImpl<T>>);\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const HalfFloatType& type) {\n+    return Status::NotImplemented(\"Computing mean of type \", type);\n+  }\n+\n+  Status Visit(const DataType& type) {\n+    return Status::NotImplemented(\"Computing mean of type \", type);\n+  }\n+\n+  static Result<HashAggregateKernel> Make(const std::shared_ptr<DataType>& type) {\n+    GroupedMeanFactory factory;\n+    factory.argument_type = InputType::Array(type);\n+    RETURN_NOT_OK(VisitTypeInline(*type, &factory));\n+    return std::move(factory.kernel);\n+  }\n+\n+  HashAggregateKernel kernel;\n+  InputType argument_type;\n+};\n+\n+// Variance/Stdev implementation\n+\n+using arrow::internal::int128_t;\n+\n+template <typename Type>\n+struct GroupedVarStdImpl : public GroupedAggregator {\n+  using CType = typename Type::c_type;\n+\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    options_ = *checked_cast<const VarianceOptions*>(options);\n+    ctx_ = ctx;\n+    pool_ = ctx->memory_pool();\n+    counts_ = BufferBuilder(pool_);\n+    means_ = BufferBuilder(pool_);\n+    m2s_ = BufferBuilder(pool_);\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    RETURN_NOT_OK(counts_.Append(added_groups * sizeof(int64_t), 0));\n+    RETURN_NOT_OK(means_.Append(added_groups * sizeof(double), 0));\n+    RETURN_NOT_OK(m2s_.Append(added_groups * sizeof(double), 0));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override { return ConsumeImpl(batch); }\n+\n+  // float/double/int64: calculate `m2` (sum((X-mean)^2)) with `two pass algorithm`\n+  // (see aggregate_var_std.cc)\n+  template <typename T = Type>\n+  enable_if_t<is_floating_type<T>::value || (sizeof(CType) > 4), Status> ConsumeImpl(\n+      const ExecBatch& batch) {\n+    using SumType =\n+        typename std::conditional<is_floating_type<T>::value, double, int128_t>::type;\n+\n+    int64_t* counts = reinterpret_cast<int64_t*>(counts_.mutable_data());\n+    double* means = reinterpret_cast<double*>(means_.mutable_data());\n+    double* m2s = reinterpret_cast<double*>(m2s_.mutable_data());\n+\n+    // XXX this uses naive summation; we should switch to pairwise summation as was\n+    // done for the scalar aggregate kernel in ARROW-11567\n+    std::vector<SumType> sums(num_groups_);\n+    auto g = batch[1].array()->GetValues<uint32_t>(1);\n+    VisitArrayDataInline<Type>(\n+        *batch[0].array(),\n+        [&](typename TypeTraits<Type>::CType value) {\n+          sums[*g] += value;\n+          counts[*g] += 1;\n+          ++g;\n+        },\n+        [&] { ++g; });\n+\n+    for (int64_t i = 0; i < num_groups_; i++) {\n+      means[i] = static_cast<double>(sums[i]) / counts[i];\n+    }\n+\n+    g = batch[1].array()->GetValues<uint32_t>(1);\n+    VisitArrayDataInline<Type>(\n+        *batch[0].array(),\n+        [&](typename TypeTraits<Type>::CType value) {\n+          const double v = static_cast<double>(value);\n+          m2s[*g] += (v - means[*g]) * (v - means[*g]);\n+          ++g;\n+        },\n+        [&] { ++g; });\n+\n+    return Status::OK();\n+  }\n+\n+  // int32/16/8: textbook one pass algorithm with integer arithmetic (see\n+  // aggregate_var_std.cc)\n+  template <typename T = Type>\n+  enable_if_t<is_integer_type<T>::value && (sizeof(CType) <= 4), Status> ConsumeImpl(\n+      const ExecBatch& batch) {\n+    // max number of elements that sum will not overflow int64 (2Gi int32 elements)\n+    // for uint32:    0 <= sum < 2^63 (int64 >= 0)\n+    // for int32: -2^62 <= sum < 2^62\n+    constexpr int64_t max_length = 1ULL << (63 - sizeof(CType) * 8);\n+\n+    const auto& array = *batch[0].array();\n+    const auto g = batch[1].array()->GetValues<uint32_t>(1);\n+\n+    std::vector<int64_t> sum(num_groups_);\n+    std::vector<int128_t> square_sum(num_groups_);\n+\n+    ARROW_ASSIGN_OR_RAISE(auto mapping,\n+                          AllocateBuffer(num_groups_ * sizeof(uint32_t), pool_));\n+    for (uint32_t i = 0; static_cast<int64_t>(i) < num_groups_; i++) {\n+      reinterpret_cast<uint32_t*>(mapping->mutable_data())[i] = i;\n+    }\n+    ArrayData group_id_mapping(uint32(), num_groups_, {nullptr, std::move(mapping)},\n+                               /*null_count=*/0);\n+\n+    const CType* values = array.GetValues<CType>(1);\n+\n+    for (int64_t start_index = 0; start_index < batch.length; start_index += max_length) {\n+      // process in chunks that overflow will never happen\n+\n+      // reset state\n+      std::fill(sum.begin(), sum.end(), 0);\n+      std::fill(square_sum.begin(), square_sum.end(), 0);\n+      GroupedVarStdImpl<Type> state;\n+      RETURN_NOT_OK(state.Init(ctx_, &options_));\n+      RETURN_NOT_OK(state.Resize(num_groups_));\n+      int64_t* other_counts = reinterpret_cast<int64_t*>(state.counts_.mutable_data());\n+      double* other_means = reinterpret_cast<double*>(state.means_.mutable_data());\n+      double* other_m2s = reinterpret_cast<double*>(state.m2s_.mutable_data());\n+\n+      arrow::internal::VisitSetBitRunsVoid(\n+          array.buffers[0], array.offset + start_index,\n+          std::min(max_length, batch.length - start_index),\n+          [&](int64_t pos, int64_t len) {\n+            for (int64_t i = 0; i < len; ++i) {\n+              const int64_t index = start_index + pos + i;\n+              const auto value = values[index];\n+              sum[g[index]] += value;\n+              square_sum[g[index]] += static_cast<uint64_t>(value) * value;\n+              other_counts[g[index]]++;\n+            }\n+          });\n+\n+      for (int64_t i = 0; i < num_groups_; i++) {\n+        if (other_counts[i] == 0) continue;\n+\n+        const double mean = static_cast<double>(sum[i]) / other_counts[i];\n+        // calculate m2 = square_sum - sum * sum / count\n+        // decompose `sum * sum / count` into integers and fractions\n+        const int128_t sum_square = static_cast<int128_t>(sum[i]) * sum[i];\n+        const int128_t integers = sum_square / other_counts[i];\n+        const double fractions =\n+            static_cast<double>(sum_square % other_counts[i]) / other_counts[i];\n+        const double m2 = static_cast<double>(square_sum[i] - integers) - fractions;\n+\n+        other_means[i] = mean;\n+        other_m2s[i] = m2;\n+      }\n+      RETURN_NOT_OK(this->Merge(std::move(state), group_id_mapping));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    // Combine m2 from two chunks (see aggregate_var_std.cc)\n+    auto other = checked_cast<GroupedVarStdImpl*>(&raw_other);\n+\n+    auto counts = reinterpret_cast<int64_t*>(counts_.mutable_data());\n+    auto means = reinterpret_cast<double*>(means_.mutable_data());\n+    auto m2s = reinterpret_cast<double*>(m2s_.mutable_data());\n+\n+    const auto* other_counts = reinterpret_cast<const int64_t*>(other->counts_.data());\n+    const auto* other_means = reinterpret_cast<const double*>(other->means_.data());\n+    const auto* other_m2s = reinterpret_cast<const double*>(other->m2s_.data());\n+\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (int64_t other_g = 0; other_g < group_id_mapping.length; ++other_g, ++g) {\n+      if (other_counts[other_g] == 0) continue;\n+      const double mean =\n+          (means[*g] * counts[*g] + other_means[other_g] * other_counts[other_g]) /\n+          (counts[*g] + other_counts[other_g]);\n+      m2s[*g] += other_m2s[other_g] +\n+                 counts[*g] * (means[*g] - mean) * (means[*g] - mean) +\n+                 other_counts[other_g] * (other_means[other_g] - mean) *\n+                     (other_means[other_g] - mean);\n+      counts[*g] += other_counts[other_g];\n+      means[*g] = mean;\n+    }\n\nReview comment:\n       https://issues.apache.org/jira/browse/ARROW-13451\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-26T19:03:21.407+0000",
                    "updated": "2021-07-26T19:03:21.407+0000",
                    "started": "2021-07-26T19:03:21.406+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "627937",
                    "issueId": "13388690"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13388690/worklog/627986",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10792:\nURL: https://github.com/apache/arrow/pull/10792#discussion_r676913833\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1005,6 +1007,325 @@ struct GroupedSumFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// Mean implementation\n+\n+template <typename Type>\n+struct GroupedMeanImpl : public GroupedSumImpl<Type> {\n+  Result<Datum> Finalize() override {\n+    using SumType = typename GroupedSumImpl<Type>::SumType;\n+    std::shared_ptr<Buffer> null_bitmap;\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> values,\n+                          AllocateBuffer(num_groups_ * sizeof(double), pool_));\n+    int64_t null_count = 0;\n+\n+    const int64_t* counts = reinterpret_cast<const int64_t*>(counts_.data());\n+    const auto* sums = reinterpret_cast<const SumType*>(sums_.data());\n+    double* means = reinterpret_cast<double*>(values->mutable_data());\n+    for (int64_t i = 0; i < num_groups_; ++i) {\n+      if (counts[i] > 0) {\n+        means[i] = static_cast<double>(sums[i] / counts[i]);\n+        continue;\n+      }\n+      means[i] = 0;\n+\n+      if (null_bitmap == nullptr) {\n+        ARROW_ASSIGN_OR_RAISE(null_bitmap, AllocateBitmap(num_groups_, pool_));\n+        BitUtil::SetBitsTo(null_bitmap->mutable_data(), 0, num_groups_, true);\n+      }\n+\n+      null_count += 1;\n+      BitUtil::SetBitTo(null_bitmap->mutable_data(), i, false);\n+    }\n+\n+    return ArrayData::Make(float64(), num_groups_,\n+                           {std::move(null_bitmap), std::move(values)}, null_count);\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override { return float64(); }\n+\n+  using GroupedSumImpl<Type>::num_groups_;\n+  using GroupedSumImpl<Type>::pool_;\n+  using GroupedSumImpl<Type>::counts_;\n+  using GroupedSumImpl<Type>::sums_;\n+};\n+\n+struct GroupedMeanFactory {\n+  template <typename T, typename AccType = typename FindAccumulatorType<T>::Type>\n+  Status Visit(const T&) {\n+    kernel = MakeKernel(std::move(argument_type), HashAggregateInit<GroupedMeanImpl<T>>);\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const HalfFloatType& type) {\n+    return Status::NotImplemented(\"Computing mean of type \", type);\n+  }\n+\n+  Status Visit(const DataType& type) {\n+    return Status::NotImplemented(\"Computing mean of type \", type);\n+  }\n+\n+  static Result<HashAggregateKernel> Make(const std::shared_ptr<DataType>& type) {\n+    GroupedMeanFactory factory;\n+    factory.argument_type = InputType::Array(type);\n+    RETURN_NOT_OK(VisitTypeInline(*type, &factory));\n+    return std::move(factory.kernel);\n+  }\n+\n+  HashAggregateKernel kernel;\n+  InputType argument_type;\n+};\n+\n+// Variance/Stdev implementation\n+\n+using arrow::internal::int128_t;\n+\n+template <typename Type>\n+struct GroupedVarStdImpl : public GroupedAggregator {\n+  using CType = typename Type::c_type;\n+\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    options_ = *checked_cast<const VarianceOptions*>(options);\n+    ctx_ = ctx;\n+    pool_ = ctx->memory_pool();\n+    counts_ = BufferBuilder(pool_);\n+    means_ = BufferBuilder(pool_);\n+    m2s_ = BufferBuilder(pool_);\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    RETURN_NOT_OK(counts_.Append(added_groups * sizeof(int64_t), 0));\n+    RETURN_NOT_OK(means_.Append(added_groups * sizeof(double), 0));\n+    RETURN_NOT_OK(m2s_.Append(added_groups * sizeof(double), 0));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override { return ConsumeImpl(batch); }\n+\n+  // float/double/int64: calculate `m2` (sum((X-mean)^2)) with `two pass algorithm`\n+  // (see aggregate_var_std.cc)\n+  template <typename T = Type>\n+  enable_if_t<is_floating_type<T>::value || (sizeof(CType) > 4), Status> ConsumeImpl(\n+      const ExecBatch& batch) {\n+    using SumType =\n+        typename std::conditional<is_floating_type<T>::value, double, int128_t>::type;\n+\n+    int64_t* counts = reinterpret_cast<int64_t*>(counts_.mutable_data());\n+    double* means = reinterpret_cast<double*>(means_.mutable_data());\n+    double* m2s = reinterpret_cast<double*>(m2s_.mutable_data());\n+\n+    // XXX this uses naive summation; we should switch to pairwise summation as was\n+    // done for the scalar aggregate kernel in ARROW-11567\n+    std::vector<SumType> sums(num_groups_);\n+    auto g = batch[1].array()->GetValues<uint32_t>(1);\n+    VisitArrayDataInline<Type>(\n+        *batch[0].array(),\n+        [&](typename TypeTraits<Type>::CType value) {\n+          sums[*g] += value;\n+          counts[*g] += 1;\n+          ++g;\n+        },\n+        [&] { ++g; });\n+\n+    for (int64_t i = 0; i < num_groups_; i++) {\n+      means[i] = static_cast<double>(sums[i]) / counts[i];\n+    }\n+\n+    g = batch[1].array()->GetValues<uint32_t>(1);\n+    VisitArrayDataInline<Type>(\n+        *batch[0].array(),\n+        [&](typename TypeTraits<Type>::CType value) {\n+          const double v = static_cast<double>(value);\n+          m2s[*g] += (v - means[*g]) * (v - means[*g]);\n+          ++g;\n+        },\n+        [&] { ++g; });\n+\n+    return Status::OK();\n+  }\n+\n+  // int32/16/8: textbook one pass algorithm with integer arithmetic (see\n+  // aggregate_var_std.cc)\n+  template <typename T = Type>\n+  enable_if_t<is_integer_type<T>::value && (sizeof(CType) <= 4), Status> ConsumeImpl(\n+      const ExecBatch& batch) {\n+    // max number of elements that sum will not overflow int64 (2Gi int32 elements)\n+    // for uint32:    0 <= sum < 2^63 (int64 >= 0)\n+    // for int32: -2^62 <= sum < 2^62\n+    constexpr int64_t max_length = 1ULL << (63 - sizeof(CType) * 8);\n+\n+    const auto& array = *batch[0].array();\n+    const auto g = batch[1].array()->GetValues<uint32_t>(1);\n+\n+    std::vector<int64_t> sum(num_groups_);\n+    std::vector<int128_t> square_sum(num_groups_);\n+\n+    ARROW_ASSIGN_OR_RAISE(auto mapping,\n+                          AllocateBuffer(num_groups_ * sizeof(uint32_t), pool_));\n+    for (uint32_t i = 0; static_cast<int64_t>(i) < num_groups_; i++) {\n+      reinterpret_cast<uint32_t*>(mapping->mutable_data())[i] = i;\n+    }\n+    ArrayData group_id_mapping(uint32(), num_groups_, {nullptr, std::move(mapping)},\n+                               /*null_count=*/0);\n+\n+    const CType* values = array.GetValues<CType>(1);\n+\n+    for (int64_t start_index = 0; start_index < batch.length; start_index += max_length) {\n+      // process in chunks that overflow will never happen\n+\n+      // reset state\n+      std::fill(sum.begin(), sum.end(), 0);\n+      std::fill(square_sum.begin(), square_sum.end(), 0);\n+      GroupedVarStdImpl<Type> state;\n+      RETURN_NOT_OK(state.Init(ctx_, &options_));\n+      RETURN_NOT_OK(state.Resize(num_groups_));\n+      int64_t* other_counts = reinterpret_cast<int64_t*>(state.counts_.mutable_data());\n+      double* other_means = reinterpret_cast<double*>(state.means_.mutable_data());\n+      double* other_m2s = reinterpret_cast<double*>(state.m2s_.mutable_data());\n+\n+      arrow::internal::VisitSetBitRunsVoid(\n+          array.buffers[0], array.offset + start_index,\n+          std::min(max_length, batch.length - start_index),\n+          [&](int64_t pos, int64_t len) {\n+            for (int64_t i = 0; i < len; ++i) {\n+              const int64_t index = start_index + pos + i;\n+              const auto value = values[index];\n+              sum[g[index]] += value;\n+              square_sum[g[index]] += static_cast<uint64_t>(value) * value;\n+              other_counts[g[index]]++;\n+            }\n+          });\n+\n+      for (int64_t i = 0; i < num_groups_; i++) {\n+        if (other_counts[i] == 0) continue;\n+\n+        const double mean = static_cast<double>(sum[i]) / other_counts[i];\n+        // calculate m2 = square_sum - sum * sum / count\n+        // decompose `sum * sum / count` into integers and fractions\n+        const int128_t sum_square = static_cast<int128_t>(sum[i]) * sum[i];\n+        const int128_t integers = sum_square / other_counts[i];\n+        const double fractions =\n+            static_cast<double>(sum_square % other_counts[i]) / other_counts[i];\n+        const double m2 = static_cast<double>(square_sum[i] - integers) - fractions;\n+\n+        other_means[i] = mean;\n+        other_m2s[i] = m2;\n+      }\n+      RETURN_NOT_OK(this->Merge(std::move(state), group_id_mapping));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    // Combine m2 from two chunks (see aggregate_var_std.cc)\n+    auto other = checked_cast<GroupedVarStdImpl*>(&raw_other);\n+\n+    auto counts = reinterpret_cast<int64_t*>(counts_.mutable_data());\n+    auto means = reinterpret_cast<double*>(means_.mutable_data());\n+    auto m2s = reinterpret_cast<double*>(m2s_.mutable_data());\n+\n+    const auto* other_counts = reinterpret_cast<const int64_t*>(other->counts_.data());\n+    const auto* other_means = reinterpret_cast<const double*>(other->means_.data());\n+    const auto* other_m2s = reinterpret_cast<const double*>(other->m2s_.data());\n+\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (int64_t other_g = 0; other_g < group_id_mapping.length; ++other_g, ++g) {\n+      if (other_counts[other_g] == 0) continue;\n+      const double mean =\n+          (means[*g] * counts[*g] + other_means[other_g] * other_counts[other_g]) /\n+          (counts[*g] + other_counts[other_g]);\n+      m2s[*g] += other_m2s[other_g] +\n+                 counts[*g] * (means[*g] - mean) * (means[*g] - mean) +\n+                 other_counts[other_g] * (other_means[other_g] - mean) *\n+                     (other_means[other_g] - mean);\n+      counts[*g] += other_counts[other_g];\n+      means[*g] = mean;\n+    }\n\nReview comment:\n       I'll see if I can get a comparison up before I'm out.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-26T20:18:20.002+0000",
                    "updated": "2021-07-26T20:18:20.002+0000",
                    "started": "2021-07-26T20:18:20.001+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "627986",
                    "issueId": "13388690"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13388690/worklog/628441",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10792:\nURL: https://github.com/apache/arrow/pull/10792#discussion_r677453068\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1005,6 +1007,325 @@ struct GroupedSumFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// Mean implementation\n+\n+template <typename Type>\n+struct GroupedMeanImpl : public GroupedSumImpl<Type> {\n+  Result<Datum> Finalize() override {\n+    using SumType = typename GroupedSumImpl<Type>::SumType;\n+    std::shared_ptr<Buffer> null_bitmap;\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> values,\n+                          AllocateBuffer(num_groups_ * sizeof(double), pool_));\n+    int64_t null_count = 0;\n+\n+    const int64_t* counts = reinterpret_cast<const int64_t*>(counts_.data());\n+    const auto* sums = reinterpret_cast<const SumType*>(sums_.data());\n+    double* means = reinterpret_cast<double*>(values->mutable_data());\n+    for (int64_t i = 0; i < num_groups_; ++i) {\n+      if (counts[i] > 0) {\n+        means[i] = static_cast<double>(sums[i] / counts[i]);\n+        continue;\n+      }\n+      means[i] = 0;\n+\n+      if (null_bitmap == nullptr) {\n+        ARROW_ASSIGN_OR_RAISE(null_bitmap, AllocateBitmap(num_groups_, pool_));\n+        BitUtil::SetBitsTo(null_bitmap->mutable_data(), 0, num_groups_, true);\n+      }\n+\n+      null_count += 1;\n+      BitUtil::SetBitTo(null_bitmap->mutable_data(), i, false);\n+    }\n+\n+    return ArrayData::Make(float64(), num_groups_,\n+                           {std::move(null_bitmap), std::move(values)}, null_count);\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override { return float64(); }\n+\n+  using GroupedSumImpl<Type>::num_groups_;\n+  using GroupedSumImpl<Type>::pool_;\n+  using GroupedSumImpl<Type>::counts_;\n+  using GroupedSumImpl<Type>::sums_;\n+};\n+\n+struct GroupedMeanFactory {\n+  template <typename T, typename AccType = typename FindAccumulatorType<T>::Type>\n+  Status Visit(const T&) {\n+    kernel = MakeKernel(std::move(argument_type), HashAggregateInit<GroupedMeanImpl<T>>);\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const HalfFloatType& type) {\n+    return Status::NotImplemented(\"Computing mean of type \", type);\n+  }\n+\n+  Status Visit(const DataType& type) {\n+    return Status::NotImplemented(\"Computing mean of type \", type);\n+  }\n+\n+  static Result<HashAggregateKernel> Make(const std::shared_ptr<DataType>& type) {\n+    GroupedMeanFactory factory;\n+    factory.argument_type = InputType::Array(type);\n+    RETURN_NOT_OK(VisitTypeInline(*type, &factory));\n+    return std::move(factory.kernel);\n+  }\n+\n+  HashAggregateKernel kernel;\n+  InputType argument_type;\n+};\n+\n+// Variance/Stdev implementation\n+\n+using arrow::internal::int128_t;\n+\n+template <typename Type>\n+struct GroupedVarStdImpl : public GroupedAggregator {\n+  using CType = typename Type::c_type;\n+\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    options_ = *checked_cast<const VarianceOptions*>(options);\n+    ctx_ = ctx;\n+    pool_ = ctx->memory_pool();\n+    counts_ = BufferBuilder(pool_);\n+    means_ = BufferBuilder(pool_);\n+    m2s_ = BufferBuilder(pool_);\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    RETURN_NOT_OK(counts_.Append(added_groups * sizeof(int64_t), 0));\n+    RETURN_NOT_OK(means_.Append(added_groups * sizeof(double), 0));\n+    RETURN_NOT_OK(m2s_.Append(added_groups * sizeof(double), 0));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override { return ConsumeImpl(batch); }\n+\n+  // float/double/int64: calculate `m2` (sum((X-mean)^2)) with `two pass algorithm`\n+  // (see aggregate_var_std.cc)\n+  template <typename T = Type>\n+  enable_if_t<is_floating_type<T>::value || (sizeof(CType) > 4), Status> ConsumeImpl(\n+      const ExecBatch& batch) {\n+    using SumType =\n+        typename std::conditional<is_floating_type<T>::value, double, int128_t>::type;\n+\n+    int64_t* counts = reinterpret_cast<int64_t*>(counts_.mutable_data());\n+    double* means = reinterpret_cast<double*>(means_.mutable_data());\n+    double* m2s = reinterpret_cast<double*>(m2s_.mutable_data());\n+\n+    // XXX this uses naive summation; we should switch to pairwise summation as was\n+    // done for the scalar aggregate kernel in ARROW-11567\n+    std::vector<SumType> sums(num_groups_);\n+    auto g = batch[1].array()->GetValues<uint32_t>(1);\n+    VisitArrayDataInline<Type>(\n+        *batch[0].array(),\n+        [&](typename TypeTraits<Type>::CType value) {\n+          sums[*g] += value;\n+          counts[*g] += 1;\n+          ++g;\n+        },\n+        [&] { ++g; });\n+\n+    for (int64_t i = 0; i < num_groups_; i++) {\n+      means[i] = static_cast<double>(sums[i]) / counts[i];\n+    }\n+\n+    g = batch[1].array()->GetValues<uint32_t>(1);\n+    VisitArrayDataInline<Type>(\n+        *batch[0].array(),\n+        [&](typename TypeTraits<Type>::CType value) {\n+          const double v = static_cast<double>(value);\n+          m2s[*g] += (v - means[*g]) * (v - means[*g]);\n+          ++g;\n+        },\n+        [&] { ++g; });\n+\n+    return Status::OK();\n+  }\n+\n+  // int32/16/8: textbook one pass algorithm with integer arithmetic (see\n+  // aggregate_var_std.cc)\n+  template <typename T = Type>\n+  enable_if_t<is_integer_type<T>::value && (sizeof(CType) <= 4), Status> ConsumeImpl(\n+      const ExecBatch& batch) {\n+    // max number of elements that sum will not overflow int64 (2Gi int32 elements)\n+    // for uint32:    0 <= sum < 2^63 (int64 >= 0)\n+    // for int32: -2^62 <= sum < 2^62\n+    constexpr int64_t max_length = 1ULL << (63 - sizeof(CType) * 8);\n+\n+    const auto& array = *batch[0].array();\n+    const auto g = batch[1].array()->GetValues<uint32_t>(1);\n+\n+    std::vector<int64_t> sum(num_groups_);\n+    std::vector<int128_t> square_sum(num_groups_);\n+\n+    ARROW_ASSIGN_OR_RAISE(auto mapping,\n+                          AllocateBuffer(num_groups_ * sizeof(uint32_t), pool_));\n+    for (uint32_t i = 0; static_cast<int64_t>(i) < num_groups_; i++) {\n+      reinterpret_cast<uint32_t*>(mapping->mutable_data())[i] = i;\n+    }\n+    ArrayData group_id_mapping(uint32(), num_groups_, {nullptr, std::move(mapping)},\n+                               /*null_count=*/0);\n+\n+    const CType* values = array.GetValues<CType>(1);\n+\n+    for (int64_t start_index = 0; start_index < batch.length; start_index += max_length) {\n+      // process in chunks that overflow will never happen\n+\n+      // reset state\n+      std::fill(sum.begin(), sum.end(), 0);\n+      std::fill(square_sum.begin(), square_sum.end(), 0);\n+      GroupedVarStdImpl<Type> state;\n+      RETURN_NOT_OK(state.Init(ctx_, &options_));\n+      RETURN_NOT_OK(state.Resize(num_groups_));\n+      int64_t* other_counts = reinterpret_cast<int64_t*>(state.counts_.mutable_data());\n+      double* other_means = reinterpret_cast<double*>(state.means_.mutable_data());\n+      double* other_m2s = reinterpret_cast<double*>(state.m2s_.mutable_data());\n+\n+      arrow::internal::VisitSetBitRunsVoid(\n+          array.buffers[0], array.offset + start_index,\n+          std::min(max_length, batch.length - start_index),\n+          [&](int64_t pos, int64_t len) {\n+            for (int64_t i = 0; i < len; ++i) {\n+              const int64_t index = start_index + pos + i;\n+              const auto value = values[index];\n+              sum[g[index]] += value;\n+              square_sum[g[index]] += static_cast<uint64_t>(value) * value;\n+              other_counts[g[index]]++;\n+            }\n+          });\n+\n+      for (int64_t i = 0; i < num_groups_; i++) {\n+        if (other_counts[i] == 0) continue;\n+\n+        const double mean = static_cast<double>(sum[i]) / other_counts[i];\n+        // calculate m2 = square_sum - sum * sum / count\n+        // decompose `sum * sum / count` into integers and fractions\n+        const int128_t sum_square = static_cast<int128_t>(sum[i]) * sum[i];\n+        const int128_t integers = sum_square / other_counts[i];\n+        const double fractions =\n+            static_cast<double>(sum_square % other_counts[i]) / other_counts[i];\n+        const double m2 = static_cast<double>(square_sum[i] - integers) - fractions;\n+\n+        other_means[i] = mean;\n+        other_m2s[i] = m2;\n+      }\n+      RETURN_NOT_OK(this->Merge(std::move(state), group_id_mapping));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    // Combine m2 from two chunks (see aggregate_var_std.cc)\n+    auto other = checked_cast<GroupedVarStdImpl*>(&raw_other);\n+\n+    auto counts = reinterpret_cast<int64_t*>(counts_.mutable_data());\n+    auto means = reinterpret_cast<double*>(means_.mutable_data());\n+    auto m2s = reinterpret_cast<double*>(m2s_.mutable_data());\n+\n+    const auto* other_counts = reinterpret_cast<const int64_t*>(other->counts_.data());\n+    const auto* other_means = reinterpret_cast<const double*>(other->means_.data());\n+    const auto* other_m2s = reinterpret_cast<const double*>(other->m2s_.data());\n+\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (int64_t other_g = 0; other_g < group_id_mapping.length; ++other_g, ++g) {\n+      if (other_counts[other_g] == 0) continue;\n+      const double mean =\n+          (means[*g] * counts[*g] + other_means[other_g] * other_counts[other_g]) /\n+          (counts[*g] + other_counts[other_g]);\n+      m2s[*g] += other_m2s[other_g] +\n+                 counts[*g] * (means[*g] - mean) * (means[*g] - mean) +\n+                 other_counts[other_g] * (other_means[other_g] - mean) *\n+                     (other_means[other_g] - mean);\n+      counts[*g] += other_counts[other_g];\n+      means[*g] = mean;\n+    }\n\nReview comment:\n       It's unfortunately not very good. See #10813.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-27T13:32:42.830+0000",
                    "updated": "2021-07-27T13:32:42.830+0000",
                    "started": "2021-07-27T13:32:42.830+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "628441",
                    "issueId": "13388690"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13388690/worklog/628519",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10792:\nURL: https://github.com/apache/arrow/pull/10792#discussion_r677526124\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1005,6 +1007,325 @@ struct GroupedSumFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// Mean implementation\n+\n+template <typename Type>\n+struct GroupedMeanImpl : public GroupedSumImpl<Type> {\n+  Result<Datum> Finalize() override {\n+    using SumType = typename GroupedSumImpl<Type>::SumType;\n+    std::shared_ptr<Buffer> null_bitmap;\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> values,\n+                          AllocateBuffer(num_groups_ * sizeof(double), pool_));\n+    int64_t null_count = 0;\n+\n+    const int64_t* counts = reinterpret_cast<const int64_t*>(counts_.data());\n+    const auto* sums = reinterpret_cast<const SumType*>(sums_.data());\n+    double* means = reinterpret_cast<double*>(values->mutable_data());\n+    for (int64_t i = 0; i < num_groups_; ++i) {\n+      if (counts[i] > 0) {\n+        means[i] = static_cast<double>(sums[i] / counts[i]);\n+        continue;\n+      }\n+      means[i] = 0;\n+\n+      if (null_bitmap == nullptr) {\n+        ARROW_ASSIGN_OR_RAISE(null_bitmap, AllocateBitmap(num_groups_, pool_));\n+        BitUtil::SetBitsTo(null_bitmap->mutable_data(), 0, num_groups_, true);\n+      }\n+\n+      null_count += 1;\n+      BitUtil::SetBitTo(null_bitmap->mutable_data(), i, false);\n+    }\n+\n+    return ArrayData::Make(float64(), num_groups_,\n+                           {std::move(null_bitmap), std::move(values)}, null_count);\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override { return float64(); }\n+\n+  using GroupedSumImpl<Type>::num_groups_;\n+  using GroupedSumImpl<Type>::pool_;\n+  using GroupedSumImpl<Type>::counts_;\n+  using GroupedSumImpl<Type>::sums_;\n+};\n+\n+struct GroupedMeanFactory {\n+  template <typename T, typename AccType = typename FindAccumulatorType<T>::Type>\n+  Status Visit(const T&) {\n+    kernel = MakeKernel(std::move(argument_type), HashAggregateInit<GroupedMeanImpl<T>>);\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const HalfFloatType& type) {\n+    return Status::NotImplemented(\"Computing mean of type \", type);\n+  }\n+\n+  Status Visit(const DataType& type) {\n+    return Status::NotImplemented(\"Computing mean of type \", type);\n+  }\n+\n+  static Result<HashAggregateKernel> Make(const std::shared_ptr<DataType>& type) {\n+    GroupedMeanFactory factory;\n+    factory.argument_type = InputType::Array(type);\n+    RETURN_NOT_OK(VisitTypeInline(*type, &factory));\n+    return std::move(factory.kernel);\n+  }\n+\n+  HashAggregateKernel kernel;\n+  InputType argument_type;\n+};\n+\n+// Variance/Stdev implementation\n+\n+using arrow::internal::int128_t;\n+\n+template <typename Type>\n+struct GroupedVarStdImpl : public GroupedAggregator {\n+  using CType = typename Type::c_type;\n+\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    options_ = *checked_cast<const VarianceOptions*>(options);\n+    ctx_ = ctx;\n+    pool_ = ctx->memory_pool();\n+    counts_ = BufferBuilder(pool_);\n+    means_ = BufferBuilder(pool_);\n+    m2s_ = BufferBuilder(pool_);\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    RETURN_NOT_OK(counts_.Append(added_groups * sizeof(int64_t), 0));\n+    RETURN_NOT_OK(means_.Append(added_groups * sizeof(double), 0));\n+    RETURN_NOT_OK(m2s_.Append(added_groups * sizeof(double), 0));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override { return ConsumeImpl(batch); }\n+\n+  // float/double/int64: calculate `m2` (sum((X-mean)^2)) with `two pass algorithm`\n+  // (see aggregate_var_std.cc)\n+  template <typename T = Type>\n+  enable_if_t<is_floating_type<T>::value || (sizeof(CType) > 4), Status> ConsumeImpl(\n+      const ExecBatch& batch) {\n+    using SumType =\n+        typename std::conditional<is_floating_type<T>::value, double, int128_t>::type;\n+\n+    int64_t* counts = reinterpret_cast<int64_t*>(counts_.mutable_data());\n+    double* means = reinterpret_cast<double*>(means_.mutable_data());\n+    double* m2s = reinterpret_cast<double*>(m2s_.mutable_data());\n+\n+    // XXX this uses naive summation; we should switch to pairwise summation as was\n+    // done for the scalar aggregate kernel in ARROW-11567\n+    std::vector<SumType> sums(num_groups_);\n+    auto g = batch[1].array()->GetValues<uint32_t>(1);\n+    VisitArrayDataInline<Type>(\n+        *batch[0].array(),\n+        [&](typename TypeTraits<Type>::CType value) {\n+          sums[*g] += value;\n+          counts[*g] += 1;\n+          ++g;\n+        },\n+        [&] { ++g; });\n+\n+    for (int64_t i = 0; i < num_groups_; i++) {\n+      means[i] = static_cast<double>(sums[i]) / counts[i];\n+    }\n+\n+    g = batch[1].array()->GetValues<uint32_t>(1);\n+    VisitArrayDataInline<Type>(\n+        *batch[0].array(),\n+        [&](typename TypeTraits<Type>::CType value) {\n+          const double v = static_cast<double>(value);\n+          m2s[*g] += (v - means[*g]) * (v - means[*g]);\n+          ++g;\n+        },\n+        [&] { ++g; });\n+\n+    return Status::OK();\n+  }\n+\n+  // int32/16/8: textbook one pass algorithm with integer arithmetic (see\n+  // aggregate_var_std.cc)\n+  template <typename T = Type>\n+  enable_if_t<is_integer_type<T>::value && (sizeof(CType) <= 4), Status> ConsumeImpl(\n+      const ExecBatch& batch) {\n+    // max number of elements that sum will not overflow int64 (2Gi int32 elements)\n+    // for uint32:    0 <= sum < 2^63 (int64 >= 0)\n+    // for int32: -2^62 <= sum < 2^62\n+    constexpr int64_t max_length = 1ULL << (63 - sizeof(CType) * 8);\n+\n+    const auto& array = *batch[0].array();\n+    const auto g = batch[1].array()->GetValues<uint32_t>(1);\n+\n+    std::vector<int64_t> sum(num_groups_);\n+    std::vector<int128_t> square_sum(num_groups_);\n+\n+    ARROW_ASSIGN_OR_RAISE(auto mapping,\n+                          AllocateBuffer(num_groups_ * sizeof(uint32_t), pool_));\n+    for (uint32_t i = 0; static_cast<int64_t>(i) < num_groups_; i++) {\n+      reinterpret_cast<uint32_t*>(mapping->mutable_data())[i] = i;\n+    }\n+    ArrayData group_id_mapping(uint32(), num_groups_, {nullptr, std::move(mapping)},\n+                               /*null_count=*/0);\n+\n+    const CType* values = array.GetValues<CType>(1);\n+\n+    for (int64_t start_index = 0; start_index < batch.length; start_index += max_length) {\n+      // process in chunks that overflow will never happen\n+\n+      // reset state\n+      std::fill(sum.begin(), sum.end(), 0);\n+      std::fill(square_sum.begin(), square_sum.end(), 0);\n+      GroupedVarStdImpl<Type> state;\n+      RETURN_NOT_OK(state.Init(ctx_, &options_));\n+      RETURN_NOT_OK(state.Resize(num_groups_));\n+      int64_t* other_counts = reinterpret_cast<int64_t*>(state.counts_.mutable_data());\n+      double* other_means = reinterpret_cast<double*>(state.means_.mutable_data());\n+      double* other_m2s = reinterpret_cast<double*>(state.m2s_.mutable_data());\n+\n+      arrow::internal::VisitSetBitRunsVoid(\n+          array.buffers[0], array.offset + start_index,\n+          std::min(max_length, batch.length - start_index),\n+          [&](int64_t pos, int64_t len) {\n+            for (int64_t i = 0; i < len; ++i) {\n+              const int64_t index = start_index + pos + i;\n+              const auto value = values[index];\n+              sum[g[index]] += value;\n+              square_sum[g[index]] += static_cast<uint64_t>(value) * value;\n+              other_counts[g[index]]++;\n+            }\n+          });\n+\n+      for (int64_t i = 0; i < num_groups_; i++) {\n+        if (other_counts[i] == 0) continue;\n+\n+        const double mean = static_cast<double>(sum[i]) / other_counts[i];\n+        // calculate m2 = square_sum - sum * sum / count\n+        // decompose `sum * sum / count` into integers and fractions\n+        const int128_t sum_square = static_cast<int128_t>(sum[i]) * sum[i];\n+        const int128_t integers = sum_square / other_counts[i];\n+        const double fractions =\n+            static_cast<double>(sum_square % other_counts[i]) / other_counts[i];\n+        const double m2 = static_cast<double>(square_sum[i] - integers) - fractions;\n+\n+        other_means[i] = mean;\n+        other_m2s[i] = m2;\n+      }\n+      RETURN_NOT_OK(this->Merge(std::move(state), group_id_mapping));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    // Combine m2 from two chunks (see aggregate_var_std.cc)\n+    auto other = checked_cast<GroupedVarStdImpl*>(&raw_other);\n+\n+    auto counts = reinterpret_cast<int64_t*>(counts_.mutable_data());\n+    auto means = reinterpret_cast<double*>(means_.mutable_data());\n+    auto m2s = reinterpret_cast<double*>(m2s_.mutable_data());\n+\n+    const auto* other_counts = reinterpret_cast<const int64_t*>(other->counts_.data());\n+    const auto* other_means = reinterpret_cast<const double*>(other->means_.data());\n+    const auto* other_m2s = reinterpret_cast<const double*>(other->m2s_.data());\n+\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (int64_t other_g = 0; other_g < group_id_mapping.length; ++other_g, ++g) {\n+      if (other_counts[other_g] == 0) continue;\n+      const double mean =\n+          (means[*g] * counts[*g] + other_means[other_g] * other_counts[other_g]) /\n+          (counts[*g] + other_counts[other_g]);\n+      m2s[*g] += other_m2s[other_g] +\n+                 counts[*g] * (means[*g] - mean) * (means[*g] - mean) +\n+                 other_counts[other_g] * (other_means[other_g] - mean) *\n+                     (other_means[other_g] - mean);\n+      counts[*g] += other_counts[other_g];\n+      means[*g] = mean;\n+    }\n\nReview comment:\n       I'll try refactoring it instead and compare the performance.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-27T14:49:34.241+0000",
                    "updated": "2021-07-27T14:49:34.241+0000",
                    "started": "2021-07-27T14:49:34.241+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "628519",
                    "issueId": "13388690"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13388690/worklog/628569",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10792:\nURL: https://github.com/apache/arrow/pull/10792#issuecomment-887624968\n\n\n   @ursabot please benchmark lang=C++\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-27T15:47:05.352+0000",
                    "updated": "2021-07-27T15:47:05.352+0000",
                    "started": "2021-07-27T15:47:05.352+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "628569",
                    "issueId": "13388690"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13388690/worklog/628570",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot commented on pull request #10792:\nURL: https://github.com/apache/arrow/pull/10792#issuecomment-887625130\n\n\n   Benchmark runs are scheduled for baseline = 31b60f3a2319cc628fa8c692d441f94fb32322fe and contender = df994626e0e6186edb48039e5f768b445986d13c. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Skipped :warning: Provided benchmark filters do not have any benchmark groups to be executed on ec2-t3-xlarge-us-east-2] [ec2-t3-xlarge-us-east-2 (mimalloc)](https://conbench.ursa.dev/compare/runs/7a89ec47dd834ea882321fa62be177c5...691bcfcbd03643afaf7c670dc34c3456/)\n   [Skipped :warning: Only ['Python', 'R', 'JavaScript'] langs are supported on ursa-i9-9960x] [ursa-i9-9960x (mimalloc)](https://conbench.ursa.dev/compare/runs/48503bd2b71344a997208fc917431628...b95bb718815e414cad0642e0800a44da/)\n   [Scheduled] [ursa-thinkcentre-m75q (mimalloc)](https://conbench.ursa.dev/compare/runs/8a465ec2c3c94f44b11a78566dd93734...550b0f83a9a74ad4b45d9f5406c6d9a1/)\n   Supported benchmarks:\n   ursa-i9-9960x: langs = Python, R, JavaScript\n   ursa-thinkcentre-m75q: langs = C++, Java\n   ec2-t3-xlarge-us-east-2: cloud = True\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-27T15:47:18.526+0000",
                    "updated": "2021-07-27T15:47:18.526+0000",
                    "started": "2021-07-27T15:47:18.526+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "628570",
                    "issueId": "13388690"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13388690/worklog/628672",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot edited a comment on pull request #10792:\nURL: https://github.com/apache/arrow/pull/10792#issuecomment-887625130\n\n\n   Benchmark runs are scheduled for baseline = 31b60f3a2319cc628fa8c692d441f94fb32322fe and contender = df994626e0e6186edb48039e5f768b445986d13c. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Skipped :warning: Provided benchmark filters do not have any benchmark groups to be executed on ec2-t3-xlarge-us-east-2] [ec2-t3-xlarge-us-east-2 (mimalloc)](https://conbench.ursa.dev/compare/runs/7a89ec47dd834ea882321fa62be177c5...691bcfcbd03643afaf7c670dc34c3456/)\n   [Skipped :warning: Only ['Python', 'R', 'JavaScript'] langs are supported on ursa-i9-9960x] [ursa-i9-9960x (mimalloc)](https://conbench.ursa.dev/compare/runs/48503bd2b71344a997208fc917431628...b95bb718815e414cad0642e0800a44da/)\n   [Failed] [ursa-thinkcentre-m75q (mimalloc)](https://conbench.ursa.dev/compare/runs/8a465ec2c3c94f44b11a78566dd93734...550b0f83a9a74ad4b45d9f5406c6d9a1/)\n   Supported benchmarks:\n   ursa-i9-9960x: langs = Python, R, JavaScript\n   ursa-thinkcentre-m75q: langs = C++, Java\n   ec2-t3-xlarge-us-east-2: cloud = True\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-27T18:48:27.262+0000",
                    "updated": "2021-07-27T18:48:27.262+0000",
                    "started": "2021-07-27T18:48:27.262+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "628672",
                    "issueId": "13388690"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13388690/worklog/631095",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #10792:\nURL: https://github.com/apache/arrow/pull/10792#issuecomment-889041262\n\n\n   @ursabot please benchmark lang=C++\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-29T11:32:04.883+0000",
                    "updated": "2021-07-29T11:32:04.883+0000",
                    "started": "2021-07-29T11:32:04.882+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "631095",
                    "issueId": "13388690"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13388690/worklog/631096",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot commented on pull request #10792:\nURL: https://github.com/apache/arrow/pull/10792#issuecomment-889041516\n\n\n   Benchmark runs are scheduled for baseline = 31b60f3a2319cc628fa8c692d441f94fb32322fe and contender = 90c91fa6cdc7c32bf00dd2e88cba27c79dbab717. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Skipped :warning: Provided benchmark filters do not have any benchmark groups to be executed on ec2-t3-xlarge-us-east-2] [ec2-t3-xlarge-us-east-2 (mimalloc)](https://conbench.ursa.dev/compare/runs/7a89ec47dd834ea882321fa62be177c5...19dd1f3d74554b8ea67238a094890834/)\n   [Skipped :warning: Only ['Python', 'R', 'JavaScript'] langs are supported on ursa-i9-9960x] [ursa-i9-9960x (mimalloc)](https://conbench.ursa.dev/compare/runs/48503bd2b71344a997208fc917431628...5f0704b53eda41ac87f2f2bef0cbdb56/)\n   [Scheduled] [ursa-thinkcentre-m75q (mimalloc)](https://conbench.ursa.dev/compare/runs/8a465ec2c3c94f44b11a78566dd93734...21f4c3398c254bbdad1f04e4dff64748/)\n   Supported benchmarks:\n   ursa-i9-9960x: langs = Python, R, JavaScript\n   ursa-thinkcentre-m75q: langs = C++, Java\n   ec2-t3-xlarge-us-east-2: cloud = True\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-29T11:32:19.003+0000",
                    "updated": "2021-07-29T11:32:19.003+0000",
                    "started": "2021-07-29T11:32:19.002+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "631096",
                    "issueId": "13388690"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13388690/worklog/631108",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot edited a comment on pull request #10792:\nURL: https://github.com/apache/arrow/pull/10792#issuecomment-889041516\n\n\n   Benchmark runs are scheduled for baseline = 31b60f3a2319cc628fa8c692d441f94fb32322fe and contender = 90c91fa6cdc7c32bf00dd2e88cba27c79dbab717. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Skipped :warning: Provided benchmark filters do not have any benchmark groups to be executed on ec2-t3-xlarge-us-east-2] [ec2-t3-xlarge-us-east-2 (mimalloc)](https://conbench.ursa.dev/compare/runs/7a89ec47dd834ea882321fa62be177c5...19dd1f3d74554b8ea67238a094890834/)\n   [Skipped :warning: Only ['Python', 'R', 'JavaScript'] langs are supported on ursa-i9-9960x] [ursa-i9-9960x (mimalloc)](https://conbench.ursa.dev/compare/runs/48503bd2b71344a997208fc917431628...5f0704b53eda41ac87f2f2bef0cbdb56/)\n   [Finished :arrow_down:0.67% :arrow_up:0.05%] [ursa-thinkcentre-m75q (mimalloc)](https://conbench.ursa.dev/compare/runs/8a465ec2c3c94f44b11a78566dd93734...21f4c3398c254bbdad1f04e4dff64748/)\n   Supported benchmarks:\n   ursa-i9-9960x: langs = Python, R, JavaScript\n   ursa-thinkcentre-m75q: langs = C++, Java\n   ec2-t3-xlarge-us-east-2: cloud = True\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-29T12:20:34.016+0000",
                    "updated": "2021-07-29T12:20:34.016+0000",
                    "started": "2021-07-29T12:20:34.015+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "631108",
                    "issueId": "13388690"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13388690/worklog/632135",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10792:\nURL: https://github.com/apache/arrow/pull/10792#issuecomment-890687071\n\n\n   From conbench it looks like the changes generally don't affect the performance of the existing variance/stddev kernels except for maybe the int32 variance case (likely a fluke?).\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-02T03:37:05.767+0000",
                    "updated": "2021-08-02T03:37:05.767+0000",
                    "started": "2021-08-02T03:37:05.767+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "632135",
                    "issueId": "13388690"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13388690/worklog/632379",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #10792:\nURL: https://github.com/apache/arrow/pull/10792#issuecomment-891063486\n\n\n   It's difficult to navigate the conbench results, but the results don't look like concerning in any way.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-02T14:14:35.887+0000",
                    "updated": "2021-08-02T14:14:35.887+0000",
                    "started": "2021-08-02T14:14:35.887+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "632379",
                    "issueId": "13388690"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13388690/worklog/632380",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou edited a comment on pull request #10792:\nURL: https://github.com/apache/arrow/pull/10792#issuecomment-891063486\n\n\n   It's difficult to navigate the conbench results, but the results don't seem concerning in any way.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-02T14:15:09.303+0000",
                    "updated": "2021-08-02T14:15:09.303+0000",
                    "started": "2021-08-02T14:15:09.303+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "632380",
                    "issueId": "13388690"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 12600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@48f60515[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1104512b[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@352a6af8[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@694f87f[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@937c434[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@2411d66b[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@428a05bb[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@63fc4a95[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@54dd24ba[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@7ed512c4[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6ce06778[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@6d493093[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 12600,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Aug 02 14:19:20 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-08-02T14:19:20.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13295/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2021-07-09T15:34:54.000+0000",
        "updated": "2021-08-09T18:54:45.000+0000",
        "timeoriginalestimate": null,
        "description": "We have scalar aggregate kernels for these already that can serve as the basis for a hash aggregate implementation.\r\n\r\nDepends on ARROW-12759 as that refactors\u00a0 how hash aggregate kernels are implemented.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "3.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 12600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Implement hash_aggregate mean/stdev/variance kernels",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13388690/comment/17391620",
                    "id": "17391620",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 10792\n[https://github.com/apache/arrow/pull/10792]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-08-02T14:19:20.160+0000",
                    "updated": "2021-08-02T14:19:20.160+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0ss8o:",
        "customfield_12314139": null
    }
}