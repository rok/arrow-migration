{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13100189",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189",
    "key": "ARROW-1476",
    "fields": {
        "parent": {
            "id": "13099860",
            "key": "ARROW-1463",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860",
            "fields": {
                "summary": "[JAVA] Restructure ValueVector hierarchy to minimize compile-time generated code",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                    "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                    "name": "Resolved",
                    "id": "5",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                    "id": "4",
                    "description": "An improvement or enhancement to an existing feature or task.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                    "name": "Improvement",
                    "subtask": false,
                    "avatarId": 21140
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12341352",
                "id": "12341352",
                "name": "0.8.0",
                "archived": false,
                "released": true,
                "releaseDate": "2017-12-18"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": "2022-11-17T00:44:08.089+0000",
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": null,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=siddteotia",
            "name": "siddteotia",
            "key": "siddteotia",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=siddteotia&avatarId=32343",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=siddteotia&avatarId=32343",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=siddteotia&avatarId=32343",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=siddteotia&avatarId=32343"
            },
            "displayName": "Siddharth Teotia",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328933",
                "id": "12328933",
                "name": "Java"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": null,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
            "name": "jnadeau",
            "key": "jnadeau",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Jacques Nadeau",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
            "name": "jnadeau",
            "key": "jnadeau",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Jacques Nadeau",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1476/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 0,
            "worklogs": []
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": null,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@1d931263[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3f95c6a5[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@54defdb5[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@456fa965[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7b876494[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@753d0ad6[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@562d6291[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@6eb1cdb0[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2e52b736[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@33a47390[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@ea0a69f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@6e1c36b6[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": null,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Nov 15 23:53:44 UTC 2017",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2017-11-15T23:53:44.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1476/watchers",
            "watchCount": 4,
            "isWatching": false
        },
        "created": "2017-09-06T15:36:11.000+0000",
        "updated": "2019-06-03T12:50:48.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {},
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[JAVA] Implement final ValueVector updates",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16250272",
                    "id": "16250272",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=siddteotia",
                        "name": "siddteotia",
                        "key": "siddteotia",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=siddteotia&avatarId=32343",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=siddteotia&avatarId=32343",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=siddteotia&avatarId=32343",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=siddteotia&avatarId=32343"
                        },
                        "displayName": "Siddharth Teotia",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "3rd patch for java-vector-refactor branch is in progress. PR should be up by EOD. The bulk of code is already pushed as part of first two patches. Minor changes were needed as part of testing in Dremio. Once the 3rd PR is available, we can work towards merging this branch into master.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=siddteotia",
                        "name": "siddteotia",
                        "key": "siddteotia",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=siddteotia&avatarId=32343",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=siddteotia&avatarId=32343",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=siddteotia&avatarId=32343",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=siddteotia&avatarId=32343"
                        },
                        "displayName": "Siddharth Teotia",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-13T21:30:47.788+0000",
                    "updated": "2017-11-13T21:30:47.788+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16250631",
                    "id": "16250631",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia opened a new pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316\n \n \n   cc @jacques-n , @BryanCutler , @icexelloss \r\n   \r\n   bug fixes and clean up done as part of testing in Dremio -- this is the 3rd patch I was referring to\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T01:25:13.991+0000",
                    "updated": "2017-11-14T01:25:13.991+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16250681",
                    "id": "16250681",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344124148\n \n \n   I just rebased this after ARROW-1717 was merged\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T02:17:20.279+0000",
                    "updated": "2017-11-14T02:17:20.279+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16250798",
                    "id": "16250798",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344139446\n \n \n   Can we try to fix up the checkstyle warnings as part of this process as well? There seems to be a bunch of indentation problems etc. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T03:58:30.575+0000",
                    "updated": "2017-11-14T03:58:30.575+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16250799",
                    "id": "16250799",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344139481\n \n \n   We'll want to rebase the vector refactor branch after this is merged as some of the tests are failing due to reasons that have been fixed in master\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T03:58:53.485+0000",
                    "updated": "2017-11-14T03:58:53.485+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16250853",
                    "id": "16250853",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344146292\n \n \n   Yes @wesm , we need to rebase this branch before merging into master.  I have addressed indentation and line length issues. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T04:53:49.441+0000",
                    "updated": "2017-11-14T04:53:49.441+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16250854",
                    "id": "16250854",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344146292\n \n \n   @wesm, yes we need to rebase this branch before merging into master.  I have addressed indentation and line length issues. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T04:54:09.635+0000",
                    "updated": "2017-11-14T04:54:09.635+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251488",
                    "id": "16251488",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150855200\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableFixedWidthVector.java\n ##########\n @@ -543,21 +533,28 @@ public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers\n     */\n    public List<ArrowBuf> getFieldBuffers() {\n \n Review comment:\n   What's the difference of this function and \r\n   \r\n   ```\r\n   public ArrowBuf[] getBuffers(boolean clear)\r\n   ```\r\n   ?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T14:55:17.671+0000",
                    "updated": "2017-11-14T14:55:17.671+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251496",
                    "id": "16251496",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150856630\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\n ##########\n @@ -430,11 +441,11 @@ private void allocateValidityBuffer(final long size) {\n     * double the current value capacity.\n     */\n    public void reAlloc() {\n-      reallocValueBuffer();\n+      reallocDataBuffer();\n       reallocValidityAndOffsetBuffers();\n    }\n \n-   protected void reallocValueBuffer() {\n+   public void reallocDataBuffer() {\n \n Review comment:\n   Docstring?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T14:59:40.630+0000",
                    "updated": "2017-11-14T14:59:40.630+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251499",
                    "id": "16251499",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150856994\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\n ##########\n @@ -615,8 +632,10 @@ public void transferTo(BaseNullableVariableWidthVector target){\n       target.validityBuffer = validityBuffer.transferOwnership(target.allocator).buffer;\n       target.valueBuffer = valueBuffer.transferOwnership(target.allocator).buffer;\n       target.offsetBuffer = offsetBuffer.transferOwnership(target.allocator).buffer;\n-      target.valueCount = valueCount;\n-      target.setLastSet(lastSet);\n+      target.setLastSet(this.lastSet);\n+      if (this.valueCount > 0) {\n \n Review comment:\n   Why do we need to check valueCount > 0?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T15:00:48.860+0000",
                    "updated": "2017-11-14T15:00:48.860+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251509",
                    "id": "16251509",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150858842\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\n ##########\n @@ -836,17 +858,259 @@ public int getLastSet() {\n     * @return starting offset for the element\n     */\n    public long getStartEnd(int index) {\n-      return (long)offsetBuffer.getInt(index * OFFSET_WIDTH);\n+      return offsetBuffer.getLong(index * OFFSET_WIDTH);\n    }\n \n    /**\n     * Mark the particular position in the vector as non-null.\n     *\n     * @param index position of the element.\n     */\n+   @Override\n    public void setIndexDefined(int index) {\n \n Review comment:\n   It seems naming conversion wise, all methods that handles allocates new buffers are called \"xxxSafe\". Does\r\n   ```\r\n   public void setValiditySafe(int index, boolean valid)\r\n   ```\r\n   \r\n   Makes more sense for this function?\r\n   \r\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T15:06:52.670+0000",
                    "updated": "2017-11-14T15:06:52.670+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251513",
                    "id": "16251513",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150858842\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\n ##########\n @@ -836,17 +858,259 @@ public int getLastSet() {\n     * @return starting offset for the element\n     */\n    public long getStartEnd(int index) {\n-      return (long)offsetBuffer.getInt(index * OFFSET_WIDTH);\n+      return offsetBuffer.getLong(index * OFFSET_WIDTH);\n    }\n \n    /**\n     * Mark the particular position in the vector as non-null.\n     *\n     * @param index position of the element.\n     */\n+   @Override\n    public void setIndexDefined(int index) {\n \n Review comment:\n   It seems naming conversion wise, all methods that handles allocates new buffers are called \"xxxSafe\". \r\n   \r\n   Since we have \r\n   \r\n   ```\r\n   public void safeSafe(int index, ...)\r\n   ```\r\n   \r\n   Does\r\n   ```\r\n   public void setValiditySafe(int index, boolean valid)\r\n   ```\r\n   \r\n   Makes more sense for this function?\r\n   \r\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T15:08:20.979+0000",
                    "updated": "2017-11-14T15:08:20.979+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251527",
                    "id": "16251527",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150862494\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\n ##########\n @@ -836,17 +858,259 @@ public int getLastSet() {\n     * @return starting offset for the element\n     */\n    public long getStartEnd(int index) {\n-      return (long)offsetBuffer.getInt(index * OFFSET_WIDTH);\n+      return offsetBuffer.getLong(index * OFFSET_WIDTH);\n    }\n \n    /**\n     * Mark the particular position in the vector as non-null.\n     *\n     * @param index position of the element.\n     */\n+   @Override\n    public void setIndexDefined(int index) {\n-      handleSafe(index, 0);\n+      while (index >= getValidityBufferValueCapacity()) {\n+         validityBuffer = reallocBufferHelper(validityBuffer, false);\n+      }\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+   }\n+\n+   /**\n+    * Sets the value length for an element.\n+    *\n+    * @param index   position of the element to set\n+    * @param length  length of the element\n+    */\n+   public void setValueLengthSafe(int index, int length) {\n \n Review comment:\n   I am curious what's the use case of this API, i.e, when do we want to just change the length? \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T15:18:21.819+0000",
                    "updated": "2017-11-14T15:18:21.819+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251531",
                    "id": "16251531",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150863199\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/GenerateSampleData.java\n ##########\n @@ -0,0 +1,337 @@\n+/*******************************************************************************\n \n Review comment:\n   Don't know if it's github issue, is the license format correct?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T15:20:44.026+0000",
                    "updated": "2017-11-14T15:20:44.026+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251533",
                    "id": "16251533",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150863425\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/GenerateSampleData.java\n ##########\n @@ -0,0 +1,337 @@\n+/*******************************************************************************\n+\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ ******************************************************************************/\n+\n+package org.apache.arrow.vector;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.Charset;\n+\n+/**\n+ * Helper class to generate test data for Nullable fixed and variable\n+ * width scalar vectors. Previous implementations of java vector classes\n+ * provided generateTestData(now deprecated) API to populate the vector\n+ * with sample data. This class should be used for that purpose.\n+ */\n+public class GenerateSampleData {\n \n Review comment:\n   Should this class be under test or tools?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T15:21:24.422+0000",
                    "updated": "2017-11-14T15:21:24.422+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251535",
                    "id": "16251535",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150863425\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/GenerateSampleData.java\n ##########\n @@ -0,0 +1,337 @@\n+/*******************************************************************************\n+\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ ******************************************************************************/\n+\n+package org.apache.arrow.vector;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.Charset;\n+\n+/**\n+ * Helper class to generate test data for Nullable fixed and variable\n+ * width scalar vectors. Previous implementations of java vector classes\n+ * provided generateTestData(now deprecated) API to populate the vector\n+ * with sample data. This class should be used for that purpose.\n+ */\n+public class GenerateSampleData {\n \n Review comment:\n   Should this class be under test or o.a.a.tools?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T15:21:59.354+0000",
                    "updated": "2017-11-14T15:21:59.354+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251541",
                    "id": "16251541",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150864377\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/NullableBitVector.java\n ##########\n @@ -163,7 +163,7 @@ private ArrowBuf splitAndTransferBuffer(int startIndex, int length,\n             if (destBuffer != null) {\n                destBuffer.release();\n             }\n-            destBuffer = destBuffer.slice(firstByteSource, byteSizeTarget);\n \n Review comment:\n   Are there unit tests for this kind of stuff?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T15:24:24.117+0000",
                    "updated": "2017-11-14T15:24:24.117+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251547",
                    "id": "16251547",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150865676\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/NullableBitVector.java\n ##########\n @@ -279,6 +279,8 @@ public Boolean getObject(int index) {\n    public void copyFrom(int fromIndex, int thisIndex, NullableBitVector from) {\n       if (from.isSet(fromIndex) != 0) {\n \n Review comment:\n   How about something like \r\n   \r\n   ```\r\n   BitVectorHelper.setValidityBit(validityBuffer, thisIndex, BitVectorHelper.getValidity(from, fromIndex));\r\n   ```\r\n   ?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T15:28:02.028+0000",
                    "updated": "2017-11-14T15:28:02.028+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251550",
                    "id": "16251550",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150865676\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/NullableBitVector.java\n ##########\n @@ -279,6 +279,8 @@ public Boolean getObject(int index) {\n    public void copyFrom(int fromIndex, int thisIndex, NullableBitVector from) {\n       if (from.isSet(fromIndex) != 0) {\n \n Review comment:\n   How about something like \r\n   \r\n   ```\r\n   BitVectorHelper.setValidityBit(validityBuffer, thisIndex, from.get(fromIndex));\r\n   ```\r\n   ?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T15:29:11.991+0000",
                    "updated": "2017-11-14T15:29:11.991+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251553",
                    "id": "16251553",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150866913\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/NullableBitVector.java\n ##########\n @@ -279,6 +279,8 @@ public Boolean getObject(int index) {\n    public void copyFrom(int fromIndex, int thisIndex, NullableBitVector from) {\n       if (from.isSet(fromIndex) != 0) {\n \n Review comment:\n   I am also a bit confused about \r\n   \r\n   ```\r\n   set(thisIndex, ...) \r\n   ```\r\n   vs\r\n   ```\r\n   BitVectorHelper.setValidityBit(validityBuffer, thisIndex, ...)\r\n   ```\r\n   \r\n   What's the difference?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T15:31:08.550+0000",
                    "updated": "2017-11-14T15:31:08.550+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251556",
                    "id": "16251556",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150867420\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/NullableBitVector.java\n ##########\n @@ -279,6 +279,8 @@ public Boolean getObject(int index) {\n    public void copyFrom(int fromIndex, int thisIndex, NullableBitVector from) {\n       if (from.isSet(fromIndex) != 0) {\n \n Review comment:\n   Actually, nvm. It seems all `copyFrom` follows the same pattern.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T15:32:42.546+0000",
                    "updated": "2017-11-14T15:32:42.546+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251559",
                    "id": "16251559",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150867747\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/NullableBitVector.java\n ##########\n @@ -279,6 +279,8 @@ public Boolean getObject(int index) {\n    public void copyFrom(int fromIndex, int thisIndex, NullableBitVector from) {\n       if (from.isSet(fromIndex) != 0) {\n          set(thisIndex, from.get(fromIndex));\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n \n Review comment:\n   Do we have a unit test for this?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T15:33:40.861+0000",
                    "updated": "2017-11-14T15:33:40.861+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251565",
                    "id": "16251565",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150869053\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/NullableVarBinaryVector.java\n ##########\n @@ -152,12 +135,9 @@ public void get(int index, NullableVarBinaryHolder holder){\n          holder.isSet = 0;\n          return;\n       }\n-      final int startOffset = getstartOffset(index);\n-      final int dataLength =\n-              offsetBuffer.getInt((index + 1) * OFFSET_WIDTH) - startOffset;\n       holder.isSet = 1;\n-      holder.start = startOffset;\n-      holder.end = dataLength;\n+      holder.start = getstartOffset(index);\n \n Review comment:\n   I think \"offset\" is well defined in format, so this method can probably just be:\r\n   \r\n   ```\r\n   getOffset(int index)\r\n   ```\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T15:37:20.156+0000",
                    "updated": "2017-11-14T15:37:20.156+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251567",
                    "id": "16251567",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150869475\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/NullableVarBinaryVector.java\n ##########\n @@ -152,12 +135,9 @@ public void get(int index, NullableVarBinaryHolder holder){\n          holder.isSet = 0;\n          return;\n       }\n-      final int startOffset = getstartOffset(index);\n-      final int dataLength =\n-              offsetBuffer.getInt((index + 1) * OFFSET_WIDTH) - startOffset;\n       holder.isSet = 1;\n-      holder.start = startOffset;\n-      holder.end = dataLength;\n+      holder.start = getstartOffset(index);\n \n Review comment:\n   or just:\r\n   ```\r\n   offsetBuffer.getInt(index * OFFSET_WIDTH)\r\n   ``\r\n   \r\n   Probably it consist with `holder.end = ...`\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T15:38:29.531+0000",
                    "updated": "2017-11-14T15:38:29.531+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251568",
                    "id": "16251568",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150869475\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/NullableVarBinaryVector.java\n ##########\n @@ -152,12 +135,9 @@ public void get(int index, NullableVarBinaryHolder holder){\n          holder.isSet = 0;\n          return;\n       }\n-      final int startOffset = getstartOffset(index);\n-      final int dataLength =\n-              offsetBuffer.getInt((index + 1) * OFFSET_WIDTH) - startOffset;\n       holder.isSet = 1;\n-      holder.start = startOffset;\n-      holder.end = dataLength;\n+      holder.start = getstartOffset(index);\n \n Review comment:\n   or just:\r\n   ```\r\n   offsetBuffer.getInt(index * OFFSET_WIDTH)\r\n   ```\r\n   \r\n   Probably it consist with `holder.end = ...`\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T15:38:39.462+0000",
                    "updated": "2017-11-14T15:38:39.462+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251574",
                    "id": "16251574",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150870781\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/BaseRepeatedValueVector.java\n ##########\n @@ -183,8 +183,13 @@ public void clear() {\n \n   @Override\n   public ArrowBuf[] getBuffers(boolean clear) {\n-    final ArrowBuf[] buffers = ObjectArrays.concat(new ArrowBuf[]{offsetBuffer},\n-            vector.getBuffers(false), ArrowBuf.class);\n+    final ArrowBuf[] buffers;\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = ObjectArrays.concat(new ArrowBuf[]{offsetBuffer}, vector.getBuffers(false),\n+              ArrowBuf.class);\n \n Review comment:\n   Indentation seems incorrect.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T15:42:23.191+0000",
                    "updated": "2017-11-14T15:42:23.191+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251576",
                    "id": "16251576",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150871578\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/FixedSizeListVector.java\n ##########\n @@ -282,7 +286,14 @@ public void clear() {\n \n   @Override\n   public ArrowBuf[] getBuffers(boolean clear) {\n-    final ArrowBuf[] buffers = ObjectArrays.concat(new ArrowBuf[]{validityBuffer}, vector.getBuffers(false), ArrowBuf.class);\n+    setReaderAndWriterIndex();\n+    final ArrowBuf[] buffers;\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = ObjectArrays.concat(new ArrowBuf[]{validityBuffer}, vector.getBuffers(false),\n+              ArrowBuf.class);\n \n Review comment:\n   Indentation seems incorrect.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T15:44:27.926+0000",
                    "updated": "2017-11-14T15:44:27.926+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251579",
                    "id": "16251579",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150872007\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java\n ##########\n @@ -128,17 +128,25 @@ public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers\n   @Override\n   public List<ArrowBuf> getFieldBuffers() {\n     List<ArrowBuf> result = new ArrayList<>(2);\n-    validityBuffer.readerIndex(0);\n-    validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n-    offsetBuffer.readerIndex(0);\n-    offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n-\n+    setReaderAndWriterIndex();\n     result.add(validityBuffer);\n     result.add(offsetBuffer);\n \n     return result;\n   }\n \n+  private void setReaderAndWriterIndex() {\n \n Review comment:\n   Can this be lifted to base class?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T15:45:41.679+0000",
                    "updated": "2017-11-14T15:45:41.679+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251581",
                    "id": "16251581",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150872611\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java\n ##########\n @@ -436,8 +450,15 @@ public void clear() {\n \n   @Override\n   public ArrowBuf[] getBuffers(boolean clear) {\n-    final ArrowBuf[] buffers = ObjectArrays.concat(new ArrowBuf[]{offsetBuffer}, ObjectArrays.concat(new ArrowBuf[] {validityBuffer},\n-        vector.getBuffers(false), ArrowBuf.class), ArrowBuf.class);\n+    setReaderAndWriterIndex();\n+    final ArrowBuf[] buffers;\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = ObjectArrays.concat(new ArrowBuf[]{offsetBuffer},\n+              ObjectArrays.concat(new ArrowBuf[] {validityBuffer},\n \n Review comment:\n   Indentation\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T15:47:15.244+0000",
                    "updated": "2017-11-14T15:47:15.244+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251584",
                    "id": "16251584",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150873005\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java\n ##########\n @@ -491,8 +512,22 @@ public int getNullCount() {\n     return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n   }\n \n+  @Override\n+  public int getValueCapacity() {\n+    return Math.min(getValidityBufferValueCapacity(), super.getValueCapacity());\n+  }\n+\n+  public int getValidityAndOffsetValueCapacity() {\n \n Review comment:\n   Why do we need this method? Can valueCapacity and validityCapacity mismatch?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T15:48:22.935+0000",
                    "updated": "2017-11-14T15:48:22.935+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251597",
                    "id": "16251597",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344302566\n \n \n   @siddharthteotia This looks good. I left some comments.\r\n   \r\n   One thing is that it seems this patch has quite bit of bug fixes but not many new tests. Should we add tests for those bug fixes?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T15:52:06.813+0000",
                    "updated": "2017-11-14T15:52:06.813+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251873",
                    "id": "16251873",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150918390\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\n ##########\n @@ -615,8 +632,10 @@ public void transferTo(BaseNullableVariableWidthVector target){\n       target.validityBuffer = validityBuffer.transferOwnership(target.allocator).buffer;\n       target.valueBuffer = valueBuffer.transferOwnership(target.allocator).buffer;\n       target.offsetBuffer = offsetBuffer.transferOwnership(target.allocator).buffer;\n-      target.valueCount = valueCount;\n-      target.setLastSet(lastSet);\n+      target.setLastSet(this.lastSet);\n+      if (this.valueCount > 0) {\n \n Review comment:\n   If we haven't done setValueCount() on the source vector before invoking transfer(), then valueCount is essentially 0. Doing target.setValueCount(this.valueCount) will corrupt the target vector if this.valueCount is 0.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T18:17:39.131+0000",
                    "updated": "2017-11-14T18:17:39.131+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251876",
                    "id": "16251876",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150918786\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\n ##########\n @@ -836,17 +858,259 @@ public int getLastSet() {\n     * @return starting offset for the element\n     */\n    public long getStartEnd(int index) {\n-      return (long)offsetBuffer.getInt(index * OFFSET_WIDTH);\n+      return offsetBuffer.getLong(index * OFFSET_WIDTH);\n    }\n \n    /**\n     * Mark the particular position in the vector as non-null.\n     *\n     * @param index position of the element.\n     */\n+   @Override\n    public void setIndexDefined(int index) {\n \n Review comment:\n   Not quite sure. Since this has always been setIndexDefined(), I just left it as is\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T18:19:08.477+0000",
                    "updated": "2017-11-14T18:19:08.477+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251879",
                    "id": "16251879",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150919304\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/NullableBitVector.java\n ##########\n @@ -163,7 +163,7 @@ private ArrowBuf splitAndTransferBuffer(int startIndex, int length,\n             if (destBuffer != null) {\n                destBuffer.release();\n             }\n-            destBuffer = destBuffer.slice(firstByteSource, byteSizeTarget);\n \n Review comment:\n   Yes, we have unit tests for splitAndTransfer of bit vector (validity buffer). Also we have unit tests  for split and transfer of other vectors (nullable fixed, var width and complex) and we exercise all the conditions.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T18:21:03.269+0000",
                    "updated": "2017-11-14T18:21:03.269+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251884",
                    "id": "16251884",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150919831\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java\n ##########\n @@ -128,17 +128,25 @@ public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers\n   @Override\n   public List<ArrowBuf> getFieldBuffers() {\n     List<ArrowBuf> result = new ArrayList<>(2);\n-    validityBuffer.readerIndex(0);\n-    validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n-    offsetBuffer.readerIndex(0);\n-    offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n-\n+    setReaderAndWriterIndex();\n     result.add(validityBuffer);\n     result.add(offsetBuffer);\n \n     return result;\n   }\n \n+  private void setReaderAndWriterIndex() {\n \n Review comment:\n   Probably but I thought BaseRepeatedValueVector on itself is of no use -- at least doesn't represent a materialized field. Moreover, even if we move to base class, we still have to set reader and writer index for validity buffer in sub class since the validity buffer is a property of list vector and not BaseRepeatedValueVector.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T18:23:01.851+0000",
                    "updated": "2017-11-14T18:23:01.851+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251886",
                    "id": "16251886",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150919916\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java\n ##########\n @@ -436,8 +450,15 @@ public void clear() {\n \n   @Override\n   public ArrowBuf[] getBuffers(boolean clear) {\n-    final ArrowBuf[] buffers = ObjectArrays.concat(new ArrowBuf[]{offsetBuffer}, ObjectArrays.concat(new ArrowBuf[] {validityBuffer},\n-        vector.getBuffers(false), ArrowBuf.class), ArrowBuf.class);\n+    setReaderAndWriterIndex();\n+    final ArrowBuf[] buffers;\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = ObjectArrays.concat(new ArrowBuf[]{offsetBuffer},\n+              ObjectArrays.concat(new ArrowBuf[] {validityBuffer},\n \n Review comment:\n   Done.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T18:23:21.265+0000",
                    "updated": "2017-11-14T18:23:21.265+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251888",
                    "id": "16251888",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150919968\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/BaseRepeatedValueVector.java\n ##########\n @@ -183,8 +183,13 @@ public void clear() {\n \n   @Override\n   public ArrowBuf[] getBuffers(boolean clear) {\n-    final ArrowBuf[] buffers = ObjectArrays.concat(new ArrowBuf[]{offsetBuffer},\n-            vector.getBuffers(false), ArrowBuf.class);\n+    final ArrowBuf[] buffers;\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = ObjectArrays.concat(new ArrowBuf[]{offsetBuffer}, vector.getBuffers(false),\n+              ArrowBuf.class);\n \n Review comment:\n   Done.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T18:23:30.005+0000",
                    "updated": "2017-11-14T18:23:30.005+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251889",
                    "id": "16251889",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150919991\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/FixedSizeListVector.java\n ##########\n @@ -282,7 +286,14 @@ public void clear() {\n \n   @Override\n   public ArrowBuf[] getBuffers(boolean clear) {\n-    final ArrowBuf[] buffers = ObjectArrays.concat(new ArrowBuf[]{validityBuffer}, vector.getBuffers(false), ArrowBuf.class);\n+    setReaderAndWriterIndex();\n+    final ArrowBuf[] buffers;\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = ObjectArrays.concat(new ArrowBuf[]{validityBuffer}, vector.getBuffers(false),\n+              ArrowBuf.class);\n \n Review comment:\n   Done.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T18:23:35.039+0000",
                    "updated": "2017-11-14T18:23:35.039+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251899",
                    "id": "16251899",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150921220\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/NullableBitVector.java\n ##########\n @@ -279,6 +279,8 @@ public Boolean getObject(int index) {\n    public void copyFrom(int fromIndex, int thisIndex, NullableBitVector from) {\n       if (from.isSet(fromIndex) != 0) {\n          set(thisIndex, from.get(fromIndex));\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n \n Review comment:\n   We have some copy() related unit tests but in any case, I am planning to write more unit tests in the next couple of weeks to get overall good coverage. I don't think so I can get to them now because of time constraints. \r\n   \r\n   Note that behavior of copyFrom() hasn't changed.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T18:27:52.074+0000",
                    "updated": "2017-11-14T18:27:52.074+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251906",
                    "id": "16251906",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150922101\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/NullableVarBinaryVector.java\n ##########\n @@ -152,12 +135,9 @@ public void get(int index, NullableVarBinaryHolder holder){\n          holder.isSet = 0;\n          return;\n       }\n-      final int startOffset = getstartOffset(index);\n-      final int dataLength =\n-              offsetBuffer.getInt((index + 1) * OFFSET_WIDTH) - startOffset;\n       holder.isSet = 1;\n-      holder.start = startOffset;\n-      holder.end = dataLength;\n+      holder.start = getstartOffset(index);\n \n Review comment:\n   startOffset implies the starting point of VARCHAR element in the data buffer.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T18:31:07.684+0000",
                    "updated": "2017-11-14T18:31:07.684+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251907",
                    "id": "16251907",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150922440\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/GenerateSampleData.java\n ##########\n @@ -0,0 +1,337 @@\n+/*******************************************************************************\n+\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ ******************************************************************************/\n+\n+package org.apache.arrow.vector;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.Charset;\n+\n+/**\n+ * Helper class to generate test data for Nullable fixed and variable\n+ * width scalar vectors. Previous implementations of java vector classes\n+ * provided generateTestData(now deprecated) API to populate the vector\n+ * with sample data. This class should be used for that purpose.\n+ */\n+public class GenerateSampleData {\n \n Review comment:\n   Ideally under tools but for some weird reason, I wasn't able to resolve the dependency w.r.t arrow tools in Dremio -- I was definitely missing something but for saving time just put it here.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T18:32:23.307+0000",
                    "updated": "2017-11-14T18:32:23.307+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251908",
                    "id": "16251908",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150922621\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/GenerateSampleData.java\n ##########\n @@ -0,0 +1,337 @@\n+/*******************************************************************************\n \n Review comment:\n   Corrected. Not a github issue.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T18:33:04.903+0000",
                    "updated": "2017-11-14T18:33:04.903+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251915",
                    "id": "16251915",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150923361\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\n ##########\n @@ -430,11 +441,11 @@ private void allocateValidityBuffer(final long size) {\n     * double the current value capacity.\n     */\n    public void reAlloc() {\n-      reallocValueBuffer();\n+      reallocDataBuffer();\n       reallocValidityAndOffsetBuffers();\n    }\n \n-   protected void reallocValueBuffer() {\n+   public void reallocDataBuffer() {\n \n Review comment:\n   Done.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T18:35:45.974+0000",
                    "updated": "2017-11-14T18:35:45.974+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16251988",
                    "id": "16251988",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150931797\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java\n ##########\n @@ -491,8 +512,22 @@ public int getNullCount() {\n     return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n   }\n \n+  @Override\n+  public int getValueCapacity() {\n+    return Math.min(getValidityBufferValueCapacity(), super.getValueCapacity());\n+  }\n+\n+  public int getValidityAndOffsetValueCapacity() {\n \n Review comment:\n   validity and offset move together regardless of the buffers in underlying data vector of list vector so functions like setNotNull(), startNewValue(), setValueCount() which are essentially safe methods need to determine if the inner buffers of list vector need to be reallocated or not. This decision can't be made based on getValueCapacity() since that also accounts for the value capacity of data vector. I think by mistake it is public. that needs to be corrected.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T19:06:23.779+0000",
                    "updated": "2017-11-14T19:06:23.779+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252006",
                    "id": "16252006",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344368739\n \n \n   I rebased this patch on master and addressed review comments.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T19:23:29.497+0000",
                    "updated": "2017-11-14T19:23:29.497+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252012",
                    "id": "16252012",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344370394\n \n \n   Hm, I wonder what's going on with the merge conflicts? \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T19:28:53.047+0000",
                    "updated": "2017-11-14T19:28:53.047+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252015",
                    "id": "16252015",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344371061\n \n \n   The conflicts have all been resolved in my local java-vector-refactor branch. The build and tests are clean. After doing \"git pull --rebase upstream master\" and addressing review comments, I did a force update of the branch for this PR? \r\n   \r\n   Everything is clean locally, not sure where I went wrong?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T19:31:11.096+0000",
                    "updated": "2017-11-14T19:31:11.096+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252022",
                    "id": "16252022",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344371514\n \n \n   Are you sure you rebased on apache/master? Like\r\n   \r\n   `git rebase apache/master\"\r\n   \r\n   (here apache is git@github.com:apache/arrow.git and I have just run `git fetch apache`)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T19:32:40.383+0000",
                    "updated": "2017-11-14T19:32:40.383+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252024",
                    "id": "16252024",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344371514\n \n \n   Are you sure you rebased on apache/master? Like\r\n   \r\n   `git rebase apache/master`\r\n   \r\n   (here apache is git@github.com:apache/arrow.git and I have just run `git fetch apache`)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T19:32:45.643+0000",
                    "updated": "2017-11-14T19:32:45.643+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252026",
                    "id": "16252026",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344372025\n \n \n   Oh I see. The issue is the base branch of this PR. The rebase went fine\r\n   \r\n   ```\r\n   * 635ca770 2017-11-14 | address review comments (siddharthteotia/ARROW-1476) [siddharth]\r\n   * 343f47bd 2017-11-13 | rebase on master, fix tests [siddharth]\r\n   * 102ff972 2017-11-13 | indentation and line length [siddharth]\r\n   * 2027f0bb 2017-11-13 | ARROW-1476: [JAVA] Implement Final ValueVector Updates [siddharth]\r\n   * 0de6e697 2017-11-07 | ARROW-1717: [Java] Refactor JsonReader for new class hierarchy and fix integration tests [Li Jin]\r\n   * 4509c294 2017-10-16 | ARROW-1474:[JAVA] ValueVector hierarchy (Implementation Phase 2) [siddharth]\r\n   * 6493ebf8 2017-10-14 | ARROW-1473: ValueVector new hierarchy prototype (implementation phase 1) [Siddharth Teotia]\r\n   * b18bbeba 2017-11-13 | ARROW-1371: [Website] Add \"Powered By\" page to the website (wesm/master, apache/master, master) [Korn, Uwe]\r\n   * 8f2d1525 2017-11-13 | ARROW-1802: [GLib] Support arrow-gpu [Kouhei Sutou]\r\n   * 6f8e2873 2017-11-13 | ARROW-1743: [Python] Avoid non-array writeable-flag check [Licht-T]\r\n   * 4a33bad5 2017-11-12 | ARROW-1767: [C++] Support file reads and writes over 2GB on Windows (siddharthteotia/master, origin/master, origin/HEAD) [Licht-T]\r\n   * e8331f46 2017-11-12 | ARROW-1794: [C++/Python] Rename DecimalArray to Decimal128Array [Phillip Cloud]\r\n   * 7adadd8e 2017-11-12 | ARROW-1763: [Python] Implement __hash__ for DataType [Wes McKinney]\r\n   ```\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T19:34:26.869+0000",
                    "updated": "2017-11-14T19:34:26.869+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252027",
                    "id": "16252027",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344372184\n \n \n   Just changed the base\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T19:35:04.134+0000",
                    "updated": "2017-11-14T19:35:04.134+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252035",
                    "id": "16252035",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344372801\n \n \n   OK, builds are running. I can take care of merging to master after the builds pass. @icexelloss @BryanCutler @jacques-n any last words before we pull the lever in an hour or two?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T19:37:08.362+0000",
                    "updated": "2017-11-14T19:37:08.362+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252038",
                    "id": "16252038",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344372931\n \n \n   Thanks @wesm for changing the base branch.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T19:37:37.206+0000",
                    "updated": "2017-11-14T19:37:37.206+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252048",
                    "id": "16252048",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150942069\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\n ##########\n @@ -836,17 +858,259 @@ public int getLastSet() {\n     * @return starting offset for the element\n     */\n    public long getStartEnd(int index) {\n-      return (long)offsetBuffer.getInt(index * OFFSET_WIDTH);\n+      return offsetBuffer.getLong(index * OFFSET_WIDTH);\n    }\n \n    /**\n     * Mark the particular position in the vector as non-null.\n     *\n     * @param index position of the element.\n     */\n+   @Override\n    public void setIndexDefined(int index) {\n \n Review comment:\n   Ok\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T19:42:53.315+0000",
                    "updated": "2017-11-14T19:42:53.315+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252057",
                    "id": "16252057",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150942738\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/NullableBitVector.java\n ##########\n @@ -279,6 +279,8 @@ public Boolean getObject(int index) {\n    public void copyFrom(int fromIndex, int thisIndex, NullableBitVector from) {\n       if (from.isSet(fromIndex) != 0) {\n          set(thisIndex, from.get(fromIndex));\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n \n Review comment:\n   Ok\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T19:45:13.712+0000",
                    "updated": "2017-11-14T19:45:13.712+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252092",
                    "id": "16252092",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150949190\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java\n ##########\n @@ -491,8 +512,22 @@ public int getNullCount() {\n     return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n   }\n \n+  @Override\n+  public int getValueCapacity() {\n+    return Math.min(getValidityBufferValueCapacity(), super.getValueCapacity());\n+  }\n+\n+  public int getValidityAndOffsetValueCapacity() {\n \n Review comment:\n   I see. Yeah let's make this private.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T20:09:46.976+0000",
                    "updated": "2017-11-14T20:09:46.976+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252093",
                    "id": "16252093",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150949271\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java\n ##########\n @@ -128,17 +128,25 @@ public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers\n   @Override\n   public List<ArrowBuf> getFieldBuffers() {\n     List<ArrowBuf> result = new ArrayList<>(2);\n-    validityBuffer.readerIndex(0);\n-    validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n-    offsetBuffer.readerIndex(0);\n-    offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n-\n+    setReaderAndWriterIndex();\n     result.add(validityBuffer);\n     result.add(offsetBuffer);\n \n     return result;\n   }\n \n+  private void setReaderAndWriterIndex() {\n \n Review comment:\n   OK\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T20:10:09.375+0000",
                    "updated": "2017-11-14T20:10:09.375+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252102",
                    "id": "16252102",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344383209\n \n \n   The Java build is failing -- seems there is still quite a bit of multiple-of-3 indentation. Can you fix?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T20:12:22.663+0000",
                    "updated": "2017-11-14T20:12:22.663+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252105",
                    "id": "16252105",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150949924\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/GenerateSampleData.java\n ##########\n @@ -0,0 +1,337 @@\n+/*******************************************************************************\n+\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ ******************************************************************************/\n+\n+package org.apache.arrow.vector;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.Charset;\n+\n+/**\n+ * Helper class to generate test data for Nullable fixed and variable\n+ * width scalar vectors. Previous implementations of java vector classes\n+ * provided generateTestData(now deprecated) API to populate the vector\n+ * with sample data. This class should be used for that purpose.\n+ */\n+public class GenerateSampleData {\n \n Review comment:\n   I prefer if we can move this out of vector public class. If we don't have time to do it here, can we track this somewhere so we don't forget to move it before release?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T20:12:46.799+0000",
                    "updated": "2017-11-14T20:12:46.799+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252106",
                    "id": "16252106",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150950040\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\n ##########\n @@ -836,17 +858,259 @@ public int getLastSet() {\n     * @return starting offset for the element\n     */\n    public long getStartEnd(int index) {\n-      return (long)offsetBuffer.getInt(index * OFFSET_WIDTH);\n+      return offsetBuffer.getLong(index * OFFSET_WIDTH);\n    }\n \n    /**\n     * Mark the particular position in the vector as non-null.\n     *\n     * @param index position of the element.\n     */\n+   @Override\n    public void setIndexDefined(int index) {\n-      handleSafe(index, 0);\n+      while (index >= getValidityBufferValueCapacity()) {\n+         validityBuffer = reallocBufferHelper(validityBuffer, false);\n+      }\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+   }\n+\n+   /**\n+    * Sets the value length for an element.\n+    *\n+    * @param index   position of the element to set\n+    * @param length  length of the element\n+    */\n+   public void setValueLengthSafe(int index, int length) {\n \n Review comment:\n   @siddharthteotia what's your thought on this?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T20:13:17.870+0000",
                    "updated": "2017-11-14T20:13:17.870+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252108",
                    "id": "16252108",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150950183\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableFixedWidthVector.java\n ##########\n @@ -543,21 +533,28 @@ public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers\n     */\n    public List<ArrowBuf> getFieldBuffers() {\n \n Review comment:\n   @siddharthteotia What's your thoughts on this?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T20:13:48.274+0000",
                    "updated": "2017-11-14T20:13:48.274+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252117",
                    "id": "16252117",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150951179\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/GenerateSampleData.java\n ##########\n @@ -0,0 +1,337 @@\n+/*******************************************************************************\n \n Review comment:\n   @siddharthteotia The license format still doesn't look correct.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T20:17:52.693+0000",
                    "updated": "2017-11-14T20:17:52.693+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252129",
                    "id": "16252129",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344388391\n \n \n   I am fixing the multiple-of-3 indentation. I thought mvn clean install will fail the build locally if checkstyle problems are there. Is there a deterministic way to test this locally \r\n   \r\n   Looks like there is an integration test failure as well.\r\n   \r\n   Incompatible files\r\n   index: 0, length: 1 (expected: range(0, 0))\r\n   19:50:30.037 [main] ERROR org.apache.arrow.tools.Integration - Incompatible files\r\n   java.lang.IndexOutOfBoundsException: index: 0, length: 1 (expected: range(0, 0))\r\n   \tat io.netty.buffer.ArrowBuf.checkIndexD(ArrowBuf.java:138)\r\n   \tat io.netty.buffer.ArrowBuf.chk(ArrowBuf.java:161)\r\n   \tat io.netty.buffer.ArrowBuf.getByte(ArrowBuf.java:781)\r\n   \tat org.apache.arrow.vector.BaseNullableFixedWidthVector.isSet(BaseNullableFixedWidthVector.java:799)\r\n   \tat org.apache.arrow.vector.NullableDecimalVector.getObject(NullableDecimalVector.java:139)\r\n   \tat org.apache.arrow.vector.NullableDecimalVector.getObject(NullableDecimalVector.java:39)\r\n   \tat org.apache.arrow.vector.util.Validator.compareFieldVectors(Validator.java:122)\r\n   \tat org.apache.arrow.vector.util.Validator.compareVectorSchemaRoot(Validator.java:101)\r\n   \tat org.apache.arrow.tools.Integration$Command$3.execute(Integration.java:201)\r\n   \tat org.apache.arrow.tools.Integration.run(Integration.java:114)\r\n   \tat org.apache.arrow.tools.Integration.main(Integration.java:65)\r\n   \tSuppressed: java.lang.IllegalStateException: Memory was leaked by query. Memory leaked: (4644)\r\n   \r\n    @icexelloss , is this the same integration test you were referring to in \"refactor JsonReader PR?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T20:30:37.776+0000",
                    "updated": "2017-11-14T20:30:37.776+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252131",
                    "id": "16252131",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344388391\n \n \n   I am fixing the multiple-of-3 indentation. I thought mvn clean install will fail the build locally if checkstyle problems are there. Is there a deterministic way to test this locally? \r\n   \r\n   Looks like there is an integration test failure as well.\r\n   \r\n   Incompatible files\r\n   index: 0, length: 1 (expected: range(0, 0))\r\n   19:50:30.037 [main] ERROR org.apache.arrow.tools.Integration - Incompatible files\r\n   java.lang.IndexOutOfBoundsException: index: 0, length: 1 (expected: range(0, 0))\r\n   \tat io.netty.buffer.ArrowBuf.checkIndexD(ArrowBuf.java:138)\r\n   \tat io.netty.buffer.ArrowBuf.chk(ArrowBuf.java:161)\r\n   \tat io.netty.buffer.ArrowBuf.getByte(ArrowBuf.java:781)\r\n   \tat org.apache.arrow.vector.BaseNullableFixedWidthVector.isSet(BaseNullableFixedWidthVector.java:799)\r\n   \tat org.apache.arrow.vector.NullableDecimalVector.getObject(NullableDecimalVector.java:139)\r\n   \tat org.apache.arrow.vector.NullableDecimalVector.getObject(NullableDecimalVector.java:39)\r\n   \tat org.apache.arrow.vector.util.Validator.compareFieldVectors(Validator.java:122)\r\n   \tat org.apache.arrow.vector.util.Validator.compareVectorSchemaRoot(Validator.java:101)\r\n   \tat org.apache.arrow.tools.Integration$Command$3.execute(Integration.java:201)\r\n   \tat org.apache.arrow.tools.Integration.run(Integration.java:114)\r\n   \tat org.apache.arrow.tools.Integration.main(Integration.java:65)\r\n   \tSuppressed: java.lang.IllegalStateException: Memory was leaked by query. Memory leaked: (4644)\r\n   \r\n    @icexelloss , is this the same integration test you were referring to in \"refactor JsonReader PR?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T20:31:00.220+0000",
                    "updated": "2017-11-14T20:31:00.220+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252159",
                    "id": "16252159",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344394009\n \n \n   No, the integration test I saw is something else - the one I refer to is fixed by zeroing out validity bits in json reader.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T20:50:38.596+0000",
                    "updated": "2017-11-14T20:50:38.596+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252165",
                    "id": "16252165",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344395802\n \n \n   @icexelloss , I haven't dealt with integration tests yet. So this might be a dumb question. How do I run/debug an integration test locally?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T20:56:59.466+0000",
                    "updated": "2017-11-14T20:56:59.466+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252167",
                    "id": "16252167",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344396409\n \n \n   @siddharthteotia There is a README file under arrow/integration that should get your started.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T20:58:57.641+0000",
                    "updated": "2017-11-14T20:58:57.641+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252216",
                    "id": "16252216",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150969310\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/NullableBitVector.java\n ##########\n @@ -0,0 +1,504 @@\n+/*******************************************************************************\n \n Review comment:\n   License format seems incorrect.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T21:30:34.147+0000",
                    "updated": "2017-11-14T21:30:34.147+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252225",
                    "id": "16252225",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344407499\n \n \n   For check style, I ran\r\n   ```\r\n   mvn package checkstyle:check\r\n   ```\r\n   under arrow/java. Not sure if there is a better way.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T21:38:25.536+0000",
                    "updated": "2017-11-14T21:38:25.536+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252237",
                    "id": "16252237",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344410120\n \n \n   Thanks @icexelloss . The expectation is to have absolutely no checkstyle warnings? I can see several warnings for files that haven't been changes as part of refactoring patches. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T21:47:51.232+0000",
                    "updated": "2017-11-14T21:47:51.232+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252292",
                    "id": "16252292",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r150972624\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseValueVector.java\n ##########\n @@ -122,5 +123,49 @@ public static boolean checkBufRefs(final ValueVector vv) {\n   public BufferAllocator getAllocator() {\n     return allocator;\n   }\n+\n+  protected void compareTypes(BaseValueVector target, String caller) {\n+    if (this.getMinorType() != target.getMinorType()) {\n+      throw new UnsupportedOperationException(caller + \" should have vectors of exact same type\");\n \n Review comment:\n   was this in the API before, if not maybe it would be better to  just return a boolean and the caller can throw an exception?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T21:59:43.645+0000",
                    "updated": "2017-11-14T21:59:43.645+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252525",
                    "id": "16252525",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344415423\n \n \n   It looks like the integration test is failing because we need to make code changes in C++ that interprets the JSON and loads the vector. Since the vectors no longer have inner buffers, we had to change the JAVA JsonFileReader code in JAVA that parses the JSON and appropriately allocates the inner buffers (validity, offset, data) of the target vector and fills them with data.\r\n   \r\n   We need to make similar changes in C++ code that parses a JSon file and loads/builds the vector. It looks like JAVA side of integration test is receiving a vector whose buffer has not been allocated.\r\n   \r\n   I am digging but it will be very helpful if someone from C++ side can extend help in any manner.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T22:07:56.692+0000",
                    "updated": "2017-11-14T22:07:56.692+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252527",
                    "id": "16252527",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344415423\n \n \n   It looks like the integration test is failing because we need to make code changes in C++ that interprets the JSON and loads the vector. Since the vectors no longer have inner vectors, we had to change the JAVA JsonFileReader code in JAVA that parses the JSON and appropriately allocates the inner buffers (validity, offset, data) of the target vector and fills them with data.\r\n   \r\n   We need to make similar changes in C++ code that parses a JSon file and loads/builds the vector. It looks like JAVA side of integration test is receiving a vector whose buffer has not been allocated.\r\n   \r\n   I am digging but it will be very helpful if someone from C++ side can extend help in any manner.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T22:08:18.124+0000",
                    "updated": "2017-11-14T22:08:18.124+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252529",
                    "id": "16252529",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344416669\n \n \n   \"Since the vectors no longer have inner vectors\" I'm not familiar with this terminology -- the JSON format contains a vector along with its children (are these the inner vectors?). Let me know where the problem is occurring and I can take a look\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T22:12:51.801+0000",
                    "updated": "2017-11-14T22:12:51.801+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252530",
                    "id": "16252530",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344416775\n \n \n   Does the JSON format need to change somehow? \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T22:13:16.613+0000",
                    "updated": "2017-11-14T22:13:16.613+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252554",
                    "id": "16252554",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344420686\n \n \n   The Nullable scalars (fixed width and var width)\r\n   \r\n   A NullableIntVector had two inner vectors -- BitVector and IntVector and we used to delegate the operations to these inner vectors. Now instead of the inner vectors, we just have two ArrowBufs that manage the validity and data respectively. \r\n   \r\n   The Json format doesn't need to change. However, the code that parses Json and writes to vector or vice-versa had to be changed in JAVA because it was written with assumption that vectors have inner vectors that can be directly operated on. It was changed to directly work with inner buffers as opposed to inner vectors. \r\n   \r\n   Changes were needed in JsonFileReader (function readFromJsonIntoVector) and JsonFileWriter (function writeFromVectorIntoJson) respectively.\r\n   \r\n   On the C++ side, I believe similar changes are needed in json.cc (reader and writer implementation) and json_internal.cc (ReadRecordBatch and WriteRecordBatch) functions assuming I am looking at the correct Json handling code in C++.\r\n   \r\n   @BryanCutler, @icexelloss , since you had reviewed the Json File reader/writer changes and later Li refactored them, do you agree with above analysis and suggested changes on the C++ side?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T22:28:24.301+0000",
                    "updated": "2017-11-14T22:28:24.301+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252558",
                    "id": "16252558",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344420930\n \n \n   @siddharthteotia There is already a bunch of style check warning. But there shouldn't be any with regard to Indentation, WhitespaceAround and EmptyLineSeparator.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T22:29:18.007+0000",
                    "updated": "2017-11-14T22:29:18.007+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252563",
                    "id": "16252563",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344421505\n \n \n   > It was changed to directly work with inner buffers as opposed to inner vectors.\r\n   \r\n   Again, I'm pretty lost on this terminology. Which vector types are affected by this? Can you point me to the Java code in the old vectors vs. the new vectors so I can see for myself\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T22:31:21.171+0000",
                    "updated": "2017-11-14T22:31:21.171+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252568",
                    "id": "16252568",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344423381\n \n \n   @wesm Decimal vectors are failing. I suspect this has something to do with recent changes on master with decimals. \r\n   \r\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T22:38:36.269+0000",
                    "updated": "2017-11-14T22:38:36.269+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252619",
                    "id": "16252619",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344425460\n \n \n   Got it, thanks. Unless the JSON format is changing, I don't see what could be wrong with the C++ implementation, unless something about the binary format itself changed\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T22:45:52.363+0000",
                    "updated": "2017-11-14T22:45:52.363+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252620",
                    "id": "16252620",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344425477\n \n \n   cc @cpcloud \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T22:45:57.821+0000",
                    "updated": "2017-11-14T22:45:57.821+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252642",
                    "id": "16252642",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344428363\n \n \n   I don't see anything obvious wrong with the decimal reading here, I'll reproduce locally and take a closer look.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T22:57:53.998+0000",
                    "updated": "2017-11-14T22:57:53.998+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252652",
                    "id": "16252652",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344429462\n \n \n   I think I found the issue:\r\n   \r\n   https://github.com/siddharthteotia/arrow/blob/ARROW-1476/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableFixedWidthVector.java#L516\r\n   \r\n   Comparing to the old code:\r\n   https://github.com/apache/arrow/blob/master/java/vector/src/main/java/org/apache/arrow/vector/BitVector.java#L57\r\n   \r\n   The old code handles the case where nullCount == 0 and validity buffer is empty. The new code doesn't.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T23:02:40.712+0000",
                    "updated": "2017-11-14T23:02:40.712+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252655",
                    "id": "16252655",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344430391\n \n \n   regarding whitespace style, I saw there were a few files with no empty line at the end.  Is that part of the style check?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T23:07:04.320+0000",
                    "updated": "2017-11-14T23:07:04.320+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252676",
                    "id": "16252676",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344434176\n \n \n   Thanks @icexelloss . It looks like the loadFieldBuffers code in new vector is missing some special handling of validity buffer. However, as per the old load code I am not sure when (and why) will the readable bytes be 0 and value count non-zero -- https://github.com/apache/arrow/blob/master/java/vector/src/main/java/org/apache/arrow/vector/BitVector.java#L57\r\n   If the condition is not fulfilled then it does what the new code is doing -- associate the buffer with target allocator. I am not quite sure when will the specialized handling be exercised? \r\n   \r\n   Whether the vector is all NULLs or not, the buffer cannot be empty if the value count is non-zero. Am I missing something?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T23:25:08.542+0000",
                    "updated": "2017-11-14T23:25:08.542+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252706",
                    "id": "16252706",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344439955\n \n \n   @siddharthteotia I think validity buffer is optional when nullCount == 0 per Arrow spec. I think C++ actually sends empty validity buffer when nullCount == 0.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T23:54:18.503+0000",
                    "updated": "2017-11-14T23:54:18.503+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252720",
                    "id": "16252720",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344439955\n \n \n   @siddharthteotia I think validity buffer is optional when nullCount == 0 per Arrow spec. I think C++ actually sends empty validity buffer when nullCount == 0.\r\n   \r\n   ```\r\n   if (data.readableBytes() == 0 && fieldNode.getLength() != 0)\r\n   ```\r\n   \r\n   I think this condition is to handle this code:\r\n   \r\n   https://github.com/apache/arrow/blob/master/java/vector/src/main/codegen/templates/NullableValueVectors.java#L152\r\n   \r\n   Here the first buffer (validity) triggers true for:\r\n   https://github.com/apache/arrow/blob/master/java/vector/src/main/java/org/apache/arrow/vector/BitVector.java#L57\r\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T00:02:45.034+0000",
                    "updated": "2017-11-15T00:02:45.034+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252727",
                    "id": "16252727",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344443110\n \n \n   Yeah, this is what's happening.  I confirmed the failure is when reading an binary file from C++ where null count is 0.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T00:10:53.628+0000",
                    "updated": "2017-11-15T00:10:53.628+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252730",
                    "id": "16252730",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344443748\n \n \n   Thanks @BryanCutler , @icexelloss . I wasn't aware of this and assumed that always a non-empty validity buffer will be shipped as long as valueCount > 0 regardless of null count. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T00:14:10.139+0000",
                    "updated": "2017-11-15T00:14:10.139+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252734",
                    "id": "16252734",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344444206\n \n \n   Created https://github.com/siddharthteotia/arrow/pull/2 to detect incorrect license headers.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T00:16:48.023+0000",
                    "updated": "2017-11-15T00:16:48.023+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252746",
                    "id": "16252746",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344445266\n \n \n   BTW, I think we only saw this failure because the random seed in the integration tests led a dictionary record batch that sampled all valid bits.  Perhaps we ought to have an explicit integration test for this case?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T00:23:04.941+0000",
                    "updated": "2017-11-15T00:23:04.941+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252753",
                    "id": "16252753",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344446616\n \n \n   @BryanCutler I added module for \"NewlineAtEndOfFile\" here https://github.com/siddharthteotia/arrow/pull/2\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T00:30:49.454+0000",
                    "updated": "2017-11-15T00:30:49.454+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252764",
                    "id": "16252764",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344448860\n \n \n   There was one more problem. When JsonFileReader was  refactored recently while removing the static interfaces, we did not set the writer index on the buffers we are allocating for the vector. As we are parsing JSON and writing to buffers, we should be setting writer index before calling loadFieldBuffers(). \r\n   \r\n   The static interfaces were doing so but we missed doing that in the recent change\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T00:44:26.142+0000",
                    "updated": "2017-11-15T00:44:26.142+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252834",
                    "id": "16252834",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344461498\n \n \n   FYI, I updated Spark to use these changes and tests pass for the most part.  There are still a couple things I need to work out, but overall it is looking good from this side!\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T01:58:14.916+0000",
                    "updated": "2017-11-15T01:58:14.916+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252854",
                    "id": "16252854",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344466689\n \n \n   Oops, I can take a look at JsonFileReader tomorrow. @siddharthteotia which tests are failing because of that?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T02:30:31.868+0000",
                    "updated": "2017-11-15T02:30:31.868+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252872",
                    "id": "16252872",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344473077\n \n \n   Fixing checkstyle for warning is probably a wasted effort especially when the warnings are coming from code that hasn't been modified as well. I have filed a JIRA to address this separately. With so many warnings dumped by mvn package checkstyle:check, it is slightly difficult to identify what to fix and what not.\r\n   \r\n   Essentially everything needs to be fixed -- indentation, order of imports etc throughout the code base. \r\n   \r\n   I am fine with doing it but can we do it separately? I have filed a JIRA to track this \r\n   https://issues.apache.org/jira/browse/ARROW-1813\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T03:13:20.314+0000",
                    "updated": "2017-11-15T03:13:20.314+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252873",
                    "id": "16252873",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344473077\n \n \n   Fixing checkstyle for warning is probably a wasted effort especially when the warnings are coming from code that hasn't been modified as well. I have filed a JIRA to address this separately. With so many warnings dumped by mvn package checkstyle:check, it is slightly difficult to identify what to fix and what not.\r\n   \r\n   Essentially everything needs to be fixed -- indentation, order of imports etc throughout the code base. I have done it for most parts of newly written code.\r\n   \r\n   I am fine with doing it but can we do it separately? I have filed a JIRA to track this \r\n   https://issues.apache.org/jira/browse/ARROW-1813\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T03:14:33.737+0000",
                    "updated": "2017-11-15T03:14:33.737+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252874",
                    "id": "16252874",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344473363\n \n \n   Yes, let's do the style fixes separately. I think it's long overdue\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T03:15:30.925+0000",
                    "updated": "2017-11-15T03:15:30.925+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16252881",
                    "id": "16252881",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344474860\n \n \n   @siddharthteotia How about we fix at least indentation, header and white spaces, end of file new lines for new files? \r\n   \r\n   Other checkstyle warning we can fix it later, but I am concerned with adding lots of new files with incorrect indentation and white spaces.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T03:26:32.828+0000",
                    "updated": "2017-11-15T03:26:32.828+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16253015",
                    "id": "16253015",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344497430\n \n \n   @icexelloss , I have fixed indentation, license header and white spaces in new files. Going through the code again. Travis CI build passes.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T06:22:26.921+0000",
                    "updated": "2017-11-15T06:22:26.921+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16253045",
                    "id": "16253045",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344504683\n \n \n   Build passed.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T07:06:47.340+0000",
                    "updated": "2017-11-15T07:06:47.340+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16253548",
                    "id": "16253548",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151146019\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/VectorUnloader.java\n ##########\n @@ -27,6 +27,8 @@\n import org.apache.arrow.vector.schema.ArrowRecordBatch;\n import org.apache.arrow.vector.schema.ArrowVectorType;\n \n+import javax.annotation.Nullable;\n \n Review comment:\n   Unused?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T14:48:00.362+0000",
                    "updated": "2017-11-15T14:48:00.362+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16253553",
                    "id": "16253553",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151147307\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileReader.java\n ##########\n @@ -218,16 +190,310 @@ public VectorSchemaRoot read() throws IOException {\n     }\n   }\n \n-  /**\n-   * TODO: A better way of implementing this function is to use `loadFieldBuffers` methods in\n-   * FieldVector to set the inner-vector data as done in `ArrowFileReader`.\n-   */\n-  private void readVector(Field field, FieldVector vector) throws JsonParseException, IOException {\n-    List<ArrowVectorType> vectorTypes = field.getTypeLayout().getVectorTypes();\n-    List<BufferBacked> fieldInnerVectors = vector.getFieldInnerVectors();\n-    if (vectorTypes.size() != fieldInnerVectors.size()) {\n-      throw new IllegalArgumentException(\"vector types and inner vectors are not the same size: \" + vectorTypes.size() + \" != \" + fieldInnerVectors.size());\n+  private abstract class BufferReader {\n+    abstract protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException;\n+\n+    ArrowBuf readBuffer(BufferAllocator allocator, int count) throws IOException {\n+      readToken(START_ARRAY);\n+      ArrowBuf buf = read(allocator, count);\n+      readToken(END_ARRAY);\n+      return buf;\n     }\n+  }\n+\n+  private class BufferHelper {\n+    BufferReader BIT = new BufferReader() {\n+      @Override\n+      protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException {\n+        final int bufferSize = BitVectorHelper.getValidityBufferSize(count);\n+        ArrowBuf buf = allocator.buffer(bufferSize);\n+\n+        // C++ integration test fails without this.\n+        buf.setZero(0, bufferSize);\n+\n+        for (int i = 0; i < count; i++) {\n+          parser.nextToken();\n+          BitVectorHelper.setValidityBit(buf, i, parser.readValueAs(Boolean.class) ? 1 : 0);\n+        }\n+\n+        buf.writerIndex(bufferSize);\n+        return buf;\n+      }\n+    };\n+\n+    BufferReader INT1 = new BufferReader() {\n+      @Override\n+      protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException {\n+        final int size = count * NullableTinyIntVector.TYPE_WIDTH;\n+        ArrowBuf buf = allocator.buffer(size);\n+\n+        for (int i = 0; i < count; i++) {\n+          parser.nextToken();\n+          buf.writeByte(parser.getByteValue());\n+        }\n+\n+        buf.writerIndex(size);\n \n Review comment:\n   Do we need this? `buf.writeByte` seems to update writerIndex already.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T14:52:10.150+0000",
                    "updated": "2017-11-15T14:52:10.150+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16253558",
                    "id": "16253558",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151148482\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\n ##########\n @@ -615,8 +632,10 @@ public void transferTo(BaseNullableVariableWidthVector target){\n       target.validityBuffer = validityBuffer.transferOwnership(target.allocator).buffer;\n       target.valueBuffer = valueBuffer.transferOwnership(target.allocator).buffer;\n       target.offsetBuffer = offsetBuffer.transferOwnership(target.allocator).buffer;\n-      target.valueCount = valueCount;\n-      target.setLastSet(lastSet);\n+      target.setLastSet(this.lastSet);\n+      if (this.valueCount > 0) {\n \n Review comment:\n   Ok.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T14:56:03.133+0000",
                    "updated": "2017-11-15T14:56:03.133+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16253563",
                    "id": "16253563",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151148806\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableFixedWidthVector.java\n ##########\n @@ -543,21 +533,28 @@ public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers\n     */\n    public List<ArrowBuf> getFieldBuffers() {\n \n Review comment:\n   Ping @siddharthteotia, can you explain on the difference between the two methods and how do we need both as public API?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T14:57:05.539+0000",
                    "updated": "2017-11-15T14:57:05.539+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16253566",
                    "id": "16253566",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151149051\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\n ##########\n @@ -836,17 +858,259 @@ public int getLastSet() {\n     * @return starting offset for the element\n     */\n    public long getStartEnd(int index) {\n-      return (long)offsetBuffer.getInt(index * OFFSET_WIDTH);\n+      return offsetBuffer.getLong(index * OFFSET_WIDTH);\n    }\n \n    /**\n     * Mark the particular position in the vector as non-null.\n     *\n     * @param index position of the element.\n     */\n+   @Override\n    public void setIndexDefined(int index) {\n-      handleSafe(index, 0);\n+      while (index >= getValidityBufferValueCapacity()) {\n+         validityBuffer = reallocBufferHelper(validityBuffer, false);\n+      }\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+   }\n+\n+   /**\n+    * Sets the value length for an element.\n+    *\n+    * @param index   position of the element to set\n+    * @param length  length of the element\n+    */\n+   public void setValueLengthSafe(int index, int length) {\n \n Review comment:\n   Ping @siddharthteotia , can you explain why do we need this as a public API? When would a user want to just sent length for an element?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T14:57:49.516+0000",
                    "updated": "2017-11-15T14:57:49.516+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16253570",
                    "id": "16253570",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151149731\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/GenerateSampleData.java\n ##########\n @@ -0,0 +1,337 @@\n+/*******************************************************************************\n+\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ ******************************************************************************/\n+\n+package org.apache.arrow.vector;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.Charset;\n+\n+/**\n+ * Helper class to generate test data for Nullable fixed and variable\n+ * width scalar vectors. Previous implementations of java vector classes\n+ * provided generateTestData(now deprecated) API to populate the vector\n+ * with sample data. This class should be used for that purpose.\n+ */\n+public class GenerateSampleData {\n \n Review comment:\n   Ping @siddharthteotia. Looks like this class is not used anywhere. Do we need this?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T14:59:57.219+0000",
                    "updated": "2017-11-15T14:59:57.219+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16253574",
                    "id": "16253574",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151150694\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java\n ##########\n @@ -363,86 +481,114 @@ public UnionVector promoteToUnion() {\n     return vector;\n   }\n \n-  private int lastSet = 0;\n+  @Override\n+  public Object getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    }\n+    final List<Object> vals = new JsonStringArrayList<>();\n+    final int start = offsetBuffer.getInt(index * OFFSET_WIDTH);\n+    final int end = offsetBuffer.getInt((index + 1) * OFFSET_WIDTH);\n+    final ValueVector vv = getDataVector();\n+    for (int i = start; i < end; i++) {\n+      vals.add(vv.getObject(i));\n+    }\n \n-  public class Accessor extends BaseRepeatedAccessor {\n+    return vals;\n+  }\n \n-    @Override\n-    public Object getObject(int index) {\n-      if (isNull(index)) {\n-        return null;\n-      }\n-      final List<Object> vals = new JsonStringArrayList<>();\n-      final UInt4Vector.Accessor offsetsAccessor = offsets.getAccessor();\n-      final int start = offsetsAccessor.get(index);\n-      final int end = offsetsAccessor.get(index + 1);\n-      final ValueVector.Accessor valuesAccessor = getDataVector().getAccessor();\n-      for (int i = start; i < end; i++) {\n-        vals.add(valuesAccessor.getObject(i));\n-      }\n-      return vals;\n-    }\n+  @Override\n+  public boolean isNull(int index) {\n+    return (isSet(index) == 0);\n+  }\n \n-    @Override\n-    public boolean isNull(int index) {\n-      return bits.getAccessor().get(index) == 0;\n-    }\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return Long.bitCount(b & (1L << bitIndex));\n+  }\n \n-    @Override\n-    public int getNullCount() {\n-      return bits.getAccessor().getNullCount();\n-    }\n+  @Override\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n   }\n \n-  public class Mutator extends BaseRepeatedMutator {\n-    public void setNotNull(int index) {\n-      bits.getMutator().setSafe(index, 1);\n-      lastSet = index + 1;\n-    }\n+  @Override\n+  public int getValueCapacity() {\n+    return Math.min(getValidityBufferValueCapacity(), super.getValueCapacity());\n+  }\n \n-    @Override\n-    public int startNewValue(int index) {\n-      for (int i = lastSet; i <= index; i++) {\n-        offsets.getMutator().setSafe(i + 1, offsets.getAccessor().get(i));\n-      }\n-      setNotNull(index);\n-      lastSet = index + 1;\n-      return offsets.getAccessor().get(lastSet);\n-    }\n+  public int getValidityAndOffsetValueCapacity() {\n \n Review comment:\n   @siddharthteotia I think we want to make this private, is that correct?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T15:02:51.768+0000",
                    "updated": "2017-11-15T15:02:51.768+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16253576",
                    "id": "16253576",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151151148\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/NullableVarBinaryVector.java\n ##########\n @@ -152,12 +135,9 @@ public void get(int index, NullableVarBinaryHolder holder){\n          holder.isSet = 0;\n          return;\n       }\n-      final int startOffset = getstartOffset(index);\n-      final int dataLength =\n-              offsetBuffer.getInt((index + 1) * OFFSET_WIDTH) - startOffset;\n       holder.isSet = 1;\n-      holder.start = startOffset;\n-      holder.end = dataLength;\n+      holder.start = getstartOffset(index);\n \n Review comment:\n   Ok\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T15:04:18.722+0000",
                    "updated": "2017-11-15T15:04:18.722+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16253581",
                    "id": "16253581",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344620732\n \n \n   Awesome.\r\n   \r\n   @siddharthteotia I have re commented on all my previous comments that are not addressed. Can you take a look? Thanks! \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T15:06:49.632+0000",
                    "updated": "2017-11-15T15:06:49.632+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16253608",
                    "id": "16253608",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344626951\n \n \n   @siddharthteotia There are still some indentation and white space warning on the new vector files, you can see this by running:\r\n   \r\n   ```\r\n   mvn package checkstyle:checkstyle\r\n   ```\r\n   \r\n   and check the html file under \r\n   \r\n   ```\r\n   vector/target/site/checkstyle.html\r\n   ```\r\n   \r\n   Can you double check those please? Thanks\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T15:25:52.763+0000",
                    "updated": "2017-11-15T15:25:52.763+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16253638",
                    "id": "16253638",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344626951\n \n \n   @siddharthteotia There are still some indentation and white space warning on the some new vector files\r\n   \r\n   ```\r\n   org/apache/arrow/vector/BaseNullableFixedWidthVector.java\r\n   org/apache/arrow/vector/BaseNullableVariableWidthVector.java\r\n   ```\r\n   \r\n   you can see this by running:\r\n   \r\n   ```\r\n   mvn package checkstyle:checkstyle\r\n   ```\r\n   \r\n   and check the html file under \r\n   \r\n   ```\r\n   vector/target/site/checkstyle.html\r\n   ```\r\n   \r\n   Can you double check those please? Thanks. Otherwise style looks correct.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T15:35:05.472+0000",
                    "updated": "2017-11-15T15:35:05.472+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16253648",
                    "id": "16253648",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344631236\n \n \n   Looks like we are on the home stretch. I can merge later today when these last small items are addressed\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T15:38:50.030+0000",
                    "updated": "2017-11-15T15:38:50.030+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16253893",
                    "id": "16253893",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151209408\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/GenerateSampleData.java\n ##########\n @@ -0,0 +1,337 @@\n+/*******************************************************************************\n+\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ ******************************************************************************/\n+\n+package org.apache.arrow.vector;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.Charset;\n+\n+/**\n+ * Helper class to generate test data for Nullable fixed and variable\n+ * width scalar vectors. Previous implementations of java vector classes\n+ * provided generateTestData(now deprecated) API to populate the vector\n+ * with sample data. This class should be used for that purpose.\n+ */\n+public class GenerateSampleData {\n \n Review comment:\n   We use this in Dremio\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T18:17:43.157+0000",
                    "updated": "2017-11-15T18:17:43.157+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16253894",
                    "id": "16253894",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151209979\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/VectorUnloader.java\n ##########\n @@ -27,6 +27,8 @@\n import org.apache.arrow.vector.schema.ArrowRecordBatch;\n import org.apache.arrow.vector.schema.ArrowVectorType;\n \n+import javax.annotation.Nullable;\n \n Review comment:\n   Done.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T18:19:46.430+0000",
                    "updated": "2017-11-15T18:19:46.430+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16253900",
                    "id": "16253900",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151210811\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileReader.java\n ##########\n @@ -218,16 +190,310 @@ public VectorSchemaRoot read() throws IOException {\n     }\n   }\n \n-  /**\n-   * TODO: A better way of implementing this function is to use `loadFieldBuffers` methods in\n-   * FieldVector to set the inner-vector data as done in `ArrowFileReader`.\n-   */\n-  private void readVector(Field field, FieldVector vector) throws JsonParseException, IOException {\n-    List<ArrowVectorType> vectorTypes = field.getTypeLayout().getVectorTypes();\n-    List<BufferBacked> fieldInnerVectors = vector.getFieldInnerVectors();\n-    if (vectorTypes.size() != fieldInnerVectors.size()) {\n-      throw new IllegalArgumentException(\"vector types and inner vectors are not the same size: \" + vectorTypes.size() + \" != \" + fieldInnerVectors.size());\n+  private abstract class BufferReader {\n+    abstract protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException;\n+\n+    ArrowBuf readBuffer(BufferAllocator allocator, int count) throws IOException {\n+      readToken(START_ARRAY);\n+      ArrowBuf buf = read(allocator, count);\n+      readToken(END_ARRAY);\n+      return buf;\n     }\n+  }\n+\n+  private class BufferHelper {\n+    BufferReader BIT = new BufferReader() {\n+      @Override\n+      protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException {\n+        final int bufferSize = BitVectorHelper.getValidityBufferSize(count);\n+        ArrowBuf buf = allocator.buffer(bufferSize);\n+\n+        // C++ integration test fails without this.\n+        buf.setZero(0, bufferSize);\n+\n+        for (int i = 0; i < count; i++) {\n+          parser.nextToken();\n+          BitVectorHelper.setValidityBit(buf, i, parser.readValueAs(Boolean.class) ? 1 : 0);\n+        }\n+\n+        buf.writerIndex(bufferSize);\n+        return buf;\n+      }\n+    };\n+\n+    BufferReader INT1 = new BufferReader() {\n+      @Override\n+      protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException {\n+        final int size = count * NullableTinyIntVector.TYPE_WIDTH;\n+        ArrowBuf buf = allocator.buffer(size);\n+\n+        for (int i = 0; i < count; i++) {\n+          parser.nextToken();\n+          buf.writeByte(parser.getByteValue());\n+        }\n+\n+        buf.writerIndex(size);\n \n Review comment:\n   Yes we don't need. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T18:23:05.870+0000",
                    "updated": "2017-11-15T18:23:05.870+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16253901",
                    "id": "16253901",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151210853\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java\n ##########\n @@ -363,86 +481,114 @@ public UnionVector promoteToUnion() {\n     return vector;\n   }\n \n-  private int lastSet = 0;\n+  @Override\n+  public Object getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    }\n+    final List<Object> vals = new JsonStringArrayList<>();\n+    final int start = offsetBuffer.getInt(index * OFFSET_WIDTH);\n+    final int end = offsetBuffer.getInt((index + 1) * OFFSET_WIDTH);\n+    final ValueVector vv = getDataVector();\n+    for (int i = start; i < end; i++) {\n+      vals.add(vv.getObject(i));\n+    }\n \n-  public class Accessor extends BaseRepeatedAccessor {\n+    return vals;\n+  }\n \n-    @Override\n-    public Object getObject(int index) {\n-      if (isNull(index)) {\n-        return null;\n-      }\n-      final List<Object> vals = new JsonStringArrayList<>();\n-      final UInt4Vector.Accessor offsetsAccessor = offsets.getAccessor();\n-      final int start = offsetsAccessor.get(index);\n-      final int end = offsetsAccessor.get(index + 1);\n-      final ValueVector.Accessor valuesAccessor = getDataVector().getAccessor();\n-      for (int i = start; i < end; i++) {\n-        vals.add(valuesAccessor.getObject(i));\n-      }\n-      return vals;\n-    }\n+  @Override\n+  public boolean isNull(int index) {\n+    return (isSet(index) == 0);\n+  }\n \n-    @Override\n-    public boolean isNull(int index) {\n-      return bits.getAccessor().get(index) == 0;\n-    }\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return Long.bitCount(b & (1L << bitIndex));\n+  }\n \n-    @Override\n-    public int getNullCount() {\n-      return bits.getAccessor().getNullCount();\n-    }\n+  @Override\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n   }\n \n-  public class Mutator extends BaseRepeatedMutator {\n-    public void setNotNull(int index) {\n-      bits.getMutator().setSafe(index, 1);\n-      lastSet = index + 1;\n-    }\n+  @Override\n+  public int getValueCapacity() {\n+    return Math.min(getValidityBufferValueCapacity(), super.getValueCapacity());\n+  }\n \n-    @Override\n-    public int startNewValue(int index) {\n-      for (int i = lastSet; i <= index; i++) {\n-        offsets.getMutator().setSafe(i + 1, offsets.getAccessor().get(i));\n-      }\n-      setNotNull(index);\n-      lastSet = index + 1;\n-      return offsets.getAccessor().get(lastSet);\n-    }\n+  public int getValidityAndOffsetValueCapacity() {\n \n Review comment:\n   Yes.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T18:23:15.195+0000",
                    "updated": "2017-11-15T18:23:15.195+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16253990",
                    "id": "16253990",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151225640\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/GenerateSampleData.java\n ##########\n @@ -0,0 +1,337 @@\n+/*******************************************************************************\n+\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ ******************************************************************************/\n+\n+package org.apache.arrow.vector;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.Charset;\n+\n+/**\n+ * Helper class to generate test data for Nullable fixed and variable\n+ * width scalar vectors. Previous implementations of java vector classes\n+ * provided generateTestData(now deprecated) API to populate the vector\n+ * with sample data. This class should be used for that purpose.\n+ */\n+public class GenerateSampleData {\n \n Review comment:\n   If it's only used for Dremio testing, does it make more sense to stay in Dremio codebase?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T19:19:41.072+0000",
                    "updated": "2017-11-15T19:19:41.072+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16254002",
                    "id": "16254002",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151226732\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableFixedWidthVector.java\n ##########\n @@ -0,0 +1,848 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.schema.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * BaseNullableFixedWidthVector provides an abstract interface for\n+ * implementing vectors of fixed width values. The vectors are nullable\n+ * implying that zero or more elements in the vector could be NULL.\n+ */\n+public abstract class BaseNullableFixedWidthVector extends BaseValueVector\n+        implements FixedWidthVector, FieldVector, NullableVectorDefinitionSetter {\n+  private final byte typeWidth;\n+\n+  protected int valueAllocationSizeInBytes;\n+  protected int validityAllocationSizeInBytes;\n+\n+  protected final Field field;\n+  private int allocationMonitor;\n+  protected ArrowBuf validityBuffer;\n+  protected ArrowBuf valueBuffer;\n+  protected int valueCount;\n+\n+  public BaseNullableFixedWidthVector(final String name, final BufferAllocator allocator,\n+                                      FieldType fieldType, final byte typeWidth) {\n+    super(name, allocator);\n+    this.typeWidth = typeWidth;\n+    field = new Field(name, fieldType, null);\n+    valueCount = 0;\n+    allocationMonitor = 0;\n+    validityBuffer = allocator.getEmpty();\n+    valueBuffer = allocator.getEmpty();\n+    if (typeWidth > 0) {\n+      valueAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * typeWidth;\n+      validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    } else {\n+         /* specialized handling for NullableBitVector */\n+      valueAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+      validityAllocationSizeInBytes = valueAllocationSizeInBytes;\n+    }\n+  }\n+\n+\n+   /* TODO:\n+    *\n+    * see if getNullCount() can be made faster -- O(1)\n+    */\n+\n+   /* TODO:\n+    * Once the entire hierarchy has been refactored, move common functions\n+    * like getNullCount(), splitAndTransferValidityBuffer to top level\n+    * base class BaseValueVector.\n+    *\n+    * Along with this, some class members (validityBuffer) can also be\n+    * abstracted out to top level base class.\n+    *\n+    * Right now BaseValueVector is the top level base class for other\n+    * vector types in ValueVector hierarchy (non-nullable) and those\n+    * vectors have not yet been refactored/removed so moving things to\n+    * the top class as of now is not a good idea.\n+    */\n+\n+\n+  @Override\n+  @Deprecated\n+  public Mutator getMutator() {\n+    throw new UnsupportedOperationException(\"Mutator is not supported for writing to vector\");\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public Accessor getAccessor() {\n+    throw new UnsupportedOperationException(\"Accessor is not supported for reading from vector\");\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that manages the validity\n+   * (NULL or NON-NULL nature) of elements in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return (validityBuffer.memoryAddress());\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the data for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getDataBufferAddress() {\n+    return (valueBuffer.memoryAddress());\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the offsets for elements\n+   * in the vector. This operation is not supported for fixed-width vectors.\n+   * @return starting address of the buffer\n+   * @throws UnsupportedOperationException for fixed width vectors\n+   */\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    throw new UnsupportedOperationException(\"not supported for fixed-width vectors\");\n+  }\n+\n+  /**\n+   * Get buffer that manages the validity (NULL or NON-NULL nature) of\n+   * elements in the vector. Consider it as a buffer for internal bit vector\n+   * data structure.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  /**\n+   * Get the buffer that stores the data for elements in the vector.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    return valueBuffer;\n+  }\n+\n+  /**\n+   * buffer that stores the offsets for elements\n+   * in the vector. This operation is not supported for fixed-width vectors.\n+   * @return buffer\n+   * @throws UnsupportedOperationException for fixed width vectors\n+   */\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    throw new UnsupportedOperationException(\"not supported for fixed-width vectors\");\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   * @param valueCount desired number of elements in the vector\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount) {\n+    final long size = (long) valueCount * typeWidth;\n+    if (size > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+    valueAllocationSizeInBytes = (int) size;\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(valueCount);\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    return Math.min(getValueBufferValueCapacity(), getValidityBufferValueCapacity());\n+  }\n+\n+  private int getValueBufferValueCapacity() {\n+    return (int) ((valueBuffer.capacity() * 1.0) / typeWidth);\n+  }\n+\n+  private int getValidityBufferValueCapacity() {\n+    return (int) (validityBuffer.capacity() * 8L);\n+  }\n+\n+  /**\n+   * zero out the vector and the data in associated buffers.\n+   */\n+  @Override\n+  public void zeroVector() {\n+    initValidityBuffer();\n+    initValueBuffer();\n+  }\n+\n+  /* zero out the validity buffer */\n+  private void initValidityBuffer() {\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+\n+  /* zero out the data buffer */\n+  private void initValueBuffer() {\n+    valueBuffer.setZero(0, valueBuffer.capacity());\n+  }\n+\n+  /**\n+   * Reset the vector to initial state. Same as {@link #zeroVector()}.\n+   * Note that this method doesn't release any memory.\n+   */\n+  public void reset() {\n+    zeroVector();\n+  }\n+\n+  /**\n+   * Close the vector and release the associated buffers.\n+   */\n+  @Override\n+  public void close() {\n+    clear();\n+  }\n+\n+  /**\n+   * Same as {@link #close()}\n+   */\n+  @Override\n+  public void clear() {\n+    valueCount = 0;\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    valueBuffer = releaseBuffer(valueBuffer);\n+  }\n+\n+  /* used to step down the memory allocation */\n+  protected void incrementAllocationMonitor() {\n+    if (allocationMonitor < 0) {\n+      allocationMonitor = 0;\n+    }\n+    allocationMonitor++;\n+  }\n+\n+  /* used to step up the memory allocation */\n+  protected void decrementAllocationMonitor() {\n+    if (allocationMonitor > 0) {\n+      allocationMonitor = 0;\n+    }\n+    allocationMonitor--;\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory.\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector. See {@link #allocateNew(int)} for allocating memory for specific\n+   * number of elements in the vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  @Override\n+  public boolean allocateNewSafe() {\n+    long curAllocationSizeValue = valueAllocationSizeInBytes;\n+    long curAllocationSizeValidity = validityAllocationSizeInBytes;\n+\n+    if (curAllocationSizeValue > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory exceeds limit\");\n+    }\n+\n+      /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(curAllocationSizeValue, curAllocationSizeValidity);\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Allocate memory for the vector to support storing at least the provided number of\n+   * elements in the vector. This method must be called prior to using the ValueVector.\n+   *\n+   * @param valueCount the desired number of elements in the vector\n+   * @throws org.apache.arrow.memory.OutOfMemoryException\n+   */\n+  public void allocateNew(int valueCount) {\n+    long valueBufferSize = valueCount * typeWidth;\n+    long validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    if (typeWidth == 0) {\n+         /* specialized handling for NullableBitVector */\n+      valueBufferSize = validityBufferSize;\n+    }\n+\n+    if (valueBufferSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+\n+      /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(valueBufferSize, validityBufferSize);\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Actual memory allocation is done by this function. All the calculations\n+   * and knowledge about what size to allocate is upto the callers of this\n+   * method.\n+   * Callers appropriately handle errors if memory allocation fails here.\n+   * Callers should also take care of determining that desired size is\n+   * within the bounds of max allocation allowed and any other error\n+   * conditions.\n+   */\n+  private void allocateBytes(final long valueBufferSize, final long validityBufferSize) {\n+      /* allocate data buffer */\n+    int curSize = (int) valueBufferSize;\n+    valueBuffer = allocator.buffer(curSize);\n+    valueBuffer.readerIndex(0);\n+    valueAllocationSizeInBytes = curSize;\n+      /* allocate validity buffer */\n+    allocateValidityBuffer((int) validityBufferSize);\n+    zeroVector();\n+  }\n+\n+  /**\n+   * During splitAndTransfer, if we splitting from a random position within a byte,\n+   * we can't just slice the source buffer so we have to explicitly allocate the\n+   * validityBuffer of the target vector. This is unlike the databuffer which we can\n+   * always slice for the target vector.\n+   */\n+  private void allocateValidityBuffer(final int validityBufferSize) {\n+    validityBuffer = allocator.buffer(validityBufferSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = validityBufferSize;\n+  }\n+\n+  /**\n+   * Get the potential buffer size for a particular number of records.\n+   * @param count desired number of elements in the vector\n+   * @return estimated size of underlying buffers if the vector holds\n+   *         a given number of elements\n+   */\n+  @Override\n+  public int getBufferSizeFor(final int count) {\n+    if (count == 0) {\n+      return 0;\n+    }\n+    return (count * typeWidth) + getValidityBufferSizeFromCount(count);\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    return (valueCount * typeWidth) + getValidityBufferSizeFromCount(valueCount);\n+  }\n+\n+  /**\n+   * Get information about how this field is materialized.\n+   * @return the field corresponding to this vector\n+   */\n+  @Override\n+  public Field getField() {\n+    return field;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n \n Review comment:\n   My previous comments are squashed because of code change.\r\n   \r\n   Why do we need both \r\n   \r\n   ```\r\n   public ArrowBuf[] getBuffers(boolean clear)\r\n   ``` \r\n   and \r\n   ```\r\n   public List<ArrowBuf> getFieldBuffers()\r\n   ```\r\n   Both as public API? They look very similar to me and might confuse users.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T19:23:41.730+0000",
                    "updated": "2017-11-15T19:23:41.730+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16254006",
                    "id": "16254006",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151227918\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\n ##########\n @@ -0,0 +1,1250 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.NullableMapVector;\n+import org.apache.arrow.vector.schema.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public abstract class BaseNullableVariableWidthVector extends BaseValueVector\n+        implements VariableWidthVector, FieldVector, NullableVectorDefinitionSetter {\n+  private static final int DEFAULT_RECORD_BYTE_COUNT = 8;\n+  private static final int INITIAL_BYTE_COUNT = INITIAL_VALUE_ALLOCATION * DEFAULT_RECORD_BYTE_COUNT;\n+\n+  private int valueAllocationSizeInBytes;\n+  private int validityAllocationSizeInBytes;\n+  private int offsetAllocationSizeInBytes;\n+\n+  /* protected members */\n+  public static final int OFFSET_WIDTH = 4; /* 4 byte unsigned int to track offsets */\n+  protected static final byte[] emptyByteArray = new byte[]{};\n+  protected ArrowBuf validityBuffer;\n+  protected ArrowBuf valueBuffer;\n+  protected ArrowBuf offsetBuffer;\n+  protected int valueCount;\n+  protected int lastSet;\n+  protected final Field field;\n+  private boolean cleared;\n+\n+  public BaseNullableVariableWidthVector(final String name, final BufferAllocator allocator,\n+                                         FieldType fieldType) {\n+    super(name, allocator);\n+    valueAllocationSizeInBytes = INITIAL_BYTE_COUNT;\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    offsetAllocationSizeInBytes = (INITIAL_VALUE_ALLOCATION) * OFFSET_WIDTH;\n+    field = new Field(name, fieldType, null);\n+    valueCount = 0;\n+    lastSet = -1;\n+    offsetBuffer = allocator.getEmpty();\n+    validityBuffer = allocator.getEmpty();\n+    valueBuffer = allocator.getEmpty();\n+    cleared = false;\n+  }\n+\n+   /* TODO:\n+    *\n+    * see if getNullCount() can be made faster -- O(1)\n+    */\n+\n+  /* TODO:\n+    * Once the entire hierarchy has been refactored, move common functions\n+    * like getNullCount(), splitAndTransferValidityBuffer to top level\n+    * base class BaseValueVector.\n+    *\n+    * Along with this, some class members (validityBuffer) can also be\n+    * abstracted out to top level base class.\n+    *\n+    * Right now BaseValueVector is the top level base class for other\n+    * vector types in ValueVector hierarchy (non-nullable) and those\n+    * vectors have not yet been refactored/removed so moving things to\n+    * the top class as of now is not a good idea.\n+    */\n+\n+\n+  @Override\n+  @Deprecated\n+  public VariableWidthMutator getMutator() {\n+    throw new UnsupportedOperationException(\"Mutator is not supported for writing into vector\");\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public VariableWidthAccessor getAccessor() {\n+    throw new UnsupportedOperationException(\"Accessor is not supported for reading from vector\");\n+  }\n+\n+  /**\n+   * Get buffer that manages the validity (NULL or NON-NULL nature) of\n+   * elements in the vector. Consider it as a buffer for internal bit vector\n+   * data structure.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  /**\n+   * Get the buffer that stores the data for elements in the vector.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    return valueBuffer;\n+  }\n+\n+  /**\n+   * buffer that stores the offsets for elements\n+   * in the vector. This operation is not supported for fixed-width vectors.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the offsets for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return offsetBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that manages the validity\n+   * (NULL or NON-NULL nature) of elements in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return validityBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the data for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getDataBufferAddress() {\n+    return valueBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   * @param valueCount desired number of elements in the vector\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount) {\n+    final long size = (long) valueCount * DEFAULT_RECORD_BYTE_COUNT;\n+    if (size > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+    valueAllocationSizeInBytes = (int) size;\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(valueCount);\n+      /* to track the end offset of last data element in vector, we need\n+       * an additional slot in offset buffer.\n+       */\n+    offsetAllocationSizeInBytes = (valueCount + 1) * OFFSET_WIDTH;\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    final int offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n+    return Math.min(offsetValueCapacity, getValidityBufferValueCapacity());\n+  }\n+\n+  private int getValidityBufferValueCapacity() {\n+    return (int) (validityBuffer.capacity() * 8L);\n+  }\n+\n+  private int getOffsetBufferValueCapacity() {\n+    return (int) ((offsetBuffer.capacity() * 1.0) / OFFSET_WIDTH);\n+  }\n+\n+  /**\n+   * zero out the vector and the data in associated buffers.\n+   */\n+  public void zeroVector() {\n+    initValidityBuffer();\n+    initOffsetBuffer();\n+  }\n+\n+  /* zero out the validity buffer */\n+  private void initValidityBuffer() {\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+\n+  /* zero out the offset buffer */\n+  private void initOffsetBuffer() {\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+\n+  /**\n+   * Reset the vector to initial state. Same as {@link #zeroVector()}.\n+   * Note that this method doesn't release any memory.\n+   */\n+  public void reset() {\n+    zeroVector();\n+    lastSet = -1;\n+  }\n+\n+  /**\n+   * Close the vector and release the associated buffers.\n+   */\n+  @Override\n+  public void close() {\n+    clear();\n+  }\n+\n+  /**\n+   * Same as {@link #close()}\n+   */\n+  @Override\n+  public void clear() {\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    valueBuffer = releaseBuffer(valueBuffer);\n+    offsetBuffer = releaseBuffer(offsetBuffer);\n+    cleared = true;\n+    lastSet = -1;\n+    valueCount = 0;\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Initialize the children in schema for this Field. This operation is a\n+   * NO-OP for scalar types since they don't have any children.\n+   * @param children the schema\n+   * @throws IllegalArgumentException if children is a non-empty list for scalar types.\n+   */\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (!children.isEmpty()) {\n+      throw new IllegalArgumentException(\"primitive type vector can not have children\");\n+    }\n+  }\n+\n+  /**\n+   * Get the inner child vectors.\n+   * @return list of child vectors for complex types, empty list for scalar vector\n+   * types\n+   */\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return Collections.emptyList();\n+  }\n+\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+    ArrowBuf dataBuffer = ownBuffers.get(2);\n+\n+    validityBuffer.release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.release();\n+    offsetBuffer = offBuffer.retain(allocator);\n+    valueBuffer.release();\n+    valueBuffer = dataBuffer.retain(allocator);\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector\n+   * @return the inner buffers.\n+   */\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(3);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+    result.add(valueBuffer);\n+\n+    return result;\n+  }\n+\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    valueBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+      valueBuffer.writerIndex(0);\n+    } else {\n+      final int lastDataOffset = getstartOffset(valueCount);\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+      valueBuffer.writerIndex(lastDataOffset);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory.\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector. See {@link #allocateNew(int, int)} for allocating memory for specific\n+   * number of elements in the vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  @Override\n+  public boolean allocateNewSafe() {\n+    long curAllocationSizeValue = valueAllocationSizeInBytes;\n+    long curAllocationSizeValidity = validityAllocationSizeInBytes;\n+    long curAllocationSizeOffset = offsetAllocationSizeInBytes;\n+\n+    if (curAllocationSizeValue > MAX_ALLOCATION_SIZE ||\n+            curAllocationSizeOffset > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory exceeds limit\");\n+    }\n+\n+      /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(curAllocationSizeValue, curAllocationSizeValidity, curAllocationSizeOffset);\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Allocate memory for the vector to support storing at least the provided number of\n+   * elements in the vector. This method must be called prior to using the ValueVector.\n+   *\n+   * @param totalBytes desired total memory capacity\n+   * @param valueCount the desired number of elements in the vector\n+   * @throws org.apache.arrow.memory.OutOfMemoryException\n+   */\n+  @Override\n+  public void allocateNew(int totalBytes, int valueCount) {\n+    assert totalBytes >= 0;\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+\n+    if (totalBytes > MAX_ALLOCATION_SIZE ||\n+            offsetBufferSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory exceeds limit\");\n+    }\n+\n+      /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(totalBytes, validityBufferSize, offsetBufferSize);\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+    }\n+  }\n+\n+  /* allocate the inner buffers */\n+  private void allocateBytes(final long valueBufferSize, final long validityBufferSize,\n+                             final long offsetBufferSize) {\n+      /* allocate data buffer */\n+    int curSize = (int) valueBufferSize;\n+    valueBuffer = allocator.buffer(curSize);\n+    valueBuffer.readerIndex(0);\n+    valueAllocationSizeInBytes = curSize;\n+    allocateValidityBuffer(validityBufferSize);\n+    allocateOffsetBuffer(offsetBufferSize);\n+  }\n+\n+  /* allocate offset buffer */\n+  private void allocateOffsetBuffer(final long size) {\n+    final int curSize = (int) size;\n+    offsetBuffer = allocator.buffer(curSize);\n+    offsetBuffer.readerIndex(0);\n+    offsetAllocationSizeInBytes = curSize;\n+    initOffsetBuffer();\n+  }\n+\n+  /* allocate validity buffer */\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    initValidityBuffer();\n+  }\n+\n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  public void reAlloc() {\n+    reallocDataBuffer();\n+    reallocValidityAndOffsetBuffers();\n+  }\n+\n+  /**\n+   * Reallocate the data buffer. Data Buffer stores the actual data for\n+   * VARCHAR or VARBINARY elements in the vector. The behavior is to double\n+   * the size of buffer.\n+   * @throws OversizedAllocationException if the desired new size is more than\n+   *                                      max allowed\n+   * @throws OutOfMemoryException if the internal memory allocation fails\n+   */\n+  public void reallocDataBuffer() {\n+    long baseSize = valueAllocationSizeInBytes;\n+    final int currentBufferCapacity = valueBuffer.capacity();\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, valueBuffer, 0, currentBufferCapacity);\n+    valueBuffer.release();\n+    valueBuffer = newBuf;\n+    valueAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  /**\n+   * Reallocate the validity and offset buffers for this vector. Validity\n+   * buffer is used to track the NULL or NON-NULL nature of elements in\n+   * the vector and offset buffer is used to store the lengths of variable\n+   * width elements in the vector.\n+   *\n+   * Note that data buffer for variable length vectors moves independent\n+   * of the companion validity and offset buffers. This is in\n+   * contrast to what we have for fixed width vectors.\n+   *\n+   * So even though we may have setup an initial capacity of 1024\n+   * elements in the vector, it is quite possible\n+   * that we need to reAlloc() the data buffer when we are setting\n+   * the 5th element in the vector simply because previous\n+   * variable length elements have exhausted the buffer capacity.\n+   * However, we really don't need to reAlloc() validity and\n+   * offset buffers until we try to set the 1025th element\n+   * This is why we do a separate check for safe methods to\n+   * determine which buffer needs reallocation.\n+   * @throws OversizedAllocationException if the desired new size is more than\n+   *                                      max allowed\n+   * @throws OutOfMemoryException if the internal memory allocation fails\n+   */\n+  public void reallocValidityAndOffsetBuffers() {\n+    offsetBuffer = reallocBufferHelper(offsetBuffer, true);\n+    validityBuffer = reallocBufferHelper(validityBuffer, false);\n+  }\n+\n+  /* helper method to realloc a particular buffer. returns the allocated buffer */\n+  private ArrowBuf reallocBufferHelper(ArrowBuf buffer, final boolean offsetBuffer) {\n+    final int currentBufferCapacity = buffer.capacity();\n+    long baseSize = (offsetBuffer ? offsetAllocationSizeInBytes\n+            : validityAllocationSizeInBytes);\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, buffer, 0, currentBufferCapacity);\n+    final int halfNewCapacity = newBuf.capacity() / 2;\n+    newBuf.setZero(halfNewCapacity, halfNewCapacity);\n+    buffer.release(1);\n+    buffer = newBuf;\n+    if (offsetBuffer) {\n+      offsetAllocationSizeInBytes = (int) newAllocationSize;\n+    } else {\n+      validityAllocationSizeInBytes = (int) newAllocationSize;\n+    }\n+\n+    return buffer;\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying data buffer.\n+   * @return\n+   */\n+  @Override\n+  public int getByteCapacity() {\n+    return valueBuffer.capacity();\n+  }\n+\n+  @Override\n+  public int getCurrentSizeInBytes() {\n+      /* TODO */\n+    return 0;\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    return getBufferSizeFor(this.valueCount);\n+  }\n+\n+  /**\n+   * Get the potential buffer size for a particular number of records.\n+   * @param valueCount desired number of elements in the vector\n+   * @return estimated size of underlying buffers if the vector holds\n+   *         a given number of elements\n+   */\n+  @Override\n+  public int getBufferSizeFor(final int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+      /* get the end offset for this valueCount */\n+    final int dataBufferSize = offsetBuffer.getInt(valueCount * OFFSET_WIDTH);\n+    return validityBufferSize + offsetBufferSize + dataBufferSize;\n+  }\n+\n+  /**\n+   * Get information about how this field is materialized.\n+   * @return the field corresponding to this vector\n+   */\n+  @Override\n+  public Field getField() {\n+    return field;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    final ArrowBuf[] buffers;\n+    setReaderAndWriterIndex();\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = new ArrowBuf[3];\n+      buffers[0] = validityBuffer;\n+      buffers[1] = offsetBuffer;\n+      buffers[2] = valueBuffer;\n+    }\n+    if (clear) {\n+      for (final ArrowBuf buffer : buffers) {\n+        buffer.retain(1);\n+      }\n+      clear();\n+    }\n+    return buffers;\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @param callBack\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return getTransferPair(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(BufferAllocator allocator) {\n+    return getTransferPair(name, allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  public abstract TransferPair getTransferPair(String ref, BufferAllocator allocator);\n+\n+  /**\n+   * Transfer this vector'data to another vector. The memory associated\n+   * with this vector is transferred to the allocator of target vector\n+   * for accounting and management purposes.\n+   * @param target destination vector for transfer\n+   */\n+  public void transferTo(BaseNullableVariableWidthVector target) {\n+    compareTypes(target, \"transferTo\");\n+    target.clear();\n+    target.validityBuffer = validityBuffer.transferOwnership(target.allocator).buffer;\n+    target.valueBuffer = valueBuffer.transferOwnership(target.allocator).buffer;\n+    target.offsetBuffer = offsetBuffer.transferOwnership(target.allocator).buffer;\n+    target.setLastSet(this.lastSet);\n+    if (this.valueCount > 0) {\n+      target.setValueCount(this.valueCount);\n+    }\n+    clear();\n+  }\n+\n+  /**\n+   * Slice this vector at desired index and length and transfer the\n+   * corresponding data to the target vector.\n+   * @param startIndex start position of the split in source vector.\n+   * @param length length of the split.\n+   * @param target destination vector\n+   */\n+  public void splitAndTransferTo(int startIndex, int length,\n+                                 BaseNullableVariableWidthVector target) {\n+    compareTypes(target, \"splitAndTransferTo\");\n+    target.clear();\n+    splitAndTransferValidityBuffer(startIndex, length, target);\n+    splitAndTransferOffsetBuffer(startIndex, length, target);\n+    target.setLastSet(length - 1);\n+    if (this.valueCount > 0) {\n+      target.setValueCount(this.valueCount);\n+    }\n+  }\n+\n+  /*\n+   * Transfer the offsets along with data. Unlike the data buffer, we cannot simply\n+   * slice the offset buffer for split and transfer. The reason is that offsets\n+   * in the target vector have to be adjusted and made relative to the staring\n+   * offset in source vector from the start index of split. This is why, we\n+   * need to explicitly allocate the offset buffer and set the adjusted offsets\n+   * in the target vector.\n+   */\n+  private void splitAndTransferOffsetBuffer(int startIndex, int length, BaseNullableVariableWidthVector target) {\n+    final int start = offsetBuffer.getInt(startIndex * OFFSET_WIDTH);\n+    final int end = offsetBuffer.getInt((startIndex + length) * OFFSET_WIDTH);\n+    final int dataLength = end - start;\n+    target.allocateOffsetBuffer((length + 1) * OFFSET_WIDTH);\n+    for (int i = 0; i < length + 1; i++) {\n+      final int relativeSourceOffset = offsetBuffer.getInt((startIndex + i) * OFFSET_WIDTH) - start;\n+      target.offsetBuffer.setInt(i * OFFSET_WIDTH, relativeSourceOffset);\n+    }\n+    target.valueBuffer = valueBuffer.slice(start, dataLength).transferOwnership(target.allocator).buffer;\n+  }\n+\n+  /*\n+   * Transfer the validity.\n+   */\n+  private void splitAndTransferValidityBuffer(int startIndex, int length,\n+                                              BaseNullableVariableWidthVector target) {\n+    assert startIndex + length <= valueCount;\n+    int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+    int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+    int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+    int offset = startIndex % 8;\n+\n+    if (length > 0) {\n+      if (offset == 0) {\n+        // slice\n+        if (target.validityBuffer != null) {\n+          target.validityBuffer.release();\n+        }\n+        target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+        target.validityBuffer.retain(1);\n+      } else {\n+            /* Copy data\n+             * When the first bit starts from the middle of a byte (offset != 0),\n+             * copy data from src BitVector.\n+             * Each byte in the target is composed by a part in i-th byte,\n+             * another part in (i+1)-th byte.\n+             */\n+        target.allocateValidityBuffer(byteSizeTarget);\n+\n+        for (int i = 0; i < byteSizeTarget - 1; i++) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer, firstByteSource + i, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer, firstByteSource + i + 1, offset);\n+\n+          target.validityBuffer.setByte(i, (b1 + b2));\n+        }\n+\n+            /* Copying the last piece is done in the following manner:\n+             * if the source vector has 1 or more bytes remaining, we copy\n+             * the last piece as a byte formed by shifting data\n+             * from the current byte and the next byte.\n+             *\n+             * if the source vector has no more bytes remaining\n+             * (we are at the last byte), we copy the last piece as a byte\n+             * by shifting data from the current byte.\n+             */\n+        if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer,\n+                  firstByteSource + byteSizeTarget, offset);\n+\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+        } else {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+        }\n+      }\n+    }\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                common getters and setters                      *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the number of elements that are null in the vector\n+   *\n+   * @return the number of null elements.\n+   */\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  /**\n+   * Check if the given index is within the current value capacity\n+   * of the vector\n+   *\n+   * @param index  position to check\n+   * @return true if index is within the current value capacity\n+   */\n+  public boolean isSafe(int index) {\n+    return index < getValueCapacity();\n+  }\n+\n+  /**\n+   * Check if element at given index is null.\n+   *\n+   * @param index  position of element\n+   * @return true if element at given index is null\n+   */\n+  public boolean isNull(int index) {\n+    return (isSet(index) == 0);\n+  }\n+\n+  /**\n+   * Same as {@link #isNull(int)}.\n+   *\n+   * @param index  position of element\n+   * @return 1 if element at given index is not null, 0 otherwise\n+   */\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return Long.bitCount(b & (1L << bitIndex));\n+  }\n+\n+  /**\n+   * Get the value count of vector. This will always be zero unless\n+   * setValueCount(int) has been called prior to calling this.\n+   *\n+   * @return valueCount for the vector\n+   */\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n+\n+  /**\n+   * Sets the value count for the vector\n+   *\n+   * @param valueCount   value count\n+   */\n+  public void setValueCount(int valueCount) {\n+    assert valueCount >= 0;\n+    this.valueCount = valueCount;\n+    while (valueCount > getValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    fillHoles(valueCount);\n+    lastSet = valueCount - 1;\n+    setReaderAndWriterIndex();\n+  }\n+\n+  /**\n+   * Create holes in the vector upto the given index (exclusive).\n+   * Holes will be created from the current last set position in\n+   * the vector.\n+   *\n+   * @param index target index\n+   */\n+  public void fillEmpties(int index) {\n+    handleSafe(index, emptyByteArray.length);\n+    fillHoles(index);\n+    lastSet = index - 1;\n+  }\n+\n+  /**\n+   * Set the index of last non-null element in the vector.\n+   * It is important to call this method with appropriate value\n+   * before calling {@link #setValueCount(int)}.\n+   *\n+   * @param value desired index of last non-null element.\n+   */\n+  public void setLastSet(int value) {\n+    lastSet = value;\n+  }\n+\n+  /**\n+   * Get the index of last non-null element in the vector.\n+   *\n+   * @return index of the last non-null element\n+   */\n+  public int getLastSet() {\n+    return lastSet;\n+  }\n+\n+  /**\n+   * Get the starting position (offset) in the data stream for a given\n+   * element in the vector.\n+   *\n+   * @param index position of the element in the vector\n+   * @return starting offset for the element\n+   */\n+  public long getStartEnd(int index) {\n+    return offsetBuffer.getLong(index * OFFSET_WIDTH);\n+  }\n+\n+  /**\n+   * Mark the particular position in the vector as non-null.\n+   *\n+   * @param index position of the element.\n+   */\n+  @Override\n+  public void setIndexDefined(int index) {\n+    while (index >= getValidityBufferValueCapacity()) {\n+      validityBuffer = reallocBufferHelper(validityBuffer, false);\n+    }\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+  }\n+\n+  /**\n+   * Sets the value length for an element.\n+   *\n+   * @param index   position of the element to set\n+   * @param length  length of the element\n+   */\n+  public void setValueLengthSafe(int index, int length) {\n \n Review comment:\n   This function is not used. \r\n   \r\n   Also, I am not sure if we need an API for just setting value length. When would this be useful?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T19:28:22.795+0000",
                    "updated": "2017-11-15T19:28:22.795+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16254046",
                    "id": "16254046",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151232859\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/GenerateSampleData.java\n ##########\n @@ -0,0 +1,337 @@\n+/*******************************************************************************\n+\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ ******************************************************************************/\n+\n+package org.apache.arrow.vector;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.Charset;\n+\n+/**\n+ * Helper class to generate test data for Nullable fixed and variable\n+ * width scalar vectors. Previous implementations of java vector classes\n+ * provided generateTestData(now deprecated) API to populate the vector\n+ * with sample data. This class should be used for that purpose.\n+ */\n+public class GenerateSampleData {\n \n Review comment:\n   This is not something new. Vector classes have had the API generateTestData() from the beginning. As part of refactoring, we decided to move it out of the main API of vectors and provide a separate API for populating vectors with dummy data.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T19:47:28.027+0000",
                    "updated": "2017-11-15T19:47:28.027+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16254050",
                    "id": "16254050",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151233222\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/GenerateSampleData.java\n ##########\n @@ -0,0 +1,337 @@\n+/*******************************************************************************\n+\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ ******************************************************************************/\n+\n+package org.apache.arrow.vector;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.Charset;\n+\n+/**\n+ * Helper class to generate test data for Nullable fixed and variable\n+ * width scalar vectors. Previous implementations of java vector classes\n+ * provided generateTestData(now deprecated) API to populate the vector\n+ * with sample data. This class should be used for that purpose.\n+ */\n+public class GenerateSampleData {\n \n Review comment:\n   The old generateTestData() API in vectors is deprecated and the class description implies that any users of the former should now be using GenerateSampleData. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T19:48:48.386+0000",
                    "updated": "2017-11-15T19:48:48.386+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16254062",
                    "id": "16254062",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151234844\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/GenerateSampleData.java\n ##########\n @@ -0,0 +1,337 @@\n+/*******************************************************************************\n+\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ ******************************************************************************/\n+\n+package org.apache.arrow.vector;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.Charset;\n+\n+/**\n+ * Helper class to generate test data for Nullable fixed and variable\n+ * width scalar vectors. Previous implementations of java vector classes\n+ * provided generateTestData(now deprecated) API to populate the vector\n+ * with sample data. This class should be used for that purpose.\n+ */\n+public class GenerateSampleData {\n \n Review comment:\n   I see. It makes more sense now, thanks for the explanation. Let's keep it then.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T19:55:08.349+0000",
                    "updated": "2017-11-15T19:55:08.349+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16254063",
                    "id": "16254063",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151235010\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableFixedWidthVector.java\n ##########\n @@ -0,0 +1,848 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.schema.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * BaseNullableFixedWidthVector provides an abstract interface for\n+ * implementing vectors of fixed width values. The vectors are nullable\n+ * implying that zero or more elements in the vector could be NULL.\n+ */\n+public abstract class BaseNullableFixedWidthVector extends BaseValueVector\n+        implements FixedWidthVector, FieldVector, NullableVectorDefinitionSetter {\n+  private final byte typeWidth;\n+\n+  protected int valueAllocationSizeInBytes;\n+  protected int validityAllocationSizeInBytes;\n+\n+  protected final Field field;\n+  private int allocationMonitor;\n+  protected ArrowBuf validityBuffer;\n+  protected ArrowBuf valueBuffer;\n+  protected int valueCount;\n+\n+  public BaseNullableFixedWidthVector(final String name, final BufferAllocator allocator,\n+                                      FieldType fieldType, final byte typeWidth) {\n+    super(name, allocator);\n+    this.typeWidth = typeWidth;\n+    field = new Field(name, fieldType, null);\n+    valueCount = 0;\n+    allocationMonitor = 0;\n+    validityBuffer = allocator.getEmpty();\n+    valueBuffer = allocator.getEmpty();\n+    if (typeWidth > 0) {\n+      valueAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * typeWidth;\n+      validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    } else {\n+         /* specialized handling for NullableBitVector */\n+      valueAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+      validityAllocationSizeInBytes = valueAllocationSizeInBytes;\n+    }\n+  }\n+\n+\n+   /* TODO:\n+    *\n+    * see if getNullCount() can be made faster -- O(1)\n+    */\n+\n+   /* TODO:\n+    * Once the entire hierarchy has been refactored, move common functions\n+    * like getNullCount(), splitAndTransferValidityBuffer to top level\n+    * base class BaseValueVector.\n+    *\n+    * Along with this, some class members (validityBuffer) can also be\n+    * abstracted out to top level base class.\n+    *\n+    * Right now BaseValueVector is the top level base class for other\n+    * vector types in ValueVector hierarchy (non-nullable) and those\n+    * vectors have not yet been refactored/removed so moving things to\n+    * the top class as of now is not a good idea.\n+    */\n+\n+\n+  @Override\n+  @Deprecated\n+  public Mutator getMutator() {\n+    throw new UnsupportedOperationException(\"Mutator is not supported for writing to vector\");\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public Accessor getAccessor() {\n+    throw new UnsupportedOperationException(\"Accessor is not supported for reading from vector\");\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that manages the validity\n+   * (NULL or NON-NULL nature) of elements in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return (validityBuffer.memoryAddress());\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the data for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getDataBufferAddress() {\n+    return (valueBuffer.memoryAddress());\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the offsets for elements\n+   * in the vector. This operation is not supported for fixed-width vectors.\n+   * @return starting address of the buffer\n+   * @throws UnsupportedOperationException for fixed width vectors\n+   */\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    throw new UnsupportedOperationException(\"not supported for fixed-width vectors\");\n+  }\n+\n+  /**\n+   * Get buffer that manages the validity (NULL or NON-NULL nature) of\n+   * elements in the vector. Consider it as a buffer for internal bit vector\n+   * data structure.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  /**\n+   * Get the buffer that stores the data for elements in the vector.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    return valueBuffer;\n+  }\n+\n+  /**\n+   * buffer that stores the offsets for elements\n+   * in the vector. This operation is not supported for fixed-width vectors.\n+   * @return buffer\n+   * @throws UnsupportedOperationException for fixed width vectors\n+   */\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    throw new UnsupportedOperationException(\"not supported for fixed-width vectors\");\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   * @param valueCount desired number of elements in the vector\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount) {\n+    final long size = (long) valueCount * typeWidth;\n+    if (size > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+    valueAllocationSizeInBytes = (int) size;\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(valueCount);\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    return Math.min(getValueBufferValueCapacity(), getValidityBufferValueCapacity());\n+  }\n+\n+  private int getValueBufferValueCapacity() {\n+    return (int) ((valueBuffer.capacity() * 1.0) / typeWidth);\n+  }\n+\n+  private int getValidityBufferValueCapacity() {\n+    return (int) (validityBuffer.capacity() * 8L);\n+  }\n+\n+  /**\n+   * zero out the vector and the data in associated buffers.\n+   */\n+  @Override\n+  public void zeroVector() {\n+    initValidityBuffer();\n+    initValueBuffer();\n+  }\n+\n+  /* zero out the validity buffer */\n+  private void initValidityBuffer() {\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+\n+  /* zero out the data buffer */\n+  private void initValueBuffer() {\n+    valueBuffer.setZero(0, valueBuffer.capacity());\n+  }\n+\n+  /**\n+   * Reset the vector to initial state. Same as {@link #zeroVector()}.\n+   * Note that this method doesn't release any memory.\n+   */\n+  public void reset() {\n+    zeroVector();\n+  }\n+\n+  /**\n+   * Close the vector and release the associated buffers.\n+   */\n+  @Override\n+  public void close() {\n+    clear();\n+  }\n+\n+  /**\n+   * Same as {@link #close()}\n+   */\n+  @Override\n+  public void clear() {\n+    valueCount = 0;\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    valueBuffer = releaseBuffer(valueBuffer);\n+  }\n+\n+  /* used to step down the memory allocation */\n+  protected void incrementAllocationMonitor() {\n+    if (allocationMonitor < 0) {\n+      allocationMonitor = 0;\n+    }\n+    allocationMonitor++;\n+  }\n+\n+  /* used to step up the memory allocation */\n+  protected void decrementAllocationMonitor() {\n+    if (allocationMonitor > 0) {\n+      allocationMonitor = 0;\n+    }\n+    allocationMonitor--;\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory.\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector. See {@link #allocateNew(int)} for allocating memory for specific\n+   * number of elements in the vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  @Override\n+  public boolean allocateNewSafe() {\n+    long curAllocationSizeValue = valueAllocationSizeInBytes;\n+    long curAllocationSizeValidity = validityAllocationSizeInBytes;\n+\n+    if (curAllocationSizeValue > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory exceeds limit\");\n+    }\n+\n+      /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(curAllocationSizeValue, curAllocationSizeValidity);\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Allocate memory for the vector to support storing at least the provided number of\n+   * elements in the vector. This method must be called prior to using the ValueVector.\n+   *\n+   * @param valueCount the desired number of elements in the vector\n+   * @throws org.apache.arrow.memory.OutOfMemoryException\n+   */\n+  public void allocateNew(int valueCount) {\n+    long valueBufferSize = valueCount * typeWidth;\n+    long validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    if (typeWidth == 0) {\n+         /* specialized handling for NullableBitVector */\n+      valueBufferSize = validityBufferSize;\n+    }\n+\n+    if (valueBufferSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+\n+      /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(valueBufferSize, validityBufferSize);\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Actual memory allocation is done by this function. All the calculations\n+   * and knowledge about what size to allocate is upto the callers of this\n+   * method.\n+   * Callers appropriately handle errors if memory allocation fails here.\n+   * Callers should also take care of determining that desired size is\n+   * within the bounds of max allocation allowed and any other error\n+   * conditions.\n+   */\n+  private void allocateBytes(final long valueBufferSize, final long validityBufferSize) {\n+      /* allocate data buffer */\n+    int curSize = (int) valueBufferSize;\n+    valueBuffer = allocator.buffer(curSize);\n+    valueBuffer.readerIndex(0);\n+    valueAllocationSizeInBytes = curSize;\n+      /* allocate validity buffer */\n+    allocateValidityBuffer((int) validityBufferSize);\n+    zeroVector();\n+  }\n+\n+  /**\n+   * During splitAndTransfer, if we splitting from a random position within a byte,\n+   * we can't just slice the source buffer so we have to explicitly allocate the\n+   * validityBuffer of the target vector. This is unlike the databuffer which we can\n+   * always slice for the target vector.\n+   */\n+  private void allocateValidityBuffer(final int validityBufferSize) {\n+    validityBuffer = allocator.buffer(validityBufferSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = validityBufferSize;\n+  }\n+\n+  /**\n+   * Get the potential buffer size for a particular number of records.\n+   * @param count desired number of elements in the vector\n+   * @return estimated size of underlying buffers if the vector holds\n+   *         a given number of elements\n+   */\n+  @Override\n+  public int getBufferSizeFor(final int count) {\n+    if (count == 0) {\n+      return 0;\n+    }\n+    return (count * typeWidth) + getValidityBufferSizeFromCount(count);\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    return (valueCount * typeWidth) + getValidityBufferSizeFromCount(valueCount);\n+  }\n+\n+  /**\n+   * Get information about how this field is materialized.\n+   * @return the field corresponding to this vector\n+   */\n+  @Override\n+  public Field getField() {\n+    return field;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n \n Review comment:\n   AFAIK, getBuffers() is an old method for getting a batch of buffers for serialization. We use it for maintaining compatibility with Drill client. I think in future, we should consider removing it from Arrow and writing a wrapper over it in Dremio. This way we will just have getFieldBuffers.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T19:55:46.169+0000",
                    "updated": "2017-11-15T19:55:46.169+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16254071",
                    "id": "16254071",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344710833\n \n \n   @wesm , let me know if I need to squash the latest 7 commits for this JIRA or you can take care of it while merging. I think we would be merging 4 commits into master:\r\n   \r\n   ARROW-1473\r\n   ARROW-1474\r\n   ARROW-1717\r\n   ARROW-1476 (squashed latest commits)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T20:00:02.739+0000",
                    "updated": "2017-11-15T20:00:02.739+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16254102",
                    "id": "16254102",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151241423\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableFixedWidthVector.java\n ##########\n @@ -0,0 +1,848 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.schema.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * BaseNullableFixedWidthVector provides an abstract interface for\n+ * implementing vectors of fixed width values. The vectors are nullable\n+ * implying that zero or more elements in the vector could be NULL.\n+ */\n+public abstract class BaseNullableFixedWidthVector extends BaseValueVector\n+        implements FixedWidthVector, FieldVector, NullableVectorDefinitionSetter {\n+  private final byte typeWidth;\n+\n+  protected int valueAllocationSizeInBytes;\n+  protected int validityAllocationSizeInBytes;\n+\n+  protected final Field field;\n+  private int allocationMonitor;\n+  protected ArrowBuf validityBuffer;\n+  protected ArrowBuf valueBuffer;\n+  protected int valueCount;\n+\n+  public BaseNullableFixedWidthVector(final String name, final BufferAllocator allocator,\n+                                      FieldType fieldType, final byte typeWidth) {\n+    super(name, allocator);\n+    this.typeWidth = typeWidth;\n+    field = new Field(name, fieldType, null);\n+    valueCount = 0;\n+    allocationMonitor = 0;\n+    validityBuffer = allocator.getEmpty();\n+    valueBuffer = allocator.getEmpty();\n+    if (typeWidth > 0) {\n+      valueAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * typeWidth;\n+      validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    } else {\n+         /* specialized handling for NullableBitVector */\n+      valueAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+      validityAllocationSizeInBytes = valueAllocationSizeInBytes;\n+    }\n+  }\n+\n+\n+   /* TODO:\n+    *\n+    * see if getNullCount() can be made faster -- O(1)\n+    */\n+\n+   /* TODO:\n+    * Once the entire hierarchy has been refactored, move common functions\n+    * like getNullCount(), splitAndTransferValidityBuffer to top level\n+    * base class BaseValueVector.\n+    *\n+    * Along with this, some class members (validityBuffer) can also be\n+    * abstracted out to top level base class.\n+    *\n+    * Right now BaseValueVector is the top level base class for other\n+    * vector types in ValueVector hierarchy (non-nullable) and those\n+    * vectors have not yet been refactored/removed so moving things to\n+    * the top class as of now is not a good idea.\n+    */\n+\n+\n+  @Override\n+  @Deprecated\n+  public Mutator getMutator() {\n+    throw new UnsupportedOperationException(\"Mutator is not supported for writing to vector\");\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public Accessor getAccessor() {\n+    throw new UnsupportedOperationException(\"Accessor is not supported for reading from vector\");\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that manages the validity\n+   * (NULL or NON-NULL nature) of elements in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return (validityBuffer.memoryAddress());\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the data for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getDataBufferAddress() {\n+    return (valueBuffer.memoryAddress());\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the offsets for elements\n+   * in the vector. This operation is not supported for fixed-width vectors.\n+   * @return starting address of the buffer\n+   * @throws UnsupportedOperationException for fixed width vectors\n+   */\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    throw new UnsupportedOperationException(\"not supported for fixed-width vectors\");\n+  }\n+\n+  /**\n+   * Get buffer that manages the validity (NULL or NON-NULL nature) of\n+   * elements in the vector. Consider it as a buffer for internal bit vector\n+   * data structure.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  /**\n+   * Get the buffer that stores the data for elements in the vector.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    return valueBuffer;\n+  }\n+\n+  /**\n+   * buffer that stores the offsets for elements\n+   * in the vector. This operation is not supported for fixed-width vectors.\n+   * @return buffer\n+   * @throws UnsupportedOperationException for fixed width vectors\n+   */\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    throw new UnsupportedOperationException(\"not supported for fixed-width vectors\");\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   * @param valueCount desired number of elements in the vector\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount) {\n+    final long size = (long) valueCount * typeWidth;\n+    if (size > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+    valueAllocationSizeInBytes = (int) size;\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(valueCount);\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    return Math.min(getValueBufferValueCapacity(), getValidityBufferValueCapacity());\n+  }\n+\n+  private int getValueBufferValueCapacity() {\n+    return (int) ((valueBuffer.capacity() * 1.0) / typeWidth);\n+  }\n+\n+  private int getValidityBufferValueCapacity() {\n+    return (int) (validityBuffer.capacity() * 8L);\n+  }\n+\n+  /**\n+   * zero out the vector and the data in associated buffers.\n+   */\n+  @Override\n+  public void zeroVector() {\n+    initValidityBuffer();\n+    initValueBuffer();\n+  }\n+\n+  /* zero out the validity buffer */\n+  private void initValidityBuffer() {\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+\n+  /* zero out the data buffer */\n+  private void initValueBuffer() {\n+    valueBuffer.setZero(0, valueBuffer.capacity());\n+  }\n+\n+  /**\n+   * Reset the vector to initial state. Same as {@link #zeroVector()}.\n+   * Note that this method doesn't release any memory.\n+   */\n+  public void reset() {\n+    zeroVector();\n+  }\n+\n+  /**\n+   * Close the vector and release the associated buffers.\n+   */\n+  @Override\n+  public void close() {\n+    clear();\n+  }\n+\n+  /**\n+   * Same as {@link #close()}\n+   */\n+  @Override\n+  public void clear() {\n+    valueCount = 0;\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    valueBuffer = releaseBuffer(valueBuffer);\n+  }\n+\n+  /* used to step down the memory allocation */\n+  protected void incrementAllocationMonitor() {\n+    if (allocationMonitor < 0) {\n+      allocationMonitor = 0;\n+    }\n+    allocationMonitor++;\n+  }\n+\n+  /* used to step up the memory allocation */\n+  protected void decrementAllocationMonitor() {\n+    if (allocationMonitor > 0) {\n+      allocationMonitor = 0;\n+    }\n+    allocationMonitor--;\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory.\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector. See {@link #allocateNew(int)} for allocating memory for specific\n+   * number of elements in the vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  @Override\n+  public boolean allocateNewSafe() {\n+    long curAllocationSizeValue = valueAllocationSizeInBytes;\n+    long curAllocationSizeValidity = validityAllocationSizeInBytes;\n+\n+    if (curAllocationSizeValue > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory exceeds limit\");\n+    }\n+\n+      /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(curAllocationSizeValue, curAllocationSizeValidity);\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Allocate memory for the vector to support storing at least the provided number of\n+   * elements in the vector. This method must be called prior to using the ValueVector.\n+   *\n+   * @param valueCount the desired number of elements in the vector\n+   * @throws org.apache.arrow.memory.OutOfMemoryException\n+   */\n+  public void allocateNew(int valueCount) {\n+    long valueBufferSize = valueCount * typeWidth;\n+    long validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    if (typeWidth == 0) {\n+         /* specialized handling for NullableBitVector */\n+      valueBufferSize = validityBufferSize;\n+    }\n+\n+    if (valueBufferSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+\n+      /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(valueBufferSize, validityBufferSize);\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Actual memory allocation is done by this function. All the calculations\n+   * and knowledge about what size to allocate is upto the callers of this\n+   * method.\n+   * Callers appropriately handle errors if memory allocation fails here.\n+   * Callers should also take care of determining that desired size is\n+   * within the bounds of max allocation allowed and any other error\n+   * conditions.\n+   */\n+  private void allocateBytes(final long valueBufferSize, final long validityBufferSize) {\n+      /* allocate data buffer */\n+    int curSize = (int) valueBufferSize;\n+    valueBuffer = allocator.buffer(curSize);\n+    valueBuffer.readerIndex(0);\n+    valueAllocationSizeInBytes = curSize;\n+      /* allocate validity buffer */\n+    allocateValidityBuffer((int) validityBufferSize);\n+    zeroVector();\n+  }\n+\n+  /**\n+   * During splitAndTransfer, if we splitting from a random position within a byte,\n+   * we can't just slice the source buffer so we have to explicitly allocate the\n+   * validityBuffer of the target vector. This is unlike the databuffer which we can\n+   * always slice for the target vector.\n+   */\n+  private void allocateValidityBuffer(final int validityBufferSize) {\n+    validityBuffer = allocator.buffer(validityBufferSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = validityBufferSize;\n+  }\n+\n+  /**\n+   * Get the potential buffer size for a particular number of records.\n+   * @param count desired number of elements in the vector\n+   * @return estimated size of underlying buffers if the vector holds\n+   *         a given number of elements\n+   */\n+  @Override\n+  public int getBufferSizeFor(final int count) {\n+    if (count == 0) {\n+      return 0;\n+    }\n+    return (count * typeWidth) + getValidityBufferSizeFromCount(count);\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    return (valueCount * typeWidth) + getValidityBufferSizeFromCount(valueCount);\n+  }\n+\n+  /**\n+   * Get information about how this field is materialized.\n+   * @return the field corresponding to this vector\n+   */\n+  @Override\n+  public Field getField() {\n+    return field;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n \n Review comment:\n   I see. Does it make sense to mark getBuffers() as deprecated so it's less confusing for the other users?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T20:22:14.876+0000",
                    "updated": "2017-11-15T20:22:14.876+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16254120",
                    "id": "16254120",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151243286\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableFixedWidthVector.java\n ##########\n @@ -0,0 +1,848 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.schema.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * BaseNullableFixedWidthVector provides an abstract interface for\n+ * implementing vectors of fixed width values. The vectors are nullable\n+ * implying that zero or more elements in the vector could be NULL.\n+ */\n+public abstract class BaseNullableFixedWidthVector extends BaseValueVector\n+        implements FixedWidthVector, FieldVector, NullableVectorDefinitionSetter {\n+  private final byte typeWidth;\n+\n+  protected int valueAllocationSizeInBytes;\n+  protected int validityAllocationSizeInBytes;\n+\n+  protected final Field field;\n+  private int allocationMonitor;\n+  protected ArrowBuf validityBuffer;\n+  protected ArrowBuf valueBuffer;\n+  protected int valueCount;\n+\n+  public BaseNullableFixedWidthVector(final String name, final BufferAllocator allocator,\n+                                      FieldType fieldType, final byte typeWidth) {\n+    super(name, allocator);\n+    this.typeWidth = typeWidth;\n+    field = new Field(name, fieldType, null);\n+    valueCount = 0;\n+    allocationMonitor = 0;\n+    validityBuffer = allocator.getEmpty();\n+    valueBuffer = allocator.getEmpty();\n+    if (typeWidth > 0) {\n+      valueAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * typeWidth;\n+      validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    } else {\n+         /* specialized handling for NullableBitVector */\n+      valueAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+      validityAllocationSizeInBytes = valueAllocationSizeInBytes;\n+    }\n+  }\n+\n+\n+   /* TODO:\n+    *\n+    * see if getNullCount() can be made faster -- O(1)\n+    */\n+\n+   /* TODO:\n+    * Once the entire hierarchy has been refactored, move common functions\n+    * like getNullCount(), splitAndTransferValidityBuffer to top level\n+    * base class BaseValueVector.\n+    *\n+    * Along with this, some class members (validityBuffer) can also be\n+    * abstracted out to top level base class.\n+    *\n+    * Right now BaseValueVector is the top level base class for other\n+    * vector types in ValueVector hierarchy (non-nullable) and those\n+    * vectors have not yet been refactored/removed so moving things to\n+    * the top class as of now is not a good idea.\n+    */\n+\n+\n+  @Override\n+  @Deprecated\n+  public Mutator getMutator() {\n+    throw new UnsupportedOperationException(\"Mutator is not supported for writing to vector\");\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public Accessor getAccessor() {\n+    throw new UnsupportedOperationException(\"Accessor is not supported for reading from vector\");\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that manages the validity\n+   * (NULL or NON-NULL nature) of elements in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return (validityBuffer.memoryAddress());\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the data for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getDataBufferAddress() {\n+    return (valueBuffer.memoryAddress());\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the offsets for elements\n+   * in the vector. This operation is not supported for fixed-width vectors.\n+   * @return starting address of the buffer\n+   * @throws UnsupportedOperationException for fixed width vectors\n+   */\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    throw new UnsupportedOperationException(\"not supported for fixed-width vectors\");\n+  }\n+\n+  /**\n+   * Get buffer that manages the validity (NULL or NON-NULL nature) of\n+   * elements in the vector. Consider it as a buffer for internal bit vector\n+   * data structure.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  /**\n+   * Get the buffer that stores the data for elements in the vector.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    return valueBuffer;\n+  }\n+\n+  /**\n+   * buffer that stores the offsets for elements\n+   * in the vector. This operation is not supported for fixed-width vectors.\n+   * @return buffer\n+   * @throws UnsupportedOperationException for fixed width vectors\n+   */\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    throw new UnsupportedOperationException(\"not supported for fixed-width vectors\");\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   * @param valueCount desired number of elements in the vector\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount) {\n+    final long size = (long) valueCount * typeWidth;\n+    if (size > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+    valueAllocationSizeInBytes = (int) size;\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(valueCount);\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    return Math.min(getValueBufferValueCapacity(), getValidityBufferValueCapacity());\n+  }\n+\n+  private int getValueBufferValueCapacity() {\n+    return (int) ((valueBuffer.capacity() * 1.0) / typeWidth);\n+  }\n+\n+  private int getValidityBufferValueCapacity() {\n+    return (int) (validityBuffer.capacity() * 8L);\n+  }\n+\n+  /**\n+   * zero out the vector and the data in associated buffers.\n+   */\n+  @Override\n+  public void zeroVector() {\n+    initValidityBuffer();\n+    initValueBuffer();\n+  }\n+\n+  /* zero out the validity buffer */\n+  private void initValidityBuffer() {\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+\n+  /* zero out the data buffer */\n+  private void initValueBuffer() {\n+    valueBuffer.setZero(0, valueBuffer.capacity());\n+  }\n+\n+  /**\n+   * Reset the vector to initial state. Same as {@link #zeroVector()}.\n+   * Note that this method doesn't release any memory.\n+   */\n+  public void reset() {\n+    zeroVector();\n+  }\n+\n+  /**\n+   * Close the vector and release the associated buffers.\n+   */\n+  @Override\n+  public void close() {\n+    clear();\n+  }\n+\n+  /**\n+   * Same as {@link #close()}\n+   */\n+  @Override\n+  public void clear() {\n+    valueCount = 0;\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    valueBuffer = releaseBuffer(valueBuffer);\n+  }\n+\n+  /* used to step down the memory allocation */\n+  protected void incrementAllocationMonitor() {\n+    if (allocationMonitor < 0) {\n+      allocationMonitor = 0;\n+    }\n+    allocationMonitor++;\n+  }\n+\n+  /* used to step up the memory allocation */\n+  protected void decrementAllocationMonitor() {\n+    if (allocationMonitor > 0) {\n+      allocationMonitor = 0;\n+    }\n+    allocationMonitor--;\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory.\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector. See {@link #allocateNew(int)} for allocating memory for specific\n+   * number of elements in the vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  @Override\n+  public boolean allocateNewSafe() {\n+    long curAllocationSizeValue = valueAllocationSizeInBytes;\n+    long curAllocationSizeValidity = validityAllocationSizeInBytes;\n+\n+    if (curAllocationSizeValue > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory exceeds limit\");\n+    }\n+\n+      /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(curAllocationSizeValue, curAllocationSizeValidity);\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Allocate memory for the vector to support storing at least the provided number of\n+   * elements in the vector. This method must be called prior to using the ValueVector.\n+   *\n+   * @param valueCount the desired number of elements in the vector\n+   * @throws org.apache.arrow.memory.OutOfMemoryException\n+   */\n+  public void allocateNew(int valueCount) {\n+    long valueBufferSize = valueCount * typeWidth;\n+    long validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    if (typeWidth == 0) {\n+         /* specialized handling for NullableBitVector */\n+      valueBufferSize = validityBufferSize;\n+    }\n+\n+    if (valueBufferSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+\n+      /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(valueBufferSize, validityBufferSize);\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Actual memory allocation is done by this function. All the calculations\n+   * and knowledge about what size to allocate is upto the callers of this\n+   * method.\n+   * Callers appropriately handle errors if memory allocation fails here.\n+   * Callers should also take care of determining that desired size is\n+   * within the bounds of max allocation allowed and any other error\n+   * conditions.\n+   */\n+  private void allocateBytes(final long valueBufferSize, final long validityBufferSize) {\n+      /* allocate data buffer */\n+    int curSize = (int) valueBufferSize;\n+    valueBuffer = allocator.buffer(curSize);\n+    valueBuffer.readerIndex(0);\n+    valueAllocationSizeInBytes = curSize;\n+      /* allocate validity buffer */\n+    allocateValidityBuffer((int) validityBufferSize);\n+    zeroVector();\n+  }\n+\n+  /**\n+   * During splitAndTransfer, if we splitting from a random position within a byte,\n+   * we can't just slice the source buffer so we have to explicitly allocate the\n+   * validityBuffer of the target vector. This is unlike the databuffer which we can\n+   * always slice for the target vector.\n+   */\n+  private void allocateValidityBuffer(final int validityBufferSize) {\n+    validityBuffer = allocator.buffer(validityBufferSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = validityBufferSize;\n+  }\n+\n+  /**\n+   * Get the potential buffer size for a particular number of records.\n+   * @param count desired number of elements in the vector\n+   * @return estimated size of underlying buffers if the vector holds\n+   *         a given number of elements\n+   */\n+  @Override\n+  public int getBufferSizeFor(final int count) {\n+    if (count == 0) {\n+      return 0;\n+    }\n+    return (count * typeWidth) + getValidityBufferSizeFromCount(count);\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    return (valueCount * typeWidth) + getValidityBufferSizeFromCount(valueCount);\n+  }\n+\n+  /**\n+   * Get information about how this field is materialized.\n+   * @return the field corresponding to this vector\n+   */\n+  @Override\n+  public Field getField() {\n+    return field;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n \n Review comment:\n   Let's not worry about it right now. These two APIs have not been introduced as part of refactoring and have been in Arrow code for quite some time. \r\n   \r\n   I will file a JIRA and we can brainstorm w.r.t appropriate steps to address the ambiguity (if any)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T20:30:50.268+0000",
                    "updated": "2017-11-15T20:30:50.268+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16254122",
                    "id": "16254122",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344719171\n \n \n   Build passed.\r\n   I think we are all set for merge.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T20:31:43.522+0000",
                    "updated": "2017-11-15T20:31:43.522+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16254126",
                    "id": "16254126",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151243900\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableFixedWidthVector.java\n ##########\n @@ -0,0 +1,848 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.schema.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * BaseNullableFixedWidthVector provides an abstract interface for\n+ * implementing vectors of fixed width values. The vectors are nullable\n+ * implying that zero or more elements in the vector could be NULL.\n+ */\n+public abstract class BaseNullableFixedWidthVector extends BaseValueVector\n+        implements FixedWidthVector, FieldVector, NullableVectorDefinitionSetter {\n+  private final byte typeWidth;\n+\n+  protected int valueAllocationSizeInBytes;\n+  protected int validityAllocationSizeInBytes;\n+\n+  protected final Field field;\n+  private int allocationMonitor;\n+  protected ArrowBuf validityBuffer;\n+  protected ArrowBuf valueBuffer;\n+  protected int valueCount;\n+\n+  public BaseNullableFixedWidthVector(final String name, final BufferAllocator allocator,\n+                                      FieldType fieldType, final byte typeWidth) {\n+    super(name, allocator);\n+    this.typeWidth = typeWidth;\n+    field = new Field(name, fieldType, null);\n+    valueCount = 0;\n+    allocationMonitor = 0;\n+    validityBuffer = allocator.getEmpty();\n+    valueBuffer = allocator.getEmpty();\n+    if (typeWidth > 0) {\n+      valueAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * typeWidth;\n+      validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    } else {\n+         /* specialized handling for NullableBitVector */\n+      valueAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+      validityAllocationSizeInBytes = valueAllocationSizeInBytes;\n+    }\n+  }\n+\n+\n+   /* TODO:\n+    *\n+    * see if getNullCount() can be made faster -- O(1)\n+    */\n+\n+   /* TODO:\n+    * Once the entire hierarchy has been refactored, move common functions\n+    * like getNullCount(), splitAndTransferValidityBuffer to top level\n+    * base class BaseValueVector.\n+    *\n+    * Along with this, some class members (validityBuffer) can also be\n+    * abstracted out to top level base class.\n+    *\n+    * Right now BaseValueVector is the top level base class for other\n+    * vector types in ValueVector hierarchy (non-nullable) and those\n+    * vectors have not yet been refactored/removed so moving things to\n+    * the top class as of now is not a good idea.\n+    */\n+\n+\n+  @Override\n+  @Deprecated\n+  public Mutator getMutator() {\n+    throw new UnsupportedOperationException(\"Mutator is not supported for writing to vector\");\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public Accessor getAccessor() {\n+    throw new UnsupportedOperationException(\"Accessor is not supported for reading from vector\");\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that manages the validity\n+   * (NULL or NON-NULL nature) of elements in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return (validityBuffer.memoryAddress());\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the data for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getDataBufferAddress() {\n+    return (valueBuffer.memoryAddress());\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the offsets for elements\n+   * in the vector. This operation is not supported for fixed-width vectors.\n+   * @return starting address of the buffer\n+   * @throws UnsupportedOperationException for fixed width vectors\n+   */\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    throw new UnsupportedOperationException(\"not supported for fixed-width vectors\");\n+  }\n+\n+  /**\n+   * Get buffer that manages the validity (NULL or NON-NULL nature) of\n+   * elements in the vector. Consider it as a buffer for internal bit vector\n+   * data structure.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  /**\n+   * Get the buffer that stores the data for elements in the vector.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    return valueBuffer;\n+  }\n+\n+  /**\n+   * buffer that stores the offsets for elements\n+   * in the vector. This operation is not supported for fixed-width vectors.\n+   * @return buffer\n+   * @throws UnsupportedOperationException for fixed width vectors\n+   */\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    throw new UnsupportedOperationException(\"not supported for fixed-width vectors\");\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   * @param valueCount desired number of elements in the vector\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount) {\n+    final long size = (long) valueCount * typeWidth;\n+    if (size > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+    valueAllocationSizeInBytes = (int) size;\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(valueCount);\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    return Math.min(getValueBufferValueCapacity(), getValidityBufferValueCapacity());\n+  }\n+\n+  private int getValueBufferValueCapacity() {\n+    return (int) ((valueBuffer.capacity() * 1.0) / typeWidth);\n+  }\n+\n+  private int getValidityBufferValueCapacity() {\n+    return (int) (validityBuffer.capacity() * 8L);\n+  }\n+\n+  /**\n+   * zero out the vector and the data in associated buffers.\n+   */\n+  @Override\n+  public void zeroVector() {\n+    initValidityBuffer();\n+    initValueBuffer();\n+  }\n+\n+  /* zero out the validity buffer */\n+  private void initValidityBuffer() {\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+\n+  /* zero out the data buffer */\n+  private void initValueBuffer() {\n+    valueBuffer.setZero(0, valueBuffer.capacity());\n+  }\n+\n+  /**\n+   * Reset the vector to initial state. Same as {@link #zeroVector()}.\n+   * Note that this method doesn't release any memory.\n+   */\n+  public void reset() {\n+    zeroVector();\n+  }\n+\n+  /**\n+   * Close the vector and release the associated buffers.\n+   */\n+  @Override\n+  public void close() {\n+    clear();\n+  }\n+\n+  /**\n+   * Same as {@link #close()}\n+   */\n+  @Override\n+  public void clear() {\n+    valueCount = 0;\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    valueBuffer = releaseBuffer(valueBuffer);\n+  }\n+\n+  /* used to step down the memory allocation */\n+  protected void incrementAllocationMonitor() {\n+    if (allocationMonitor < 0) {\n+      allocationMonitor = 0;\n+    }\n+    allocationMonitor++;\n+  }\n+\n+  /* used to step up the memory allocation */\n+  protected void decrementAllocationMonitor() {\n+    if (allocationMonitor > 0) {\n+      allocationMonitor = 0;\n+    }\n+    allocationMonitor--;\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory.\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector. See {@link #allocateNew(int)} for allocating memory for specific\n+   * number of elements in the vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  @Override\n+  public boolean allocateNewSafe() {\n+    long curAllocationSizeValue = valueAllocationSizeInBytes;\n+    long curAllocationSizeValidity = validityAllocationSizeInBytes;\n+\n+    if (curAllocationSizeValue > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory exceeds limit\");\n+    }\n+\n+      /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(curAllocationSizeValue, curAllocationSizeValidity);\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Allocate memory for the vector to support storing at least the provided number of\n+   * elements in the vector. This method must be called prior to using the ValueVector.\n+   *\n+   * @param valueCount the desired number of elements in the vector\n+   * @throws org.apache.arrow.memory.OutOfMemoryException\n+   */\n+  public void allocateNew(int valueCount) {\n+    long valueBufferSize = valueCount * typeWidth;\n+    long validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    if (typeWidth == 0) {\n+         /* specialized handling for NullableBitVector */\n+      valueBufferSize = validityBufferSize;\n+    }\n+\n+    if (valueBufferSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+\n+      /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(valueBufferSize, validityBufferSize);\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Actual memory allocation is done by this function. All the calculations\n+   * and knowledge about what size to allocate is upto the callers of this\n+   * method.\n+   * Callers appropriately handle errors if memory allocation fails here.\n+   * Callers should also take care of determining that desired size is\n+   * within the bounds of max allocation allowed and any other error\n+   * conditions.\n+   */\n+  private void allocateBytes(final long valueBufferSize, final long validityBufferSize) {\n+      /* allocate data buffer */\n+    int curSize = (int) valueBufferSize;\n+    valueBuffer = allocator.buffer(curSize);\n+    valueBuffer.readerIndex(0);\n+    valueAllocationSizeInBytes = curSize;\n+      /* allocate validity buffer */\n+    allocateValidityBuffer((int) validityBufferSize);\n+    zeroVector();\n+  }\n+\n+  /**\n+   * During splitAndTransfer, if we splitting from a random position within a byte,\n+   * we can't just slice the source buffer so we have to explicitly allocate the\n+   * validityBuffer of the target vector. This is unlike the databuffer which we can\n+   * always slice for the target vector.\n+   */\n+  private void allocateValidityBuffer(final int validityBufferSize) {\n+    validityBuffer = allocator.buffer(validityBufferSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = validityBufferSize;\n+  }\n+\n+  /**\n+   * Get the potential buffer size for a particular number of records.\n+   * @param count desired number of elements in the vector\n+   * @return estimated size of underlying buffers if the vector holds\n+   *         a given number of elements\n+   */\n+  @Override\n+  public int getBufferSizeFor(final int count) {\n+    if (count == 0) {\n+      return 0;\n+    }\n+    return (count * typeWidth) + getValidityBufferSizeFromCount(count);\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    return (valueCount * typeWidth) + getValidityBufferSizeFromCount(valueCount);\n+  }\n+\n+  /**\n+   * Get information about how this field is materialized.\n+   * @return the field corresponding to this vector\n+   */\n+  @Override\n+  public Field getField() {\n+    return field;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n \n Review comment:\n   Ok. Sounds good.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T20:33:38.247+0000",
                    "updated": "2017-11-15T20:33:38.247+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16254128",
                    "id": "16254128",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151243945\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\n ##########\n @@ -0,0 +1,1250 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.NullableMapVector;\n+import org.apache.arrow.vector.schema.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public abstract class BaseNullableVariableWidthVector extends BaseValueVector\n+        implements VariableWidthVector, FieldVector, NullableVectorDefinitionSetter {\n+  private static final int DEFAULT_RECORD_BYTE_COUNT = 8;\n+  private static final int INITIAL_BYTE_COUNT = INITIAL_VALUE_ALLOCATION * DEFAULT_RECORD_BYTE_COUNT;\n+\n+  private int valueAllocationSizeInBytes;\n+  private int validityAllocationSizeInBytes;\n+  private int offsetAllocationSizeInBytes;\n+\n+  /* protected members */\n+  public static final int OFFSET_WIDTH = 4; /* 4 byte unsigned int to track offsets */\n+  protected static final byte[] emptyByteArray = new byte[]{};\n+  protected ArrowBuf validityBuffer;\n+  protected ArrowBuf valueBuffer;\n+  protected ArrowBuf offsetBuffer;\n+  protected int valueCount;\n+  protected int lastSet;\n+  protected final Field field;\n+  private boolean cleared;\n+\n+  public BaseNullableVariableWidthVector(final String name, final BufferAllocator allocator,\n+                                         FieldType fieldType) {\n+    super(name, allocator);\n+    valueAllocationSizeInBytes = INITIAL_BYTE_COUNT;\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    offsetAllocationSizeInBytes = (INITIAL_VALUE_ALLOCATION) * OFFSET_WIDTH;\n+    field = new Field(name, fieldType, null);\n+    valueCount = 0;\n+    lastSet = -1;\n+    offsetBuffer = allocator.getEmpty();\n+    validityBuffer = allocator.getEmpty();\n+    valueBuffer = allocator.getEmpty();\n+    cleared = false;\n+  }\n+\n+   /* TODO:\n+    *\n+    * see if getNullCount() can be made faster -- O(1)\n+    */\n+\n+  /* TODO:\n+    * Once the entire hierarchy has been refactored, move common functions\n+    * like getNullCount(), splitAndTransferValidityBuffer to top level\n+    * base class BaseValueVector.\n+    *\n+    * Along with this, some class members (validityBuffer) can also be\n+    * abstracted out to top level base class.\n+    *\n+    * Right now BaseValueVector is the top level base class for other\n+    * vector types in ValueVector hierarchy (non-nullable) and those\n+    * vectors have not yet been refactored/removed so moving things to\n+    * the top class as of now is not a good idea.\n+    */\n+\n+\n+  @Override\n+  @Deprecated\n+  public VariableWidthMutator getMutator() {\n+    throw new UnsupportedOperationException(\"Mutator is not supported for writing into vector\");\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public VariableWidthAccessor getAccessor() {\n+    throw new UnsupportedOperationException(\"Accessor is not supported for reading from vector\");\n+  }\n+\n+  /**\n+   * Get buffer that manages the validity (NULL or NON-NULL nature) of\n+   * elements in the vector. Consider it as a buffer for internal bit vector\n+   * data structure.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  /**\n+   * Get the buffer that stores the data for elements in the vector.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    return valueBuffer;\n+  }\n+\n+  /**\n+   * buffer that stores the offsets for elements\n+   * in the vector. This operation is not supported for fixed-width vectors.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the offsets for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return offsetBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that manages the validity\n+   * (NULL or NON-NULL nature) of elements in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return validityBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the data for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getDataBufferAddress() {\n+    return valueBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   * @param valueCount desired number of elements in the vector\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount) {\n+    final long size = (long) valueCount * DEFAULT_RECORD_BYTE_COUNT;\n+    if (size > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+    valueAllocationSizeInBytes = (int) size;\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(valueCount);\n+      /* to track the end offset of last data element in vector, we need\n+       * an additional slot in offset buffer.\n+       */\n+    offsetAllocationSizeInBytes = (valueCount + 1) * OFFSET_WIDTH;\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    final int offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n+    return Math.min(offsetValueCapacity, getValidityBufferValueCapacity());\n+  }\n+\n+  private int getValidityBufferValueCapacity() {\n+    return (int) (validityBuffer.capacity() * 8L);\n+  }\n+\n+  private int getOffsetBufferValueCapacity() {\n+    return (int) ((offsetBuffer.capacity() * 1.0) / OFFSET_WIDTH);\n+  }\n+\n+  /**\n+   * zero out the vector and the data in associated buffers.\n+   */\n+  public void zeroVector() {\n+    initValidityBuffer();\n+    initOffsetBuffer();\n+  }\n+\n+  /* zero out the validity buffer */\n+  private void initValidityBuffer() {\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+\n+  /* zero out the offset buffer */\n+  private void initOffsetBuffer() {\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+\n+  /**\n+   * Reset the vector to initial state. Same as {@link #zeroVector()}.\n+   * Note that this method doesn't release any memory.\n+   */\n+  public void reset() {\n+    zeroVector();\n+    lastSet = -1;\n+  }\n+\n+  /**\n+   * Close the vector and release the associated buffers.\n+   */\n+  @Override\n+  public void close() {\n+    clear();\n+  }\n+\n+  /**\n+   * Same as {@link #close()}\n+   */\n+  @Override\n+  public void clear() {\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    valueBuffer = releaseBuffer(valueBuffer);\n+    offsetBuffer = releaseBuffer(offsetBuffer);\n+    cleared = true;\n+    lastSet = -1;\n+    valueCount = 0;\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Initialize the children in schema for this Field. This operation is a\n+   * NO-OP for scalar types since they don't have any children.\n+   * @param children the schema\n+   * @throws IllegalArgumentException if children is a non-empty list for scalar types.\n+   */\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (!children.isEmpty()) {\n+      throw new IllegalArgumentException(\"primitive type vector can not have children\");\n+    }\n+  }\n+\n+  /**\n+   * Get the inner child vectors.\n+   * @return list of child vectors for complex types, empty list for scalar vector\n+   * types\n+   */\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return Collections.emptyList();\n+  }\n+\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+    ArrowBuf dataBuffer = ownBuffers.get(2);\n+\n+    validityBuffer.release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.release();\n+    offsetBuffer = offBuffer.retain(allocator);\n+    valueBuffer.release();\n+    valueBuffer = dataBuffer.retain(allocator);\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector\n+   * @return the inner buffers.\n+   */\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(3);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+    result.add(valueBuffer);\n+\n+    return result;\n+  }\n+\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    valueBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+      valueBuffer.writerIndex(0);\n+    } else {\n+      final int lastDataOffset = getstartOffset(valueCount);\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+      valueBuffer.writerIndex(lastDataOffset);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory.\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector. See {@link #allocateNew(int, int)} for allocating memory for specific\n+   * number of elements in the vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  @Override\n+  public boolean allocateNewSafe() {\n+    long curAllocationSizeValue = valueAllocationSizeInBytes;\n+    long curAllocationSizeValidity = validityAllocationSizeInBytes;\n+    long curAllocationSizeOffset = offsetAllocationSizeInBytes;\n+\n+    if (curAllocationSizeValue > MAX_ALLOCATION_SIZE ||\n+            curAllocationSizeOffset > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory exceeds limit\");\n+    }\n+\n+      /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(curAllocationSizeValue, curAllocationSizeValidity, curAllocationSizeOffset);\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Allocate memory for the vector to support storing at least the provided number of\n+   * elements in the vector. This method must be called prior to using the ValueVector.\n+   *\n+   * @param totalBytes desired total memory capacity\n+   * @param valueCount the desired number of elements in the vector\n+   * @throws org.apache.arrow.memory.OutOfMemoryException\n+   */\n+  @Override\n+  public void allocateNew(int totalBytes, int valueCount) {\n+    assert totalBytes >= 0;\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+\n+    if (totalBytes > MAX_ALLOCATION_SIZE ||\n+            offsetBufferSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory exceeds limit\");\n+    }\n+\n+      /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(totalBytes, validityBufferSize, offsetBufferSize);\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+    }\n+  }\n+\n+  /* allocate the inner buffers */\n+  private void allocateBytes(final long valueBufferSize, final long validityBufferSize,\n+                             final long offsetBufferSize) {\n+      /* allocate data buffer */\n+    int curSize = (int) valueBufferSize;\n+    valueBuffer = allocator.buffer(curSize);\n+    valueBuffer.readerIndex(0);\n+    valueAllocationSizeInBytes = curSize;\n+    allocateValidityBuffer(validityBufferSize);\n+    allocateOffsetBuffer(offsetBufferSize);\n+  }\n+\n+  /* allocate offset buffer */\n+  private void allocateOffsetBuffer(final long size) {\n+    final int curSize = (int) size;\n+    offsetBuffer = allocator.buffer(curSize);\n+    offsetBuffer.readerIndex(0);\n+    offsetAllocationSizeInBytes = curSize;\n+    initOffsetBuffer();\n+  }\n+\n+  /* allocate validity buffer */\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    initValidityBuffer();\n+  }\n+\n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  public void reAlloc() {\n+    reallocDataBuffer();\n+    reallocValidityAndOffsetBuffers();\n+  }\n+\n+  /**\n+   * Reallocate the data buffer. Data Buffer stores the actual data for\n+   * VARCHAR or VARBINARY elements in the vector. The behavior is to double\n+   * the size of buffer.\n+   * @throws OversizedAllocationException if the desired new size is more than\n+   *                                      max allowed\n+   * @throws OutOfMemoryException if the internal memory allocation fails\n+   */\n+  public void reallocDataBuffer() {\n+    long baseSize = valueAllocationSizeInBytes;\n+    final int currentBufferCapacity = valueBuffer.capacity();\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, valueBuffer, 0, currentBufferCapacity);\n+    valueBuffer.release();\n+    valueBuffer = newBuf;\n+    valueAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  /**\n+   * Reallocate the validity and offset buffers for this vector. Validity\n+   * buffer is used to track the NULL or NON-NULL nature of elements in\n+   * the vector and offset buffer is used to store the lengths of variable\n+   * width elements in the vector.\n+   *\n+   * Note that data buffer for variable length vectors moves independent\n+   * of the companion validity and offset buffers. This is in\n+   * contrast to what we have for fixed width vectors.\n+   *\n+   * So even though we may have setup an initial capacity of 1024\n+   * elements in the vector, it is quite possible\n+   * that we need to reAlloc() the data buffer when we are setting\n+   * the 5th element in the vector simply because previous\n+   * variable length elements have exhausted the buffer capacity.\n+   * However, we really don't need to reAlloc() validity and\n+   * offset buffers until we try to set the 1025th element\n+   * This is why we do a separate check for safe methods to\n+   * determine which buffer needs reallocation.\n+   * @throws OversizedAllocationException if the desired new size is more than\n+   *                                      max allowed\n+   * @throws OutOfMemoryException if the internal memory allocation fails\n+   */\n+  public void reallocValidityAndOffsetBuffers() {\n+    offsetBuffer = reallocBufferHelper(offsetBuffer, true);\n+    validityBuffer = reallocBufferHelper(validityBuffer, false);\n+  }\n+\n+  /* helper method to realloc a particular buffer. returns the allocated buffer */\n+  private ArrowBuf reallocBufferHelper(ArrowBuf buffer, final boolean offsetBuffer) {\n+    final int currentBufferCapacity = buffer.capacity();\n+    long baseSize = (offsetBuffer ? offsetAllocationSizeInBytes\n+            : validityAllocationSizeInBytes);\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, buffer, 0, currentBufferCapacity);\n+    final int halfNewCapacity = newBuf.capacity() / 2;\n+    newBuf.setZero(halfNewCapacity, halfNewCapacity);\n+    buffer.release(1);\n+    buffer = newBuf;\n+    if (offsetBuffer) {\n+      offsetAllocationSizeInBytes = (int) newAllocationSize;\n+    } else {\n+      validityAllocationSizeInBytes = (int) newAllocationSize;\n+    }\n+\n+    return buffer;\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying data buffer.\n+   * @return\n+   */\n+  @Override\n+  public int getByteCapacity() {\n+    return valueBuffer.capacity();\n+  }\n+\n+  @Override\n+  public int getCurrentSizeInBytes() {\n+      /* TODO */\n+    return 0;\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    return getBufferSizeFor(this.valueCount);\n+  }\n+\n+  /**\n+   * Get the potential buffer size for a particular number of records.\n+   * @param valueCount desired number of elements in the vector\n+   * @return estimated size of underlying buffers if the vector holds\n+   *         a given number of elements\n+   */\n+  @Override\n+  public int getBufferSizeFor(final int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+      /* get the end offset for this valueCount */\n+    final int dataBufferSize = offsetBuffer.getInt(valueCount * OFFSET_WIDTH);\n+    return validityBufferSize + offsetBufferSize + dataBufferSize;\n+  }\n+\n+  /**\n+   * Get information about how this field is materialized.\n+   * @return the field corresponding to this vector\n+   */\n+  @Override\n+  public Field getField() {\n+    return field;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    final ArrowBuf[] buffers;\n+    setReaderAndWriterIndex();\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = new ArrowBuf[3];\n+      buffers[0] = validityBuffer;\n+      buffers[1] = offsetBuffer;\n+      buffers[2] = valueBuffer;\n+    }\n+    if (clear) {\n+      for (final ArrowBuf buffer : buffers) {\n+        buffer.retain(1);\n+      }\n+      clear();\n+    }\n+    return buffers;\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @param callBack\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return getTransferPair(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(BufferAllocator allocator) {\n+    return getTransferPair(name, allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  public abstract TransferPair getTransferPair(String ref, BufferAllocator allocator);\n+\n+  /**\n+   * Transfer this vector'data to another vector. The memory associated\n+   * with this vector is transferred to the allocator of target vector\n+   * for accounting and management purposes.\n+   * @param target destination vector for transfer\n+   */\n+  public void transferTo(BaseNullableVariableWidthVector target) {\n+    compareTypes(target, \"transferTo\");\n+    target.clear();\n+    target.validityBuffer = validityBuffer.transferOwnership(target.allocator).buffer;\n+    target.valueBuffer = valueBuffer.transferOwnership(target.allocator).buffer;\n+    target.offsetBuffer = offsetBuffer.transferOwnership(target.allocator).buffer;\n+    target.setLastSet(this.lastSet);\n+    if (this.valueCount > 0) {\n+      target.setValueCount(this.valueCount);\n+    }\n+    clear();\n+  }\n+\n+  /**\n+   * Slice this vector at desired index and length and transfer the\n+   * corresponding data to the target vector.\n+   * @param startIndex start position of the split in source vector.\n+   * @param length length of the split.\n+   * @param target destination vector\n+   */\n+  public void splitAndTransferTo(int startIndex, int length,\n+                                 BaseNullableVariableWidthVector target) {\n+    compareTypes(target, \"splitAndTransferTo\");\n+    target.clear();\n+    splitAndTransferValidityBuffer(startIndex, length, target);\n+    splitAndTransferOffsetBuffer(startIndex, length, target);\n+    target.setLastSet(length - 1);\n+    if (this.valueCount > 0) {\n+      target.setValueCount(this.valueCount);\n+    }\n+  }\n+\n+  /*\n+   * Transfer the offsets along with data. Unlike the data buffer, we cannot simply\n+   * slice the offset buffer for split and transfer. The reason is that offsets\n+   * in the target vector have to be adjusted and made relative to the staring\n+   * offset in source vector from the start index of split. This is why, we\n+   * need to explicitly allocate the offset buffer and set the adjusted offsets\n+   * in the target vector.\n+   */\n+  private void splitAndTransferOffsetBuffer(int startIndex, int length, BaseNullableVariableWidthVector target) {\n+    final int start = offsetBuffer.getInt(startIndex * OFFSET_WIDTH);\n+    final int end = offsetBuffer.getInt((startIndex + length) * OFFSET_WIDTH);\n+    final int dataLength = end - start;\n+    target.allocateOffsetBuffer((length + 1) * OFFSET_WIDTH);\n+    for (int i = 0; i < length + 1; i++) {\n+      final int relativeSourceOffset = offsetBuffer.getInt((startIndex + i) * OFFSET_WIDTH) - start;\n+      target.offsetBuffer.setInt(i * OFFSET_WIDTH, relativeSourceOffset);\n+    }\n+    target.valueBuffer = valueBuffer.slice(start, dataLength).transferOwnership(target.allocator).buffer;\n+  }\n+\n+  /*\n+   * Transfer the validity.\n+   */\n+  private void splitAndTransferValidityBuffer(int startIndex, int length,\n+                                              BaseNullableVariableWidthVector target) {\n+    assert startIndex + length <= valueCount;\n+    int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+    int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+    int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+    int offset = startIndex % 8;\n+\n+    if (length > 0) {\n+      if (offset == 0) {\n+        // slice\n+        if (target.validityBuffer != null) {\n+          target.validityBuffer.release();\n+        }\n+        target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+        target.validityBuffer.retain(1);\n+      } else {\n+            /* Copy data\n+             * When the first bit starts from the middle of a byte (offset != 0),\n+             * copy data from src BitVector.\n+             * Each byte in the target is composed by a part in i-th byte,\n+             * another part in (i+1)-th byte.\n+             */\n+        target.allocateValidityBuffer(byteSizeTarget);\n+\n+        for (int i = 0; i < byteSizeTarget - 1; i++) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer, firstByteSource + i, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer, firstByteSource + i + 1, offset);\n+\n+          target.validityBuffer.setByte(i, (b1 + b2));\n+        }\n+\n+            /* Copying the last piece is done in the following manner:\n+             * if the source vector has 1 or more bytes remaining, we copy\n+             * the last piece as a byte formed by shifting data\n+             * from the current byte and the next byte.\n+             *\n+             * if the source vector has no more bytes remaining\n+             * (we are at the last byte), we copy the last piece as a byte\n+             * by shifting data from the current byte.\n+             */\n+        if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer,\n+                  firstByteSource + byteSizeTarget, offset);\n+\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+        } else {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+        }\n+      }\n+    }\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                common getters and setters                      *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the number of elements that are null in the vector\n+   *\n+   * @return the number of null elements.\n+   */\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  /**\n+   * Check if the given index is within the current value capacity\n+   * of the vector\n+   *\n+   * @param index  position to check\n+   * @return true if index is within the current value capacity\n+   */\n+  public boolean isSafe(int index) {\n+    return index < getValueCapacity();\n+  }\n+\n+  /**\n+   * Check if element at given index is null.\n+   *\n+   * @param index  position of element\n+   * @return true if element at given index is null\n+   */\n+  public boolean isNull(int index) {\n+    return (isSet(index) == 0);\n+  }\n+\n+  /**\n+   * Same as {@link #isNull(int)}.\n+   *\n+   * @param index  position of element\n+   * @return 1 if element at given index is not null, 0 otherwise\n+   */\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return Long.bitCount(b & (1L << bitIndex));\n+  }\n+\n+  /**\n+   * Get the value count of vector. This will always be zero unless\n+   * setValueCount(int) has been called prior to calling this.\n+   *\n+   * @return valueCount for the vector\n+   */\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n+\n+  /**\n+   * Sets the value count for the vector\n+   *\n+   * @param valueCount   value count\n+   */\n+  public void setValueCount(int valueCount) {\n+    assert valueCount >= 0;\n+    this.valueCount = valueCount;\n+    while (valueCount > getValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    fillHoles(valueCount);\n+    lastSet = valueCount - 1;\n+    setReaderAndWriterIndex();\n+  }\n+\n+  /**\n+   * Create holes in the vector upto the given index (exclusive).\n+   * Holes will be created from the current last set position in\n+   * the vector.\n+   *\n+   * @param index target index\n+   */\n+  public void fillEmpties(int index) {\n+    handleSafe(index, emptyByteArray.length);\n+    fillHoles(index);\n+    lastSet = index - 1;\n+  }\n+\n+  /**\n+   * Set the index of last non-null element in the vector.\n+   * It is important to call this method with appropriate value\n+   * before calling {@link #setValueCount(int)}.\n+   *\n+   * @param value desired index of last non-null element.\n+   */\n+  public void setLastSet(int value) {\n+    lastSet = value;\n+  }\n+\n+  /**\n+   * Get the index of last non-null element in the vector.\n+   *\n+   * @return index of the last non-null element\n+   */\n+  public int getLastSet() {\n+    return lastSet;\n+  }\n+\n+  /**\n+   * Get the starting position (offset) in the data stream for a given\n+   * element in the vector.\n+   *\n+   * @param index position of the element in the vector\n+   * @return starting offset for the element\n+   */\n+  public long getStartEnd(int index) {\n+    return offsetBuffer.getLong(index * OFFSET_WIDTH);\n+  }\n+\n+  /**\n+   * Mark the particular position in the vector as non-null.\n+   *\n+   * @param index position of the element.\n+   */\n+  @Override\n+  public void setIndexDefined(int index) {\n+    while (index >= getValidityBufferValueCapacity()) {\n+      validityBuffer = reallocBufferHelper(validityBuffer, false);\n+    }\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+  }\n+\n+  /**\n+   * Sets the value length for an element.\n+   *\n+   * @param index   position of the element to set\n+   * @param length  length of the element\n+   */\n+  public void setValueLengthSafe(int index, int length) {\n \n Review comment:\n   @siddharthteotia what's your thought on this\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T20:33:51.574+0000",
                    "updated": "2017-11-15T20:33:51.574+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16254130",
                    "id": "16254130",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151244183\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseValueVector.java\n ##########\n @@ -122,5 +123,49 @@ public static boolean checkBufRefs(final ValueVector vv) {\n   public BufferAllocator getAllocator() {\n     return allocator;\n   }\n+\n+  protected void compareTypes(BaseValueVector target, String caller) {\n+    if (this.getMinorType() != target.getMinorType()) {\n+      throw new UnsupportedOperationException(caller + \" should have vectors of exact same type\");\n \n Review comment:\n   Since it's a protected method. I don't think it matters too much. I am ok with it as is.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T20:34:49.716+0000",
                    "updated": "2017-11-15T20:34:49.716+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16254153",
                    "id": "16254153",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151247552\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\n ##########\n @@ -0,0 +1,1250 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.NullableMapVector;\n+import org.apache.arrow.vector.schema.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public abstract class BaseNullableVariableWidthVector extends BaseValueVector\n+        implements VariableWidthVector, FieldVector, NullableVectorDefinitionSetter {\n+  private static final int DEFAULT_RECORD_BYTE_COUNT = 8;\n+  private static final int INITIAL_BYTE_COUNT = INITIAL_VALUE_ALLOCATION * DEFAULT_RECORD_BYTE_COUNT;\n+\n+  private int valueAllocationSizeInBytes;\n+  private int validityAllocationSizeInBytes;\n+  private int offsetAllocationSizeInBytes;\n+\n+  /* protected members */\n+  public static final int OFFSET_WIDTH = 4; /* 4 byte unsigned int to track offsets */\n+  protected static final byte[] emptyByteArray = new byte[]{};\n+  protected ArrowBuf validityBuffer;\n+  protected ArrowBuf valueBuffer;\n+  protected ArrowBuf offsetBuffer;\n+  protected int valueCount;\n+  protected int lastSet;\n+  protected final Field field;\n+  private boolean cleared;\n+\n+  public BaseNullableVariableWidthVector(final String name, final BufferAllocator allocator,\n+                                         FieldType fieldType) {\n+    super(name, allocator);\n+    valueAllocationSizeInBytes = INITIAL_BYTE_COUNT;\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    offsetAllocationSizeInBytes = (INITIAL_VALUE_ALLOCATION) * OFFSET_WIDTH;\n+    field = new Field(name, fieldType, null);\n+    valueCount = 0;\n+    lastSet = -1;\n+    offsetBuffer = allocator.getEmpty();\n+    validityBuffer = allocator.getEmpty();\n+    valueBuffer = allocator.getEmpty();\n+    cleared = false;\n+  }\n+\n+   /* TODO:\n+    *\n+    * see if getNullCount() can be made faster -- O(1)\n+    */\n+\n+  /* TODO:\n+    * Once the entire hierarchy has been refactored, move common functions\n+    * like getNullCount(), splitAndTransferValidityBuffer to top level\n+    * base class BaseValueVector.\n+    *\n+    * Along with this, some class members (validityBuffer) can also be\n+    * abstracted out to top level base class.\n+    *\n+    * Right now BaseValueVector is the top level base class for other\n+    * vector types in ValueVector hierarchy (non-nullable) and those\n+    * vectors have not yet been refactored/removed so moving things to\n+    * the top class as of now is not a good idea.\n+    */\n+\n+\n+  @Override\n+  @Deprecated\n+  public VariableWidthMutator getMutator() {\n+    throw new UnsupportedOperationException(\"Mutator is not supported for writing into vector\");\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public VariableWidthAccessor getAccessor() {\n+    throw new UnsupportedOperationException(\"Accessor is not supported for reading from vector\");\n+  }\n+\n+  /**\n+   * Get buffer that manages the validity (NULL or NON-NULL nature) of\n+   * elements in the vector. Consider it as a buffer for internal bit vector\n+   * data structure.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  /**\n+   * Get the buffer that stores the data for elements in the vector.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    return valueBuffer;\n+  }\n+\n+  /**\n+   * buffer that stores the offsets for elements\n+   * in the vector. This operation is not supported for fixed-width vectors.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the offsets for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return offsetBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that manages the validity\n+   * (NULL or NON-NULL nature) of elements in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return validityBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the data for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getDataBufferAddress() {\n+    return valueBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   * @param valueCount desired number of elements in the vector\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount) {\n+    final long size = (long) valueCount * DEFAULT_RECORD_BYTE_COUNT;\n+    if (size > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+    valueAllocationSizeInBytes = (int) size;\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(valueCount);\n+      /* to track the end offset of last data element in vector, we need\n+       * an additional slot in offset buffer.\n+       */\n+    offsetAllocationSizeInBytes = (valueCount + 1) * OFFSET_WIDTH;\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    final int offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n+    return Math.min(offsetValueCapacity, getValidityBufferValueCapacity());\n+  }\n+\n+  private int getValidityBufferValueCapacity() {\n+    return (int) (validityBuffer.capacity() * 8L);\n+  }\n+\n+  private int getOffsetBufferValueCapacity() {\n+    return (int) ((offsetBuffer.capacity() * 1.0) / OFFSET_WIDTH);\n+  }\n+\n+  /**\n+   * zero out the vector and the data in associated buffers.\n+   */\n+  public void zeroVector() {\n+    initValidityBuffer();\n+    initOffsetBuffer();\n+  }\n+\n+  /* zero out the validity buffer */\n+  private void initValidityBuffer() {\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+\n+  /* zero out the offset buffer */\n+  private void initOffsetBuffer() {\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+\n+  /**\n+   * Reset the vector to initial state. Same as {@link #zeroVector()}.\n+   * Note that this method doesn't release any memory.\n+   */\n+  public void reset() {\n+    zeroVector();\n+    lastSet = -1;\n+  }\n+\n+  /**\n+   * Close the vector and release the associated buffers.\n+   */\n+  @Override\n+  public void close() {\n+    clear();\n+  }\n+\n+  /**\n+   * Same as {@link #close()}\n+   */\n+  @Override\n+  public void clear() {\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    valueBuffer = releaseBuffer(valueBuffer);\n+    offsetBuffer = releaseBuffer(offsetBuffer);\n+    cleared = true;\n+    lastSet = -1;\n+    valueCount = 0;\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Initialize the children in schema for this Field. This operation is a\n+   * NO-OP for scalar types since they don't have any children.\n+   * @param children the schema\n+   * @throws IllegalArgumentException if children is a non-empty list for scalar types.\n+   */\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (!children.isEmpty()) {\n+      throw new IllegalArgumentException(\"primitive type vector can not have children\");\n+    }\n+  }\n+\n+  /**\n+   * Get the inner child vectors.\n+   * @return list of child vectors for complex types, empty list for scalar vector\n+   * types\n+   */\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return Collections.emptyList();\n+  }\n+\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+    ArrowBuf dataBuffer = ownBuffers.get(2);\n+\n+    validityBuffer.release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.release();\n+    offsetBuffer = offBuffer.retain(allocator);\n+    valueBuffer.release();\n+    valueBuffer = dataBuffer.retain(allocator);\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector\n+   * @return the inner buffers.\n+   */\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(3);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+    result.add(valueBuffer);\n+\n+    return result;\n+  }\n+\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    valueBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+      valueBuffer.writerIndex(0);\n+    } else {\n+      final int lastDataOffset = getstartOffset(valueCount);\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+      valueBuffer.writerIndex(lastDataOffset);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory.\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector. See {@link #allocateNew(int, int)} for allocating memory for specific\n+   * number of elements in the vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  @Override\n+  public boolean allocateNewSafe() {\n+    long curAllocationSizeValue = valueAllocationSizeInBytes;\n+    long curAllocationSizeValidity = validityAllocationSizeInBytes;\n+    long curAllocationSizeOffset = offsetAllocationSizeInBytes;\n+\n+    if (curAllocationSizeValue > MAX_ALLOCATION_SIZE ||\n+            curAllocationSizeOffset > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory exceeds limit\");\n+    }\n+\n+      /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(curAllocationSizeValue, curAllocationSizeValidity, curAllocationSizeOffset);\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Allocate memory for the vector to support storing at least the provided number of\n+   * elements in the vector. This method must be called prior to using the ValueVector.\n+   *\n+   * @param totalBytes desired total memory capacity\n+   * @param valueCount the desired number of elements in the vector\n+   * @throws org.apache.arrow.memory.OutOfMemoryException\n+   */\n+  @Override\n+  public void allocateNew(int totalBytes, int valueCount) {\n+    assert totalBytes >= 0;\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+\n+    if (totalBytes > MAX_ALLOCATION_SIZE ||\n+            offsetBufferSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory exceeds limit\");\n+    }\n+\n+      /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(totalBytes, validityBufferSize, offsetBufferSize);\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+    }\n+  }\n+\n+  /* allocate the inner buffers */\n+  private void allocateBytes(final long valueBufferSize, final long validityBufferSize,\n+                             final long offsetBufferSize) {\n+      /* allocate data buffer */\n+    int curSize = (int) valueBufferSize;\n+    valueBuffer = allocator.buffer(curSize);\n+    valueBuffer.readerIndex(0);\n+    valueAllocationSizeInBytes = curSize;\n+    allocateValidityBuffer(validityBufferSize);\n+    allocateOffsetBuffer(offsetBufferSize);\n+  }\n+\n+  /* allocate offset buffer */\n+  private void allocateOffsetBuffer(final long size) {\n+    final int curSize = (int) size;\n+    offsetBuffer = allocator.buffer(curSize);\n+    offsetBuffer.readerIndex(0);\n+    offsetAllocationSizeInBytes = curSize;\n+    initOffsetBuffer();\n+  }\n+\n+  /* allocate validity buffer */\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    initValidityBuffer();\n+  }\n+\n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  public void reAlloc() {\n+    reallocDataBuffer();\n+    reallocValidityAndOffsetBuffers();\n+  }\n+\n+  /**\n+   * Reallocate the data buffer. Data Buffer stores the actual data for\n+   * VARCHAR or VARBINARY elements in the vector. The behavior is to double\n+   * the size of buffer.\n+   * @throws OversizedAllocationException if the desired new size is more than\n+   *                                      max allowed\n+   * @throws OutOfMemoryException if the internal memory allocation fails\n+   */\n+  public void reallocDataBuffer() {\n+    long baseSize = valueAllocationSizeInBytes;\n+    final int currentBufferCapacity = valueBuffer.capacity();\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, valueBuffer, 0, currentBufferCapacity);\n+    valueBuffer.release();\n+    valueBuffer = newBuf;\n+    valueAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  /**\n+   * Reallocate the validity and offset buffers for this vector. Validity\n+   * buffer is used to track the NULL or NON-NULL nature of elements in\n+   * the vector and offset buffer is used to store the lengths of variable\n+   * width elements in the vector.\n+   *\n+   * Note that data buffer for variable length vectors moves independent\n+   * of the companion validity and offset buffers. This is in\n+   * contrast to what we have for fixed width vectors.\n+   *\n+   * So even though we may have setup an initial capacity of 1024\n+   * elements in the vector, it is quite possible\n+   * that we need to reAlloc() the data buffer when we are setting\n+   * the 5th element in the vector simply because previous\n+   * variable length elements have exhausted the buffer capacity.\n+   * However, we really don't need to reAlloc() validity and\n+   * offset buffers until we try to set the 1025th element\n+   * This is why we do a separate check for safe methods to\n+   * determine which buffer needs reallocation.\n+   * @throws OversizedAllocationException if the desired new size is more than\n+   *                                      max allowed\n+   * @throws OutOfMemoryException if the internal memory allocation fails\n+   */\n+  public void reallocValidityAndOffsetBuffers() {\n+    offsetBuffer = reallocBufferHelper(offsetBuffer, true);\n+    validityBuffer = reallocBufferHelper(validityBuffer, false);\n+  }\n+\n+  /* helper method to realloc a particular buffer. returns the allocated buffer */\n+  private ArrowBuf reallocBufferHelper(ArrowBuf buffer, final boolean offsetBuffer) {\n+    final int currentBufferCapacity = buffer.capacity();\n+    long baseSize = (offsetBuffer ? offsetAllocationSizeInBytes\n+            : validityAllocationSizeInBytes);\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, buffer, 0, currentBufferCapacity);\n+    final int halfNewCapacity = newBuf.capacity() / 2;\n+    newBuf.setZero(halfNewCapacity, halfNewCapacity);\n+    buffer.release(1);\n+    buffer = newBuf;\n+    if (offsetBuffer) {\n+      offsetAllocationSizeInBytes = (int) newAllocationSize;\n+    } else {\n+      validityAllocationSizeInBytes = (int) newAllocationSize;\n+    }\n+\n+    return buffer;\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying data buffer.\n+   * @return\n+   */\n+  @Override\n+  public int getByteCapacity() {\n+    return valueBuffer.capacity();\n+  }\n+\n+  @Override\n+  public int getCurrentSizeInBytes() {\n+      /* TODO */\n+    return 0;\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    return getBufferSizeFor(this.valueCount);\n+  }\n+\n+  /**\n+   * Get the potential buffer size for a particular number of records.\n+   * @param valueCount desired number of elements in the vector\n+   * @return estimated size of underlying buffers if the vector holds\n+   *         a given number of elements\n+   */\n+  @Override\n+  public int getBufferSizeFor(final int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+      /* get the end offset for this valueCount */\n+    final int dataBufferSize = offsetBuffer.getInt(valueCount * OFFSET_WIDTH);\n+    return validityBufferSize + offsetBufferSize + dataBufferSize;\n+  }\n+\n+  /**\n+   * Get information about how this field is materialized.\n+   * @return the field corresponding to this vector\n+   */\n+  @Override\n+  public Field getField() {\n+    return field;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    final ArrowBuf[] buffers;\n+    setReaderAndWriterIndex();\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = new ArrowBuf[3];\n+      buffers[0] = validityBuffer;\n+      buffers[1] = offsetBuffer;\n+      buffers[2] = valueBuffer;\n+    }\n+    if (clear) {\n+      for (final ArrowBuf buffer : buffers) {\n+        buffer.retain(1);\n+      }\n+      clear();\n+    }\n+    return buffers;\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @param callBack\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return getTransferPair(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(BufferAllocator allocator) {\n+    return getTransferPair(name, allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  public abstract TransferPair getTransferPair(String ref, BufferAllocator allocator);\n+\n+  /**\n+   * Transfer this vector'data to another vector. The memory associated\n+   * with this vector is transferred to the allocator of target vector\n+   * for accounting and management purposes.\n+   * @param target destination vector for transfer\n+   */\n+  public void transferTo(BaseNullableVariableWidthVector target) {\n+    compareTypes(target, \"transferTo\");\n+    target.clear();\n+    target.validityBuffer = validityBuffer.transferOwnership(target.allocator).buffer;\n+    target.valueBuffer = valueBuffer.transferOwnership(target.allocator).buffer;\n+    target.offsetBuffer = offsetBuffer.transferOwnership(target.allocator).buffer;\n+    target.setLastSet(this.lastSet);\n+    if (this.valueCount > 0) {\n+      target.setValueCount(this.valueCount);\n+    }\n+    clear();\n+  }\n+\n+  /**\n+   * Slice this vector at desired index and length and transfer the\n+   * corresponding data to the target vector.\n+   * @param startIndex start position of the split in source vector.\n+   * @param length length of the split.\n+   * @param target destination vector\n+   */\n+  public void splitAndTransferTo(int startIndex, int length,\n+                                 BaseNullableVariableWidthVector target) {\n+    compareTypes(target, \"splitAndTransferTo\");\n+    target.clear();\n+    splitAndTransferValidityBuffer(startIndex, length, target);\n+    splitAndTransferOffsetBuffer(startIndex, length, target);\n+    target.setLastSet(length - 1);\n+    if (this.valueCount > 0) {\n+      target.setValueCount(this.valueCount);\n+    }\n+  }\n+\n+  /*\n+   * Transfer the offsets along with data. Unlike the data buffer, we cannot simply\n+   * slice the offset buffer for split and transfer. The reason is that offsets\n+   * in the target vector have to be adjusted and made relative to the staring\n+   * offset in source vector from the start index of split. This is why, we\n+   * need to explicitly allocate the offset buffer and set the adjusted offsets\n+   * in the target vector.\n+   */\n+  private void splitAndTransferOffsetBuffer(int startIndex, int length, BaseNullableVariableWidthVector target) {\n+    final int start = offsetBuffer.getInt(startIndex * OFFSET_WIDTH);\n+    final int end = offsetBuffer.getInt((startIndex + length) * OFFSET_WIDTH);\n+    final int dataLength = end - start;\n+    target.allocateOffsetBuffer((length + 1) * OFFSET_WIDTH);\n+    for (int i = 0; i < length + 1; i++) {\n+      final int relativeSourceOffset = offsetBuffer.getInt((startIndex + i) * OFFSET_WIDTH) - start;\n+      target.offsetBuffer.setInt(i * OFFSET_WIDTH, relativeSourceOffset);\n+    }\n+    target.valueBuffer = valueBuffer.slice(start, dataLength).transferOwnership(target.allocator).buffer;\n+  }\n+\n+  /*\n+   * Transfer the validity.\n+   */\n+  private void splitAndTransferValidityBuffer(int startIndex, int length,\n+                                              BaseNullableVariableWidthVector target) {\n+    assert startIndex + length <= valueCount;\n+    int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+    int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+    int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+    int offset = startIndex % 8;\n+\n+    if (length > 0) {\n+      if (offset == 0) {\n+        // slice\n+        if (target.validityBuffer != null) {\n+          target.validityBuffer.release();\n+        }\n+        target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+        target.validityBuffer.retain(1);\n+      } else {\n+            /* Copy data\n+             * When the first bit starts from the middle of a byte (offset != 0),\n+             * copy data from src BitVector.\n+             * Each byte in the target is composed by a part in i-th byte,\n+             * another part in (i+1)-th byte.\n+             */\n+        target.allocateValidityBuffer(byteSizeTarget);\n+\n+        for (int i = 0; i < byteSizeTarget - 1; i++) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer, firstByteSource + i, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer, firstByteSource + i + 1, offset);\n+\n+          target.validityBuffer.setByte(i, (b1 + b2));\n+        }\n+\n+            /* Copying the last piece is done in the following manner:\n+             * if the source vector has 1 or more bytes remaining, we copy\n+             * the last piece as a byte formed by shifting data\n+             * from the current byte and the next byte.\n+             *\n+             * if the source vector has no more bytes remaining\n+             * (we are at the last byte), we copy the last piece as a byte\n+             * by shifting data from the current byte.\n+             */\n+        if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer,\n+                  firstByteSource + byteSizeTarget, offset);\n+\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+        } else {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+        }\n+      }\n+    }\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                common getters and setters                      *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the number of elements that are null in the vector\n+   *\n+   * @return the number of null elements.\n+   */\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  /**\n+   * Check if the given index is within the current value capacity\n+   * of the vector\n+   *\n+   * @param index  position to check\n+   * @return true if index is within the current value capacity\n+   */\n+  public boolean isSafe(int index) {\n+    return index < getValueCapacity();\n+  }\n+\n+  /**\n+   * Check if element at given index is null.\n+   *\n+   * @param index  position of element\n+   * @return true if element at given index is null\n+   */\n+  public boolean isNull(int index) {\n+    return (isSet(index) == 0);\n+  }\n+\n+  /**\n+   * Same as {@link #isNull(int)}.\n+   *\n+   * @param index  position of element\n+   * @return 1 if element at given index is not null, 0 otherwise\n+   */\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return Long.bitCount(b & (1L << bitIndex));\n+  }\n+\n+  /**\n+   * Get the value count of vector. This will always be zero unless\n+   * setValueCount(int) has been called prior to calling this.\n+   *\n+   * @return valueCount for the vector\n+   */\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n+\n+  /**\n+   * Sets the value count for the vector\n+   *\n+   * @param valueCount   value count\n+   */\n+  public void setValueCount(int valueCount) {\n+    assert valueCount >= 0;\n+    this.valueCount = valueCount;\n+    while (valueCount > getValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    fillHoles(valueCount);\n+    lastSet = valueCount - 1;\n+    setReaderAndWriterIndex();\n+  }\n+\n+  /**\n+   * Create holes in the vector upto the given index (exclusive).\n+   * Holes will be created from the current last set position in\n+   * the vector.\n+   *\n+   * @param index target index\n+   */\n+  public void fillEmpties(int index) {\n+    handleSafe(index, emptyByteArray.length);\n+    fillHoles(index);\n+    lastSet = index - 1;\n+  }\n+\n+  /**\n+   * Set the index of last non-null element in the vector.\n+   * It is important to call this method with appropriate value\n+   * before calling {@link #setValueCount(int)}.\n+   *\n+   * @param value desired index of last non-null element.\n+   */\n+  public void setLastSet(int value) {\n+    lastSet = value;\n+  }\n+\n+  /**\n+   * Get the index of last non-null element in the vector.\n+   *\n+   * @return index of the last non-null element\n+   */\n+  public int getLastSet() {\n+    return lastSet;\n+  }\n+\n+  /**\n+   * Get the starting position (offset) in the data stream for a given\n+   * element in the vector.\n+   *\n+   * @param index position of the element in the vector\n+   * @return starting offset for the element\n+   */\n+  public long getStartEnd(int index) {\n+    return offsetBuffer.getLong(index * OFFSET_WIDTH);\n+  }\n+\n+  /**\n+   * Mark the particular position in the vector as non-null.\n+   *\n+   * @param index position of the element.\n+   */\n+  @Override\n+  public void setIndexDefined(int index) {\n+    while (index >= getValidityBufferValueCapacity()) {\n+      validityBuffer = reallocBufferHelper(validityBuffer, false);\n+    }\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+  }\n+\n+  /**\n+   * Sets the value length for an element.\n+   *\n+   * @param index   position of the element to set\n+   * @param length  length of the element\n+   */\n+  public void setValueLengthSafe(int index, int length) {\n \n Review comment:\n   We use it in our Parquet code -- I may have to evaluate its usage but the API has been there in variable width vector from the beginning.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T20:49:59.243+0000",
                    "updated": "2017-11-15T20:49:59.243+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16254160",
                    "id": "16254160",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#discussion_r151248493\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\n ##########\n @@ -0,0 +1,1250 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.NullableMapVector;\n+import org.apache.arrow.vector.schema.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public abstract class BaseNullableVariableWidthVector extends BaseValueVector\n+        implements VariableWidthVector, FieldVector, NullableVectorDefinitionSetter {\n+  private static final int DEFAULT_RECORD_BYTE_COUNT = 8;\n+  private static final int INITIAL_BYTE_COUNT = INITIAL_VALUE_ALLOCATION * DEFAULT_RECORD_BYTE_COUNT;\n+\n+  private int valueAllocationSizeInBytes;\n+  private int validityAllocationSizeInBytes;\n+  private int offsetAllocationSizeInBytes;\n+\n+  /* protected members */\n+  public static final int OFFSET_WIDTH = 4; /* 4 byte unsigned int to track offsets */\n+  protected static final byte[] emptyByteArray = new byte[]{};\n+  protected ArrowBuf validityBuffer;\n+  protected ArrowBuf valueBuffer;\n+  protected ArrowBuf offsetBuffer;\n+  protected int valueCount;\n+  protected int lastSet;\n+  protected final Field field;\n+  private boolean cleared;\n+\n+  public BaseNullableVariableWidthVector(final String name, final BufferAllocator allocator,\n+                                         FieldType fieldType) {\n+    super(name, allocator);\n+    valueAllocationSizeInBytes = INITIAL_BYTE_COUNT;\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    offsetAllocationSizeInBytes = (INITIAL_VALUE_ALLOCATION) * OFFSET_WIDTH;\n+    field = new Field(name, fieldType, null);\n+    valueCount = 0;\n+    lastSet = -1;\n+    offsetBuffer = allocator.getEmpty();\n+    validityBuffer = allocator.getEmpty();\n+    valueBuffer = allocator.getEmpty();\n+    cleared = false;\n+  }\n+\n+   /* TODO:\n+    *\n+    * see if getNullCount() can be made faster -- O(1)\n+    */\n+\n+  /* TODO:\n+    * Once the entire hierarchy has been refactored, move common functions\n+    * like getNullCount(), splitAndTransferValidityBuffer to top level\n+    * base class BaseValueVector.\n+    *\n+    * Along with this, some class members (validityBuffer) can also be\n+    * abstracted out to top level base class.\n+    *\n+    * Right now BaseValueVector is the top level base class for other\n+    * vector types in ValueVector hierarchy (non-nullable) and those\n+    * vectors have not yet been refactored/removed so moving things to\n+    * the top class as of now is not a good idea.\n+    */\n+\n+\n+  @Override\n+  @Deprecated\n+  public VariableWidthMutator getMutator() {\n+    throw new UnsupportedOperationException(\"Mutator is not supported for writing into vector\");\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public VariableWidthAccessor getAccessor() {\n+    throw new UnsupportedOperationException(\"Accessor is not supported for reading from vector\");\n+  }\n+\n+  /**\n+   * Get buffer that manages the validity (NULL or NON-NULL nature) of\n+   * elements in the vector. Consider it as a buffer for internal bit vector\n+   * data structure.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  /**\n+   * Get the buffer that stores the data for elements in the vector.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    return valueBuffer;\n+  }\n+\n+  /**\n+   * buffer that stores the offsets for elements\n+   * in the vector. This operation is not supported for fixed-width vectors.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the offsets for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return offsetBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that manages the validity\n+   * (NULL or NON-NULL nature) of elements in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return validityBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the data for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getDataBufferAddress() {\n+    return valueBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   * @param valueCount desired number of elements in the vector\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount) {\n+    final long size = (long) valueCount * DEFAULT_RECORD_BYTE_COUNT;\n+    if (size > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+    valueAllocationSizeInBytes = (int) size;\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(valueCount);\n+      /* to track the end offset of last data element in vector, we need\n+       * an additional slot in offset buffer.\n+       */\n+    offsetAllocationSizeInBytes = (valueCount + 1) * OFFSET_WIDTH;\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    final int offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n+    return Math.min(offsetValueCapacity, getValidityBufferValueCapacity());\n+  }\n+\n+  private int getValidityBufferValueCapacity() {\n+    return (int) (validityBuffer.capacity() * 8L);\n+  }\n+\n+  private int getOffsetBufferValueCapacity() {\n+    return (int) ((offsetBuffer.capacity() * 1.0) / OFFSET_WIDTH);\n+  }\n+\n+  /**\n+   * zero out the vector and the data in associated buffers.\n+   */\n+  public void zeroVector() {\n+    initValidityBuffer();\n+    initOffsetBuffer();\n+  }\n+\n+  /* zero out the validity buffer */\n+  private void initValidityBuffer() {\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+\n+  /* zero out the offset buffer */\n+  private void initOffsetBuffer() {\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+\n+  /**\n+   * Reset the vector to initial state. Same as {@link #zeroVector()}.\n+   * Note that this method doesn't release any memory.\n+   */\n+  public void reset() {\n+    zeroVector();\n+    lastSet = -1;\n+  }\n+\n+  /**\n+   * Close the vector and release the associated buffers.\n+   */\n+  @Override\n+  public void close() {\n+    clear();\n+  }\n+\n+  /**\n+   * Same as {@link #close()}\n+   */\n+  @Override\n+  public void clear() {\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    valueBuffer = releaseBuffer(valueBuffer);\n+    offsetBuffer = releaseBuffer(offsetBuffer);\n+    cleared = true;\n+    lastSet = -1;\n+    valueCount = 0;\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Initialize the children in schema for this Field. This operation is a\n+   * NO-OP for scalar types since they don't have any children.\n+   * @param children the schema\n+   * @throws IllegalArgumentException if children is a non-empty list for scalar types.\n+   */\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (!children.isEmpty()) {\n+      throw new IllegalArgumentException(\"primitive type vector can not have children\");\n+    }\n+  }\n+\n+  /**\n+   * Get the inner child vectors.\n+   * @return list of child vectors for complex types, empty list for scalar vector\n+   * types\n+   */\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return Collections.emptyList();\n+  }\n+\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+    ArrowBuf dataBuffer = ownBuffers.get(2);\n+\n+    validityBuffer.release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.release();\n+    offsetBuffer = offBuffer.retain(allocator);\n+    valueBuffer.release();\n+    valueBuffer = dataBuffer.retain(allocator);\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector\n+   * @return the inner buffers.\n+   */\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(3);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+    result.add(valueBuffer);\n+\n+    return result;\n+  }\n+\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    valueBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+      valueBuffer.writerIndex(0);\n+    } else {\n+      final int lastDataOffset = getstartOffset(valueCount);\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+      valueBuffer.writerIndex(lastDataOffset);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory.\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector. See {@link #allocateNew(int, int)} for allocating memory for specific\n+   * number of elements in the vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  @Override\n+  public boolean allocateNewSafe() {\n+    long curAllocationSizeValue = valueAllocationSizeInBytes;\n+    long curAllocationSizeValidity = validityAllocationSizeInBytes;\n+    long curAllocationSizeOffset = offsetAllocationSizeInBytes;\n+\n+    if (curAllocationSizeValue > MAX_ALLOCATION_SIZE ||\n+            curAllocationSizeOffset > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory exceeds limit\");\n+    }\n+\n+      /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(curAllocationSizeValue, curAllocationSizeValidity, curAllocationSizeOffset);\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Allocate memory for the vector to support storing at least the provided number of\n+   * elements in the vector. This method must be called prior to using the ValueVector.\n+   *\n+   * @param totalBytes desired total memory capacity\n+   * @param valueCount the desired number of elements in the vector\n+   * @throws org.apache.arrow.memory.OutOfMemoryException\n+   */\n+  @Override\n+  public void allocateNew(int totalBytes, int valueCount) {\n+    assert totalBytes >= 0;\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+\n+    if (totalBytes > MAX_ALLOCATION_SIZE ||\n+            offsetBufferSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory exceeds limit\");\n+    }\n+\n+      /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(totalBytes, validityBufferSize, offsetBufferSize);\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+    }\n+  }\n+\n+  /* allocate the inner buffers */\n+  private void allocateBytes(final long valueBufferSize, final long validityBufferSize,\n+                             final long offsetBufferSize) {\n+      /* allocate data buffer */\n+    int curSize = (int) valueBufferSize;\n+    valueBuffer = allocator.buffer(curSize);\n+    valueBuffer.readerIndex(0);\n+    valueAllocationSizeInBytes = curSize;\n+    allocateValidityBuffer(validityBufferSize);\n+    allocateOffsetBuffer(offsetBufferSize);\n+  }\n+\n+  /* allocate offset buffer */\n+  private void allocateOffsetBuffer(final long size) {\n+    final int curSize = (int) size;\n+    offsetBuffer = allocator.buffer(curSize);\n+    offsetBuffer.readerIndex(0);\n+    offsetAllocationSizeInBytes = curSize;\n+    initOffsetBuffer();\n+  }\n+\n+  /* allocate validity buffer */\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    initValidityBuffer();\n+  }\n+\n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  public void reAlloc() {\n+    reallocDataBuffer();\n+    reallocValidityAndOffsetBuffers();\n+  }\n+\n+  /**\n+   * Reallocate the data buffer. Data Buffer stores the actual data for\n+   * VARCHAR or VARBINARY elements in the vector. The behavior is to double\n+   * the size of buffer.\n+   * @throws OversizedAllocationException if the desired new size is more than\n+   *                                      max allowed\n+   * @throws OutOfMemoryException if the internal memory allocation fails\n+   */\n+  public void reallocDataBuffer() {\n+    long baseSize = valueAllocationSizeInBytes;\n+    final int currentBufferCapacity = valueBuffer.capacity();\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, valueBuffer, 0, currentBufferCapacity);\n+    valueBuffer.release();\n+    valueBuffer = newBuf;\n+    valueAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  /**\n+   * Reallocate the validity and offset buffers for this vector. Validity\n+   * buffer is used to track the NULL or NON-NULL nature of elements in\n+   * the vector and offset buffer is used to store the lengths of variable\n+   * width elements in the vector.\n+   *\n+   * Note that data buffer for variable length vectors moves independent\n+   * of the companion validity and offset buffers. This is in\n+   * contrast to what we have for fixed width vectors.\n+   *\n+   * So even though we may have setup an initial capacity of 1024\n+   * elements in the vector, it is quite possible\n+   * that we need to reAlloc() the data buffer when we are setting\n+   * the 5th element in the vector simply because previous\n+   * variable length elements have exhausted the buffer capacity.\n+   * However, we really don't need to reAlloc() validity and\n+   * offset buffers until we try to set the 1025th element\n+   * This is why we do a separate check for safe methods to\n+   * determine which buffer needs reallocation.\n+   * @throws OversizedAllocationException if the desired new size is more than\n+   *                                      max allowed\n+   * @throws OutOfMemoryException if the internal memory allocation fails\n+   */\n+  public void reallocValidityAndOffsetBuffers() {\n+    offsetBuffer = reallocBufferHelper(offsetBuffer, true);\n+    validityBuffer = reallocBufferHelper(validityBuffer, false);\n+  }\n+\n+  /* helper method to realloc a particular buffer. returns the allocated buffer */\n+  private ArrowBuf reallocBufferHelper(ArrowBuf buffer, final boolean offsetBuffer) {\n+    final int currentBufferCapacity = buffer.capacity();\n+    long baseSize = (offsetBuffer ? offsetAllocationSizeInBytes\n+            : validityAllocationSizeInBytes);\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, buffer, 0, currentBufferCapacity);\n+    final int halfNewCapacity = newBuf.capacity() / 2;\n+    newBuf.setZero(halfNewCapacity, halfNewCapacity);\n+    buffer.release(1);\n+    buffer = newBuf;\n+    if (offsetBuffer) {\n+      offsetAllocationSizeInBytes = (int) newAllocationSize;\n+    } else {\n+      validityAllocationSizeInBytes = (int) newAllocationSize;\n+    }\n+\n+    return buffer;\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying data buffer.\n+   * @return\n+   */\n+  @Override\n+  public int getByteCapacity() {\n+    return valueBuffer.capacity();\n+  }\n+\n+  @Override\n+  public int getCurrentSizeInBytes() {\n+      /* TODO */\n+    return 0;\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    return getBufferSizeFor(this.valueCount);\n+  }\n+\n+  /**\n+   * Get the potential buffer size for a particular number of records.\n+   * @param valueCount desired number of elements in the vector\n+   * @return estimated size of underlying buffers if the vector holds\n+   *         a given number of elements\n+   */\n+  @Override\n+  public int getBufferSizeFor(final int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+      /* get the end offset for this valueCount */\n+    final int dataBufferSize = offsetBuffer.getInt(valueCount * OFFSET_WIDTH);\n+    return validityBufferSize + offsetBufferSize + dataBufferSize;\n+  }\n+\n+  /**\n+   * Get information about how this field is materialized.\n+   * @return the field corresponding to this vector\n+   */\n+  @Override\n+  public Field getField() {\n+    return field;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    final ArrowBuf[] buffers;\n+    setReaderAndWriterIndex();\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = new ArrowBuf[3];\n+      buffers[0] = validityBuffer;\n+      buffers[1] = offsetBuffer;\n+      buffers[2] = valueBuffer;\n+    }\n+    if (clear) {\n+      for (final ArrowBuf buffer : buffers) {\n+        buffer.retain(1);\n+      }\n+      clear();\n+    }\n+    return buffers;\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @param callBack\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return getTransferPair(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(BufferAllocator allocator) {\n+    return getTransferPair(name, allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  public abstract TransferPair getTransferPair(String ref, BufferAllocator allocator);\n+\n+  /**\n+   * Transfer this vector'data to another vector. The memory associated\n+   * with this vector is transferred to the allocator of target vector\n+   * for accounting and management purposes.\n+   * @param target destination vector for transfer\n+   */\n+  public void transferTo(BaseNullableVariableWidthVector target) {\n+    compareTypes(target, \"transferTo\");\n+    target.clear();\n+    target.validityBuffer = validityBuffer.transferOwnership(target.allocator).buffer;\n+    target.valueBuffer = valueBuffer.transferOwnership(target.allocator).buffer;\n+    target.offsetBuffer = offsetBuffer.transferOwnership(target.allocator).buffer;\n+    target.setLastSet(this.lastSet);\n+    if (this.valueCount > 0) {\n+      target.setValueCount(this.valueCount);\n+    }\n+    clear();\n+  }\n+\n+  /**\n+   * Slice this vector at desired index and length and transfer the\n+   * corresponding data to the target vector.\n+   * @param startIndex start position of the split in source vector.\n+   * @param length length of the split.\n+   * @param target destination vector\n+   */\n+  public void splitAndTransferTo(int startIndex, int length,\n+                                 BaseNullableVariableWidthVector target) {\n+    compareTypes(target, \"splitAndTransferTo\");\n+    target.clear();\n+    splitAndTransferValidityBuffer(startIndex, length, target);\n+    splitAndTransferOffsetBuffer(startIndex, length, target);\n+    target.setLastSet(length - 1);\n+    if (this.valueCount > 0) {\n+      target.setValueCount(this.valueCount);\n+    }\n+  }\n+\n+  /*\n+   * Transfer the offsets along with data. Unlike the data buffer, we cannot simply\n+   * slice the offset buffer for split and transfer. The reason is that offsets\n+   * in the target vector have to be adjusted and made relative to the staring\n+   * offset in source vector from the start index of split. This is why, we\n+   * need to explicitly allocate the offset buffer and set the adjusted offsets\n+   * in the target vector.\n+   */\n+  private void splitAndTransferOffsetBuffer(int startIndex, int length, BaseNullableVariableWidthVector target) {\n+    final int start = offsetBuffer.getInt(startIndex * OFFSET_WIDTH);\n+    final int end = offsetBuffer.getInt((startIndex + length) * OFFSET_WIDTH);\n+    final int dataLength = end - start;\n+    target.allocateOffsetBuffer((length + 1) * OFFSET_WIDTH);\n+    for (int i = 0; i < length + 1; i++) {\n+      final int relativeSourceOffset = offsetBuffer.getInt((startIndex + i) * OFFSET_WIDTH) - start;\n+      target.offsetBuffer.setInt(i * OFFSET_WIDTH, relativeSourceOffset);\n+    }\n+    target.valueBuffer = valueBuffer.slice(start, dataLength).transferOwnership(target.allocator).buffer;\n+  }\n+\n+  /*\n+   * Transfer the validity.\n+   */\n+  private void splitAndTransferValidityBuffer(int startIndex, int length,\n+                                              BaseNullableVariableWidthVector target) {\n+    assert startIndex + length <= valueCount;\n+    int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+    int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+    int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+    int offset = startIndex % 8;\n+\n+    if (length > 0) {\n+      if (offset == 0) {\n+        // slice\n+        if (target.validityBuffer != null) {\n+          target.validityBuffer.release();\n+        }\n+        target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+        target.validityBuffer.retain(1);\n+      } else {\n+            /* Copy data\n+             * When the first bit starts from the middle of a byte (offset != 0),\n+             * copy data from src BitVector.\n+             * Each byte in the target is composed by a part in i-th byte,\n+             * another part in (i+1)-th byte.\n+             */\n+        target.allocateValidityBuffer(byteSizeTarget);\n+\n+        for (int i = 0; i < byteSizeTarget - 1; i++) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer, firstByteSource + i, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer, firstByteSource + i + 1, offset);\n+\n+          target.validityBuffer.setByte(i, (b1 + b2));\n+        }\n+\n+            /* Copying the last piece is done in the following manner:\n+             * if the source vector has 1 or more bytes remaining, we copy\n+             * the last piece as a byte formed by shifting data\n+             * from the current byte and the next byte.\n+             *\n+             * if the source vector has no more bytes remaining\n+             * (we are at the last byte), we copy the last piece as a byte\n+             * by shifting data from the current byte.\n+             */\n+        if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer,\n+                  firstByteSource + byteSizeTarget, offset);\n+\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+        } else {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+        }\n+      }\n+    }\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                common getters and setters                      *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the number of elements that are null in the vector\n+   *\n+   * @return the number of null elements.\n+   */\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  /**\n+   * Check if the given index is within the current value capacity\n+   * of the vector\n+   *\n+   * @param index  position to check\n+   * @return true if index is within the current value capacity\n+   */\n+  public boolean isSafe(int index) {\n+    return index < getValueCapacity();\n+  }\n+\n+  /**\n+   * Check if element at given index is null.\n+   *\n+   * @param index  position of element\n+   * @return true if element at given index is null\n+   */\n+  public boolean isNull(int index) {\n+    return (isSet(index) == 0);\n+  }\n+\n+  /**\n+   * Same as {@link #isNull(int)}.\n+   *\n+   * @param index  position of element\n+   * @return 1 if element at given index is not null, 0 otherwise\n+   */\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return Long.bitCount(b & (1L << bitIndex));\n+  }\n+\n+  /**\n+   * Get the value count of vector. This will always be zero unless\n+   * setValueCount(int) has been called prior to calling this.\n+   *\n+   * @return valueCount for the vector\n+   */\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n+\n+  /**\n+   * Sets the value count for the vector\n+   *\n+   * @param valueCount   value count\n+   */\n+  public void setValueCount(int valueCount) {\n+    assert valueCount >= 0;\n+    this.valueCount = valueCount;\n+    while (valueCount > getValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    fillHoles(valueCount);\n+    lastSet = valueCount - 1;\n+    setReaderAndWriterIndex();\n+  }\n+\n+  /**\n+   * Create holes in the vector upto the given index (exclusive).\n+   * Holes will be created from the current last set position in\n+   * the vector.\n+   *\n+   * @param index target index\n+   */\n+  public void fillEmpties(int index) {\n+    handleSafe(index, emptyByteArray.length);\n+    fillHoles(index);\n+    lastSet = index - 1;\n+  }\n+\n+  /**\n+   * Set the index of last non-null element in the vector.\n+   * It is important to call this method with appropriate value\n+   * before calling {@link #setValueCount(int)}.\n+   *\n+   * @param value desired index of last non-null element.\n+   */\n+  public void setLastSet(int value) {\n+    lastSet = value;\n+  }\n+\n+  /**\n+   * Get the index of last non-null element in the vector.\n+   *\n+   * @return index of the last non-null element\n+   */\n+  public int getLastSet() {\n+    return lastSet;\n+  }\n+\n+  /**\n+   * Get the starting position (offset) in the data stream for a given\n+   * element in the vector.\n+   *\n+   * @param index position of the element in the vector\n+   * @return starting offset for the element\n+   */\n+  public long getStartEnd(int index) {\n+    return offsetBuffer.getLong(index * OFFSET_WIDTH);\n+  }\n+\n+  /**\n+   * Mark the particular position in the vector as non-null.\n+   *\n+   * @param index position of the element.\n+   */\n+  @Override\n+  public void setIndexDefined(int index) {\n+    while (index >= getValidityBufferValueCapacity()) {\n+      validityBuffer = reallocBufferHelper(validityBuffer, false);\n+    }\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+  }\n+\n+  /**\n+   * Sets the value length for an element.\n+   *\n+   * @param index   position of the element to set\n+   * @param length  length of the element\n+   */\n+  public void setValueLengthSafe(int index, int length) {\n \n Review comment:\n   Thanks for the clarification - I wasn't sure which APIs are from the old vectors and which APIs are added.\r\n   \r\n   Looks good then.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T20:54:20.746+0000",
                    "updated": "2017-11-15T20:54:20.746+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16254166",
                    "id": "16254166",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344725439\n \n \n   LGTM. +1. \r\n   \r\n   Thanks @siddharthteotia for the epic effort!\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T20:55:54.319+0000",
                    "updated": "2017-11-15T20:55:54.319+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16254215",
                    "id": "16254215",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344732144\n \n \n   Sweet, thanks all! I will take care of merging to master (and squashing the commits between the last refactor patch and now)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T21:21:29.155+0000",
                    "updated": "2017-11-15T21:21:29.155+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16254224",
                    "id": "16254224",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344733804\n \n \n   +1, great work @siddharthteotia !\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T21:26:57.743+0000",
                    "updated": "2017-11-15T21:26:57.743+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16254258",
                    "id": "16254258",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316#issuecomment-344738429\n \n \n   merged to master. thank you!\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T21:44:06.455+0000",
                    "updated": "2017-11-15T21:44:06.455+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16254259",
                    "id": "16254259",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm closed pull request #1316: ARROW-1476: [JAVA] Implement Final ValueVector Updates\nURL: https://github.com/apache/arrow/pull/1316\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/java/tools/src/test/java/org/apache/arrow/tools/ArrowFileTestFixtures.java b/java/tools/src/test/java/org/apache/arrow/tools/ArrowFileTestFixtures.java\nindex 6d9a6c132..c56a5a330 100644\n--- a/java/tools/src/test/java/org/apache/arrow/tools/ArrowFileTestFixtures.java\n+++ b/java/tools/src/test/java/org/apache/arrow/tools/ArrowFileTestFixtures.java\n@@ -78,8 +78,8 @@ static void validateOutput(File testOutFile, BufferAllocator allocator) throws E\n   static void validateContent(int count, VectorSchemaRoot root) {\n     Assert.assertEquals(count, root.getRowCount());\n     for (int i = 0; i < count; i++) {\n-      Assert.assertEquals(i, root.getVector(\"int\").getAccessor().getObject(i));\n-      Assert.assertEquals(Long.valueOf(i), root.getVector(\"bigInt\").getAccessor().getObject(i));\n+      Assert.assertEquals(i, root.getVector(\"int\").getObject(i));\n+      Assert.assertEquals(Long.valueOf(i), root.getVector(\"bigInt\").getObject(i));\n     }\n   }\n \ndiff --git a/java/tools/src/test/java/org/apache/arrow/tools/EchoServerTest.java b/java/tools/src/test/java/org/apache/arrow/tools/EchoServerTest.java\nindex ecac6d6e5..89714e447 100644\n--- a/java/tools/src/test/java/org/apache/arrow/tools/EchoServerTest.java\n+++ b/java/tools/src/test/java/org/apache/arrow/tools/EchoServerTest.java\n@@ -104,10 +104,10 @@ private void testEchoServer(int serverPort,\n       for (int i = 0; i < batches; i++) {\n         vector.allocateNew(16);\n         for (int j = 0; j < 8; j++) {\n-          vector.getMutator().set(j, j + i);\n-          vector.getMutator().set(j + 8, 0, (byte) (j + i));\n+          vector.set(j, j + i);\n+          vector.set(j + 8, 0, (byte) (j + i));\n         }\n-        vector.getMutator().setValueCount(16);\n+        vector.setValueCount(16);\n         root.setRowCount(16);\n         writer.writeBatch();\n       }\n@@ -120,10 +120,10 @@ private void testEchoServer(int serverPort,\n       for (int i = 0; i < batches; i++) {\n         Assert.assertTrue(reader.loadNextBatch());\n         assertEquals(16, reader.getVectorSchemaRoot().getRowCount());\n-        assertEquals(16, readVector.getAccessor().getValueCount());\n+        assertEquals(16, readVector.getValueCount());\n         for (int j = 0; j < 8; j++) {\n-          assertEquals(j + i, readVector.getAccessor().get(j));\n-          assertTrue(readVector.getAccessor().isNull(j + 8));\n+          assertEquals(j + i, readVector.get(j));\n+          assertTrue(readVector.isNull(j + 8));\n         }\n       }\n       Assert.assertFalse(reader.loadNextBatch());\n@@ -169,20 +169,18 @@ public void testFlatDictionary() throws IOException {\n                  FieldType.nullable(VARCHAR.getType()),\n                  allocator)) {\n       writeVector.allocateNewSafe();\n-      NullableIntVector.Mutator mutator = writeVector.getMutator();\n-      mutator.set(0, 0);\n-      mutator.set(1, 1);\n-      mutator.set(3, 2);\n-      mutator.set(4, 1);\n-      mutator.set(5, 2);\n-      mutator.setValueCount(6);\n+      writeVector.set(0, 0);\n+      writeVector.set(1, 1);\n+      writeVector.set(3, 2);\n+      writeVector.set(4, 1);\n+      writeVector.set(5, 2);\n+      writeVector.setValueCount(6);\n \n       writeDictionaryVector.allocateNewSafe();\n-      NullableVarCharVector.Mutator dictionaryMutator = writeDictionaryVector.getMutator();\n-      dictionaryMutator.set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n-      dictionaryMutator.set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n-      dictionaryMutator.set(2, \"baz\".getBytes(StandardCharsets.UTF_8));\n-      dictionaryMutator.setValueCount(3);\n+      writeDictionaryVector.set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n+      writeDictionaryVector.set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n+      writeDictionaryVector.set(2, \"baz\".getBytes(StandardCharsets.UTF_8));\n+      writeDictionaryVector.setValueCount(3);\n \n       List<Field> fields = ImmutableList.of(writeVector.getField());\n       List<FieldVector> vectors = ImmutableList.of((FieldVector) writeVector);\n@@ -210,23 +208,21 @@ public void testFlatDictionary() throws IOException {\n         Assert.assertNotNull(readEncoding);\n         Assert.assertEquals(1L, readEncoding.getId());\n \n-        FieldVector.Accessor accessor = readVector.getAccessor();\n-        Assert.assertEquals(6, accessor.getValueCount());\n-        Assert.assertEquals(0, accessor.getObject(0));\n-        Assert.assertEquals(1, accessor.getObject(1));\n-        Assert.assertEquals(null, accessor.getObject(2));\n-        Assert.assertEquals(2, accessor.getObject(3));\n-        Assert.assertEquals(1, accessor.getObject(4));\n-        Assert.assertEquals(2, accessor.getObject(5));\n+        Assert.assertEquals(6, readVector.getValueCount());\n+        Assert.assertEquals(0, readVector.getObject(0));\n+        Assert.assertEquals(1, readVector.getObject(1));\n+        Assert.assertEquals(null, readVector.getObject(2));\n+        Assert.assertEquals(2, readVector.getObject(3));\n+        Assert.assertEquals(1, readVector.getObject(4));\n+        Assert.assertEquals(2, readVector.getObject(5));\n \n         Dictionary dictionary = reader.lookup(1L);\n         Assert.assertNotNull(dictionary);\n-        NullableVarCharVector.Accessor dictionaryAccessor = ((NullableVarCharVector) dictionary\n-            .getVector()).getAccessor();\n-        Assert.assertEquals(3, dictionaryAccessor.getValueCount());\n-        Assert.assertEquals(new Text(\"foo\"), dictionaryAccessor.getObject(0));\n-        Assert.assertEquals(new Text(\"bar\"), dictionaryAccessor.getObject(1));\n-        Assert.assertEquals(new Text(\"baz\"), dictionaryAccessor.getObject(2));\n+        NullableVarCharVector dictionaryVector = ((NullableVarCharVector) dictionary.getVector());\n+        Assert.assertEquals(3, dictionaryVector.getValueCount());\n+        Assert.assertEquals(new Text(\"foo\"), dictionaryVector.getObject(0));\n+        Assert.assertEquals(new Text(\"bar\"), dictionaryVector.getObject(1));\n+        Assert.assertEquals(new Text(\"baz\"), dictionaryVector.getObject(2));\n       }\n     }\n   }\n@@ -243,9 +239,9 @@ public void testNestedDictionary() throws IOException {\n       // [['foo', 'bar'], ['foo'], ['bar']] -> [[0, 1], [0], [1]]\n \n       writeDictionaryVector.allocateNew();\n-      writeDictionaryVector.getMutator().set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n-      writeDictionaryVector.getMutator().set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n-      writeDictionaryVector.getMutator().setValueCount(2);\n+      writeDictionaryVector.set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n+      writeDictionaryVector.set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n+      writeDictionaryVector.setValueCount(2);\n \n       writeVector.addOrGetVector(new FieldType(true, MinorType.INT.getType(), writeEncoding, null));\n       writeVector.allocateNew();\n@@ -297,19 +293,17 @@ public void testNestedDictionary() throws IOException {\n         Assert.assertEquals(2L, encoding.getId());\n         Assert.assertEquals(new Int(32, true), encoding.getIndexType());\n \n-        ListVector.Accessor accessor = readVector.getAccessor();\n-        Assert.assertEquals(3, accessor.getValueCount());\n-        Assert.assertEquals(Arrays.asList(0, 1), accessor.getObject(0));\n-        Assert.assertEquals(Arrays.asList(0), accessor.getObject(1));\n-        Assert.assertEquals(Arrays.asList(1), accessor.getObject(2));\n+        Assert.assertEquals(3, readVector.getValueCount());\n+        Assert.assertEquals(Arrays.asList(0, 1), readVector.getObject(0));\n+        Assert.assertEquals(Arrays.asList(0), readVector.getObject(1));\n+        Assert.assertEquals(Arrays.asList(1), readVector.getObject(2));\n \n         Dictionary readDictionary = reader.lookup(2L);\n         Assert.assertNotNull(readDictionary);\n-        NullableVarCharVector.Accessor dictionaryAccessor = ((NullableVarCharVector)\n-            readDictionary.getVector()).getAccessor();\n-        Assert.assertEquals(2, dictionaryAccessor.getValueCount());\n-        Assert.assertEquals(new Text(\"foo\"), dictionaryAccessor.getObject(0));\n-        Assert.assertEquals(new Text(\"bar\"), dictionaryAccessor.getObject(1));\n+        NullableVarCharVector dictionaryVector = ((NullableVarCharVector) readDictionary.getVector());\n+        Assert.assertEquals(2, dictionaryVector.getValueCount());\n+        Assert.assertEquals(new Text(\"foo\"), dictionaryVector.getObject(0));\n+        Assert.assertEquals(new Text(\"bar\"), dictionaryVector.getObject(1));\n       }\n     }\n   }\ndiff --git a/java/vector/src/main/codegen/templates/ComplexReaders.java b/java/vector/src/main/codegen/templates/ComplexReaders.java\nindex 38cd1bfde..60347a2fc 100644\n--- a/java/vector/src/main/codegen/templates/ComplexReaders.java\n+++ b/java/vector/src/main/codegen/templates/ComplexReaders.java\n@@ -70,7 +70,7 @@ public Field getField(){\n   \n   public boolean isSet(){\n     <#if nullMode == \"Nullable\">\n-    return !vector.getAccessor().isNull(idx());\n+        return !vector.isNull(idx());\n     <#else>\n     return true;\n     </#if>\n@@ -93,11 +93,11 @@ public void read(${minor.class?cap_first}Holder h){\n   </#if>\n \n   public void read(Nullable${minor.class?cap_first}Holder h){\n-    vector.getAccessor().get(idx(), h);\n+    vector.get(idx(), h);\n   }\n   \n   public ${friendlyType} read${safeType}(){\n-    return vector.getAccessor().getObject(idx());\n+    return vector.getObject(idx());\n   }\n \n   <#if minor.class == \"TimeStampSec\" ||\n@@ -106,7 +106,7 @@ public void read(Nullable${minor.class?cap_first}Holder h){\n        minor.class == \"TimeStampNano\">\n   @Override\n   public ${minor.boxedType} read${minor.boxedType}(){\n-    return vector.getAccessor().get(idx());\n+    return vector.get(idx());\n   }\n   </#if>\n   \n@@ -115,7 +115,7 @@ public void copyValue(FieldWriter w){\n   }\n   \n   public Object readObject(){\n-    return vector.getAccessor().getObject(idx());\n+    return (Object)vector.getObject(idx());\n   }\n }\n </#if>\ndiff --git a/java/vector/src/main/codegen/templates/ComplexWriters.java b/java/vector/src/main/codegen/templates/ComplexWriters.java\nindex fe099bede..406bbb39c 100644\n--- a/java/vector/src/main/codegen/templates/ComplexWriters.java\n+++ b/java/vector/src/main/codegen/templates/ComplexWriters.java\n@@ -39,11 +39,9 @@\n @SuppressWarnings(\"unused\")\n public class ${eName}WriterImpl extends AbstractFieldWriter {\n \n-  private final Nullable${name}Vector.Mutator mutator;\n   final Nullable${name}Vector vector;\n \n   public ${eName}WriterImpl(Nullable${name}Vector vector) {\n-    this.mutator = vector.getMutator();\n     this.vector = vector;\n   }\n \n@@ -103,31 +101,31 @@ public void setPosition(int idx) {\n   <#else>\n \n   public void write(${minor.class}Holder h) {\n-    mutator.setSafe(idx(), h);\n-    vector.getMutator().setValueCount(idx()+1);\n+    vector.setSafe(idx(), h);\n+    vector.setValueCount(idx()+1);\n   }\n \n   public void write(Nullable${minor.class}Holder h) {\n-    mutator.setSafe(idx(), h);\n-    vector.getMutator().setValueCount(idx()+1);\n+    vector.setSafe(idx(), h);\n+    vector.setValueCount(idx()+1);\n   }\n \n   public void write${minor.class}(<#list fields as field>${field.type} ${field.name}<#if field_has_next>, </#if></#list>) {\n-    mutator.setSafe(idx()<#if mode == \"Nullable\">, 1</#if><#list fields as field><#if field.include!true >, ${field.name}</#if></#list>);\n-    vector.getMutator().setValueCount(idx()+1);\n+    vector.setSafe(idx()<#if mode == \"Nullable\">, 1</#if><#list fields as field><#if field.include!true >, ${field.name}</#if></#list>);\n+    vector.setValueCount(idx()+1);\n   }\n-  <#if minor.class == \"Decimal\">\n \n+  <#if minor.class == \"Decimal\">\n   public void write${minor.class}(${friendlyType} value) {\n-    mutator.setSafe(idx(), value);\n-    vector.getMutator().setValueCount(idx()+1);\n+    vector.setSafe(idx(), value);\n+    vector.setValueCount(idx()+1);\n   }\n   </#if>\n-  <#if mode == \"Nullable\">\n \n+  <#if mode == \"Nullable\">\n   public void writeNull() {\n-    mutator.setNull(idx());\n-    vector.getMutator().setValueCount(idx()+1);\n+    vector.setNull(idx());\n+    vector.setValueCount(idx()+1);\n   }\n   </#if>\n   </#if>\ndiff --git a/java/vector/src/main/codegen/templates/MapWriters.java b/java/vector/src/main/codegen/templates/MapWriters.java\nindex b89f91457..6afd508e6 100644\n--- a/java/vector/src/main/codegen/templates/MapWriters.java\n+++ b/java/vector/src/main/codegen/templates/MapWriters.java\n@@ -184,7 +184,7 @@ public ListWriter list(String name) {\n   }\n \n   public void setValueCount(int count) {\n-    container.getMutator().setValueCount(count);\n+    container.setValueCount(count);\n   }\n \n   @Override\n@@ -199,7 +199,7 @@ public void setPosition(int index) {\n   public void start() {\n     <#if mode == \"Single\">\n     <#else>\n-    container.getMutator().setIndexDefined(idx());\n+    container.setIndexDefined(idx());\n     </#if>\n   }\n \ndiff --git a/java/vector/src/main/codegen/templates/NullableValueVectors.java b/java/vector/src/main/codegen/templates/NullableValueVectors.java\ndeleted file mode 100644\nindex 122cd2364..000000000\n--- a/java/vector/src/main/codegen/templates/NullableValueVectors.java\n+++ /dev/null\n@@ -1,776 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-<@pp.dropOutputFile />\n-<#list vv.types as type>\n-<#list type.minor as minor>\n-\n-<#assign className = \"Nullable${minor.class}Vector\" />\n-<#assign valuesName = \"${minor.class}Vector\" />\n-<#assign friendlyType = (minor.friendlyType!minor.boxedType!type.boxedType) />\n-\n-<@pp.changeOutputFile name=\"/org/apache/arrow/vector/${className}.java\" />\n-\n-<#include \"/@includes/license.ftl\" />\n-\n-package org.apache.arrow.vector;\n-\n-import org.apache.arrow.vector.schema.ArrowFieldNode;\n-import java.util.Collections;\n-\n-<#include \"/@includes/vv_imports.ftl\" />\n-\n-import org.apache.arrow.flatbuf.Precision;\n-\n-/**\n- * ${className} implements a vector of values which could be null.  Elements in the vector\n- * are first checked against a fixed length vector of boolean values.  Then the element is retrieved\n- * from the base class (if not null).\n- *\n- * NB: this class is automatically generated from ${.template_name} and ValueVectorTypes.tdd using FreeMarker.\n- */\n-@SuppressWarnings(\"unused\")\n-public final class ${className} extends BaseValueVector implements <#if type.major == \"VarLen\">VariableWidth<#else>FixedWidth</#if>Vector, NullableVector, FieldVector {\n-  private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(${className}.class);\n-\n-protected final static byte[] emptyByteArray = new byte[]{};\n-  private final FieldReader reader = new ${minor.class}ReaderImpl(${className}.this);\n-\n-  private final String bitsField = \"$bits$\";\n-  private final String valuesField = \"$values$\";\n-  private final Field field;\n-\n-  final BitVector bits = new BitVector(bitsField, allocator);\n-  final ${valuesName} values;\n-\n-  private final Mutator mutator;\n-  private final Accessor accessor;\n-\n-  private final List<BufferBacked> innerVectors;\n-\n-  <#if minor.typeParams??>\n-    <#assign typeParams = minor.typeParams?reverse>\n-    <#list typeParams as typeParam>\n-  private final ${typeParam.type} ${typeParam.name};\n-    </#list>\n-\n-  /**\n-   * Assumes the type is nullable and not dictionary encoded\n-   * @param name name of the field\n-   * @param allocator allocator to use to resize the vector<#list typeParams as typeParam>\n-   * @param ${typeParam.name} type parameter ${typeParam.name}</#list>\n-   */\n-  public ${className}(String name, BufferAllocator allocator<#list typeParams as typeParam>, ${typeParam.type} ${typeParam.name}</#list>) {\n-    <#if minor.arrowTypeConstructorParams??>\n-       <#assign constructorParams = minor.arrowTypeConstructorParams />\n-    <#else>\n-       <#assign constructorParams = [] />\n-       <#list typeParams as typeParam>\n-         <#assign constructorParams = constructorParams + [ typeParam.name ] />\n-      </#list>\n-    </#if>\n-    this(name, FieldType.nullable(new ${minor.arrowType}(${constructorParams?join(\", \")})), allocator);\n-  }\n-  <#else>\n-  public ${className}(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(org.apache.arrow.vector.types.Types.MinorType.${minor.class?upper_case}.getType()), allocator);\n-  }\n-  </#if>\n-\n-  public ${className}(String name, FieldType fieldType, BufferAllocator allocator) {\n-    super(name, allocator);\n-    <#if minor.typeParams??>\n-    <#assign typeParams = minor.typeParams?reverse>\n-    ${minor.arrowType} arrowType = (${minor.arrowType})fieldType.getType();\n-    <#list typeParams as typeParam>\n-    this.${typeParam.name} = arrowType.get${typeParam.name?cap_first}();\n-    </#list>\n-    this.values = new ${valuesName}(valuesField, allocator<#list typeParams as typeParam>, ${typeParam.name}</#list>);\n-    <#else>\n-    this.values = new ${valuesName}(valuesField, allocator);\n-    </#if>\n-    this.mutator = new Mutator();\n-    this.accessor = new Accessor();\n-    this.field = new Field(name, fieldType, null);\n-    innerVectors = Collections.unmodifiableList(Arrays.<BufferBacked>asList(\n-        bits,\n-        <#if type.major = \"VarLen\">\n-        values.offsetVector,\n-        </#if>\n-        values\n-    ));\n-  }\n-\n-  @Override\n-  public BitVector getValidityVector() {\n-    return bits;\n-  }\n-\n-  @Override\n-  public List<BufferBacked> getFieldInnerVectors() {\n-    return innerVectors;\n-  }\n-\n-  @Override\n-  public void initializeChildrenFromFields(List<Field> children) {\n-    if (!children.isEmpty()) {\n-      throw new IllegalArgumentException(\"primitive type vector ${className} can not have children: \" + children);\n-    }\n-  }\n-\n-  @Override\n-  public List<FieldVector> getChildrenFromFields() {\n-    return Collections.emptyList();\n-  }\n-\n-  @Override\n-  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n-    <#if type.major = \"VarLen\">\n-    // variable width values: truncate offset vector buffer to size (#1)\n-    org.apache.arrow.vector.BaseDataValueVector.truncateBufferBasedOnSize(ownBuffers, 1,\n-        values.offsetVector.getBufferSizeFor(\n-        fieldNode.getLength() == 0? 0 : fieldNode.getLength() + 1));\n-    mutator.lastSet = fieldNode.getLength() - 1;\n-    <#else>\n-    // fixed width values truncate value vector to size (#1)\n-    org.apache.arrow.vector.BaseDataValueVector.truncateBufferBasedOnSize(ownBuffers, 1, values.getBufferSizeFor(fieldNode.getLength()));\n-    </#if>\n-    org.apache.arrow.vector.BaseDataValueVector.load(fieldNode, getFieldInnerVectors(), ownBuffers);\n-    bits.valueCount = fieldNode.getLength();\n-  }\n-\n-  public List<ArrowBuf> getFieldBuffers() {\n-    return org.apache.arrow.vector.BaseDataValueVector.unload(getFieldInnerVectors());\n-  }\n-\n-  @Override\n-  public Field getField() {\n-    return field;\n-  }\n-\n-  @Override\n-  public MinorType getMinorType() {\n-    return MinorType.${minor.class?upper_case};\n-  }\n-\n-  @Override\n-  public FieldReader getReader(){\n-    return reader;\n-  }\n-\n-  @Override\n-  public int getValueCapacity(){\n-    return Math.min(bits.getValueCapacity(), values.getValueCapacity());\n-  }\n-\n-  @Override\n-  public ArrowBuf[] getBuffers(boolean clear) {\n-    final ArrowBuf[] buffers = ObjectArrays.concat(bits.getBuffers(false), values.getBuffers(false), ArrowBuf.class);\n-    if (clear) {\n-      for (final ArrowBuf buffer:buffers) {\n-        buffer.retain(1);\n-      }\n-      clear();\n-    }\n-    return buffers;\n-  }\n-\n-  @Override\n-  public void close() {\n-    bits.close();\n-    values.close();\n-    super.close();\n-  }\n-\n-  @Override\n-  public void clear() {\n-    bits.clear();\n-    values.clear();\n-    super.clear();\n-  }\n-\n-  @Override\n-  public int getBufferSize(){\n-    return values.getBufferSize() + bits.getBufferSize();\n-  }\n-\n-  @Override\n-  public int getBufferSizeFor(final int valueCount) {\n-    if (valueCount == 0) {\n-      return 0;\n-    }\n-\n-    return values.getBufferSizeFor(valueCount)\n-        + bits.getBufferSizeFor(valueCount);\n-  }\n-\n-  public ArrowBuf getBuffer() {\n-    return values.getDataBuffer();\n-  }\n-\n-  @Override\n-  public ${valuesName} getValuesVector() {\n-    return values;\n-  }\n-\n-  @Override\n-  public void setInitialCapacity(int numRecords) {\n-    bits.setInitialCapacity(numRecords);\n-    values.setInitialCapacity(numRecords);\n-  }\n-\n-  @Override\n-  public void allocateNew() {\n-    if(!allocateNewSafe()){\n-      throw new OutOfMemoryException(\"Failure while allocating buffer.\");\n-    }\n-  }\n-\n-  @Override\n-  public boolean allocateNewSafe() {\n-    /* Boolean to keep track if all the memory allocations were successful\n-     * Used in the case of composite vectors when we need to allocate multiple\n-     * buffers for multiple vectors. If one of the allocations failed we need to\n-     * clear all the memory that we allocated\n-     */\n-    boolean success = false;\n-    try {\n-      success = values.allocateNewSafe() && bits.allocateNewSafe();\n-    } finally {\n-      if (!success) {\n-        clear();\n-      }\n-    }\n-    bits.zeroVector();\n-    mutator.reset();\n-    accessor.reset();\n-    return success;\n-  }\n-\n-  @Override\n-  public void reAlloc() {\n-    bits.reAlloc();\n-    values.reAlloc();\n-  }\n-\n-  public void reset() {\n-    bits.zeroVector();\n-    mutator.reset();\n-    accessor.reset();\n-  }\n-\n-  <#if type.major == \"VarLen\">\n-  @Override\n-  public void allocateNew(int totalBytes, int valueCount) {\n-    try {\n-      values.allocateNew(totalBytes, valueCount);\n-      bits.allocateNew(valueCount);\n-    } catch(RuntimeException e) {\n-      clear();\n-      throw e;\n-    }\n-    bits.zeroVector();\n-    mutator.reset();\n-    accessor.reset();\n-  }\n-\n-  @Override\n-  public int getByteCapacity(){\n-    return values.getByteCapacity();\n-  }\n-\n-  @Override\n-  public int getCurrentSizeInBytes(){\n-    return values.getCurrentSizeInBytes();\n-  }\n-\n-  <#else>\n-  @Override\n-  public void allocateNew(int valueCount) {\n-    try {\n-      values.allocateNew(valueCount);\n-      bits.allocateNew(valueCount);\n-    } catch(OutOfMemoryException e) {\n-      clear();\n-      throw e;\n-    }\n-    bits.zeroVector();\n-    mutator.reset();\n-    accessor.reset();\n-  }\n-\n-  /**\n-   * {@inheritDoc}\n-   */\n-  @Override\n-  public void zeroVector() {\n-    bits.zeroVector();\n-    values.zeroVector();\n-  }\n-  </#if>\n-\n-  @Override\n-  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n-        return getTransferPair(ref, allocator);\n-  }\n-\n-  @Override\n-  public TransferPair getTransferPair(BufferAllocator allocator){\n-    return new TransferImpl(name, allocator);\n-\n-  }\n-\n-  @Override\n-  public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n-    return new TransferImpl(ref, allocator);\n-  }\n-\n-  @Override\n-  public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((${className}) to);\n-  }\n-\n-  public void transferTo(${className} target){\n-    bits.transferTo(target.bits);\n-    values.transferTo(target.values);\n-    <#if type.major == \"VarLen\">\n-    target.mutator.lastSet = mutator.lastSet;\n-    </#if>\n-    clear();\n-  }\n-\n-  public void splitAndTransferTo(int startIndex, int length, ${className} target) {\n-    bits.splitAndTransferTo(startIndex, length, target.bits);\n-    values.splitAndTransferTo(startIndex, length, target.values);\n-    <#if type.major == \"VarLen\">\n-    target.mutator.lastSet = length - 1;\n-    </#if>\n-  }\n-\n-  private class TransferImpl implements TransferPair {\n-    ${className} to;\n-\n-    public TransferImpl(String ref, BufferAllocator allocator){\n-      to = new ${className}(ref, field.getFieldType(), allocator);\n-    }\n-\n-    public TransferImpl(${className} to){\n-      this.to = to;\n-    }\n-\n-    @Override\n-    public ${className} getTo(){\n-      return to;\n-    }\n-\n-    @Override\n-    public void transfer(){\n-      transferTo(to);\n-    }\n-\n-    @Override\n-    public void splitAndTransfer(int startIndex, int length) {\n-      splitAndTransferTo(startIndex, length, to);\n-    }\n-\n-    @Override\n-    public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, ${className}.this);\n-    }\n-  }\n-\n-  @Override\n-  public Accessor getAccessor(){\n-    return accessor;\n-  }\n-\n-  @Override\n-  public Mutator getMutator(){\n-    return mutator;\n-  }\n-\n-  public void copyFrom(int fromIndex, int thisIndex, ${className} from){\n-    final Accessor fromAccessor = from.getAccessor();\n-    if (!fromAccessor.isNull(fromIndex)) {\n-      mutator.set(thisIndex, fromAccessor.get(fromIndex));\n-    }\n-    <#if type.major == \"VarLen\">mutator.lastSet = thisIndex;</#if>\n-  }\n-\n-  public void copyFromSafe(int fromIndex, int thisIndex, ${valuesName} from){\n-    <#if type.major == \"VarLen\">\n-    mutator.fillEmpties(thisIndex);\n-    </#if>\n-    values.copyFromSafe(fromIndex, thisIndex, from);\n-    bits.getMutator().setSafeToOne(thisIndex);\n-    <#if type.major == \"VarLen\">mutator.lastSet = thisIndex;</#if>\n-  }\n-\n-  public void copyFromSafe(int fromIndex, int thisIndex, ${className} from){\n-    <#if type.major == \"VarLen\">\n-    mutator.fillEmpties(thisIndex);\n-    </#if>\n-    bits.copyFromSafe(fromIndex, thisIndex, from.bits);\n-    values.copyFromSafe(fromIndex, thisIndex, from.values);\n-    <#if type.major == \"VarLen\">mutator.lastSet = thisIndex;</#if>\n-  }\n-\n-  @Override\n-  public long getValidityBufferAddress() {\n-    /* address of the databuffer associated with the bitVector */\n-    return (bits.getDataBuffer().memoryAddress());\n-  }\n-\n-  @Override\n-  public long getDataBufferAddress() {\n-    /* address of the dataBuffer associated with the valueVector */\n-    return (values.getDataBuffer().memoryAddress());\n-  }\n-\n-  @Override\n-  public long getOffsetBufferAddress() {\n-    /* address of the dataBuffer associated with the offsetVector\n-     * this operation is not supported for fixed-width vector types.\n-     */\n-    <#if type.major != \"VarLen\">\n-        throw new UnsupportedOperationException();\n-    <#else>\n-        return (values.getOffsetAddr());\n-    </#if>\n-  }\n-\n-  @Override\n-  public ArrowBuf getValidityBuffer() {\n-    /* dataBuffer associated with the bitVector */\n-    return (bits.getDataBuffer());\n-  }\n-\n-  @Override\n-  public ArrowBuf getDataBuffer() {\n-    /* dataBuffer associated with the valueVector */\n-    return (values.getDataBuffer());\n-  }\n-\n-  @Override\n-  public ArrowBuf getOffsetBuffer() {\n-    /* dataBuffer associated with the offsetVector of the valueVector */\n-    <#if type.major != \"VarLen\">\n-        throw new UnsupportedOperationException();\n-    <#else>\n-        return (values.getOffsetBuffer());\n-    </#if>\n-  }\n-\n-  public final class Accessor extends BaseDataValueVector.BaseAccessor <#if type.major = \"VarLen\">implements VariableWidthVector.VariableWidthAccessor</#if> {\n-    final BitVector.Accessor bAccessor = bits.getAccessor();\n-    final ${valuesName}.Accessor vAccessor = values.getAccessor();\n-\n-    /**\n-     * Get the element at the specified position.\n-     *\n-     * @param  index   position of the value\n-     * @return value of the element, if not null\n-     */\n-    public <#if type.major == \"VarLen\">byte[]<#else>${minor.javaType!type.javaType}</#if> get(int index) {\n-      if (isNull(index)) {\n-          throw new IllegalStateException(\"Can't get a null value\");\n-      }\n-      return vAccessor.get(index);\n-    }\n-\n-    @Override\n-    public boolean isNull(int index) {\n-      return isSet(index) == 0;\n-    }\n-\n-    public int isSet(int index){\n-      return bAccessor.get(index);\n-    }\n-\n-    <#if type.major == \"VarLen\">\n-    public long getStartEnd(int index){\n-      return vAccessor.getStartEnd(index);\n-    }\n-\n-    @Override\n-    public int getValueLength(int index) {\n-      return values.getAccessor().getValueLength(index);\n-    }\n-    </#if>\n-\n-    public void get(int index, Nullable${minor.class}Holder holder){\n-      vAccessor.get(index, holder);\n-      holder.isSet = bAccessor.get(index);\n-    }\n-\n-    @Override\n-    public ${friendlyType} getObject(int index) {\n-      if (isNull(index)) {\n-          return null;\n-      }else{\n-        return vAccessor.getObject(index);\n-      }\n-    }\n-\n-    <#if minor.class == \"IntervalYear\" || minor.class == \"IntervalDay\">\n-    public StringBuilder getAsStringBuilder(int index) {\n-      if (isNull(index)) {\n-          return null;\n-      }else{\n-        return vAccessor.getAsStringBuilder(index);\n-      }\n-    }\n-    </#if>\n-\n-    @Override\n-    public int getValueCount(){\n-      return bits.getAccessor().getValueCount();\n-    }\n-\n-    public void reset(){}\n-  }\n-\n-  public final class Mutator extends BaseDataValueVector.BaseMutator implements NullableVectorDefinitionSetter<#if type.major = \"VarLen\">, VariableWidthVector.VariableWidthMutator</#if> {\n-    private int setCount;\n-    <#if type.major = \"VarLen\"> private int lastSet = -1;</#if>\n-\n-    private Mutator(){\n-    }\n-\n-    public ${valuesName} getVectorWithValues(){\n-      return values;\n-    }\n-\n-    @Override\n-    public void setIndexDefined(int index){\n-      bits.getMutator().setToOne(index);\n-    }\n-\n-    /**\n-     * Set the variable length element at the specified index to the supplied byte array.\n-     *\n-     * @param index   position of the bit to set\n-     * @param value   array of bytes (or int if smaller than 4 bytes) to write\n-     */\n-    public void set(int index, <#if type.major == \"VarLen\">byte[]<#elseif (type.width < 4)>int<#else>${minor.javaType!type.javaType}</#if> value) {\n-      setCount++;\n-      final ${valuesName}.Mutator valuesMutator = values.getMutator();\n-      final BitVector.Mutator bitsMutator = bits.getMutator();\n-      <#if type.major == \"VarLen\">\n-      for (int i = lastSet + 1; i < index; i++) {\n-        valuesMutator.set(i, emptyByteArray);\n-      }\n-      </#if>\n-      bitsMutator.setToOne(index);\n-      valuesMutator.set(index, value);\n-      <#if type.major == \"VarLen\">lastSet = index;</#if>\n-    }\n-\n-    <#if type.major == \"VarLen\">\n-\n-    public void fillEmpties(int index){\n-      final ${valuesName}.Mutator valuesMutator = values.getMutator();\n-      for (int i = lastSet + 1; i < index; i++) {\n-        valuesMutator.setSafe(i, emptyByteArray);\n-      }\n-      while(index > bits.getValueCapacity()) {\n-        bits.reAlloc();\n-      }\n-      lastSet = index - 1;\n-    }\n-\n-    @Override\n-    public void setValueLengthSafe(int index, int length) {\n-      values.getMutator().setValueLengthSafe(index, length);\n-      lastSet = index;\n-    }\n-    </#if>\n-\n-    public void setSafe(int index, byte[] value, int start, int length) {\n-      <#if type.major != \"VarLen\">\n-      throw new UnsupportedOperationException();\n-      <#else>\n-      fillEmpties(index);\n-\n-      bits.getMutator().setSafeToOne(index);\n-      values.getMutator().setSafe(index, value, start, length);\n-      setCount++;\n-      <#if type.major == \"VarLen\">lastSet = index;</#if>\n-      </#if>\n-    }\n-\n-    public void setSafe(int index, ByteBuffer value, int start, int length) {\n-      <#if type.major != \"VarLen\">\n-      throw new UnsupportedOperationException();\n-      <#else>\n-      fillEmpties(index);\n-\n-      bits.getMutator().setSafeToOne(index);\n-      values.getMutator().setSafe(index, value, start, length);\n-      setCount++;\n-      <#if type.major == \"VarLen\">lastSet = index;</#if>\n-      </#if>\n-    }\n-\n-    public void setNull(int index){\n-      bits.getMutator().setSafe(index, 0);\n-    }\n-\n-    public void setSkipNull(int index, ${minor.class}Holder holder){\n-      values.getMutator().set(index, holder);\n-    }\n-\n-    public void setSkipNull(int index, Nullable${minor.class}Holder holder){\n-      values.getMutator().set(index, holder);\n-    }\n-\n-    public void set(int index, Nullable${minor.class}Holder holder){\n-      final ${valuesName}.Mutator valuesMutator = values.getMutator();\n-      <#if type.major == \"VarLen\">\n-      for (int i = lastSet + 1; i < index; i++) {\n-        valuesMutator.set(i, emptyByteArray);\n-      }\n-      </#if>\n-      bits.getMutator().set(index, holder.isSet);\n-      valuesMutator.set(index, holder);\n-      <#if type.major == \"VarLen\">lastSet = index;</#if>\n-    }\n-\n-    public void set(int index, ${minor.class}Holder holder){\n-      final ${valuesName}.Mutator valuesMutator = values.getMutator();\n-      <#if type.major == \"VarLen\">\n-      for (int i = lastSet + 1; i < index; i++) {\n-        valuesMutator.set(i, emptyByteArray);\n-      }\n-      </#if>\n-      bits.getMutator().setToOne(index);\n-      valuesMutator.set(index, holder);\n-      <#if type.major == \"VarLen\">lastSet = index;</#if>\n-    }\n-\n-    public boolean isSafe(int outIndex) {\n-      return outIndex < ${className}.this.getValueCapacity();\n-    }\n-\n-    <#assign fields = minor.fields!type.fields />\n-    public void set(int index, int isSet<#list fields as field>, ${field.type} ${field.name}Field</#list> ){\n-      final ${valuesName}.Mutator valuesMutator = values.getMutator();\n-      <#if type.major == \"VarLen\">\n-      for (int i = lastSet + 1; i < index; i++) {\n-        valuesMutator.set(i, emptyByteArray);\n-      }\n-      </#if>\n-      bits.getMutator().set(index, isSet);\n-      valuesMutator.set(index<#list fields as field><#if field.include!true >, ${field.name}Field</#if></#list>);\n-      <#if type.major == \"VarLen\">lastSet = index;</#if>\n-    }\n-\n-    public void setSafe(int index, int isSet<#list fields as field><#if field.include!true >, ${field.type} ${field.name}Field</#if></#list> ) {\n-      <#if type.major == \"VarLen\">\n-      fillEmpties(index);\n-      </#if>\n-      bits.getMutator().setSafe(index, isSet);\n-      values.getMutator().setSafe(index<#list fields as field><#if field.include!true >, ${field.name}Field</#if></#list>);\n-      setCount++;\n-      <#if type.major == \"VarLen\">lastSet = index;</#if>\n-    }\n-\n-\n-    public void setSafe(int index, Nullable${minor.class}Holder value) {\n-      <#if type.major == \"VarLen\">\n-      fillEmpties(index);\n-      </#if>\n-      bits.getMutator().setSafe(index, value.isSet);\n-      values.getMutator().setSafe(index, value);\n-      setCount++;\n-      <#if type.major == \"VarLen\">lastSet = index;</#if>\n-    }\n-\n-    public void setSafe(int index, ${minor.class}Holder value) {\n-      <#if type.major == \"VarLen\">\n-      fillEmpties(index);\n-      </#if>\n-      bits.getMutator().setSafeToOne(index);\n-      values.getMutator().setSafe(index, value);\n-      setCount++;\n-      <#if type.major == \"VarLen\">lastSet = index;</#if>\n-    }\n-\n-    <#if !(type.major == \"VarLen\" || minor.class == \"IntervalDay\")>\n-    public void setSafe(int index, ${minor.javaType!type.javaType} value) {\n-      bits.getMutator().setSafeToOne(index);\n-      values.getMutator().setSafe(index, value);\n-      setCount++;\n-    }\n-\n-    </#if>\n-    <#if minor.class == \"Decimal\">\n-    public void set(int index, ${friendlyType} value) {\n-      bits.getMutator().setToOne(index);\n-      values.getMutator().set(index, value);\n-    }\n-\n-    public void setSafe(int index, ${friendlyType} value) {\n-      bits.getMutator().setSafeToOne(index);\n-      values.getMutator().setSafe(index, value);\n-      setCount++;\n-    }\n-\n-    </#if>\n-    @Override\n-    public void setValueCount(int valueCount) {\n-      assert valueCount >= 0;\n-      <#if type.major == \"VarLen\">\n-      fillEmpties(valueCount);\n-      </#if>\n-      values.getMutator().setValueCount(valueCount);\n-      bits.getMutator().setValueCount(valueCount);\n-    }\n-\n-    @Override\n-    public void generateTestData(int valueCount){\n-      bits.getMutator().generateTestDataAlt(valueCount);\n-      values.getMutator().generateTestData(valueCount);\n-      <#if type.major = \"VarLen\">lastSet = valueCount;</#if>\n-      setValueCount(valueCount);\n-    }\n-\n-    @Override\n-    public void reset(){\n-      setCount = 0;\n-      <#if type.major = \"VarLen\">lastSet = -1;</#if>\n-    }\n-\n-    public void setLastSet(int value) {\n-      <#if type.major = \"VarLen\">\n-        lastSet = value;\n-      <#else>\n-        throw new UnsupportedOperationException();\n-      </#if>\n-    }\n-\n-    public int getLastSet() {\n-      <#if type.major != \"VarLen\">\n-        throw new UnsupportedOperationException();\n-      <#else>\n-        return lastSet;\n-      </#if>\n-    }\n-  }\n-}\n-</#list>\n-</#list>\ndiff --git a/java/vector/src/main/codegen/templates/UnionListWriter.java b/java/vector/src/main/codegen/templates/UnionListWriter.java\nindex 9fe41d0d9..8ac23fe46 100644\n--- a/java/vector/src/main/codegen/templates/UnionListWriter.java\n+++ b/java/vector/src/main/codegen/templates/UnionListWriter.java\n@@ -36,11 +36,11 @@\n public class UnionListWriter extends AbstractFieldWriter {\n \n   private ListVector vector;\n-  private UInt4Vector offsets;\n   private PromotableWriter writer;\n   private boolean inMap = false;\n   private String mapName;\n   private int lastIndex = 0;\n+  private static final int OFFSET_WIDTH = 4;\n \n   public UnionListWriter(ListVector vector) {\n     this(vector, NullableMapWriterFactory.getNullableMapWriterFactoryInstance());\n@@ -49,7 +49,6 @@ public UnionListWriter(ListVector vector) {\n   public UnionListWriter(ListVector vector, NullableMapWriterFactory nullableMapWriterFactory) {\n     this.vector = vector;\n     this.writer = new PromotableWriter(vector.getDataVector(), vector, nullableMapWriterFactory);\n-    this.offsets = vector.getOffsetVector();\n   }\n \n   public UnionListWriter(ListVector vector, AbstractFieldWriter parent) {\n@@ -72,7 +71,7 @@ public Field getField() {\n   }\n \n   public void setValueCount(int count) {\n-    vector.getMutator().setValueCount(count);\n+    vector.setValueCount(count);\n   }\n \n   @Override\n@@ -133,13 +132,13 @@ public MapWriter map(String name) {\n \n   @Override\n   public void startList() {\n-    vector.getMutator().startNewValue(idx());\n-    writer.setPosition(offsets.getAccessor().get(idx() + 1));\n+    vector.startNewValue(idx());\n+    writer.setPosition(vector.getOffsetBuffer().getInt((idx() + 1) * OFFSET_WIDTH));\n   }\n \n   @Override\n   public void endList() {\n-    offsets.getMutator().set(idx() + 1, writer.idx());\n+    vector.getOffsetBuffer().setInt((idx() + 1) * OFFSET_WIDTH, writer.idx());\n     setPosition(idx() + 1);\n   }\n \ndiff --git a/java/vector/src/main/codegen/templates/UnionReader.java b/java/vector/src/main/codegen/templates/UnionReader.java\nindex fd3a766fc..98bb7c1f5 100644\n--- a/java/vector/src/main/codegen/templates/UnionReader.java\n+++ b/java/vector/src/main/codegen/templates/UnionReader.java\n@@ -60,7 +60,7 @@ public Field getField() {\n   }\n \n   public boolean isSet(){\n-    return !data.getAccessor().isNull(idx());\n+    return !data.isNull(idx());\n   }\n \n   public void read(UnionHolder holder) {\ndiff --git a/java/vector/src/main/codegen/templates/UnionVector.java b/java/vector/src/main/codegen/templates/UnionVector.java\nindex fe24a8674..e44edbd47 100644\n--- a/java/vector/src/main/codegen/templates/UnionVector.java\n+++ b/java/vector/src/main/codegen/templates/UnionVector.java\n@@ -25,6 +25,7 @@\n \n <#include \"/@includes/vv_imports.ftl\" />\n import com.google.common.collect.ImmutableList;\n+import io.netty.buffer.ArrowBuf;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Iterator;\n@@ -32,6 +33,9 @@\n import org.apache.arrow.vector.complex.impl.ComplexCopier;\n import org.apache.arrow.vector.util.CallBack;\n import org.apache.arrow.vector.schema.ArrowFieldNode;\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n \n import static org.apache.arrow.vector.types.UnionMode.Sparse;\n \n@@ -56,12 +60,10 @@\n \n   private String name;\n   private BufferAllocator allocator;\n-  private Accessor accessor = new Accessor();\n-  private Mutator mutator = new Mutator();\n   int valueCount;\n \n   MapVector internalMap;\n-  UInt1Vector typeVector;\n+  protected ArrowBuf typeBuffer;\n \n   private NullableMapVector mapVector;\n   private ListVector listVector;\n@@ -71,16 +73,17 @@\n   private int singleType = 0;\n   private ValueVector singleVector;\n \n+  private static final byte TYPE_WIDTH = 1;\n   private final CallBack callBack;\n-  private final List<BufferBacked> innerVectors;\n+  private int typeBufferAllocationSizeInBytes;\n \n   public UnionVector(String name, BufferAllocator allocator, CallBack callBack) {\n     this.name = name;\n     this.allocator = allocator;\n     this.internalMap = new MapVector(\"internal\", allocator, new FieldType(false, ArrowType.Struct.INSTANCE, null, null), callBack);\n-    this.typeVector = new UInt1Vector(\"types\", allocator);\n+    this.typeBuffer = allocator.getEmpty();\n     this.callBack = callBack;\n-    this.innerVectors = Collections.unmodifiableList(Arrays.<BufferBacked>asList(typeVector));\n+    this.typeBufferAllocationSizeInBytes = BaseValueVector.INITIAL_VALUE_ALLOCATION * TYPE_WIDTH;\n   }\n \n   public BufferAllocator getAllocator() {\n@@ -104,20 +107,35 @@ public void initializeChildrenFromFields(List<Field> children) {\n \n   @Override\n   public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n-    // truncate types vector buffer to size (#0)\n-    org.apache.arrow.vector.BaseDataValueVector.truncateBufferBasedOnSize(ownBuffers, 0, typeVector.getBufferSizeFor(fieldNode.getLength()));\n-    BaseDataValueVector.load(fieldNode, getFieldInnerVectors(), ownBuffers);\n+    if (ownBuffers.size() != 1) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 1 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf buffer = ownBuffers.get(0);\n+    typeBuffer.release();\n+    typeBuffer = buffer.retain(allocator);\n+    typeBufferAllocationSizeInBytes = typeBuffer.capacity();\n     this.valueCount = fieldNode.getLength();\n   }\n \n   @Override\n   public List<ArrowBuf> getFieldBuffers() {\n-    return BaseDataValueVector.unload(getFieldInnerVectors());\n+    List<ArrowBuf> result = new ArrayList<>(1);\n+    setReaderAndWriterIndex();\n+    result.add(typeBuffer);\n+\n+    return result;\n+  }\n+\n+  private void setReaderAndWriterIndex() {\n+    typeBuffer.readerIndex(0);\n+    typeBuffer.writerIndex(valueCount * TYPE_WIDTH);\n   }\n \n   @Override\n+  @Deprecated\n   public List<BufferBacked> getFieldInnerVectors() {\n-     return this.innerVectors;\n+     throw new UnsupportedOperationException(\"There are no inner vectors. Use geFieldBuffers\");\n   }\n \n   private String fieldName(MinorType type) {\n@@ -134,7 +152,7 @@ private FieldType fieldType(MinorType type) {\n \n   @Override\n   public long getValidityBufferAddress() {\n-    return typeVector.getDataBuffer().memoryAddress();\n+    return typeBuffer.memoryAddress();\n   }\n \n   @Override\n@@ -148,7 +166,7 @@ public long getOffsetBufferAddress() {\n   }\n \n   @Override\n-  public ArrowBuf getValidityBuffer() { return typeVector.getDataBuffer(); }\n+  public ArrowBuf getValidityBuffer() { return typeBuffer; }\n \n   @Override\n   public ArrowBuf getDataBuffer() { throw new UnsupportedOperationException(); }\n@@ -211,47 +229,80 @@ public ListVector getList() {\n   }\n \n   public int getTypeValue(int index) {\n-    return typeVector.getAccessor().get(index);\n-  }\n-\n-  public UInt1Vector getTypeVector() {\n-    return typeVector;\n+    return typeBuffer.getByte(index * TYPE_WIDTH);\n   }\n \n   @Override\n   public void allocateNew() throws OutOfMemoryException {\n+    /* new allocation -- clear the current buffers */\n+    clear();\n     internalMap.allocateNew();\n-    typeVector.allocateNew();\n-    if (typeVector != null) {\n-      typeVector.zeroVector();\n+    try {\n+      allocateTypeBuffer();\n+    } catch (Exception e) {\n+      clear();\n+      throw e;\n     }\n   }\n \n   @Override\n   public boolean allocateNewSafe() {\n+    /* new allocation -- clear the current buffers */\n+    clear();\n     boolean safe = internalMap.allocateNewSafe();\n-    safe = safe && typeVector.allocateNewSafe();\n-    if (safe) {\n-      if (typeVector != null) {\n-        typeVector.zeroVector();\n-      }\n+    if (!safe) { return false; }\n+    try {\n+      allocateTypeBuffer();\n+    } catch (Exception e) {\n+      clear();\n+      return  false;\n     }\n-    return safe;\n+\n+    return true;\n+  }\n+\n+  private void allocateTypeBuffer() {\n+    typeBuffer = allocator.buffer(typeBufferAllocationSizeInBytes);\n+    typeBuffer.readerIndex(0);\n+    typeBuffer.setZero(0, typeBuffer.capacity());\n   }\n \n   @Override\n   public void reAlloc() {\n     internalMap.reAlloc();\n-    typeVector.reAlloc();\n+    reallocTypeBuffer();\n   }\n \n-  @Override\n-  public void setInitialCapacity(int numRecords) {\n+  private void reallocTypeBuffer() {\n+    final int currentBufferCapacity = typeBuffer.capacity();\n+    long baseSize  = typeBufferAllocationSizeInBytes;\n+\n+    if (baseSize < (long)currentBufferCapacity) {\n+      baseSize = (long)currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+    if (newAllocationSize > BaseValueVector.MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int)newAllocationSize);\n+    newBuf.setBytes(0, typeBuffer, 0, currentBufferCapacity);\n+    final int halfNewCapacity = newBuf.capacity() / 2;\n+    newBuf.setZero(halfNewCapacity, halfNewCapacity);\n+    typeBuffer.release(1);\n+    typeBuffer = newBuf;\n+    typeBufferAllocationSizeInBytes = (int)newAllocationSize;\n   }\n \n   @Override\n+  public void setInitialCapacity(int numRecords) { }\n+\n+  @Override\n   public int getValueCapacity() {\n-    return Math.min(typeVector.getValueCapacity(), internalMap.getValueCapacity());\n+    return Math.min(getTypeBufferValueCapacity(), internalMap.getValueCapacity());\n   }\n \n   @Override\n@@ -261,7 +312,9 @@ public void close() {\n \n   @Override\n   public void clear() {\n-    typeVector.clear();\n+    valueCount = 0;\n+    typeBuffer.release();\n+    typeBuffer = allocator.getEmpty();\n     internalMap.clear();\n   }\n \n@@ -300,7 +353,7 @@ public TransferPair makeTransferPair(ValueVector target) {\n   public void copyFrom(int inIndex, int outIndex, UnionVector from) {\n     from.getReader().setPosition(inIndex);\n     getWriter().setPosition(outIndex);\n-    ComplexCopier.copy(from.reader, mutator.writer);\n+    ComplexCopier.copy(from.reader, writer);\n   }\n \n   public void copyFromSafe(int inIndex, int outIndex, UnionVector from) {\n@@ -321,33 +374,35 @@ public FieldVector addVector(FieldVector v) {\n \n   private class TransferImpl implements TransferPair {\n     private final TransferPair internalMapVectorTransferPair;\n-    private final TransferPair typeVectorTransferPair;\n     private final UnionVector to;\n \n     public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n       to = new UnionVector(name, allocator, callBack);\n       internalMapVectorTransferPair = internalMap.makeTransferPair(to.internalMap);\n-      typeVectorTransferPair = typeVector.makeTransferPair(to.typeVector);\n     }\n \n     public TransferImpl(UnionVector to) {\n       this.to = to;\n       internalMapVectorTransferPair = internalMap.makeTransferPair(to.internalMap);\n-      typeVectorTransferPair = typeVector.makeTransferPair(to.typeVector);\n     }\n \n     @Override\n     public void transfer() {\n+      to.clear();\n+      to.typeBuffer = typeBuffer.transferOwnership(to.allocator).buffer;\n       internalMapVectorTransferPair.transfer();\n-      typeVectorTransferPair.transfer();\n       to.valueCount = valueCount;\n+      clear();\n     }\n \n     @Override\n     public void splitAndTransfer(int startIndex, int length) {\n+      to.clear();\n       internalMapVectorTransferPair.splitAndTransfer(startIndex, length);\n-      typeVectorTransferPair.splitAndTransfer(startIndex, length);\n-      to.getMutator().setValueCount(length);\n+      final int startPoint = startIndex * TYPE_WIDTH;\n+      final int sliceLength = length * TYPE_WIDTH;\n+      to.typeBuffer = typeBuffer.slice(startPoint, sliceLength).transferOwnership(to.allocator).buffer;\n+      to.setValueCount(length);\n     }\n \n     @Override\n@@ -362,13 +417,15 @@ public void copyValueSafe(int from, int to) {\n   }\n \n   @Override\n+  @Deprecated\n   public Accessor getAccessor() {\n-    return accessor;\n+    throw new UnsupportedOperationException(\"Accessor is not supported for reading from UNION\");\n   }\n \n   @Override\n+  @Deprecated\n   public Mutator getMutator() {\n-    return mutator;\n+    throw new UnsupportedOperationException(\"Mutator is not supported for writing to UNION\");\n   }\n \n   @Override\n@@ -380,15 +437,17 @@ public FieldReader getReader() {\n   }\n \n   public FieldWriter getWriter() {\n-    if (mutator.writer == null) {\n-      mutator.writer = new UnionWriter(this);\n+    if (writer == null) {\n+      writer = new UnionWriter(this);\n     }\n-    return mutator.writer;\n+    return writer;\n   }\n \n   @Override\n   public int getBufferSize() {\n-    return typeVector.getBufferSize() + internalMap.getBufferSize();\n+    if (valueCount == 0) { return 0; }\n+\n+    return (valueCount * TYPE_WIDTH) + internalMap.getBufferSize();\n   }\n \n   @Override\n@@ -402,14 +461,23 @@ public int getBufferSizeFor(final int valueCount) {\n       bufferSize += v.getBufferSizeFor(valueCount);\n     }\n \n-    return (int) bufferSize;\n+    return (int) bufferSize + (valueCount * TYPE_WIDTH);\n   }\n \n   @Override\n   public ArrowBuf[] getBuffers(boolean clear) {\n     ImmutableList.Builder<ArrowBuf> builder = ImmutableList.builder();\n-    builder.add(typeVector.getBuffers(clear));\n-    builder.add(internalMap.getBuffers(clear));\n+    setReaderAndWriterIndex();\n+    if (getBufferSize() != 0) {\n+      builder.add(typeBuffer);\n+      builder.add(internalMap.getBuffers(clear));\n+    }\n+    if (clear) {\n+      valueCount = 0;\n+      typeBuffer.retain();\n+      typeBuffer.release();\n+      typeBuffer = allocator.getEmpty();\n+    }\n     List<ArrowBuf> list = builder.build();\n     return list.toArray(new ArrowBuf[list.size()]);\n   }\n@@ -417,15 +485,12 @@ public int getBufferSizeFor(final int valueCount) {\n   @Override\n   public Iterator<ValueVector> iterator() {\n     List<ValueVector> vectors = Lists.newArrayList(internalMap.iterator());\n-    vectors.add(typeVector);\n     return vectors.iterator();\n   }\n \n-  public class Accessor extends BaseValueVector.BaseAccessor {\n \n-    @Override\n     public Object getObject(int index) {\n-      int type = typeVector.getAccessor().get(index);\n+      int type = typeBuffer.getByte(index * TYPE_WIDTH);\n       switch (MinorType.values()[type]) {\n       case NULL:\n         return null;\n@@ -436,14 +501,14 @@ public Object getObject(int index) {\n           <#assign uncappedName = name?uncap_first/>\n           <#if !minor.typeParams?? >\n       case ${name?upper_case}:\n-        return get${name}Vector().getAccessor().getObject(index);\n+          return get${name}Vector().getObject(index);\n           </#if>\n         </#list>\n       </#list>\n       case MAP:\n-        return getMap().getAccessor().getObject(index);\n+        return getMap().getObject(index);\n       case LIST:\n-        return getList().getAccessor().getObject(index);\n+        return getList().getObject(index);\n       default:\n         throw new UnsupportedOperationException(\"Cannot support type: \" + MinorType.values()[type]);\n       }\n@@ -462,30 +527,37 @@ public void get(int index, UnionHolder holder) {\n       holder.reader = reader;\n     }\n \n-    @Override\n     public int getValueCount() {\n       return valueCount;\n     }\n \n-    @Override\n     public boolean isNull(int index) {\n-      return typeVector.getAccessor().get(index) == 0;\n+      return (typeBuffer.getByte(index * TYPE_WIDTH) == 0);\n+    }\n+\n+    @Override\n+    public int getNullCount() {\n+      int nullCount = 0;\n+      for (int i = 0; i < getValueCount(); i++) {\n+        if (isNull(i)) {\n+          nullCount++;\n+        }\n+      }\n+      return nullCount;\n     }\n \n     public int isSet(int index) {\n       return isNull(index) ? 0 : 1;\n     }\n-  }\n-\n-  public class Mutator extends BaseValueVector.BaseMutator {\n \n     UnionWriter writer;\n \n-    @Override\n     public void setValueCount(int valueCount) {\n-      UnionVector.this.valueCount = valueCount;\n-      typeVector.getMutator().setValueCount(valueCount);\n-      internalMap.getMutator().setValueCount(valueCount);\n+      this.valueCount = valueCount;\n+      while (valueCount > getTypeBufferValueCapacity()) {\n+        reallocTypeBuffer();\n+      }\n+      internalMap.setValueCount(valueCount);\n     }\n \n     public void setSafe(int index, UnionHolder holder) {\n@@ -530,7 +602,7 @@ public void setSafe(int index, UnionHolder holder) {\n         <#if !minor.typeParams?? >\n     public void setSafe(int index, Nullable${name}Holder holder) {\n       setType(index, MinorType.${name?upper_case});\n-      get${name}Vector().getMutator().setSafe(index, holder);\n+      get${name}Vector().setSafe(index, holder);\n     }\n \n         </#if>\n@@ -538,13 +610,13 @@ public void setSafe(int index, Nullable${name}Holder holder) {\n     </#list>\n \n     public void setType(int index, MinorType type) {\n-      typeVector.getMutator().setSafe(index, (byte) type.ordinal());\n+      while (index >= getTypeBufferValueCapacity()) {\n+        reallocTypeBuffer();\n+      }\n+      typeBuffer.setByte(index * TYPE_WIDTH , (byte) type.ordinal());\n     }\n \n-    @Override\n-    public void reset() { }\n-\n-    @Override\n-    public void generateTestData(int values) { }\n-  }\n+    private int getTypeBufferValueCapacity() {\n+      return (int) ((typeBuffer.capacity() * 1.0) / TYPE_WIDTH);\n+    }\n }\ndiff --git a/java/vector/src/main/codegen/templates/UnionWriter.java b/java/vector/src/main/codegen/templates/UnionWriter.java\nindex f892bac91..526708a4c 100644\n--- a/java/vector/src/main/codegen/templates/UnionWriter.java\n+++ b/java/vector/src/main/codegen/templates/UnionWriter.java\n@@ -62,7 +62,7 @@ public void setPosition(int index) {\n \n   @Override\n   public void start() {\n-    data.getMutator().setType(idx(), MinorType.MAP);\n+    data.setType(idx(), MinorType.MAP);\n     getMapWriter().start();\n   }\n \n@@ -74,7 +74,7 @@ public void end() {\n   @Override\n   public void startList() {\n     getListWriter().startList();\n-    data.getMutator().setType(idx(), MinorType.LIST);\n+    data.setType(idx(), MinorType.LIST);\n   }\n \n   @Override\n@@ -92,7 +92,7 @@ private MapWriter getMapWriter() {\n   }\n \n   public MapWriter asMap() {\n-    data.getMutator().setType(idx(), MinorType.MAP);\n+    data.setType(idx(), MinorType.MAP);\n     return getMapWriter();\n   }\n \n@@ -106,7 +106,7 @@ private ListWriter getListWriter() {\n   }\n \n   public ListWriter asList() {\n-    data.getMutator().setType(idx(), MinorType.LIST);\n+    data.setType(idx(), MinorType.LIST);\n     return getListWriter();\n   }\n \n@@ -150,19 +150,19 @@ BaseWriter getWriter(MinorType minorType) {\n   }\n \n   public ${name}Writer as${name}() {\n-    data.getMutator().setType(idx(), MinorType.${name?upper_case});\n+    data.setType(idx(), MinorType.${name?upper_case});\n     return get${name}Writer();\n   }\n \n   @Override\n   public void write(${name}Holder holder) {\n-    data.getMutator().setType(idx(), MinorType.${name?upper_case});\n+    data.setType(idx(), MinorType.${name?upper_case});\n     get${name}Writer().setPosition(idx());\n     get${name}Writer().write${name}(<#list fields as field>holder.${field.name}<#if field_has_next>, </#if></#list>);\n   }\n \n   public void write${minor.class}(<#list fields as field>${field.type} ${field.name}<#if field_has_next>, </#if></#list>) {\n-    data.getMutator().setType(idx(), MinorType.${name?upper_case});\n+    data.setType(idx(), MinorType.${name?upper_case});\n     get${name}Writer().setPosition(idx());\n     get${name}Writer().write${name}(<#list fields as field>${field.name}<#if field_has_next>, </#if></#list>);\n   }\n@@ -175,28 +175,28 @@ public void writeNull() {\n \n   @Override\n   public MapWriter map() {\n-    data.getMutator().setType(idx(), MinorType.LIST);\n+    data.setType(idx(), MinorType.LIST);\n     getListWriter().setPosition(idx());\n     return getListWriter().map();\n   }\n \n   @Override\n   public ListWriter list() {\n-    data.getMutator().setType(idx(), MinorType.LIST);\n+    data.setType(idx(), MinorType.LIST);\n     getListWriter().setPosition(idx());\n     return getListWriter().list();\n   }\n \n   @Override\n   public ListWriter list(String name) {\n-    data.getMutator().setType(idx(), MinorType.MAP);\n+    data.setType(idx(), MinorType.MAP);\n     getMapWriter().setPosition(idx());\n     return getMapWriter().list(name);\n   }\n \n   @Override\n   public MapWriter map(String name) {\n-    data.getMutator().setType(idx(), MinorType.MAP);\n+    data.setType(idx(), MinorType.MAP);\n     getMapWriter().setPosition(idx());\n     return getMapWriter().map(name);\n   }\n@@ -209,14 +209,14 @@ public MapWriter map(String name) {\n   <#if !minor.typeParams?? >\n   @Override\n   public ${capName}Writer ${lowerName}(String name) {\n-    data.getMutator().setType(idx(), MinorType.MAP);\n+    data.setType(idx(), MinorType.MAP);\n     getMapWriter().setPosition(idx());\n     return getMapWriter().${lowerName}(name);\n   }\n \n   @Override\n   public ${capName}Writer ${lowerName}() {\n-    data.getMutator().setType(idx(), MinorType.LIST);\n+    data.setType(idx(), MinorType.LIST);\n     getListWriter().setPosition(idx());\n     return getListWriter().${lowerName}();\n   }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/BaseDataValueVector.java b/java/vector/src/main/java/org/apache/arrow/vector/BaseDataValueVector.java\nindex 01340f66c..38524ff8a 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/BaseDataValueVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/BaseDataValueVector.java\n@@ -6,9 +6,9 @@\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- *\n+ * <p>\n  * http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * <p>\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -85,7 +85,7 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallB\n     if (getBufferSize() == 0) {\n       out = new ArrowBuf[0];\n     } else {\n-      out = new ArrowBuf[] {data};\n+      out = new ArrowBuf[]{data};\n       data.readerIndex(0);\n       if (clear) {\n         data.retain(1);\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableFixedWidthVector.java b/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableFixedWidthVector.java\nnew file mode 100644\nindex 000000000..209758e4e\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableFixedWidthVector.java\n@@ -0,0 +1,850 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.schema.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * BaseNullableFixedWidthVector provides an abstract interface for\n+ * implementing vectors of fixed width values. The vectors are nullable\n+ * implying that zero or more elements in the vector could be NULL.\n+ */\n+public abstract class BaseNullableFixedWidthVector extends BaseValueVector\n+        implements FixedWidthVector, FieldVector, NullableVectorDefinitionSetter {\n+  private final byte typeWidth;\n+\n+  protected int valueAllocationSizeInBytes;\n+  protected int validityAllocationSizeInBytes;\n+\n+  protected final Field field;\n+  private int allocationMonitor;\n+  protected ArrowBuf validityBuffer;\n+  protected ArrowBuf valueBuffer;\n+  protected int valueCount;\n+\n+  public BaseNullableFixedWidthVector(final String name, final BufferAllocator allocator,\n+                                      FieldType fieldType, final byte typeWidth) {\n+    super(name, allocator);\n+    this.typeWidth = typeWidth;\n+    field = new Field(name, fieldType, null);\n+    valueCount = 0;\n+    allocationMonitor = 0;\n+    validityBuffer = allocator.getEmpty();\n+    valueBuffer = allocator.getEmpty();\n+    if (typeWidth > 0) {\n+      valueAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * typeWidth;\n+      validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    } else {\n+      /* specialized handling for NullableBitVector */\n+      valueAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+      validityAllocationSizeInBytes = valueAllocationSizeInBytes;\n+    }\n+  }\n+\n+\n+  /* TODO:\n+   * see if getNullCount() can be made faster -- O(1)\n+   */\n+\n+  /* TODO:\n+   * Once the entire hierarchy has been refactored, move common functions\n+   * like getNullCount(), splitAndTransferValidityBuffer to top level\n+   * base class BaseValueVector.\n+   *\n+   * Along with this, some class members (validityBuffer) can also be\n+   * abstracted out to top level base class.\n+   *\n+   * Right now BaseValueVector is the top level base class for other\n+   * vector types in ValueVector hierarchy (non-nullable) and those\n+   * vectors have not yet been refactored/removed so moving things to\n+   * the top class as of now is not a good idea.\n+   */\n+\n+\n+  @Override\n+  @Deprecated\n+  public Mutator getMutator() {\n+    throw new UnsupportedOperationException(\"Mutator is not supported for writing to vector\");\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public Accessor getAccessor() {\n+    throw new UnsupportedOperationException(\"Accessor is not supported for reading from vector\");\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that manages the validity\n+   * (NULL or NON-NULL nature) of elements in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return (validityBuffer.memoryAddress());\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the data for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getDataBufferAddress() {\n+    return (valueBuffer.memoryAddress());\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the offsets for elements\n+   * in the vector. This operation is not supported for fixed-width vectors.\n+   * @return starting address of the buffer\n+   * @throws UnsupportedOperationException for fixed width vectors\n+   */\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    throw new UnsupportedOperationException(\"not supported for fixed-width vectors\");\n+  }\n+\n+  /**\n+   * Get buffer that manages the validity (NULL or NON-NULL nature) of\n+   * elements in the vector. Consider it as a buffer for internal bit vector\n+   * data structure.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  /**\n+   * Get the buffer that stores the data for elements in the vector.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    return valueBuffer;\n+  }\n+\n+  /**\n+   * buffer that stores the offsets for elements\n+   * in the vector. This operation is not supported for fixed-width vectors.\n+   * @return buffer\n+   * @throws UnsupportedOperationException for fixed width vectors\n+   */\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    throw new UnsupportedOperationException(\"not supported for fixed-width vectors\");\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   * @param valueCount desired number of elements in the vector\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount) {\n+    final long size = (long) valueCount * typeWidth;\n+    if (size > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+    valueAllocationSizeInBytes = (int) size;\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(valueCount);\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    return Math.min(getValueBufferValueCapacity(), getValidityBufferValueCapacity());\n+  }\n+\n+  private int getValueBufferValueCapacity() {\n+    return (int) ((valueBuffer.capacity() * 1.0) / typeWidth);\n+  }\n+\n+  private int getValidityBufferValueCapacity() {\n+    return (int) (validityBuffer.capacity() * 8L);\n+  }\n+\n+  /**\n+   * zero out the vector and the data in associated buffers.\n+   */\n+  @Override\n+  public void zeroVector() {\n+    initValidityBuffer();\n+    initValueBuffer();\n+  }\n+\n+  /* zero out the validity buffer */\n+  private void initValidityBuffer() {\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+\n+  /* zero out the data buffer */\n+  private void initValueBuffer() {\n+    valueBuffer.setZero(0, valueBuffer.capacity());\n+  }\n+\n+  /**\n+   * Reset the vector to initial state. Same as {@link #zeroVector()}.\n+   * Note that this method doesn't release any memory.\n+   */\n+  public void reset() {\n+    zeroVector();\n+  }\n+\n+  /**\n+   * Close the vector and release the associated buffers.\n+   */\n+  @Override\n+  public void close() {\n+    clear();\n+  }\n+\n+  /**\n+   * Same as {@link #close()}\n+   */\n+  @Override\n+  public void clear() {\n+    valueCount = 0;\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    valueBuffer = releaseBuffer(valueBuffer);\n+  }\n+\n+  /* used to step down the memory allocation */\n+  protected void incrementAllocationMonitor() {\n+    if (allocationMonitor < 0) {\n+      allocationMonitor = 0;\n+    }\n+    allocationMonitor++;\n+  }\n+\n+  /* used to step up the memory allocation */\n+  protected void decrementAllocationMonitor() {\n+    if (allocationMonitor > 0) {\n+      allocationMonitor = 0;\n+    }\n+    allocationMonitor--;\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory.\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector. See {@link #allocateNew(int)} for allocating memory for specific\n+   * number of elements in the vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  @Override\n+  public boolean allocateNewSafe() {\n+    long curAllocationSizeValue = valueAllocationSizeInBytes;\n+    long curAllocationSizeValidity = validityAllocationSizeInBytes;\n+\n+    if (curAllocationSizeValue > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory exceeds limit\");\n+    }\n+\n+      /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(curAllocationSizeValue, curAllocationSizeValidity);\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Allocate memory for the vector to support storing at least the provided number of\n+   * elements in the vector. This method must be called prior to using the ValueVector.\n+   *\n+   * @param valueCount the desired number of elements in the vector\n+   * @throws org.apache.arrow.memory.OutOfMemoryException\n+   */\n+  public void allocateNew(int valueCount) {\n+    long valueBufferSize = valueCount * typeWidth;\n+    long validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    if (typeWidth == 0) {\n+      /* specialized handling for NullableBitVector */\n+      valueBufferSize = validityBufferSize;\n+    }\n+\n+    if (valueBufferSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+\n+    /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(valueBufferSize, validityBufferSize);\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Actual memory allocation is done by this function. All the calculations\n+   * and knowledge about what size to allocate is upto the callers of this\n+   * method.\n+   * Callers appropriately handle errors if memory allocation fails here.\n+   * Callers should also take care of determining that desired size is\n+   * within the bounds of max allocation allowed and any other error\n+   * conditions.\n+   */\n+  private void allocateBytes(final long valueBufferSize, final long validityBufferSize) {\n+    /* allocate data buffer */\n+    int curSize = (int) valueBufferSize;\n+    valueBuffer = allocator.buffer(curSize);\n+    valueBuffer.readerIndex(0);\n+    valueAllocationSizeInBytes = curSize;\n+    /* allocate validity buffer */\n+    allocateValidityBuffer((int) validityBufferSize);\n+    zeroVector();\n+  }\n+\n+  /**\n+   * During splitAndTransfer, if we splitting from a random position within a byte,\n+   * we can't just slice the source buffer so we have to explicitly allocate the\n+   * validityBuffer of the target vector. This is unlike the databuffer which we can\n+   * always slice for the target vector.\n+   */\n+  private void allocateValidityBuffer(final int validityBufferSize) {\n+    validityBuffer = allocator.buffer(validityBufferSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = validityBufferSize;\n+  }\n+\n+  /**\n+   * Get the potential buffer size for a particular number of records.\n+   * @param count desired number of elements in the vector\n+   * @return estimated size of underlying buffers if the vector holds\n+   *         a given number of elements\n+   */\n+  @Override\n+  public int getBufferSizeFor(final int count) {\n+    if (count == 0) {\n+      return 0;\n+    }\n+    return (count * typeWidth) + getValidityBufferSizeFromCount(count);\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    return (valueCount * typeWidth) + getValidityBufferSizeFromCount(valueCount);\n+  }\n+\n+  /**\n+   * Get information about how this field is materialized.\n+   * @return the field corresponding to this vector\n+   */\n+  @Override\n+  public Field getField() {\n+    return field;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    final ArrowBuf[] buffers;\n+    setReaderAndWriterIndex();\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = new ArrowBuf[2];\n+      buffers[0] = validityBuffer;\n+      buffers[1] = valueBuffer;\n+    }\n+    if (clear) {\n+      for (final ArrowBuf buffer : buffers) {\n+        buffer.retain(1);\n+      }\n+      clear();\n+    }\n+    return buffers;\n+  }\n+\n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  @Override\n+  public void reAlloc() {\n+    valueBuffer = reallocBufferHelper(valueBuffer, true);\n+    validityBuffer = reallocBufferHelper(validityBuffer, false);\n+  }\n+\n+  /**\n+   * Helper method for reallocating a particular internal buffer\n+   * Returns the new buffer.\n+   */\n+  private ArrowBuf reallocBufferHelper(ArrowBuf buffer, final boolean dataBuffer) {\n+    final int currentBufferCapacity = buffer.capacity();\n+    long baseSize = (dataBuffer ? valueAllocationSizeInBytes\n+            : validityAllocationSizeInBytes);\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, buffer, 0, currentBufferCapacity);\n+    final int halfNewCapacity = newBuf.capacity() / 2;\n+    newBuf.setZero(halfNewCapacity, halfNewCapacity);\n+    buffer.release(1);\n+    buffer = newBuf;\n+    if (dataBuffer) {\n+      valueAllocationSizeInBytes = (int) newAllocationSize;\n+    } else {\n+      validityAllocationSizeInBytes = (int) newAllocationSize;\n+    }\n+\n+    return buffer;\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Initialize the children in schema for this Field. This operation is a\n+   * NO-OP for scalar types since they don't have any children.\n+   * @param children the schema\n+   * @throws IllegalArgumentException if children is a non-empty list for scalar types.\n+   */\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (!children.isEmpty()) {\n+      throw new IllegalArgumentException(\"primitive type vector can not have children\");\n+    }\n+  }\n+\n+  /**\n+   * Get the inner child vectors.\n+   * @return list of child vectors for complex types, empty list for scalar vector\n+   * types\n+   */\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return Collections.emptyList();\n+  }\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf dataBuffer = ownBuffers.get(1);\n+\n+    validityBuffer.release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    valueBuffer.release();\n+    valueBuffer = dataBuffer.retain(allocator);\n+\n+    valueCount = fieldNode.getLength();\n+\n+    valueAllocationSizeInBytes = valueBuffer.capacity();\n+    validityAllocationSizeInBytes = validityBuffer.capacity();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector\n+   * @return the inner buffers.\n+   */\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(2);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(valueBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    valueBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      valueBuffer.writerIndex(0);\n+    } else {\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      if (typeWidth == 0) {\n+        /* specialized handling for NullableBitVector */\n+        valueBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      } else {\n+        valueBuffer.writerIndex(valueCount * typeWidth);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @param callBack\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return getTransferPair(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(BufferAllocator allocator) {\n+    return getTransferPair(name, allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  public abstract TransferPair getTransferPair(String ref, BufferAllocator allocator);\n+\n+  /**\n+   * Transfer this vector'data to another vector. The memory associated\n+   * with this vector is transferred to the allocator of target vector\n+   * for accounting and management purposes.\n+   * @param target destination vector for transfer\n+   */\n+  public void transferTo(BaseNullableFixedWidthVector target) {\n+    compareTypes(target, \"transferTo\");\n+    target.clear();\n+    target.validityBuffer = validityBuffer.transferOwnership(target.allocator).buffer;\n+    target.valueBuffer = valueBuffer.transferOwnership(target.allocator).buffer;\n+    target.valueCount = valueCount;\n+    clear();\n+  }\n+\n+  /**\n+   * Slice this vector at desired index and length and transfer the\n+   * corresponding data to the target vector.\n+   * @param startIndex start position of the split in source vector.\n+   * @param length length of the split.\n+   * @param target destination vector\n+   */\n+  public void splitAndTransferTo(int startIndex, int length,\n+                                 BaseNullableFixedWidthVector target) {\n+    compareTypes(target, \"splitAndTransferTo\");\n+    target.clear();\n+    splitAndTransferValidityBuffer(startIndex, length, target);\n+    splitAndTransferValueBuffer(startIndex, length, target);\n+    target.setValueCount(length);\n+  }\n+\n+  /**\n+   * Data buffer can always be split and transferred using slicing.\n+   */\n+  private void splitAndTransferValueBuffer(int startIndex, int length,\n+                                           BaseNullableFixedWidthVector target) {\n+    final int startPoint = startIndex * typeWidth;\n+    final int sliceLength = length * typeWidth;\n+    target.valueBuffer = valueBuffer.slice(startPoint, sliceLength).transferOwnership(target.allocator).buffer;\n+  }\n+\n+  /**\n+   * Validity buffer has multiple cases of split and transfer depending on\n+   * the starting position of the source index.\n+   */\n+  private void splitAndTransferValidityBuffer(int startIndex, int length,\n+                                              BaseNullableFixedWidthVector target) {\n+    assert startIndex + length <= valueCount;\n+    int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+    int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+    int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+    int offset = startIndex % 8;\n+\n+    if (length > 0) {\n+      if (offset == 0) {\n+        /* slice */\n+        if (target.validityBuffer != null) {\n+          target.validityBuffer.release();\n+        }\n+        target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+        target.validityBuffer.retain(1);\n+      } else {\n+        /* Copy data\n+         * When the first bit starts from the middle of a byte (offset != 0),\n+         * copy data from src BitVector.\n+         * Each byte in the target is composed by a part in i-th byte,\n+         * another part in (i+1)-th byte.\n+         */\n+        target.allocateValidityBuffer(byteSizeTarget);\n+\n+        for (int i = 0; i < byteSizeTarget - 1; i++) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+                  firstByteSource + i, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer,\n+                  firstByteSource + i + 1, offset);\n+\n+          target.validityBuffer.setByte(i, (b1 + b2));\n+        }\n+\n+        /* Copying the last piece is done in the following manner:\n+         * if the source vector has 1 or more bytes remaining, we copy\n+         * the last piece as a byte formed by shifting data\n+         * from the current byte and the next byte.\n+         *\n+         * if the source vector has no more bytes remaining\n+         * (we are at the last byte), we copy the last piece as a byte\n+         * by shifting data from the current byte.\n+         */\n+        if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer,\n+                  firstByteSource + byteSizeTarget, offset);\n+\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+        } else {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+        }\n+      }\n+    }\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          common getters and setters                            *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the number of elements that are null in the vector\n+   *\n+   * @return the number of null elements.\n+   */\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  /**\n+   * Get the value count of vector. This will always be zero unless\n+   * {@link #setValueCount(int)} has been called prior to calling this.\n+   *\n+   * @return valueCount for the vector\n+   */\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n+\n+  /**\n+   * Set value count for the vector.\n+   *\n+   * @param valueCount  value count to set\n+   */\n+  public void setValueCount(int valueCount) {\n+    this.valueCount = valueCount;\n+    final int currentValueCapacity = getValueCapacity();\n+    while (valueCount > getValueCapacity()) {\n+      reAlloc();\n+    }\n+    /*\n+     * We are trying to understand the pattern of memory allocation.\n+     * If initially, the user did vector.allocateNew(), we would have\n+     * allocated memory of default size (4096 * type width).\n+     * Later on user invokes setValueCount(count).\n+     *\n+     * If the existing value capacity is twice as large as the\n+     * valueCount, we know that we over-provisioned memory in the\n+     * first place when default memory allocation was done because user\n+     * really needs a much less value count in the vector.\n+     *\n+     * We record this by bumping up the allocationMonitor. If this pattern\n+     * happens for certain number of times and allocationMonitor\n+     * reaches the threshold (internal hardcoded) value, subsequent\n+     * call to allocateNew() will take care of stepping down the\n+     * default memory allocation size.\n+     *\n+     * Another case would be under-provisioning the initial memory and\n+     * thus going through a lot of realloc(). Here the goal is to\n+     * see if we can minimize the number of reallocations. Again the\n+     * state is recorded in allocationMonitor by decrementing it\n+     * (negative value). If a threshold is hit, realloc will try to\n+     * allocate more memory in order to possibly avoid a future realloc.\n+     * This case is also applicable to setSafe() methods which can trigger\n+     * a realloc() and thus we record the state there as well.\n+     */\n+    if (valueCount > 0) {\n+      if (currentValueCapacity >= (valueCount * 2)) {\n+        incrementAllocationMonitor();\n+      } else if (currentValueCapacity <= (valueCount / 2)) {\n+        decrementAllocationMonitor();\n+      }\n+    }\n+    setReaderAndWriterIndex();\n+  }\n+\n+  /**\n+   * Check if the given index is within the current value capacity\n+   * of the vector\n+   *\n+   * @param index  position to check\n+   * @return true if index is within the current value capacity\n+   */\n+  public boolean isSafe(int index) {\n+    return index < getValueCapacity();\n+  }\n+\n+  /**\n+   * Check if element at given index is null.\n+   *\n+   * @param index  position of element\n+   * @return true if element at given index is null, false otherwise\n+   */\n+  public boolean isNull(int index) {\n+    return (isSet(index) == 0);\n+  }\n+\n+  /**\n+   * Same as {@link #isNull(int)}.\n+   *\n+   * @param index  position of element\n+   * @return 1 if element at given index is not null, 0 otherwise\n+   */\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return Long.bitCount(b & (1L << bitIndex));\n+  }\n+\n+  /**\n+   * Mark the particular position in the vector as non-null.\n+   *\n+   * @param index position of the element.\n+   */\n+  @Override\n+  public void setIndexDefined(int index) {\n+    handleSafe(index);\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+  }\n+\n+  public void set(int index, byte[] value, int start, int length) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public void setSafe(int index, byte[] value, int start, int length) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public void set(int index, ByteBuffer value, int start, int length) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public void setSafe(int index, ByteBuffer value, int start, int length) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                helper methods for setters                      *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  protected void handleSafe(int index) {\n+    while (index >= getValueCapacity()) {\n+      decrementAllocationMonitor();\n+      reAlloc();\n+    }\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java b/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\nnew file mode 100644\nindex 000000000..edf4987de\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\n@@ -0,0 +1,1250 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.NullableMapVector;\n+import org.apache.arrow.vector.schema.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public abstract class BaseNullableVariableWidthVector extends BaseValueVector\n+        implements VariableWidthVector, FieldVector, NullableVectorDefinitionSetter {\n+  private static final int DEFAULT_RECORD_BYTE_COUNT = 8;\n+  private static final int INITIAL_BYTE_COUNT = INITIAL_VALUE_ALLOCATION * DEFAULT_RECORD_BYTE_COUNT;\n+\n+  private int valueAllocationSizeInBytes;\n+  private int validityAllocationSizeInBytes;\n+  private int offsetAllocationSizeInBytes;\n+\n+  /* protected members */\n+  public static final int OFFSET_WIDTH = 4; /* 4 byte unsigned int to track offsets */\n+  protected static final byte[] emptyByteArray = new byte[]{};\n+  protected ArrowBuf validityBuffer;\n+  protected ArrowBuf valueBuffer;\n+  protected ArrowBuf offsetBuffer;\n+  protected int valueCount;\n+  protected int lastSet;\n+  protected final Field field;\n+  private boolean cleared;\n+\n+  public BaseNullableVariableWidthVector(final String name, final BufferAllocator allocator,\n+                                         FieldType fieldType) {\n+    super(name, allocator);\n+    valueAllocationSizeInBytes = INITIAL_BYTE_COUNT;\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    offsetAllocationSizeInBytes = (INITIAL_VALUE_ALLOCATION) * OFFSET_WIDTH;\n+    field = new Field(name, fieldType, null);\n+    valueCount = 0;\n+    lastSet = -1;\n+    offsetBuffer = allocator.getEmpty();\n+    validityBuffer = allocator.getEmpty();\n+    valueBuffer = allocator.getEmpty();\n+    cleared = false;\n+  }\n+\n+  /* TODO:\n+   * see if getNullCount() can be made faster -- O(1)\n+   */\n+\n+  /* TODO:\n+   * Once the entire hierarchy has been refactored, move common functions\n+   * like getNullCount(), splitAndTransferValidityBuffer to top level\n+   * base class BaseValueVector.\n+   *\n+   * Along with this, some class members (validityBuffer) can also be\n+   * abstracted out to top level base class.\n+   *\n+   * Right now BaseValueVector is the top level base class for other\n+   * vector types in ValueVector hierarchy (non-nullable) and those\n+   * vectors have not yet been refactored/removed so moving things to\n+   * the top class as of now is not a good idea.\n+   */\n+\n+  @Override\n+  @Deprecated\n+  public VariableWidthMutator getMutator() {\n+    throw new UnsupportedOperationException(\"Mutator is not supported for writing into vector\");\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public VariableWidthAccessor getAccessor() {\n+    throw new UnsupportedOperationException(\"Accessor is not supported for reading from vector\");\n+  }\n+\n+  /**\n+   * Get buffer that manages the validity (NULL or NON-NULL nature) of\n+   * elements in the vector. Consider it as a buffer for internal bit vector\n+   * data structure.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  /**\n+   * Get the buffer that stores the data for elements in the vector.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    return valueBuffer;\n+  }\n+\n+  /**\n+   * buffer that stores the offsets for elements\n+   * in the vector. This operation is not supported for fixed-width vectors.\n+   * @return buffer\n+   */\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the offsets for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return offsetBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that manages the validity\n+   * (NULL or NON-NULL nature) of elements in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return validityBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Get the memory address of buffer that stores the data for elements\n+   * in the vector.\n+   * @return starting address of the buffer\n+   */\n+  @Override\n+  public long getDataBufferAddress() {\n+    return valueBuffer.memoryAddress();\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   * @param valueCount desired number of elements in the vector\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount) {\n+    final long size = (long) valueCount * DEFAULT_RECORD_BYTE_COUNT;\n+    if (size > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+    valueAllocationSizeInBytes = (int) size;\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(valueCount);\n+    /* to track the end offset of last data element in vector, we need\n+     * an additional slot in offset buffer.\n+     */\n+    offsetAllocationSizeInBytes = (valueCount + 1) * OFFSET_WIDTH;\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    final int offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n+    return Math.min(offsetValueCapacity, getValidityBufferValueCapacity());\n+  }\n+\n+  private int getValidityBufferValueCapacity() {\n+    return (int) (validityBuffer.capacity() * 8L);\n+  }\n+\n+  private int getOffsetBufferValueCapacity() {\n+    return (int) ((offsetBuffer.capacity() * 1.0) / OFFSET_WIDTH);\n+  }\n+\n+  /**\n+   * zero out the vector and the data in associated buffers.\n+   */\n+  public void zeroVector() {\n+    initValidityBuffer();\n+    initOffsetBuffer();\n+  }\n+\n+  /* zero out the validity buffer */\n+  private void initValidityBuffer() {\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+\n+  /* zero out the offset buffer */\n+  private void initOffsetBuffer() {\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+\n+  /**\n+   * Reset the vector to initial state. Same as {@link #zeroVector()}.\n+   * Note that this method doesn't release any memory.\n+   */\n+  public void reset() {\n+    zeroVector();\n+    lastSet = -1;\n+  }\n+\n+  /**\n+   * Close the vector and release the associated buffers.\n+   */\n+  @Override\n+  public void close() {\n+    clear();\n+  }\n+\n+  /**\n+   * Same as {@link #close()}\n+   */\n+  @Override\n+  public void clear() {\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    valueBuffer = releaseBuffer(valueBuffer);\n+    offsetBuffer = releaseBuffer(offsetBuffer);\n+    cleared = true;\n+    lastSet = -1;\n+    valueCount = 0;\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Initialize the children in schema for this Field. This operation is a\n+   * NO-OP for scalar types since they don't have any children.\n+   * @param children the schema\n+   * @throws IllegalArgumentException if children is a non-empty list for scalar types.\n+   */\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (!children.isEmpty()) {\n+      throw new IllegalArgumentException(\"primitive type vector can not have children\");\n+    }\n+  }\n+\n+  /**\n+   * Get the inner child vectors.\n+   * @return list of child vectors for complex types, empty list for scalar vector\n+   * types\n+   */\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return Collections.emptyList();\n+  }\n+\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+    ArrowBuf dataBuffer = ownBuffers.get(2);\n+\n+    validityBuffer.release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.release();\n+    offsetBuffer = offBuffer.retain(allocator);\n+    valueBuffer.release();\n+    valueBuffer = dataBuffer.retain(allocator);\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector\n+   * @return the inner buffers.\n+   */\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(3);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+    result.add(valueBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    valueBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+      valueBuffer.writerIndex(0);\n+    } else {\n+      final int lastDataOffset = getstartOffset(valueCount);\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+      valueBuffer.writerIndex(lastDataOffset);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory.\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector. See {@link #allocateNew(int, int)} for allocating memory for specific\n+   * number of elements in the vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  @Override\n+  public boolean allocateNewSafe() {\n+    long curAllocationSizeValue = valueAllocationSizeInBytes;\n+    long curAllocationSizeValidity = validityAllocationSizeInBytes;\n+    long curAllocationSizeOffset = offsetAllocationSizeInBytes;\n+\n+    if (curAllocationSizeValue > MAX_ALLOCATION_SIZE ||\n+            curAllocationSizeOffset > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory exceeds limit\");\n+    }\n+\n+    /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(curAllocationSizeValue, curAllocationSizeValidity, curAllocationSizeOffset);\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Allocate memory for the vector to support storing at least the provided number of\n+   * elements in the vector. This method must be called prior to using the ValueVector.\n+   *\n+   * @param totalBytes desired total memory capacity\n+   * @param valueCount the desired number of elements in the vector\n+   * @throws org.apache.arrow.memory.OutOfMemoryException\n+   */\n+  @Override\n+  public void allocateNew(int totalBytes, int valueCount) {\n+    assert totalBytes >= 0;\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+\n+    if (totalBytes > MAX_ALLOCATION_SIZE ||\n+            offsetBufferSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory exceeds limit\");\n+    }\n+\n+    /* we are doing a new allocation -- release the current buffers */\n+    clear();\n+\n+    try {\n+      allocateBytes(totalBytes, validityBufferSize, offsetBufferSize);\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+    }\n+  }\n+\n+  /* allocate the inner buffers */\n+  private void allocateBytes(final long valueBufferSize, final long validityBufferSize,\n+                             final long offsetBufferSize) {\n+    /* allocate data buffer */\n+    int curSize = (int) valueBufferSize;\n+    valueBuffer = allocator.buffer(curSize);\n+    valueBuffer.readerIndex(0);\n+    valueAllocationSizeInBytes = curSize;\n+    allocateValidityBuffer(validityBufferSize);\n+    allocateOffsetBuffer(offsetBufferSize);\n+  }\n+\n+  /* allocate offset buffer */\n+  private void allocateOffsetBuffer(final long size) {\n+    final int curSize = (int) size;\n+    offsetBuffer = allocator.buffer(curSize);\n+    offsetBuffer.readerIndex(0);\n+    offsetAllocationSizeInBytes = curSize;\n+    initOffsetBuffer();\n+  }\n+\n+  /* allocate validity buffer */\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    initValidityBuffer();\n+  }\n+\n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  public void reAlloc() {\n+    reallocDataBuffer();\n+    reallocValidityAndOffsetBuffers();\n+  }\n+\n+  /**\n+   * Reallocate the data buffer. Data Buffer stores the actual data for\n+   * VARCHAR or VARBINARY elements in the vector. The behavior is to double\n+   * the size of buffer.\n+   * @throws OversizedAllocationException if the desired new size is more than\n+   *                                      max allowed\n+   * @throws OutOfMemoryException if the internal memory allocation fails\n+   */\n+  public void reallocDataBuffer() {\n+    long baseSize = valueAllocationSizeInBytes;\n+    final int currentBufferCapacity = valueBuffer.capacity();\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, valueBuffer, 0, currentBufferCapacity);\n+    valueBuffer.release();\n+    valueBuffer = newBuf;\n+    valueAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  /**\n+   * Reallocate the validity and offset buffers for this vector. Validity\n+   * buffer is used to track the NULL or NON-NULL nature of elements in\n+   * the vector and offset buffer is used to store the lengths of variable\n+   * width elements in the vector.\n+   *\n+   * Note that data buffer for variable length vectors moves independent\n+   * of the companion validity and offset buffers. This is in\n+   * contrast to what we have for fixed width vectors.\n+   *\n+   * So even though we may have setup an initial capacity of 1024\n+   * elements in the vector, it is quite possible\n+   * that we need to reAlloc() the data buffer when we are setting\n+   * the 5th element in the vector simply because previous\n+   * variable length elements have exhausted the buffer capacity.\n+   * However, we really don't need to reAlloc() validity and\n+   * offset buffers until we try to set the 1025th element\n+   * This is why we do a separate check for safe methods to\n+   * determine which buffer needs reallocation.\n+   * @throws OversizedAllocationException if the desired new size is more than\n+   *                                      max allowed\n+   * @throws OutOfMemoryException if the internal memory allocation fails\n+   */\n+  public void reallocValidityAndOffsetBuffers() {\n+    offsetBuffer = reallocBufferHelper(offsetBuffer, true);\n+    validityBuffer = reallocBufferHelper(validityBuffer, false);\n+  }\n+\n+  /* helper method to realloc a particular buffer. returns the allocated buffer */\n+  private ArrowBuf reallocBufferHelper(ArrowBuf buffer, final boolean offsetBuffer) {\n+    final int currentBufferCapacity = buffer.capacity();\n+    long baseSize = (offsetBuffer ? offsetAllocationSizeInBytes\n+            : validityAllocationSizeInBytes);\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, buffer, 0, currentBufferCapacity);\n+    final int halfNewCapacity = newBuf.capacity() / 2;\n+    newBuf.setZero(halfNewCapacity, halfNewCapacity);\n+    buffer.release(1);\n+    buffer = newBuf;\n+    if (offsetBuffer) {\n+      offsetAllocationSizeInBytes = (int) newAllocationSize;\n+    } else {\n+      validityAllocationSizeInBytes = (int) newAllocationSize;\n+    }\n+\n+    return buffer;\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying data buffer.\n+   * @return\n+   */\n+  @Override\n+  public int getByteCapacity() {\n+    return valueBuffer.capacity();\n+  }\n+\n+  @Override\n+  public int getCurrentSizeInBytes() {\n+      /* TODO */\n+    return 0;\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    return getBufferSizeFor(this.valueCount);\n+  }\n+\n+  /**\n+   * Get the potential buffer size for a particular number of records.\n+   * @param valueCount desired number of elements in the vector\n+   * @return estimated size of underlying buffers if the vector holds\n+   *         a given number of elements\n+   */\n+  @Override\n+  public int getBufferSizeFor(final int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+      /* get the end offset for this valueCount */\n+    final int dataBufferSize = offsetBuffer.getInt(valueCount * OFFSET_WIDTH);\n+    return validityBufferSize + offsetBufferSize + dataBufferSize;\n+  }\n+\n+  /**\n+   * Get information about how this field is materialized.\n+   * @return the field corresponding to this vector\n+   */\n+  @Override\n+  public Field getField() {\n+    return field;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    final ArrowBuf[] buffers;\n+    setReaderAndWriterIndex();\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = new ArrowBuf[3];\n+      buffers[0] = validityBuffer;\n+      buffers[1] = offsetBuffer;\n+      buffers[2] = valueBuffer;\n+    }\n+    if (clear) {\n+      for (final ArrowBuf buffer : buffers) {\n+        buffer.retain(1);\n+      }\n+      clear();\n+    }\n+    return buffers;\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @param callBack\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return getTransferPair(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  @Override\n+  public TransferPair getTransferPair(BufferAllocator allocator) {\n+    return getTransferPair(name, allocator);\n+  }\n+\n+  /**\n+   * Construct a transfer pair of this vector and another vector of same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return TransferPair\n+   */\n+  public abstract TransferPair getTransferPair(String ref, BufferAllocator allocator);\n+\n+  /**\n+   * Transfer this vector'data to another vector. The memory associated\n+   * with this vector is transferred to the allocator of target vector\n+   * for accounting and management purposes.\n+   * @param target destination vector for transfer\n+   */\n+  public void transferTo(BaseNullableVariableWidthVector target) {\n+    compareTypes(target, \"transferTo\");\n+    target.clear();\n+    target.validityBuffer = validityBuffer.transferOwnership(target.allocator).buffer;\n+    target.valueBuffer = valueBuffer.transferOwnership(target.allocator).buffer;\n+    target.offsetBuffer = offsetBuffer.transferOwnership(target.allocator).buffer;\n+    target.setLastSet(this.lastSet);\n+    if (this.valueCount > 0) {\n+      target.setValueCount(this.valueCount);\n+    }\n+    clear();\n+  }\n+\n+  /**\n+   * Slice this vector at desired index and length and transfer the\n+   * corresponding data to the target vector.\n+   * @param startIndex start position of the split in source vector.\n+   * @param length length of the split.\n+   * @param target destination vector\n+   */\n+  public void splitAndTransferTo(int startIndex, int length,\n+                                 BaseNullableVariableWidthVector target) {\n+    compareTypes(target, \"splitAndTransferTo\");\n+    target.clear();\n+    splitAndTransferValidityBuffer(startIndex, length, target);\n+    splitAndTransferOffsetBuffer(startIndex, length, target);\n+    target.setLastSet(length - 1);\n+    if (this.valueCount > 0) {\n+      target.setValueCount(this.valueCount);\n+    }\n+  }\n+\n+  /*\n+   * Transfer the offsets along with data. Unlike the data buffer, we cannot simply\n+   * slice the offset buffer for split and transfer. The reason is that offsets\n+   * in the target vector have to be adjusted and made relative to the staring\n+   * offset in source vector from the start index of split. This is why, we\n+   * need to explicitly allocate the offset buffer and set the adjusted offsets\n+   * in the target vector.\n+   */\n+  private void splitAndTransferOffsetBuffer(int startIndex, int length, BaseNullableVariableWidthVector target) {\n+    final int start = offsetBuffer.getInt(startIndex * OFFSET_WIDTH);\n+    final int end = offsetBuffer.getInt((startIndex + length) * OFFSET_WIDTH);\n+    final int dataLength = end - start;\n+    target.allocateOffsetBuffer((length + 1) * OFFSET_WIDTH);\n+    for (int i = 0; i < length + 1; i++) {\n+      final int relativeSourceOffset = offsetBuffer.getInt((startIndex + i) * OFFSET_WIDTH) - start;\n+      target.offsetBuffer.setInt(i * OFFSET_WIDTH, relativeSourceOffset);\n+    }\n+    target.valueBuffer = valueBuffer.slice(start, dataLength).transferOwnership(target.allocator).buffer;\n+  }\n+\n+  /*\n+   * Transfer the validity.\n+   */\n+  private void splitAndTransferValidityBuffer(int startIndex, int length,\n+                                              BaseNullableVariableWidthVector target) {\n+    assert startIndex + length <= valueCount;\n+    int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+    int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+    int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+    int offset = startIndex % 8;\n+\n+    if (length > 0) {\n+      if (offset == 0) {\n+        // slice\n+        if (target.validityBuffer != null) {\n+          target.validityBuffer.release();\n+        }\n+        target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+        target.validityBuffer.retain(1);\n+      } else {\n+        /* Copy data\n+         * When the first bit starts from the middle of a byte (offset != 0),\n+         * copy data from src BitVector.\n+         * Each byte in the target is composed by a part in i-th byte,\n+         * another part in (i+1)-th byte.\n+         */\n+        target.allocateValidityBuffer(byteSizeTarget);\n+\n+        for (int i = 0; i < byteSizeTarget - 1; i++) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer, firstByteSource + i, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer, firstByteSource + i + 1, offset);\n+\n+          target.validityBuffer.setByte(i, (b1 + b2));\n+        }\n+        /* Copying the last piece is done in the following manner:\n+         * if the source vector has 1 or more bytes remaining, we copy\n+         * the last piece as a byte formed by shifting data\n+         * from the current byte and the next byte.\n+         *\n+         * if the source vector has no more bytes remaining\n+         * (we are at the last byte), we copy the last piece as a byte\n+         * by shifting data from the current byte.\n+         */\n+        if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer,\n+                  firstByteSource + byteSizeTarget, offset);\n+\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+        } else {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+        }\n+      }\n+    }\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                common getters and setters                      *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the number of elements that are null in the vector\n+   *\n+   * @return the number of null elements.\n+   */\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  /**\n+   * Check if the given index is within the current value capacity\n+   * of the vector\n+   *\n+   * @param index  position to check\n+   * @return true if index is within the current value capacity\n+   */\n+  public boolean isSafe(int index) {\n+    return index < getValueCapacity();\n+  }\n+\n+  /**\n+   * Check if element at given index is null.\n+   *\n+   * @param index  position of element\n+   * @return true if element at given index is null\n+   */\n+  public boolean isNull(int index) {\n+    return (isSet(index) == 0);\n+  }\n+\n+  /**\n+   * Same as {@link #isNull(int)}.\n+   *\n+   * @param index  position of element\n+   * @return 1 if element at given index is not null, 0 otherwise\n+   */\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return Long.bitCount(b & (1L << bitIndex));\n+  }\n+\n+  /**\n+   * Get the value count of vector. This will always be zero unless\n+   * setValueCount(int) has been called prior to calling this.\n+   *\n+   * @return valueCount for the vector\n+   */\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n+\n+  /**\n+   * Sets the value count for the vector\n+   *\n+   * @param valueCount   value count\n+   */\n+  public void setValueCount(int valueCount) {\n+    assert valueCount >= 0;\n+    this.valueCount = valueCount;\n+    while (valueCount > getValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    fillHoles(valueCount);\n+    lastSet = valueCount - 1;\n+    setReaderAndWriterIndex();\n+  }\n+\n+  /**\n+   * Create holes in the vector upto the given index (exclusive).\n+   * Holes will be created from the current last set position in\n+   * the vector.\n+   *\n+   * @param index target index\n+   */\n+  public void fillEmpties(int index) {\n+    handleSafe(index, emptyByteArray.length);\n+    fillHoles(index);\n+    lastSet = index - 1;\n+  }\n+\n+  /**\n+   * Set the index of last non-null element in the vector.\n+   * It is important to call this method with appropriate value\n+   * before calling {@link #setValueCount(int)}.\n+   *\n+   * @param value desired index of last non-null element.\n+   */\n+  public void setLastSet(int value) {\n+    lastSet = value;\n+  }\n+\n+  /**\n+   * Get the index of last non-null element in the vector.\n+   *\n+   * @return index of the last non-null element\n+   */\n+  public int getLastSet() {\n+    return lastSet;\n+  }\n+\n+  /**\n+   * Get the starting position (offset) in the data stream for a given\n+   * element in the vector.\n+   *\n+   * @param index position of the element in the vector\n+   * @return starting offset for the element\n+   */\n+  public long getStartEnd(int index) {\n+    return offsetBuffer.getLong(index * OFFSET_WIDTH);\n+  }\n+\n+  /**\n+   * Mark the particular position in the vector as non-null.\n+   *\n+   * @param index position of the element.\n+   */\n+  @Override\n+  public void setIndexDefined(int index) {\n+    while (index >= getValidityBufferValueCapacity()) {\n+      validityBuffer = reallocBufferHelper(validityBuffer, false);\n+    }\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+  }\n+\n+  /**\n+   * Sets the value length for an element.\n+   *\n+   * @param index   position of the element to set\n+   * @param length  length of the element\n+   */\n+  public void setValueLengthSafe(int index, int length) {\n+    assert index >= 0;\n+    handleSafe(index, length);\n+    fillHoles(index);\n+    final int startOffset = getstartOffset(index);\n+    offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + length);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Get the variable length element at specified index as Text.\n+   *\n+   * @param index   position of element to get\n+   * @return greater than 0 length for non-null element, 0 otherwise\n+   */\n+  public int getValueLength(int index) {\n+    assert index >= 0;\n+    if (isSet(index) == 0) {\n+      return 0;\n+    }\n+    final int startOffset = getstartOffset(index);\n+    final int dataLength =\n+            offsetBuffer.getInt((index + 1) * OFFSET_WIDTH) - startOffset;\n+    return dataLength;\n+  }\n+\n+  /**\n+   * Set the variable length element at the specified index to the supplied\n+   * byte array. This is same as using {@link #set(int, byte[], int, int)}\n+   * with start as 0 and length as value.length\n+   *\n+   * @param index   position of the element to set\n+   * @param value   array of bytes to write\n+   */\n+  public void set(int index, byte[] value) {\n+    assert index >= 0;\n+    fillHoles(index);\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setBytes(index, value, 0, value.length);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, byte[])} except that it handles the\n+   * case where index and length of new element are beyond the existing\n+   * capacity of the vector.\n+   *\n+   * @param index   position of the element to set\n+   * @param value   array of bytes to write\n+   */\n+  public void setSafe(int index, byte[] value) {\n+    assert index >= 0;\n+    fillEmpties(index);\n+    handleSafe(index, value.length);\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setBytes(index, value, 0, value.length);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Set the variable length element at the specified index to the supplied\n+   * byte array.\n+   *\n+   * @param index   position of the element to set\n+   * @param value   array of bytes to write\n+   * @param start   start index in array of bytes\n+   * @param length  length of data in array of bytes\n+   */\n+  public void set(int index, byte[] value, int start, int length) {\n+    assert index >= 0;\n+    fillHoles(index);\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setBytes(index, value, start, length);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, byte[], int, int)} except that it handles the\n+   * case where index and length of new element are beyond the existing\n+   * capacity of the vector.\n+   *\n+   * @param index   position of the element to set\n+   * @param value   array of bytes to write\n+   * @param start   start index in array of bytes\n+   * @param length  length of data in array of bytes\n+   */\n+  public void setSafe(int index, byte[] value, int start, int length) {\n+    assert index >= 0;\n+    fillEmpties(index);\n+    handleSafe(index, length);\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setBytes(index, value, start, length);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Set the variable length element at the specified index to the\n+   * content in supplied ByteBuffer\n+   *\n+   * @param index   position of the element to set\n+   * @param value   ByteBuffer with data\n+   * @param start   start index in ByteBuffer\n+   * @param length  length of data in ByteBuffer\n+   */\n+  public void set(int index, ByteBuffer value, int start, int length) {\n+    assert index >= 0;\n+    fillHoles(index);\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    final int startOffset = getstartOffset(index);\n+    offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + length);\n+    valueBuffer.setBytes(startOffset, value, start, length);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, ByteBuffer, int, int)} except that it handles the\n+   * case where index and length of new element are beyond the existing\n+   * capacity of the vector.\n+   *\n+   * @param index   position of the element to set\n+   * @param value   ByteBuffer with data\n+   * @param start   start index in ByteBuffer\n+   * @param length  length of data in ByteBuffer\n+   */\n+  public void setSafe(int index, ByteBuffer value, int start, int length) {\n+    assert index >= 0;\n+    fillEmpties(index);\n+    handleSafe(index, length);\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    final int startOffset = getstartOffset(index);\n+    offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + length);\n+    valueBuffer.setBytes(startOffset, value, start, length);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Set the element at the given index to null.\n+   *\n+   * @param index   position of element\n+   */\n+  public void setNull(int index) {\n+    while (index >= getValidityBufferValueCapacity()) {\n+      validityBuffer = reallocBufferHelper(validityBuffer, false);\n+    }\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n+\n+  /**\n+   * Store the given value at a particular position in the vector. isSet indicates\n+   * whether the value is NULL or not.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param start start position of data in buffer\n+   * @param end end position of data in buffer\n+   * @param buffer data buffer containing the variable width element to be stored\n+   *               in the vector\n+   */\n+  public void set(int index, int isSet, int start, int end, ArrowBuf buffer) {\n+    assert index >= 0;\n+    final int dataLength = end - start;\n+    fillHoles(index);\n+    BitVectorHelper.setValidityBit(validityBuffer, index, isSet);\n+    final int startOffset = offsetBuffer.getInt(index * OFFSET_WIDTH);\n+    offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + dataLength);\n+    valueBuffer.setBytes(startOffset, buffer, start, dataLength);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int, int, int, ArrowBuf)} except that it handles the case\n+   * when index is greater than or equal to current value capacity of the\n+   * vector.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param start start position of data in buffer\n+   * @param end end position of data in buffer\n+   * @param buffer data buffer containing the variable width element to be stored\n+   *               in the vector\n+   */\n+  public void setSafe(int index, int isSet, int start, int end, ArrowBuf buffer) {\n+    assert index >= 0;\n+    final int dataLength = end - start;\n+    fillEmpties(index);\n+    handleSafe(index, end);\n+    BitVectorHelper.setValidityBit(validityBuffer, index, isSet);\n+    final int startOffset = offsetBuffer.getInt(index * OFFSET_WIDTH);\n+    offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + dataLength);\n+    valueBuffer.setBytes(startOffset, buffer, start, dataLength);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Store the given value at a particular position in the vector. isSet indicates\n+   * whether the value is NULL or not.\n+   * @param index position of the new value\n+   * @param start start position of data in buffer\n+   * @param length length of data in buffer\n+   * @param buffer data buffer containing the variable width element to be stored\n+   *               in the vector\n+   */\n+  public void set(int index, int start, int length, ArrowBuf buffer) {\n+    assert index >= 0;\n+    fillHoles(index);\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    final int startOffset = offsetBuffer.getInt(index * OFFSET_WIDTH);\n+    offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + length);\n+    final ArrowBuf bb = buffer.slice(start, length);\n+    valueBuffer.setBytes(startOffset, bb);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int, int, int, ArrowBuf)} except that it handles the case\n+   * when index is greater than or equal to current value capacity of the\n+   * vector.\n+   * @param index position of the new value\n+   * @param start start position of data in buffer\n+   * @param length length of data in buffer\n+   * @param buffer data buffer containing the variable width element to be stored\n+   *               in the vector\n+   */\n+  public void setSafe(int index, int start, int length, ArrowBuf buffer) {\n+    assert index >= 0;\n+    fillEmpties(index);\n+    handleSafe(index, length);\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    final int startOffset = offsetBuffer.getInt(index * OFFSET_WIDTH);\n+    offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + length);\n+    final ArrowBuf bb = buffer.slice(start, length);\n+    valueBuffer.setBytes(startOffset, bb);\n+    lastSet = index;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                helper methods for setters                      *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  protected final void fillHoles(int index) {\n+    for (int i = lastSet + 1; i < index; i++) {\n+      setBytes(i, emptyByteArray, 0, emptyByteArray.length);\n+    }\n+    lastSet = index - 1;\n+  }\n+\n+  protected final void setBytes(int index, byte[] value, int start, int length) {\n+    /* end offset of current last element in the vector. this will\n+     * be the start offset of new element we are trying to store.\n+     */\n+    final int startOffset = getstartOffset(index);\n+    /* set new end offset */\n+    offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + length);\n+    /* store the var length data in value buffer */\n+    valueBuffer.setBytes(startOffset, value, start, length);\n+  }\n+\n+  protected final int getstartOffset(int index) {\n+    return offsetBuffer.getInt(index * OFFSET_WIDTH);\n+  }\n+\n+  protected final void handleSafe(int index, int dataLength) {\n+    /*\n+     * IMPORTANT:\n+     * value buffer for variable length vectors moves independent\n+     * of the companion validity and offset buffers. This is in\n+     * contrast to what we have for fixed width vectors.\n+     *\n+     * Here there is no concept of getValueCapacity() in the\n+     * data stream. getValueCapacity() is applicable only to validity\n+     * and offset buffers.\n+     *\n+     * So even though we may have setup an initial capacity of 1024\n+     * elements in the vector, it is quite possible\n+     * that we need to reAlloc() the data buffer when we are setting\n+     * the 5th element in the vector simply because previous\n+     * variable length elements have exhausted the buffer capacity.\n+     * However, we really don't need to reAlloc() validity and\n+     * offset buffers until we try to set the 1025th element\n+     * This is why we do a separate check for safe methods to\n+     * determine which buffer needs reallocation.\n+     */\n+    while (index >= getValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    final int startOffset = getstartOffset(index);\n+    while (valueBuffer.capacity() < (startOffset + dataLength)) {\n+      reallocDataBuffer();\n+    }\n+  }\n+\n+  /**\n+   * Method used by Json Writer to read a variable width element from\n+   * the variable width vector and write to Json.\n+   *\n+   * This method should not be used externally.\n+   *\n+   * @param data buffer storing the variable width vector elements\n+   * @param offset buffer storing the offsets of variable width vector elements\n+   * @param index position of the element in the vector\n+   * @return array of bytes\n+   */\n+  public static byte[] get(final ArrowBuf data, final ArrowBuf offset, int index) {\n+    final int currentStartOffset = offset.getInt(index * OFFSET_WIDTH);\n+    final int dataLength =\n+            offset.getInt((index + 1) * OFFSET_WIDTH) - currentStartOffset;\n+    final byte[] result = new byte[dataLength];\n+    data.getBytes(currentStartOffset, result, 0, dataLength);\n+    return result;\n+  }\n+\n+  /**\n+   * Method used by Json Reader to explicitly set the offsets of the variable\n+   * width vector data. The method takes care of allocating the memory for\n+   * offsets if the caller hasn't done so.\n+   *\n+   * This method should not be used externally.\n+   *\n+   * @param buffer ArrowBuf to store offsets for variable width elements\n+   * @param allocator memory allocator\n+   * @param valueCount number of elements\n+   * @param index position of the element\n+   * @param value offset of the element\n+   * @return buffer holding the offsets\n+   */\n+  public static ArrowBuf set(ArrowBuf buffer, BufferAllocator allocator,\n+                             int valueCount, int index, int value) {\n+    if (buffer == null) {\n+      buffer = allocator.buffer(valueCount * OFFSET_WIDTH);\n+    }\n+    buffer.setInt(index * OFFSET_WIDTH, value);\n+    if (index == (valueCount - 1)) {\n+      buffer.writerIndex(valueCount * OFFSET_WIDTH);\n+    }\n+\n+    return buffer;\n+  }\n+}\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/BaseValueVector.java b/java/vector/src/main/java/org/apache/arrow/vector/BaseValueVector.java\nindex 598e578e5..fc0ab3e59 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/BaseValueVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/BaseValueVector.java\n@@ -6,9 +6,9 @@\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- *\n+ * <p>\n  * http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * <p>\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -18,8 +18,10 @@\n \n package org.apache.arrow.vector;\n \n+import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Iterator;\n+import java.util.List;\n \n import com.google.flatbuffers.FlatBufferBuilder;\n import org.apache.arrow.memory.BufferAllocator;\n@@ -54,7 +56,6 @@ public String toString() {\n \n   @Override\n   public void clear() {\n-    getMutator().reset();\n   }\n \n   @Override\n@@ -122,5 +123,49 @@ public static boolean checkBufRefs(final ValueVector vv) {\n   public BufferAllocator getAllocator() {\n     return allocator;\n   }\n+\n+  protected void compareTypes(BaseValueVector target, String caller) {\n+    if (this.getMinorType() != target.getMinorType()) {\n+      throw new UnsupportedOperationException(caller + \" should have vectors of exact same type\");\n+    }\n+  }\n+\n+  protected ArrowBuf releaseBuffer(ArrowBuf buffer) {\n+    buffer.release();\n+    buffer = allocator.getEmpty();\n+    return buffer;\n+  }\n+\n+  @Override\n+  public int getValueCount() {\n+    return getAccessor().getValueCount();\n+  }\n+\n+  @Override\n+  public void setValueCount(int valueCount) {\n+    getMutator().setValueCount(valueCount);\n+  }\n+\n+  @Override\n+\n+  public Object getObject(int index) {\n+    return getAccessor().getObject(index);\n+  }\n+\n+  @Override\n+\n+  public int getNullCount() {\n+    return getAccessor().getNullCount();\n+  }\n+\n+  @Override\n+  public boolean isNull(int index) {\n+    return getAccessor().isNull(index);\n+  }\n+\n+  /* number of bytes for the validity buffer for the given valueCount */\n+  protected static int getValidityBufferSizeFromCount(final int valueCount) {\n+    return (int) Math.ceil(valueCount / 8.0);\n+  }\n }\n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/BitVector.java b/java/vector/src/main/java/org/apache/arrow/vector/BitVector.java\nindex 591d13c4b..c6d404e15 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/BitVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/BitVector.java\n@@ -251,12 +251,12 @@ public void copyFromSafe(int inIndex, int outIndex, BitVector from) {\n \n   @Override\n   public Mutator getMutator() {\n-    return new Mutator();\n+    return mutator;\n   }\n \n   @Override\n   public Accessor getAccessor() {\n-    return new Accessor();\n+    return accessor;\n   }\n \n   @Override\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/BitVectorHelper.java b/java/vector/src/main/java/org/apache/arrow/vector/BitVectorHelper.java\nnew file mode 100644\nindex 000000000..23252ca69\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/BitVectorHelper.java\n@@ -0,0 +1,201 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.schema.ArrowFieldNode;\n+\n+/**\n+ * Helper class for performing generic operations on a bit vector buffer.\n+ * External use of this class is not recommended.\n+ */\n+public class BitVectorHelper {\n+\n+  /**\n+   * Get the index of byte corresponding to bit index in validity buffer\n+   */\n+  public static int byteIndex(int absoluteBitIndex) {\n+    return absoluteBitIndex >> 3;\n+  }\n+\n+  /**\n+   * Get the relative index of bit within the byte in validity buffer\n+   */\n+  public static int bitIndex(int absoluteBitIndex) {\n+    return absoluteBitIndex & 7;\n+  }\n+\n+  /**\n+   * Set the bit at provided index to 1.\n+   *\n+   * @param validityBuffer\n+   * @param index\n+   */\n+  public static void setValidityBitToOne(ArrowBuf validityBuffer, int index) {\n+    final int byteIndex = byteIndex(index);\n+    final int bitIndex = bitIndex(index);\n+    byte currentByte = validityBuffer.getByte(byteIndex);\n+    final byte bitMask = (byte) (1L << bitIndex);\n+    currentByte |= bitMask;\n+    validityBuffer.setByte(byteIndex, currentByte);\n+  }\n+\n+  /**\n+   * Set the bit at a given index to provided value (1 or 0)\n+   *\n+   * @param validityBuffer\n+   * @param index\n+   * @param value\n+   */\n+  public static void setValidityBit(ArrowBuf validityBuffer, int index, int value) {\n+    final int byteIndex = byteIndex(index);\n+    final int bitIndex = bitIndex(index);\n+    byte currentByte = validityBuffer.getByte(byteIndex);\n+    final byte bitMask = (byte) (1L << bitIndex);\n+    if (value != 0) {\n+      currentByte |= bitMask;\n+    } else {\n+      currentByte -= (bitMask & currentByte);\n+    }\n+    validityBuffer.setByte(byteIndex, currentByte);\n+  }\n+\n+  /**\n+   * Set the bit at a given index to provided value (1 or 0). Internally\n+   * takes care of allocating the buffer if the caller didn't do so.\n+   *\n+   * @param validityBuffer\n+   * @param allocator\n+   * @param valueCount\n+   * @param index\n+   * @param value\n+   * @return ArrowBuf\n+   */\n+  public static ArrowBuf setValidityBit(ArrowBuf validityBuffer, BufferAllocator allocator,\n+                                        int valueCount, int index, int value) {\n+    if (validityBuffer == null) {\n+      validityBuffer = allocator.buffer(getValidityBufferSize(valueCount));\n+    }\n+    setValidityBit(validityBuffer, index, value);\n+    if (index == (valueCount - 1)) {\n+      validityBuffer.writerIndex(getValidityBufferSize(valueCount));\n+    }\n+\n+    return validityBuffer;\n+  }\n+\n+  /**\n+   * Check if a bit at a given index is set or not.\n+   *\n+   * @param buffer\n+   * @param index\n+   * @return 1 if bit is set, 0 otherwise.\n+   */\n+  public static int get(final ArrowBuf buffer, int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = buffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return Long.bitCount(b & (1L << bitIndex));\n+  }\n+\n+  /**\n+   * Compute the size of validity buffer required to manage a given number\n+   * of elements in a vector.\n+   *\n+   * @param valueCount\n+   * @return buffer size\n+   */\n+  public static int getValidityBufferSize(int valueCount) {\n+    return ((int) Math.ceil(valueCount / 8.0));\n+  }\n+\n+  /**\n+   * Given a validity buffer, find the number of bits that are not set.\n+   * This is used to compute the number of null elements in a nullable vector.\n+   *\n+   * @param validityBuffer\n+   * @param valueCount\n+   * @return number of bits not set.\n+   */\n+  public static int getNullCount(final ArrowBuf validityBuffer, final int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    int count = 0;\n+    final int sizeInBytes = getValidityBufferSize(valueCount);\n+\n+    for (int i = 0; i < sizeInBytes; ++i) {\n+      final byte byteValue = validityBuffer.getByte(i);\n+      /* Java uses two's complement binary representation, hence 11111111_b which is -1\n+       * when converted to Int will have 32bits set to 1. Masking the MSB and then\n+       * adding it back solves the issue.\n+       */\n+      count += Integer.bitCount(byteValue & 0x7F) - (byteValue >> 7);\n+    }\n+    int nullCount = (sizeInBytes * 8) - count;\n+    /* if the valueCount is not a multiple of 8,\n+     * the bits on the right were counted as null bits.\n+     */\n+    int remainder = valueCount % 8;\n+    nullCount -= remainder == 0 ? 0 : 8 - remainder;\n+    return nullCount;\n+  }\n+\n+  public static byte getBitsFromCurrentByte(final ArrowBuf data, final int index, final int offset) {\n+    return (byte) ((data.getByte(index) & 0xFF) >>> offset);\n+  }\n+\n+  public static byte getBitsFromNextByte(ArrowBuf data, int index, int offset) {\n+    return (byte) ((data.getByte(index) << (8 - offset)));\n+  }\n+\n+  public static ArrowBuf loadValidityBuffer(final ArrowFieldNode fieldNode,\n+                                            final ArrowBuf sourceValidityBuffer,\n+                                            final BufferAllocator allocator) {\n+    final int valueCount = fieldNode.getLength();\n+    ArrowBuf newBuffer = null;\n+    /* either all NULLs or all non-NULLs */\n+    if (fieldNode.getNullCount() == 0 || fieldNode.getNullCount() == valueCount) {\n+      newBuffer = allocator.buffer(getValidityBufferSize(valueCount));\n+      newBuffer.setZero(0, newBuffer.capacity());\n+      if (fieldNode.getNullCount() != 0) {\n+        /* all NULLs */\n+        return newBuffer;\n+      }\n+      /* all non-NULLs */\n+      int fullBytesCount = valueCount / 8;\n+      for (int i = 0; i < fullBytesCount; ++i) {\n+        newBuffer.setByte(i, 0xFF);\n+      }\n+      int remainder = valueCount % 8;\n+      if (remainder > 0) {\n+        byte bitMask = (byte) (0xFFL >>> ((8 - remainder) & 7));\n+        newBuffer.setByte(fullBytesCount, bitMask);\n+      }\n+    } else {\n+      /* mixed byte pattern -- create another ArrowBuf associated with the\n+       * target allocator\n+       */\n+      newBuffer = sourceValidityBuffer.retain(allocator);\n+    }\n+\n+    return newBuffer;\n+  }\n+}\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/GenerateSampleData.java b/java/vector/src/main/java/org/apache/arrow/vector/GenerateSampleData.java\nnew file mode 100644\nindex 000000000..806beb5f8\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/GenerateSampleData.java\n@@ -0,0 +1,336 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.Charset;\n+\n+/**\n+ * Helper class to generate test data for Nullable fixed and variable\n+ * width scalar vectors. Previous implementations of java vector classes\n+ * provided generateTestData(now deprecated) API to populate the vector\n+ * with sample data. This class should be used for that purpose.\n+ */\n+public class GenerateSampleData {\n+\n+  public static void generateTestData(final ValueVector vector, final int valueCount) {\n+    if (vector instanceof NullableIntVector) {\n+      writeIntData((NullableIntVector) vector, valueCount);\n+    } else if (vector instanceof NullableDecimalVector) {\n+      writeDecimalData((NullableDecimalVector) vector, valueCount);\n+    } else if (vector instanceof NullableBitVector) {\n+      writeBooleanData((NullableBitVector) vector, valueCount);\n+    } else if (vector instanceof NullableVarCharVector) {\n+      writeVarCharData((NullableVarCharVector) vector, valueCount);\n+    } else if (vector instanceof NullableVarBinaryVector) {\n+      writeVarBinaryData((NullableVarBinaryVector) vector, valueCount);\n+    } else if (vector instanceof NullableBigIntVector) {\n+      writeBigIntData((NullableBigIntVector) vector, valueCount);\n+    } else if (vector instanceof NullableFloat4Vector) {\n+      writeFloatData((NullableFloat4Vector) vector, valueCount);\n+    } else if (vector instanceof NullableFloat8Vector) {\n+      writeDoubleData((NullableFloat8Vector) vector, valueCount);\n+    } else if (vector instanceof NullableDateDayVector) {\n+      writeDateDayData((NullableDateDayVector) vector, valueCount);\n+    } else if (vector instanceof NullableDateMilliVector) {\n+      writeDateMilliData((NullableDateMilliVector) vector, valueCount);\n+    } else if (vector instanceof NullableIntervalDayVector) {\n+      writeIntervalDayData((NullableIntervalDayVector) vector, valueCount);\n+    } else if (vector instanceof NullableIntervalYearVector) {\n+      writeIntervalYearData((NullableIntervalYearVector) vector, valueCount);\n+    } else if (vector instanceof NullableSmallIntVector) {\n+      writeSmallIntData((NullableSmallIntVector) vector, valueCount);\n+    } else if (vector instanceof NullableTinyIntVector) {\n+      writeTinyIntData((NullableTinyIntVector) vector, valueCount);\n+    } else if (vector instanceof NullableTimeMicroVector) {\n+      writeTimeMicroData((NullableTimeMicroVector) vector, valueCount);\n+    } else if (vector instanceof NullableTimeMilliVector) {\n+      writeTimeMilliData((NullableTimeMilliVector) vector, valueCount);\n+    } else if (vector instanceof NullableTimeNanoVector) {\n+      writeTimeNanoData((NullableTimeNanoVector) vector, valueCount);\n+    } else if (vector instanceof NullableTimeSecVector) {\n+      writeTimeSecData((NullableTimeSecVector) vector, valueCount);\n+    } else if (vector instanceof NullableTimeStampSecVector) {\n+      writeTimeStampData((NullableTimeStampSecVector) vector, valueCount);\n+    } else if (vector instanceof NullableTimeStampMicroVector) {\n+      writeTimeStampData((NullableTimeStampMicroVector) vector, valueCount);\n+    } else if (vector instanceof NullableTimeStampMilliVector) {\n+      writeTimeStampData((NullableTimeStampMilliVector) vector, valueCount);\n+    } else if (vector instanceof NullableTimeStampNanoVector) {\n+      writeTimeStampData((NullableTimeStampNanoVector) vector, valueCount);\n+    } else if (vector instanceof NullableTimeStampSecTZVector) {\n+      writeTimeStampData((NullableTimeStampSecTZVector) vector, valueCount);\n+    } else if (vector instanceof NullableTimeStampMicroTZVector) {\n+      writeTimeStampData((NullableTimeStampMicroTZVector) vector, valueCount);\n+    } else if (vector instanceof NullableTimeStampMilliTZVector) {\n+      writeTimeStampData((NullableTimeStampMilliTZVector) vector, valueCount);\n+    } else if (vector instanceof NullableTimeStampNanoTZVector) {\n+      writeTimeStampData((NullableTimeStampNanoTZVector) vector, valueCount);\n+    }\n+  }\n+\n+  private static void writeTimeStampData(NullableTimeStampVector vector, int valueCount) {\n+    final long even = 100000;\n+    final long odd = 200000;\n+    for (int i = 0; i < valueCount; i++) {\n+      if (i % 2 == 0) {\n+        vector.setSafe(i, even);\n+      } else {\n+        vector.setSafe(i, odd);\n+      }\n+    }\n+    vector.setValueCount(valueCount);\n+  }\n+\n+  private static void writeDecimalData(NullableDecimalVector vector, int valueCount) {\n+    final BigDecimal even = new BigDecimal(0.0543278923);\n+    final BigDecimal odd = new BigDecimal(2.0543278923);\n+    for (int i = 0; i < valueCount; i++) {\n+      if (i % 2 == 0) {\n+        vector.setSafe(i, even);\n+      } else {\n+        vector.setSafe(i, odd);\n+      }\n+    }\n+    vector.setValueCount(valueCount);\n+  }\n+\n+  private static void writeIntData(NullableIntVector vector, int valueCount) {\n+    final int even = 1000;\n+    final int odd = 2000;\n+    for (int i = 0; i < valueCount; i++) {\n+      if (i % 2 == 0) {\n+        vector.setSafe(i, even);\n+      } else {\n+        vector.setSafe(i, odd);\n+      }\n+    }\n+    vector.setValueCount(valueCount);\n+  }\n+\n+  private static void writeBooleanData(NullableBitVector vector, int valueCount) {\n+    final int even = 0;\n+    final int odd = 1;\n+    for (int i = 0; i < valueCount; i++) {\n+      if (i % 2 == 0) {\n+        vector.setSafe(i, even);\n+      } else {\n+        vector.setSafe(i, odd);\n+      }\n+    }\n+    vector.setValueCount(valueCount);\n+  }\n+\n+  private static void writeIntervalYearData(NullableIntervalYearVector vector, int valueCount) {\n+    final int even = 1;\n+    final int odd = 2;\n+    for (int i = 0; i < valueCount; i++) {\n+      if (i % 2 == 0) {\n+        vector.setSafe(i, even);\n+      } else {\n+        vector.setSafe(i, odd);\n+      }\n+    }\n+    vector.setValueCount(valueCount);\n+  }\n+\n+  private static void writeIntervalDayData(NullableIntervalDayVector vector, int valueCount) {\n+    for (int i = 0; i < valueCount; i++) {\n+      if (i % 2 == 0) {\n+        vector.setSafe(i, 1, 50);\n+      } else {\n+        vector.setSafe(i, 2, 100);\n+      }\n+    }\n+    vector.setValueCount(valueCount);\n+  }\n+\n+  private static void writeTimeSecData(NullableTimeSecVector vector, int valueCount) {\n+    final int even = 500;\n+    final int odd = 900;\n+    for (int i = 0; i < valueCount; i++) {\n+      if (i % 2 == 0) {\n+        vector.setSafe(i, even);\n+      } else {\n+        vector.setSafe(i, odd);\n+      }\n+    }\n+    vector.setValueCount(valueCount);\n+  }\n+\n+  private static void writeTimeMilliData(NullableTimeMilliVector vector, int valueCount) {\n+    final int even = 1000;\n+    final int odd = 2000;\n+    for (int i = 0; i < valueCount; i++) {\n+      if (i % 2 == 0) {\n+        vector.setSafe(i, even);\n+      } else {\n+        vector.setSafe(i, odd);\n+      }\n+    }\n+    vector.setValueCount(valueCount);\n+  }\n+\n+  private static void writeTimeMicroData(NullableTimeMicroVector vector, int valueCount) {\n+    final long even = 1000000000;\n+    final long odd = 2000000000;\n+    for (int i = 0; i < valueCount; i++) {\n+      if (i % 2 == 0) {\n+        vector.setSafe(i, even);\n+      } else {\n+        vector.setSafe(i, odd);\n+      }\n+    }\n+    vector.setValueCount(valueCount);\n+\n+  }\n+\n+  private static void writeTimeNanoData(NullableTimeNanoVector vector, int valueCount) {\n+    final long even = 1000000000;\n+    final long odd = 2000000000;\n+    for (int i = 0; i < valueCount; i++) {\n+      if (i % 2 == 0) {\n+        vector.setSafe(i, even);\n+      } else {\n+        vector.setSafe(i, odd);\n+      }\n+    }\n+    vector.setValueCount(valueCount);\n+  }\n+\n+  private static void writeDateDayData(NullableDateDayVector vector, int valueCount) {\n+    final int even = 1000;\n+    final int odd = 2000;\n+    for (int i = 0; i < valueCount; i++) {\n+      if (i % 2 == 0) {\n+        vector.setSafe(i, even);\n+      } else {\n+        vector.setSafe(i, odd);\n+      }\n+    }\n+    vector.setValueCount(valueCount);\n+  }\n+\n+  private static void writeDateMilliData(NullableDateMilliVector vector, int valueCount) {\n+    final long even = 1000000000;\n+    final long odd = 2000000000;\n+    for (int i = 0; i < valueCount; i++) {\n+      if (i % 2 == 0) {\n+        vector.setSafe(i, even);\n+      } else {\n+        vector.setSafe(i, odd);\n+      }\n+    }\n+    vector.setValueCount(valueCount);\n+  }\n+\n+  private static void writeSmallIntData(NullableSmallIntVector vector, int valueCount) {\n+    final short even = 10;\n+    final short odd = 20;\n+    for (int i = 0; i < valueCount; i++) {\n+      if (i % 2 == 0) {\n+        vector.setSafe(i, even);\n+      } else {\n+        vector.setSafe(i, odd);\n+      }\n+    }\n+    vector.setValueCount(valueCount);\n+  }\n+\n+  private static void writeTinyIntData(NullableTinyIntVector vector, int valueCount) {\n+    final byte even = 1;\n+    final byte odd = 2;\n+    for (int i = 0; i < valueCount; i++) {\n+      if (i % 2 == 0) {\n+        vector.setSafe(i, even);\n+      } else {\n+        vector.setSafe(i, odd);\n+      }\n+    }\n+    vector.setValueCount(valueCount);\n+  }\n+\n+  private static void writeBigIntData(NullableBigIntVector vector, int valueCount) {\n+    final long even = 1000000000;\n+    final long odd = 2000000000;\n+    for (int i = 0; i < valueCount; i++) {\n+      if (i % 2 == 0) {\n+        vector.setSafe(i, even);\n+      } else {\n+        vector.setSafe(i, odd);\n+      }\n+    }\n+    vector.setValueCount(valueCount);\n+  }\n+\n+  private static void writeFloatData(NullableFloat4Vector vector, int valueCount) {\n+    final float even = 20.3f;\n+    final float odd = 40.2f;\n+    for (int i = 0; i < valueCount; i++) {\n+      if (i % 2 == 0) {\n+        vector.setSafe(i, even);\n+      } else {\n+        vector.setSafe(i, odd);\n+      }\n+    }\n+    vector.setValueCount(valueCount);\n+  }\n+\n+  private static void writeDoubleData(NullableFloat8Vector vector, int valueCount) {\n+    final double even = 20.2373;\n+    final double odd = 40.2378;\n+    for (int i = 0; i < valueCount; i++) {\n+      if (i % 2 == 0) {\n+        vector.setSafe(i, even);\n+      } else {\n+        vector.setSafe(i, odd);\n+      }\n+    }\n+    vector.setValueCount(valueCount);\n+  }\n+\n+  private static void writeVarBinaryData(NullableVarBinaryVector vector, int valueCount) {\n+    Charset utf8Charset = Charset.forName(\"UTF-8\");\n+    final byte[] even = \"AAAAA1\".getBytes(utf8Charset);\n+    final byte[] odd = \"BBBBBBBBB2\".getBytes(utf8Charset);\n+    for (int i = 0; i < valueCount; i++) {\n+      if (i % 2 == 0) {\n+        vector.setSafe(i, even);\n+      } else {\n+        vector.setSafe(i, odd);\n+      }\n+    }\n+    vector.setValueCount(valueCount);\n+  }\n+\n+  private static void writeVarCharData(NullableVarCharVector vector, int valueCount) {\n+    Charset utf8Charset = Charset.forName(\"UTF-8\");\n+    final byte[] even = \"AAAAA1\".getBytes(utf8Charset);\n+    final byte[] odd = \"BBBBBBBBB2\".getBytes(utf8Charset);\n+    for (int i = 0; i < valueCount; i++) {\n+      if (i % 2 == 0) {\n+        vector.setSafe(i, even);\n+      } else {\n+        vector.setSafe(i, odd);\n+      }\n+    }\n+    vector.setValueCount(valueCount);\n+  }\n+}\n+\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableBigIntVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableBigIntVector.java\nnew file mode 100644\nindex 000000000..eca6592c5\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableBigIntVector.java\n@@ -0,0 +1,368 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.BigIntReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.BigIntHolder;\n+import org.apache.arrow.vector.holders.NullableBigIntHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableBigIntVector implements a fixed width vector (8 bytes) of\n+ * integer values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableBigIntVector extends BaseNullableFixedWidthVector {\n+  public static final byte TYPE_WIDTH = 8;\n+  private final FieldReader reader;\n+\n+  /**\n+   * Instantiate a NullableBigIntVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableBigIntVector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(Types.MinorType.BIGINT.getType()),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableBigIntVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableBigIntVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, TYPE_WIDTH);\n+    reader = new BigIntReaderImpl(NullableBigIntVector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.BIGINT;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+  /**\n+   * Get the element at the given index from the vector.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public long get(int index) throws IllegalStateException {\n+    if (isSet(index) == 0) {\n+      throw new IllegalStateException(\"Value at index is null\");\n+    }\n+    return valueBuffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableBigIntHolder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public Long getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return valueBuffer.getLong(index * TYPE_WIDTH);\n+    }\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFrom(int fromIndex, int thisIndex, NullableBigIntVector from) {\n+    if (from.isSet(fromIndex) != 0) {\n+      set(thisIndex, from.get(fromIndex));\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, NullableBigIntVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFromSafe(int fromIndex, int thisIndex, NullableBigIntVector from) {\n+    handleSafe(thisIndex);\n+    copyFrom(fromIndex, thisIndex, from);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  private void setValue(int index, long value) {\n+    valueBuffer.setLong(index * TYPE_WIDTH, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void set(int index, long value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableBigIntHolder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, BigIntHolder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, long)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void setSafe(int index, long value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableBigIntHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableBigIntHolder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, BigIntHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, BigIntHolder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Set the element at the given index to null.\n+   *\n+   * @param index   position of element\n+   */\n+  public void setNull(int index) {\n+    handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n+\n+  /**\n+   * Store the given value at a particular position in the vector. isSet indicates\n+   * whether the value is NULL or not.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void set(int index, int isSet, long value) {\n+    if (isSet > 0) {\n+      set(index, value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int, long)} except that it handles the case\n+   * when index is greater than or equal to current value capacity of the\n+   * vector.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void setSafe(int index, int isSet, long value) {\n+    handleSafe(index);\n+    set(index, isSet, value);\n+  }\n+\n+  /**\n+   * Given a data buffer, get the value stored at a particular position\n+   * in the vector.\n+   *\n+   * This method should not be used externally.\n+   *\n+   * @param buffer data buffer\n+   * @param index position of the element.\n+   * @return value stored at the index.\n+   */\n+  public static long get(final ArrowBuf buffer, final int index) {\n+    return buffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new TransferImpl(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableBigIntVector) to);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    NullableBigIntVector to;\n+\n+    public TransferImpl(String ref, BufferAllocator allocator) {\n+      to = new NullableBigIntVector(ref, field.getFieldType(), allocator);\n+    }\n+\n+    public TransferImpl(NullableBigIntVector to) {\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public NullableBigIntVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      transferTo(to);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      splitAndTransferTo(startIndex, length, to);\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      to.copyFromSafe(fromIndex, toIndex, NullableBigIntVector.this);\n+    }\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableBitVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableBitVector.java\nnew file mode 100644\nindex 000000000..bd363f5b7\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableBitVector.java\n@@ -0,0 +1,516 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.BitReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.BitHolder;\n+import org.apache.arrow.vector.holders.NullableBitHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * NullableBitVector implements a fixed width (1 bit) vector of\n+ * boolean values which could be null. Each value in the vector corresponds\n+ * to a single bit in the underlying data stream backing the vector.\n+ */\n+public class NullableBitVector extends BaseNullableFixedWidthVector {\n+  private final FieldReader reader;\n+\n+  /**\n+   * Instantiate a NullableBitVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   *\n+   * @param name      name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableBitVector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(Types.MinorType.BIT.getType()),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableBitVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   *\n+   * @param name      name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableBitVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, (byte) 0);\n+    reader = new BitReaderImpl(NullableBitVector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   *\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   *\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.BIT;\n+  }\n+\n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   *\n+   * @param valueCount desired number of elements in the vector\n+   */\n+  @Override\n+  public void setInitialCapacity(int valueCount) {\n+    final int size = getValidityBufferSizeFromCount(valueCount);\n+    if (size > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+    valueAllocationSizeInBytes = size;\n+    validityAllocationSizeInBytes = size;\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector\n+   *\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    return (int) (validityBuffer.capacity() * 8L);\n+  }\n+\n+  /**\n+   * Get the potential buffer size for a particular number of records.\n+   *\n+   * @param count desired number of elements in the vector\n+   * @return estimated size of underlying buffers if the vector holds\n+   * a given number of elements\n+   */\n+  @Override\n+  public int getBufferSizeFor(final int count) {\n+    if (count == 0) {\n+      return 0;\n+    }\n+    return 2 * getValidityBufferSizeFromCount(count);\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector\n+   *\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    return getBufferSizeFor(valueCount);\n+  }\n+\n+  /**\n+   * Slice this vector at desired index and length and transfer the\n+   * corresponding data to the target vector.\n+   *\n+   * @param startIndex start position of the split in source vector.\n+   * @param length     length of the split.\n+   * @param target     destination vector\n+   */\n+  public void splitAndTransferTo(int startIndex, int length,\n+                                 BaseNullableFixedWidthVector target) {\n+    compareTypes(target, \"splitAndTransferTo\");\n+    target.clear();\n+    target.validityBuffer = splitAndTransferBuffer(startIndex, length, target,\n+            validityBuffer, target.validityBuffer);\n+    target.valueBuffer = splitAndTransferBuffer(startIndex, length, target,\n+            valueBuffer, target.valueBuffer);\n+\n+    target.setValueCount(length);\n+  }\n+\n+  private ArrowBuf splitAndTransferBuffer(int startIndex, int length,\n+                                          BaseNullableFixedWidthVector target,\n+                                          ArrowBuf sourceBuffer, ArrowBuf destBuffer) {\n+    assert startIndex + length <= valueCount;\n+    int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+    int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+    int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+    int offset = startIndex % 8;\n+\n+    if (length > 0) {\n+      if (offset == 0) {\n+            /* slice */\n+        if (destBuffer != null) {\n+          destBuffer.release();\n+        }\n+        destBuffer = sourceBuffer.slice(firstByteSource, byteSizeTarget);\n+        destBuffer.retain(1);\n+      } else {\n+            /* Copy data\n+             * When the first bit starts from the middle of a byte (offset != 0),\n+             * copy data from src BitVector.\n+             * Each byte in the target is composed by a part in i-th byte,\n+             * another part in (i+1)-th byte.\n+             */\n+        destBuffer = allocator.buffer(byteSizeTarget);\n+        destBuffer.readerIndex(0);\n+        destBuffer.setZero(0, destBuffer.capacity());\n+\n+        for (int i = 0; i < byteSizeTarget - 1; i++) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(sourceBuffer, firstByteSource + i, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(sourceBuffer, firstByteSource + i + 1, offset);\n+\n+          destBuffer.setByte(i, (b1 + b2));\n+        }\n+\n+            /* Copying the last piece is done in the following manner:\n+             * if the source vector has 1 or more bytes remaining, we copy\n+             * the last piece as a byte formed by shifting data\n+             * from the current byte and the next byte.\n+             *\n+             * if the source vector has no more bytes remaining\n+             * (we are at the last byte), we copy the last piece as a byte\n+             * by shifting data from the current byte.\n+             */\n+        if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(sourceBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(sourceBuffer,\n+                  firstByteSource + byteSizeTarget, offset);\n+\n+          destBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+        } else {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(sourceBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          destBuffer.setByte(byteSizeTarget - 1, b1);\n+        }\n+      }\n+    }\n+\n+    return destBuffer;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+  private int getBit(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = valueBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return Long.bitCount(b & (1L << bitIndex));\n+  }\n+\n+  /**\n+   * Get the element at the given index from the vector.\n+   *\n+   * @param index position of element\n+   * @return element at given index\n+   */\n+  public int get(int index) throws IllegalStateException {\n+    if (isSet(index) == 0) {\n+      throw new IllegalStateException(\"Value at index is null\");\n+    }\n+    return getBit(index);\n+  }\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index position of element\n+   */\n+  public void get(int index, NullableBitHolder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = getBit(index);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index position of element\n+   * @return element at given index\n+   */\n+  public Boolean getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return new Boolean(getBit(index) != 0);\n+    }\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector\n+   *\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from      source vector\n+   */\n+  public void copyFrom(int fromIndex, int thisIndex, NullableBitVector from) {\n+    if (from.isSet(fromIndex) != 0) {\n+      set(thisIndex, from.get(fromIndex));\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, NullableBitVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   *\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from      source vector\n+   */\n+  public void copyFromSafe(int fromIndex, int thisIndex, NullableBitVector from) {\n+    handleSafe(thisIndex);\n+    copyFrom(fromIndex, thisIndex, from);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index position of element\n+   * @param value value of element\n+   */\n+  public void set(int index, int value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    if (value != 0) {\n+      BitVectorHelper.setValidityBitToOne(valueBuffer, index);\n+    } else {\n+      BitVectorHelper.setValidityBit(valueBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index  position of element\n+   * @param holder nullable data holder for value of element\n+   */\n+  public void set(int index, NullableBitHolder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      if (holder.value != 0) {\n+        BitVectorHelper.setValidityBitToOne(valueBuffer, index);\n+      } else {\n+        BitVectorHelper.setValidityBit(valueBuffer, index, 0);\n+      }\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index  position of element\n+   * @param holder data holder for value of element\n+   */\n+  public void set(int index, BitHolder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    if (holder.value != 0) {\n+      BitVectorHelper.setValidityBitToOne(valueBuffer, index);\n+    } else {\n+      BitVectorHelper.setValidityBit(valueBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index position of element\n+   * @param value value of element\n+   */\n+  public void setSafe(int index, int value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableBitHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index  position of element\n+   * @param holder nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableBitHolder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, BitHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index  position of element\n+   * @param holder data holder for value of element\n+   */\n+  public void setSafe(int index, BitHolder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Set the element at the given index to null.\n+   *\n+   * @param index position of element\n+   */\n+  public void setNull(int index) {\n+    handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n+\n+  /**\n+   * Store the given value at a particular position in the vector. isSet indicates\n+   * whether the value is NULL or not.\n+   *\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void set(int index, int isSet, int value) {\n+    if (isSet > 0) {\n+      set(index, value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int, int)} except that it handles the case\n+   * when index is greater than or equal to current value capacity of the\n+   * vector.\n+   *\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void setSafe(int index, int isSet, int value) {\n+    handleSafe(index);\n+    set(index, isSet, value);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   *\n+   * @param ref       name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new TransferImpl(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   *\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableBitVector) to);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    NullableBitVector to;\n+\n+    public TransferImpl(String ref, BufferAllocator allocator) {\n+      to = new NullableBitVector(ref, field.getFieldType(), allocator);\n+    }\n+\n+    public TransferImpl(NullableBitVector to) {\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public NullableBitVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      transferTo(to);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      splitAndTransferTo(startIndex, length, to);\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      to.copyFromSafe(fromIndex, toIndex, NullableBitVector.this);\n+    }\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableDateDayVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableDateDayVector.java\nnew file mode 100644\nindex 000000000..c5ddc9e87\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableDateDayVector.java\n@@ -0,0 +1,370 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.DateDayReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.DateDayHolder;\n+import org.apache.arrow.vector.holders.NullableDateDayHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.slf4j.Logger;\n+\n+/**\n+ * NullableDateDayVector implements a fixed width (4 bytes) vector of\n+ * date values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableDateDayVector extends BaseNullableFixedWidthVector {\n+  private static final byte TYPE_WIDTH = 4;\n+  private final FieldReader reader;\n+\n+  /**\n+   * Instantiate a NullableDateDayVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableDateDayVector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(Types.MinorType.DATEDAY.getType()),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableDateDayVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableDateDayVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, TYPE_WIDTH);\n+    reader = new DateDayReaderImpl(NullableDateDayVector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.DATEDAY;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public int get(int index) throws IllegalStateException {\n+    if (isSet(index) == 0) {\n+      throw new IllegalStateException(\"Value at index is null\");\n+    }\n+    return valueBuffer.getInt(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableDateDayHolder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getInt(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public Integer getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return valueBuffer.getInt(index * TYPE_WIDTH);\n+    }\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFrom(int fromIndex, int thisIndex, NullableDateDayVector from) {\n+    if (from.isSet(fromIndex) != 0) {\n+      set(thisIndex, from.get(fromIndex));\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, NullableDateDayVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFromSafe(int fromIndex, int thisIndex, NullableDateDayVector from) {\n+    handleSafe(thisIndex);\n+    copyFrom(fromIndex, thisIndex, from);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  private void setValue(int index, int value) {\n+    valueBuffer.setInt(index * TYPE_WIDTH, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void set(int index, int value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableDateDayHolder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, DateDayHolder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void setSafe(int index, int value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableDateDayHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableDateDayHolder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, DateDayHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, DateDayHolder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Set the element at the given index to null.\n+   *\n+   * @param index   position of element\n+   */\n+  public void setNull(int index) {\n+    handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n+\n+  /**\n+   * Store the given value at a particular position in the vector. isSet indicates\n+   * whether the value is NULL or not.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void set(int index, int isSet, int value) {\n+    if (isSet > 0) {\n+      set(index, value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int, int)} except that it handles the case\n+   * when index is greater than or equal to current value capacity of the\n+   * vector.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void setSafe(int index, int isSet, int value) {\n+    handleSafe(index);\n+    set(index, isSet, value);\n+  }\n+\n+  /**\n+   * Given a data buffer, get the value stored at a particular position\n+   * in the vector.\n+   *\n+   * This method should not be used externally.\n+   *\n+   * @param buffer data buffer\n+   * @param index position of the element.\n+   * @return value stored at the index.\n+   */\n+  public static int get(final ArrowBuf buffer, final int index) {\n+    return buffer.getInt(index * TYPE_WIDTH);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new TransferImpl(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableDateDayVector) to);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    NullableDateDayVector to;\n+\n+    public TransferImpl(String ref, BufferAllocator allocator) {\n+      to = new NullableDateDayVector(ref, field.getFieldType(), allocator);\n+    }\n+\n+    public TransferImpl(NullableDateDayVector to) {\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public NullableDateDayVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      transferTo(to);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      splitAndTransferTo(startIndex, length, to);\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      to.copyFromSafe(fromIndex, toIndex, NullableDateDayVector.this);\n+    }\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableDateMilliVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableDateMilliVector.java\nnew file mode 100644\nindex 000000000..7e37055da\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableDateMilliVector.java\n@@ -0,0 +1,375 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.DateMilliReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.DateMilliHolder;\n+import org.apache.arrow.vector.holders.NullableDateMilliHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.joda.time.LocalDateTime;\n+import org.joda.time.LocalDateTimes;\n+import org.slf4j.Logger;\n+\n+/**\n+ * NullableDateMilliVector implements a fixed width vector (8 bytes) of\n+ * date values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableDateMilliVector extends BaseNullableFixedWidthVector {\n+  private static final byte TYPE_WIDTH = 8;\n+  private final FieldReader reader;\n+\n+  /**\n+   * Instantiate a NullableDateMilliVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableDateMilliVector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(Types.MinorType.DATEMILLI.getType()),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableDateMilliVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableDateMilliVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, TYPE_WIDTH);\n+    reader = new DateMilliReaderImpl(NullableDateMilliVector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.DATEMILLI;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public long get(int index) throws IllegalStateException {\n+    if (isSet(index) == 0) {\n+      throw new IllegalStateException(\"Value at index is null\");\n+    }\n+    return valueBuffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableDateMilliHolder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public LocalDateTime getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      final long millis = valueBuffer.getLong(index * TYPE_WIDTH);\n+      final LocalDateTime localDateTime = new org.joda.time.LocalDateTime(millis,\n+              org.joda.time.DateTimeZone.UTC);\n+      return localDateTime;\n+    }\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFrom(int fromIndex, int thisIndex, NullableDateMilliVector from) {\n+    if (from.isSet(fromIndex) != 0) {\n+      set(thisIndex, from.get(fromIndex));\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, NullableDateMilliVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFromSafe(int fromIndex, int thisIndex, NullableDateMilliVector from) {\n+    handleSafe(thisIndex);\n+    copyFrom(fromIndex, thisIndex, from);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  private void setValue(int index, long value) {\n+    valueBuffer.setLong(index * TYPE_WIDTH, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void set(int index, long value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableDateMilliHolder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, DateMilliHolder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, long)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void setSafe(int index, long value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableDateMilliHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableDateMilliHolder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, DateMilliHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, DateMilliHolder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Set the element at the given index to null.\n+   *\n+   * @param index   position of element\n+   */\n+  public void setNull(int index) {\n+    handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n+\n+  /**\n+   * Store the given value at a particular position in the vector. isSet indicates\n+   * whether the value is NULL or not.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void set(int index, int isSet, long value) {\n+    if (isSet > 0) {\n+      set(index, value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int, long)} except that it handles the case\n+   * when index is greater than or equal to current value capacity of the\n+   * vector.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void setSafe(int index, int isSet, long value) {\n+    handleSafe(index);\n+    set(index, isSet, value);\n+  }\n+\n+  /**\n+   * Given a data buffer, get the value stored at a particular position\n+   * in the vector.\n+   *\n+   * This method should not be used externally.\n+   *\n+   * @param buffer data buffer\n+   * @param index position of the element.\n+   * @return value stored at the index.\n+   */\n+  public static long get(final ArrowBuf buffer, final int index) {\n+    return buffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new TransferImpl(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableDateMilliVector) to);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    NullableDateMilliVector to;\n+\n+    public TransferImpl(String ref, BufferAllocator allocator) {\n+      to = new NullableDateMilliVector(ref, field.getFieldType(), allocator);\n+    }\n+\n+    public TransferImpl(NullableDateMilliVector to) {\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public NullableDateMilliVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      transferTo(to);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      splitAndTransferTo(startIndex, length, to);\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      to.copyFromSafe(fromIndex, toIndex, NullableDateMilliVector.this);\n+    }\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableDecimalVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableDecimalVector.java\nnew file mode 100644\nindex 000000000..dcc551094\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableDecimalVector.java\n@@ -0,0 +1,427 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.DecimalReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.DecimalHolder;\n+import org.apache.arrow.vector.holders.NullableDecimalHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.DecimalUtility;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * NullableDecimalVector implements a fixed width vector (16 bytes) of\n+ * decimal values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableDecimalVector extends BaseNullableFixedWidthVector {\n+  public static final byte TYPE_WIDTH = 16;\n+  private final FieldReader reader;\n+\n+  private final int precision;\n+  private final int scale;\n+\n+  /**\n+   * Instantiate a NullableDecimalVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableDecimalVector(String name, BufferAllocator allocator,\n+                               int precision, int scale) {\n+    this(name, FieldType.nullable(new org.apache.arrow.vector.types.pojo.ArrowType.Decimal(precision, scale)),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableDecimalVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableDecimalVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, TYPE_WIDTH);\n+    org.apache.arrow.vector.types.pojo.ArrowType.Decimal arrowType = (org.apache.arrow.vector.types.pojo.ArrowType.Decimal) fieldType.getType();\n+    reader = new DecimalReaderImpl(NullableDecimalVector.this);\n+    this.precision = arrowType.getPrecision();\n+    this.scale = arrowType.getScale();\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.DECIMAL;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public ArrowBuf get(int index) throws IllegalStateException {\n+    if (isSet(index) == 0) {\n+      throw new IllegalStateException(\"Value at index is null\");\n+    }\n+    return valueBuffer.slice(index * TYPE_WIDTH, TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableDecimalHolder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.buffer = valueBuffer;\n+    holder.precision = precision;\n+    holder.scale = scale;\n+    holder.start = index * TYPE_WIDTH;\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public BigDecimal getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return DecimalUtility.getBigDecimalFromArrowBuf(valueBuffer, index, scale);\n+    }\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFrom(int fromIndex, int thisIndex, NullableDecimalVector from) {\n+    if (from.isSet(fromIndex) != 0) {\n+      from.valueBuffer.getBytes(fromIndex * TYPE_WIDTH, valueBuffer,\n+              thisIndex * TYPE_WIDTH, TYPE_WIDTH);\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, thisIndex);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, NullableDecimalVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFromSafe(int fromIndex, int thisIndex, NullableDecimalVector from) {\n+    handleSafe(thisIndex);\n+    copyFrom(fromIndex, thisIndex, from);\n+  }\n+\n+  /**\n+   * Return scale for the decimal value\n+   */\n+  public int getScale() {\n+    return scale;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index    position of element\n+   * @param buffer   ArrowBuf containing decimal value.\n+   */\n+  public void set(int index, ArrowBuf buffer) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    valueBuffer.setBytes(index * TYPE_WIDTH, buffer, 0, TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index    position of element\n+   * @param start    start index of data in the buffer\n+   * @param buffer   ArrowBuf containing decimal value.\n+   */\n+  public void set(int index, int start, ArrowBuf buffer) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    valueBuffer.setBytes(index * TYPE_WIDTH, buffer, start, TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index   position of element\n+   * @param value   BigDecimal containing decimal value.\n+   */\n+  public void set(int index, BigDecimal value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    DecimalUtility.checkPrecisionAndScale(value, precision, scale);\n+    DecimalUtility.writeBigDecimalToArrowBuf(value, valueBuffer, index);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableDecimalHolder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      valueBuffer.setBytes(index * TYPE_WIDTH, holder.buffer, holder.start, TYPE_WIDTH);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, DecimalHolder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    valueBuffer.setBytes(index * TYPE_WIDTH, holder.buffer, holder.start, TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, ArrowBuf)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param buffer  ArrowBuf containing decimal value.\n+   */\n+  public void setSafe(int index, ArrowBuf buffer) {\n+    handleSafe(index);\n+    set(index, buffer);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int, ArrowBuf)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index    position of element\n+   * @param start    start index of data in the buffer\n+   * @param buffer   ArrowBuf containing decimal value.\n+   */\n+  public void setSafe(int index, int start, ArrowBuf buffer) {\n+    handleSafe(index);\n+    set(index, start, buffer);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, BigDecimal)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param value   BigDecimal containing decimal value.\n+   */\n+  public void setSafe(int index, BigDecimal value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableDecimalHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableDecimalHolder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, DecimalHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, DecimalHolder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Set the element at the given index to null.\n+   *\n+   * @param index   position of element\n+   */\n+  public void setNull(int index) {\n+    handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n+\n+  /**\n+   * Store the given value at a particular position in the vector. isSet indicates\n+   * whether the value is NULL or not.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param start start position of the value in the buffer\n+   * @param buffer buffer containing the value to be stored in the vector\n+   */\n+  public void set(int index, int isSet, int start, ArrowBuf buffer) {\n+    if (isSet > 0) {\n+      set(index, start, buffer);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #setSafe(int, int, int, ArrowBuf)} except that it handles\n+   * the case when the position of new value is beyond the current value\n+   * capacity of the vector.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param start start position of the value in the buffer\n+   * @param buffer buffer containing the value to be stored in the vector\n+   */\n+  public void setSafe(int index, int isSet, int start, ArrowBuf buffer) {\n+    handleSafe(index);\n+    set(index, isSet, start, buffer);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new TransferImpl(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableDecimalVector) to);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    NullableDecimalVector to;\n+\n+    public TransferImpl(String ref, BufferAllocator allocator) {\n+      to = new NullableDecimalVector(ref, allocator, NullableDecimalVector.this.precision,\n+              NullableDecimalVector.this.scale);\n+    }\n+\n+    public TransferImpl(NullableDecimalVector to) {\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public NullableDecimalVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      transferTo(to);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      splitAndTransferTo(startIndex, length, to);\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      to.copyFromSafe(fromIndex, toIndex, NullableDecimalVector.this);\n+    }\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableFloat4Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableFloat4Vector.java\nnew file mode 100644\nindex 000000000..834f16c21\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableFloat4Vector.java\n@@ -0,0 +1,369 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.Float4ReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.Float4Holder;\n+import org.apache.arrow.vector.holders.NullableFloat4Holder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableFloat4Vector implements a fixed width vector (4 bytes) of\n+ * float values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableFloat4Vector extends BaseNullableFixedWidthVector {\n+  public static final byte TYPE_WIDTH = 4;\n+  private final FieldReader reader;\n+\n+  /**\n+   * Instantiate a NullableFloat4Vector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableFloat4Vector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(Types.MinorType.FLOAT4.getType()),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableFloat4Vector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableFloat4Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, TYPE_WIDTH);\n+    reader = new Float4ReaderImpl(NullableFloat4Vector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.FLOAT4;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public float get(int index) throws IllegalStateException {\n+    if (isSet(index) == 0) {\n+      throw new IllegalStateException(\"Value at index is null\");\n+    }\n+    return valueBuffer.getFloat(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableFloat4Holder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getFloat(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public Float getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return valueBuffer.getFloat(index * TYPE_WIDTH);\n+    }\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFrom(int fromIndex, int thisIndex, NullableFloat4Vector from) {\n+    if (from.isSet(fromIndex) != 0) {\n+      set(thisIndex, from.get(fromIndex));\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, NullableFloat4Vector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFromSafe(int fromIndex, int thisIndex, NullableFloat4Vector from) {\n+    handleSafe(thisIndex);\n+    copyFrom(fromIndex, thisIndex, from);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  private void setValue(int index, float value) {\n+    valueBuffer.setFloat(index * TYPE_WIDTH, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void set(int index, float value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableFloat4Holder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, Float4Holder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, float)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void setSafe(int index, float value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableFloat4Holder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableFloat4Holder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, Float4Holder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, Float4Holder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Set the element at the given index to null.\n+   *\n+   * @param index   position of element\n+   */\n+  public void setNull(int index) {\n+    handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n+\n+  /**\n+   * Store the given value at a particular position in the vector. isSet indicates\n+   * whether the value is NULL or not.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void set(int index, int isSet, float value) {\n+    if (isSet > 0) {\n+      set(index, value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int, float)} except that it handles the case\n+   * when index is greater than or equal to current value capacity of the\n+   * vector.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void setSafe(int index, int isSet, float value) {\n+    handleSafe(index);\n+    set(index, isSet, value);\n+  }\n+\n+  /**\n+   * Given a data buffer, get the value stored at a particular position\n+   * in the vector.\n+   *\n+   * This method should not be used externally.\n+   *\n+   * @param buffer data buffer\n+   * @param index position of the element.\n+   * @return value stored at the index.\n+   */\n+  public static float get(final ArrowBuf buffer, final int index) {\n+    return buffer.getFloat(index * TYPE_WIDTH);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new TransferImpl(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableFloat4Vector) to);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    NullableFloat4Vector to;\n+\n+    public TransferImpl(String ref, BufferAllocator allocator) {\n+      to = new NullableFloat4Vector(ref, field.getFieldType(), allocator);\n+    }\n+\n+    public TransferImpl(NullableFloat4Vector to) {\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public NullableFloat4Vector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      transferTo(to);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      splitAndTransferTo(startIndex, length, to);\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      to.copyFromSafe(fromIndex, toIndex, NullableFloat4Vector.this);\n+    }\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableFloat8Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableFloat8Vector.java\nnew file mode 100644\nindex 000000000..b054d9b05\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableFloat8Vector.java\n@@ -0,0 +1,369 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.Float8ReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.Float8Holder;\n+import org.apache.arrow.vector.holders.NullableFloat8Holder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableFloat8Vector implements a fixed width vector (8 bytes) of\n+ * double values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableFloat8Vector extends BaseNullableFixedWidthVector {\n+  public static final byte TYPE_WIDTH = 8;\n+  private final FieldReader reader;\n+\n+  /**\n+   * Instantiate a NullableFloat8Vector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableFloat8Vector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(Types.MinorType.FLOAT8.getType()),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableFloat8Vector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableFloat8Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, TYPE_WIDTH);\n+    reader = new Float8ReaderImpl(NullableFloat8Vector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.FLOAT8;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public double get(int index) throws IllegalStateException {\n+    if (isSet(index) == 0) {\n+      throw new IllegalStateException(\"Value at index is null\");\n+    }\n+    return valueBuffer.getDouble(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableFloat8Holder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getDouble(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public Double getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return valueBuffer.getDouble(index * TYPE_WIDTH);\n+    }\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFrom(int fromIndex, int thisIndex, NullableFloat8Vector from) {\n+    if (from.isSet(fromIndex) != 0) {\n+      set(thisIndex, from.get(fromIndex));\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, NullableFloat8Vector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFromSafe(int fromIndex, int thisIndex, NullableFloat8Vector from) {\n+    handleSafe(thisIndex);\n+    copyFrom(fromIndex, thisIndex, from);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  private void setValue(int index, double value) {\n+    valueBuffer.setDouble(index * TYPE_WIDTH, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void set(int index, double value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableFloat8Holder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, Float8Holder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, double)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void setSafe(int index, double value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableFloat8Holder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableFloat8Holder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, Float8Holder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, Float8Holder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Set the element at the given index to null.\n+   *\n+   * @param index   position of element\n+   */\n+  public void setNull(int index) {\n+    handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n+\n+  /**\n+   * Store the given value at a particular position in the vector. isSet indicates\n+   * whether the value is NULL or not.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void set(int index, int isSet, double value) {\n+    if (isSet > 0) {\n+      set(index, value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int, double)} except that it handles the case\n+   * when index is greater than or equal to current value capacity of the\n+   * vector.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void setSafe(int index, int isSet, double value) {\n+    handleSafe(index);\n+    set(index, isSet, value);\n+  }\n+\n+  /**\n+   * Given a data buffer, get the value stored at a particular position\n+   * in the vector.\n+   *\n+   * This method should not be used externally.\n+   *\n+   * @param buffer data buffer\n+   * @param index position of the element.\n+   * @return value stored at the index.\n+   */\n+  public static double get(final ArrowBuf buffer, final int index) {\n+    return buffer.getDouble(index * TYPE_WIDTH);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new TransferImpl(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableFloat8Vector) to);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    NullableFloat8Vector to;\n+\n+    public TransferImpl(String ref, BufferAllocator allocator) {\n+      to = new NullableFloat8Vector(ref, field.getFieldType(), allocator);\n+    }\n+\n+    public TransferImpl(NullableFloat8Vector to) {\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public NullableFloat8Vector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      transferTo(to);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      splitAndTransferTo(startIndex, length, to);\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      to.copyFromSafe(fromIndex, toIndex, NullableFloat8Vector.this);\n+    }\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableIntVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableIntVector.java\nnew file mode 100644\nindex 000000000..e5dfbcedc\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableIntVector.java\n@@ -0,0 +1,379 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.IntReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.IntHolder;\n+import org.apache.arrow.vector.holders.NullableIntHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableIntVector implements a fixed width (4 bytes) vector of\n+ * integer values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableIntVector extends BaseNullableFixedWidthVector {\n+  public static final byte TYPE_WIDTH = 4;\n+  private final FieldReader reader;\n+\n+  /**\n+   * Instantiate a NullableIntVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   *\n+   * @param name      name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableIntVector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(org.apache.arrow.vector.types.Types.MinorType.INT.getType()),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableIntVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   *\n+   * @param name      name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableIntVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, TYPE_WIDTH);\n+    reader = new IntReaderImpl(NullableIntVector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   *\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   *\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.INT;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector.\n+   *\n+   * @param index position of element\n+   * @return element at given index\n+   */\n+  public int get(int index) throws IllegalStateException {\n+    if (isSet(index) == 0) {\n+      throw new IllegalStateException(\"Value at index is null\");\n+    }\n+    return valueBuffer.getInt(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index position of element\n+   */\n+  public void get(int index, NullableIntHolder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getInt(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index position of element\n+   * @return element at given index\n+   */\n+  public Integer getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return valueBuffer.getInt(index * TYPE_WIDTH);\n+    }\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector\n+   *\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from      source vector\n+   */\n+  public void copyFrom(int fromIndex, int thisIndex, NullableIntVector from) {\n+    if (from.isSet(fromIndex) != 0) {\n+      set(thisIndex, from.get(fromIndex));\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, NullableIntVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   *\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from      source vector\n+   */\n+  public void copyFromSafe(int fromIndex, int thisIndex, NullableIntVector from) {\n+    handleSafe(thisIndex);\n+    copyFrom(fromIndex, thisIndex, from);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  private void setValue(int index, int value) {\n+    valueBuffer.setInt(index * TYPE_WIDTH, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index position of element\n+   * @param value value of element\n+   */\n+  public void set(int index, int value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index  position of element\n+   * @param holder nullable data holder for value of element\n+   */\n+  public void set(int index, NullableIntHolder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index  position of element\n+   * @param holder data holder for value of element\n+   */\n+  public void set(int index, IntHolder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index position of element\n+   * @param value value of element\n+   */\n+  public void setSafe(int index, int value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableIntHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index  position of element\n+   * @param holder nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableIntHolder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, IntHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index  position of element\n+   * @param holder data holder for value of element\n+   */\n+  public void setSafe(int index, IntHolder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Set the element at the given index to null.\n+   *\n+   * @param index position of element\n+   */\n+  public void setNull(int index) {\n+    handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n+\n+  /**\n+   * Store the given value at a particular position in the vector. isSet indicates\n+   * whether the value is NULL or not.\n+   *\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void set(int index, int isSet, int value) {\n+    if (isSet > 0) {\n+      set(index, value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int, int)} except that it handles the case\n+   * when index is greater than or equal to current value capacity of the\n+   * vector.\n+   *\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void setSafe(int index, int isSet, int value) {\n+    handleSafe(index);\n+    set(index, isSet, value);\n+  }\n+\n+  /**\n+   * Given a data buffer, get the value stored at a particular position\n+   * in the vector.\n+   * <p>\n+   * This method should not be used externally.\n+   *\n+   * @param buffer data buffer\n+   * @param index  position of the element.\n+   * @return value stored at the index.\n+   */\n+  public static int get(final ArrowBuf buffer, final int index) {\n+    return buffer.getInt(index * TYPE_WIDTH);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   *\n+   * @param ref       name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new TransferImpl(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   *\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableIntVector) to);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    NullableIntVector to;\n+\n+    public TransferImpl(String ref, BufferAllocator allocator) {\n+      to = new NullableIntVector(ref, field.getFieldType(), allocator);\n+    }\n+\n+    public TransferImpl(NullableIntVector to) {\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public NullableIntVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      transferTo(to);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      splitAndTransferTo(startIndex, length, to);\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      to.copyFromSafe(fromIndex, toIndex, NullableIntVector.this);\n+    }\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableIntervalDayVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableIntervalDayVector.java\nnew file mode 100644\nindex 000000000..8d2fb5661\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableIntervalDayVector.java\n@@ -0,0 +1,429 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.IntervalDayReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.IntervalDayHolder;\n+import org.apache.arrow.vector.holders.NullableIntervalDayHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.joda.time.Period;\n+\n+/**\n+ * NullableIntervalDayVector implements a fixed width vector (8 bytes) of\n+ * interval (days and milliseconds) values which could be null.\n+ * A validity buffer (bit vector) is maintained to track which elements in the\n+ * vector are null.\n+ */\n+public class NullableIntervalDayVector extends BaseNullableFixedWidthVector {\n+  private static final byte TYPE_WIDTH = 8;\n+  private static final byte MILLISECOND_OFFSET = 4;\n+  private final FieldReader reader;\n+\n+  /**\n+   * Instantiate a NullableIntervalDayVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableIntervalDayVector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(Types.MinorType.INTERVALDAY.getType()),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableIntervalDayVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableIntervalDayVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, TYPE_WIDTH);\n+    reader = new IntervalDayReaderImpl(NullableIntervalDayVector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.INTERVALDAY;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public ArrowBuf get(int index) throws IllegalStateException {\n+    if (isSet(index) == 0) {\n+      return null;\n+    }\n+    return valueBuffer.slice(index * TYPE_WIDTH, TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableIntervalDayHolder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    final int startIndex = index * TYPE_WIDTH;\n+    holder.isSet = 1;\n+    holder.days = valueBuffer.getInt(startIndex);\n+    holder.milliseconds = valueBuffer.getInt(startIndex + MILLISECOND_OFFSET);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public Period getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      final int startIndex = index * TYPE_WIDTH;\n+      final int days = valueBuffer.getInt(startIndex);\n+      final int milliseconds = valueBuffer.getInt(startIndex + MILLISECOND_OFFSET);\n+      final Period p = new Period();\n+      return p.plusDays(days).plusMillis(milliseconds);\n+    }\n+  }\n+\n+  /**\n+   * Get the Interval value at a given index as a {@link StringBuilder} object\n+   * @param index position of the element\n+   * @return String Builder object with Interval value as\n+   *         [days, hours, minutes, seconds, millis]\n+   */\n+  public StringBuilder getAsStringBuilder(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return getAsStringBuilderHelper(index);\n+    }\n+  }\n+\n+  private StringBuilder getAsStringBuilderHelper(int index) {\n+    final int startIndex = index * TYPE_WIDTH;\n+\n+    final int days = valueBuffer.getInt(startIndex);\n+    int millis = valueBuffer.getInt(startIndex + MILLISECOND_OFFSET);\n+\n+    final int hours = millis / (org.apache.arrow.vector.util.DateUtility.hoursToMillis);\n+    millis = millis % (org.apache.arrow.vector.util.DateUtility.hoursToMillis);\n+\n+    final int minutes = millis / (org.apache.arrow.vector.util.DateUtility.minutesToMillis);\n+    millis = millis % (org.apache.arrow.vector.util.DateUtility.minutesToMillis);\n+\n+    final int seconds = millis / (org.apache.arrow.vector.util.DateUtility.secondsToMillis);\n+    millis = millis % (org.apache.arrow.vector.util.DateUtility.secondsToMillis);\n+\n+    final String dayString = (Math.abs(days) == 1) ? \" day \" : \" days \";\n+\n+    return (new StringBuilder().\n+            append(days).append(dayString).\n+            append(hours).append(\":\").\n+            append(minutes).append(\":\").\n+            append(seconds).append(\".\").\n+            append(millis));\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFrom(int fromIndex, int thisIndex, NullableIntervalDayVector from) {\n+    if (from.isSet(fromIndex) != 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, thisIndex);\n+      from.valueBuffer.getBytes(fromIndex * TYPE_WIDTH, this.valueBuffer,\n+              thisIndex * TYPE_WIDTH, TYPE_WIDTH);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, NullableIntervalDayVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFromSafe(int fromIndex, int thisIndex, NullableIntervalDayVector from) {\n+    handleSafe(thisIndex);\n+    copyFrom(fromIndex, thisIndex, from);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void set(int index, ArrowBuf value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    valueBuffer.setBytes(index * TYPE_WIDTH, value, 0, TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index          position of element\n+   * @param days           days for the interval\n+   * @param milliseconds   milliseconds for the interval\n+   */\n+  public void set(int index, int days, int milliseconds) {\n+    final int offsetIndex = index * TYPE_WIDTH;\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    valueBuffer.setInt(offsetIndex, days);\n+    valueBuffer.setInt((offsetIndex + MILLISECOND_OFFSET), milliseconds);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableIntervalDayHolder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      set(index, holder.days, holder.milliseconds);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, IntervalDayHolder holder) {\n+    set(index, holder.days, holder.milliseconds);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, ArrowBuf)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void setSafe(int index, ArrowBuf value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int, int)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index          position of element\n+   * @param days           days for the interval\n+   * @param milliseconds   milliseconds for the interval\n+   */\n+  public void setSafe(int index, int days, int milliseconds) {\n+    handleSafe(index);\n+    set(index, days, milliseconds);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableIntervalDayHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableIntervalDayHolder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, IntervalDayHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, IntervalDayHolder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Set the element at the given index to null.\n+   *\n+   * @param index   position of element\n+   */\n+  public void setNull(int index) {\n+    handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n+\n+  /**\n+   * Store the given value at a particular position in the vector. isSet indicates\n+   * whether the value is NULL or not.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param days days component of interval\n+   * @param milliseconds millisecond component of interval\n+   */\n+  public void set(int index, int isSet, int days, int milliseconds) {\n+    if (isSet > 0) {\n+      set(index, days, milliseconds);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int, int, int)} except that it handles the case\n+   * when index is greater than or equal to current value capacity of the\n+   * vector.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param days days component of interval\n+   * @param milliseconds millisecond component of interval\n+   */\n+  public void setSafe(int index, int isSet, int days, int milliseconds) {\n+    handleSafe(index);\n+    set(index, isSet, days, milliseconds);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new TransferImpl(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableIntervalDayVector) to);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    NullableIntervalDayVector to;\n+\n+    public TransferImpl(String ref, BufferAllocator allocator) {\n+      to = new NullableIntervalDayVector(ref, field.getFieldType(), allocator);\n+    }\n+\n+    public TransferImpl(NullableIntervalDayVector to) {\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public NullableIntervalDayVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      transferTo(to);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      splitAndTransferTo(startIndex, length, to);\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      to.copyFromSafe(fromIndex, toIndex, NullableIntervalDayVector.this);\n+    }\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableIntervalYearVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableIntervalYearVector.java\nnew file mode 100644\nindex 000000000..ac121d2f0\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableIntervalYearVector.java\n@@ -0,0 +1,387 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.IntervalYearReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.IntervalYearHolder;\n+import org.apache.arrow.vector.holders.NullableIntervalYearHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.joda.time.Period;\n+\n+/**\n+ * NullableIntervalYearVector implements a fixed width (4 bytes) vector of\n+ * interval (years and months) values which could be null. A validity buffer\n+ * (bit vector) is maintained to track which elements in the vector are null.\n+ */\n+public class NullableIntervalYearVector extends BaseNullableFixedWidthVector {\n+  private static final byte TYPE_WIDTH = 4;\n+  private final FieldReader reader;\n+\n+  /**\n+   * Instantiate a NullableIntervalYearVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableIntervalYearVector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(Types.MinorType.INTERVALYEAR.getType()),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableIntervalYearVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableIntervalYearVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, TYPE_WIDTH);\n+    reader = new IntervalYearReaderImpl(NullableIntervalYearVector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.INTERVALYEAR;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public int get(int index) throws IllegalStateException {\n+    if (isSet(index) == 0) {\n+      throw new IllegalStateException(\"Value at index is null\");\n+    }\n+    return valueBuffer.getInt(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableIntervalYearHolder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getInt(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public Period getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      final int interval = valueBuffer.getInt(index * TYPE_WIDTH);\n+      final int years = (interval / org.apache.arrow.vector.util.DateUtility.yearsToMonths);\n+      final int months = (interval % org.apache.arrow.vector.util.DateUtility.yearsToMonths);\n+      final Period p = new Period();\n+      return p.plusYears(years).plusMonths(months);\n+    }\n+  }\n+\n+  /**\n+   * Get the Interval value at a given index as a {@link StringBuilder} object\n+   * @param index position of the element\n+   * @return String Builder object with Interval value as\n+   *         [years, months]\n+   */\n+  public StringBuilder getAsStringBuilder(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return getAsStringBuilderHelper(index);\n+    }\n+  }\n+\n+  private StringBuilder getAsStringBuilderHelper(int index) {\n+    int value = valueBuffer.getInt(index * TYPE_WIDTH);\n+\n+    final int years = (value / org.apache.arrow.vector.util.DateUtility.yearsToMonths);\n+    final int months = (value % org.apache.arrow.vector.util.DateUtility.yearsToMonths);\n+\n+    final String yearString = (Math.abs(years) == 1) ? \" year \" : \" years \";\n+    final String monthString = (Math.abs(months) == 1) ? \" month \" : \" months \";\n+\n+    return (new StringBuilder().\n+            append(years).append(yearString).\n+            append(months).append(monthString));\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFrom(int fromIndex, int thisIndex, NullableIntervalYearVector from) {\n+    if (from.isSet(fromIndex) != 0) {\n+      set(thisIndex, from.get(fromIndex));\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, NullableIntervalYearVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFromSafe(int fromIndex, int thisIndex, NullableIntervalYearVector from) {\n+    handleSafe(thisIndex);\n+    copyFrom(fromIndex, thisIndex, from);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  private void setValue(int index, int value) {\n+    valueBuffer.setInt(index * TYPE_WIDTH, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void set(int index, int value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableIntervalYearHolder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, IntervalYearHolder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void setSafe(int index, int value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableIntervalYearHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableIntervalYearHolder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, IntervalYearHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, IntervalYearHolder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Set the element at the given index to null.\n+   *\n+   * @param index   position of element\n+   */\n+  public void setNull(int index) {\n+    handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n+\n+  /**\n+   * Store the given value at a particular position in the vector. isSet indicates\n+   * whether the value is NULL or not.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void set(int index, int isSet, int value) {\n+    if (isSet > 0) {\n+      set(index, value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int, int)} except that it handles the case\n+   * when index is greater than or equal to current value capacity of the\n+   * vector.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void setSafe(int index, int isSet, int value) {\n+    handleSafe(index);\n+    set(index, isSet, value);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new TransferImpl(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableIntervalYearVector) to);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    NullableIntervalYearVector to;\n+\n+    public TransferImpl(String ref, BufferAllocator allocator) {\n+      to = new NullableIntervalYearVector(ref, field.getFieldType(), allocator);\n+    }\n+\n+    public TransferImpl(NullableIntervalYearVector to) {\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public NullableIntervalYearVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      transferTo(to);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      splitAndTransferTo(startIndex, length, to);\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      to.copyFromSafe(fromIndex, toIndex, NullableIntervalYearVector.this);\n+    }\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableSmallIntVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableSmallIntVector.java\nnew file mode 100644\nindex 000000000..5dd1492a3\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableSmallIntVector.java\n@@ -0,0 +1,396 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.SmallIntReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.SmallIntHolder;\n+import org.apache.arrow.vector.holders.NullableSmallIntHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableSmallIntVector implements a fixed width (2 bytes) vector of\n+ * short values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableSmallIntVector extends BaseNullableFixedWidthVector {\n+  public static final byte TYPE_WIDTH = 2;\n+  private final FieldReader reader;\n+\n+  /**\n+   * Instantiate a NullableSmallIntVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableSmallIntVector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(Types.MinorType.SMALLINT.getType()),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableSmallIntVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableSmallIntVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, TYPE_WIDTH);\n+    reader = new SmallIntReaderImpl(NullableSmallIntVector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.SMALLINT;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public short get(int index) throws IllegalStateException {\n+    if (isSet(index) == 0) {\n+      throw new IllegalStateException(\"Value at index is null\");\n+    }\n+    return valueBuffer.getShort(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableSmallIntHolder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getShort(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public Short getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return valueBuffer.getShort(index * TYPE_WIDTH);\n+    }\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFrom(int fromIndex, int thisIndex, NullableSmallIntVector from) {\n+    if (from.isSet(fromIndex) != 0) {\n+      set(thisIndex, from.get(fromIndex));\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, NullableSmallIntVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFromSafe(int fromIndex, int thisIndex, NullableSmallIntVector from) {\n+    handleSafe(thisIndex);\n+    copyFrom(fromIndex, thisIndex, from);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  private void setValue(int index, int value) {\n+    valueBuffer.setShort(index * TYPE_WIDTH, value);\n+  }\n+\n+  private void setValue(int index, short value) {\n+    valueBuffer.setShort(index * TYPE_WIDTH, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void set(int index, int value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void set(int index, short value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableSmallIntHolder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, SmallIntHolder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void setSafe(int index, int value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, short)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void setSafe(int index, short value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableSmallIntHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableSmallIntHolder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, SmallIntHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, SmallIntHolder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Set the element at the given index to null.\n+   *\n+   * @param index   position of element\n+   */\n+  public void setNull(int index) {\n+    handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n+\n+  /**\n+   * Store the given value at a particular position in the vector. isSet indicates\n+   * whether the value is NULL or not.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void set(int index, int isSet, short value) {\n+    if (isSet > 0) {\n+      set(index, value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int, short)} except that it handles the case\n+   * when index is greater than or equal to current value capacity of the\n+   * vector.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void setSafe(int index, int isSet, short value) {\n+    handleSafe(index);\n+    set(index, isSet, value);\n+  }\n+\n+  /**\n+   * Given a data buffer, get the value stored at a particular position\n+   * in the vector.\n+   *\n+   * This method should not be used externally.\n+   *\n+   * @param buffer data buffer\n+   * @param index position of the element.\n+   * @return value stored at the index.\n+   */\n+  public static short get(final ArrowBuf buffer, final int index) {\n+    return buffer.getShort(index * TYPE_WIDTH);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new TransferImpl(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableSmallIntVector) to);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    NullableSmallIntVector to;\n+\n+    public TransferImpl(String ref, BufferAllocator allocator) {\n+      to = new NullableSmallIntVector(ref, field.getFieldType(), allocator);\n+    }\n+\n+    public TransferImpl(NullableSmallIntVector to) {\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public NullableSmallIntVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      transferTo(to);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      splitAndTransferTo(startIndex, length, to);\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      to.copyFromSafe(fromIndex, toIndex, NullableSmallIntVector.this);\n+    }\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeMicroVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeMicroVector.java\nnew file mode 100644\nindex 000000000..25da4f68d\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeMicroVector.java\n@@ -0,0 +1,370 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeMicroReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeMicroHolder;\n+import org.apache.arrow.vector.holders.NullableTimeMicroHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.slf4j.Logger;\n+\n+/**\n+ * NullableTimeMicroVector implements a fixed width vector (8 bytes) of\n+ * time (microsecond resolution) values which could be null.\n+ * A validity buffer (bit vector) is maintained to track which elements in the\n+ * vector are null.\n+ */\n+public class NullableTimeMicroVector extends BaseNullableFixedWidthVector {\n+  private static final byte TYPE_WIDTH = 8;\n+  private final FieldReader reader;\n+\n+  /**\n+   * Instantiate a NullableTimeMicroVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeMicroVector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(Types.MinorType.TIMEMICRO.getType()),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableTimeMicroVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeMicroVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, TYPE_WIDTH);\n+    reader = new TimeMicroReaderImpl(NullableTimeMicroVector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.TIMEMICRO;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+  /**\n+   * Get the element at the given index from the vector.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public long get(int index) throws IllegalStateException {\n+    if (isSet(index) == 0) {\n+      throw new IllegalStateException(\"Value at index is null\");\n+    }\n+    return valueBuffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableTimeMicroHolder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public Long getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return valueBuffer.getLong(index * TYPE_WIDTH);\n+    }\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFrom(int fromIndex, int thisIndex, NullableTimeMicroVector from) {\n+    if (from.isSet(fromIndex) != 0) {\n+      set(thisIndex, from.get(fromIndex));\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, NullableTimeMicroVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFromSafe(int fromIndex, int thisIndex, NullableTimeMicroVector from) {\n+    handleSafe(thisIndex);\n+    copyFrom(fromIndex, thisIndex, from);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  private void setValue(int index, long value) {\n+    valueBuffer.setLong(index * TYPE_WIDTH, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void set(int index, long value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableTimeMicroHolder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, TimeMicroHolder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, long)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void setSafe(int index, long value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableTimeMicroHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableTimeMicroHolder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, TimeMicroHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, TimeMicroHolder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Set the element at the given index to null.\n+   *\n+   * @param index   position of element\n+   */\n+  public void setNull(int index) {\n+    handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n+\n+  /**\n+   * Store the given value at a particular position in the vector. isSet indicates\n+   * whether the value is NULL or not.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void set(int index, int isSet, long value) {\n+    if (isSet > 0) {\n+      set(index, value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int, long)} except that it handles the case\n+   * when index is greater than or equal to current value capacity of the\n+   * vector.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void setSafe(int index, int isSet, long value) {\n+    handleSafe(index);\n+    set(index, isSet, value);\n+  }\n+\n+  /**\n+   * Given a data buffer, get the value stored at a particular position\n+   * in the vector.\n+   *\n+   * This method should not be used externally.\n+   *\n+   * @param buffer data buffer\n+   * @param index position of the element.\n+   * @return value stored at the index.\n+   */\n+  public static long get(final ArrowBuf buffer, int index) {\n+    return buffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new TransferImpl(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableTimeMicroVector) to);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    NullableTimeMicroVector to;\n+\n+    public TransferImpl(String ref, BufferAllocator allocator) {\n+      to = new NullableTimeMicroVector(ref, field.getFieldType(), allocator);\n+    }\n+\n+    public TransferImpl(NullableTimeMicroVector to) {\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public NullableTimeMicroVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      transferTo(to);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      splitAndTransferTo(startIndex, length, to);\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      to.copyFromSafe(fromIndex, toIndex, NullableTimeMicroVector.this);\n+    }\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeMilliVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeMilliVector.java\nnew file mode 100644\nindex 000000000..7d2d5d1f1\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeMilliVector.java\n@@ -0,0 +1,371 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeMilliReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeMilliHolder;\n+import org.apache.arrow.vector.holders.NullableTimeMilliHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.joda.time.LocalDateTime;\n+import org.slf4j.Logger;\n+\n+/**\n+ * NullableTimeMilliVector implements a fixed width (4 bytes) vector of\n+ * time (millisecond resolution) values which could be null. A validity buffer\n+ * (bit vector) is maintained to track which elements in the vector are null.\n+ */\n+public class NullableTimeMilliVector extends BaseNullableFixedWidthVector {\n+  private static final byte TYPE_WIDTH = 4;\n+  private final FieldReader reader;\n+\n+  /**\n+   * Instantiate a NullableTimeMilliVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeMilliVector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(Types.MinorType.TIMEMILLI.getType()),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableTimeMilliVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeMilliVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, TYPE_WIDTH);\n+    reader = new TimeMilliReaderImpl(NullableTimeMilliVector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.TIMEMILLI;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+  /**\n+   * Get the element at the given index from the vector.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public int get(int index) throws IllegalStateException {\n+    if (isSet(index) == 0) {\n+      throw new IllegalStateException(\"Value at index is null\");\n+    }\n+    return valueBuffer.getInt(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableTimeMilliHolder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getInt(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public LocalDateTime getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    }\n+    org.joda.time.LocalDateTime ldt = new org.joda.time.LocalDateTime(get(index),\n+            org.joda.time.DateTimeZone.UTC);\n+    return ldt;\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFrom(int fromIndex, int thisIndex, NullableTimeMilliVector from) {\n+    if (from.isSet(fromIndex) != 0) {\n+      set(thisIndex, from.get(fromIndex));\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, NullableTimeMilliVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFromSafe(int fromIndex, int thisIndex, NullableTimeMilliVector from) {\n+    handleSafe(thisIndex);\n+    copyFrom(fromIndex, thisIndex, from);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  private void setValue(int index, int value) {\n+    valueBuffer.setInt(index * TYPE_WIDTH, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void set(int index, int value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableTimeMilliHolder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, TimeMilliHolder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void setSafe(int index, int value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableTimeMilliHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableTimeMilliHolder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, TimeMilliHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, TimeMilliHolder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Set the element at the given index to null.\n+   *\n+   * @param index   position of element\n+   */\n+  public void setNull(int index) {\n+    handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n+\n+  /**\n+   * Store the given value at a particular position in the vector. isSet indicates\n+   * whether the value is NULL or not.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void set(int index, int isSet, int value) {\n+    if (isSet > 0) {\n+      set(index, value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int, int)} except that it handles the case\n+   * when index is greater than or equal to current value capacity of the\n+   * vector.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void setSafe(int index, int isSet, int value) {\n+    handleSafe(index);\n+    set(index, isSet, value);\n+  }\n+\n+\n+  /**\n+   * Given a data buffer, get the value stored at a particular position\n+   * in the vector.\n+   *\n+   * This method should not be used externally.\n+   *\n+   * @param buffer data buffer\n+   * @param index position of the element.\n+   * @return value stored at the index.\n+   */\n+  public static int get(final ArrowBuf buffer, final int index) {\n+    return buffer.getInt(index * TYPE_WIDTH);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new TransferImpl(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableTimeMilliVector) to);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    NullableTimeMilliVector to;\n+\n+    public TransferImpl(String ref, BufferAllocator allocator) {\n+      to = new NullableTimeMilliVector(ref, field.getFieldType(), allocator);\n+    }\n+\n+    public TransferImpl(NullableTimeMilliVector to) {\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public NullableTimeMilliVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      transferTo(to);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      splitAndTransferTo(startIndex, length, to);\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      to.copyFromSafe(fromIndex, toIndex, NullableTimeMilliVector.this);\n+    }\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeNanoVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeNanoVector.java\nnew file mode 100644\nindex 000000000..e93a63fe2\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeNanoVector.java\n@@ -0,0 +1,368 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeNanoReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeNanoHolder;\n+import org.apache.arrow.vector.holders.NullableTimeNanoHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableTimeNanoVector implements a fixed width vector (8 bytes) of\n+ * time (nanosecond resolution) values which could be null. A validity buffer\n+ * (bit vector) is maintained to track which elements in the vector are null.\n+ */\n+public class NullableTimeNanoVector extends BaseNullableFixedWidthVector {\n+  private static final byte TYPE_WIDTH = 8;\n+  private final FieldReader reader;\n+\n+  /**\n+   * Instantiate a NullableTimeNanoVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeNanoVector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(Types.MinorType.TIMENANO.getType()),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableTimeNanoVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeNanoVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, TYPE_WIDTH);\n+    reader = new TimeNanoReaderImpl(NullableTimeNanoVector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.TIMENANO;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public long get(int index) throws IllegalStateException {\n+    if (isSet(index) == 0) {\n+      throw new IllegalStateException(\"Value at index is null\");\n+    }\n+    return valueBuffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableTimeNanoHolder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public Long getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return valueBuffer.getLong(index * TYPE_WIDTH);\n+    }\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFrom(int fromIndex, int thisIndex, NullableTimeNanoVector from) {\n+    if (from.isSet(fromIndex) != 0) {\n+      set(thisIndex, from.get(fromIndex));\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, NullableTimeNanoVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFromSafe(int fromIndex, int thisIndex, NullableTimeNanoVector from) {\n+    handleSafe(thisIndex);\n+    copyFrom(fromIndex, thisIndex, from);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  private void setValue(int index, long value) {\n+    valueBuffer.setLong(index * TYPE_WIDTH, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void set(int index, long value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableTimeNanoHolder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, TimeNanoHolder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, long)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void setSafe(int index, long value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableTimeNanoHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableTimeNanoHolder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, TimeNanoHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, TimeNanoHolder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Set the element at the given index to null.\n+   *\n+   * @param index   position of element\n+   */\n+  public void setNull(int index) {\n+    handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n+\n+  /**\n+   * Store the given value at a particular position in the vector. isSet indicates\n+   * whether the value is NULL or not.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void set(int index, int isSet, long value) {\n+    if (isSet > 0) {\n+      set(index, value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int, long)} except that it handles the case\n+   * when index is greater than or equal to current value capacity of the\n+   * vector.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void setSafe(int index, int isSet, long value) {\n+    handleSafe(index);\n+    set(index, isSet, value);\n+  }\n+\n+  /**\n+   * Given a data buffer, get the value stored at a particular position\n+   * in the vector.\n+   *\n+   * This method should not be used externally.\n+   *\n+   * @param buffer data buffer\n+   * @param index position of the element.\n+   * @return value stored at the index.\n+   */\n+  public static long get(final ArrowBuf buffer, final int index) {\n+    return buffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new TransferImpl(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableTimeNanoVector) to);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    NullableTimeNanoVector to;\n+\n+    public TransferImpl(String ref, BufferAllocator allocator) {\n+      to = new NullableTimeNanoVector(ref, field.getFieldType(), allocator);\n+    }\n+\n+    public TransferImpl(NullableTimeNanoVector to) {\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public NullableTimeNanoVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      transferTo(to);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      splitAndTransferTo(startIndex, length, to);\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      to.copyFromSafe(fromIndex, toIndex, NullableTimeNanoVector.this);\n+    }\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeSecVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeSecVector.java\nnew file mode 100644\nindex 000000000..8329fa781\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeSecVector.java\n@@ -0,0 +1,369 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeSecReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeSecHolder;\n+import org.apache.arrow.vector.holders.NullableTimeSecHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableTimeSecVector implements a fixed width (4 bytes) vector of\n+ * time (seconds resolution) values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableTimeSecVector extends BaseNullableFixedWidthVector {\n+  private static final byte TYPE_WIDTH = 4;\n+  private final FieldReader reader;\n+\n+  /**\n+   * Instantiate a NullableTimeSecVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeSecVector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(Types.MinorType.TIMESEC.getType()),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableTimeSecVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeSecVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, TYPE_WIDTH);\n+    reader = new TimeSecReaderImpl(NullableTimeSecVector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.TIMESEC;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public int get(int index) throws IllegalStateException {\n+    if (isSet(index) == 0) {\n+      throw new IllegalStateException(\"Value at index is null\");\n+    }\n+    return valueBuffer.getInt(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableTimeSecHolder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getInt(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public Integer getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return valueBuffer.getInt(index * TYPE_WIDTH);\n+    }\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFrom(int fromIndex, int thisIndex, NullableTimeSecVector from) {\n+    if (from.isSet(fromIndex) != 0) {\n+      set(thisIndex, from.get(fromIndex));\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, NullableTimeSecVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFromSafe(int fromIndex, int thisIndex, NullableTimeSecVector from) {\n+    handleSafe(thisIndex);\n+    copyFrom(fromIndex, thisIndex, from);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  private void setValue(int index, int value) {\n+    valueBuffer.setInt(index * TYPE_WIDTH, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void set(int index, int value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableTimeSecHolder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, TimeSecHolder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void setSafe(int index, int value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableTimeSecHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableTimeSecHolder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, TimeSecHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, TimeSecHolder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Set the element at the given index to null.\n+   *\n+   * @param index   position of element\n+   */\n+  public void setNull(int index) {\n+    handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n+\n+  /**\n+   * Store the given value at a particular position in the vector. isSet indicates\n+   * whether the value is NULL or not.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void set(int index, int isSet, int value) {\n+    if (isSet > 0) {\n+      set(index, value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int, int)} except that it handles the case\n+   * when index is greater than or equal to current value capacity of the\n+   * vector.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void setSafe(int index, int isSet, int value) {\n+    handleSafe(index);\n+    set(index, isSet, value);\n+  }\n+\n+  /**\n+   * Given a data buffer, get the value stored at a particular position\n+   * in the vector.\n+   *\n+   * This method should not be used externally.\n+   *\n+   * @param buffer data buffer\n+   * @param index position of the element.\n+   * @return value stored at the index.\n+   */\n+  public static int get(final ArrowBuf buffer, final int index) {\n+    return buffer.getInt(index * TYPE_WIDTH);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new TransferImpl(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableTimeSecVector) to);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    NullableTimeSecVector to;\n+\n+    public TransferImpl(String ref, BufferAllocator allocator) {\n+      to = new NullableTimeSecVector(ref, field.getFieldType(), allocator);\n+    }\n+\n+    public TransferImpl(NullableTimeSecVector to) {\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public NullableTimeSecVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      transferTo(to);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      splitAndTransferTo(startIndex, length, to);\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      to.copyFromSafe(fromIndex, toIndex, NullableTimeSecVector.this);\n+    }\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMicroTZVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMicroTZVector.java\nnew file mode 100644\nindex 000000000..c7ad14154\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMicroTZVector.java\n@@ -0,0 +1,217 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeStampMicroTZReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeStampMicroTZHolder;\n+import org.apache.arrow.vector.holders.NullableTimeStampMicroTZHolder;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableTimeStampMicroTZVector implements a fixed width vector (8 bytes) of\n+ * timestamp (microsecond resolution) values which could be null. A validity buffer\n+ * (bit vector) is maintained to track which elements in the vector are null.\n+ */\n+public class NullableTimeStampMicroTZVector extends NullableTimeStampVector {\n+  private final FieldReader reader;\n+  private final String timeZone;\n+\n+  /**\n+   * Instantiate a NullableTimeStampMicroTZVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeStampMicroTZVector(String name, BufferAllocator allocator, String timeZone) {\n+    this(name, FieldType.nullable(new org.apache.arrow.vector.types.pojo.ArrowType.Timestamp(TimeUnit.MICROSECOND, timeZone)),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableTimeStampMicroTZVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeStampMicroTZVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, fieldType, allocator);\n+    org.apache.arrow.vector.types.pojo.ArrowType.Timestamp arrowType = (org.apache.arrow.vector.types.pojo.ArrowType.Timestamp) fieldType.getType();\n+    timeZone = arrowType.getTimezone();\n+    reader = new TimeStampMicroTZReaderImpl(NullableTimeStampMicroTZVector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.TIMESTAMPMICROTZ;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableTimeStampMicroTZHolder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public Long getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return valueBuffer.getLong(index * TYPE_WIDTH);\n+    }\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableTimeStampMicroTZHolder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, TimeStampMicroTZHolder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableTimeStampMicroTZHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableTimeStampMicroTZHolder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, TimeStampMicroTZHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, TimeStampMicroTZHolder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    NullableTimeStampMicroTZVector to = new NullableTimeStampMicroTZVector(ref,\n+            field.getFieldType(), allocator);\n+    return new TransferImpl(to);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableTimeStampMicroTZVector) to);\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMicroVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMicroVector.java\nnew file mode 100644\nindex 000000000..5a34b194c\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMicroVector.java\n@@ -0,0 +1,219 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeStampMicroReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeStampMicroHolder;\n+import org.apache.arrow.vector.holders.NullableTimeStampMicroHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.joda.time.LocalDateTime;\n+\n+/**\n+ * NullableTimeStampMicroVector implements a fixed width vector (8 bytes) of\n+ * timestamp (microsecond resolution) values which could be null. A validity buffer\n+ * (bit vector) is maintained to track which elements in the vector are null.\n+ */\n+public class NullableTimeStampMicroVector extends NullableTimeStampVector {\n+  private final FieldReader reader;\n+\n+  /**\n+   * Instantiate a NullableTimeStampMicroVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeStampMicroVector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(Types.MinorType.TIMESTAMPMICRO.getType()),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableTimeStampMicroVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeStampMicroVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, fieldType, allocator);\n+    reader = new TimeStampMicroReaderImpl(NullableTimeStampMicroVector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.TIMESTAMPMICRO;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableTimeStampMicroHolder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public LocalDateTime getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+         /* value is truncated when converting microseconds to milliseconds in order to use DateTime type */\n+      final long micros = valueBuffer.getLong(index * TYPE_WIDTH);\n+      final long millis = java.util.concurrent.TimeUnit.MICROSECONDS.toMillis(micros);\n+      final org.joda.time.LocalDateTime localDateTime = new org.joda.time.LocalDateTime(millis,\n+              org.joda.time.DateTimeZone.UTC);\n+      return localDateTime;\n+    }\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableTimeStampMicroHolder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, TimeStampMicroHolder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableTimeStampMicroHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableTimeStampMicroHolder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, TimeStampMicroHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, TimeStampMicroHolder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    NullableTimeStampMicroVector to = new NullableTimeStampMicroVector(ref,\n+            field.getFieldType(), allocator);\n+    return new TransferImpl(to);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableTimeStampMicroVector) to);\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMilliTZVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMilliTZVector.java\nnew file mode 100644\nindex 000000000..f9736aed7\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMilliTZVector.java\n@@ -0,0 +1,216 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeStampMilliTZReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeStampMilliTZHolder;\n+import org.apache.arrow.vector.holders.NullableTimeStampMilliTZHolder;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableTimeStampMilliTZVector implements a fixed width vector (8 bytes) of\n+ * timestamp (millisecond resolution) values which could be null. A validity buffer\n+ * (bit vector) is maintained to track which elements in the vector are null.\n+ */\n+public class NullableTimeStampMilliTZVector extends NullableTimeStampVector {\n+  private final FieldReader reader;\n+  private final String timeZone;\n+\n+  /**\n+   * Instantiate a NullableTimeStampMilliTZVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeStampMilliTZVector(String name, BufferAllocator allocator, String timeZone) {\n+    this(name, FieldType.nullable(new org.apache.arrow.vector.types.pojo.ArrowType.Timestamp(TimeUnit.MILLISECOND, timeZone)),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableTimeStampMilliTZVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeStampMilliTZVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, fieldType, allocator);\n+    org.apache.arrow.vector.types.pojo.ArrowType.Timestamp arrowType = (org.apache.arrow.vector.types.pojo.ArrowType.Timestamp) fieldType.getType();\n+    timeZone = arrowType.getTimezone();\n+    reader = new TimeStampMilliTZReaderImpl(NullableTimeStampMilliTZVector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.TIMESTAMPMILLITZ;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableTimeStampMilliTZHolder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public Long getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return valueBuffer.getLong(index * TYPE_WIDTH);\n+    }\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableTimeStampMilliTZHolder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, TimeStampMilliTZHolder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableTimeStampMilliTZHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableTimeStampMilliTZHolder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, TimeStampMilliTZHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, TimeStampMilliTZHolder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    NullableTimeStampMilliTZVector to = new NullableTimeStampMilliTZVector(ref,\n+            field.getFieldType(), allocator);\n+    return new TransferImpl(to);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableTimeStampMilliTZVector) to);\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMilliVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMilliVector.java\nnew file mode 100644\nindex 000000000..fc38a6bd5\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMilliVector.java\n@@ -0,0 +1,217 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeStampMilliReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeStampMilliHolder;\n+import org.apache.arrow.vector.holders.NullableTimeStampMilliHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.joda.time.LocalDateTime;\n+\n+/**\n+ * NullableTimeStampMilliVector implements a fixed width vector (8 bytes) of\n+ * timestamp (millisecond resolution) values which could be null. A validity buffer\n+ * (bit vector) is maintained to track which elements in the vector are null.\n+ */\n+public class NullableTimeStampMilliVector extends NullableTimeStampVector {\n+  private final FieldReader reader;\n+\n+  /**\n+   * Instantiate a NullableTimeStampMilliVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeStampMilliVector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(Types.MinorType.TIMESTAMPMILLI.getType()),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableTimeStampMilliVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeStampMilliVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, fieldType, allocator);\n+    reader = new TimeStampMilliReaderImpl(NullableTimeStampMilliVector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.TIMESTAMPMILLI;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableTimeStampMilliHolder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public LocalDateTime getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      final long millis = valueBuffer.getLong(index * TYPE_WIDTH);\n+      final org.joda.time.LocalDateTime localDateTime = new org.joda.time.LocalDateTime(millis,\n+              org.joda.time.DateTimeZone.UTC);\n+      return localDateTime;\n+    }\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableTimeStampMilliHolder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, TimeStampMilliHolder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableTimeStampMilliHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableTimeStampMilliHolder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, TimeStampMilliHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, TimeStampMilliHolder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    NullableTimeStampMilliVector to = new NullableTimeStampMilliVector(ref,\n+            field.getFieldType(), allocator);\n+    return new TransferImpl(to);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableTimeStampMilliVector) to);\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampNanoTZVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampNanoTZVector.java\nnew file mode 100644\nindex 000000000..8eb48462c\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampNanoTZVector.java\n@@ -0,0 +1,217 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeStampNanoTZReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeStampNanoTZHolder;\n+import org.apache.arrow.vector.holders.NullableTimeStampNanoTZHolder;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableTimeStampNanoTZVector implements a fixed width vector (8 bytes) of\n+ * timestamp (nanosecond resolution) values which could be null. A validity buffer\n+ * (bit vector) is maintained to track which elements in the vector are null.\n+ */\n+public class NullableTimeStampNanoTZVector extends NullableTimeStampVector {\n+  private final FieldReader reader;\n+  private final String timeZone;\n+\n+  /**\n+   * Instantiate a NullableTimeStampNanoTZVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeStampNanoTZVector(String name, BufferAllocator allocator, String timeZone) {\n+    this(name, FieldType.nullable(new org.apache.arrow.vector.types.pojo.ArrowType.Timestamp(TimeUnit.NANOSECOND, timeZone)),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableTimeStampNanoTZVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeStampNanoTZVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, fieldType, allocator);\n+    org.apache.arrow.vector.types.pojo.ArrowType.Timestamp arrowType = (org.apache.arrow.vector.types.pojo.ArrowType.Timestamp) fieldType.getType();\n+    timeZone = arrowType.getTimezone();\n+    reader = new TimeStampNanoTZReaderImpl(NullableTimeStampNanoTZVector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.TIMESTAMPNANOTZ;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableTimeStampNanoTZHolder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public Long getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return valueBuffer.getLong(index * TYPE_WIDTH);\n+    }\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableTimeStampNanoTZHolder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, TimeStampNanoTZHolder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableTimeStampNanoTZHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableTimeStampNanoTZHolder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, TimeStampNanoTZHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, TimeStampNanoTZHolder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    NullableTimeStampNanoTZVector to = new NullableTimeStampNanoTZVector(ref,\n+            field.getFieldType(), allocator);\n+    return new TransferImpl(to);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableTimeStampNanoTZVector) to);\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampNanoVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampNanoVector.java\nnew file mode 100644\nindex 000000000..6cc5c9057\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampNanoVector.java\n@@ -0,0 +1,218 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeStampNanoReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeStampNanoHolder;\n+import org.apache.arrow.vector.holders.NullableTimeStampNanoHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.joda.time.LocalDateTime;\n+\n+/**\n+ * NullableTimeStampNanoVector implements a fixed width vector (8 bytes) of\n+ * timestamp (nanosecond resolution) values which could be null. A validity buffer\n+ * (bit vector) is maintained to track which elements in the vector are null.\n+ */\n+public class NullableTimeStampNanoVector extends NullableTimeStampVector {\n+  private final FieldReader reader;\n+\n+  /**\n+   * Instantiate a NullableTimeStampNanoVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeStampNanoVector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(Types.MinorType.TIMESTAMPNANO.getType()),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableTimeStampNanoVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeStampNanoVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, fieldType, allocator);\n+    reader = new TimeStampNanoReaderImpl(NullableTimeStampNanoVector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.TIMESTAMPNANO;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableTimeStampNanoHolder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public LocalDateTime getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      final long nanos = valueBuffer.getLong(index * TYPE_WIDTH);\n+      final long millis = java.util.concurrent.TimeUnit.NANOSECONDS.toMillis(nanos);\n+      final org.joda.time.LocalDateTime localDateTime = new org.joda.time.LocalDateTime(millis,\n+              org.joda.time.DateTimeZone.UTC);\n+      return localDateTime;\n+    }\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableTimeStampNanoHolder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, TimeStampNanoHolder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableTimeStampNanoHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableTimeStampNanoHolder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, TimeStampNanoHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, TimeStampNanoHolder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    NullableTimeStampNanoVector to = new NullableTimeStampNanoVector(ref,\n+            field.getFieldType(), allocator);\n+    return new TransferImpl(to);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableTimeStampNanoVector) to);\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampSecTZVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampSecTZVector.java\nnew file mode 100644\nindex 000000000..0593ac76d\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampSecTZVector.java\n@@ -0,0 +1,215 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeStampSecTZReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeStampSecTZHolder;\n+import org.apache.arrow.vector.holders.NullableTimeStampSecTZHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableTimeStampSecTZVector implements a fixed width vector (8 bytes) of\n+ * timestamp (seconds resolution) values which could be null. A validity buffer\n+ * (bit vector) is maintained to track which elements in the vector are null.\n+ */\n+public class NullableTimeStampSecTZVector extends NullableTimeStampVector {\n+  private final FieldReader reader;\n+  private final String timeZone;\n+\n+  /**\n+   * Instantiate a NullableTimeStampSecTZVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeStampSecTZVector(String name, BufferAllocator allocator, String timeZone) {\n+    this(name, FieldType.nullable(new org.apache.arrow.vector.types.pojo.ArrowType.Timestamp(org.apache.arrow.vector.types.TimeUnit.SECOND, timeZone)),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableTimeStampSecTZVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeStampSecTZVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, fieldType, allocator);\n+    org.apache.arrow.vector.types.pojo.ArrowType.Timestamp arrowType = (org.apache.arrow.vector.types.pojo.ArrowType.Timestamp) fieldType.getType();\n+    timeZone = arrowType.getTimezone();\n+    reader = new TimeStampSecTZReaderImpl(NullableTimeStampSecTZVector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.TIMESTAMPSECTZ;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableTimeStampSecTZHolder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public Long getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return valueBuffer.getLong(index * TYPE_WIDTH);\n+    }\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableTimeStampSecTZHolder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, TimeStampSecTZHolder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableTimeStampSecTZHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableTimeStampSecTZHolder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, TimeStampSecTZHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, TimeStampSecTZHolder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    NullableTimeStampSecTZVector to = new NullableTimeStampSecTZVector(ref,\n+            field.getFieldType(), allocator);\n+    return new TransferImpl(to);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableTimeStampSecTZVector) to);\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampSecVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampSecVector.java\nnew file mode 100644\nindex 000000000..1afdb30d0\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampSecVector.java\n@@ -0,0 +1,218 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeStampSecReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeStampSecHolder;\n+import org.apache.arrow.vector.holders.NullableTimeStampSecHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.joda.time.LocalDateTime;\n+\n+/**\n+ * NullableTimeStampSecVector implements a fixed width vector (8 bytes) of\n+ * timestamp (seconds resolution) values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableTimeStampSecVector extends NullableTimeStampVector {\n+  private final FieldReader reader;\n+\n+  /**\n+   * Instantiate a NullableTimeStampSecVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeStampSecVector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(Types.MinorType.TIMESTAMPSEC.getType()),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableTimeStampSecVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeStampSecVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, fieldType, allocator);\n+    reader = new TimeStampSecReaderImpl(NullableTimeStampSecVector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.TIMESTAMPSEC;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableTimeStampSecHolder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public LocalDateTime getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      final long secs = valueBuffer.getLong(index * TYPE_WIDTH);\n+      final long millis = java.util.concurrent.TimeUnit.SECONDS.toMillis(secs);\n+      final org.joda.time.LocalDateTime localDateTime = new org.joda.time.LocalDateTime(millis,\n+              org.joda.time.DateTimeZone.UTC);\n+      return localDateTime;\n+    }\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableTimeStampSecHolder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, TimeStampSecHolder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableTimeStampSecHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableTimeStampSecHolder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, TimeStampSecHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, TimeStampSecHolder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    NullableTimeStampSecVector to = new NullableTimeStampSecVector(ref,\n+            field.getFieldType(), allocator);\n+    return new TransferImpl(to);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableTimeStampSecVector) to);\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampVector.java\nnew file mode 100644\nindex 000000000..d65cb83e1\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampVector.java\n@@ -0,0 +1,219 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableTimeStampVector is an abstract interface for fixed width vector (8 bytes)\n+ * of timestamp values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public abstract class NullableTimeStampVector extends BaseNullableFixedWidthVector {\n+  protected static final byte TYPE_WIDTH = 8;\n+\n+  /**\n+   * Instantiate a NullableTimeStampVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTimeStampVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, TYPE_WIDTH);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+  /**\n+   * Get the element at the given index from the vector.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public long get(int index) throws IllegalStateException {\n+    if (isSet(index) == 0) {\n+      throw new IllegalStateException(\"Value at index is null\");\n+    }\n+    return valueBuffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFrom(int fromIndex, int thisIndex, NullableTimeStampVector from) {\n+    if (from.isSet(fromIndex) != 0) {\n+      set(thisIndex, from.get(fromIndex));\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #copyFromSafe(int, int, NullableTimeStampVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFromSafe(int fromIndex, int thisIndex, NullableTimeStampVector from) {\n+    handleSafe(thisIndex);\n+    copyFrom(fromIndex, thisIndex, from);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  protected void setValue(int index, long value) {\n+    valueBuffer.setLong(index * TYPE_WIDTH, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void set(int index, long value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, long)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void setSafe(int index, long value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to null.\n+   *\n+   * @param index   position of element\n+   */\n+  public void setNull(int index) {\n+    handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n+\n+  /**\n+   * Store the given value at a particular position in the vector. isSet indicates\n+   * whether the value is NULL or not.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void set(int index, int isSet, long value) {\n+    if (isSet > 0) {\n+      set(index, value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int, long)} except that it handles the case\n+   * when index is greater than or equal to current value capacity of the\n+   * vector.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void setSafe(int index, int isSet, long value) {\n+    handleSafe(index);\n+    set(index, isSet, value);\n+  }\n+\n+  /**\n+   * Given a data buffer, get the value stored at a particular position\n+   * in the vector.\n+   *\n+   * This method should not be used externally.\n+   *\n+   * @param buffer data buffer\n+   * @param index position of the element.\n+   * @return value stored at the index.\n+   */\n+  public static long get(final ArrowBuf buffer, final int index) {\n+    return buffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  public class TransferImpl implements TransferPair {\n+    NullableTimeStampVector to;\n+\n+    public TransferImpl(NullableTimeStampVector to) {\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public NullableTimeStampVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      transferTo(to);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      splitAndTransferTo(startIndex, length, to);\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      to.copyFromSafe(fromIndex, toIndex, NullableTimeStampVector.this);\n+    }\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTinyIntVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTinyIntVector.java\nnew file mode 100644\nindex 000000000..106359ddd\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTinyIntVector.java\n@@ -0,0 +1,396 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TinyIntReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TinyIntHolder;\n+import org.apache.arrow.vector.holders.NullableTinyIntHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableTinyIntVector implements a fixed width (1 bytes) vector of\n+ * byte values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableTinyIntVector extends BaseNullableFixedWidthVector {\n+  public static final byte TYPE_WIDTH = 1;\n+  private final FieldReader reader;\n+\n+  /**\n+   * Instantiate a NullableTinyIntVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTinyIntVector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(Types.MinorType.TINYINT.getType()),\n+            allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableTinyIntVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableTinyIntVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, TYPE_WIDTH);\n+    reader = new TinyIntReaderImpl(NullableTinyIntVector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.TINYINT;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public byte get(int index) throws IllegalStateException {\n+    if (isSet(index) == 0) {\n+      throw new IllegalStateException(\"Value at index is null\");\n+    }\n+    return valueBuffer.getByte(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableTinyIntHolder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getByte(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public Byte getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return valueBuffer.getByte(index * TYPE_WIDTH);\n+    }\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFrom(int fromIndex, int thisIndex, NullableTinyIntVector from) {\n+    if (from.isSet(fromIndex) != 0) {\n+      set(thisIndex, from.get(fromIndex));\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, NullableTinyIntVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFromSafe(int fromIndex, int thisIndex, NullableTinyIntVector from) {\n+    handleSafe(thisIndex);\n+    copyFrom(fromIndex, thisIndex, from);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+  private void setValue(int index, int value) {\n+    valueBuffer.setByte(index * TYPE_WIDTH, value);\n+  }\n+\n+  private void setValue(int index, byte value) {\n+    valueBuffer.setByte(index * TYPE_WIDTH, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void set(int index, int value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void set(int index, byte value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableTinyIntHolder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, TinyIntHolder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void setSafe(int index, int value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, byte)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void setSafe(int index, byte value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableTinyIntHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableTinyIntHolder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, TinyIntHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, TinyIntHolder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Set the element at the given index to null.\n+   *\n+   * @param index   position of element\n+   */\n+  public void setNull(int index) {\n+    handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n+\n+  /**\n+   * Store the given value at a particular position in the vector. isSet indicates\n+   * whether the value is NULL or not.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void set(int index, int isSet, byte value) {\n+    if (isSet > 0) {\n+      set(index, value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int, byte)} except that it handles the case\n+   * when index is greater than or equal to current value capacity of the\n+   * vector.\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void setSafe(int index, int isSet, byte value) {\n+    handleSafe(index);\n+    set(index, isSet, value);\n+  }\n+\n+  /**\n+   * Given a data buffer, get the value stored at a particular position\n+   * in the vector.\n+   *\n+   * This method should not be used externally.\n+   *\n+   * @param buffer data buffer\n+   * @param index position of the element.\n+   * @return value stored at the index.\n+   */\n+  public static byte get(final ArrowBuf buffer, final int index) {\n+    return buffer.getByte(index * TYPE_WIDTH);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new TransferImpl(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableTinyIntVector) to);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    NullableTinyIntVector to;\n+\n+    public TransferImpl(String ref, BufferAllocator allocator) {\n+      to = new NullableTinyIntVector(ref, field.getFieldType(), allocator);\n+    }\n+\n+    public TransferImpl(NullableTinyIntVector to) {\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public NullableTinyIntVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      transferTo(to);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      splitAndTransferTo(startIndex, length, to);\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      to.copyFromSafe(fromIndex, toIndex, NullableTinyIntVector.this);\n+    }\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt1Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt1Vector.java\nnew file mode 100644\nindex 000000000..52f6c151b\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt1Vector.java\n@@ -0,0 +1,318 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.UInt1ReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.UInt1Holder;\n+import org.apache.arrow.vector.holders.NullableUInt1Holder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableUInt1Vector implements a fixed width (1 bytes) vector of\n+ * integer values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableUInt1Vector extends BaseNullableFixedWidthVector {\n+  private static final byte TYPE_WIDTH = 1;\n+  private final FieldReader reader;\n+\n+  public NullableUInt1Vector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(org.apache.arrow.vector.types.Types.MinorType.UINT1.getType()),\n+            allocator);\n+  }\n+\n+  public NullableUInt1Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, TYPE_WIDTH);\n+    reader = new UInt1ReaderImpl(NullableUInt1Vector.this);\n+  }\n+\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.UINT1;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public byte get(int index) throws IllegalStateException {\n+    if (isSet(index) == 0) {\n+      throw new IllegalStateException(\"Value at index is null\");\n+    }\n+    return valueBuffer.getByte(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableUInt1Holder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getByte(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public Byte getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return valueBuffer.getByte(index * TYPE_WIDTH);\n+    }\n+  }\n+\n+  public void copyFrom(int fromIndex, int thisIndex, NullableUInt1Vector from) {\n+    if (from.isSet(fromIndex) != 0) {\n+      set(thisIndex, from.get(fromIndex));\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n+    }\n+  }\n+\n+  public void copyFromSafe(int fromIndex, int thisIndex, NullableUInt1Vector from) {\n+    handleSafe(thisIndex);\n+    copyFrom(fromIndex, thisIndex, from);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  private void setValue(int index, int value) {\n+    valueBuffer.setByte(index * TYPE_WIDTH, value);\n+  }\n+\n+  private void setValue(int index, byte value) {\n+    valueBuffer.setByte(index * TYPE_WIDTH, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void set(int index, int value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void set(int index, byte value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableUInt1Holder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, UInt1Holder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void setSafe(int index, int value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, byte)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void setSafe(int index, byte value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableUInt1Holder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableUInt1Holder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, UInt1Holder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, UInt1Holder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Set the element at the given index to null.\n+   *\n+   * @param index   position of element\n+   */\n+  public void setNull(int index) {\n+    handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n+\n+  public void set(int index, int isSet, byte value) {\n+    if (isSet > 0) {\n+      set(index, value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  public void setSafe(int index, int isSet, byte value) {\n+    handleSafe(index);\n+    set(index, isSet, value);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new TransferImpl(ref, allocator);\n+  }\n+\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableUInt1Vector) to);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    NullableUInt1Vector to;\n+\n+    public TransferImpl(String ref, BufferAllocator allocator) {\n+      to = new NullableUInt1Vector(ref, field.getFieldType(), allocator);\n+    }\n+\n+    public TransferImpl(NullableUInt1Vector to) {\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public NullableUInt1Vector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      transferTo(to);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      splitAndTransferTo(startIndex, length, to);\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      to.copyFromSafe(fromIndex, toIndex, NullableUInt1Vector.this);\n+    }\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt2Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt2Vector.java\nnew file mode 100644\nindex 000000000..42ba6e139\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt2Vector.java\n@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.UInt2ReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.UInt2Holder;\n+import org.apache.arrow.vector.holders.NullableUInt2Holder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.slf4j.Logger;\n+\n+/**\n+ * NullableUInt2Vector implements a fixed width (2 bytes) vector of\n+ * integer values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableUInt2Vector extends BaseNullableFixedWidthVector {\n+  private static final byte TYPE_WIDTH = 2;\n+  private final FieldReader reader;\n+\n+  public NullableUInt2Vector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(org.apache.arrow.vector.types.Types.MinorType.UINT2.getType()),\n+            allocator);\n+  }\n+\n+  public NullableUInt2Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, TYPE_WIDTH);\n+    reader = new UInt2ReaderImpl(NullableUInt2Vector.this);\n+  }\n+\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.UINT2;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public char get(int index) throws IllegalStateException {\n+    if (isSet(index) == 0) {\n+      throw new IllegalStateException(\"Value at index is null\");\n+    }\n+    return valueBuffer.getChar(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableUInt2Holder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getChar(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public Character getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return valueBuffer.getChar(index * TYPE_WIDTH);\n+    }\n+  }\n+\n+  public void copyFrom(int fromIndex, int thisIndex, NullableUInt2Vector from) {\n+    if (from.isSet(fromIndex) != 0) {\n+      set(thisIndex, from.get(fromIndex));\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n+    }\n+  }\n+\n+  public void copyFromSafe(int fromIndex, int thisIndex, NullableUInt2Vector from) {\n+    handleSafe(thisIndex);\n+    copyFrom(fromIndex, thisIndex, from);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  private void setValue(int index, int value) {\n+    valueBuffer.setChar(index * TYPE_WIDTH, value);\n+  }\n+\n+  private void setValue(int index, char value) {\n+    valueBuffer.setChar(index * TYPE_WIDTH, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void set(int index, int value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void set(int index, char value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableUInt2Holder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, UInt2Holder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void setSafe(int index, int value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, char)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void setSafe(int index, char value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableUInt2Holder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableUInt2Holder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, UInt2Holder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, UInt2Holder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Set the element at the given index to null.\n+   *\n+   * @param index   position of element\n+   */\n+  public void setNull(int index) {\n+    handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n+\n+  public void set(int index, int isSet, char value) {\n+    if (isSet > 0) {\n+      set(index, value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  public void setSafe(int index, int isSet, char value) {\n+    handleSafe(index);\n+    set(index, isSet, value);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new TransferImpl(ref, allocator);\n+  }\n+\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableUInt2Vector) to);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    NullableUInt2Vector to;\n+\n+    public TransferImpl(String ref, BufferAllocator allocator) {\n+      to = new NullableUInt2Vector(ref, field.getFieldType(), allocator);\n+    }\n+\n+    public TransferImpl(NullableUInt2Vector to) {\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public NullableUInt2Vector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      transferTo(to);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      splitAndTransferTo(startIndex, length, to);\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      to.copyFromSafe(fromIndex, toIndex, NullableUInt2Vector.this);\n+    }\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt4Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt4Vector.java\nnew file mode 100644\nindex 000000000..1ec21490d\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt4Vector.java\n@@ -0,0 +1,291 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.UInt4ReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.UInt4Holder;\n+import org.apache.arrow.vector.holders.NullableUInt4Holder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.slf4j.Logger;\n+\n+/**\n+ * NullableUInt4Vector implements a fixed width (4 bytes) vector of\n+ * integer values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableUInt4Vector extends BaseNullableFixedWidthVector {\n+  private static final byte TYPE_WIDTH = 4;\n+  private final FieldReader reader;\n+\n+  public NullableUInt4Vector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(org.apache.arrow.vector.types.Types.MinorType.UINT4.getType()),\n+            allocator);\n+  }\n+\n+  public NullableUInt4Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, TYPE_WIDTH);\n+    reader = new UInt4ReaderImpl(NullableUInt4Vector.this);\n+  }\n+\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.UINT4;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public int get(int index) throws IllegalStateException {\n+    if (isSet(index) == 0) {\n+      throw new IllegalStateException(\"Value at index is null\");\n+    }\n+    return valueBuffer.getInt(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableUInt4Holder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getInt(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public Integer getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return valueBuffer.getInt(index * TYPE_WIDTH);\n+    }\n+  }\n+\n+  public void copyFrom(int fromIndex, int thisIndex, NullableUInt4Vector from) {\n+    if (from.isSet(fromIndex) != 0) {\n+      set(thisIndex, from.get(fromIndex));\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n+    }\n+  }\n+\n+  public void copyFromSafe(int fromIndex, int thisIndex, NullableUInt4Vector from) {\n+    handleSafe(thisIndex);\n+    copyFrom(fromIndex, thisIndex, from);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  private void setValue(int index, int value) {\n+    valueBuffer.setInt(index * TYPE_WIDTH, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void set(int index, int value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableUInt4Holder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, UInt4Holder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, int)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void setSafe(int index, int value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableUInt4Holder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableUInt4Holder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, UInt4Holder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, UInt4Holder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Set the element at the given index to null.\n+   *\n+   * @param index   position of element\n+   */\n+  public void setNull(int index) {\n+    handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n+\n+  public void set(int index, int isSet, int value) {\n+    if (isSet > 0) {\n+      set(index, value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  public void setSafe(int index, int isSet, int value) {\n+    handleSafe(index);\n+    set(index, isSet, value);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new TransferImpl(ref, allocator);\n+  }\n+\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableUInt4Vector) to);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    NullableUInt4Vector to;\n+\n+    public TransferImpl(String ref, BufferAllocator allocator) {\n+      to = new NullableUInt4Vector(ref, field.getFieldType(), allocator);\n+    }\n+\n+    public TransferImpl(NullableUInt4Vector to) {\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public NullableUInt4Vector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      transferTo(to);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      splitAndTransferTo(startIndex, length, to);\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      to.copyFromSafe(fromIndex, toIndex, NullableUInt4Vector.this);\n+    }\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt8Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt8Vector.java\nnew file mode 100644\nindex 000000000..408a810cf\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt8Vector.java\n@@ -0,0 +1,291 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.UInt8ReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.UInt8Holder;\n+import org.apache.arrow.vector.holders.NullableUInt8Holder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.slf4j.Logger;\n+\n+/**\n+ * NullableUInt8Vector implements a fixed width vector (8 bytes) of\n+ * integer values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableUInt8Vector extends BaseNullableFixedWidthVector {\n+  private static final byte TYPE_WIDTH = 8;\n+  private final FieldReader reader;\n+\n+  public NullableUInt8Vector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(Types.MinorType.UINT8.getType()),\n+            allocator);\n+  }\n+\n+  public NullableUInt8Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, TYPE_WIDTH);\n+    reader = new UInt8ReaderImpl(NullableUInt8Vector.this);\n+  }\n+\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.UINT8;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the element at the given index from the vector.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public long get(int index) throws IllegalStateException {\n+    if (isSet(index) == 0) {\n+      throw new IllegalStateException(\"Value at index is null\");\n+    }\n+    return valueBuffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index   position of element\n+   */\n+  public void get(int index, NullableUInt8Holder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+  }\n+\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index   position of element\n+   * @return element at given index\n+   */\n+  public Long getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return valueBuffer.getLong(index * TYPE_WIDTH);\n+    }\n+  }\n+\n+  public void copyFrom(int fromIndex, int thisIndex, NullableUInt8Vector from) {\n+    if (from.isSet(fromIndex) != 0) {\n+      set(thisIndex, from.get(fromIndex));\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, thisIndex, 0);\n+    }\n+  }\n+\n+  public void copyFromSafe(int fromIndex, int thisIndex, NullableUInt8Vector from) {\n+    handleSafe(thisIndex);\n+    copyFrom(fromIndex, thisIndex, from);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  private void setValue(int index, long value) {\n+    valueBuffer.setLong(index * TYPE_WIDTH, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void set(int index, long value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, value);\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void set(int index, NullableUInt8Holder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void set(int index, UInt8Holder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    setValue(index, holder.value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, long)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param value   value of element\n+   */\n+  public void setSafe(int index, long value) {\n+    handleSafe(index);\n+    set(index, value);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableUInt8Holder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableUInt8Holder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, UInt8Holder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index   position of element\n+   * @param holder  data holder for value of element\n+   */\n+  public void setSafe(int index, UInt8Holder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n+  }\n+\n+  /**\n+   * Set the element at the given index to null.\n+   *\n+   * @param index   position of element\n+   */\n+  public void setNull(int index) {\n+    handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n+\n+  public void set(int index, int isSet, long value) {\n+    if (isSet > 0) {\n+      set(index, value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n+  }\n+\n+  public void setSafe(int index, int isSet, long value) {\n+    handleSafe(index);\n+    set(index, isSet, value);\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new TransferImpl(ref, allocator);\n+  }\n+\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableUInt8Vector) to);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    NullableUInt8Vector to;\n+\n+    public TransferImpl(String ref, BufferAllocator allocator) {\n+      to = new NullableUInt8Vector(ref, field.getFieldType(), allocator);\n+    }\n+\n+    public TransferImpl(NullableUInt8Vector to) {\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public NullableUInt8Vector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      transferTo(to);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      splitAndTransferTo(startIndex, length, to);\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      to.copyFromSafe(fromIndex, toIndex, NullableUInt8Vector.this);\n+    }\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableVarBinaryVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableVarBinaryVector.java\nnew file mode 100644\nindex 000000000..1dfe8912c\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableVarBinaryVector.java\n@@ -0,0 +1,328 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.VarBinaryReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.VarBinaryHolder;\n+import org.apache.arrow.vector.holders.NullableVarBinaryHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * NullableVarBinaryVector implements a variable width vector of binary\n+ * values which could be NULL. A validity buffer (bit vector) is maintained\n+ * to track which elements in the vector are null.\n+ */\n+public class NullableVarBinaryVector extends BaseNullableVariableWidthVector {\n+  private final FieldReader reader;\n+\n+  /**\n+   * Instantiate a NullableVarBinaryVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableVarBinaryVector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(Types.MinorType.VARBINARY.getType()), allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableVarBinaryVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableVarBinaryVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType);\n+    reader = new VarBinaryReaderImpl(NullableVarBinaryVector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.VARBINARY;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value getter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the variable length element at specified index as byte array.\n+   *\n+   * @param index   position of element to get\n+   * @return array of bytes for non-null element, null otherwise\n+   */\n+  public byte[] get(int index) {\n+    assert index >= 0;\n+    if (isSet(index) == 0) {\n+      throw new IllegalStateException(\"Value at index is null\");\n+    }\n+    final int startOffset = getstartOffset(index);\n+    final int dataLength =\n+            offsetBuffer.getInt((index + 1) * OFFSET_WIDTH) - startOffset;\n+    final byte[] result = new byte[dataLength];\n+    valueBuffer.getBytes(startOffset, result, 0, dataLength);\n+    return result;\n+  }\n+\n+  /**\n+   * Get the variable length element at specified index as Text.\n+   *\n+   * @param index   position of element to get\n+   * @return byte array for non-null element, null otherwise\n+   */\n+  public byte[] getObject(int index) {\n+    byte[] b;\n+    try {\n+      b = get(index);\n+    } catch (IllegalStateException e) {\n+      return null;\n+    }\n+    return b;\n+  }\n+\n+  /**\n+   * Get the variable length element at specified index and sets the state\n+   * in provided holder.\n+   *\n+   * @param index   position of element to get\n+   * @param holder  data holder to be populated by this function\n+   */\n+  public void get(int index, NullableVarBinaryHolder holder) {\n+    assert index >= 0;\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.start = getstartOffset(index);\n+    holder.end = offsetBuffer.getInt((index + 1) * OFFSET_WIDTH);\n+    holder.buffer = valueBuffer;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFrom(int fromIndex, int thisIndex, NullableVarBinaryVector from) {\n+    final int start = from.offsetBuffer.getInt(fromIndex * OFFSET_WIDTH);\n+    final int end = from.offsetBuffer.getInt((fromIndex + 1) * OFFSET_WIDTH);\n+    final int length = end - start;\n+    fillHoles(thisIndex);\n+    BitVectorHelper.setValidityBit(this.validityBuffer, thisIndex, from.isSet(fromIndex));\n+    final int copyStart = offsetBuffer.getInt(thisIndex * OFFSET_WIDTH);\n+    from.valueBuffer.getBytes(start, this.valueBuffer, copyStart, length);\n+    offsetBuffer.setInt((thisIndex + 1) * OFFSET_WIDTH, copyStart + length);\n+    lastSet = thisIndex;\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, NullableVarBinaryVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFromSafe(int fromIndex, int thisIndex, NullableVarBinaryVector from) {\n+    final int start = from.offsetBuffer.getInt(fromIndex * OFFSET_WIDTH);\n+    final int end = from.offsetBuffer.getInt((fromIndex + 1) * OFFSET_WIDTH);\n+    final int length = end - start;\n+    handleSafe(thisIndex, length);\n+    fillHoles(thisIndex);\n+    BitVectorHelper.setValidityBit(this.validityBuffer, thisIndex, from.isSet(fromIndex));\n+    final int copyStart = offsetBuffer.getInt(thisIndex * OFFSET_WIDTH);\n+    from.valueBuffer.getBytes(start, this.valueBuffer, copyStart, length);\n+    offsetBuffer.setInt((thisIndex + 1) * OFFSET_WIDTH, copyStart + length);\n+    lastSet = thisIndex;\n+  }\n+\n+  /**\n+   * Set the variable length element at the specified index to the data\n+   * buffer supplied in the holder\n+   *\n+   * @param index   position of the element to set\n+   * @param holder  holder that carries data buffer.\n+   */\n+  public void set(int index, VarBinaryHolder holder) {\n+    assert index >= 0;\n+    fillHoles(index);\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    final int dataLength = holder.end - holder.start;\n+    final int startOffset = getstartOffset(index);\n+    offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + dataLength);\n+    valueBuffer.setBytes(startOffset, holder.buffer, holder.start, dataLength);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, VarBinaryHolder)} except that it handles the\n+   * case where index and length of new element are beyond the existing\n+   * capacity of the vector.\n+   *\n+   * @param index   position of the element to set\n+   * @param holder  holder that carries data buffer.\n+   */\n+  public void setSafe(int index, VarBinaryHolder holder) {\n+    assert index >= 0;\n+    final int dataLength = holder.end - holder.start;\n+    fillEmpties(index);\n+    handleSafe(index, dataLength);\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    final int startOffset = getstartOffset(index);\n+    offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + dataLength);\n+    valueBuffer.setBytes(startOffset, holder.buffer, holder.start, dataLength);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Set the variable length element at the specified index to the data\n+   * buffer supplied in the holder\n+   *\n+   * @param index   position of the element to set\n+   * @param holder  holder that carries data buffer.\n+   */\n+  public void set(int index, NullableVarBinaryHolder holder) {\n+    assert index >= 0;\n+    fillHoles(index);\n+    BitVectorHelper.setValidityBit(validityBuffer, index, holder.isSet);\n+    final int dataLength = holder.end - holder.start;\n+    final int startOffset = getstartOffset(index);\n+    offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + dataLength);\n+    valueBuffer.setBytes(startOffset, holder.buffer, holder.start, dataLength);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableVarBinaryHolder)} except that it handles the\n+   * case where index and length of new element are beyond the existing\n+   * capacity of the vector.\n+   *\n+   * @param index   position of the element to set\n+   * @param holder  holder that carries data buffer.\n+   */\n+  public void setSafe(int index, NullableVarBinaryHolder holder) {\n+    assert index >= 0;\n+    final int dataLength = holder.end - holder.start;\n+    fillEmpties(index);\n+    handleSafe(index, dataLength);\n+    BitVectorHelper.setValidityBit(validityBuffer, index, holder.isSet);\n+    final int startOffset = getstartOffset(index);\n+    offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + dataLength);\n+    valueBuffer.setBytes(startOffset, holder.buffer, holder.start, dataLength);\n+    lastSet = index;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new TransferImpl(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableVarBinaryVector) to);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    NullableVarBinaryVector to;\n+\n+    public TransferImpl(String ref, BufferAllocator allocator) {\n+      to = new NullableVarBinaryVector(ref, field.getFieldType(), allocator);\n+    }\n+\n+    public TransferImpl(NullableVarBinaryVector to) {\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public NullableVarBinaryVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      transferTo(to);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      splitAndTransferTo(startIndex, length, to);\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      to.copyFromSafe(fromIndex, toIndex, NullableVarBinaryVector.this);\n+    }\n+  }\n+}\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableVarCharVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableVarCharVector.java\nnew file mode 100644\nindex 000000000..31e409cc6\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableVarCharVector.java\n@@ -0,0 +1,331 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.VarCharReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.VarCharHolder;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.Text;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * NullableVarCharVector implements a variable width vector of VARCHAR\n+ * values which could be NULL. A validity buffer (bit vector) is maintained\n+ * to track which elements in the vector are null.\n+ */\n+public class NullableVarCharVector extends BaseNullableVariableWidthVector {\n+  private final FieldReader reader;\n+\n+  /**\n+   * Instantiate a NullableVarCharVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableVarCharVector(String name, BufferAllocator allocator) {\n+    this(name, FieldType.nullable(org.apache.arrow.vector.types.Types.MinorType.VARCHAR.getType()), allocator);\n+  }\n+\n+  /**\n+   * Instantiate a NullableVarCharVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   * @param name name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public NullableVarCharVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType);\n+    reader = new VarCharReaderImpl(NullableVarCharVector.this);\n+  }\n+\n+  /**\n+   * Get a reader that supports reading values from this vector\n+   * @return Field Reader for this vector\n+   */\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n+  @Override\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.VARCHAR;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value getter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Get the variable length element at specified index as byte array.\n+   *\n+   * @param index   position of element to get\n+   * @return array of bytes for non-null element, null otherwise\n+   */\n+  public byte[] get(int index) {\n+    assert index >= 0;\n+    if (isSet(index) == 0) {\n+      throw new IllegalStateException(\"Value at index is null\");\n+    }\n+    final int startOffset = getstartOffset(index);\n+    final int dataLength =\n+            offsetBuffer.getInt((index + 1) * OFFSET_WIDTH) - startOffset;\n+    final byte[] result = new byte[dataLength];\n+    valueBuffer.getBytes(startOffset, result, 0, dataLength);\n+    return result;\n+  }\n+\n+  /**\n+   * Get the variable length element at specified index as Text.\n+   *\n+   * @param index   position of element to get\n+   * @return Text object for non-null element, null otherwise\n+   */\n+  public Text getObject(int index) {\n+    Text result = new Text();\n+    byte[] b;\n+    try {\n+      b = get(index);\n+    } catch (IllegalStateException e) {\n+      return null;\n+    }\n+    result.set(b);\n+    return result;\n+  }\n+\n+  /**\n+   * Get the variable length element at specified index and sets the state\n+   * in provided holder.\n+   *\n+   * @param index   position of element to get\n+   * @param holder  data holder to be populated by this function\n+   */\n+  public void get(int index, NullableVarCharHolder holder) {\n+    assert index >= 0;\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n+    }\n+    holder.isSet = 1;\n+    holder.start = getstartOffset(index);\n+    holder.end = offsetBuffer.getInt((index + 1) * OFFSET_WIDTH);\n+    holder.buffer = valueBuffer;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFrom(int fromIndex, int thisIndex, NullableVarCharVector from) {\n+    final int start = from.offsetBuffer.getInt(fromIndex * OFFSET_WIDTH);\n+    final int end = from.offsetBuffer.getInt((fromIndex + 1) * OFFSET_WIDTH);\n+    final int length = end - start;\n+    fillHoles(thisIndex);\n+    BitVectorHelper.setValidityBit(this.validityBuffer, thisIndex, from.isSet(fromIndex));\n+    final int copyStart = offsetBuffer.getInt(thisIndex * OFFSET_WIDTH);\n+    from.valueBuffer.getBytes(start, this.valueBuffer, copyStart, length);\n+    offsetBuffer.setInt((thisIndex + 1) * OFFSET_WIDTH, copyStart + length);\n+    lastSet = thisIndex;\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, NullableVarCharVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  public void copyFromSafe(int fromIndex, int thisIndex, NullableVarCharVector from) {\n+    final int start = from.offsetBuffer.getInt(fromIndex * OFFSET_WIDTH);\n+    final int end = from.offsetBuffer.getInt((fromIndex + 1) * OFFSET_WIDTH);\n+    final int length = end - start;\n+    handleSafe(thisIndex, length);\n+    fillHoles(thisIndex);\n+    BitVectorHelper.setValidityBit(this.validityBuffer, thisIndex, from.isSet(fromIndex));\n+    final int copyStart = offsetBuffer.getInt(thisIndex * OFFSET_WIDTH);\n+    from.valueBuffer.getBytes(start, this.valueBuffer, copyStart, length);\n+    offsetBuffer.setInt((thisIndex + 1) * OFFSET_WIDTH, copyStart + length);\n+    lastSet = thisIndex;\n+  }\n+\n+  /**\n+   * Set the variable length element at the specified index to the data\n+   * buffer supplied in the holder\n+   *\n+   * @param index   position of the element to set\n+   * @param holder  holder that carries data buffer.\n+   */\n+  public void set(int index, VarCharHolder holder) {\n+    assert index >= 0;\n+    fillHoles(index);\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    final int dataLength = holder.end - holder.start;\n+    final int startOffset = getstartOffset(index);\n+    offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + dataLength);\n+    valueBuffer.setBytes(startOffset, holder.buffer, holder.start, dataLength);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, VarCharHolder)} except that it handles the\n+   * case where index and length of new element are beyond the existing\n+   * capacity of the vector.\n+   *\n+   * @param index   position of the element to set\n+   * @param holder  holder that carries data buffer.\n+   */\n+  public void setSafe(int index, VarCharHolder holder) {\n+    assert index >= 0;\n+    final int dataLength = holder.end - holder.start;\n+    fillEmpties(index);\n+    handleSafe(index, dataLength);\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    final int startOffset = getstartOffset(index);\n+    offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + dataLength);\n+    valueBuffer.setBytes(startOffset, holder.buffer, holder.start, dataLength);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Set the variable length element at the specified index to the data\n+   * buffer supplied in the holder\n+   *\n+   * @param index   position of the element to set\n+   * @param holder  holder that carries data buffer.\n+   */\n+  public void set(int index, NullableVarCharHolder holder) {\n+    assert index >= 0;\n+    fillHoles(index);\n+    BitVectorHelper.setValidityBit(validityBuffer, index, holder.isSet);\n+    final int dataLength = holder.end - holder.start;\n+    final int startOffset = getstartOffset(index);\n+    offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + dataLength);\n+    valueBuffer.setBytes(startOffset, holder.buffer, holder.start, dataLength);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Same as {@link #set(int, NullableVarCharHolder)} except that it handles the\n+   * case where index and length of new element are beyond the existing\n+   * capacity of the vector.\n+   *\n+   * @param index   position of the element to set\n+   * @param holder  holder that carries data buffer.\n+   */\n+  public void setSafe(int index, NullableVarCharHolder holder) {\n+    assert index >= 0;\n+    final int dataLength = holder.end - holder.start;\n+    fillEmpties(index);\n+    handleSafe(index, dataLength);\n+    BitVectorHelper.setValidityBit(validityBuffer, index, holder.isSet);\n+    final int startOffset = getstartOffset(index);\n+    offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + dataLength);\n+    valueBuffer.setBytes(startOffset, holder.buffer, holder.start, dataLength);\n+    lastSet = index;\n+  }\n+\n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   * @param ref name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new TransferImpl(ref, allocator);\n+  }\n+\n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new TransferImpl((NullableVarCharVector) to);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    NullableVarCharVector to;\n+\n+    public TransferImpl(String ref, BufferAllocator allocator) {\n+      to = new NullableVarCharVector(ref, field.getFieldType(), allocator);\n+    }\n+\n+    public TransferImpl(NullableVarCharVector to) {\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public NullableVarCharVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      transferTo(to);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      splitAndTransferTo(startIndex, length, to);\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      to.copyFromSafe(fromIndex, toIndex, NullableVarCharVector.this);\n+    }\n+  }\n+}\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/ValueVector.java b/java/vector/src/main/java/org/apache/arrow/vector/ValueVector.java\nindex fb7286f85..0d3acf164 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/ValueVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/ValueVector.java\n@@ -6,9 +6,9 @@\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- *\n+ * <p>\n  * http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * <p>\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -255,4 +255,18 @@\n    * @return buffer\n    */\n   public ArrowBuf getOffsetBuffer();\n+\n+  /* temporarily add these methods here until we remove other vectors\n+   * (non-nullable) which are under ValueVector hierarchy and still\n+   * use the mutator/accessor interfaces.\n+   */\n+  public int getValueCount();\n+\n+  public void setValueCount(int valueCount);\n+\n+  public Object getObject(int index);\n+\n+  public int getNullCount();\n+\n+  public boolean isNull(int index);\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/VectorSchemaRoot.java b/java/vector/src/main/java/org/apache/arrow/vector/VectorSchemaRoot.java\nindex 0c8868cad..196393fb9 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/VectorSchemaRoot.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/VectorSchemaRoot.java\n@@ -38,7 +38,7 @@\n   private final Map<String, FieldVector> fieldVectorsMap = new HashMap<>();\n \n   public VectorSchemaRoot(FieldVector parent) {\n-    this(parent.getField().getChildren(), parent.getChildrenFromFields(), parent.getAccessor().getValueCount());\n+    this(parent.getField().getChildren(), parent.getChildrenFromFields(), parent.getValueCount());\n   }\n \n   public VectorSchemaRoot(List<Field> fields, List<FieldVector> fieldVectors, int rowCount) {\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/VectorUnloader.java b/java/vector/src/main/java/org/apache/arrow/vector/VectorUnloader.java\nindex f8385a726..fd9677312 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/VectorUnloader.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/VectorUnloader.java\n@@ -22,7 +22,6 @@\n import java.util.List;\n \n import io.netty.buffer.ArrowBuf;\n-import org.apache.arrow.vector.ValueVector.Accessor;\n import org.apache.arrow.vector.schema.ArrowFieldNode;\n import org.apache.arrow.vector.schema.ArrowRecordBatch;\n import org.apache.arrow.vector.schema.ArrowVectorType;\n@@ -53,8 +52,7 @@ public ArrowRecordBatch getRecordBatch() {\n   }\n \n   private void appendNodes(FieldVector vector, List<ArrowFieldNode> nodes, List<ArrowBuf> buffers) {\n-    Accessor accessor = vector.getAccessor();\n-    nodes.add(new ArrowFieldNode(accessor.getValueCount(), includeNullCount ? accessor.getNullCount() : -1));\n+    nodes.add(new ArrowFieldNode(vector.getValueCount(), includeNullCount ? vector.getNullCount() : -1));\n     List<ArrowBuf> fieldBuffers = vector.getFieldBuffers();\n     List<ArrowVectorType> expectedBuffers = vector.getField().getTypeLayout().getVectorTypes();\n     if (fieldBuffers.size() != expectedBuffers.size()) {\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/ZeroVector.java b/java/vector/src/main/java/org/apache/arrow/vector/ZeroVector.java\nindex 5ac00375f..3cc93a2a3 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/ZeroVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/ZeroVector.java\n@@ -259,4 +259,19 @@ public ArrowBuf getDataBuffer() {\n   public ArrowBuf getOffsetBuffer() {\n     throw new UnsupportedOperationException();\n   }\n+\n+  @Override\n+  public int getValueCount() { return 0; }\n+\n+  @Override\n+  public void setValueCount(int valueCount) { }\n+\n+  @Override\n+  public Object getObject(int index) { return null; }\n+\n+  @Override\n+  public int getNullCount() { return 0; }\n+\n+  @Override\n+  public boolean isNull(int index) { return false; }\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/AbstractMapVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/AbstractMapVector.java\nindex 26b0f9058..1b20b09d8 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/AbstractMapVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/AbstractMapVector.java\n@@ -141,8 +141,8 @@ public void reAlloc() {\n   }\n \n   private boolean nullFilled(ValueVector vector) {\n-    for (int r = 0; r < vector.getAccessor().getValueCount(); r++) {\n-      if (!vector.getAccessor().isNull(r)) {\n+    for (int r = 0; r < vector.getValueCount(); r++) {\n+      if (!vector.isNull(r)) {\n         return false;\n       }\n     }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/BaseRepeatedValueVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/BaseRepeatedValueVector.java\nindex 8e2877f89..4648d0789 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/BaseRepeatedValueVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/BaseRepeatedValueVector.java\n@@ -6,9 +6,9 @@\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- *\n+ * <p>\n  * http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * <p>\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -21,6 +21,7 @@\n import java.util.Collections;\n import java.util.Iterator;\n \n+import org.apache.arrow.memory.BaseAllocator;\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.vector.AddOrGetResult;\n import org.apache.arrow.vector.BaseValueVector;\n@@ -31,6 +32,7 @@\n import org.apache.arrow.vector.types.pojo.ArrowType.ArrowTypeID;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n \n import com.google.common.base.Preconditions;\n@@ -41,12 +43,14 @@\n public abstract class BaseRepeatedValueVector extends BaseValueVector implements RepeatedValueVector {\n \n   public final static FieldVector DEFAULT_DATA_VECTOR = ZeroVector.INSTANCE;\n-  public final static String OFFSETS_VECTOR_NAME = \"$offsets$\";\n   public final static String DATA_VECTOR_NAME = \"$data$\";\n \n-  protected final UInt4Vector offsets;\n+  public final static byte OFFSET_WIDTH = 4;\n+  protected ArrowBuf offsetBuffer;\n   protected FieldVector vector;\n   protected final CallBack callBack;\n+  protected int valueCount;\n+  protected int offsetAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n \n   protected BaseRepeatedValueVector(String name, BufferAllocator allocator, CallBack callBack) {\n     this(name, allocator, DEFAULT_DATA_VECTOR, callBack);\n@@ -54,42 +58,72 @@ protected BaseRepeatedValueVector(String name, BufferAllocator allocator, CallBa\n \n   protected BaseRepeatedValueVector(String name, BufferAllocator allocator, FieldVector vector, CallBack callBack) {\n     super(name, allocator);\n-    this.offsets = new UInt4Vector(OFFSETS_VECTOR_NAME, allocator);\n+    this.offsetBuffer = allocator.getEmpty();\n     this.vector = Preconditions.checkNotNull(vector, \"data vector cannot be null\");\n     this.callBack = callBack;\n+    this.valueCount = 0;\n   }\n \n   @Override\n   public boolean allocateNewSafe() {\n-    /* boolean to keep track if all the memory allocation were successful\n-     * Used in the case of composite vectors when we need to allocate multiple\n-     * buffers for multiple vectors. If one of the allocations failed we need to\n-     * clear all the memory that we allocated\n-     */\n-    boolean success = false;\n+    boolean dataAlloc = false;\n     try {\n-      if (!offsets.allocateNewSafe()) {\n-        return false;\n-      }\n-      success = vector.allocateNewSafe();\n+      allocateOffsetBuffer(offsetAllocationSizeInBytes);\n+      dataAlloc = vector.allocateNewSafe();\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+      return false;\n     } finally {\n-      if (!success) {\n+      if (!dataAlloc) {\n         clear();\n       }\n     }\n-    offsets.zeroVector();\n-    return success;\n+    return dataAlloc;\n+  }\n+\n+  protected void allocateOffsetBuffer(final long size) {\n+    final int curSize = (int) size;\n+    offsetBuffer = allocator.buffer(curSize);\n+    offsetBuffer.readerIndex(0);\n+    offsetAllocationSizeInBytes = curSize;\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n   }\n \n   @Override\n   public void reAlloc() {\n-    offsets.reAlloc();\n+    reallocOffsetBuffer();\n     vector.reAlloc();\n   }\n \n+  protected void reallocOffsetBuffer() {\n+    final int currentBufferCapacity = offsetBuffer.capacity();\n+    long baseSize = offsetAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, offsetBuffer, 0, currentBufferCapacity);\n+    final int halfNewCapacity = newBuf.capacity() / 2;\n+    newBuf.setZero(halfNewCapacity, halfNewCapacity);\n+    offsetBuffer.release(1);\n+    offsetBuffer = newBuf;\n+    offsetAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n   @Override\n+  @Deprecated\n   public UInt4Vector getOffsetVector() {\n-    return offsets;\n+    throw new UnsupportedOperationException(\"There is no inner offset vector\");\n   }\n \n   @Override\n@@ -99,25 +133,29 @@ public FieldVector getDataVector() {\n \n   @Override\n   public void setInitialCapacity(int numRecords) {\n-    offsets.setInitialCapacity(numRecords + 1);\n+    offsetAllocationSizeInBytes = (numRecords + 1) * OFFSET_WIDTH;\n     vector.setInitialCapacity(numRecords * RepeatedValueVector.DEFAULT_REPEAT_PER_RECORD);\n   }\n \n   @Override\n   public int getValueCapacity() {\n-    final int offsetValueCapacity = Math.max(offsets.getValueCapacity() - 1, 0);\n+    final int offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n     if (vector == DEFAULT_DATA_VECTOR) {\n       return offsetValueCapacity;\n     }\n     return Math.min(vector.getValueCapacity(), offsetValueCapacity);\n   }\n \n+  protected int getOffsetBufferValueCapacity() {\n+    return (int) ((offsetBuffer.capacity() * 1.0) / OFFSET_WIDTH);\n+  }\n+\n   @Override\n   public int getBufferSize() {\n-    if (getAccessor().getValueCount() == 0) {\n+    if (getValueCount() == 0) {\n       return 0;\n     }\n-    return offsets.getBufferSize() + vector.getBufferSize();\n+    return ((valueCount + 1) * OFFSET_WIDTH) + vector.getBufferSize();\n   }\n \n   @Override\n@@ -126,7 +164,7 @@ public int getBufferSizeFor(int valueCount) {\n       return 0;\n     }\n \n-    return offsets.getBufferSizeFor(valueCount + 1) + vector.getBufferSizeFor(valueCount);\n+    return ((valueCount + 1) * OFFSET_WIDTH) + vector.getBufferSizeFor(valueCount);\n   }\n \n   @Override\n@@ -136,14 +174,21 @@ public int getBufferSizeFor(int valueCount) {\n \n   @Override\n   public void clear() {\n-    offsets.clear();\n+    offsetBuffer = releaseBuffer(offsetBuffer);\n     vector.clear();\n+    valueCount = 0;\n     super.clear();\n   }\n \n   @Override\n   public ArrowBuf[] getBuffers(boolean clear) {\n-    final ArrowBuf[] buffers = ObjectArrays.concat(offsets.getBuffers(false), vector.getBuffers(false), ArrowBuf.class);\n+    final ArrowBuf[] buffers;\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = ObjectArrays.concat(new ArrowBuf[]{offsetBuffer}, vector.getBuffers(false),\n+              ArrowBuf.class);\n+    }\n     if (clear) {\n       for (ArrowBuf buffer : buffers) {\n         buffer.retain();\n@@ -167,15 +212,15 @@ public int size() {\n       // returned vector must have the same field\n       created = true;\n       if (callBack != null &&\n-          // not a schema change if changing from ZeroVector to ZeroVector\n-          (fieldType.getType().getTypeID() != ArrowTypeID.Null)) {\n+              // not a schema change if changing from ZeroVector to ZeroVector\n+              (fieldType.getType().getTypeID() != ArrowTypeID.Null)) {\n         callBack.doWork();\n       }\n     }\n \n     if (vector.getField().getType().getTypeID() != fieldType.getType().getTypeID()) {\n       final String msg = String.format(\"Inner vector type mismatch. Requested type: [%s], actual type: [%s]\",\n-          fieldType.getType().getTypeID(), vector.getField().getType().getTypeID());\n+              fieldType.getType().getTypeID(), vector.getField().getType().getTypeID());\n       throw new SchemaChangeRuntimeException(msg);\n     }\n \n@@ -187,54 +232,61 @@ protected void replaceDataVector(FieldVector v) {\n     vector = v;\n   }\n \n-  public abstract class BaseRepeatedAccessor extends BaseValueVector.BaseAccessor implements RepeatedAccessor {\n \n-    @Override\n-    public int getValueCount() {\n-      return Math.max(offsets.getAccessor().getValueCount() - 1, 0);\n-    }\n+  @Override\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n \n-    @Override\n-    public int getInnerValueCount() {\n-      return vector.getAccessor().getValueCount();\n-    }\n+  /* returns the value count for inner data vector for this list vector */\n+  public int getInnerValueCount() {\n+    return vector.getValueCount();\n+  }\n \n-    @Override\n-    public int getInnerValueCountAt(int index) {\n-      return offsets.getAccessor().get(index + 1) - offsets.getAccessor().get(index);\n-    }\n \n-    @Override\n-    public boolean isNull(int index) {\n-      return false;\n-    }\n+  /* returns the value count for inner data vector at a particular index */\n+  public int getInnerValueCountAt(int index) {\n+    return offsetBuffer.getInt((index + 1) * OFFSET_WIDTH) -\n+            offsetBuffer.getInt(index * OFFSET_WIDTH);\n+  }\n \n-    @Override\n-    public boolean isEmpty(int index) {\n-      return false;\n-    }\n+  public boolean isNull(int index) {\n+    return false;\n   }\n \n-  public abstract class BaseRepeatedMutator extends BaseValueVector.BaseMutator implements RepeatedMutator {\n+  public boolean isEmpty(int index) {\n+    return false;\n+  }\n \n-    @Override\n-    public int startNewValue(int index) {\n-      while (offsets.getValueCapacity() <= index) {\n-        offsets.reAlloc();\n-      }\n-      int offset = offsets.getAccessor().get(index);\n-      offsets.getMutator().setSafe(index + 1, offset);\n-      setValueCount(index + 1);\n-      return offset;\n+  public int startNewValue(int index) {\n+    while (index >= getOffsetBufferValueCapacity()) {\n+      reallocOffsetBuffer();\n     }\n+    int offset = offsetBuffer.getInt(index * OFFSET_WIDTH);\n+    offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, offset);\n+    setValueCount(index + 1);\n+    return offset;\n+  }\n \n-    @Override\n-    public void setValueCount(int valueCount) {\n-      // TODO: populate offset end points\n-      offsets.getMutator().setValueCount(valueCount == 0 ? 0 : valueCount + 1);\n-      final int childValueCount = valueCount == 0 ? 0 : offsets.getAccessor().get(valueCount);\n-      vector.getMutator().setValueCount(childValueCount);\n+  public void setValueCount(int valueCount) {\n+    this.valueCount = valueCount;\n+    while (valueCount > getOffsetBufferValueCapacity()) {\n+      reallocOffsetBuffer();\n     }\n+    final int childValueCount = valueCount == 0 ? 0 :\n+            offsetBuffer.getInt(valueCount * OFFSET_WIDTH);\n+    vector.setValueCount(childValueCount);\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public RepeatedAccessor getAccessor() {\n+    throw new UnsupportedOperationException(\"Accessor is not supported for reading from LIST.\");\n   }\n \n+  @Override\n+  @Deprecated\n+  public RepeatedMutator getMutator() {\n+    throw new UnsupportedOperationException(\"Mutator is not supported for writing to LIST\");\n+  }\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/FixedSizeListVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/FixedSizeListVector.java\nindex b3be37541..6713b1c78 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/FixedSizeListVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/FixedSizeListVector.java\n@@ -1,5 +1,4 @@\n-/*******************************************************************************\n-\n+/**\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n@@ -7,41 +6,32 @@\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- *\n+ * <p>\n  * http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * <p>\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n- ******************************************************************************/\n+ */\n \n package org.apache.arrow.vector.complex;\n \n import static java.util.Collections.singletonList;\n import static org.apache.arrow.vector.complex.BaseRepeatedValueVector.DATA_VECTOR_NAME;\n \n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Objects;\n+import java.util.*;\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ObjectArrays;\n \n import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BaseAllocator;\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.memory.OutOfMemoryException;\n-import org.apache.arrow.vector.AddOrGetResult;\n-import org.apache.arrow.vector.BaseDataValueVector;\n-import org.apache.arrow.vector.BaseValueVector;\n-import org.apache.arrow.vector.BitVector;\n-import org.apache.arrow.vector.BufferBacked;\n-import org.apache.arrow.vector.FieldVector;\n-import org.apache.arrow.vector.ValueVector;\n-import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.*;\n import org.apache.arrow.vector.complex.impl.UnionFixedSizeListReader;\n import org.apache.arrow.vector.schema.ArrowFieldNode;\n import org.apache.arrow.vector.types.Types.MinorType;\n@@ -49,10 +39,7 @@\n import org.apache.arrow.vector.types.pojo.DictionaryEncoding;\n import org.apache.arrow.vector.types.pojo.Field;\n import org.apache.arrow.vector.types.pojo.FieldType;\n-import org.apache.arrow.vector.util.CallBack;\n-import org.apache.arrow.vector.util.JsonStringArrayList;\n-import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n-import org.apache.arrow.vector.util.TransferPair;\n+import org.apache.arrow.vector.util.*;\n \n public class FixedSizeListVector extends BaseValueVector implements FieldVector, PromotableVector {\n \n@@ -62,15 +49,13 @@ public static FixedSizeListVector empty(String name, int size, BufferAllocator a\n   }\n \n   private FieldVector vector;\n-  private final BitVector bits;\n+  private ArrowBuf validityBuffer;\n   private final int listSize;\n   private final FieldType fieldType;\n-  private final List<BufferBacked> innerVectors;\n \n   private UnionFixedSizeListReader reader;\n-\n-  private Mutator mutator = new Mutator();\n-  private Accessor accessor = new Accessor();\n+  private int valueCount;\n+  private int validityAllocationSizeInBytes;\n \n   // deprecated, use FieldType or static constructor instead\n   @Deprecated\n@@ -87,13 +72,14 @@ public FixedSizeListVector(String name,\n                              FieldType fieldType,\n                              CallBack schemaChangeCallback) {\n     super(name, allocator);\n-    this.bits = new BitVector(\"$bits$\", allocator);\n+    this.validityBuffer = allocator.getEmpty();\n     this.vector = ZeroVector.INSTANCE;\n     this.fieldType = fieldType;\n     this.listSize = ((ArrowType.FixedSizeList) fieldType.getType()).getListSize();\n     Preconditions.checkArgument(listSize > 0, \"list size must be positive\");\n-    this.innerVectors = Collections.singletonList((BufferBacked) bits);\n     this.reader = new UnionFixedSizeListReader(this);\n+    this.valueCount = 0;\n+    this.validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n   }\n \n   @Override\n@@ -131,27 +117,49 @@ public void initializeChildrenFromFields(List<Field> children) {\n \n   @Override\n   public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n-    BaseDataValueVector.load(fieldNode, innerVectors, ownBuffers);\n+    if (ownBuffers.size() != 1) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 1 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+\n+    validityBuffer.release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    valueCount = fieldNode.getLength();\n+\n+    validityAllocationSizeInBytes = validityBuffer.capacity();\n   }\n \n   @Override\n   public List<ArrowBuf> getFieldBuffers() {\n-    return BaseDataValueVector.unload(innerVectors);\n+    List<ArrowBuf> result = new ArrayList<>(1);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+\n+    return result;\n+  }\n+\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n   }\n \n   @Override\n+  @Deprecated\n   public List<BufferBacked> getFieldInnerVectors() {\n-    return innerVectors;\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n   }\n \n   @Override\n+  @Deprecated\n   public Accessor getAccessor() {\n-    return accessor;\n+    throw new UnsupportedOperationException(\"Accessor is not supported for reading from vector\");\n   }\n \n   @Override\n+  @Deprecated\n   public Mutator getMutator() {\n-    return mutator;\n+    throw new UnsupportedOperationException(\"Mutator is not supported for writing to vector\");\n   }\n \n   @Override\n@@ -161,7 +169,9 @@ public UnionFixedSizeListReader getReader() {\n \n   @Override\n   public void allocateNew() throws OutOfMemoryException {\n-    allocateNewSafe();\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory\");\n+    }\n   }\n \n   @Override\n@@ -173,31 +183,65 @@ public boolean allocateNewSafe() {\n      */\n     boolean success = false;\n     try {\n-      success = bits.allocateNewSafe() && vector.allocateNewSafe();\n+      /* we are doing a new allocation -- release the current buffers */\n+      clear();\n+      /* allocate validity buffer */\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      success = vector.allocateNewSafe();\n     } finally {\n       if (!success) {\n         clear();\n+        return false;\n       }\n     }\n-    if (success) {\n-      bits.zeroVector();\n-    }\n-    return success;\n+\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n   }\n \n   @Override\n   public void reAlloc() {\n-    bits.reAlloc();\n+    reallocValidityBuffer();\n     vector.reAlloc();\n   }\n \n+  private void reallocValidityBuffer() {\n+    final int currentBufferCapacity = validityBuffer.capacity();\n+    long baseSize = validityAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setZero(0, newBuf.capacity());\n+    newBuf.setBytes(0, validityBuffer, 0, currentBufferCapacity);\n+    validityBuffer.release(1);\n+    validityBuffer = newBuf;\n+    validityAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n   public FieldVector getDataVector() {\n     return vector;\n   }\n \n   @Override\n   public void setInitialCapacity(int numRecords) {\n-    bits.setInitialCapacity(numRecords);\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n     vector.setInitialCapacity(numRecords * listSize);\n   }\n \n@@ -206,15 +250,15 @@ public int getValueCapacity() {\n     if (vector == ZeroVector.INSTANCE) {\n       return 0;\n     }\n-    return vector.getValueCapacity() / listSize;\n+    return Math.min(vector.getValueCapacity() / listSize, getValidityBufferValueCapacity());\n   }\n \n   @Override\n   public int getBufferSize() {\n-    if (accessor.getValueCount() == 0) {\n+    if (getValueCount() == 0) {\n       return 0;\n     }\n-    return bits.getBufferSize() + vector.getBufferSize();\n+    return getValidityBufferSizeFromCount(valueCount) + vector.getBufferSize();\n   }\n \n   @Override\n@@ -222,7 +266,8 @@ public int getBufferSizeFor(int valueCount) {\n     if (valueCount == 0) {\n       return 0;\n     }\n-    return bits.getBufferSizeFor(valueCount) + vector.getBufferSizeFor(valueCount * listSize);\n+    return getValidityBufferSizeFromCount(valueCount) +\n+            vector.getBufferSizeFor(valueCount * listSize);\n   }\n \n   @Override\n@@ -232,14 +277,22 @@ public int getBufferSizeFor(int valueCount) {\n \n   @Override\n   public void clear() {\n-    bits.clear();\n+    validityBuffer = releaseBuffer(validityBuffer);\n     vector.clear();\n+    valueCount = 0;\n     super.clear();\n   }\n \n   @Override\n   public ArrowBuf[] getBuffers(boolean clear) {\n-    final ArrowBuf[] buffers = ObjectArrays.concat(bits.getBuffers(false), vector.getBuffers(false), ArrowBuf.class);\n+    setReaderAndWriterIndex();\n+    final ArrowBuf[] buffers;\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = ObjectArrays.concat(new ArrowBuf[]{validityBuffer}, vector.getBuffers(false),\n+              ArrowBuf.class);\n+    }\n     if (clear) {\n       for (ArrowBuf buffer : buffers) {\n         buffer.retain();\n@@ -268,7 +321,7 @@ public int size() {\n     // returned vector must have the same field\n     if (!Objects.equals(vector.getField().getType(), type.getType())) {\n       final String msg = String.format(\"Inner vector type mismatch. Requested type: [%s], actual type: [%s]\",\n-          type.getType(), vector.getField().getType());\n+              type.getType(), vector.getField().getType());\n       throw new SchemaChangeRuntimeException(msg);\n     }\n \n@@ -295,7 +348,7 @@ public UnionVector promoteToUnion() {\n \n   @Override\n   public long getValidityBufferAddress() {\n-    return (bits.getDataBuffer().memoryAddress());\n+    return validityBuffer.memoryAddress();\n   }\n \n   @Override\n@@ -310,7 +363,7 @@ public long getOffsetBufferAddress() {\n \n   @Override\n   public ArrowBuf getValidityBuffer() {\n-    return (bits.getDataBuffer());\n+    return validityBuffer;\n   }\n \n   @Override\n@@ -323,52 +376,64 @@ public ArrowBuf getOffsetBuffer() {\n     throw new UnsupportedOperationException();\n   }\n \n-  public class Accessor extends BaseValueVector.BaseAccessor {\n-\n-    @Override\n-    public Object getObject(int index) {\n-      if (isNull(index)) {\n-        return null;\n-      }\n-      final List<Object> vals = new JsonStringArrayList<>(listSize);\n-      final ValueVector.Accessor valuesAccessor = vector.getAccessor();\n-      for (int i = 0; i < listSize; i++) {\n-        vals.add(valuesAccessor.getObject(index * listSize + i));\n-      }\n-      return vals;\n+  @Override\n+  public Object getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n     }\n-\n-    @Override\n-    public boolean isNull(int index) {\n-      return bits.getAccessor().get(index) == 0;\n+    final List<Object> vals = new JsonStringArrayList<>(listSize);\n+    for (int i = 0; i < listSize; i++) {\n+      vals.add(vector.getObject(index * listSize + i));\n     }\n+    return vals;\n+  }\n \n-    @Override\n-    public int getNullCount() {\n-      return bits.getAccessor().getNullCount();\n-    }\n+  public boolean isNull(int index) {\n+    return (isSet(index) == 0);\n+  }\n \n-    @Override\n-    public int getValueCount() {\n-      return bits.getAccessor().getValueCount();\n-    }\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return Long.bitCount(b & (1L << bitIndex));\n   }\n \n-  public class Mutator extends BaseValueVector.BaseMutator {\n+  @Override\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  @Override\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n \n-    public void setNull(int index) {\n-      bits.getMutator().setSafe(index, 0);\n+  private int getValidityBufferValueCapacity() {\n+    return (int) (validityBuffer.capacity() * 8L);\n+  }\n+\n+  public void setNull(int index) {\n+    while (index >= getValidityBufferValueCapacity()) {\n+      reallocValidityBuffer();\n     }\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n \n-    public void setNotNull(int index) {\n-      bits.getMutator().setSafe(index, 1);\n+  public void setNotNull(int index) {\n+    while (index >= getValidityBufferValueCapacity()) {\n+      reallocValidityBuffer();\n     }\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+  }\n \n-    @Override\n-    public void setValueCount(int valueCount) {\n-      bits.getMutator().setValueCount(valueCount);\n-      vector.getMutator().setValueCount(valueCount * listSize);\n+  @Override\n+  public void setValueCount(int valueCount) {\n+    this.valueCount = valueCount;\n+    while (valueCount > getValidityBufferValueCapacity()) {\n+      reallocValidityBuffer();\n     }\n+    vector.setValueCount(valueCount * listSize);\n   }\n \n   @Override\n@@ -389,7 +454,7 @@ public TransferPair makeTransferPair(ValueVector target) {\n   private class TransferImpl implements TransferPair {\n \n     FixedSizeListVector to;\n-    TransferPair pairs[] = new TransferPair[2];\n+    TransferPair dataPair;\n \n     public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n       this(new FixedSizeListVector(name, allocator, fieldType, callBack));\n@@ -398,19 +463,21 @@ public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n     public TransferImpl(FixedSizeListVector to) {\n       this.to = to;\n       to.addOrGetVector(vector.getField().getFieldType());\n-      pairs[0] = bits.makeTransferPair(to.bits);\n-      pairs[1] = vector.makeTransferPair(to.vector);\n+      dataPair = vector.makeTransferPair(to.vector);\n     }\n \n     @Override\n     public void transfer() {\n-      for (TransferPair pair : pairs) {\n-        pair.transfer();\n-      }\n+      to.clear();\n+      dataPair.transfer();\n+      to.validityBuffer = validityBuffer.transferOwnership(to.allocator).buffer;\n+      to.setValueCount(valueCount);\n+      clear();\n     }\n \n     @Override\n     public void splitAndTransfer(int startIndex, int length) {\n+      to.clear();\n       to.allocateNew();\n       for (int i = 0; i < length; i++) {\n         copyValueSafe(startIndex + i, i);\n@@ -423,12 +490,15 @@ public ValueVector getTo() {\n     }\n \n     @Override\n-    public void copyValueSafe(int from, int to) {\n-      pairs[0].copyValueSafe(from, to);\n-      int fromOffset = from * listSize;\n-      int toOffset = to * listSize;\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      while (toIndex >= to.getValueCapacity()) {\n+        to.reAlloc();\n+      }\n+      BitVectorHelper.setValidityBit(to.validityBuffer, toIndex, isSet(fromIndex));\n+      int fromOffset = fromIndex * listSize;\n+      int toOffset = toIndex * listSize;\n       for (int i = 0; i < listSize; i++) {\n-        pairs[1].copyValueSafe(fromOffset + i, toOffset + i);\n+        dataPair.copyValueSafe(fromOffset + i, toOffset + i);\n       }\n     }\n   }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java\nindex ea28a6061..afe86a692 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java\n@@ -1,5 +1,4 @@\n-/*******************************************************************************\n-\n+/**\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n@@ -7,39 +6,37 @@\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- *\n+ * <p>\n  * http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * <p>\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n- ******************************************************************************/\n+ */\n \n package org.apache.arrow.vector.complex;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n import static java.util.Collections.singletonList;\n \n-import java.util.Arrays;\n-import java.util.Collections;\n+import java.util.ArrayList;\n import java.util.List;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ObjectArrays;\n \n import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BaseAllocator;\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.memory.OutOfMemoryException;\n import org.apache.arrow.vector.AddOrGetResult;\n-import org.apache.arrow.vector.BaseDataValueVector;\n-import org.apache.arrow.vector.BitVector;\n import org.apache.arrow.vector.BufferBacked;\n import org.apache.arrow.vector.FieldVector;\n-import org.apache.arrow.vector.UInt4Vector;\n import org.apache.arrow.vector.ValueVector;\n import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.BitVectorHelper;\n import org.apache.arrow.vector.complex.impl.ComplexCopier;\n import org.apache.arrow.vector.complex.impl.UnionListReader;\n import org.apache.arrow.vector.complex.impl.UnionListWriter;\n@@ -53,6 +50,7 @@\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.CallBack;\n import org.apache.arrow.vector.util.JsonStringArrayList;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n import org.apache.arrow.vector.util.TransferPair;\n \n public class ListVector extends BaseRepeatedValueVector implements FieldVector, PromotableVector {\n@@ -61,14 +59,12 @@ public static ListVector empty(String name, BufferAllocator allocator) {\n     return new ListVector(name, allocator, FieldType.nullable(ArrowType.List.INSTANCE), null);\n   }\n \n-  final UInt4Vector offsets;\n-  final BitVector bits;\n-  private final List<BufferBacked> innerVectors;\n-  private Mutator mutator = new Mutator();\n-  private Accessor accessor = new Accessor();\n+  protected ArrowBuf validityBuffer;\n   private UnionListReader reader;\n   private CallBack callBack;\n   private final FieldType fieldType;\n+  private int validityAllocationSizeInBytes;\n+  private int lastSet;\n \n   // deprecated, use FieldType or static constructor instead\n   @Deprecated\n@@ -84,12 +80,12 @@ public ListVector(String name, BufferAllocator allocator, DictionaryEncoding dic\n \n   public ListVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n     super(name, allocator, callBack);\n-    this.bits = new BitVector(\"$bits$\", allocator);\n-    this.offsets = getOffsetVector();\n-    this.innerVectors = Collections.unmodifiableList(Arrays.<BufferBacked>asList(bits, offsets));\n+    this.validityBuffer = allocator.getEmpty();\n     this.reader = new UnionListReader(this);\n     this.fieldType = checkNotNull(fieldType);\n     this.callBack = callBack;\n+    this.validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    this.lastSet = 0;\n   }\n \n   @Override\n@@ -111,44 +107,176 @@ public void initializeChildrenFromFields(List<Field> children) {\n     return singletonList(getDataVector());\n   }\n \n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n   @Override\n   public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n-    // variable width values: truncate offset vector buffer to size (#1)\n-    org.apache.arrow.vector.BaseDataValueVector.truncateBufferBasedOnSize(ownBuffers, 1, offsets.getBufferSizeFor(fieldNode.getLength() + 1));\n-    BaseDataValueVector.load(fieldNode, getFieldInnerVectors(), ownBuffers);\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+\n+    validityBuffer.release();\n+    validityBuffer = bitBuffer.retain(allocator);\n+    offsetBuffer.release();\n+    offsetBuffer = offBuffer.retain(allocator);\n+\n+    validityAllocationSizeInBytes = validityBuffer.capacity();\n+    offsetAllocationSizeInBytes = offsetBuffer.capacity();\n+\n     lastSet = fieldNode.getLength();\n+    valueCount = fieldNode.getLength();\n   }\n \n+  /**\n+   * Get the buffers belonging to this vector\n+   * @return the inner buffers.\n+   */\n   @Override\n   public List<ArrowBuf> getFieldBuffers() {\n-    return BaseDataValueVector.unload(getFieldInnerVectors());\n+    List<ArrowBuf> result = new ArrayList<>(2);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+    } else {\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+    }\n   }\n \n   @Override\n+  @Deprecated\n   public List<BufferBacked> getFieldInnerVectors() {\n-    return innerVectors;\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n   }\n \n   public UnionListWriter getWriter() {\n     return new UnionListWriter(this);\n   }\n \n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n   @Override\n   public void allocateNew() throws OutOfMemoryException {\n-    super.allocateNewSafe();\n-    bits.allocateNewSafe();\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  public boolean allocateNewSafe() {\n+    boolean success = false;\n+    try {\n+      /* we are doing a new allocation -- release the current buffers */\n+      clear();\n+      /* allocate validity buffer */\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      /* allocate offset and data buffer */\n+      success = super.allocateNewSafe();\n+    } finally {\n+      if (!success) {\n+        clear();\n+        return false;\n+      }\n+    }\n+    return true;\n   }\n \n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+\n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n   @Override\n   public void reAlloc() {\n+    /* reallocate the validity buffer */\n+    reallocValidityBuffer();\n+    /* reallocate the offset and data */\n     super.reAlloc();\n-    bits.reAlloc();\n   }\n \n+  private void reallocValidityAndOffsetBuffers() {\n+    reallocOffsetBuffer();\n+    reallocValidityBuffer();\n+  }\n+\n+  private void reallocValidityBuffer() {\n+    final int currentBufferCapacity = validityBuffer.capacity();\n+    long baseSize = validityAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, validityBuffer, 0, currentBufferCapacity);\n+    final int halfNewCapacity = newBuf.capacity() / 2;\n+    newBuf.setZero(halfNewCapacity, halfNewCapacity);\n+    validityBuffer.release(1);\n+    validityBuffer = newBuf;\n+    validityAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, ListVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n   public void copyFromSafe(int inIndex, int outIndex, ListVector from) {\n     copyFrom(inIndex, outIndex, from);\n   }\n \n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n   public void copyFrom(int inIndex, int outIndex, ListVector from) {\n     FieldReader in = from.getReader();\n     in.setPosition(inIndex);\n@@ -157,6 +285,10 @@ public void copyFrom(int inIndex, int outIndex, ListVector from) {\n     ComplexCopier.copy(in, out);\n   }\n \n+  /**\n+   * Get the inner data vector for this list vector\n+   * @return data vector\n+   */\n   @Override\n   public FieldVector getDataVector() {\n     return vector;\n@@ -179,7 +311,7 @@ public TransferPair makeTransferPair(ValueVector target) {\n \n   @Override\n   public long getValidityBufferAddress() {\n-    return (bits.getDataBuffer().memoryAddress());\n+    return (validityBuffer.memoryAddress());\n   }\n \n   @Override\n@@ -189,11 +321,13 @@ public long getDataBufferAddress() {\n \n   @Override\n   public long getOffsetBufferAddress() {\n-    return (offsets.getDataBuffer().memoryAddress());\n+    return (offsetBuffer.memoryAddress());\n   }\n \n   @Override\n-  public ArrowBuf getValidityBuffer() { return bits.getDataBuffer(); }\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n \n   @Override\n   public ArrowBuf getDataBuffer() {\n@@ -201,17 +335,15 @@ public ArrowBuf getDataBuffer() {\n   }\n \n   @Override\n-  public ArrowBuf getOffsetBuffer() { return offsets.getDataBuffer(); }\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n \n   private class TransferImpl implements TransferPair {\n \n     ListVector to;\n-    TransferPair bitsTransferPair;\n-    TransferPair offsetsTransferPair;\n     TransferPair dataTransferPair;\n \n-    TransferPair[] pairs;\n-\n     public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n       this(new ListVector(name, allocator, fieldType, callBack));\n     }\n@@ -219,39 +351,112 @@ public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n     public TransferImpl(ListVector to) {\n       this.to = to;\n       to.addOrGetVector(vector.getField().getFieldType());\n-      offsetsTransferPair = offsets.makeTransferPair(to.offsets);\n-      bitsTransferPair = bits.makeTransferPair(to.bits);\n       if (to.getDataVector() instanceof ZeroVector) {\n         to.addOrGetVector(vector.getField().getFieldType());\n       }\n       dataTransferPair = getDataVector().makeTransferPair(to.getDataVector());\n-      pairs = new TransferPair[] {bitsTransferPair, offsetsTransferPair, dataTransferPair};\n     }\n \n+    /**\n+     * Transfer this vector'data to another vector. The memory associated\n+     * with this vector is transferred to the allocator of target vector\n+     * for accounting and management purposes.\n+     */\n     @Override\n     public void transfer() {\n-      for (TransferPair pair : pairs) {\n-        pair.transfer();\n-      }\n+      to.clear();\n+      dataTransferPair.transfer();\n+      to.validityBuffer = validityBuffer.transferOwnership(to.allocator).buffer;\n+      to.offsetBuffer = offsetBuffer.transferOwnership(to.allocator).buffer;\n       to.lastSet = lastSet;\n+      if (valueCount > 0) {\n+        to.setValueCount(valueCount);\n+      }\n+      clear();\n     }\n \n+    /**\n+     * Slice this vector at desired index and length and transfer the\n+     * corresponding data to the target vector.\n+     * @param startIndex start position of the split in source vector.\n+     * @param length length of the split.\n+     */\n     @Override\n     public void splitAndTransfer(int startIndex, int length) {\n-      UInt4Vector.Accessor offsetVectorAccessor = ListVector.this.offsets.getAccessor();\n-      final int startPoint = offsetVectorAccessor.get(startIndex);\n-      final int sliceLength = offsetVectorAccessor.get(startIndex + length) - startPoint;\n+      final int startPoint = offsetBuffer.getInt(startIndex * OFFSET_WIDTH);\n+      final int sliceLength = offsetBuffer.getInt((startIndex + length) * OFFSET_WIDTH) - startPoint;\n       to.clear();\n-      to.offsets.allocateNew(length + 1);\n-      offsetVectorAccessor = ListVector.this.offsets.getAccessor();\n-      final UInt4Vector.Mutator targetOffsetVectorMutator = to.offsets.getMutator();\n+      to.allocateOffsetBuffer((length + 1) * OFFSET_WIDTH);\n+      /* splitAndTransfer offset buffer */\n       for (int i = 0; i < length + 1; i++) {\n-        targetOffsetVectorMutator.set(i, offsetVectorAccessor.get(startIndex + i) - startPoint);\n+        final int relativeOffset = offsetBuffer.getInt((startIndex + i) * OFFSET_WIDTH) - startPoint;\n+        to.offsetBuffer.setInt(i * OFFSET_WIDTH, relativeOffset);\n       }\n-      bitsTransferPair.splitAndTransfer(startIndex, length);\n+      /* splitAndTransfer validity buffer */\n+      splitAndTransferValidityBuffer(startIndex, length, to);\n+      /* splitAndTransfer data buffer */\n       dataTransferPair.splitAndTransfer(startPoint, sliceLength);\n       to.lastSet = length;\n-      to.mutator.setValueCount(length);\n+      to.setValueCount(length);\n+    }\n+\n+    /*\n+     * transfer the validity.\n+     */\n+    private void splitAndTransferValidityBuffer(int startIndex, int length, ListVector target) {\n+      assert startIndex + length <= valueCount;\n+      int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+      int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+      int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+      int offset = startIndex % 8;\n+\n+      if (length > 0) {\n+        if (offset == 0) {\n+          // slice\n+          if (target.validityBuffer != null) {\n+            target.validityBuffer.release();\n+          }\n+          target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+          target.validityBuffer.retain(1);\n+        } else {\n+          /* Copy data\n+           * When the first bit starts from the middle of a byte (offset != 0),\n+           * copy data from src BitVector.\n+           * Each byte in the target is composed by a part in i-th byte,\n+           * another part in (i+1)-th byte.\n+           */\n+          target.allocateValidityBuffer(byteSizeTarget);\n+\n+          for (int i = 0; i < byteSizeTarget - 1; i++) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer, firstByteSource + i, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer, firstByteSource + i + 1, offset);\n+\n+            target.validityBuffer.setByte(i, (b1 + b2));\n+          }\n+\n+          /* Copying the last piece is done in the following manner:\n+           * if the source vector has 1 or more bytes remaining, we copy\n+           * the last piece as a byte formed by shifting data\n+           * from the current byte and the next byte.\n+           *\n+           * if the source vector has no more bytes remaining\n+           * (we are at the last byte), we copy the last piece as a byte\n+           * by shifting data from the current byte.\n+           */\n+          if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget, offset);\n+\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+          } else {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+          }\n+        }\n+      }\n     }\n \n     @Override\n@@ -266,58 +471,29 @@ public void copyValueSafe(int from, int to) {\n   }\n \n   @Override\n-  public Accessor getAccessor() {\n-    return accessor;\n-  }\n-\n-  @Override\n-  public Mutator getMutator() {\n-    return mutator;\n-  }\n-\n-  @Override\n   public UnionListReader getReader() {\n     return reader;\n   }\n \n-  @Override\n-  public boolean allocateNewSafe() {\n-    /* boolean to keep track if all the memory allocation were successful\n-     * Used in the case of composite vectors when we need to allocate multiple\n-     * buffers for multiple vectors. If one of the allocations failed we need to\n-     * clear all the memory that we allocated\n-     */\n-    boolean success = false;\n-    try {\n-      if (!offsets.allocateNewSafe()) {\n-        return false;\n-      }\n-      success = vector.allocateNewSafe();\n-      success = success && bits.allocateNewSafe();\n-    } finally {\n-      if (!success) {\n-        clear();\n-      }\n-    }\n-    if (success) {\n-      offsets.zeroVector();\n-      bits.zeroVector();\n-    }\n-    return success;\n-  }\n-\n   public <T extends ValueVector> AddOrGetResult<T> addOrGetVector(FieldType fieldType) {\n     AddOrGetResult<T> result = super.addOrGetVector(fieldType);\n     reader = new UnionListReader(this);\n     return result;\n   }\n \n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector\n+   * @return size of underlying buffers.\n+   */\n   @Override\n   public int getBufferSize() {\n-    if (getAccessor().getValueCount() == 0) {\n+    if (valueCount == 0) {\n       return 0;\n     }\n-    return offsets.getBufferSize() + bits.getBufferSize() + vector.getBufferSize();\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    return offsetBufferSize + validityBufferSize + vector.getBufferSize();\n   }\n \n   @Override\n@@ -332,17 +508,33 @@ public MinorType getMinorType() {\n \n   @Override\n   public void clear() {\n-    offsets.clear();\n-    vector.clear();\n-    bits.clear();\n-    lastSet = 0;\n     super.clear();\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    lastSet = 0;\n   }\n \n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n   @Override\n   public ArrowBuf[] getBuffers(boolean clear) {\n-    final ArrowBuf[] buffers = ObjectArrays.concat(offsets.getBuffers(false), ObjectArrays.concat(bits.getBuffers(false),\n-        vector.getBuffers(false), ArrowBuf.class), ArrowBuf.class);\n+    setReaderAndWriterIndex();\n+    final ArrowBuf[] buffers;\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = ObjectArrays.concat(new ArrowBuf[]{offsetBuffer},\n+              ObjectArrays.concat(new ArrowBuf[]{validityBuffer},\n+                      vector.getBuffers(false), ArrowBuf.class), ArrowBuf.class);\n+    }\n     if (clear) {\n       for (ArrowBuf buffer : buffers) {\n         buffer.retain();\n@@ -363,86 +555,150 @@ public UnionVector promoteToUnion() {\n     return vector;\n   }\n \n-  private int lastSet = 0;\n+  /**\n+   * Get the element in the list vector at a particular index\n+   * @param index position of the element\n+   * @return Object at given position\n+   */\n+  @Override\n+  public Object getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    }\n+    final List<Object> vals = new JsonStringArrayList<>();\n+    final int start = offsetBuffer.getInt(index * OFFSET_WIDTH);\n+    final int end = offsetBuffer.getInt((index + 1) * OFFSET_WIDTH);\n+    final ValueVector vv = getDataVector();\n+    for (int i = start; i < end; i++) {\n+      vals.add(vv.getObject(i));\n+    }\n \n-  public class Accessor extends BaseRepeatedAccessor {\n+    return vals;\n+  }\n \n-    @Override\n-    public Object getObject(int index) {\n-      if (isNull(index)) {\n-        return null;\n-      }\n-      final List<Object> vals = new JsonStringArrayList<>();\n-      final UInt4Vector.Accessor offsetsAccessor = offsets.getAccessor();\n-      final int start = offsetsAccessor.get(index);\n-      final int end = offsetsAccessor.get(index + 1);\n-      final ValueVector.Accessor valuesAccessor = getDataVector().getAccessor();\n-      for (int i = start; i < end; i++) {\n-        vals.add(valuesAccessor.getObject(i));\n-      }\n-      return vals;\n-    }\n+  /**\n+   * Check if element at given index is null.\n+   *\n+   * @param index  position of element\n+   * @return true if element at given index is null, false otherwise\n+   */\n+  @Override\n+  public boolean isNull(int index) {\n+    return (isSet(index) == 0);\n+  }\n+\n+  /**\n+   * Same as {@link #isNull(int)}.\n+   *\n+   * @param index  position of element\n+   * @return 1 if element at given index is not null, 0 otherwise\n+   */\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return Long.bitCount(b & (1L << bitIndex));\n+  }\n+\n+  /**\n+   * Get the number of elements that are null in the vector\n+   *\n+   * @return the number of null elements.\n+   */\n+  @Override\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n \n-    @Override\n-    public boolean isNull(int index) {\n-      return bits.getAccessor().get(index) == 0;\n-    }\n+  /**\n+   * Get the current value capacity for the vector\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    return Math.min(getValidityBufferValueCapacity(), super.getValueCapacity());\n+  }\n \n-    @Override\n-    public int getNullCount() {\n-      return bits.getAccessor().getNullCount();\n-    }\n+  private int getValidityAndOffsetValueCapacity() {\n+    final int offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n+    return Math.min(offsetValueCapacity, getValidityBufferValueCapacity());\n   }\n \n-  public class Mutator extends BaseRepeatedMutator {\n-    public void setNotNull(int index) {\n-      bits.getMutator().setSafe(index, 1);\n-      lastSet = index + 1;\n-    }\n+  private int getValidityBufferValueCapacity() {\n+    return (int) (validityBuffer.capacity() * 8L);\n+  }\n \n-    @Override\n-    public int startNewValue(int index) {\n-      for (int i = lastSet; i <= index; i++) {\n-        offsets.getMutator().setSafe(i + 1, offsets.getAccessor().get(i));\n-      }\n-      setNotNull(index);\n-      lastSet = index + 1;\n-      return offsets.getAccessor().get(lastSet);\n+  public void setNotNull(int index) {\n+    while (index >= getValidityAndOffsetValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n     }\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    lastSet = index + 1;\n+  }\n \n-    /**\n-     * End the current value\n-     *\n-     * @param index index of the value to end\n-     * @param size  number of elements in the list that was written\n-     */\n-    public void endValue(int index, int size) {\n-      offsets.getMutator().set(index + 1, offsets.getAccessor().get(index + 1) + size);\n+  /**\n+   * Start a new value in the list vector\n+   *\n+   * @param index index of the value to start\n+   */\n+  @Override\n+  public int startNewValue(int index) {\n+    while (index >= getValidityAndOffsetValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n     }\n-\n-    @Override\n-    public void setValueCount(int valueCount) {\n-      // TODO: populate offset end points\n-      if (valueCount == 0) {\n-        offsets.getMutator().setValueCount(0);\n-      } else {\n-        for (int i = lastSet; i < valueCount; i++) {\n-          offsets.getMutator().setSafe(i + 1, offsets.getAccessor().get(i));\n-        }\n-        offsets.getMutator().setValueCount(valueCount + 1);\n-      }\n-      final int childValueCount = valueCount == 0 ? 0 : offsets.getAccessor().get(valueCount);\n-      vector.getMutator().setValueCount(childValueCount);\n-      bits.getMutator().setValueCount(valueCount);\n+    for (int i = lastSet; i <= index; i++) {\n+      final int currentOffset = offsetBuffer.getInt(i * OFFSET_WIDTH);\n+      offsetBuffer.setInt((i + 1) * OFFSET_WIDTH, currentOffset);\n     }\n-\n-    public void setLastSet(int value) {\n-      lastSet = value;\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    lastSet = index + 1;\n+    return offsetBuffer.getInt(lastSet * OFFSET_WIDTH);\n+  }\n+\n+  /**\n+   * End the current value\n+   *\n+   * @param index index of the value to end\n+   * @param size  number of elements in the list that was written\n+   */\n+  public void endValue(int index, int size) {\n+    final int currentOffset = offsetBuffer.getInt((index + 1) * OFFSET_WIDTH);\n+    offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, currentOffset + size);\n+  }\n+\n+  /**\n+   * Sets the value count for the vector\n+   *\n+   * @param valueCount   value count\n+   */\n+  @Override\n+  public void setValueCount(int valueCount) {\n+    this.valueCount = valueCount;\n+    if (valueCount > 0) {\n+      while (valueCount > getValidityAndOffsetValueCapacity()) {\n+        /* check if validity and offset buffers need to be re-allocated */\n+        reallocValidityAndOffsetBuffers();\n+      }\n+      for (int i = lastSet; i < valueCount; i++) {\n+        /* fill the holes with offsets */\n+        final int currentOffset = offsetBuffer.getInt(i * OFFSET_WIDTH);\n+        offsetBuffer.setInt((i + 1) * OFFSET_WIDTH, currentOffset);\n+      }\n     }\n+    /* valueCount for the data vector is the current end offset */\n+    final int childValueCount = (valueCount == 0) ? 0 :\n+            offsetBuffer.getInt(valueCount * OFFSET_WIDTH);\n+    /* set the value count of data vector and this will take care of\n+     * checking whether data buffer needs to be reallocated.\n+     */\n+    vector.setValueCount(childValueCount);\n+  }\n \n-    public int getLastSet() {\n-      return lastSet;\n-    }\n+  public void setLastSet(int value) {\n+    lastSet = value;\n   }\n \n+  public int getLastSet() {\n+    return lastSet;\n+  }\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\nindex f46635ad7..6089a6792 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\n@@ -35,9 +35,7 @@\n import io.netty.buffer.ArrowBuf;\n \n import org.apache.arrow.memory.BufferAllocator;\n-import org.apache.arrow.vector.BaseValueVector;\n-import org.apache.arrow.vector.FieldVector;\n-import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.*;\n import org.apache.arrow.vector.complex.impl.SingleMapReaderImpl;\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.ComplexHolder;\n@@ -58,8 +56,6 @@ public static MapVector empty(String name, BufferAllocator allocator) {\n   }\n \n   private final SingleMapReaderImpl reader = new SingleMapReaderImpl(this);\n-  private final Accessor accessor = new Accessor();\n-  private final Mutator mutator = new Mutator();\n   protected final FieldType fieldType;\n   public int valueCount;\n \n@@ -72,6 +68,7 @@ public MapVector(String name, BufferAllocator allocator, CallBack callBack) {\n   public MapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n     super(name, allocator, callBack);\n     this.fieldType = checkNotNull(fieldType);\n+    this.valueCount = 0;\n   }\n \n   @Override\n@@ -232,7 +229,7 @@ public void splitAndTransfer(int startIndex, int length) {\n       for (TransferPair p : pairs) {\n         p.splitAndTransfer(startIndex, length);\n       }\n-      to.getMutator().setValueCount(length);\n+      to.setValueCount(length);\n     }\n   }\n \n@@ -257,63 +254,54 @@ public int compare(@Nullable ValueVector left, @Nullable ValueVector right) {\n \n   @Override\n   public Accessor getAccessor() {\n-    return accessor;\n+    throw new UnsupportedOperationException(\"accessor is not needed for MAP\");\n   }\n \n   @Override\n   public Mutator getMutator() {\n-    return mutator;\n+    throw new UnsupportedOperationException(\"mutator is not needed for MAP\");\n   }\n \n-  public class Accessor extends BaseValueVector.BaseAccessor {\n-\n-    @Override\n-    public Object getObject(int index) {\n-      Map<String, Object> vv = new JsonStringHashMap<>();\n-      for (String child : getChildFieldNames()) {\n-        ValueVector v = getChild(child);\n-        if (v != null && index < v.getAccessor().getValueCount()) {\n-          Object value = v.getAccessor().getObject(index);\n-          if (value != null) {\n-            vv.put(child, value);\n-          }\n+  @Override\n+  public Object getObject(int index) {\n+    Map<String, Object> vv = new JsonStringHashMap<>();\n+    for (String child : getChildFieldNames()) {\n+      ValueVector v = getChild(child);\n+      if (v != null && index < v.getValueCount()) {\n+        Object value = v.getObject(index);\n+        if (value != null) {\n+          vv.put(child, value);\n         }\n       }\n-      return vv;\n     }\n+    return vv;\n+  }\n \n-    public void get(int index, ComplexHolder holder) {\n-      reader.setPosition(index);\n-      holder.reader = reader;\n-    }\n+  @Override\n+  public boolean isNull(int index) { return false; }\n+  @Override\n+  public int getNullCount() { return 0; }\n \n-    @Override\n-    public int getValueCount() {\n-      return valueCount;\n-    }\n+  public void get(int index, ComplexHolder holder) {\n+    reader.setPosition(index);\n+    holder.reader = reader;\n   }\n \n-  public ValueVector getVectorById(int id) {\n-    return getChildByOrdinal(id);\n+  @Override\n+  public int getValueCount() {\n+    return valueCount;\n   }\n \n-  public class Mutator extends BaseValueVector.BaseMutator {\n-\n-    @Override\n-    public void setValueCount(int valueCount) {\n-      for (final ValueVector v : getChildren()) {\n-        v.getMutator().setValueCount(valueCount);\n-      }\n-      MapVector.this.valueCount = valueCount;\n-    }\n-\n-    @Override\n-    public void reset() {\n-    }\n+  public ValueVector getVectorById(int id) {\n+  return getChildByOrdinal(id);\n+}\n \n-    @Override\n-    public void generateTestData(int values) {\n+  @Override\n+  public void setValueCount(int valueCount) {\n+    for (final ValueVector v : getChildren()) {\n+      v.setValueCount(valueCount);\n     }\n+    MapVector.this.valueCount = valueCount;\n   }\n \n   @Override\n@@ -361,5 +349,4 @@ public void initializeChildrenFromFields(List<Field> children) {\n   public List<FieldVector> getChildrenFromFields() {\n     return getChildren();\n   }\n-\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/NullableMapVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/NullableMapVector.java\nindex 1c9d5aa26..f95302f55 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/NullableMapVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/NullableMapVector.java\n@@ -6,9 +6,9 @@\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- *\n+ * <p>\n  * http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * <p>\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -20,6 +20,7 @@\n \n import static com.google.common.base.Preconditions.checkNotNull;\n \n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n@@ -27,13 +28,9 @@\n import com.google.common.collect.ObjectArrays;\n \n import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BaseAllocator;\n import org.apache.arrow.memory.BufferAllocator;\n-import org.apache.arrow.vector.BaseDataValueVector;\n-import org.apache.arrow.vector.BitVector;\n-import org.apache.arrow.vector.BufferBacked;\n-import org.apache.arrow.vector.FieldVector;\n-import org.apache.arrow.vector.NullableVectorDefinitionSetter;\n-import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.*;\n import org.apache.arrow.vector.complex.impl.NullableMapReaderImpl;\n import org.apache.arrow.vector.complex.impl.NullableMapWriter;\n import org.apache.arrow.vector.holders.ComplexHolder;\n@@ -44,6 +41,7 @@\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.types.pojo.Field;\n import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n import org.apache.arrow.vector.util.TransferPair;\n \n public class NullableMapVector extends MapVector implements FieldVector {\n@@ -56,12 +54,8 @@ public static NullableMapVector empty(String name, BufferAllocator allocator) {\n   private final NullableMapReaderImpl reader = new NullableMapReaderImpl(this);\n   private final NullableMapWriter writer = new NullableMapWriter(this);\n \n-  protected final BitVector bits;\n-\n-  private final List<BufferBacked> innerVectors;\n-\n-  private final Accessor accessor;\n-  private final Mutator mutator;\n+  protected ArrowBuf validityBuffer;\n+  private int validityAllocationSizeInBytes;\n \n   // deprecated, use FieldType or static constructor instead\n   @Deprecated\n@@ -77,10 +71,8 @@ public NullableMapVector(String name, BufferAllocator allocator, DictionaryEncod\n \n   public NullableMapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n     super(name, checkNotNull(allocator), fieldType, callBack);\n-    this.bits = new BitVector(\"$bits$\", allocator);\n-    this.innerVectors = Collections.unmodifiableList(Arrays.<BufferBacked>asList(bits));\n-    this.accessor = new Accessor();\n-    this.mutator = new Mutator();\n+    this.validityBuffer = allocator.getEmpty();\n+    this.validityAllocationSizeInBytes = BitVectorHelper.getValidityBufferSize(BaseValueVector.INITIAL_VALUE_ALLOCATION);\n   }\n \n   @Override\n@@ -92,18 +84,36 @@ public Field getField() {\n \n   @Override\n   public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n-    BaseDataValueVector.load(fieldNode, getFieldInnerVectors(), ownBuffers);\n-    this.valueCount = fieldNode.getLength();\n+    if (ownBuffers.size() != 1) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 1 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+\n+    validityBuffer.release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    valueCount = fieldNode.getLength();\n+    validityAllocationSizeInBytes = validityBuffer.capacity();\n   }\n \n   @Override\n   public List<ArrowBuf> getFieldBuffers() {\n-    return BaseDataValueVector.unload(getFieldInnerVectors());\n+    List<ArrowBuf> result = new ArrayList<>(1);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+\n+    return result;\n+  }\n+\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    validityBuffer.writerIndex(BitVectorHelper.getValidityBufferSize(valueCount));\n   }\n \n   @Override\n+  @Deprecated\n   public List<BufferBacked> getFieldInnerVectors() {\n-    return innerVectors;\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n   }\n \n   @Override\n@@ -146,63 +156,195 @@ protected NullableMapTransferPair(NullableMapVector from, NullableMapVector to,\n \n     @Override\n     public void transfer() {\n-      bits.transferTo(target.bits);\n+      target.clear();\n+      target.validityBuffer = validityBuffer.transferOwnership(target.allocator).buffer;\n       super.transfer();\n+      clear();\n     }\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      target.bits.copyFromSafe(fromIndex, toIndex, bits);\n+      while (toIndex >= target.getValidityBufferValueCapacity()) {\n+        target.reallocValidityBuffer();\n+      }\n+      BitVectorHelper.setValidityBit(target.validityBuffer, toIndex, isSet(fromIndex));\n       super.copyValueSafe(fromIndex, toIndex);\n     }\n \n     @Override\n     public void splitAndTransfer(int startIndex, int length) {\n-      bits.splitAndTransferTo(startIndex, length, target.bits);\n+      target.clear();\n+      splitAndTransferValidityBuffer(startIndex, length, target);\n       super.splitAndTransfer(startIndex, length);\n     }\n   }\n \n-  @Override\n-  public int getValueCapacity() {\n-    return Math.min(bits.getValueCapacity(), super.getValueCapacity());\n+  /*\n+   * transfer the validity.\n+   */\n+  private void splitAndTransferValidityBuffer(int startIndex, int length, NullableMapVector target) {\n+    assert startIndex + length <= valueCount;\n+    int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+    int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+    int byteSizeTarget = BitVectorHelper.getValidityBufferSize(length);\n+    int offset = startIndex % 8;\n+\n+    if (length > 0) {\n+      if (offset == 0) {\n+        // slice\n+        if (target.validityBuffer != null) {\n+          target.validityBuffer.release();\n+        }\n+        target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+        target.validityBuffer.retain(1);\n+      } else {\n+        /* Copy data\n+         * When the first bit starts from the middle of a byte (offset != 0),\n+         * copy data from src BitVector.\n+         * Each byte in the target is composed by a part in i-th byte,\n+         * another part in (i+1)-th byte.\n+         */\n+        target.allocateValidityBuffer(byteSizeTarget);\n+\n+        for (int i = 0; i < byteSizeTarget - 1; i++) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer, firstByteSource + i, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer, firstByteSource + i + 1, offset);\n+\n+          target.validityBuffer.setByte(i, (b1 + b2));\n+        }\n+\n+        /* Copying the last piece is done in the following manner:\n+         * if the source vector has 1 or more bytes remaining, we copy\n+         * the last piece as a byte formed by shifting data\n+         * from the current byte and the next byte.\n+         *\n+         * if the source vector has no more bytes remaining\n+         * (we are at the last byte), we copy the last piece as a byte\n+         * by shifting data from the current byte.\n+         */\n+        if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer,\n+                  firstByteSource + byteSizeTarget, offset);\n+\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+        } else {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+        }\n+      }\n+    }\n   }\n \n+  /**\n+   * Get the value capacity of the internal validity buffer.\n+   * @return number of elements that validity buffer can hold\n+   */\n+  private int getValidityBufferValueCapacity() {\n+    return (int) (validityBuffer.capacity() * 8L);\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    return Math.min(getValidityBufferValueCapacity(),\n+            super.getValueCapacity());\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n   @Override\n   public ArrowBuf[] getBuffers(boolean clear) {\n-    return ObjectArrays.concat(bits.getBuffers(clear), super.getBuffers(clear), ArrowBuf.class);\n+    setReaderAndWriterIndex();\n+    final ArrowBuf[] buffers;\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = ObjectArrays.concat(new ArrowBuf[]{validityBuffer}, super.getBuffers(false),\n+              ArrowBuf.class);\n+    }\n+    if (clear) {\n+      for (ArrowBuf buffer : buffers) {\n+        buffer.retain();\n+      }\n+      clear();\n+    }\n+\n+    return buffers;\n   }\n \n+  /**\n+   * Close the vector and release the associated buffers.\n+   */\n   @Override\n   public void close() {\n-    bits.close();\n+    clearValidityBuffer();\n     super.close();\n   }\n \n+  /**\n+   * Same as {@link #close()}\n+   */\n   @Override\n   public void clear() {\n-    bits.clear();\n+    clearValidityBuffer();\n     super.clear();\n   }\n \n+  /**\n+   * Release the validity buffer\n+   */\n+  private void clearValidityBuffer() {\n+    validityBuffer.release();\n+    validityBuffer = allocator.getEmpty();\n+  }\n \n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector\n+   * @return size of underlying buffers.\n+   */\n   @Override\n   public int getBufferSize() {\n-    return super.getBufferSize() + bits.getBufferSize();\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    return super.getBufferSize() +\n+            BitVectorHelper.getValidityBufferSize(valueCount);\n   }\n \n+  /**\n+   * Get the potential buffer size for a particular number of records.\n+   * @param valueCount desired number of elements in the vector\n+   * @return estimated size of underlying buffers if the vector holds\n+   *         a given number of elements\n+   */\n   @Override\n   public int getBufferSizeFor(final int valueCount) {\n     if (valueCount == 0) {\n       return 0;\n     }\n     return super.getBufferSizeFor(valueCount)\n-        + bits.getBufferSizeFor(valueCount);\n+            + BitVectorHelper.getValidityBufferSize(valueCount);\n   }\n \n   @Override\n   public void setInitialCapacity(int numRecords) {\n-    bits.setInitialCapacity(numRecords);\n+    validityAllocationSizeInBytes = BitVectorHelper.getValidityBufferSize(numRecords);\n     super.setInitialCapacity(numRecords);\n   }\n \n@@ -215,25 +357,59 @@ public boolean allocateNewSafe() {\n      */\n     boolean success = false;\n     try {\n-      success = super.allocateNewSafe() && bits.allocateNewSafe();\n+      clear();\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      success = super.allocateNewSafe();\n     } finally {\n       if (!success) {\n         clear();\n+        return false;\n       }\n     }\n-    bits.zeroVector();\n-    return success;\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n   }\n \n   @Override\n   public void reAlloc() {\n-    bits.reAlloc();\n+    /* reallocate the validity buffer */\n+    reallocValidityBuffer();\n     super.reAlloc();\n   }\n \n+  private void reallocValidityBuffer() {\n+    final int currentBufferCapacity = validityBuffer.capacity();\n+    long baseSize = validityAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+    if (newAllocationSize > BaseValueVector.MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setZero(0, newBuf.capacity());\n+    newBuf.setBytes(0, validityBuffer, 0, currentBufferCapacity);\n+    validityBuffer.release(1);\n+    validityBuffer = newBuf;\n+    validityAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n   @Override\n   public long getValidityBufferAddress() {\n-    return bits.getBuffer().memoryAddress();\n+    return validityBuffer.memoryAddress();\n   }\n \n   @Override\n@@ -248,7 +424,7 @@ public long getOffsetBufferAddress() {\n \n   @Override\n   public ArrowBuf getValidityBuffer() {\n-    return bits.getDataBuffer();\n+    return validityBuffer;\n   }\n \n   @Override\n@@ -261,82 +437,76 @@ public ArrowBuf getOffsetBuffer() {\n     throw new UnsupportedOperationException();\n   }\n \n-  public final class Accessor extends MapVector.Accessor {\n-    final BitVector.Accessor bAccessor = bits.getAccessor();\n-\n-    @Override\n-    public Object getObject(int index) {\n-      if (isNull(index)) {\n-        return null;\n-      } else {\n-        return super.getObject(index);\n-      }\n-    }\n-\n-    @Override\n-    public void get(int index, ComplexHolder holder) {\n-      holder.isSet = isSet(index);\n-      super.get(index, holder);\n-    }\n-\n-    @Override\n-    public int getNullCount() {\n-      return bits.getAccessor().getNullCount();\n-    }\n-\n-    @Override\n-    public boolean isNull(int index) {\n-      return isSet(index) == 0;\n-    }\n-\n-    public int isSet(int index) {\n-      return bAccessor.get(index);\n+  @Override\n+  public Object getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return super.getObject(index);\n     }\n-\n   }\n \n-  public final class Mutator extends MapVector.Mutator implements NullableVectorDefinitionSetter {\n+  @Override\n+  public void get(int index, ComplexHolder holder) {\n+    holder.isSet = isSet(index);\n+    super.get(index, holder);\n+  }\n \n-    private Mutator() {\n-    }\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n \n-    @Override\n-    public void setIndexDefined(int index) {\n-      bits.getMutator().setSafe(index, 1);\n-    }\n+  public boolean isNull(int index) {\n+    return isSet(index) == 0;\n+  }\n \n-    public void setNull(int index) {\n-      bits.getMutator().setSafe(index, 0);\n-    }\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return Long.bitCount(b & (1L << bitIndex));\n+  }\n \n-    @Override\n-    public void setValueCount(int valueCount) {\n-      assert valueCount >= 0;\n-      super.setValueCount(valueCount);\n-      bits.getMutator().setValueCount(valueCount);\n+  public void setIndexDefined(int index) {\n+    while (index >= getValidityBufferValueCapacity()) {\n+      /* realloc the inner buffers if needed */\n+      reallocValidityBuffer();\n     }\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+  }\n \n-    @Override\n-    public void generateTestData(int valueCount) {\n-      super.generateTestData(valueCount);\n-      bits.getMutator().generateTestDataAlt(valueCount);\n+  public void setNull(int index) {\n+    while (index >= getValidityBufferValueCapacity()) {\n+      /* realloc the inner buffers if needed */\n+      reallocValidityBuffer();\n     }\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n \n-    @Override\n-    public void reset() {\n-      bits.getMutator().setValueCount(0);\n+  @Override\n+  public void setValueCount(int valueCount) {\n+    assert valueCount >= 0;\n+    while (valueCount > getValidityBufferValueCapacity()) {\n+      /* realloc the inner buffers if needed */\n+      reallocValidityBuffer();\n     }\n+    super.setValueCount(valueCount);\n+    this.valueCount = valueCount;\n+  }\n \n+  public void reset() {\n+    valueCount = 0;\n   }\n \n   @Override\n+  @Deprecated\n   public Accessor getAccessor() {\n-    return accessor;\n+    throw new UnsupportedOperationException(\"Accessor is not supported for reading from Nullable MAP\");\n   }\n \n   @Override\n+  @Deprecated\n   public Mutator getMutator() {\n-    return mutator;\n+    throw new UnsupportedOperationException(\"Mutator is not supported for writing to Nullable MAP\");\n   }\n-\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapReaderImpl.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapReaderImpl.java\nindex 614c266ac..06b0f4d43 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapReaderImpl.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapReaderImpl.java\n@@ -52,6 +52,6 @@ public void copyAsField(String name, MapWriter writer) {\n \n   @Override\n   public boolean isSet() {\n-    return !nullableMapVector.getAccessor().isNull(idx());\n+    return !nullableMapVector.isNull(idx());\n   }\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/PromotableWriter.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/PromotableWriter.java\nindex 9722196ed..5bd439cac 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/PromotableWriter.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/PromotableWriter.java\n@@ -162,7 +162,7 @@ private FieldWriter promoteToUnion() {\n     writer = new UnionWriter(unionVector, nullableMapWriterFactory);\n     writer.setPosition(idx());\n     for (int i = 0; i <= idx(); i++) {\n-      unionVector.getMutator().setType(i, vector.getMinorType());\n+      unionVector.setType(i, vector.getMinorType());\n     }\n     vector = null;\n     state = State.UNION;\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/SingleMapReaderImpl.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/SingleMapReaderImpl.java\nindex 3ebd0cd7d..c77ca4e8f 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/SingleMapReaderImpl.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/SingleMapReaderImpl.java\n@@ -78,7 +78,7 @@ public void setPosition(int index) {\n \n   @Override\n   public Object readObject() {\n-    return vector.getAccessor().getObject(idx());\n+    return vector.getObject(idx());\n   }\n \n   @Override\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/UnionFixedSizeListReader.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/UnionFixedSizeListReader.java\nindex f3e9b8773..4ad2f6f5f 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/UnionFixedSizeListReader.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/UnionFixedSizeListReader.java\n@@ -46,7 +46,7 @@ public UnionFixedSizeListReader(FixedSizeListVector vector) {\n \n   @Override\n   public boolean isSet() {\n-    return !vector.getAccessor().isNull(idx());\n+    return !vector.isNull(idx());\n   }\n \n   @Override\n@@ -56,7 +56,7 @@ public FieldReader reader() {\n \n   @Override\n   public Object readObject() {\n-    return vector.getAccessor().getObject(idx());\n+    return vector.getObject(idx());\n   }\n \n   @Override\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/UnionListReader.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/UnionListReader.java\nindex b98c36d2b..6243a2833 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/UnionListReader.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/UnionListReader.java\n@@ -19,6 +19,7 @@\n \n package org.apache.arrow.vector.complex.impl;\n \n+import io.netty.buffer.ArrowBuf;\n import org.apache.arrow.vector.UInt4Vector;\n import org.apache.arrow.vector.ValueVector;\n import org.apache.arrow.vector.complex.ListVector;\n@@ -33,12 +34,11 @@\n \n   private ListVector vector;\n   private ValueVector data;\n-  private UInt4Vector offsets;\n+  private static final int OFFSET_WIDTH = 4;\n \n   public UnionListReader(ListVector vector) {\n     this.vector = vector;\n     this.data = vector.getDataVector();\n-    this.offsets = vector.getOffsetVector();\n   }\n \n   @Override\n@@ -48,7 +48,7 @@ public Field getField() {\n \n   @Override\n   public boolean isSet() {\n-    return !vector.getAccessor().isNull(idx());\n+    return !vector.isNull(idx());\n   }\n \n   private int currentOffset;\n@@ -57,8 +57,8 @@ public boolean isSet() {\n   @Override\n   public void setPosition(int index) {\n     super.setPosition(index);\n-    currentOffset = offsets.getAccessor().get(index) - 1;\n-    maxOffset = offsets.getAccessor().get(index + 1);\n+    currentOffset = vector.getOffsetBuffer().getInt(index * OFFSET_WIDTH) - 1;\n+    maxOffset = vector.getOffsetBuffer().getInt((index + 1) * OFFSET_WIDTH);\n   }\n \n   @Override\n@@ -68,7 +68,7 @@ public FieldReader reader() {\n \n   @Override\n   public Object readObject() {\n-    return vector.getAccessor().getObject(idx());\n+    return vector.getObject(idx());\n   }\n \n   @Override\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/dictionary/DictionaryEncoder.java b/java/vector/src/main/java/org/apache/arrow/vector/dictionary/DictionaryEncoder.java\nindex 3b7dc4a56..762a442c9 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/dictionary/DictionaryEncoder.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/dictionary/DictionaryEncoder.java\n@@ -47,11 +47,10 @@\n   public static ValueVector encode(ValueVector vector, Dictionary dictionary) {\n     validateType(vector.getMinorType());\n     // load dictionary values into a hashmap for lookup\n-    ValueVector.Accessor dictionaryAccessor = dictionary.getVector().getAccessor();\n-    Map<Object, Integer> lookUps = new HashMap<>(dictionaryAccessor.getValueCount());\n-    for (int i = 0; i < dictionaryAccessor.getValueCount(); i++) {\n+    Map<Object, Integer> lookUps = new HashMap<>(dictionary.getVector().getValueCount());\n+    for (int i = 0; i < dictionary.getVector().getValueCount(); i++) {\n       // for primitive array types we need a wrapper that implements equals and hashcode appropriately\n-      lookUps.put(dictionaryAccessor.getObject(i), i);\n+      lookUps.put(dictionary.getVector().getObject(i), i);\n     }\n \n     Field valueField = vector.getField();\n@@ -61,14 +60,13 @@ public static ValueVector encode(ValueVector vector, Dictionary dictionary) {\n \n     // vector to hold our indices (dictionary encoded values)\n     FieldVector indices = indexField.createVector(vector.getAllocator());\n-    ValueVector.Mutator mutator = indices.getMutator();\n \n     // use reflection to pull out the set method\n     // TODO implement a common interface for int vectors\n     Method setter = null;\n     for (Class<?> c : ImmutableList.of(int.class, long.class)) {\n       try {\n-        setter = mutator.getClass().getMethod(\"setSafe\", int.class, c);\n+        setter = indices.getClass().getMethod(\"setSafe\", int.class, c);\n         break;\n       } catch (NoSuchMethodException e) {\n         // ignore\n@@ -78,21 +76,20 @@ public static ValueVector encode(ValueVector vector, Dictionary dictionary) {\n       throw new IllegalArgumentException(\"Dictionary encoding does not have a valid int type:\" + indices.getClass());\n     }\n \n-    ValueVector.Accessor accessor = vector.getAccessor();\n-    int count = accessor.getValueCount();\n+    int count = vector.getValueCount();\n \n     indices.allocateNew();\n \n     try {\n       for (int i = 0; i < count; i++) {\n-        Object value = accessor.getObject(i);\n+        Object value = vector.getObject(i);\n         if (value != null) { // if it's null leave it null\n           // note: this may fail if value was not included in the dictionary\n           Object encoded = lookUps.get(value);\n           if (encoded == null) {\n             throw new IllegalArgumentException(\"Dictionary encoding not defined for value:\" + value);\n           }\n-          setter.invoke(mutator, i, encoded);\n+          setter.invoke(indices, i, encoded);\n         }\n       }\n     } catch (IllegalAccessException e) {\n@@ -101,7 +98,7 @@ public static ValueVector encode(ValueVector vector, Dictionary dictionary) {\n       throw new RuntimeException(\"InvocationTargetException invoking vector mutator set():\", e.getCause());\n     }\n \n-    mutator.setValueCount(count);\n+    indices.setValueCount(count);\n \n     return indices;\n   }\n@@ -114,15 +111,14 @@ public static ValueVector encode(ValueVector vector, Dictionary dictionary) {\n    * @return vector with values restored from dictionary\n    */\n   public static ValueVector decode(ValueVector indices, Dictionary dictionary) {\n-    ValueVector.Accessor accessor = indices.getAccessor();\n-    int count = accessor.getValueCount();\n+    int count = indices.getValueCount();\n     ValueVector dictionaryVector = dictionary.getVector();\n-    int dictionaryCount = dictionaryVector.getAccessor().getValueCount();\n+    int dictionaryCount = dictionaryVector.getValueCount();\n     // copy the dictionary values into the decoded vector\n     TransferPair transfer = dictionaryVector.getTransferPair(indices.getAllocator());\n     transfer.getTo().allocateNewSafe();\n     for (int i = 0; i < count; i++) {\n-      Object index = accessor.getObject(i);\n+      Object index = indices.getObject(i);\n       if (index != null) {\n         int indexAsInt = ((Number) index).intValue();\n         if (indexAsInt > dictionaryCount) {\n@@ -133,7 +129,7 @@ public static ValueVector decode(ValueVector indices, Dictionary dictionary) {\n     }\n     // TODO do we need to worry about the field?\n     ValueVector decoded = transfer.getTo();\n-    decoded.getMutator().setValueCount(count);\n+    decoded.setValueCount(count);\n     return decoded;\n   }\n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/file/ArrowWriter.java b/java/vector/src/main/java/org/apache/arrow/vector/file/ArrowWriter.java\nindex b35aba542..7dc10b5e6 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/file/ArrowWriter.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/file/ArrowWriter.java\n@@ -82,7 +82,7 @@ protected ArrowWriter(VectorSchemaRoot root, DictionaryProvider provider, Writab\n     for (long id : dictionaryIdsUsed) {\n       Dictionary dictionary = provider.lookup(id);\n       FieldVector vector = dictionary.getVector();\n-      int count = vector.getAccessor().getValueCount();\n+      int count = vector.getValueCount();\n       VectorSchemaRoot dictRoot = new VectorSchemaRoot(ImmutableList.of(vector.getField()), ImmutableList.of(vector), count);\n       VectorUnloader unloader = new VectorUnloader(dictRoot);\n       ArrowRecordBatch batch = unloader.getRecordBatch();\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileReader.java b/java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileReader.java\nindex e1c7c909f..8017b385d 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileReader.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileReader.java\n@@ -23,7 +23,7 @@\n import static com.fasterxml.jackson.core.JsonToken.START_ARRAY;\n import static com.fasterxml.jackson.core.JsonToken.START_OBJECT;\n import static java.nio.charset.StandardCharsets.UTF_8;\n-import static org.apache.arrow.vector.schema.ArrowVectorType.OFFSET;\n+import static org.apache.arrow.vector.schema.ArrowVectorType.*;\n \n import java.io.File;\n import java.io.IOException;\n@@ -33,47 +33,19 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.*;\n \n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+import io.netty.buffer.ArrowBuf;\n import org.apache.arrow.memory.BufferAllocator;\n-import org.apache.arrow.vector.BigIntVector;\n-import org.apache.arrow.vector.BitVector;\n-import org.apache.arrow.vector.BufferBacked;\n-import org.apache.arrow.vector.DateDayVector;\n-import org.apache.arrow.vector.DateMilliVector;\n-import org.apache.arrow.vector.DecimalVector;\n-import org.apache.arrow.vector.FieldVector;\n-import org.apache.arrow.vector.Float4Vector;\n-import org.apache.arrow.vector.Float8Vector;\n-import org.apache.arrow.vector.IntVector;\n-import org.apache.arrow.vector.NullableVarBinaryVector;\n-import org.apache.arrow.vector.NullableVarCharVector;\n-import org.apache.arrow.vector.SmallIntVector;\n-import org.apache.arrow.vector.TimeMicroVector;\n-import org.apache.arrow.vector.TimeMilliVector;\n-import org.apache.arrow.vector.TimeNanoVector;\n-import org.apache.arrow.vector.TimeSecVector;\n-import org.apache.arrow.vector.TimeStampMicroTZVector;\n-import org.apache.arrow.vector.TimeStampMicroVector;\n-import org.apache.arrow.vector.TimeStampMilliTZVector;\n-import org.apache.arrow.vector.TimeStampMilliVector;\n-import org.apache.arrow.vector.TimeStampNanoTZVector;\n-import org.apache.arrow.vector.TimeStampNanoVector;\n-import org.apache.arrow.vector.TimeStampSecTZVector;\n-import org.apache.arrow.vector.TimeStampSecVector;\n-import org.apache.arrow.vector.TinyIntVector;\n-import org.apache.arrow.vector.UInt1Vector;\n-import org.apache.arrow.vector.UInt2Vector;\n-import org.apache.arrow.vector.UInt4Vector;\n-import org.apache.arrow.vector.UInt8Vector;\n-import org.apache.arrow.vector.ValueVector;\n-import org.apache.arrow.vector.VarBinaryVector;\n-import org.apache.arrow.vector.VarCharVector;\n-import org.apache.arrow.vector.VectorSchemaRoot;\n-import org.apache.arrow.vector.complex.ListVector;\n+import org.apache.arrow.vector.*;\n import org.apache.arrow.vector.dictionary.Dictionary;\n import org.apache.arrow.vector.dictionary.DictionaryProvider;\n+import org.apache.arrow.vector.file.InvalidArrowFileException;\n+import org.apache.arrow.vector.schema.ArrowFieldNode;\n import org.apache.arrow.vector.schema.ArrowVectorType;\n+import org.apache.arrow.vector.types.Types;\n import org.apache.arrow.vector.types.pojo.Field;\n import org.apache.arrow.vector.types.pojo.Schema;\n import org.apache.arrow.vector.util.DecimalUtility;\n@@ -153,7 +125,7 @@ private void readDictionaryBatches() throws JsonParseException, IOException {\n       FieldVector vector = dict.getVector();\n       List<Field> fields = ImmutableList.of(vector.getField());\n       List<FieldVector> vectors = ImmutableList.of(vector);\n-      VectorSchemaRoot root = new VectorSchemaRoot(fields, vectors, vector.getAccessor().getValueCount());\n+      VectorSchemaRoot root = new VectorSchemaRoot(fields, vectors, vector.getValueCount());\n       read(root);\n \n       readToken(END_OBJECT);\n@@ -177,7 +149,7 @@ public boolean read(VectorSchemaRoot root) throws IOException {\n         {\n           for (Field field : root.getSchema().getFields()) {\n             FieldVector vector = root.getVector(field.getName());\n-            readVector(field, vector);\n+            readFromJsonIntoVector(field, vector);\n           }\n         }\n         readToken(END_ARRAY);\n@@ -204,7 +176,7 @@ public VectorSchemaRoot read() throws IOException {\n         {\n           for (Field field : schema.getFields()) {\n             FieldVector vector = recordBatch.getVector(field.getName());\n-            readVector(field, vector);\n+            readFromJsonIntoVector(field, vector);\n           }\n         }\n         readToken(END_ARRAY);\n@@ -218,16 +190,304 @@ public VectorSchemaRoot read() throws IOException {\n     }\n   }\n \n-  /**\n-   * TODO: A better way of implementing this function is to use `loadFieldBuffers` methods in\n-   * FieldVector to set the inner-vector data as done in `ArrowFileReader`.\n-   */\n-  private void readVector(Field field, FieldVector vector) throws JsonParseException, IOException {\n-    List<ArrowVectorType> vectorTypes = field.getTypeLayout().getVectorTypes();\n-    List<BufferBacked> fieldInnerVectors = vector.getFieldInnerVectors();\n-    if (vectorTypes.size() != fieldInnerVectors.size()) {\n-      throw new IllegalArgumentException(\"vector types and inner vectors are not the same size: \" + vectorTypes.size() + \" != \" + fieldInnerVectors.size());\n+  private abstract class BufferReader {\n+    abstract protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException;\n+\n+    ArrowBuf readBuffer(BufferAllocator allocator, int count) throws IOException {\n+      readToken(START_ARRAY);\n+      ArrowBuf buf = read(allocator, count);\n+      readToken(END_ARRAY);\n+      return buf;\n     }\n+  }\n+\n+  private class BufferHelper {\n+    BufferReader BIT = new BufferReader() {\n+      @Override\n+      protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException {\n+        final int bufferSize = BitVectorHelper.getValidityBufferSize(count);\n+        ArrowBuf buf = allocator.buffer(bufferSize);\n+\n+        // C++ integration test fails without this.\n+        buf.setZero(0, bufferSize);\n+\n+        for (int i = 0; i < count; i++) {\n+          parser.nextToken();\n+          BitVectorHelper.setValidityBit(buf, i, parser.readValueAs(Boolean.class) ? 1 : 0);\n+        }\n+\n+        buf.writerIndex(bufferSize);\n+        return buf;\n+      }\n+    };\n+\n+    BufferReader INT1 = new BufferReader() {\n+      @Override\n+      protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException {\n+        final int size = count * NullableTinyIntVector.TYPE_WIDTH;\n+        ArrowBuf buf = allocator.buffer(size);\n+\n+        for (int i = 0; i < count; i++) {\n+          parser.nextToken();\n+          buf.writeByte(parser.getByteValue());\n+        }\n+\n+        return buf;\n+      }\n+    };\n+\n+    BufferReader INT2 = new BufferReader() {\n+      @Override\n+      protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException {\n+        final int size = count * NullableSmallIntVector.TYPE_WIDTH;\n+        ArrowBuf buf = allocator.buffer(size);\n+\n+        for (int i = 0; i < count; i++) {\n+          parser.nextToken();\n+          buf.writeShort(parser.getShortValue());\n+        }\n+\n+        return buf;\n+      }\n+    };\n+\n+    BufferReader INT4 = new BufferReader() {\n+      @Override\n+      protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException {\n+        final int size = count * NullableIntVector.TYPE_WIDTH;\n+        ArrowBuf buf = allocator.buffer(size);\n+\n+        for (int i = 0; i < count; i++) {\n+          parser.nextToken();\n+          buf.writeInt(parser.getIntValue());\n+        }\n+\n+        return buf;\n+      }\n+    };\n+\n+    BufferReader INT8 = new BufferReader() {\n+      @Override\n+      protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException {\n+        final int size = count * NullableBigIntVector.TYPE_WIDTH;\n+        ArrowBuf buf = allocator.buffer(size);\n+\n+        for (int i = 0; i < count; i++) {\n+          parser.nextToken();\n+          buf.writeLong(parser.getLongValue());\n+        }\n+\n+        return buf;\n+      }\n+    };\n+\n+    BufferReader FLOAT4 = new BufferReader() {\n+      @Override\n+      protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException {\n+        final int size = count * NullableFloat4Vector.TYPE_WIDTH;\n+        ArrowBuf buf = allocator.buffer(size);\n+\n+        for (int i = 0; i < count; i++) {\n+          parser.nextToken();\n+          buf.writeFloat(parser.getFloatValue());\n+        }\n+\n+        return buf;\n+      }\n+    };\n+\n+    BufferReader FLOAT8 = new BufferReader() {\n+      @Override\n+      protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException {\n+        final int size = count * NullableFloat8Vector.TYPE_WIDTH;\n+        ArrowBuf buf = allocator.buffer(size);\n+\n+        for (int i = 0; i < count; i++) {\n+          parser.nextToken();\n+          buf.writeDouble(parser.getDoubleValue());\n+        }\n+\n+        return buf;\n+      }\n+    };\n+\n+    BufferReader DECIMAL = new BufferReader() {\n+      @Override\n+      protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException {\n+        final int size = count * NullableDecimalVector.TYPE_WIDTH;\n+        ArrowBuf buf = allocator.buffer(size);\n+\n+        for (int i = 0; i < count; i++) {\n+          parser.nextToken();\n+          BigDecimal decimalValue = new BigDecimal(parser.readValueAs(String.class));\n+          DecimalUtility.writeBigDecimalToArrowBuf(decimalValue, buf, i);\n+        }\n+\n+        buf.writerIndex(size);\n+        return buf;\n+      }\n+    };\n+\n+    BufferReader VARCHAR = new BufferReader() {\n+      @Override\n+      protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException {\n+        ArrayList<byte[]> values = Lists.newArrayList();\n+        int bufferSize = 0;\n+        for (int i = 0; i < count; i++) {\n+          parser.nextToken();\n+          final byte[] value = parser.getValueAsString().getBytes(UTF_8);\n+          values.add(value);\n+          bufferSize += value.length;\n+\n+        }\n+\n+        ArrowBuf buf = allocator.buffer(bufferSize);\n+\n+        for (byte[] value : values) {\n+          buf.writeBytes(value);\n+        }\n+\n+        return buf;\n+      }\n+    };\n+\n+    BufferReader VARBINARY = new BufferReader() {\n+      @Override\n+      protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException {\n+        ArrayList<byte[]> values = Lists.newArrayList();\n+        int bufferSize = 0;\n+        for (int i = 0; i < count; i++) {\n+          parser.nextToken();\n+          final byte[] value = decodeHexSafe(parser.readValueAs(String.class));\n+          values.add(value);\n+          bufferSize += value.length;\n+\n+        }\n+\n+        ArrowBuf buf = allocator.buffer(bufferSize);\n+\n+        for (byte[] value : values) {\n+          buf.writeBytes(value);\n+        }\n+\n+        return buf;\n+      }\n+    };\n+  }\n+\n+  private ArrowBuf readIntoBuffer(BufferAllocator allocator, ArrowVectorType bufferType,\n+                                  Types.MinorType type, int count) throws IOException {\n+    ArrowBuf buf;\n+\n+    BufferHelper helper = new BufferHelper();\n+\n+    BufferReader reader = null;\n+\n+    if (bufferType.equals(VALIDITY)) {\n+      reader = helper.BIT;\n+    } else if (bufferType.equals(OFFSET)) {\n+      reader = helper.INT4;\n+    } else if (bufferType.equals(TYPE)) {\n+      reader = helper.INT1;\n+    } else if (bufferType.equals(DATA)) {\n+      switch (type) {\n+        case BIT:\n+          reader = helper.BIT;\n+          break;\n+        case TINYINT:\n+          reader = helper.INT1;\n+          break;\n+        case SMALLINT:\n+          reader = helper.INT2;\n+          break;\n+        case INT:\n+          reader = helper.INT4;\n+          break;\n+        case BIGINT:\n+          reader = helper.INT8;\n+          break;\n+        case UINT1:\n+          reader = helper.INT1;\n+          break;\n+        case UINT2:\n+          reader = helper.INT2;\n+          break;\n+        case UINT4:\n+          reader = helper.INT4;\n+          break;\n+        case UINT8:\n+          reader = helper.INT8;\n+          break;\n+        case FLOAT4:\n+          reader = helper.FLOAT4;\n+          break;\n+        case FLOAT8:\n+          reader = helper.FLOAT8;\n+          break;\n+        case DECIMAL:\n+          reader = helper.DECIMAL;\n+          break;\n+        case VARCHAR:\n+          reader = helper.VARCHAR;\n+          break;\n+        case VARBINARY:\n+          reader = helper.VARBINARY;\n+          break;\n+        case DATEDAY:\n+          reader = helper.INT4;\n+          break;\n+        case DATEMILLI:\n+          reader = helper.INT8;\n+          break;\n+        case TIMESEC:\n+        case TIMEMILLI:\n+          reader = helper.INT4;\n+          break;\n+        case TIMEMICRO:\n+        case TIMENANO:\n+          reader = helper.INT8;\n+          break;\n+        case TIMESTAMPNANO:\n+        case TIMESTAMPMICRO:\n+        case TIMESTAMPMILLI:\n+        case TIMESTAMPSEC:\n+        case TIMESTAMPNANOTZ:\n+        case TIMESTAMPMICROTZ:\n+        case TIMESTAMPMILLITZ:\n+        case TIMESTAMPSECTZ:\n+          reader = helper.INT8;\n+          break;\n+        default:\n+          throw new UnsupportedOperationException(\"Cannot read array of type \" + type);\n+      }\n+    } else {\n+      throw new InvalidArrowFileException(\"Unrecognized buffer type \" + bufferType);\n+    }\n+\n+    buf = reader.readBuffer(allocator, count);\n+\n+    assert buf != null;\n+    return buf;\n+  }\n+\n+  private void readFromJsonIntoVector(Field field, FieldVector vector) throws JsonParseException, IOException {\n+    List<ArrowVectorType> vectorTypes = field.getTypeLayout().getVectorTypes();\n+    ArrowBuf[] vectorBuffers = new ArrowBuf[vectorTypes.size()];\n+    /*\n+     * The order of inner buffers is :\n+     * Fixed width vector:\n+     *    -- validity buffer\n+     *    -- data buffer\n+     * Variable width vector:\n+     *    -- validity buffer\n+     *    -- offset buffer\n+     *    -- data buffer\n+     *\n+     * This is similar to what getFieldInnerVectors() used to give but now that we don't have\n+     * inner vectors anymore, we will work directly at the buffer level -- populate buffers\n+     * locally as we read from Json parser and do loadFieldBuffers on the vector followed by\n+     * releasing the local buffers.\n+     */\n     readToken(START_OBJECT);\n     {\n       // If currently reading dictionaries, field name is not important so don't check\n@@ -236,58 +496,51 @@ private void readVector(Field field, FieldVector vector) throws JsonParseExcepti\n         throw new IllegalArgumentException(\"Expected field \" + field.getName() + \" but got \" + name);\n       }\n \n-      // Initialize the vector with required capacity\n-      int count = readNextField(\"count\", Integer.class);\n-      vector.setInitialCapacity(count);\n-      vector.allocateNew();\n+      /* Initialize the vector with required capacity but don't allocateNew since we would\n+       * be doing loadFieldBuffers.\n+       */\n+      int valueCount = readNextField(\"count\", Integer.class);\n+      vector.setInitialCapacity(valueCount);\n \n-      // Read inner vectors\n       for (int v = 0; v < vectorTypes.size(); v++) {\n         ArrowVectorType vectorType = vectorTypes.get(v);\n-        ValueVector valueVector = (ValueVector) fieldInnerVectors.get(v);\n         nextFieldIs(vectorType.getName());\n-        readToken(START_ARRAY);\n-        int innerVectorCount = vectorType.equals(OFFSET) ? count + 1 : count;\n-        for (int i = 0; i < innerVectorCount; i++) {\n-          parser.nextToken();\n-          setValueFromParser(valueVector, i);\n+        int innerBufferValueCount = valueCount;\n+        if (vectorType.equals(OFFSET)) {\n+          /* offset buffer has 1 additional value capacity */\n+          innerBufferValueCount = valueCount + 1;\n         }\n-        readToken(END_ARRAY);\n-      }\n \n-      // Set lastSet before valueCount to prevent setValueCount from filling empty values\n-      switch (vector.getMinorType()) {\n-        case LIST:\n-          // ListVector starts lastSet from index 0, so lastSet value is always last index written + 1\n-          ((ListVector) vector).getMutator().setLastSet(count);\n-          break;\n-        case VARBINARY:\n-          ((NullableVarBinaryVector) vector).getMutator().setLastSet(count - 1);\n-          break;\n-        case VARCHAR:\n-          ((NullableVarCharVector) vector).getMutator().setLastSet(count - 1);\n-          break;\n+        vectorBuffers[v] = readIntoBuffer(allocator, vectorType, vector.getMinorType(), innerBufferValueCount);\n       }\n-      vector.getMutator().setValueCount(count);\n \n-      // read child vectors, if any\n+      final int nullCount = BitVectorHelper.getNullCount(vectorBuffers[0], valueCount);\n+      final ArrowFieldNode fieldNode = new ArrowFieldNode(valueCount, nullCount);\n+      vector.loadFieldBuffers(fieldNode, Arrays.asList(vectorBuffers));\n+\n+      /* read child vectors (if any) */\n       List<Field> fields = field.getChildren();\n       if (!fields.isEmpty()) {\n         List<FieldVector> vectorChildren = vector.getChildrenFromFields();\n         if (fields.size() != vectorChildren.size()) {\n-          throw new IllegalArgumentException(\"fields and children are not the same size: \" + fields.size() + \" != \" + vectorChildren.size());\n+          throw new IllegalArgumentException(\n+                  \"fields and children are not the same size: \" + fields.size() + \" != \" + vectorChildren.size());\n         }\n         nextFieldIs(\"children\");\n         readToken(START_ARRAY);\n         for (int i = 0; i < fields.size(); i++) {\n           Field childField = fields.get(i);\n           FieldVector childVector = vectorChildren.get(i);\n-          readVector(childField, childVector);\n+          readFromJsonIntoVector(childField, childVector);\n         }\n         readToken(END_ARRAY);\n       }\n     }\n     readToken(END_OBJECT);\n+\n+    for (ArrowBuf buffer: vectorBuffers) {\n+      buffer.release();\n+    }\n   }\n \n   private byte[] decodeHexSafe(String hexString) throws IOException {\n@@ -298,101 +551,6 @@ private void readVector(Field field, FieldVector vector) throws JsonParseExcepti\n     }\n   }\n \n-  private void setValueFromParser(ValueVector valueVector, int i) throws IOException {\n-    switch (valueVector.getMinorType()) {\n-      case BIT:\n-        ((BitVector) valueVector).getMutator().set(i, parser.readValueAs(Boolean.class) ? 1 : 0);\n-        break;\n-      case TINYINT:\n-        ((TinyIntVector) valueVector).getMutator().set(i, parser.readValueAs(Integer.class));\n-        break;\n-      case SMALLINT:\n-        ((SmallIntVector) valueVector).getMutator().set(i, parser.readValueAs(Integer.class));\n-        break;\n-      case INT:\n-        ((IntVector) valueVector).getMutator().set(i, parser.readValueAs(Integer.class));\n-        break;\n-      case BIGINT:\n-        ((BigIntVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case UINT1:\n-        ((UInt1Vector) valueVector).getMutator().set(i, parser.readValueAs(Integer.class));\n-        break;\n-      case UINT2:\n-        ((UInt2Vector) valueVector).getMutator().set(i, parser.readValueAs(Integer.class));\n-        break;\n-      case UINT4:\n-        ((UInt4Vector) valueVector).getMutator().set(i, parser.readValueAs(Integer.class));\n-        break;\n-      case UINT8:\n-        ((UInt8Vector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case FLOAT4:\n-        ((Float4Vector) valueVector).getMutator().set(i, parser.readValueAs(Float.class));\n-        break;\n-      case FLOAT8:\n-        ((Float8Vector) valueVector).getMutator().set(i, parser.readValueAs(Double.class));\n-        break;\n-      case DECIMAL: {\n-          DecimalVector decimalVector = (DecimalVector) valueVector;\n-          // Here we assume the decimal value is the unscaled integer value as a string\n-          BigDecimal decimalValue = new BigDecimal(parser.readValueAs(String.class));\n-          DecimalUtility.writeBigDecimalToArrowBuf(decimalValue, decimalVector.getBuffer(), i);\n-        }\n-        break;\n-      case VARBINARY:\n-        ((VarBinaryVector) valueVector).getMutator().setSafe(i, decodeHexSafe(parser.readValueAs(String.class)));\n-        break;\n-      case VARCHAR:\n-        ((VarCharVector) valueVector).getMutator().setSafe(i, parser.readValueAs(String.class).getBytes(UTF_8));\n-        break;\n-      case DATEDAY:\n-        ((DateDayVector) valueVector).getMutator().set(i, parser.readValueAs(Integer.class));\n-        break;\n-      case DATEMILLI:\n-        ((DateMilliVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case TIMESEC:\n-        ((TimeSecVector) valueVector).getMutator().set(i, parser.readValueAs(Integer.class));\n-        break;\n-      case TIMEMILLI:\n-        ((TimeMilliVector) valueVector).getMutator().set(i, parser.readValueAs(Integer.class));\n-        break;\n-      case TIMEMICRO:\n-        ((TimeMicroVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case TIMENANO:\n-        ((TimeNanoVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case TIMESTAMPSEC:\n-        ((TimeStampSecVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case TIMESTAMPMILLI:\n-        ((TimeStampMilliVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case TIMESTAMPMICRO:\n-        ((TimeStampMicroVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case TIMESTAMPNANO:\n-        ((TimeStampNanoVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case TIMESTAMPSECTZ:\n-        ((TimeStampSecTZVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case TIMESTAMPMILLITZ:\n-        ((TimeStampMilliTZVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case TIMESTAMPMICROTZ:\n-        ((TimeStampMicroTZVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case TIMESTAMPNANOTZ:\n-        ((TimeStampNanoTZVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      default:\n-        throw new UnsupportedOperationException(\"minor type: \" + valueVector.getMinorType());\n-    }\n-  }\n-\n   @Override\n   public void close() throws IOException {\n     parser.close();\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileWriter.java b/java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileWriter.java\nindex 05341bec4..0c8507b51 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileWriter.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileWriter.java\n@@ -18,6 +18,8 @@\n \n package org.apache.arrow.vector.file.json;\n \n+import static org.apache.arrow.vector.schema.ArrowVectorType.*;\n+\n import java.io.File;\n import java.io.IOException;\n import java.math.BigDecimal;\n@@ -28,28 +30,11 @@\n \n import com.google.common.collect.ImmutableList;\n import io.netty.buffer.ArrowBuf;\n-import org.apache.arrow.vector.BitVector;\n-import org.apache.arrow.vector.BufferBacked;\n-import org.apache.arrow.vector.DateDayVector;\n-import org.apache.arrow.vector.DateMilliVector;\n-import org.apache.arrow.vector.DecimalVector;\n-import org.apache.arrow.vector.FieldVector;\n-import org.apache.arrow.vector.TimeMicroVector;\n-import org.apache.arrow.vector.TimeMilliVector;\n-import org.apache.arrow.vector.TimeNanoVector;\n-import org.apache.arrow.vector.TimeSecVector;\n-import org.apache.arrow.vector.TimeStampMicroVector;\n-import org.apache.arrow.vector.TimeStampMilliVector;\n-import org.apache.arrow.vector.TimeStampNanoVector;\n-import org.apache.arrow.vector.TimeStampSecVector;\n-import org.apache.arrow.vector.ValueVector;\n-import org.apache.arrow.vector.ValueVector.Accessor;\n-import org.apache.arrow.vector.VarBinaryVector;\n-import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.*;\n import org.apache.arrow.vector.dictionary.Dictionary;\n import org.apache.arrow.vector.dictionary.DictionaryProvider;\n import org.apache.arrow.vector.schema.ArrowVectorType;\n-import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.Types;\n import org.apache.arrow.vector.types.pojo.Field;\n import org.apache.arrow.vector.types.pojo.Schema;\n \n@@ -135,7 +120,7 @@ private void writeDictionaryBatches(JsonGenerator generator, Set<Long> dictionar\n       FieldVector vector = dictionary.getVector();\n       List<Field> fields = ImmutableList.of(vector.getField());\n       List<FieldVector> vectors = ImmutableList.of(vector);\n-      VectorSchemaRoot root = new VectorSchemaRoot(fields, vectors, vector.getAccessor().getValueCount());\n+      VectorSchemaRoot root = new VectorSchemaRoot(fields, vectors, vector.getValueCount());\n       writeBatch(root);\n \n       generator.writeEndObject();\n@@ -157,31 +142,38 @@ private void writeBatch(VectorSchemaRoot recordBatch) throws IOException {\n       generator.writeArrayFieldStart(\"columns\");\n       for (Field field : recordBatch.getSchema().getFields()) {\n         FieldVector vector = recordBatch.getVector(field.getName());\n-        writeVector(field, vector);\n+        writeFromVectorIntoJson(field, vector);\n       }\n       generator.writeEndArray();\n     }\n     generator.writeEndObject();\n   }\n \n-  private void writeVector(Field field, FieldVector vector) throws IOException {\n+  private void writeFromVectorIntoJson(Field field, FieldVector vector) throws IOException {\n     List<ArrowVectorType> vectorTypes = field.getTypeLayout().getVectorTypes();\n-    List<BufferBacked> fieldInnerVectors = vector.getFieldInnerVectors();\n-    if (vectorTypes.size() != fieldInnerVectors.size()) {\n-      throw new IllegalArgumentException(\"vector types and inner vectors are not the same size: \" + vectorTypes.size() + \" != \" + fieldInnerVectors.size());\n+    List<ArrowBuf> vectorBuffers = vector.getFieldBuffers();\n+    if (vectorTypes.size() != vectorBuffers.size()) {\n+      throw new IllegalArgumentException(\"vector types and inner vector buffers are not the same size: \" + vectorTypes.size() + \" != \" + vectorBuffers.size());\n     }\n     generator.writeStartObject();\n     {\n       generator.writeObjectField(\"name\", field.getName());\n-      int valueCount = vector.getAccessor().getValueCount();\n+      int valueCount = vector.getValueCount();\n       generator.writeObjectField(\"count\", valueCount);\n+      final int scale = (vector instanceof NullableDecimalVector) ?\n+                            ((NullableDecimalVector) vector).getScale() : 0;\n       for (int v = 0; v < vectorTypes.size(); v++) {\n         ArrowVectorType vectorType = vectorTypes.get(v);\n-        BufferBacked innerVector = fieldInnerVectors.get(v);\n+        ArrowBuf vectorBuffer = vectorBuffers.get(v);\n         generator.writeArrayFieldStart(vectorType.getName());\n-        ValueVector valueVector = (ValueVector) innerVector;\n-        for (int i = 0; i < valueVector.getAccessor().getValueCount(); i++) {\n-          writeValueToGenerator(valueVector, i);\n+        final int bufferValueCount = (vectorType.equals(OFFSET)) ? valueCount + 1 : valueCount;\n+        for (int i = 0; i < bufferValueCount; i++) {\n+          if (vectorType.equals(DATA) && (vector.getMinorType() == Types.MinorType.VARCHAR ||\n+                  vector.getMinorType() == Types.MinorType.VARBINARY)) {\n+            writeValueToGenerator(vectorType, vectorBuffer, vectorBuffers.get(v-1), vector, i, scale);\n+          } else {\n+            writeValueToGenerator(vectorType, vectorBuffer, null, vector, i, scale);\n+          }\n         }\n         generator.writeEndArray();\n       }\n@@ -195,7 +187,7 @@ private void writeVector(Field field, FieldVector vector) throws IOException {\n         for (int i = 0; i < fields.size(); i++) {\n           Field childField = fields.get(i);\n           FieldVector childVector = children.get(i);\n-          writeVector(childField, childVector);\n+          writeFromVectorIntoJson(childField, childVector);\n         }\n         generator.writeEndArray();\n       }\n@@ -203,62 +195,102 @@ private void writeVector(Field field, FieldVector vector) throws IOException {\n     generator.writeEndObject();\n   }\n \n-  private void writeValueToGenerator(ValueVector valueVector, int i) throws IOException {\n-    switch (valueVector.getMinorType()) {\n-      case DATEDAY:\n-        generator.writeNumber(((DateDayVector) valueVector).getAccessor().get(i));\n-        break;\n-      case DATEMILLI:\n-        generator.writeNumber(((DateMilliVector) valueVector).getAccessor().get(i));\n-        break;\n-      case TIMESEC:\n-        generator.writeNumber(((TimeSecVector) valueVector).getAccessor().get(i));\n-        break;\n-      case TIMEMILLI:\n-        generator.writeNumber(((TimeMilliVector) valueVector).getAccessor().get(i));\n-        break;\n-      case TIMEMICRO:\n-        generator.writeNumber(((TimeMicroVector) valueVector).getAccessor().get(i));\n-        break;\n-      case TIMENANO:\n-        generator.writeNumber(((TimeNanoVector) valueVector).getAccessor().get(i));\n-        break;\n-      case TIMESTAMPSEC:\n-        generator.writeNumber(((TimeStampSecVector) valueVector).getAccessor().get(i));\n-        break;\n-      case TIMESTAMPMILLI:\n-        generator.writeNumber(((TimeStampMilliVector) valueVector).getAccessor().get(i));\n-        break;\n-      case TIMESTAMPMICRO:\n-        generator.writeNumber(((TimeStampMicroVector) valueVector).getAccessor().get(i));\n-        break;\n-      case TIMESTAMPNANO:\n-        generator.writeNumber(((TimeStampNanoVector) valueVector).getAccessor().get(i));\n-        break;\n-      case BIT:\n-        generator.writeNumber(((BitVector) valueVector).getAccessor().get(i));\n-        break;\n-      case VARBINARY: {\n-          String hexString = Hex.encodeHexString(((VarBinaryVector) valueVector).getAccessor().get(i));\n-          generator.writeString(hexString);\n+  private void writeValueToGenerator(ArrowVectorType bufferType, ArrowBuf buffer,\n+                                     ArrowBuf offsetBuffer, FieldVector vector,\n+                                     final int index, final int scale) throws IOException {\n+    if (bufferType.equals(TYPE)) {\n+      generator.writeNumber(buffer.getByte(index * NullableTinyIntVector.TYPE_WIDTH));\n+    } else if (bufferType.equals(OFFSET)) {\n+      generator.writeNumber(buffer.getInt(index * BaseNullableVariableWidthVector.OFFSET_WIDTH));\n+    } else if(bufferType.equals(VALIDITY)) {\n+      generator.writeNumber(vector.isNull(index) ? 0 : 1);\n+    } else if (bufferType.equals(DATA)) {\n+      switch (vector.getMinorType()) {\n+        case TINYINT:\n+          generator.writeNumber(NullableTinyIntVector.get(buffer, index));\n+          break;\n+        case SMALLINT:\n+          generator.writeNumber(NullableSmallIntVector.get(buffer, index));\n+          break;\n+        case INT:\n+          generator.writeNumber(NullableIntVector.get(buffer, index));\n+          break;\n+        case BIGINT:\n+          generator.writeNumber(NullableBigIntVector.get(buffer, index));\n+          break;\n+        case FLOAT4:\n+          generator.writeNumber(NullableFloat4Vector.get(buffer, index));\n+          break;\n+        case FLOAT8:\n+          generator.writeNumber(NullableFloat8Vector.get(buffer, index));\n+          break;\n+        case DATEDAY:\n+          generator.writeNumber(NullableDateDayVector.get(buffer, index));\n+          break;\n+        case DATEMILLI:\n+          generator.writeNumber(NullableDateMilliVector.get(buffer, index));\n+          break;\n+        case TIMESEC:\n+          generator.writeNumber(NullableTimeSecVector.get(buffer, index));\n+          break;\n+        case TIMEMILLI:\n+          generator.writeNumber(NullableTimeMilliVector.get(buffer, index));\n+          break;\n+        case TIMEMICRO:\n+          generator.writeNumber(NullableTimeMicroVector.get(buffer, index));\n+          break;\n+        case TIMENANO:\n+          generator.writeNumber(NullableTimeNanoVector.get(buffer, index));\n+          break;\n+        case TIMESTAMPSEC:\n+          generator.writeNumber(NullableTimeStampSecVector.get(buffer, index));\n+          break;\n+        case TIMESTAMPMILLI:\n+          generator.writeNumber(NullableTimeStampMilliVector.get(buffer, index));\n+          break;\n+        case TIMESTAMPMICRO:\n+          generator.writeNumber(NullableTimeStampMicroVector.get(buffer, index));\n+          break;\n+        case TIMESTAMPNANO:\n+          generator.writeNumber(NullableTimeStampNanoVector.get(buffer, index));\n+          break;\n+        case TIMESTAMPSECTZ:\n+          generator.writeNumber(NullableTimeStampSecTZVector.get(buffer, index));\n+          break;\n+        case TIMESTAMPMILLITZ:\n+          generator.writeNumber(NullableTimeStampMilliTZVector.get(buffer, index));\n+          break;\n+        case TIMESTAMPMICROTZ:\n+          generator.writeNumber(NullableTimeStampMicroTZVector.get(buffer, index));\n+          break;\n+        case TIMESTAMPNANOTZ:\n+          generator.writeNumber(NullableTimeStampNanoTZVector.get(buffer, index));\n+          break;\n+        case BIT:\n+          generator.writeNumber(BitVectorHelper.get(buffer, index));\n+          break;\n+        case VARBINARY: {\n+          assert offsetBuffer != null;\n+          String hexString = Hex.encodeHexString(BaseNullableVariableWidthVector.get(buffer,\n+                  offsetBuffer, index));\n+          generator.writeObject(hexString);\n+          break;\n+        }\n+        case VARCHAR: {\n+          assert offsetBuffer != null;\n+          byte[] b = (BaseNullableVariableWidthVector.get(buffer, offsetBuffer, index));\n+          generator.writeString(new String(b, \"UTF-8\"));\n+          break;\n         }\n-        break;\n-      case DECIMAL: {\n-          BigDecimal decimalValue = ((DecimalVector) valueVector).getAccessor().getObject(i);\n+        case DECIMAL: {\n+          BigDecimal decimalValue = DecimalUtility.getBigDecimalFromArrowBuf(buffer, index, scale);\n           // We write the unscaled value, because the scale is stored in the type metadata.\n           generator.writeString(decimalValue.unscaledValue().toString());\n+          break;\n         }\n-        break;\n-      default:\n-        // TODO: each type\n-        Accessor accessor = valueVector.getAccessor();\n-        Object value = accessor.getObject(i);\n-        if (value instanceof Number || value instanceof Boolean) {\n-          generator.writeObject(value);\n-        } else {\n-          generator.writeObject(value.toString());\n-        }\n-        break;\n+        default:\n+          throw new UnsupportedOperationException(\"minor type: \" + vector.getMinorType());\n+      }\n     }\n   }\n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/util/Validator.java b/java/vector/src/main/java/org/apache/arrow/vector/util/Validator.java\nindex 5851bd5fa..c27e5e5c8 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/util/Validator.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/util/Validator.java\n@@ -114,13 +114,13 @@ public static void compareFieldVectors(FieldVector vector1, FieldVector vector2)\n     if (!field1.equals(vector2.getField())) {\n       throw new IllegalArgumentException(\"Different Fields:\\n\" + field1 + \"\\n!=\\n\" + vector2.getField());\n     }\n-    int valueCount = vector1.getAccessor().getValueCount();\n-    if (valueCount != vector2.getAccessor().getValueCount()) {\n-      throw new IllegalArgumentException(\"Different value count for field \" + field1 + \" : \" + valueCount + \" != \" + vector2.getAccessor().getValueCount());\n+    int valueCount = vector1.getValueCount();\n+    if (valueCount != vector2.getValueCount()) {\n+      throw new IllegalArgumentException(\"Different value count for field \" + field1 + \" : \" + valueCount + \" != \" + vector2.getValueCount());\n     }\n     for (int j = 0; j < valueCount; j++) {\n-      Object obj1 = vector1.getAccessor().getObject(j);\n-      Object obj2 = vector2.getAccessor().getObject(j);\n+      Object obj1 = vector1.getObject(j);\n+      Object obj2 = vector2.getObject(j);\n       if (!equals(field1.getType(), obj1, obj2)) {\n         throw new IllegalArgumentException(\n             \"Different values in column:\\n\" + field1 + \" at index \" + j + \": \" + obj1 + \" != \" + obj2);\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java\nindex 17fcf05fc..ada341497 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java\n@@ -340,59 +340,56 @@ public void testReallocAfterVectorTransfer2() {\n       int valueCapacity = vector.getValueCapacity();\n       assertEquals(4096, valueCapacity);\n \n-      final NullableBitVector.Mutator mutator = vector.getMutator();\n-      final NullableBitVector.Accessor accessor = vector.getAccessor();\n-\n       for (int i = 0; i < valueCapacity; i++) {\n         if ((i & 1) == 1) {\n-          mutator.set(i, 1);\n+          vector.set(i, 1);\n         }\n       }\n \n       for (int i = 0; i < valueCapacity; i++) {\n         if ((i & 1) == 1) {\n-          assertFalse(\"unexpected cleared bit at index: \" + i, accessor.isNull(i));\n+          assertFalse(\"unexpected cleared bit at index: \" + i, vector.isNull(i));\n         }\n         else {\n-          assertTrue(\"unexpected set bit at index: \" + i, accessor.isNull(i));\n+          assertTrue(\"unexpected set bit at index: \" + i, vector.isNull(i));\n         }\n       }\n \n       /* trigger first realloc */\n-      mutator.setSafe(valueCapacity, 1, 1);\n+      vector.setSafe(valueCapacity, 1, 1);\n       assertEquals(valueCapacity * 2, vector.getValueCapacity());\n \n       for (int i = valueCapacity; i < valueCapacity*2; i++) {\n         if ((i & 1) == 1) {\n-          mutator.set(i, 1);\n+          vector.set(i, 1);\n         }\n       }\n \n       for (int i = 0; i < valueCapacity*2; i++) {\n         if (((i & 1) == 1) || (i == valueCapacity)) {\n-          assertFalse(\"unexpected cleared bit at index: \" + i, accessor.isNull(i));\n+          assertFalse(\"unexpected cleared bit at index: \" + i, vector.isNull(i));\n         }\n         else {\n-          assertTrue(\"unexpected set bit at index: \" + i, accessor.isNull(i));\n+          assertTrue(\"unexpected set bit at index: \" + i, vector.isNull(i));\n         }\n       }\n \n       /* trigger second realloc */\n-      mutator.setSafe(valueCapacity*2, 1, 1);\n+      vector.setSafe(valueCapacity*2, 1, 1);\n       assertEquals(valueCapacity * 4, vector.getValueCapacity());\n \n       for (int i = valueCapacity*2; i < valueCapacity*4; i++) {\n         if ((i & 1) == 1) {\n-          mutator.set(i, 1);\n+          vector.set(i, 1);\n         }\n       }\n \n       for (int i = 0; i < valueCapacity*4; i++) {\n         if (((i & 1) == 1) || (i == valueCapacity) || (i == valueCapacity*2)) {\n-          assertFalse(\"unexpected cleared bit at index: \" + i, accessor.isNull(i));\n+          assertFalse(\"unexpected cleared bit at index: \" + i, vector.isNull(i));\n         }\n         else {\n-          assertTrue(\"unexpected set bit at index: \" + i, accessor.isNull(i));\n+          assertTrue(\"unexpected set bit at index: \" + i, vector.isNull(i));\n         }\n       }\n \n@@ -400,26 +397,24 @@ public void testReallocAfterVectorTransfer2() {\n       TransferPair transferPair = vector.getTransferPair(allocator);\n       transferPair.transfer();\n       final NullableBitVector toVector = (NullableBitVector)transferPair.getTo();\n-      final NullableBitVector.Accessor toAccessor = toVector.getAccessor();\n-      final NullableBitVector.Mutator toMutator = toVector.getMutator();\n \n       assertEquals(valueCapacity * 4, toVector.getValueCapacity());\n \n       /* realloc the toVector */\n-      toMutator.setSafe(valueCapacity * 4, 1, 1);\n+      toVector.setSafe(valueCapacity * 4, 1, 1);\n \n       for (int i = 0; i < toVector.getValueCapacity(); i++) {\n         if (i <= valueCapacity * 4) {\n           if (((i & 1) == 1) || (i == valueCapacity) ||\n                   (i == valueCapacity*2) || (i == valueCapacity*4)) {\n-            assertFalse(\"unexpected cleared bit at index: \" + i, toAccessor.isNull(i));\n+            assertFalse(\"unexpected cleared bit at index: \" + i, toVector.isNull(i));\n           }\n           else {\n-            assertTrue(\"unexpected set bit at index: \" + i, toAccessor.isNull(i));\n+            assertTrue(\"unexpected set bit at index: \" + i, toVector.isNull(i));\n           }\n         }\n         else {\n-          assertTrue(\"unexpected set bit at index: \" + i, toAccessor.isNull(i));\n+          assertTrue(\"unexpected set bit at index: \" + i, toVector.isNull(i));\n         }\n       }\n \ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestBufferOwnershipTransfer.java b/java/vector/src/test/java/org/apache/arrow/vector/TestBufferOwnershipTransfer.java\nindex 1a801a63e..4fe286145 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestBufferOwnershipTransfer.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestBufferOwnershipTransfer.java\n@@ -40,7 +40,7 @@ public void testTransferFixedWidth() {\n \n     NullableIntVector v1 = new NullableIntVector(\"v1\", childAllocator1);\n     v1.allocateNew();\n-    v1.getMutator().setValueCount(4095);\n+    v1.setValueCount(4095);\n \n     NullableIntVector v2 = new NullableIntVector(\"v2\", childAllocator2);\n \n@@ -60,8 +60,8 @@ public void testTransferVariableidth() {\n \n     NullableVarCharVector v1 = new NullableVarCharVector(\"v1\", childAllocator1);\n     v1.allocateNew();\n-    v1.getMutator().setSafe(4094, \"hello world\".getBytes(), 0, 11);\n-    v1.getMutator().setValueCount(4001);\n+    v1.setSafe(4094, \"hello world\".getBytes(), 0, 11);\n+    v1.setValueCount(4001);\n \n     NullableVarCharVector v2 = new NullableVarCharVector(\"v2\", childAllocator2);\n \ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestDecimalVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestDecimalVector.java\nindex 56d229327..4d844d6d3 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestDecimalVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestDecimalVector.java\n@@ -71,14 +71,14 @@ public void testValuesWriteRead() {\n       for (int i = 0; i < intValues.length; i++) {\n         BigDecimal decimal = new BigDecimal(BigInteger.valueOf(intValues[i]), scale);\n         values[i] = decimal;\n-        decimalVector.getMutator().setSafe(i, decimal);\n+        decimalVector.setSafe(i, decimal);\n       }\n \n-      decimalVector.getMutator().setValueCount(intValues.length);\n+      decimalVector.setValueCount(intValues.length);\n \n       for (int i = 0; i < intValues.length; i++) {\n-        BigDecimal value = decimalVector.getAccessor().getObject(i);\n-        assertEquals(values[i], value);\n+        BigDecimal value = decimalVector.getObject(i);\n+        assertEquals(\"unexpected data at index: \" + i, values[i], value);\n       }\n     }\n   }\n@@ -92,7 +92,7 @@ public void testBigDecimalDifferentScaleAndPrecision() {\n       boolean hasError = false;\n       try {\n         BigDecimal decimal = new BigDecimal(BigInteger.valueOf(0), 3);\n-        decimalVector.getMutator().setSafe(0, decimal);\n+        decimalVector.setSafe(0, decimal);\n       } catch (UnsupportedOperationException ue) {\n         hasError = true;\n       } finally {\n@@ -103,7 +103,7 @@ public void testBigDecimalDifferentScaleAndPrecision() {\n       hasError = false;\n       try {\n         BigDecimal decimal = new BigDecimal(BigInteger.valueOf(12345), 2);\n-        decimalVector.getMutator().setSafe(0, decimal);\n+        decimalVector.setSafe(0, decimal);\n       } catch (UnsupportedOperationException ue) {\n         hasError = true;\n       } finally {\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestDictionaryVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestDictionaryVector.java\nindex f8c16e7fc..46a2bafa0 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestDictionaryVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestDictionaryVector.java\n@@ -56,24 +56,22 @@ public void testEncodeStrings() {\n     // Create a new value vector\n     try (final NullableVarCharVector vector = newNullableVarCharVector(\"foo\", allocator);\n          final NullableVarCharVector dictionaryVector = newNullableVarCharVector(\"dict\", allocator);) {\n-      final NullableVarCharVector.Mutator m = vector.getMutator();\n       vector.allocateNew(512, 5);\n \n       // set some values\n-      m.setSafe(0, zero, 0, zero.length);\n-      m.setSafe(1, one, 0, one.length);\n-      m.setSafe(2, one, 0, one.length);\n-      m.setSafe(3, two, 0, two.length);\n-      m.setSafe(4, zero, 0, zero.length);\n-      m.setValueCount(5);\n+      vector.setSafe(0, zero, 0, zero.length);\n+      vector.setSafe(1, one, 0, one.length);\n+      vector.setSafe(2, one, 0, one.length);\n+      vector.setSafe(3, two, 0, two.length);\n+      vector.setSafe(4, zero, 0, zero.length);\n+      vector.setValueCount(5);\n \n       // set some dictionary values\n-      final NullableVarCharVector.Mutator m2 = dictionaryVector.getMutator();\n       dictionaryVector.allocateNew(512, 3);\n-      m2.setSafe(0, zero, 0, zero.length);\n-      m2.setSafe(1, one, 0, one.length);\n-      m2.setSafe(2, two, 0, two.length);\n-      m2.setValueCount(3);\n+      dictionaryVector.setSafe(0, zero, 0, zero.length);\n+      dictionaryVector.setSafe(1, one, 0, one.length);\n+      dictionaryVector.setSafe(2, two, 0, two.length);\n+      dictionaryVector.setValueCount(3);\n \n       Dictionary dictionary = new Dictionary(dictionaryVector, new DictionaryEncoding(1L, false, null));\n \n@@ -81,20 +79,20 @@ public void testEncodeStrings() {\n         // verify indices\n         assertEquals(NullableIntVector.class, encoded.getClass());\n \n-        NullableIntVector.Accessor indexAccessor = ((NullableIntVector) encoded).getAccessor();\n-        assertEquals(5, indexAccessor.getValueCount());\n-        assertEquals(0, indexAccessor.get(0));\n-        assertEquals(1, indexAccessor.get(1));\n-        assertEquals(1, indexAccessor.get(2));\n-        assertEquals(2, indexAccessor.get(3));\n-        assertEquals(0, indexAccessor.get(4));\n+        NullableIntVector index = ((NullableIntVector)encoded);\n+        assertEquals(5, index.getValueCount());\n+        assertEquals(0, index.get(0));\n+        assertEquals(1, index.get(1));\n+        assertEquals(1, index.get(2));\n+        assertEquals(2, index.get(3));\n+        assertEquals(0, index.get(4));\n \n         // now run through the decoder and verify we get the original back\n         try (ValueVector decoded = DictionaryEncoder.decode(encoded, dictionary)) {\n           assertEquals(vector.getClass(), decoded.getClass());\n-          assertEquals(vector.getAccessor().getValueCount(), decoded.getAccessor().getValueCount());\n+          assertEquals(vector.getValueCount(), ((NullableVarCharVector)decoded).getValueCount());\n           for (int i = 0; i < 5; i++) {\n-            assertEquals(vector.getAccessor().getObject(i), decoded.getAccessor().getObject(i));\n+            assertEquals(vector.getObject(i), ((NullableVarCharVector)decoded).getObject(i));\n           }\n         }\n       }\n@@ -106,21 +104,20 @@ public void testEncodeLargeVector() {\n     // Create a new value vector\n     try (final NullableVarCharVector vector = newNullableVarCharVector(\"foo\", allocator);\n          final NullableVarCharVector dictionaryVector = newNullableVarCharVector(\"dict\", allocator);) {\n-      final NullableVarCharVector.Mutator m = vector.getMutator();\n       vector.allocateNew();\n \n       int count = 10000;\n \n       for (int i = 0; i < 10000; ++i) {\n-        vector.getMutator().setSafe(i, data[i % 3], 0, data[i % 3].length);\n+        vector.setSafe(i, data[i % 3], 0, data[i % 3].length);\n       }\n-      vector.getMutator().setValueCount(count);\n+      vector.setValueCount(count);\n \n       dictionaryVector.allocateNew(512, 3);\n-      dictionaryVector.getMutator().setSafe(0, zero, 0, zero.length);\n-      dictionaryVector.getMutator().setSafe(1, one, 0, one.length);\n-      dictionaryVector.getMutator().setSafe(2, two, 0, two.length);\n-      dictionaryVector.getMutator().setValueCount(3);\n+      dictionaryVector.setSafe(0, zero, 0, zero.length);\n+      dictionaryVector.setSafe(1, one, 0, one.length);\n+      dictionaryVector.setSafe(2, two, 0, two.length);\n+      dictionaryVector.setValueCount(3);\n \n       Dictionary dictionary = new Dictionary(dictionaryVector, new DictionaryEncoding(1L, false, null));\n \n@@ -129,18 +126,18 @@ public void testEncodeLargeVector() {\n         // verify indices\n         assertEquals(NullableIntVector.class, encoded.getClass());\n \n-        NullableIntVector.Accessor indexAccessor = ((NullableIntVector) encoded).getAccessor();\n-        assertEquals(count, indexAccessor.getValueCount());\n+        NullableIntVector index = ((NullableIntVector) encoded);\n+        assertEquals(count, index.getValueCount());\n         for (int i = 0; i < count; ++i) {\n-          assertEquals(i % 3, indexAccessor.get(i));\n+          assertEquals(i % 3, index.get(i));\n         }\n \n         // now run through the decoder and verify we get the original back\n         try (ValueVector decoded = DictionaryEncoder.decode(encoded, dictionary)) {\n           assertEquals(vector.getClass(), decoded.getClass());\n-          assertEquals(vector.getAccessor().getValueCount(), decoded.getAccessor().getValueCount());\n+          assertEquals(vector.getValueCount(), decoded.getValueCount());\n           for (int i = 0; i < count; ++i) {\n-            assertEquals(vector.getAccessor().getObject(i), decoded.getAccessor().getObject(i));\n+            assertEquals(vector.getObject(i), decoded.getObject(i));\n           }\n         }\n       }\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestFixedSizeListVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestFixedSizeListVector.java\nindex 43d9387b1..2af6cd53a 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestFixedSizeListVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestFixedSizeListVector.java\n@@ -54,15 +54,14 @@ public void terminate() throws Exception {\n   public void testIntType() {\n     try (FixedSizeListVector vector = FixedSizeListVector.empty(\"list\", 2, allocator)) {\n       NullableIntVector nested = (NullableIntVector) vector.addOrGetVector(FieldType.nullable(MinorType.INT.getType())).getVector();\n-      NullableIntVector.Mutator mutator = nested.getMutator();\n       vector.allocateNew();\n \n       for (int i = 0; i < 10; i++) {\n-        vector.getMutator().setNotNull(i);\n-        mutator.set(i * 2, i);\n-        mutator.set(i * 2 + 1, i + 10);\n+        vector.setNotNull(i);\n+        nested.set(i * 2, i);\n+        nested.set(i * 2 + 1, i + 10);\n       }\n-      vector.getMutator().setValueCount(10);\n+      vector.setValueCount(10);\n \n       UnionFixedSizeListReader reader = vector.getReader();\n       for (int i = 0; i < 10; i++) {\n@@ -82,17 +81,16 @@ public void testIntType() {\n   public void testFloatTypeNullable() {\n     try (FixedSizeListVector vector = FixedSizeListVector.empty(\"list\", 2, allocator)) {\n       NullableFloat4Vector nested = (NullableFloat4Vector) vector.addOrGetVector(FieldType.nullable(MinorType.FLOAT4.getType())).getVector();\n-      NullableFloat4Vector.Mutator mutator = nested.getMutator();\n       vector.allocateNew();\n \n       for (int i = 0; i < 10; i++) {\n         if (i % 2 == 0) {\n-          vector.getMutator().setNotNull(i);\n-          mutator.set(i * 2, i + 0.1f);\n-          mutator.set(i * 2 + 1, i + 10.1f);\n+          vector.setNotNull(i);\n+          nested.set(i * 2, i + 0.1f);\n+          nested.set(i * 2 + 1, i + 10.1f);\n         }\n       }\n-      vector.getMutator().setValueCount(10);\n+      vector.setValueCount(10);\n \n       UnionFixedSizeListReader reader = vector.getReader();\n       for (int i = 0; i < 10; i++) {\n@@ -116,24 +114,22 @@ public void testFloatTypeNullable() {\n   @Test\n   public void testNestedInList() {\n     try (ListVector vector = ListVector.empty(\"list\", allocator)) {\n-      ListVector.Mutator mutator = vector.getMutator();\n       FixedSizeListVector tuples = (FixedSizeListVector) vector.addOrGetVector(FieldType.nullable(new ArrowType.FixedSizeList(2))).getVector();\n-      FixedSizeListVector.Mutator tupleMutator = tuples.getMutator();\n-      NullableIntVector.Mutator innerMutator = (NullableIntVector.Mutator) tuples.addOrGetVector(FieldType.nullable(MinorType.INT.getType())).getVector().getMutator();\n+      NullableIntVector innerVector = (NullableIntVector) tuples.addOrGetVector(FieldType.nullable(MinorType.INT.getType())).getVector();\n       vector.allocateNew();\n \n       for (int i = 0; i < 10; i++) {\n         if (i % 2 == 0) {\n-          int position = mutator.startNewValue(i);\n+          int position = vector.startNewValue(i);\n           for (int j = 0; j < i % 7; j++) {\n-            tupleMutator.setNotNull(position + j);\n-            innerMutator.set((position + j) * 2, j);\n-            innerMutator.set((position + j) * 2 + 1, j + 1);\n+            tuples.setNotNull(position + j);\n+            innerVector.set((position + j) * 2, j);\n+            innerVector.set((position + j) * 2 + 1, j + 1);\n           }\n-          mutator.endValue(i, i % 7);\n+          vector.endValue(i, i % 7);\n         }\n       }\n-      mutator.setValueCount(10);\n+      vector.setValueCount(10);\n \n       UnionListReader reader = vector.getReader();\n       for (int i = 0; i < 10; i++) {\n@@ -162,24 +158,24 @@ public void testTransferPair() {\n     try (FixedSizeListVector from = new FixedSizeListVector(\"from\", allocator, 2, null, null);\n          FixedSizeListVector to = new FixedSizeListVector(\"to\", allocator, 2, null, null)) {\n       NullableFloat4Vector nested = (NullableFloat4Vector) from.addOrGetVector(FieldType.nullable(MinorType.FLOAT4.getType())).getVector();\n-      NullableFloat4Vector.Mutator mutator = nested.getMutator();\n       from.allocateNew();\n \n       for (int i = 0; i < 10; i++) {\n         if (i % 2 == 0) {\n-          from.getMutator().setNotNull(i);\n-          mutator.set(i * 2, i + 0.1f);\n-          mutator.set(i * 2 + 1, i + 10.1f);\n+          from.setNotNull(i);\n+          nested.set(i * 2, i + 0.1f);\n+          nested.set(i * 2 + 1, i + 10.1f);\n         }\n       }\n-      from.getMutator().setValueCount(10);\n+      from.setValueCount(10);\n \n       TransferPair pair = from.makeTransferPair(to);\n \n       pair.copyValueSafe(0, 1);\n       pair.copyValueSafe(2, 2);\n       to.copyFromSafe(4, 3, from);\n-      to.getMutator().setValueCount(10);\n+\n+      to.setValueCount(10);\n \n       UnionFixedSizeListReader reader = to.getReader();\n \ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestListVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestListVector.java\nindex 59e1646e8..f6aa86a30 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestListVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestListVector.java\n@@ -85,7 +85,7 @@ public void testCopyFrom() throws Exception {\n       for (int i = 0; i < 3; i++) {\n         outVector.copyFrom(i, i, inVector);\n       }\n-      outVector.getMutator().setValueCount(3);\n+      outVector.setValueCount(3);\n \n       // assert the output vector is correct\n       FieldReader reader = outVector.getReader();\n@@ -95,11 +95,9 @@ public void testCopyFrom() throws Exception {\n       reader.setPosition(2);\n       Assert.assertTrue(\"shouldn't be null\", reader.isSet());\n \n-      /* check the exact contents of vector */\n-      final ListVector.Accessor accessor = outVector.getAccessor();\n \n       /* index 0 */\n-      Object result = accessor.getObject(0);\n+      Object result = outVector.getObject(0);\n       ArrayList<Long> resultSet = (ArrayList<Long>) result;\n       assertEquals(3, resultSet.size());\n       assertEquals(new Long(1), (Long) resultSet.get(0));\n@@ -107,11 +105,11 @@ public void testCopyFrom() throws Exception {\n       assertEquals(new Long(3), (Long) resultSet.get(2));\n \n       /* index 1 */\n-      result = accessor.getObject(1);\n+      result = outVector.getObject(1);\n       assertNull(result);\n \n       /* index 2 */\n-      result = accessor.getObject(2);\n+      result = outVector.getObject(2);\n       resultSet = (ArrayList<Long>) result;\n       assertEquals(0, resultSet.size());\n     }\n@@ -128,46 +126,46 @@ public void testSetLastSetUsage() throws Exception {\n       /* allocate memory */\n       listVector.allocateNew();\n \n-      /* get inner vectors; bitVector and offsetVector */\n-      List<BufferBacked> innerVectors = listVector.getFieldInnerVectors();\n-      BitVector bitVector = (BitVector) innerVectors.get(0);\n-      UInt4Vector offsetVector = (UInt4Vector) innerVectors.get(1);\n+      /* get inner buffers; validityBuffer and offsetBuffer */\n+\n+      ArrowBuf validityBuffer = listVector.getValidityBuffer();\n+      ArrowBuf offsetBuffer = listVector.getOffsetBuffer();\n \n       /* get the underlying data vector -- NullableBigIntVector */\n       NullableBigIntVector dataVector = (NullableBigIntVector) listVector.getDataVector();\n \n       /* check current lastSet */\n-      assertEquals(Integer.toString(0), Integer.toString(listVector.getMutator().getLastSet()));\n+      assertEquals(Integer.toString(0), Integer.toString(listVector.getLastSet()));\n \n       int index = 0;\n       int offset = 0;\n \n-      /* write [10, 11, 12] to the list vector at index */\n-      bitVector.getMutator().setSafe(index, 1);\n-      dataVector.getMutator().setSafe(0, 1, 10);\n-      dataVector.getMutator().setSafe(1, 1, 11);\n-      dataVector.getMutator().setSafe(2, 1, 12);\n-      offsetVector.getMutator().setSafe(index + 1, 3);\n+      /* write [10, 11, 12] to the list vector at index 0 */\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      dataVector.setSafe(0, 1, 10);\n+      dataVector.setSafe(1, 1, 11);\n+      dataVector.setSafe(2, 1, 12);\n+      offsetBuffer.setInt((index + 1) * ListVector.OFFSET_WIDTH, 3);\n \n       index += 1;\n \n       /* write [13, 14] to the list vector at index 1 */\n-      bitVector.getMutator().setSafe(index, 1);\n-      dataVector.getMutator().setSafe(3, 1, 13);\n-      dataVector.getMutator().setSafe(4, 1, 14);\n-      offsetVector.getMutator().setSafe(index + 1, 5);\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      dataVector.setSafe(3, 1, 13);\n+      dataVector.setSafe(4, 1, 14);\n+      offsetBuffer.setInt((index + 1) * ListVector.OFFSET_WIDTH, 5);\n \n       index += 1;\n \n       /* write [15, 16, 17] to the list vector at index 2 */\n-      bitVector.getMutator().setSafe(index, 1);\n-      dataVector.getMutator().setSafe(5, 1, 15);\n-      dataVector.getMutator().setSafe(6, 1, 16);\n-      dataVector.getMutator().setSafe(7, 1, 17);\n-      offsetVector.getMutator().setSafe(index + 1, 8);\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      dataVector.setSafe(5, 1, 15);\n+      dataVector.setSafe(6, 1, 16);\n+      dataVector.setSafe(7, 1, 17);\n+      offsetBuffer.setInt((index + 1) * ListVector.OFFSET_WIDTH, 8);\n \n       /* check current lastSet */\n-      assertEquals(Integer.toString(0), Integer.toString(listVector.getMutator().getLastSet()));\n+      assertEquals(Integer.toString(0), Integer.toString(listVector.getLastSet()));\n \n       /* set lastset and arbitrary valuecount for list vector.\n        *\n@@ -208,54 +206,50 @@ public void testSetLastSetUsage() throws Exception {\n        *                [15, 16, 17]\n        *              }\n        */\n-      listVector.getMutator().setLastSet(3);\n-      listVector.getMutator().setValueCount(10);\n-\n-      /* check the vector output */\n-      final UInt4Vector.Accessor offsetAccessor = offsetVector.getAccessor();\n-      final ValueVector.Accessor valueAccessor = dataVector.getAccessor();\n+      listVector.setLastSet(3);\n+      listVector.setValueCount(10);\n \n       index = 0;\n-      offset = offsetAccessor.get(index);\n+      offset = offsetBuffer.getInt(index * ListVector.OFFSET_WIDTH);\n       assertEquals(Integer.toString(0), Integer.toString(offset));\n \n-      Object actual = valueAccessor.getObject(offset);\n+      Object actual = dataVector.getObject(offset);\n       assertEquals(new Long(10), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(11), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(12), (Long) actual);\n \n       index++;\n-      offset = offsetAccessor.get(index);\n+      offset = offsetBuffer.getInt(index * ListVector.OFFSET_WIDTH);\n       assertEquals(Integer.toString(3), Integer.toString(offset));\n \n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(13), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(14), (Long) actual);\n \n       index++;\n-      offset = offsetAccessor.get(index);\n+      offset = offsetBuffer.getInt(index * ListVector.OFFSET_WIDTH);\n       assertEquals(Integer.toString(5), Integer.toString(offset));\n \n-      actual = valueAccessor.getObject(offsetAccessor.get(index));\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(15), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(16), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(17), (Long) actual);\n \n       index++;\n-      offset = offsetAccessor.get(index);\n+      offset = offsetBuffer.getInt(index * ListVector.OFFSET_WIDTH);\n       assertEquals(Integer.toString(8), Integer.toString(offset));\n \n-      actual = valueAccessor.getObject(offsetAccessor.get(index));\n+      actual = dataVector.getObject(offset);\n       assertNull(actual);\n     }\n   }\n@@ -308,99 +302,97 @@ public void testSplitAndTransfer() throws Exception {\n       listWriter.bigInt().writeBigInt(23);\n       listWriter.endList();\n \n-      listVector.getMutator().setValueCount(5);\n+      listVector.setValueCount(5);\n \n-      assertEquals(5, listVector.getMutator().getLastSet());\n+      assertEquals(5, listVector.getLastSet());\n \n-      /* get offsetVector */\n-      UInt4Vector offsetVector = (UInt4Vector) listVector.getOffsetVector();\n+      /* get offset buffer */\n+      final ArrowBuf offsetBuffer = listVector.getOffsetBuffer();\n \n       /* get dataVector */\n       NullableBigIntVector dataVector = (NullableBigIntVector) listVector.getDataVector();\n \n       /* check the vector output */\n-      final UInt4Vector.Accessor offsetAccessor = offsetVector.getAccessor();\n-      final ValueVector.Accessor valueAccessor = dataVector.getAccessor();\n \n       int index = 0;\n       int offset = 0;\n       Object actual = null;\n \n       /* index 0 */\n-      assertFalse(listVector.getAccessor().isNull(index));\n-      offset = offsetAccessor.get(index);\n+      assertFalse(listVector.isNull(index));\n+      offset = offsetBuffer.getInt(index * ListVector.OFFSET_WIDTH);\n       assertEquals(Integer.toString(0), Integer.toString(offset));\n \n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(10), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(11), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(12), (Long) actual);\n \n       /* index 1 */\n       index++;\n-      assertFalse(listVector.getAccessor().isNull(index));\n-      offset = offsetAccessor.get(index);\n+      assertFalse(listVector.isNull(index));\n+      offset = offsetBuffer.getInt(index * ListVector.OFFSET_WIDTH);\n       assertEquals(Integer.toString(3), Integer.toString(offset));\n \n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(13), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(14), (Long) actual);\n \n       /* index 2 */\n       index++;\n-      assertFalse(listVector.getAccessor().isNull(index));\n-      offset = offsetAccessor.get(index);\n+      assertFalse(listVector.isNull(index));\n+      offset = offsetBuffer.getInt(index * ListVector.OFFSET_WIDTH);\n       assertEquals(Integer.toString(5), Integer.toString(offset));\n \n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(15), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(16), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(17), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(18), (Long) actual);\n \n       /* index 3 */\n       index++;\n-      assertFalse(listVector.getAccessor().isNull(index));\n-      offset = offsetAccessor.get(index);\n+      assertFalse(listVector.isNull(index));\n+      offset = offsetBuffer.getInt(index * ListVector.OFFSET_WIDTH);\n       assertEquals(Integer.toString(9), Integer.toString(offset));\n \n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(19), (Long) actual);\n \n       /* index 4 */\n       index++;\n-      assertFalse(listVector.getAccessor().isNull(index));\n-      offset = offsetAccessor.get(index);\n+      assertFalse(listVector.isNull(index));\n+      offset = offsetBuffer.getInt(index * ListVector.OFFSET_WIDTH);\n       assertEquals(Integer.toString(10), Integer.toString(offset));\n \n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(20), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(21), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(22), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(23), (Long) actual);\n \n       /* index 5 */\n       index++;\n-      assertTrue(listVector.getAccessor().isNull(index));\n-      offset = offsetAccessor.get(index);\n+      assertTrue(listVector.isNull(index));\n+      offset = offsetBuffer.getInt(index * ListVector.OFFSET_WIDTH);\n       assertEquals(Integer.toString(14), Integer.toString(offset));\n \n       /* do split and transfer */\n@@ -423,26 +415,26 @@ public void testSplitAndTransfer() throws Exception {\n           transferPair.splitAndTransfer(start, splitLength);\n \n           /* get offsetVector of toVector */\n-          UInt4Vector offsetVector1 = (UInt4Vector) toVector.getOffsetVector();\n-          UInt4Vector.Accessor offsetAccessor1 = offsetVector1.getAccessor();\n+          final ArrowBuf toOffsetBuffer = toVector.getOffsetBuffer();\n \n           /* get dataVector of toVector */\n           NullableBigIntVector dataVector1 = (NullableBigIntVector) toVector.getDataVector();\n-          NullableBigIntVector.Accessor valueAccessor1 = dataVector1.getAccessor();\n \n           for (int i = 0; i < splitLength; i++) {\n-            dataLength1 = offsetAccessor.get(start + i + 1) - offsetAccessor.get(start + i);\n-            dataLength2 = offsetAccessor1.get(i + 1) - offsetAccessor1.get(i);\n+            dataLength1 = offsetBuffer.getInt((start + i + 1) * ListVector.OFFSET_WIDTH) -\n+                    offsetBuffer.getInt((start + i) * ListVector.OFFSET_WIDTH);\n+            dataLength2 = toOffsetBuffer.getInt((i + 1) * ListVector.OFFSET_WIDTH)\n+                    - toOffsetBuffer.getInt(i * ListVector.OFFSET_WIDTH);\n \n             assertEquals(\"Different data lengths at index: \" + i + \" and start: \" + start,\n                     dataLength1, dataLength2);\n \n-            offset1 = offsetAccessor.get(start + i);\n-            offset2 = offsetAccessor1.get(i);\n+            offset1 = offsetBuffer.getInt((start + i) * ListVector.OFFSET_WIDTH);\n+            offset2 = toOffsetBuffer.getInt(i * ListVector.OFFSET_WIDTH);\n \n             for (int j = 0; j < dataLength1; j++) {\n               assertEquals(\"Different data at indexes: \" + offset1 + \" and \" + offset2,\n-                      valueAccessor.getObject(offset1), valueAccessor1.getObject(offset2));\n+                      dataVector.getObject(offset1), dataVector1.getObject(offset2));\n \n               offset1++;\n               offset2++;\n@@ -506,15 +498,14 @@ public void testNestedListVector() throws Exception {\n \n       listWriter.endList();\n \n-      assertEquals(2, listVector.getMutator().getLastSet());\n+      assertEquals(2, listVector.getLastSet());\n \n-      listVector.getMutator().setValueCount(2);\n+      listVector.setValueCount(2);\n \n-      final ListVector.Accessor accessor = listVector.getAccessor();\n-      assertEquals(2, accessor.getValueCount());\n+      assertEquals(2, listVector.getValueCount());\n \n       /* get listVector value at index 0 -- the value itself is a listvector */\n-      Object result = accessor.getObject(0);\n+      Object result = listVector.getObject(0);\n       ArrayList<ArrayList<Long>> resultSet = (ArrayList<ArrayList<Long>>) result;\n       ArrayList<Long> list;\n \n@@ -534,7 +525,7 @@ public void testNestedListVector() throws Exception {\n       assertEquals(new Long(175), list.get(3));\n \n        /* get listVector value at index 1 -- the value itself is a listvector */\n-      result = accessor.getObject(1);\n+      result = listVector.getObject(1);\n       resultSet = (ArrayList<ArrayList<Long>>) result;\n \n       assertEquals(3, resultSet.size());              /* 3 inner lists at index 1 */\n@@ -555,17 +546,16 @@ public void testNestedListVector() throws Exception {\n       assertEquals(new Long(35), list.get(2));\n \n       /* check underlying bitVector */\n-      assertFalse(accessor.isNull(0));\n-      assertFalse(accessor.isNull(1));\n+      assertFalse(listVector.isNull(0));\n+      assertFalse(listVector.isNull(1));\n \n-      /* check underlying offsetVector */\n-      UInt4Vector offsetVector = listVector.getOffsetVector();\n-      final UInt4Vector.Accessor offsetAccessor = offsetVector.getAccessor();\n+      /* check underlying offsets */\n+      final ArrowBuf offsetBuffer = listVector.getOffsetBuffer();\n \n       /* listVector has 2 lists at index 0 and 3 lists at index 1 */\n-      assertEquals(0, offsetAccessor.get(0));\n-      assertEquals(2, offsetAccessor.get(1));\n-      assertEquals(5, offsetAccessor.get(2));\n+      assertEquals(0, offsetBuffer.getInt(0 * ListVector.OFFSET_WIDTH));\n+      assertEquals(2, offsetBuffer.getInt(1 * ListVector.OFFSET_WIDTH));\n+      assertEquals(5, offsetBuffer.getInt(2 * ListVector.OFFSET_WIDTH));\n     }\n   }\n \n@@ -591,17 +581,15 @@ public void testGetBufferAddress() throws Exception {\n       listWriter.bigInt().writeBigInt(300);\n       listWriter.endList();\n \n-      final ListVector.Accessor accessor = listVector.getAccessor();\n-\n       /* check listVector contents */\n-      Object result = accessor.getObject(0);\n+      Object result = listVector.getObject(0);\n       ArrayList<Long> resultSet = (ArrayList<Long>) result;\n       assertEquals(3, resultSet.size());\n       assertEquals(new Long(50), resultSet.get(0));\n       assertEquals(new Long(100), resultSet.get(1));\n       assertEquals(new Long(200), resultSet.get(2));\n \n-      result = accessor.getObject(1);\n+      result = listVector.getObject(1);\n       resultSet = (ArrayList<Long>) result;\n       assertEquals(2, resultSet.size());\n       assertEquals(new Long(250), resultSet.get(0));\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestSplitAndTransfer.java b/java/vector/src/test/java/org/apache/arrow/vector/TestSplitAndTransfer.java\nindex 66e5375e3..7de3bcb33 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestSplitAndTransfer.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestSplitAndTransfer.java\n@@ -25,7 +25,6 @@\n import org.apache.arrow.memory.RootAllocator;\n \n import org.apache.arrow.vector.NullableVarCharVector;\n-import org.apache.arrow.vector.NullableVarCharVector.Accessor;\n import org.apache.arrow.vector.util.TransferPair;\n \n import org.junit.After;\n@@ -54,32 +53,30 @@ public void test() throws Exception {\n             final int valueCount = 500;\n             final String[] compareArray = new String[valueCount];\n \n-            final NullableVarCharVector.Mutator mutator = varCharVector.getMutator();\n             for (int i = 0; i < valueCount; i += 3) {\n                 final String s = String.format(\"%010d\", i);\n-                mutator.set(i, s.getBytes());\n+                varCharVector.set(i, s.getBytes());\n                 compareArray[i] = s;\n             }\n-            mutator.setValueCount(valueCount);\n+            varCharVector.setValueCount(valueCount);\n \n             final TransferPair tp = varCharVector.getTransferPair(allocator);\n             final NullableVarCharVector newVarCharVector = (NullableVarCharVector) tp.getTo();\n-            final Accessor accessor = newVarCharVector.getAccessor();\n             final int[][] startLengths = {{0, 201}, {201, 200}, {401, 99}};\n \n             for (final int[] startLength : startLengths) {\n                 final int start = startLength[0];\n                 final int length = startLength[1];\n                 tp.splitAndTransfer(start, length);\n-                newVarCharVector.getMutator().setValueCount(length);\n+                newVarCharVector.setValueCount(length);\n                 for (int i = 0; i < length; i++) {\n                     final boolean expectedSet = ((start + i) % 3) == 0;\n                     if (expectedSet) {\n                         final byte[] expectedValue = compareArray[start + i].getBytes();\n-                        assertFalse(accessor.isNull(i));\n-                        assertArrayEquals(expectedValue, accessor.get(i));\n+                        assertFalse(newVarCharVector.isNull(i));\n+                        assertArrayEquals(expectedValue, newVarCharVector.get(i));\n                     } else {\n-                        assertTrue(accessor.isNull(i));\n+                        assertTrue(newVarCharVector.isNull(i));\n                     }\n                 }\n                 newVarCharVector.clear();\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestUnionVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestUnionVector.java\nindex 86f0bf337..aec7d0f32 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestUnionVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestUnionVector.java\n@@ -20,6 +20,7 @@\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertFalse;\n \n import java.util.List;\n \n@@ -64,26 +65,24 @@ public void testUnionVector() throws Exception {\n       unionVector.allocateNew();\n \n       // write some data\n-      final UnionVector.Mutator mutator = unionVector.getMutator();\n-      mutator.setType(0, Types.MinorType.UINT4);\n-      mutator.setSafe(0, uInt4Holder);\n-      mutator.setType(2, Types.MinorType.UINT4);\n-      mutator.setSafe(2, uInt4Holder);\n-      mutator.setValueCount(4);\n+      unionVector.setType(0, Types.MinorType.UINT4);\n+      unionVector.setSafe(0, uInt4Holder);\n+      unionVector.setType(2, Types.MinorType.UINT4);\n+      unionVector.setSafe(2, uInt4Holder);\n+      unionVector.setValueCount(4);\n \n       // check that what we wrote is correct\n-      final UnionVector.Accessor accessor = unionVector.getAccessor();\n-      assertEquals(4, accessor.getValueCount());\n+      assertEquals(4, unionVector.getValueCount());\n \n-      assertEquals(false, accessor.isNull(0));\n-      assertEquals(100, accessor.getObject(0));\n+      assertEquals(false, unionVector.isNull(0));\n+      assertEquals(100, unionVector.getObject(0));\n \n-      assertEquals(true, accessor.isNull(1));\n+      assertEquals(true, unionVector.isNull(1));\n \n-      assertEquals(false, accessor.isNull(2));\n-      assertEquals(100, accessor.getObject(2));\n+      assertEquals(false, unionVector.isNull(2));\n+      assertEquals(100, unionVector.getObject(2));\n \n-      assertEquals(true, accessor.isNull(3));\n+      assertEquals(true, unionVector.isNull(3));\n     }\n   }\n \n@@ -93,16 +92,15 @@ public void testTransfer() throws Exception {\n       srcVector.allocateNew();\n \n       // write some data\n-      final UnionVector.Mutator mutator = srcVector.getMutator();\n-      mutator.setType(0, MinorType.INT);\n-      mutator.setSafe(0, newIntHolder(5));\n-      mutator.setType(1, MinorType.BIT);\n-      mutator.setSafe(1, newBitHolder(false));\n-      mutator.setType(3, MinorType.INT);\n-      mutator.setSafe(3, newIntHolder(10));\n-      mutator.setType(5, MinorType.BIT);\n-      mutator.setSafe(5, newBitHolder(false));\n-      mutator.setValueCount(6);\n+      srcVector.setType(0, MinorType.INT);\n+      srcVector.setSafe(0, newIntHolder(5));\n+      srcVector.setType(1, MinorType.BIT);\n+      srcVector.setSafe(1, newBitHolder(false));\n+      srcVector.setType(3, MinorType.INT);\n+      srcVector.setSafe(3, newIntHolder(10));\n+      srcVector.setType(5, MinorType.BIT);\n+      srcVector.setSafe(5, newBitHolder(false));\n+      srcVector.setValueCount(6);\n \n       try (UnionVector destVector = new UnionVector(EMPTY_SCHEMA_PATH, allocator, null)) {\n         TransferPair pair = srcVector.makeTransferPair(destVector);\n@@ -116,10 +114,23 @@ public void testTransfer() throws Exception {\n         assertEquals(srcVector.getField(), destVector.getField());\n \n         // now check the values are transferred\n-        assertEquals(srcVector.getAccessor().getValueCount(), destVector.getAccessor().getValueCount());\n-        for (int i = 0; i < srcVector.getAccessor().getValueCount(); i++) {\n-          assertEquals(\"Different values at index \" + i, srcVector.getAccessor().get(i), destVector.getAccessor().get(i));\n-        }\n+        assertEquals(6, destVector.getValueCount());\n+\n+        assertFalse(destVector.isNull(0));\n+        assertEquals(5, destVector.getObject(0));\n+\n+        assertFalse(destVector.isNull(1));\n+        assertEquals(false, destVector.getObject(1));\n+\n+        assertTrue(destVector.isNull(2));\n+\n+        assertFalse(destVector.isNull(3));\n+        assertEquals(10, destVector.getObject(3));\n+\n+        assertTrue(destVector.isNull(4));\n+\n+        assertFalse(destVector.isNull(5));\n+        assertEquals(false, destVector.getObject(5));\n       }\n     }\n   }\n@@ -127,61 +138,58 @@ public void testTransfer() throws Exception {\n   @Test\n   public void testSplitAndTransfer() throws Exception {\n     try (UnionVector sourceVector = new UnionVector(EMPTY_SCHEMA_PATH, allocator, null)) {\n-      final UnionVector.Mutator sourceMutator = sourceVector.getMutator();\n-      final UnionVector.Accessor sourceAccessor = sourceVector.getAccessor();\n \n       sourceVector.allocateNew();\n \n       /* populate the UnionVector */\n-      sourceMutator.setType(0, MinorType.INT);\n-      sourceMutator.setSafe(0, newIntHolder(5));\n-      sourceMutator.setType(1, MinorType.INT);\n-      sourceMutator.setSafe(1, newIntHolder(10));\n-      sourceMutator.setType(2, MinorType.INT);\n-      sourceMutator.setSafe(2, newIntHolder(15));\n-      sourceMutator.setType(3, MinorType.INT);\n-      sourceMutator.setSafe(3, newIntHolder(20));\n-      sourceMutator.setType(4, MinorType.INT);\n-      sourceMutator.setSafe(4, newIntHolder(25));\n-      sourceMutator.setType(5, MinorType.INT);\n-      sourceMutator.setSafe(5, newIntHolder(30));\n-      sourceMutator.setType(6, MinorType.INT);\n-      sourceMutator.setSafe(6, newIntHolder(35));\n-      sourceMutator.setType(7, MinorType.INT);\n-      sourceMutator.setSafe(7, newIntHolder(40));\n-      sourceMutator.setType(8, MinorType.INT);\n-      sourceMutator.setSafe(8, newIntHolder(45));\n-      sourceMutator.setType(9, MinorType.INT);\n-      sourceMutator.setSafe(9, newIntHolder(50));\n-      sourceMutator.setValueCount(10);\n+      sourceVector.setType(0, MinorType.INT);\n+      sourceVector.setSafe(0, newIntHolder(5));\n+      sourceVector.setType(1, MinorType.INT);\n+      sourceVector.setSafe(1, newIntHolder(10));\n+      sourceVector.setType(2, MinorType.INT);\n+      sourceVector.setSafe(2, newIntHolder(15));\n+      sourceVector.setType(3, MinorType.INT);\n+      sourceVector.setSafe(3, newIntHolder(20));\n+      sourceVector.setType(4, MinorType.INT);\n+      sourceVector.setSafe(4, newIntHolder(25));\n+      sourceVector.setType(5, MinorType.INT);\n+      sourceVector.setSafe(5, newIntHolder(30));\n+      sourceVector.setType(6, MinorType.INT);\n+      sourceVector.setSafe(6, newIntHolder(35));\n+      sourceVector.setType(7, MinorType.INT);\n+      sourceVector.setSafe(7, newIntHolder(40));\n+      sourceVector.setType(8, MinorType.INT);\n+      sourceVector.setSafe(8, newIntHolder(45));\n+      sourceVector.setType(9, MinorType.INT);\n+      sourceVector.setSafe(9, newIntHolder(50));\n+      sourceVector.setValueCount(10);\n \n       /* check the vector output */\n-      assertEquals(10, sourceAccessor.getValueCount());\n-      assertEquals(false, sourceAccessor.isNull(0));\n-      assertEquals(5, sourceAccessor.getObject(0));\n-      assertEquals(false, sourceAccessor.isNull(1));\n-      assertEquals(10, sourceAccessor.getObject(1));\n-      assertEquals(false, sourceAccessor.isNull(2));\n-      assertEquals(15, sourceAccessor.getObject(2));\n-      assertEquals(false, sourceAccessor.isNull(3));\n-      assertEquals(20, sourceAccessor.getObject(3));\n-      assertEquals(false, sourceAccessor.isNull(4));\n-      assertEquals(25, sourceAccessor.getObject(4));\n-      assertEquals(false, sourceAccessor.isNull(5));\n-      assertEquals(30, sourceAccessor.getObject(5));\n-      assertEquals(false, sourceAccessor.isNull(6));\n-      assertEquals(35, sourceAccessor.getObject(6));\n-      assertEquals(false, sourceAccessor.isNull(7));\n-      assertEquals(40, sourceAccessor.getObject(7));\n-      assertEquals(false, sourceAccessor.isNull(8));\n-      assertEquals(45, sourceAccessor.getObject(8));\n-      assertEquals(false, sourceAccessor.isNull(9));\n-      assertEquals(50, sourceAccessor.getObject(9));\n+      assertEquals(10, sourceVector.getValueCount());\n+      assertEquals(false, sourceVector.isNull(0));\n+      assertEquals(5, sourceVector.getObject(0));\n+      assertEquals(false, sourceVector.isNull(1));\n+      assertEquals(10, sourceVector.getObject(1));\n+      assertEquals(false, sourceVector.isNull(2));\n+      assertEquals(15, sourceVector.getObject(2));\n+      assertEquals(false, sourceVector.isNull(3));\n+      assertEquals(20, sourceVector.getObject(3));\n+      assertEquals(false, sourceVector.isNull(4));\n+      assertEquals(25, sourceVector.getObject(4));\n+      assertEquals(false, sourceVector.isNull(5));\n+      assertEquals(30, sourceVector.getObject(5));\n+      assertEquals(false, sourceVector.isNull(6));\n+      assertEquals(35, sourceVector.getObject(6));\n+      assertEquals(false, sourceVector.isNull(7));\n+      assertEquals(40, sourceVector.getObject(7));\n+      assertEquals(false, sourceVector.isNull(8));\n+      assertEquals(45, sourceVector.getObject(8));\n+      assertEquals(false, sourceVector.isNull(9));\n+      assertEquals(50, sourceVector.getObject(9));\n \n       try (UnionVector toVector = new UnionVector(EMPTY_SCHEMA_PATH, allocator, null)) {\n \n         final TransferPair transferPair = sourceVector.makeTransferPair(toVector);\n-        final UnionVector.Accessor toAccessor = toVector.getAccessor();\n \n         final int[][] transferLengths = {{0, 3},\n             {3, 1},\n@@ -199,8 +207,8 @@ public void testSplitAndTransfer() throws Exception {\n \n           /* check the toVector output after doing the splitAndTransfer */\n           for (int i = 0; i < length; i++) {\n-            assertEquals(\"Different data at indexes: \" + (start + i) + \"and \" + i, sourceAccessor.getObject(start + i),\n-                toAccessor.getObject(i));\n+            assertEquals(\"Different data at indexes: \" + (start + i) + \"and \" + i, sourceVector.getObject(start + i),\n+                toVector.getObject(i));\n           }\n         }\n       }\n@@ -210,70 +218,67 @@ public void testSplitAndTransfer() throws Exception {\n   @Test\n   public void testSplitAndTransferWithMixedVectors() throws Exception {\n     try (UnionVector sourceVector = new UnionVector(EMPTY_SCHEMA_PATH, allocator, null)) {\n-      final UnionVector.Mutator sourceMutator = sourceVector.getMutator();\n-      final UnionVector.Accessor sourceAccessor = sourceVector.getAccessor();\n \n       sourceVector.allocateNew();\n \n       /* populate the UnionVector */\n-      sourceMutator.setType(0, MinorType.INT);\n-      sourceMutator.setSafe(0, newIntHolder(5));\n+      sourceVector.setType(0, MinorType.INT);\n+      sourceVector.setSafe(0, newIntHolder(5));\n \n-      sourceMutator.setType(1, MinorType.FLOAT4);\n-      sourceMutator.setSafe(1, newFloat4Holder(5.5f));\n+      sourceVector.setType(1, MinorType.FLOAT4);\n+      sourceVector.setSafe(1, newFloat4Holder(5.5f));\n \n-      sourceMutator.setType(2, MinorType.INT);\n-      sourceMutator.setSafe(2, newIntHolder(10));\n+      sourceVector.setType(2, MinorType.INT);\n+      sourceVector.setSafe(2, newIntHolder(10));\n \n-      sourceMutator.setType(3, MinorType.FLOAT4);\n-      sourceMutator.setSafe(3, newFloat4Holder(10.5f));\n+      sourceVector.setType(3, MinorType.FLOAT4);\n+      sourceVector.setSafe(3, newFloat4Holder(10.5f));\n \n-      sourceMutator.setType(4, MinorType.INT);\n-      sourceMutator.setSafe(4, newIntHolder(15));\n+      sourceVector.setType(4, MinorType.INT);\n+      sourceVector.setSafe(4, newIntHolder(15));\n \n-      sourceMutator.setType(5, MinorType.FLOAT4);\n-      sourceMutator.setSafe(5, newFloat4Holder(15.5f));\n+      sourceVector.setType(5, MinorType.FLOAT4);\n+      sourceVector.setSafe(5, newFloat4Holder(15.5f));\n \n-      sourceMutator.setType(6, MinorType.INT);\n-      sourceMutator.setSafe(6, newIntHolder(20));\n+      sourceVector.setType(6, MinorType.INT);\n+      sourceVector.setSafe(6, newIntHolder(20));\n \n-      sourceMutator.setType(7, MinorType.FLOAT4);\n-      sourceMutator.setSafe(7, newFloat4Holder(20.5f));\n+      sourceVector.setType(7, MinorType.FLOAT4);\n+      sourceVector.setSafe(7, newFloat4Holder(20.5f));\n \n-      sourceMutator.setType(8, MinorType.INT);\n-      sourceMutator.setSafe(8, newIntHolder(30));\n+      sourceVector.setType(8, MinorType.INT);\n+      sourceVector.setSafe(8, newIntHolder(30));\n \n-      sourceMutator.setType(9, MinorType.FLOAT4);\n-      sourceMutator.setSafe(9, newFloat4Holder(30.5f));\n-      sourceMutator.setValueCount(10);\n+      sourceVector.setType(9, MinorType.FLOAT4);\n+      sourceVector.setSafe(9, newFloat4Holder(30.5f));\n+      sourceVector.setValueCount(10);\n \n       /* check the vector output */\n-      assertEquals(10, sourceAccessor.getValueCount());\n-      assertEquals(false, sourceAccessor.isNull(0));\n-      assertEquals(5, sourceAccessor.getObject(0));\n-      assertEquals(false, sourceAccessor.isNull(1));\n-      assertEquals(5.5f, sourceAccessor.getObject(1));\n-      assertEquals(false, sourceAccessor.isNull(2));\n-      assertEquals(10, sourceAccessor.getObject(2));\n-      assertEquals(false, sourceAccessor.isNull(3));\n-      assertEquals(10.5f, sourceAccessor.getObject(3));\n-      assertEquals(false, sourceAccessor.isNull(4));\n-      assertEquals(15, sourceAccessor.getObject(4));\n-      assertEquals(false, sourceAccessor.isNull(5));\n-      assertEquals(15.5f, sourceAccessor.getObject(5));\n-      assertEquals(false, sourceAccessor.isNull(6));\n-      assertEquals(20, sourceAccessor.getObject(6));\n-      assertEquals(false, sourceAccessor.isNull(7));\n-      assertEquals(20.5f, sourceAccessor.getObject(7));\n-      assertEquals(false, sourceAccessor.isNull(8));\n-      assertEquals(30, sourceAccessor.getObject(8));\n-      assertEquals(false, sourceAccessor.isNull(9));\n-      assertEquals(30.5f, sourceAccessor.getObject(9));\n+      assertEquals(10, sourceVector.getValueCount());\n+      assertEquals(false, sourceVector.isNull(0));\n+      assertEquals(5, sourceVector.getObject(0));\n+      assertEquals(false, sourceVector.isNull(1));\n+      assertEquals(5.5f, sourceVector.getObject(1));\n+      assertEquals(false, sourceVector.isNull(2));\n+      assertEquals(10, sourceVector.getObject(2));\n+      assertEquals(false, sourceVector.isNull(3));\n+      assertEquals(10.5f, sourceVector.getObject(3));\n+      assertEquals(false, sourceVector.isNull(4));\n+      assertEquals(15, sourceVector.getObject(4));\n+      assertEquals(false, sourceVector.isNull(5));\n+      assertEquals(15.5f, sourceVector.getObject(5));\n+      assertEquals(false, sourceVector.isNull(6));\n+      assertEquals(20, sourceVector.getObject(6));\n+      assertEquals(false, sourceVector.isNull(7));\n+      assertEquals(20.5f, sourceVector.getObject(7));\n+      assertEquals(false, sourceVector.isNull(8));\n+      assertEquals(30, sourceVector.getObject(8));\n+      assertEquals(false, sourceVector.isNull(9));\n+      assertEquals(30.5f, sourceVector.getObject(9));\n \n       try (UnionVector toVector = new UnionVector(EMPTY_SCHEMA_PATH, allocator, null)) {\n \n         final TransferPair transferPair = sourceVector.makeTransferPair(toVector);\n-        final UnionVector.Accessor toAccessor = toVector.getAccessor();\n \n         final int[][] transferLengths = {{0, 2},\n             {2, 1},\n@@ -290,7 +295,7 @@ public void testSplitAndTransferWithMixedVectors() throws Exception {\n \n           /* check the toVector output after doing the splitAndTransfer */\n           for (int i = 0; i < length; i++) {\n-            assertEquals(\"Different values at index: \" + i, sourceAccessor.getObject(start + i), toAccessor.getObject(i));\n+            assertEquals(\"Different values at index: \" + i, sourceVector.getObject(start + i), toVector.getObject(i));\n           }\n         }\n       }\n@@ -300,37 +305,35 @@ public void testSplitAndTransferWithMixedVectors() throws Exception {\n   @Test\n   public void testGetBufferAddress() throws Exception {\n     try (UnionVector vector = new UnionVector(EMPTY_SCHEMA_PATH, allocator, null)) {\n-      final UnionVector.Mutator mutator = vector.getMutator();\n-      final UnionVector.Accessor accessor = vector.getAccessor();\n       boolean error = false;\n \n       vector.allocateNew();\n \n       /* populate the UnionVector */\n-      mutator.setType(0, MinorType.INT);\n-      mutator.setSafe(0, newIntHolder(5));\n+      vector.setType(0, MinorType.INT);\n+      vector.setSafe(0, newIntHolder(5));\n \n-      mutator.setType(1, MinorType.FLOAT4);\n-      mutator.setSafe(1, newFloat4Holder(5.5f));\n+      vector.setType(1, MinorType.FLOAT4);\n+      vector.setSafe(1, newFloat4Holder(5.5f));\n \n-      mutator.setType(2, MinorType.INT);\n-      mutator.setSafe(2, newIntHolder(10));\n+      vector.setType(2, MinorType.INT);\n+      vector.setSafe(2, newIntHolder(10));\n \n-      mutator.setType(3, MinorType.FLOAT4);\n-      mutator.setSafe(3, newFloat4Holder(10.5f));\n+      vector.setType(3, MinorType.FLOAT4);\n+      vector.setSafe(3, newFloat4Holder(10.5f));\n \n-      mutator.setValueCount(10);\n+      vector.setValueCount(10);\n \n       /* check the vector output */\n-      assertEquals(10, accessor.getValueCount());\n-      assertEquals(false, accessor.isNull(0));\n-      assertEquals(5, accessor.getObject(0));\n-      assertEquals(false, accessor.isNull(1));\n-      assertEquals(5.5f, accessor.getObject(1));\n-      assertEquals(false, accessor.isNull(2));\n-      assertEquals(10, accessor.getObject(2));\n-      assertEquals(false, accessor.isNull(3));\n-      assertEquals(10.5f, accessor.getObject(3));\n+      assertEquals(10, vector.getValueCount());\n+      assertEquals(false, vector.isNull(0));\n+      assertEquals(5, vector.getObject(0));\n+      assertEquals(false, vector.isNull(1));\n+      assertEquals(5.5f, vector.getObject(1));\n+      assertEquals(false, vector.isNull(2));\n+      assertEquals(10, vector.getObject(2));\n+      assertEquals(false, vector.isNull(3));\n+      assertEquals(10.5f, vector.getObject(3));\n \n       List<ArrowBuf> buffers = vector.getFieldBuffers();\n \ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestValueVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestValueVector.java\nindex a239861d9..c7ee202f9 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestValueVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestValueVector.java\n@@ -487,8 +487,6 @@ public void testNullableFixedType1() {\n \n     // Create a new value vector for 1024 integers.\n     try (final NullableUInt4Vector vector = newVector(NullableUInt4Vector.class, EMPTY_SCHEMA_PATH, new ArrowType.Int(32, false), allocator);) {\n-      final NullableUInt4Vector.Mutator mutator = vector.getMutator();\n-      final NullableUInt4Vector.Accessor accessor = vector.getAccessor();\n       boolean error = false;\n       int initialCapacity = 1024;\n \n@@ -500,33 +498,33 @@ public void testNullableFixedType1() {\n       assertEquals(initialCapacity, vector.getValueCapacity());\n \n       // Put and set a few values\n-      mutator.set(0, 100);\n-      mutator.set(1, 101);\n-      mutator.set(100, 102);\n-      mutator.set(1022, 103);\n-      mutator.set(1023, 104);\n+      vector.set(0, 100);\n+      vector.set(1, 101);\n+      vector.set(100, 102);\n+      vector.set(1022, 103);\n+      vector.set(1023, 104);\n \n       /* check vector contents */\n-      assertEquals(100, accessor.get(0));\n-      assertEquals(101, accessor.get(1));\n-      assertEquals(102, accessor.get(100));\n-      assertEquals(103, accessor.get(1022));\n-      assertEquals(104, accessor.get(1023));\n+      assertEquals(100, vector.get(0));\n+      assertEquals(101, vector.get(1));\n+      assertEquals(102, vector.get(100));\n+      assertEquals(103, vector.get(1022));\n+      assertEquals(104, vector.get(1023));\n \n       int val = 0;\n \n       /* check unset bits/null values */\n       for (int i = 2, j = 101; i <= 99 || j <= 1021; i++, j++) {\n         if (i <= 99) {\n-          assertTrue(accessor.isNull(i));\n+          assertTrue(vector.isNull(i));\n         }\n         if(j <= 1021) {\n-          assertTrue(accessor.isNull(j));\n+          assertTrue(vector.isNull(j));\n         }\n       }\n \n       try {\n-        mutator.set(1024, 10000);\n+        vector.set(1024, 10000);\n       }\n       catch (IndexOutOfBoundsException ie) {\n         error = true;\n@@ -537,7 +535,7 @@ public void testNullableFixedType1() {\n       }\n \n       try {\n-        accessor.get(1024);\n+        vector.get(1024);\n       }\n       catch (IndexOutOfBoundsException ie) {\n         error = true;\n@@ -548,28 +546,28 @@ public void testNullableFixedType1() {\n       }\n \n       /* should trigger a realloc of the underlying bitvector and valuevector */\n-      mutator.setSafe(1024, 10000);\n+      vector.setSafe(1024, 10000);\n \n       /* check new capacity */\n       assertEquals(initialCapacity * 2, vector.getValueCapacity());\n \n       /* vector contents should still be intact after realloc */\n-      assertEquals(100, accessor.get(0));\n-      assertEquals(101, accessor.get(1));\n-      assertEquals(102, accessor.get(100));\n-      assertEquals(103, accessor.get(1022));\n-      assertEquals(104, accessor.get(1023));\n-      assertEquals(10000, accessor.get(1024));\n+      assertEquals(100, vector.get(0));\n+      assertEquals(101, vector.get(1));\n+      assertEquals(102, vector.get(100));\n+      assertEquals(103, vector.get(1022));\n+      assertEquals(104, vector.get(1023));\n+      assertEquals(10000, vector.get(1024));\n \n       val = 0;\n \n       /* check unset bits/null values */\n       for (int i = 2, j = 101; i < 99 || j < 1021; i++, j++) {\n         if (i <= 99) {\n-          assertTrue(accessor.isNull(i));\n+          assertTrue(vector.isNull(i));\n         }\n         if(j <= 1021) {\n-          assertTrue(accessor.isNull(j));\n+          assertTrue(vector.isNull(j));\n         }\n       }\n \n@@ -581,7 +579,7 @@ public void testNullableFixedType1() {\n \n       /* vector data should be zeroed out */\n       for(int i = 0; i < (initialCapacity * 2); i++) {\n-        assertTrue(\"non-null data not expected at index: \" + i, accessor.isNull(i));\n+        assertTrue(\"non-null data not expected at index: \" + i, vector.isNull(i));\n       }\n     }\n   }\n@@ -590,8 +588,6 @@ public void testNullableFixedType1() {\n   public void testNullableFixedType2() {\n     // Create a new value vector for 1024 integers\n     try (final NullableFloat4Vector vector = newVector(NullableFloat4Vector.class, EMPTY_SCHEMA_PATH, MinorType.FLOAT4, allocator);) {\n-      final NullableFloat4Vector.Mutator mutator = vector.getMutator();\n-      final NullableFloat4Vector.Accessor accessor = vector.getAccessor();\n       boolean error = false;\n       int initialCapacity = 16;\n \n@@ -603,17 +599,17 @@ public void testNullableFixedType2() {\n       assertEquals(initialCapacity, vector.getValueCapacity());\n \n       /* populate the vector */\n-      mutator.set(0, 100.5f);\n-      mutator.set(2, 201.5f);\n-      mutator.set(4, 300.3f);\n-      mutator.set(6, 423.8f);\n-      mutator.set(8, 555.6f);\n-      mutator.set(10, 66.6f);\n-      mutator.set(12, 78.8f);\n-      mutator.set(14, 89.5f);\n+      vector.set(0, 100.5f);\n+      vector.set(2, 201.5f);\n+      vector.set(4, 300.3f);\n+      vector.set(6, 423.8f);\n+      vector.set(8, 555.6f);\n+      vector.set(10, 66.6f);\n+      vector.set(12, 78.8f);\n+      vector.set(14, 89.5f);\n \n       try {\n-        mutator.set(16, 90.5f);\n+        vector.set(16, 90.5f);\n       }\n       catch (IndexOutOfBoundsException ie) {\n         error = true;\n@@ -624,25 +620,25 @@ public void testNullableFixedType2() {\n       }\n \n       /* check vector contents */\n-      assertEquals(100.5f, accessor.get(0), 0);\n-      assertTrue(accessor.isNull(1));\n-      assertEquals(201.5f, accessor.get(2), 0);\n-      assertTrue(accessor.isNull(3));\n-      assertEquals(300.3f, accessor.get(4), 0);\n-      assertTrue(accessor.isNull(5));\n-      assertEquals(423.8f, accessor.get(6), 0);\n-      assertTrue(accessor.isNull(7));\n-      assertEquals(555.6f, accessor.get(8), 0);\n-      assertTrue(accessor.isNull(9));\n-      assertEquals(66.6f, accessor.get(10), 0);\n-      assertTrue(accessor.isNull(11));\n-      assertEquals(78.8f, accessor.get(12), 0);\n-      assertTrue(accessor.isNull(13));\n-      assertEquals(89.5f, accessor.get(14), 0);\n-      assertTrue(accessor.isNull(15));\n+      assertEquals(100.5f, vector.get(0), 0);\n+      assertTrue(vector.isNull(1));\n+      assertEquals(201.5f, vector.get(2), 0);\n+      assertTrue(vector.isNull(3));\n+      assertEquals(300.3f, vector.get(4), 0);\n+      assertTrue(vector.isNull(5));\n+      assertEquals(423.8f, vector.get(6), 0);\n+      assertTrue(vector.isNull(7));\n+      assertEquals(555.6f, vector.get(8), 0);\n+      assertTrue(vector.isNull(9));\n+      assertEquals(66.6f, vector.get(10), 0);\n+      assertTrue(vector.isNull(11));\n+      assertEquals(78.8f, vector.get(12), 0);\n+      assertTrue(vector.isNull(13));\n+      assertEquals(89.5f, vector.get(14), 0);\n+      assertTrue(vector.isNull(15));\n \n       try {\n-        accessor.get(16);\n+        vector.get(16);\n       }\n       catch (IndexOutOfBoundsException ie) {\n         error = true;\n@@ -653,29 +649,28 @@ public void testNullableFixedType2() {\n       }\n \n       /* this should trigger a realloc() */\n-      mutator.setSafe(16, 90.5f);\n+      vector.setSafe(16, 90.5f);\n \n       /* underlying buffer should now be able to store double the number of values */\n       assertEquals(initialCapacity * 2, vector.getValueCapacity());\n \n       /* vector data should still be intact after realloc */\n-      assertEquals(100.5f, accessor.get(0), 0);\n-      assertTrue(accessor.isNull(1));\n-      assertEquals(201.5f, accessor.get(2), 0);\n-      assertTrue(accessor.isNull(3));\n-      assertEquals(300.3f, accessor.get(4), 0);\n-      assertTrue(accessor.isNull(5));\n-      assertEquals(423.8f, accessor.get(6), 0);\n-      assertTrue(accessor.isNull(7));\n-      assertEquals(555.6f, accessor.get(8), 0);\n-      assertTrue(accessor.isNull(9));\n-      assertEquals(66.6f, accessor.get(10), 0);\n-      assertTrue(accessor.isNull(11));\n-      assertEquals(78.8f, accessor.get(12), 0);\n-      assertTrue(accessor.isNull(13));\n-      assertEquals(89.5f, accessor.get(14), 0);\n-      assertTrue(accessor.isNull(15));\n-      assertEquals(90.5f, accessor.get(16), 0);\n+      assertEquals(100.5f, vector.get(0), 0);\n+      assertTrue(vector.isNull(1));\n+      assertEquals(201.5f, vector.get(2), 0);\n+      assertTrue(vector.isNull(3));\n+      assertEquals(300.3f, vector.get(4), 0);\n+      assertTrue(vector.isNull(5));\n+      assertEquals(423.8f, vector.get(6), 0);\n+      assertTrue(vector.isNull(7));\n+      assertEquals(555.6f, vector.get(8), 0);\n+      assertTrue(vector.isNull(9));\n+      assertEquals(66.6f, vector.get(10), 0);\n+      assertTrue(vector.isNull(11));\n+      assertEquals(78.8f, vector.get(12), 0);\n+      assertTrue(vector.isNull(13));\n+      assertEquals(89.5f, vector.get(14), 0);\n+      assertTrue(vector.isNull(15));\n \n       /* reset the vector */\n       vector.reset();\n@@ -685,7 +680,7 @@ public void testNullableFixedType2() {\n \n       /* vector data should be zeroed out */\n       for(int i = 0; i < (initialCapacity * 2); i++) {\n-        assertTrue(\"non-null data not expected at index: \" + i, accessor.isNull(i));\n+        assertTrue(\"non-null data not expected at index: \" + i, vector.isNull(i));\n       }\n     }\n   }\n@@ -694,8 +689,6 @@ public void testNullableFixedType2() {\n   public void testNullableFixedType3() {\n     // Create a new value vector for 1024 integers\n     try (final NullableIntVector vector = newVector(NullableIntVector.class, EMPTY_SCHEMA_PATH, MinorType.INT, allocator)) {\n-      final NullableIntVector.Mutator mutator = vector.getMutator();\n-      final NullableIntVector.Accessor accessor = vector.getAccessor();\n       boolean error = false;\n       int initialCapacity = 1024;\n \n@@ -706,26 +699,26 @@ public void testNullableFixedType3() {\n       /* underlying buffer should be able to store 16 values */\n       assertEquals(initialCapacity, vector.getValueCapacity());\n \n-      mutator.set(0, 1);\n-      mutator.set(1, 2);\n-      mutator.set(100, 3);\n-      mutator.set(1022, 4);\n-      mutator.set(1023, 5);\n+      vector.set(0, 1);\n+      vector.set(1, 2);\n+      vector.set(100, 3);\n+      vector.set(1022, 4);\n+      vector.set(1023, 5);\n \n       /* check vector contents */\n       int j = 1;\n       for(int i = 0; i <= 1023; i++) {\n         if((i >= 2 && i <= 99) || (i >= 101 && i <= 1021)) {\n-          assertTrue(\"non-null data not expected at index: \" + i, accessor.isNull(i));\n+          assertTrue(\"non-null data not expected at index: \" + i, vector.isNull(i));\n         }\n         else {\n-          assertFalse(\"null data not expected at index: \" + i, accessor.isNull(i));\n-          assertEquals(\"unexpected value at index: \" + i, j, accessor.get(i));\n+          assertFalse(\"null data not expected at index: \" + i, vector.isNull(i));\n+          assertEquals(\"unexpected value at index: \" + i, j, vector.get(i));\n           j++;\n         }\n       }\n \n-      mutator.setValueCount(1024);\n+      vector.setValueCount(1024);\n       Field field = vector.getField();\n       TypeLayout typeLayout = field.getTypeLayout();\n \n@@ -749,7 +742,7 @@ public void testNullableFixedType3() {\n       assertEquals(-64, validityVectorBuf.getByte(127)); // 1022nd and 1023rd bit defined\n \n       /* this should trigger a realloc() */\n-      mutator.setSafe(1024, 6);\n+      vector.setSafe(1024, 6);\n \n       /* underlying buffer should now be able to store double the number of values */\n       assertEquals(initialCapacity * 2, vector.getValueCapacity());\n@@ -758,11 +751,11 @@ public void testNullableFixedType3() {\n       j = 1;\n       for(int i = 0; i < (initialCapacity * 2); i++) {\n         if((i > 1024) || (i >= 2 && i <= 99) || (i >= 101 && i <= 1021)) {\n-          assertTrue(\"non-null data not expected at index: \" + i, accessor.isNull(i));\n+          assertTrue(\"non-null data not expected at index: \" + i, vector.isNull(i));\n         }\n         else {\n-          assertFalse(\"null data not expected at index: \" + i, accessor.isNull(i));\n-          assertEquals(\"unexpected value at index: \" + i, j, accessor.get(i));\n+          assertFalse(\"null data not expected at index: \" + i, vector.isNull(i));\n+          assertEquals(\"unexpected value at index: \" + i, j, vector.get(i));\n           j++;\n         }\n       }\n@@ -775,13 +768,101 @@ public void testNullableFixedType3() {\n \n       /* vector data should have been zeroed out */\n       for(int i = 0; i < (initialCapacity * 2); i++) {\n-        assertTrue(\"non-null data not expected at index: \" + i, accessor.isNull(i));\n+        assertTrue(\"non-null data not expected at index: \" + i, vector.isNull(i));\n       }\n \n       vector.allocateNew(4096);\n       // vector has been erased\n       for(int i = 0; i < 4096; i++) {\n-        assertTrue(\"non-null data not expected at index: \" + i, accessor.isNull(i));\n+        assertTrue(\"non-null data not expected at index: \" + i, vector.isNull(i));\n+      }\n+    }\n+  }\n+\n+  @Test /* NullableIntVector */\n+  public void testNullableFixedType4() {\n+    try (final NullableIntVector vector = newVector(NullableIntVector.class, EMPTY_SCHEMA_PATH, MinorType.INT, allocator)) {\n+\n+      /* no memory allocation has happened yet */\n+      assertEquals(0, vector.getValueCapacity());\n+\n+      vector.allocateNew();\n+      int valueCapacity = vector.getValueCapacity();\n+      assertEquals(vector.INITIAL_VALUE_ALLOCATION, valueCapacity);\n+\n+      int baseValue = 20000;\n+\n+      for (int i = 0; i < valueCapacity; i++) {\n+        if ((i & 1) == 1) {\n+          vector.set(i, baseValue + i);\n+        }\n+      }\n+\n+      for (int i = 0; i < valueCapacity; i++) {\n+        if ((i & 1) == 1) {\n+          assertFalse(\"unexpected null value at index: \" + i, vector.isNull(i));\n+          assertEquals(\"unexpected value at index: \" + i, (baseValue + i), vector.get(i));\n+        } else {\n+          assertTrue(\"unexpected non-null value at index: \" + i, vector.isNull(i));\n+        }\n+      }\n+\n+      vector.setSafe(valueCapacity, 20000000);\n+      assertEquals(valueCapacity * 2, vector.getValueCapacity());\n+\n+      for (int i = 0; i < vector.getValueCapacity(); i++) {\n+        if (i == valueCapacity) {\n+          assertFalse(\"unexpected null value at index: \" + i, vector.isNull(i));\n+          assertEquals(\"unexpected value at index: \" + i, 20000000, vector.get(i));\n+        } else if (i < valueCapacity) {\n+          if ((i & 1) == 1) {\n+            assertFalse(\"unexpected null value at index: \" + i, vector.isNull(i));\n+            assertEquals(\"unexpected value at index: \" + i, (baseValue + i), vector.get(i));\n+          }\n+        } else {\n+          assertTrue(\"unexpected non-null value at index: \" + i, vector.isNull(i));\n+        }\n+      }\n+\n+      vector.zeroVector();\n+\n+      for (int i = 0; i < vector.getValueCapacity(); i+=2) {\n+          vector.set(i, baseValue + i);\n+      }\n+\n+      for (int i = 0; i < vector.getValueCapacity(); i++) {\n+        if (i%2 == 0) {\n+          assertFalse(\"unexpected null value at index: \" + i, vector.isNull(i));\n+          assertEquals(\"unexpected value at index: \" + i, (baseValue + i), vector.get(i));\n+        } else {\n+          assertTrue(\"unexpected non-null value at index: \" + i, vector.isNull(i));\n+        }\n+      }\n+\n+      vector.setSafe((valueCapacity *  2) + 1000, 400000000);\n+      assertEquals(valueCapacity * 4, vector.getValueCapacity());\n+\n+      for (int i = 0; i < vector.getValueCapacity(); i++) {\n+        if (i == (valueCapacity*2 + 1000)) {\n+          assertFalse(\"unexpected null value at index: \" + i, vector.isNull(i));\n+          assertEquals(\"unexpected value at index: \" + i, 400000000, vector.get(i));\n+        } else if (i < valueCapacity*2 && (i%2) == 0) {\n+          assertFalse(\"unexpected null value at index: \" + i, vector.isNull(i));\n+          assertEquals(\"unexpected value at index: \" + i, baseValue + i, vector.get(i));\n+        } else {\n+          assertTrue(\"unexpected non-null value at index: \" + i, vector.isNull(i));\n+        }\n+      }\n+\n+      /* reset the vector */\n+      vector.reset();\n+\n+       /* capacity shouldn't change after reset */\n+      assertEquals(valueCapacity * 4, vector.getValueCapacity());\n+\n+      /* vector data should be zeroed out */\n+      for(int i = 0; i < (valueCapacity * 4); i++) {\n+        assertTrue(\"non-null data not expected at index: \" + i, vector.isNull(i));\n       }\n     }\n   }\n@@ -805,32 +886,30 @@ public void testNullableVarType1() {\n \n     // Create a new value vector for 1024 integers.\n     try (final NullableVarCharVector vector = newNullableVarCharVector(EMPTY_SCHEMA_PATH, allocator)) {\n-      final NullableVarCharVector.Mutator m = vector.getMutator();\n       vector.allocateNew(1024 * 10, 1024);\n \n-      m.set(0, STR1);\n-      m.set(1, STR2);\n-      m.set(2, STR3);\n-      m.setSafe(3, STR3, 1, STR3.length - 1);\n-      m.setSafe(4, STR3, 2, STR3.length - 2);\n+      vector.set(0, STR1);\n+      vector.set(1, STR2);\n+      vector.set(2, STR3);\n+      vector.setSafe(3, STR3, 1, STR3.length - 1);\n+      vector.setSafe(4, STR3, 2, STR3.length - 2);\n       ByteBuffer STR3ByteBuffer = ByteBuffer.wrap(STR3);\n-      m.setSafe(5, STR3ByteBuffer, 1, STR3.length - 1);\n-      m.setSafe(6, STR3ByteBuffer, 2, STR3.length - 2);\n+      vector.setSafe(5, STR3ByteBuffer, 1, STR3.length - 1);\n+      vector.setSafe(6, STR3ByteBuffer, 2, STR3.length - 2);\n \n       // Check the sample strings.\n-      final NullableVarCharVector.Accessor accessor = vector.getAccessor();\n-      assertArrayEquals(STR1, accessor.get(0));\n-      assertArrayEquals(STR2, accessor.get(1));\n-      assertArrayEquals(STR3, accessor.get(2));\n-      assertArrayEquals(Arrays.copyOfRange(STR3, 1, STR3.length), accessor.get(3));\n-      assertArrayEquals(Arrays.copyOfRange(STR3, 2, STR3.length), accessor.get(4));\n-      assertArrayEquals(Arrays.copyOfRange(STR3, 1, STR3.length), accessor.get(5));\n-      assertArrayEquals(Arrays.copyOfRange(STR3, 2, STR3.length), accessor.get(6));\n+      assertArrayEquals(STR1, vector.get(0));\n+      assertArrayEquals(STR2, vector.get(1));\n+      assertArrayEquals(STR3, vector.get(2));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 1, STR3.length), vector.get(3));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 2, STR3.length), vector.get(4));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 1, STR3.length), vector.get(5));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 2, STR3.length), vector.get(6));\n \n       // Ensure null value throws.\n       boolean b = false;\n       try {\n-        vector.getAccessor().get(7);\n+        vector.get(7);\n       } catch (IllegalStateException e) {\n         b = true;\n       } finally {\n@@ -844,32 +923,30 @@ public void testNullableVarType2() {\n \n     // Create a new value vector for 1024 integers.\n     try (final NullableVarBinaryVector vector = newNullableVarBinaryVector(EMPTY_SCHEMA_PATH, allocator)) {\n-      final NullableVarBinaryVector.Mutator m = vector.getMutator();\n       vector.allocateNew(1024 * 10, 1024);\n \n-      m.set(0, STR1);\n-      m.set(1, STR2);\n-      m.set(2, STR3);\n-      m.setSafe(3, STR3, 1, STR3.length - 1);\n-      m.setSafe(4, STR3, 2, STR3.length - 2);\n+      vector.set(0, STR1);\n+      vector.set(1, STR2);\n+      vector.set(2, STR3);\n+      vector.setSafe(3, STR3, 1, STR3.length - 1);\n+      vector.setSafe(4, STR3, 2, STR3.length - 2);\n       ByteBuffer STR3ByteBuffer = ByteBuffer.wrap(STR3);\n-      m.setSafe(5, STR3ByteBuffer, 1, STR3.length - 1);\n-      m.setSafe(6, STR3ByteBuffer, 2, STR3.length - 2);\n+      vector.setSafe(5, STR3ByteBuffer, 1, STR3.length - 1);\n+      vector.setSafe(6, STR3ByteBuffer, 2, STR3.length - 2);\n \n       // Check the sample strings.\n-      final NullableVarBinaryVector.Accessor accessor = vector.getAccessor();\n-      assertArrayEquals(STR1, accessor.get(0));\n-      assertArrayEquals(STR2, accessor.get(1));\n-      assertArrayEquals(STR3, accessor.get(2));\n-      assertArrayEquals(Arrays.copyOfRange(STR3, 1, STR3.length), accessor.get(3));\n-      assertArrayEquals(Arrays.copyOfRange(STR3, 2, STR3.length), accessor.get(4));\n-      assertArrayEquals(Arrays.copyOfRange(STR3, 1, STR3.length), accessor.get(5));\n-      assertArrayEquals(Arrays.copyOfRange(STR3, 2, STR3.length), accessor.get(6));\n+      assertArrayEquals(STR1, vector.get(0));\n+      assertArrayEquals(STR2, vector.get(1));\n+      assertArrayEquals(STR3, vector.get(2));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 1, STR3.length), vector.get(3));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 2, STR3.length), vector.get(4));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 1, STR3.length), vector.get(5));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 2, STR3.length), vector.get(6));\n \n       // Ensure null value throws.\n       boolean b = false;\n       try {\n-        vector.getAccessor().get(7);\n+        vector.get(7);\n       } catch (IllegalStateException e) {\n         b = true;\n       } finally {\n@@ -980,8 +1057,6 @@ public void testReallocAfterVectorTransfer1() {\n   @Test /* NullableFloat8Vector */\n   public void testReallocAfterVectorTransfer2() {\n     try (final NullableFloat8Vector vector = new NullableFloat8Vector(EMPTY_SCHEMA_PATH, allocator)) {\n-      final NullableFloat8Vector.Mutator mutator = vector.getMutator();\n-      final NullableFloat8Vector.Accessor accessor = vector.getAccessor();\n       final int initialDefaultCapacity = 4096;\n       boolean error = false;\n \n@@ -992,7 +1067,7 @@ public void testReallocAfterVectorTransfer2() {\n       double baseValue = 100.375;\n \n       for (int i = 0; i < initialDefaultCapacity; i++) {\n-        mutator.setSafe(i, baseValue + (double)i);\n+        vector.setSafe(i, baseValue + (double)i);\n       }\n \n       /* the above setSafe calls should not have triggered a realloc as\n@@ -1001,33 +1076,33 @@ public void testReallocAfterVectorTransfer2() {\n       assertEquals(initialDefaultCapacity, vector.getValueCapacity());\n \n       for (int i = 0; i < initialDefaultCapacity; i++) {\n-        double value = accessor.get(i);\n+        double value = vector.get(i);\n         assertEquals(baseValue + (double)i, value, 0);\n       }\n \n       /* this should trigger a realloc */\n-      mutator.setSafe(initialDefaultCapacity, baseValue + (double)initialDefaultCapacity);\n+      vector.setSafe(initialDefaultCapacity, baseValue + (double)initialDefaultCapacity);\n       assertEquals(initialDefaultCapacity * 2, vector.getValueCapacity());\n \n       for (int i = initialDefaultCapacity + 1; i < (initialDefaultCapacity * 2); i++) {\n-        mutator.setSafe(i, baseValue + (double)i);\n+        vector.setSafe(i, baseValue + (double)i);\n       }\n \n       for (int i = 0; i < (initialDefaultCapacity * 2); i++) {\n-        double value = accessor.get(i);\n+        double value = vector.get(i);\n         assertEquals(baseValue + (double)i, value, 0);\n       }\n \n       /* this should trigger a realloc */\n-      mutator.setSafe(initialDefaultCapacity * 2, baseValue + (double)(initialDefaultCapacity * 2));\n+      vector.setSafe(initialDefaultCapacity * 2, baseValue + (double)(initialDefaultCapacity * 2));\n       assertEquals(initialDefaultCapacity * 4, vector.getValueCapacity());\n \n       for (int i = (initialDefaultCapacity * 2) + 1; i < (initialDefaultCapacity * 4); i++) {\n-        mutator.setSafe(i, baseValue + (double)i);\n+        vector.setSafe(i, baseValue + (double)i);\n       }\n \n       for (int i = 0; i < (initialDefaultCapacity * 4); i++) {\n-        double value = accessor.get(i);\n+        double value = vector.get(i);\n         assertEquals(baseValue + (double)i, value, 0);\n       }\n \n@@ -1039,12 +1114,11 @@ public void testReallocAfterVectorTransfer2() {\n       transferPair.transfer();\n \n       NullableFloat8Vector toVector = (NullableFloat8Vector)transferPair.getTo();\n-      final NullableFloat8Vector.Accessor toAccessor = toVector.getAccessor();\n \n       /* check toVector contents before realloc */\n       for (int i = 0; i < (initialDefaultCapacity * 4); i++) {\n-        assertFalse(\"unexpected null value at index: \" + i, toAccessor.isNull(i));\n-        double value = toAccessor.get(i);\n+        assertFalse(\"unexpected null value at index: \" + i, toVector.isNull(i));\n+        double value = toVector.get(i);\n         assertEquals(\"unexpected value at index: \" + i, baseValue + (double)i, value, 0);\n       }\n \n@@ -1054,12 +1128,12 @@ public void testReallocAfterVectorTransfer2() {\n \n       for (int i = 0; i < (initialDefaultCapacity * 8); i++) {\n         if (i < (initialDefaultCapacity * 4)) {\n-          assertFalse(\"unexpected null value at index: \" + i, toAccessor.isNull(i));\n-          double value = toAccessor.get(i);\n+          assertFalse(\"unexpected null value at index: \" + i, toVector.isNull(i));\n+          double value = toVector.get(i);\n           assertEquals(\"unexpected value at index: \" + i, baseValue + (double)i, value, 0);\n         }\n         else {\n-          assertTrue(\"unexpected non-null value at index: \" + i, toAccessor.isNull(i));\n+          assertTrue(\"unexpected non-null value at index: \" + i, toVector.isNull(i));\n         }\n       }\n \n@@ -1070,43 +1144,42 @@ public void testReallocAfterVectorTransfer2() {\n   @Test /* NullableVarCharVector */\n   public void testReallocAfterVectorTransfer3() {\n     try (final NullableVarCharVector vector = new NullableVarCharVector(EMPTY_SCHEMA_PATH, allocator)) {\n-      final NullableVarCharVector.Mutator mutator = vector.getMutator();\n-      final NullableVarCharVector.Accessor accessor = vector.getAccessor();\n-\n       /* 4096 values with 10 byte per record */\n       vector.allocateNew(4096 * 10, 4096);\n       int valueCapacity = vector.getValueCapacity();\n+      assertEquals(4096, valueCapacity);\n \n       /* populate the vector */\n       for (int i = 0; i < valueCapacity; i++) {\n         if ((i & 1) == 1) {\n-          mutator.set(i, STR1);\n+          vector.set(i, STR1);\n         }\n         else {\n-          mutator.set(i, STR2);\n+          vector.set(i, STR2);\n         }\n       }\n \n       /* Check the vector output */\n       for (int i = 0; i < valueCapacity; i++) {\n         if ((i & 1) == 1) {\n-          assertArrayEquals(STR1, accessor.get(i));\n+          assertArrayEquals(STR1, vector.get(i));\n         }\n         else {\n-          assertArrayEquals(STR2, accessor.get(i));\n+          assertArrayEquals(STR2, vector.get(i));\n         }\n       }\n \n       /* trigger first realloc */\n-      mutator.setSafe(valueCapacity, STR2, 0, STR2.length);\n+      vector.setSafe(valueCapacity, STR2, 0, STR2.length);\n+      assertEquals(valueCapacity * 2, vector.getValueCapacity());\n \n       /* populate the remaining vector */\n       for (int i = valueCapacity; i < vector.getValueCapacity(); i++) {\n         if ((i & 1) == 1) {\n-          mutator.set(i, STR1);\n+          vector.set(i, STR1);\n         }\n         else {\n-          mutator.set(i, STR2);\n+          vector.set(i, STR2);\n         }\n       }\n \n@@ -1114,23 +1187,24 @@ public void testReallocAfterVectorTransfer3() {\n       valueCapacity = vector.getValueCapacity();\n       for (int i = 0; i < valueCapacity; i++) {\n         if ((i & 1) == 1) {\n-          assertArrayEquals(STR1, accessor.get(i));\n+          assertArrayEquals(STR1, vector.get(i));\n         }\n         else {\n-          assertArrayEquals(STR2, accessor.get(i));\n+          assertArrayEquals(STR2, vector.get(i));\n         }\n       }\n \n       /* trigger second realloc */\n-      mutator.setSafe(valueCapacity + 10, STR2, 0, STR2.length);\n+      vector.setSafe(valueCapacity + 10, STR2, 0, STR2.length);\n+      assertEquals(valueCapacity * 2, vector.getValueCapacity());\n \n       /* populate the remaining vector */\n       for (int i = valueCapacity; i < vector.getValueCapacity(); i++) {\n         if ((i & 1) == 1) {\n-          mutator.set(i, STR1);\n+          vector.set(i, STR1);\n         }\n         else {\n-          mutator.set(i, STR2);\n+          vector.set(i, STR2);\n         }\n       }\n \n@@ -1138,10 +1212,10 @@ public void testReallocAfterVectorTransfer3() {\n       valueCapacity = vector.getValueCapacity();\n       for (int i = 0; i < valueCapacity; i++) {\n         if ((i & 1) == 1) {\n-          assertArrayEquals(STR1, accessor.get(i));\n+          assertArrayEquals(STR1, vector.get(i));\n         }\n         else {\n-          assertArrayEquals(STR2, accessor.get(i));\n+          assertArrayEquals(STR2, vector.get(i));\n         }\n       }\n \n@@ -1152,13 +1226,112 @@ public void testReallocAfterVectorTransfer3() {\n       TransferPair transferPair = vector.getTransferPair(allocator);\n       transferPair.transfer();\n       NullableVarCharVector toVector = (NullableVarCharVector)transferPair.getTo();\n-      NullableVarCharVector.Mutator toMutator = toVector.getMutator();\n-      NullableVarCharVector.Accessor toAccessor = toVector.getAccessor();\n-\n       valueCapacity = toVector.getValueCapacity();\n \n-      /* trigger a realloc of this toVector */\n-      toMutator.setSafe(valueCapacity + 10, STR2, 0, STR2.length);\n+      for (int i = 0; i < valueCapacity; i++) {\n+        if ((i & 1) == 1) {\n+          assertArrayEquals(STR1, toVector.get(i));\n+        }\n+        else {\n+          assertArrayEquals(STR2, toVector.get(i));\n+        }\n+      }\n+\n+      toVector.close();\n+    }\n+  }\n+\n+  @Test /* NullableIntVector */\n+  public void testReallocAfterVectorTransfer4() {\n+    try (final NullableIntVector vector = new NullableIntVector(EMPTY_SCHEMA_PATH, allocator)) {\n+\n+      /* 4096 values  */\n+      vector.allocateNew(4096);\n+      int valueCapacity = vector.getValueCapacity();\n+      assertEquals(4096, valueCapacity);\n+\n+      /* populate the vector */\n+      int baseValue = 1000;\n+      for (int i = 0; i < valueCapacity; i++) {\n+        if ((i & 1) == 0) {\n+          vector.set(i, 1000 + i);\n+        }\n+      }\n+\n+      /* Check the vector output */\n+      for (int i = 0; i < valueCapacity; i++) {\n+        if ((i & 1) == 0) {\n+          assertEquals(1000 + i, vector.get(i));\n+        }\n+        else {\n+          assertTrue(vector.isNull(i));\n+        }\n+      }\n+\n+      /* trigger first realloc */\n+      vector.setSafe(valueCapacity, 10000000);\n+      assertEquals(valueCapacity * 2, vector.getValueCapacity());\n+\n+      /* populate the remaining vector */\n+      for (int i = valueCapacity; i < vector.getValueCapacity(); i++) {\n+        if ((i & 1) == 0) {\n+          vector.set(i, 1000 + i);\n+        }\n+      }\n+\n+      /* Check the vector output */\n+      valueCapacity = vector.getValueCapacity();\n+      for (int i = 0; i < valueCapacity; i++) {\n+        if ((i & 1) == 0) {\n+          assertEquals(1000 + i, vector.get(i));\n+        }\n+        else {\n+          assertTrue(vector.isNull(i));\n+        }\n+      }\n+\n+      /* trigger second realloc */\n+      vector.setSafe(valueCapacity, 10000000);\n+      assertEquals(valueCapacity * 2, vector.getValueCapacity());\n+\n+      /* populate the remaining vector */\n+      for (int i = valueCapacity; i < vector.getValueCapacity(); i++) {\n+        if ((i & 1) == 0) {\n+          vector.set(i, 1000 + i);\n+        }\n+      }\n+\n+      /* Check the vector output */\n+      valueCapacity = vector.getValueCapacity();\n+      for (int i = 0; i < valueCapacity; i++) {\n+        if ((i & 1) == 0) {\n+          assertEquals(1000 + i, vector.get(i));\n+        }\n+        else {\n+          assertTrue(vector.isNull(i));\n+        }\n+      }\n+\n+      /* we are potentially working with 4x the size of vector buffer\n+       * that we initially started with. Now let's transfer the vector.\n+       */\n+\n+      TransferPair transferPair = vector.getTransferPair(allocator);\n+      transferPair.transfer();\n+      NullableIntVector toVector = (NullableIntVector)transferPair.getTo();\n+      /* value capacity of source and target vectors should be same after\n+       * the transfer.\n+       */\n+      assertEquals(valueCapacity, toVector.getValueCapacity());\n+\n+      for (int i = 0; i < valueCapacity; i++) {\n+        if ((i & 1) == 0) {\n+          assertEquals(1000 + i, toVector.get(i));\n+        }\n+        else {\n+          assertTrue(toVector.isNull(i));\n+        }\n+      }\n \n       toVector.close();\n     }\n@@ -1168,62 +1341,62 @@ public void testReallocAfterVectorTransfer3() {\n   public void testReAllocNullableFixedWidthVector() {\n     // Create a new value vector for 1024 integers\n     try (final NullableFloat4Vector vector = newVector(NullableFloat4Vector.class, EMPTY_SCHEMA_PATH, MinorType.FLOAT4, allocator)) {\n-      final NullableFloat4Vector.Mutator m = vector.getMutator();\n       vector.allocateNew(1024);\n \n       assertEquals(1024, vector.getValueCapacity());\n \n       // Put values in indexes that fall within the initial allocation\n-      m.setSafe(0, 100.1f);\n-      m.setSafe(100, 102.3f);\n-      m.setSafe(1023, 104.5f);\n+      vector.setSafe(0, 100.1f);\n+      vector.setSafe(100, 102.3f);\n+      vector.setSafe(1023, 104.5f);\n \n       // Now try to put values in space that falls beyond the initial allocation\n-      m.setSafe(2000, 105.5f);\n+      vector.setSafe(2000, 105.5f);\n \n       // Check valueCapacity is more than initial allocation\n       assertEquals(1024 * 2, vector.getValueCapacity());\n \n-      final NullableFloat4Vector.Accessor accessor = vector.getAccessor();\n-      assertEquals(100.1f, accessor.get(0), 0);\n-      assertEquals(102.3f, accessor.get(100), 0);\n-      assertEquals(104.5f, accessor.get(1023), 0);\n-      assertEquals(105.5f, accessor.get(2000), 0);\n+      assertEquals(100.1f, vector.get(0), 0);\n+      assertEquals(102.3f, vector.get(100), 0);\n+      assertEquals(104.5f, vector.get(1023), 0);\n+      assertEquals(105.5f, vector.get(2000), 0);\n \n       // Set the valueCount to be more than valueCapacity of current allocation. This is possible for NullableValueVectors\n       // as we don't call setSafe for null values, but we do call setValueCount when all values are inserted into the\n       // vector\n-      m.setValueCount(vector.getValueCapacity() + 200);\n+      vector.setValueCount(vector.getValueCapacity() + 200);\n     }\n   }\n \n   @Test\n   public void testReAllocNullableVariableWidthVector() {\n-    // Create a new value vector for 1024 integers\n     try (final NullableVarCharVector vector = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator)) {\n-      final NullableVarCharVector.Mutator m = vector.getMutator();\n       vector.allocateNew();\n \n       int initialCapacity = vector.getValueCapacity();\n+      assertEquals(4095, initialCapacity);\n \n-      // Put values in indexes that fall within the initial allocation\n-      m.setSafe(0, STR1, 0, STR1.length);\n-      m.setSafe(initialCapacity - 1, STR2, 0, STR2.length);\n+      /* Put values in indexes that fall within the initial allocation */\n+      vector.setSafe(0, STR1, 0, STR1.length);\n+      vector.setSafe(initialCapacity - 1, STR2, 0, STR2.length);\n \n-      // Now try to put values in space that falls beyond the initial allocation\n-      m.setSafe(initialCapacity + 200, STR3, 0, STR3.length);\n+      /* the above set calls should NOT have triggered a realloc */\n+      initialCapacity = vector.getValueCapacity();\n+      assertEquals(4095, initialCapacity);\n \n-      // Check valueCapacity is more than initial allocation\n-      assertEquals((initialCapacity + 1) * 2 - 1, vector.getValueCapacity());\n+      /* Now try to put values in space that falls beyond the initial allocation */\n+      vector.setSafe(initialCapacity + 200, STR3, 0, STR3.length);\n+\n+      /* Check valueCapacity is more than initial allocation */\n+      assertEquals(((initialCapacity + 1) * 2) - 1, vector.getValueCapacity());\n \n-      final NullableVarCharVector.Accessor accessor = vector.getAccessor();\n-      assertArrayEquals(STR1, accessor.get(0));\n-      assertArrayEquals(STR2, accessor.get(initialCapacity - 1));\n-      assertArrayEquals(STR3, accessor.get(initialCapacity + 200));\n+      assertArrayEquals(STR1, vector.get(0));\n+      assertArrayEquals(STR2, vector.get(initialCapacity - 1));\n+      assertArrayEquals(STR3, vector.get(initialCapacity + 200));\n \n       // Set the valueCount to be more than valueCapacity of current allocation. This is possible for NullableValueVectors\n       // as we don't call setSafe for null values, but we do call setValueCount when the current batch is processed.\n-      m.setValueCount(vector.getValueCapacity() + 200);\n+      vector.setValueCount(vector.getValueCapacity() + 200);\n     }\n   }\n \n@@ -1232,10 +1405,18 @@ public void testFillEmptiesNotOverfill() {\n     try (final NullableVarCharVector vector = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator)) {\n       vector.allocateNew();\n \n-      vector.getMutator().setSafe(4094, \"hello\".getBytes(), 0, 5);\n-      vector.getMutator().setValueCount(4095);\n+      int initialCapacity = vector.getValueCapacity();\n+      assertEquals(4095, initialCapacity);\n+\n+      vector.setSafe(4094, \"hello\".getBytes(), 0, 5);\n+      /* the above set method should NOT have trigerred a realloc */\n+      initialCapacity = vector.getValueCapacity();\n+      assertEquals(4095, initialCapacity);\n \n-      assertEquals(4096 * 4, vector.getFieldBuffers().get(1).capacity());\n+      vector.setValueCount(4095);\n+      assertEquals(4096 * vector.OFFSET_WIDTH, vector.getFieldBuffers().get(1).capacity());\n+      initialCapacity = vector.getValueCapacity();\n+      assertEquals(4095, initialCapacity);\n     }\n   }\n \n@@ -1243,42 +1424,129 @@ public void testFillEmptiesNotOverfill() {\n   public void testCopyFromWithNulls() {\n     try (final NullableVarCharVector vector = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator);\n          final NullableVarCharVector vector2 = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator)) {\n+\n       vector.allocateNew();\n+      int capacity = vector.getValueCapacity();\n+      assertEquals(4095, capacity);\n \n       for (int i = 0; i < 4095; i++) {\n         if (i % 3 == 0) {\n           continue;\n         }\n         byte[] b = Integer.toString(i).getBytes();\n-        vector.getMutator().setSafe(i, b, 0, b.length);\n+        vector.setSafe(i, b, 0, b.length);\n       }\n \n-      vector.getMutator().setValueCount(4095);\n+      /* NO reAlloc() should have happened in setSafe() */\n+      capacity = vector.getValueCapacity();\n+      assertEquals(4095, capacity);\n+\n+      vector.setValueCount(4095);\n+\n+      for (int i = 0; i < 4095; i++) {\n+        if (i % 3 == 0) {\n+          assertNull(vector.getObject(i));\n+        } else {\n+          assertEquals(\"unexpected value at index: \" + i, Integer.toString(i), vector.getObject(i).toString());\n+        }\n+      }\n \n       vector2.allocateNew();\n+      capacity = vector2.getValueCapacity();\n+      assertEquals(4095, capacity);\n \n       for (int i = 0; i < 4095; i++) {\n         vector2.copyFromSafe(i, i, vector);\n+        if (i % 3 == 0) {\n+          assertNull(vector2.getObject(i));\n+        } else {\n+          assertEquals(\"unexpected value at index: \" + i, Integer.toString(i), vector2.getObject(i).toString());\n+        }\n       }\n \n-      vector2.getMutator().setValueCount(4095);\n+      /* NO reAlloc() should have happened in copyFrom */\n+      capacity = vector2.getValueCapacity();\n+      assertEquals(4095, capacity);\n+\n+      vector2.setValueCount(4095);\n \n       for (int i = 0; i < 4095; i++) {\n         if (i % 3 == 0) {\n-          assertNull(vector2.getAccessor().getObject(i));\n+          assertNull(vector2.getObject(i));\n         } else {\n-          assertEquals(Integer.toString(i), vector2.getAccessor().getObject(i).toString());\n+          assertEquals(\"unexpected value at index: \" + i, Integer.toString(i), vector2.getObject(i).toString());\n         }\n       }\n     }\n   }\n \n   @Test\n-  public void testSetLastSetUsage() {\n-    try (final NullableVarCharVector vector = new NullableVarCharVector(\"myvector\", allocator)) {\n+  public void testCopyFromWithNulls1() {\n+    try (final NullableVarCharVector vector = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator);\n+         final NullableVarCharVector vector2 = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator)) {\n+\n+      vector.allocateNew();\n+      int capacity = vector.getValueCapacity();\n+      assertEquals(4095, capacity);\n+\n+      for (int i = 0; i < 4095; i++) {\n+        if (i % 3 == 0) {\n+          continue;\n+        }\n+        byte[] b = Integer.toString(i).getBytes();\n+        vector.setSafe(i, b, 0, b.length);\n+      }\n+\n+      /* NO reAlloc() should have happened in setSafe() */\n+      capacity = vector.getValueCapacity();\n+      assertEquals(4095, capacity);\n+\n+      vector.setValueCount(4095);\n+\n+      for (int i = 0; i < 4095; i++) {\n+        if (i % 3 == 0) {\n+          assertNull(vector.getObject(i));\n+        } else {\n+          assertEquals(\"unexpected value at index: \" + i, Integer.toString(i), vector.getObject(i).toString());\n+        }\n+      }\n+\n+      /* set lesser initial capacity than actually needed\n+       * to trigger reallocs in copyFromSafe()\n+       */\n+      vector2.allocateNew(1024 * 10, 1024);\n+\n+      capacity = vector2.getValueCapacity();\n+      assertEquals(1024, capacity);\n+\n+      for (int i = 0; i < 4095; i++) {\n+        vector2.copyFromSafe(i, i, vector);\n+        if (i % 3 == 0) {\n+          assertNull(vector2.getObject(i));\n+        } else {\n+          assertEquals(\"unexpected value at index: \" + i, Integer.toString(i), vector2.getObject(i).toString());\n+        }\n+      }\n+\n+      /* 2 reAllocs should have happened in copyFromSafe() */\n+      capacity = vector2.getValueCapacity();\n+      assertEquals(4096, capacity);\n+\n+      vector2.setValueCount(4095);\n \n-      final NullableVarCharVector.Mutator mutator = vector.getMutator();\n+      for (int i = 0; i < 4095; i++) {\n+        if (i % 3 == 0) {\n+          assertNull(vector2.getObject(i));\n+        } else {\n+          assertEquals(\"unexpected value at index: \" + i, Integer.toString(i), vector2.getObject(i).toString());\n+        }\n+      }\n+    }\n+  }\n \n+  @Test\n+  public void testSetLastSetUsage() {\n+    try (final NullableVarCharVector vector = new NullableVarCharVector(\"myvector\", allocator)) {\n       vector.allocateNew(1024 * 10, 1024);\n \n       setBytes(0, STR1, vector);\n@@ -1289,32 +1557,102 @@ public void testSetLastSetUsage() {\n       setBytes(5, STR6, vector);\n \n       /* Check current lastSet */\n-      assertEquals(Integer.toString(-1), Integer.toString(mutator.getLastSet()));\n+      assertEquals(Integer.toString(-1), Integer.toString(vector.getLastSet()));\n \n       /* Check the vector output */\n-      final NullableVarCharVector.Accessor accessor = vector.getAccessor();\n-      assertArrayEquals(STR1, accessor.get(0));\n-      assertArrayEquals(STR2, accessor.get(1));\n-      assertArrayEquals(STR3, accessor.get(2));\n-      assertArrayEquals(STR4, accessor.get(3));\n-      assertArrayEquals(STR5, accessor.get(4));\n-      assertArrayEquals(STR6, accessor.get(5));\n+      assertArrayEquals(STR1, vector.get(0));\n+      assertArrayEquals(STR2, vector.get(1));\n+      assertArrayEquals(STR3, vector.get(2));\n+      assertArrayEquals(STR4, vector.get(3));\n+      assertArrayEquals(STR5, vector.get(4));\n+      assertArrayEquals(STR6, vector.get(5));\n \n       /*\n        * If we don't do setLastSe(5) before setValueCount(), then the latter will corrupt\n        * the value vector by filling in all positions [0,valuecount-1] will empty byte arrays.\n        * Run the test by commenting out next line and we should see incorrect vector output.\n        */\n-      mutator.setLastSet(5);\n-      mutator.setValueCount(20);\n+      vector.setLastSet(5);\n+      vector.setValueCount(20);\n+\n+      /* Check current lastSet */\n+      assertEquals(Integer.toString(19), Integer.toString(vector.getLastSet()));\n \n       /* Check the vector output again */\n-      assertArrayEquals(STR1, accessor.get(0));\n-      assertArrayEquals(STR2, accessor.get(1));\n-      assertArrayEquals(STR3, accessor.get(2));\n-      assertArrayEquals(STR4, accessor.get(3));\n-      assertArrayEquals(STR5, accessor.get(4));\n-      assertArrayEquals(STR6, accessor.get(5));\n+      assertArrayEquals(STR1, vector.get(0));\n+      assertArrayEquals(STR2, vector.get(1));\n+      assertArrayEquals(STR3, vector.get(2));\n+      assertArrayEquals(STR4, vector.get(3));\n+      assertArrayEquals(STR5, vector.get(4));\n+      assertArrayEquals(STR6, vector.get(5));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(6)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(7)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(8)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(9)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(10)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(11)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(12)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(13)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(14)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(15)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(16)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(17)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(18)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(19)));\n+\n+      /* Check offsets */\n+      assertEquals(Integer.toString(0),\n+              Integer.toString(vector.offsetBuffer.getInt(0 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(6),\n+              Integer.toString(vector.offsetBuffer.getInt(1 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(16),\n+              Integer.toString(vector.offsetBuffer.getInt(2 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(21),\n+              Integer.toString(vector.offsetBuffer.getInt(3 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(30),\n+              Integer.toString(vector.offsetBuffer.getInt(4 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(34),\n+              Integer.toString(vector.offsetBuffer.getInt(5 * vector.OFFSET_WIDTH)));\n+\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(6 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(7 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(8 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(9 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(10 * vector.OFFSET_WIDTH)));\n+\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(11 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(12 * vector.OFFSET_WIDTH)));\n+\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(13 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(14 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(15 * vector.OFFSET_WIDTH)));\n+\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(16 * vector.OFFSET_WIDTH)));\n+\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(17 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(18 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(19 * vector.OFFSET_WIDTH)));\n+\n+      vector.set(19, STR6);\n+      assertArrayEquals(STR6, vector.get(19));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(19 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(46),\n+              Integer.toString(vector.offsetBuffer.getInt(20 * vector.OFFSET_WIDTH)));\n     }\n   }\n \n@@ -1322,29 +1660,25 @@ public void testSetLastSetUsage() {\n   public void testVectorLoadUnload() {\n \n     try (final NullableVarCharVector vector1 = new NullableVarCharVector(\"myvector\", allocator)) {\n-\n-      final NullableVarCharVector.Mutator mutator1 = vector1.getMutator();\n-\n       vector1.allocateNew(1024 * 10, 1024);\n \n-      mutator1.set(0, STR1);\n-      mutator1.set(1, STR2);\n-      mutator1.set(2, STR3);\n-      mutator1.set(3, STR4);\n-      mutator1.set(4, STR5);\n-      mutator1.set(5, STR6);\n-      assertEquals(Integer.toString(5), Integer.toString(mutator1.getLastSet()));\n-      mutator1.setValueCount(15);\n-      assertEquals(Integer.toString(14), Integer.toString(mutator1.getLastSet()));\n+      vector1.set(0, STR1);\n+      vector1.set(1, STR2);\n+      vector1.set(2, STR3);\n+      vector1.set(3, STR4);\n+      vector1.set(4, STR5);\n+      vector1.set(5, STR6);\n+      assertEquals(Integer.toString(5), Integer.toString(vector1.getLastSet()));\n+      vector1.setValueCount(15);\n+      assertEquals(Integer.toString(14), Integer.toString(vector1.getLastSet()));\n \n       /* Check the vector output */\n-      final NullableVarCharVector.Accessor accessor1 = vector1.getAccessor();\n-      assertArrayEquals(STR1, accessor1.get(0));\n-      assertArrayEquals(STR2, accessor1.get(1));\n-      assertArrayEquals(STR3, accessor1.get(2));\n-      assertArrayEquals(STR4, accessor1.get(3));\n-      assertArrayEquals(STR5, accessor1.get(4));\n-      assertArrayEquals(STR6, accessor1.get(5));\n+      assertArrayEquals(STR1, vector1.get(0));\n+      assertArrayEquals(STR2, vector1.get(1));\n+      assertArrayEquals(STR3, vector1.get(2));\n+      assertArrayEquals(STR4, vector1.get(3));\n+      assertArrayEquals(STR5, vector1.get(4));\n+      assertArrayEquals(STR6, vector1.get(5));\n \n       Field field = vector1.getField();\n       String fieldName = field.getName();\n@@ -1357,7 +1691,7 @@ public void testVectorLoadUnload() {\n \n       Schema schema = new Schema(fields);\n \n-      VectorSchemaRoot schemaRoot1 = new VectorSchemaRoot(schema, fieldVectors, accessor1.getValueCount());\n+      VectorSchemaRoot schemaRoot1 = new VectorSchemaRoot(schema, fieldVectors, vector1.getValueCount());\n       VectorUnloader vectorUnloader = new VectorUnloader(schemaRoot1);\n \n       try (\n@@ -1370,24 +1704,21 @@ public void testVectorLoadUnload() {\n         vectorLoader.load(recordBatch);\n \n         NullableVarCharVector vector2 = (NullableVarCharVector) schemaRoot2.getVector(fieldName);\n-        NullableVarCharVector.Mutator mutator2 = vector2.getMutator();\n-\n         /*\n          * lastSet would have internally been set by VectorLoader.load() when it invokes\n          * loadFieldBuffers.\n          */\n-        assertEquals(Integer.toString(14), Integer.toString(mutator2.getLastSet()));\n-        mutator2.setValueCount(25);\n-        assertEquals(Integer.toString(24), Integer.toString(mutator2.getLastSet()));\n+        assertEquals(Integer.toString(14), Integer.toString(vector2.getLastSet()));\n+        vector2.setValueCount(25);\n+        assertEquals(Integer.toString(24), Integer.toString(vector2.getLastSet()));\n \n         /* Check the vector output */\n-        final NullableVarCharVector.Accessor accessor2 = vector2.getAccessor();\n-        assertArrayEquals(STR1, accessor2.get(0));\n-        assertArrayEquals(STR2, accessor2.get(1));\n-        assertArrayEquals(STR3, accessor2.get(2));\n-        assertArrayEquals(STR4, accessor2.get(3));\n-        assertArrayEquals(STR5, accessor2.get(4));\n-        assertArrayEquals(STR6, accessor2.get(5));\n+        assertArrayEquals(STR1, vector2.get(0));\n+        assertArrayEquals(STR2, vector2.get(1));\n+        assertArrayEquals(STR3, vector2.get(2));\n+        assertArrayEquals(STR4, vector2.get(3));\n+        assertArrayEquals(STR5, vector2.get(4));\n+        assertArrayEquals(STR6, vector2.get(5));\n       }\n     }\n   }\n@@ -1396,8 +1727,6 @@ public void testVectorLoadUnload() {\n   public void testFillEmptiesUsage() {\n     try (final NullableVarCharVector vector = new NullableVarCharVector(\"myvector\", allocator)) {\n \n-      final NullableVarCharVector.Mutator mutator = vector.getMutator();\n-\n       vector.allocateNew(1024 * 10, 1024);\n \n       setBytes(0, STR1, vector);\n@@ -1408,84 +1737,98 @@ public void testFillEmptiesUsage() {\n       setBytes(5, STR6, vector);\n \n       /* Check current lastSet */\n-      assertEquals(Integer.toString(-1), Integer.toString(mutator.getLastSet()));\n+      assertEquals(Integer.toString(-1), Integer.toString(vector.getLastSet()));\n \n       /* Check the vector output */\n-      final NullableVarCharVector.Accessor accessor = vector.getAccessor();\n-      assertArrayEquals(STR1, accessor.get(0));\n-      assertArrayEquals(STR2, accessor.get(1));\n-      assertArrayEquals(STR3, accessor.get(2));\n-      assertArrayEquals(STR4, accessor.get(3));\n-      assertArrayEquals(STR5, accessor.get(4));\n-      assertArrayEquals(STR6, accessor.get(5));\n-\n-      mutator.setLastSet(5);\n+      assertArrayEquals(STR1, vector.get(0));\n+      assertArrayEquals(STR2, vector.get(1));\n+      assertArrayEquals(STR3, vector.get(2));\n+      assertArrayEquals(STR4, vector.get(3));\n+      assertArrayEquals(STR5, vector.get(4));\n+      assertArrayEquals(STR6, vector.get(5));\n+\n+      vector.setLastSet(5);\n       /* fill empty byte arrays from index [6, 9] */\n-      mutator.fillEmpties(10);\n+      vector.fillEmpties(10);\n \n       /* Check current lastSet */\n-      assertEquals(Integer.toString(9), Integer.toString(mutator.getLastSet()));\n+      assertEquals(Integer.toString(9), Integer.toString(vector.getLastSet()));\n \n       /* Check the vector output */\n-      assertArrayEquals(STR1, accessor.get(0));\n-      assertArrayEquals(STR2, accessor.get(1));\n-      assertArrayEquals(STR3, accessor.get(2));\n-      assertArrayEquals(STR4, accessor.get(3));\n-      assertArrayEquals(STR5, accessor.get(4));\n-      assertArrayEquals(STR6, accessor.get(5));\n-      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(6)));\n-      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(7)));\n-      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(8)));\n-      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(9)));\n+      assertArrayEquals(STR1, vector.get(0));\n+      assertArrayEquals(STR2, vector.get(1));\n+      assertArrayEquals(STR3, vector.get(2));\n+      assertArrayEquals(STR4, vector.get(3));\n+      assertArrayEquals(STR5, vector.get(4));\n+      assertArrayEquals(STR6, vector.get(5));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(6)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(7)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(8)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(9)));\n \n       setBytes(10, STR1, vector);\n       setBytes(11, STR2, vector);\n \n-      mutator.setLastSet(11);\n+      vector.setLastSet(11);\n       /* fill empty byte arrays from index [12, 14] */\n-      mutator.setValueCount(15);\n+      vector.setValueCount(15);\n \n       /* Check current lastSet */\n-      assertEquals(Integer.toString(14), Integer.toString(mutator.getLastSet()));\n+      assertEquals(Integer.toString(14), Integer.toString(vector.getLastSet()));\n \n       /* Check the vector output */\n-      assertArrayEquals(STR1, accessor.get(0));\n-      assertArrayEquals(STR2, accessor.get(1));\n-      assertArrayEquals(STR3, accessor.get(2));\n-      assertArrayEquals(STR4, accessor.get(3));\n-      assertArrayEquals(STR5, accessor.get(4));\n-      assertArrayEquals(STR6, accessor.get(5));\n-      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(6)));\n-      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(7)));\n-      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(8)));\n-      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(9)));\n-      assertArrayEquals(STR1, accessor.get(10));\n-      assertArrayEquals(STR2, accessor.get(11));\n-      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(12)));\n-      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(13)));\n-      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(14)));\n+      assertArrayEquals(STR1, vector.get(0));\n+      assertArrayEquals(STR2, vector.get(1));\n+      assertArrayEquals(STR3, vector.get(2));\n+      assertArrayEquals(STR4, vector.get(3));\n+      assertArrayEquals(STR5, vector.get(4));\n+      assertArrayEquals(STR6, vector.get(5));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(6)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(7)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(8)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(9)));\n+      assertArrayEquals(STR1, vector.get(10));\n+      assertArrayEquals(STR2, vector.get(11));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(12)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(13)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(14)));\n \n       /* Check offsets */\n-      final UInt4Vector.Accessor offsetAccessor = vector.values.offsetVector.getAccessor();\n-      assertEquals(Integer.toString(0), Integer.toString(offsetAccessor.get(0)));\n-      assertEquals(Integer.toString(6), Integer.toString(offsetAccessor.get(1)));\n-      assertEquals(Integer.toString(16), Integer.toString(offsetAccessor.get(2)));\n-      assertEquals(Integer.toString(21), Integer.toString(offsetAccessor.get(3)));\n-      assertEquals(Integer.toString(30), Integer.toString(offsetAccessor.get(4)));\n-      assertEquals(Integer.toString(34), Integer.toString(offsetAccessor.get(5)));\n-\n-      assertEquals(Integer.toString(40), Integer.toString(offsetAccessor.get(6)));\n-      assertEquals(Integer.toString(40), Integer.toString(offsetAccessor.get(7)));\n-      assertEquals(Integer.toString(40), Integer.toString(offsetAccessor.get(8)));\n-      assertEquals(Integer.toString(40), Integer.toString(offsetAccessor.get(9)));\n-      assertEquals(Integer.toString(40), Integer.toString(offsetAccessor.get(10)));\n-\n-      assertEquals(Integer.toString(46), Integer.toString(offsetAccessor.get(11)));\n-      assertEquals(Integer.toString(56), Integer.toString(offsetAccessor.get(12)));\n-\n-      assertEquals(Integer.toString(56), Integer.toString(offsetAccessor.get(13)));\n-      assertEquals(Integer.toString(56), Integer.toString(offsetAccessor.get(14)));\n-      assertEquals(Integer.toString(56), Integer.toString(offsetAccessor.get(15)));\n+      assertEquals(Integer.toString(0),\n+              Integer.toString(vector.offsetBuffer.getInt(0 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(6),\n+              Integer.toString(vector.offsetBuffer.getInt(1 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(16),\n+              Integer.toString(vector.offsetBuffer.getInt(2 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(21),\n+              Integer.toString(vector.offsetBuffer.getInt(3 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(30),\n+              Integer.toString(vector.offsetBuffer.getInt(4 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(34),\n+              Integer.toString(vector.offsetBuffer.getInt(5 * vector.OFFSET_WIDTH)));\n+\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(6 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(7 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(8 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(9 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(10 * vector.OFFSET_WIDTH)));\n+\n+      assertEquals(Integer.toString(46),\n+              Integer.toString(vector.offsetBuffer.getInt(11 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(56),\n+              Integer.toString(vector.offsetBuffer.getInt(12 * vector.OFFSET_WIDTH)));\n+\n+      assertEquals(Integer.toString(56),\n+              Integer.toString(vector.offsetBuffer.getInt(13 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(56),\n+              Integer.toString(vector.offsetBuffer.getInt(14 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(56),\n+              Integer.toString(vector.offsetBuffer.getInt(15 * vector.OFFSET_WIDTH)));\n     }\n   }\n \n@@ -1493,29 +1836,25 @@ public void testFillEmptiesUsage() {\n   public void testGetBufferAddress1() {\n \n     try (final NullableVarCharVector vector = new NullableVarCharVector(\"myvector\", allocator)) {\n-\n-      final NullableVarCharVector.Mutator mutator = vector.getMutator();\n-      final NullableVarCharVector.Accessor accessor = vector.getAccessor();\n-\n       vector.allocateNew(1024 * 10, 1024);\n \n       /* populate the vector */\n-      mutator.set(0, STR1);\n-      mutator.set(1, STR2);\n-      mutator.set(2, STR3);\n-      mutator.set(3, STR4);\n-      mutator.set(4, STR5);\n-      mutator.set(5, STR6);\n+      vector.set(0, STR1);\n+      vector.set(1, STR2);\n+      vector.set(2, STR3);\n+      vector.set(3, STR4);\n+      vector.set(4, STR5);\n+      vector.set(5, STR6);\n \n-      mutator.setValueCount(15);\n+      vector.setValueCount(15);\n \n       /* check the vector output */\n-      assertArrayEquals(STR1, accessor.get(0));\n-      assertArrayEquals(STR2, accessor.get(1));\n-      assertArrayEquals(STR3, accessor.get(2));\n-      assertArrayEquals(STR4, accessor.get(3));\n-      assertArrayEquals(STR5, accessor.get(4));\n-      assertArrayEquals(STR6, accessor.get(5));\n+      assertArrayEquals(STR1, vector.get(0));\n+      assertArrayEquals(STR2, vector.get(1));\n+      assertArrayEquals(STR3, vector.get(2));\n+      assertArrayEquals(STR4, vector.get(3));\n+      assertArrayEquals(STR5, vector.get(4));\n+      assertArrayEquals(STR6, vector.get(5));\n \n       List<ArrowBuf> buffers = vector.getFieldBuffers();\n       long bitAddress = vector.getValidityBufferAddress();\n@@ -1531,23 +1870,18 @@ public void testGetBufferAddress1() {\n \n   @Test /* NullableIntVector */\n   public void testGetBufferAddress2() {\n-\n     try (final NullableIntVector vector = new NullableIntVector(\"myvector\", allocator)) {\n-\n-      final NullableIntVector.Mutator mutator = vector.getMutator();\n-      final NullableIntVector.Accessor accessor = vector.getAccessor();\n       boolean error = false;\n-\n       vector.allocateNew(16);\n \n       /* populate the vector */\n       for(int i = 0; i < 16; i += 2) {\n-        mutator.set(i, i+10);\n+        vector.set(i, i+10);\n       }\n \n       /* check the vector output */\n       for(int i = 0; i < 16; i += 2) {\n-        assertEquals(i+10, accessor.get(i));\n+        assertEquals(i+10, vector.get(i));\n       }\n \n       List<ArrowBuf> buffers = vector.getFieldBuffers();\n@@ -1580,11 +1914,15 @@ public void testMultipleClose() {\n     vectorAllocator.close();\n   }\n \n+  /* this method is used by the tests to bypass the vector set methods that manipulate\n+   * lastSet. The method is to test the lastSet property and that's why we load the vector\n+   * in a way that lastSet is not set automatically.\n+   */\n   public static void setBytes(int index, byte[] bytes, NullableVarCharVector vector) {\n-    final int currentOffset = vector.values.offsetVector.getAccessor().get(index);\n+    final int currentOffset = vector.offsetBuffer.getInt(index * vector.OFFSET_WIDTH);\n \n-    vector.bits.getMutator().setToOne(index);\n-    vector.values.offsetVector.getMutator().set(index + 1, currentOffset + bytes.length);\n-    vector.values.data.setBytes(currentOffset, bytes, 0, bytes.length);\n+    BitVectorHelper.setValidityBitToOne(vector.validityBuffer, index);\n+    vector.offsetBuffer.setInt((index + 1) * vector.OFFSET_WIDTH, currentOffset + bytes.length);\n+    vector.valueBuffer.setBytes(currentOffset, bytes, 0, bytes.length);\n   }\n }\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReAlloc.java b/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReAlloc.java\nindex 4ac7536c0..293ffbfe1 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReAlloc.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReAlloc.java\n@@ -28,6 +28,7 @@\n import org.apache.arrow.vector.complex.ListVector;\n import org.apache.arrow.vector.complex.NullableMapVector;\n import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.junit.After;\n import org.junit.Assert;\n@@ -76,24 +77,23 @@ public void testFixedType() {\n   @Test\n   public void testNullableType() {\n     try (final NullableVarCharVector vector = new NullableVarCharVector(\"\", allocator)) {\n-      final NullableVarCharVector.Mutator m = vector.getMutator();\n       vector.setInitialCapacity(512);\n       vector.allocateNew();\n \n       assertEquals(512, vector.getValueCapacity());\n \n       try {\n-        m.set(512, \"foo\".getBytes(StandardCharsets.UTF_8));\n+        vector.set(512, \"foo\".getBytes(StandardCharsets.UTF_8));\n         Assert.fail(\"Expected out of bounds exception\");\n       } catch (Exception e) {\n         // ok\n       }\n \n       vector.reAlloc();\n-      assertEquals(1023, vector.getValueCapacity());\n+      assertEquals(1024, vector.getValueCapacity());\n \n-      m.set(512, \"foo\".getBytes(StandardCharsets.UTF_8));\n-      assertEquals(\"foo\", new String(vector.getAccessor().get(512), StandardCharsets.UTF_8));\n+      vector.set(512, \"foo\".getBytes(StandardCharsets.UTF_8));\n+      assertEquals(\"foo\", new String(vector.get(512), StandardCharsets.UTF_8));\n     }\n   }\n \n@@ -105,7 +105,7 @@ public void testListType() {\n       vector.setInitialCapacity(512);\n       vector.allocateNew();\n \n-      assertEquals(1023, vector.getValueCapacity()); // TODO this doubles for some reason...\n+      assertEquals(1023, vector.getValueCapacity());\n \n       try {\n         vector.getOffsetVector().getAccessor().get(2014);\n@@ -116,7 +116,7 @@ public void testListType() {\n \n       vector.reAlloc();\n       assertEquals(2047, vector.getValueCapacity()); // note: size - 1\n-      assertEquals(0, vector.getOffsetVector().getAccessor().get(2014));\n+      assertEquals(0, vector.getOffsetBuffer().getInt(2014 * ListVector.OFFSET_WIDTH));\n     }\n   }\n \n@@ -139,7 +139,7 @@ public void testMapType() {\n \n       vector.reAlloc();\n       assertEquals(1024, vector.getValueCapacity());\n-      assertNull(vector.getAccessor().getObject(513));\n+      assertNull(vector.getObject(513));\n     }\n   }\n }\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestVectorUnloadLoad.java b/java/vector/src/test/java/org/apache/arrow/vector/TestVectorUnloadLoad.java\nindex 7facf73f5..3853eecac 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestVectorUnloadLoad.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestVectorUnloadLoad.java\n@@ -45,13 +45,21 @@\n import org.apache.arrow.vector.types.pojo.Field;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.types.pojo.Schema;\n-import org.junit.AfterClass;\n-import org.junit.Assert;\n-import org.junit.Test;\n+import org.junit.*;\n \n public class TestVectorUnloadLoad {\n \n-  static final BufferAllocator allocator = new RootAllocator(Integer.MAX_VALUE);\n+  private BufferAllocator allocator;\n+\n+  @Before\n+  public void init() {\n+    allocator = new RootAllocator(Long.MAX_VALUE);\n+  }\n+\n+  @After\n+  public void terminate() throws Exception {\n+    allocator.close();\n+  }\n \n   @Test\n   public void testUnloadLoad() throws IOException {\n@@ -183,24 +191,42 @@ public void testUnloadLoadAddPadding() throws IOException {\n    * @throws IOException\n    */\n   @Test\n-  public void testLoadEmptyValidityBuffer() throws IOException {\n+  public void testLoadValidityBuffer() throws IOException {\n     Schema schema = new Schema(asList(\n         new Field(\"intDefined\", FieldType.nullable(new ArrowType.Int(32, true)), Collections.<Field>emptyList()),\n         new Field(\"intNull\", FieldType.nullable(new ArrowType.Int(32, true)), Collections.<Field>emptyList())\n     ));\n     int count = 10;\n-    ArrowBuf validity = allocator.buffer(10).slice(0, 0);\n-    ArrowBuf[] values = new ArrowBuf[2];\n-    for (int i = 0; i < values.length; i++) {\n-      ArrowBuf arrowBuf = allocator.buffer(count * 4); // integers\n-      values[i] = arrowBuf;\n+    ArrowBuf[] values = new ArrowBuf[4];\n+    for (int i = 0; i < 4; i+=2) {\n+      ArrowBuf buf1 = allocator.buffer(BitVectorHelper.getValidityBufferSize(count));\n+      ArrowBuf buf2 = allocator.buffer(count * 4); // integers\n+      buf1.setZero(0, buf1.capacity());\n+      buf2.setZero(0, buf2.capacity());\n+      values[i] = buf1;\n+      values[i+1] = buf2;\n       for (int j = 0; j < count; j++) {\n-        arrowBuf.setInt(j * 4, j);\n+        if (i == 2) {\n+          BitVectorHelper.setValidityBit(buf1, j, 0);\n+        } else {\n+          BitVectorHelper.setValidityBitToOne(buf1, j);\n+        }\n+\n+        buf2.setInt(j * 4, j);\n       }\n-      arrowBuf.writerIndex(count * 4);\n+      buf1.writerIndex((int)Math.ceil(count / 8));\n+      buf2.writerIndex(count * 4);\n     }\n+\n+    /*\n+     * values[0] - validity buffer for first vector\n+     * values[1] - data buffer for first vector\n+     * values[2] - validity buffer for second vector\n+     * values[3] - data buffer for second vector\n+     */\n+\n     try (\n-        ArrowRecordBatch recordBatch = new ArrowRecordBatch(count, asList(new ArrowFieldNode(count, 0), new ArrowFieldNode(count, count)), asList(validity, values[0], validity, values[1]));\n+        ArrowRecordBatch recordBatch = new ArrowRecordBatch(count, asList(new ArrowFieldNode(count, 0), new ArrowFieldNode(count, count)), asList(values[0], values[1], values[2], values[3]));\n         BufferAllocator finalVectorsAllocator = allocator.newChildAllocator(\"final vectors\", 0, Integer.MAX_VALUE);\n         VectorSchemaRoot newRoot = VectorSchemaRoot.create(schema, finalVectorsAllocator);\n     ) {\n@@ -213,32 +239,31 @@ public void testLoadEmptyValidityBuffer() throws IOException {\n       NullableIntVector intDefinedVector = (NullableIntVector) newRoot.getVector(\"intDefined\");\n       NullableIntVector intNullVector = (NullableIntVector) newRoot.getVector(\"intNull\");\n       for (int i = 0; i < count; i++) {\n-        assertFalse(\"#\" + i, intDefinedVector.getAccessor().isNull(i));\n-        assertEquals(\"#\" + i, i, intDefinedVector.getAccessor().get(i));\n-        assertTrue(\"#\" + i, intNullVector.getAccessor().isNull(i));\n+        assertFalse(\"#\" + i, intDefinedVector.isNull(i));\n+        assertEquals(\"#\" + i, i, intDefinedVector.get(i));\n+        assertTrue(\"#\" + i, intNullVector.isNull(i));\n       }\n-      intDefinedVector.getMutator().setSafe(count + 10, 1234);\n-      assertTrue(intDefinedVector.getAccessor().isNull(count + 1));\n+      intDefinedVector.setSafe(count + 10, 1234);\n+      assertTrue(intDefinedVector.isNull(count + 1));\n       // empty slots should still default to unset\n-      intDefinedVector.getMutator().setSafe(count + 1, 789);\n-      assertFalse(intDefinedVector.getAccessor().isNull(count + 1));\n-      assertEquals(789, intDefinedVector.getAccessor().get(count + 1));\n-      assertTrue(intDefinedVector.getAccessor().isNull(count));\n-      assertTrue(intDefinedVector.getAccessor().isNull(count + 2));\n-      assertTrue(intDefinedVector.getAccessor().isNull(count + 3));\n-      assertTrue(intDefinedVector.getAccessor().isNull(count + 4));\n-      assertTrue(intDefinedVector.getAccessor().isNull(count + 5));\n-      assertTrue(intDefinedVector.getAccessor().isNull(count + 6));\n-      assertTrue(intDefinedVector.getAccessor().isNull(count + 7));\n-      assertTrue(intDefinedVector.getAccessor().isNull(count + 8));\n-      assertTrue(intDefinedVector.getAccessor().isNull(count + 9));\n-      assertFalse(intDefinedVector.getAccessor().isNull(count + 10));\n-      assertEquals(1234, intDefinedVector.getAccessor().get(count + 10));\n+      intDefinedVector.setSafe(count + 1, 789);\n+      assertFalse(intDefinedVector.isNull(count + 1));\n+      assertEquals(789, intDefinedVector.get(count + 1));\n+      assertTrue(intDefinedVector.isNull(count));\n+      assertTrue(intDefinedVector.isNull(count + 2));\n+      assertTrue(intDefinedVector.isNull(count + 3));\n+      assertTrue(intDefinedVector.isNull(count + 4));\n+      assertTrue(intDefinedVector.isNull(count + 5));\n+      assertTrue(intDefinedVector.isNull(count + 6));\n+      assertTrue(intDefinedVector.isNull(count + 7));\n+      assertTrue(intDefinedVector.isNull(count + 8));\n+      assertTrue(intDefinedVector.isNull(count + 9));\n+      assertFalse(intDefinedVector.isNull(count + 10));\n+      assertEquals(1234, intDefinedVector.get(count + 10));\n     } finally {\n       for (ArrowBuf arrowBuf : values) {\n         arrowBuf.release();\n       }\n-      validity.release();\n     }\n   }\n \n@@ -258,11 +283,11 @@ public void testUnloadLoadDuplicates() throws IOException {\n         FieldVector vector = field.createVector(originalVectorsAllocator);\n         vector.allocateNew();\n         sources.add(vector);\n-        NullableIntVector.Mutator mutator = (NullableIntVector.Mutator) vector.getMutator();\n+        NullableIntVector intVector = (NullableIntVector)vector;\n         for (int i = 0; i < count; i++) {\n-          mutator.set(i, i);\n+          intVector.set(i, i);\n         }\n-        mutator.setValueCount(count);\n+        intVector.setValueCount(count);\n       }\n \n       try (VectorSchemaRoot root = new VectorSchemaRoot(schema.getFields(), sources, count)) {\n@@ -277,8 +302,8 @@ public void testUnloadLoadDuplicates() throws IOException {\n           List<FieldVector> targets = newRoot.getFieldVectors();\n           Assert.assertEquals(sources.size(), targets.size());\n           for (int k = 0; k < sources.size(); k++) {\n-            NullableIntVector.Accessor src = (NullableIntVector.Accessor) sources.get(k).getAccessor();\n-            NullableIntVector.Accessor tgt = (NullableIntVector.Accessor) targets.get(k).getAccessor();\n+            NullableIntVector src = (NullableIntVector) sources.get(k);\n+            NullableIntVector tgt = (NullableIntVector) targets.get(k);\n             Assert.assertEquals(src.getValueCount(), tgt.getValueCount());\n             for (int i = 0; i < count; i++) {\n               Assert.assertEquals(src.get(i), tgt.get(i));\n@@ -291,14 +316,9 @@ public void testUnloadLoadDuplicates() throws IOException {\n \n   public static VectorUnloader newVectorUnloader(FieldVector root) {\n     Schema schema = new Schema(root.getField().getChildren());\n-    int valueCount = root.getAccessor().getValueCount();\n+    int valueCount = root.getValueCount();\n     List<FieldVector> fields = root.getChildrenFromFields();\n     VectorSchemaRoot vsr = new VectorSchemaRoot(schema.getFields(), fields, valueCount);\n     return new VectorUnloader(vsr);\n   }\n-\n-  @AfterClass\n-  public static void afterClass() {\n-    allocator.close();\n-  }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/complex/impl/TestPromotableWriter.java b/java/vector/src/test/java/org/apache/arrow/vector/complex/impl/TestPromotableWriter.java\nindex 97efb7d5a..b0d6cf555 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/complex/impl/TestPromotableWriter.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/complex/impl/TestPromotableWriter.java\n@@ -80,24 +80,23 @@ public void testPromoteToUnion() throws Exception {\n \n       writer.end();\n \n-      container.getMutator().setValueCount(5);\n+      container.setValueCount(5);\n \n       final UnionVector uv = v.getChild(\"A\", UnionVector.class);\n-      final UnionVector.Accessor accessor = uv.getAccessor();\n \n-      assertFalse(\"0 shouldn't be null\", accessor.isNull(0));\n-      assertEquals(false, accessor.getObject(0));\n+      assertFalse(\"0 shouldn't be null\", uv.isNull(0));\n+      assertEquals(false, uv.getObject(0));\n \n-      assertFalse(\"1 shouldn't be null\", accessor.isNull(1));\n-      assertEquals(true, accessor.getObject(1));\n+      assertFalse(\"1 shouldn't be null\", uv.isNull(1));\n+      assertEquals(true, uv.getObject(1));\n \n-      assertFalse(\"2 shouldn't be null\", accessor.isNull(2));\n-      assertEquals(10, accessor.getObject(2));\n+      assertFalse(\"2 shouldn't be null\", uv.isNull(2));\n+      assertEquals(10, uv.getObject(2));\n \n-      assertTrue(\"3 should be null\", accessor.isNull(3));\n+      assertTrue(\"3 should be null\", uv.isNull(3));\n \n-      assertFalse(\"4 shouldn't be null\", accessor.isNull(4));\n-      assertEquals(100, accessor.getObject(4));\n+      assertFalse(\"4 shouldn't be null\", uv.isNull(4));\n+      assertEquals(100, uv.getObject(4));\n \n       container.clear();\n       container.allocateNew();\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/complex/writer/TestComplexWriter.java b/java/vector/src/test/java/org/apache/arrow/vector/complex/writer/TestComplexWriter.java\nindex 856d60724..52defdc2e 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/complex/writer/TestComplexWriter.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/complex/writer/TestComplexWriter.java\n@@ -456,7 +456,7 @@ public void simpleUnion() {\n         unionWriter.writeFloat4((float) i);\n       }\n     }\n-    vector.getMutator().setValueCount(COUNT);\n+    vector.setValueCount(COUNT);\n     UnionReader unionReader = new UnionReader(vector);\n     for (int i = 0; i < COUNT; i++) {\n       unionReader.setPosition(i);\n@@ -834,7 +834,7 @@ public void complexCopierWithList() {\n     TransferPair tp = mapVector.getTransferPair(allocator);\n     tp.splitAndTransfer(0, 1);\n     MapVector toMapVector = (MapVector) tp.getTo();\n-    JsonStringHashMap<?, ?> toMapValue = (JsonStringHashMap<?, ?>) toMapVector.getAccessor().getObject(0);\n+    JsonStringHashMap<?, ?> toMapValue = (JsonStringHashMap<?, ?>) toMapVector.getObject(0);\n     JsonStringArrayList<?> object = (JsonStringArrayList<?>) toMapValue.get(\"list\");\n     assertEquals(1, object.get(0));\n     assertEquals(2, object.get(1));\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/file/BaseFileTest.java b/java/vector/src/test/java/org/apache/arrow/vector/file/BaseFileTest.java\nindex ba62de0a6..874ba99e2 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/file/BaseFileTest.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/file/BaseFileTest.java\n@@ -97,8 +97,8 @@ public void tearDown() {\n \n   protected void validateContent(int count, VectorSchemaRoot root) {\n     for (int i = 0; i < count; i++) {\n-      Assert.assertEquals(i, root.getVector(\"int\").getAccessor().getObject(i));\n-      Assert.assertEquals(Long.valueOf(i), root.getVector(\"bigInt\").getAccessor().getObject(i));\n+      Assert.assertEquals(i, root.getVector(\"int\").getObject(i));\n+      Assert.assertEquals(Long.valueOf(i), root.getVector(\"bigInt\").getObject(i));\n     }\n   }\n \n@@ -140,10 +140,9 @@ protected void writeComplexData(int count, MapVector parent) {\n   public void printVectors(List<FieldVector> vectors) {\n     for (FieldVector vector : vectors) {\n       LOGGER.debug(vector.getField().getName());\n-      Accessor accessor = vector.getAccessor();\n-      int valueCount = accessor.getValueCount();\n+      int valueCount = vector.getValueCount();\n       for (int i = 0; i < valueCount; i++) {\n-        LOGGER.debug(String.valueOf(accessor.getObject(i)));\n+        LOGGER.debug(String.valueOf(vector.getObject(i)));\n       }\n     }\n   }\n@@ -152,14 +151,15 @@ protected void validateComplexContent(int count, VectorSchemaRoot root) {\n     Assert.assertEquals(count, root.getRowCount());\n     printVectors(root.getFieldVectors());\n     for (int i = 0; i < count; i++) {\n-      Object intVal = root.getVector(\"int\").getAccessor().getObject(i);\n+\n+      Object intVal = root.getVector(\"int\").getObject(i);\n       if (i % 5 != 3) {\n         Assert.assertEquals(i, intVal);\n       } else {\n         Assert.assertNull(intVal);\n       }\n-      Assert.assertEquals(Long.valueOf(i), root.getVector(\"bigInt\").getAccessor().getObject(i));\n-      Assert.assertEquals(i % 3, ((List<?>) root.getVector(\"list\").getAccessor().getObject(i)).size());\n+      Assert.assertEquals(Long.valueOf(i), root.getVector(\"bigInt\").getObject(i));\n+      Assert.assertEquals(i % 3, ((List<?>) root.getVector(\"list\").getObject(i)).size());\n       NullableTimeStampMilliHolder h = new NullableTimeStampMilliHolder();\n       FieldReader mapReader = root.getVector(\"map\").getReader();\n       mapReader.setPosition(i);\n@@ -202,15 +202,15 @@ protected void validateDateTimeContent(int count, VectorSchemaRoot root) {\n     Assert.assertEquals(count, root.getRowCount());\n     printVectors(root.getFieldVectors());\n     for (int i = 0; i < count; i++) {\n-      long dateVal = ((NullableDateMilliVector) root.getVector(\"date\")).getAccessor().get(i);\n+      long dateVal = ((NullableDateMilliVector) root.getVector(\"date\")).get(i);\n       LocalDateTime dt = makeDateTimeFromCount(i);\n       LocalDateTime dateExpected = dt.minusMillis(dt.getMillisOfDay());\n       Assert.assertEquals(DateUtility.toMillis(dateExpected), dateVal);\n-      long timeVal = ((NullableTimeMilliVector) root.getVector(\"time\")).getAccessor().get(i);\n+      long timeVal = ((NullableTimeMilliVector) root.getVector(\"time\")).get(i);\n       Assert.assertEquals(dt.getMillisOfDay(), timeVal);\n-      Object timestampMilliVal = root.getVector(\"timestamp-milli\").getAccessor().getObject(i);\n+      Object timestampMilliVal = root.getVector(\"timestamp-milli\").getObject(i);\n       Assert.assertEquals(dt, timestampMilliVal);\n-      Object timestampMilliTZVal = root.getVector(\"timestamp-milliTZ\").getAccessor().getObject(i);\n+      Object timestampMilliTZVal = root.getVector(\"timestamp-milliTZ\").getObject(i);\n       Assert.assertEquals(DateUtility.toMillis(dt), timestampMilliTZVal);\n     }\n   }\n@@ -220,22 +220,20 @@ protected VectorSchemaRoot writeFlatDictionaryData(BufferAllocator bufferAllocat\n     // Define dictionaries and add to provider\n     NullableVarCharVector dictionary1Vector = newNullableVarCharVector(\"D1\", bufferAllocator);\n     dictionary1Vector.allocateNewSafe();\n-    NullableVarCharVector.Mutator mutator = dictionary1Vector.getMutator();\n-    mutator.set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n-    mutator.set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n-    mutator.set(2, \"baz\".getBytes(StandardCharsets.UTF_8));\n-    mutator.setValueCount(3);\n+    dictionary1Vector.set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n+    dictionary1Vector.set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n+    dictionary1Vector.set(2, \"baz\".getBytes(StandardCharsets.UTF_8));\n+    dictionary1Vector.setValueCount(3);\n \n     Dictionary dictionary1 = new Dictionary(dictionary1Vector, new DictionaryEncoding(1L, false, null));\n     provider.put(dictionary1);\n \n     NullableVarCharVector dictionary2Vector = newNullableVarCharVector(\"D2\", bufferAllocator);\n     dictionary2Vector.allocateNewSafe();\n-    mutator = dictionary2Vector.getMutator();\n-    mutator.set(0, \"micro\".getBytes(StandardCharsets.UTF_8));\n-    mutator.set(1, \"small\".getBytes(StandardCharsets.UTF_8));\n-    mutator.set(2, \"large\".getBytes(StandardCharsets.UTF_8));\n-    mutator.setValueCount(3);\n+    dictionary2Vector.set(0, \"micro\".getBytes(StandardCharsets.UTF_8));\n+    dictionary2Vector.set(1, \"small\".getBytes(StandardCharsets.UTF_8));\n+    dictionary2Vector.set(2, \"large\".getBytes(StandardCharsets.UTF_8));\n+    dictionary2Vector.setValueCount(3);\n \n     Dictionary dictionary2 = new Dictionary(dictionary2Vector, new DictionaryEncoding(2L, false, null));\n     provider.put(dictionary2);\n@@ -243,13 +241,12 @@ protected VectorSchemaRoot writeFlatDictionaryData(BufferAllocator bufferAllocat\n     // Populate the vectors\n     NullableVarCharVector vector1A = newNullableVarCharVector(\"varcharA\", bufferAllocator);\n     vector1A.allocateNewSafe();\n-    mutator = vector1A.getMutator();\n-    mutator.set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n-    mutator.set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n-    mutator.set(3, \"baz\".getBytes(StandardCharsets.UTF_8));\n-    mutator.set(4, \"bar\".getBytes(StandardCharsets.UTF_8));\n-    mutator.set(5, \"baz\".getBytes(StandardCharsets.UTF_8));\n-    mutator.setValueCount(6);\n+    vector1A.set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n+    vector1A.set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n+    vector1A.set(3, \"baz\".getBytes(StandardCharsets.UTF_8));\n+    vector1A.set(4, \"bar\".getBytes(StandardCharsets.UTF_8));\n+    vector1A.set(5, \"baz\".getBytes(StandardCharsets.UTF_8));\n+    vector1A.setValueCount(6);\n \n     FieldVector encodedVector1A = (FieldVector) DictionaryEncoder.encode(vector1A, dictionary1);\n     vector1A.close();  // Done with this vector after encoding\n@@ -257,22 +254,20 @@ protected VectorSchemaRoot writeFlatDictionaryData(BufferAllocator bufferAllocat\n     // Write this vector using indices instead of encoding\n     NullableIntVector encodedVector1B = new NullableIntVector(\"varcharB\", bufferAllocator);\n     encodedVector1B.allocateNewSafe();\n-    NullableIntVector.Mutator mutator1B = encodedVector1B.getMutator();\n-    mutator1B.set(0, 2);  // \"baz\"\n-    mutator1B.set(1, 1);  // \"bar\"\n-    mutator1B.set(2, 2);  // \"baz\"\n-    mutator1B.set(4, 1);  // \"bar\"\n-    mutator1B.set(5, 0);  // \"foo\"\n-    mutator1B.setValueCount(6);\n+    encodedVector1B.set(0, 2);  // \"baz\"\n+    encodedVector1B.set(1, 1);  // \"bar\"\n+    encodedVector1B.set(2, 2);  // \"baz\"\n+    encodedVector1B.set(4, 1);  // \"bar\"\n+    encodedVector1B.set(5, 0);  // \"foo\"\n+    encodedVector1B.setValueCount(6);\n \n     NullableVarCharVector vector2 = newNullableVarCharVector(\"sizes\", bufferAllocator);\n     vector2.allocateNewSafe();\n-    mutator = vector2.getMutator();\n-    mutator.set(1, \"large\".getBytes(StandardCharsets.UTF_8));\n-    mutator.set(2, \"small\".getBytes(StandardCharsets.UTF_8));\n-    mutator.set(3, \"small\".getBytes(StandardCharsets.UTF_8));\n-    mutator.set(4, \"large\".getBytes(StandardCharsets.UTF_8));\n-    mutator.setValueCount(6);\n+    vector2.set(1, \"large\".getBytes(StandardCharsets.UTF_8));\n+    vector2.set(2, \"small\".getBytes(StandardCharsets.UTF_8));\n+    vector2.set(3, \"small\".getBytes(StandardCharsets.UTF_8));\n+    vector2.set(4, \"large\".getBytes(StandardCharsets.UTF_8));\n+    vector2.setValueCount(6);\n \n     FieldVector encodedVector2 = (FieldVector) DictionaryEncoder.encode(vector2, dictionary2);\n     vector2.close();  // Done with this vector after encoding\n@@ -280,7 +275,7 @@ protected VectorSchemaRoot writeFlatDictionaryData(BufferAllocator bufferAllocat\n     List<Field> fields = ImmutableList.of(encodedVector1A.getField(), encodedVector1B.getField(), encodedVector2.getField());\n     List<FieldVector> vectors = ImmutableList.of(encodedVector1A, encodedVector1B, encodedVector2);\n \n-    return new VectorSchemaRoot(fields, vectors, encodedVector1A.getAccessor().getValueCount());\n+    return new VectorSchemaRoot(fields, vectors, encodedVector1A.getValueCount());\n   }\n \n   protected void validateFlatDictionary(VectorSchemaRoot root, DictionaryProvider provider) {\n@@ -291,14 +286,13 @@ protected void validateFlatDictionary(VectorSchemaRoot root, DictionaryProvider\n     Assert.assertNotNull(encoding1A);\n     Assert.assertEquals(1L, encoding1A.getId());\n \n-    FieldVector.Accessor accessor = vector1A.getAccessor();\n-    Assert.assertEquals(6, accessor.getValueCount());\n-    Assert.assertEquals(0, accessor.getObject(0));\n-    Assert.assertEquals(1, accessor.getObject(1));\n-    Assert.assertEquals(null, accessor.getObject(2));\n-    Assert.assertEquals(2, accessor.getObject(3));\n-    Assert.assertEquals(1, accessor.getObject(4));\n-    Assert.assertEquals(2, accessor.getObject(5));\n+    Assert.assertEquals(6, vector1A.getValueCount());\n+    Assert.assertEquals(0, vector1A.getObject(0));\n+    Assert.assertEquals(1, vector1A.getObject(1));\n+    Assert.assertEquals(null, vector1A.getObject(2));\n+    Assert.assertEquals(2, vector1A.getObject(3));\n+    Assert.assertEquals(1, vector1A.getObject(4));\n+    Assert.assertEquals(2, vector1A.getObject(5));\n \n     FieldVector vector1B = root.getVector(\"varcharB\");\n     Assert.assertNotNull(vector1B);\n@@ -308,14 +302,13 @@ protected void validateFlatDictionary(VectorSchemaRoot root, DictionaryProvider\n     Assert.assertTrue(encoding1A.equals(encoding1B));\n     Assert.assertEquals(1L, encoding1B.getId());\n \n-    accessor = vector1B.getAccessor();\n-    Assert.assertEquals(6, accessor.getValueCount());\n-    Assert.assertEquals(2, accessor.getObject(0));\n-    Assert.assertEquals(1, accessor.getObject(1));\n-    Assert.assertEquals(2, accessor.getObject(2));\n-    Assert.assertEquals(null, accessor.getObject(3));\n-    Assert.assertEquals(1, accessor.getObject(4));\n-    Assert.assertEquals(0, accessor.getObject(5));\n+    Assert.assertEquals(6, vector1B.getValueCount());\n+    Assert.assertEquals(2, vector1B.getObject(0));\n+    Assert.assertEquals(1, vector1B.getObject(1));\n+    Assert.assertEquals(2, vector1B.getObject(2));\n+    Assert.assertEquals(null, vector1B.getObject(3));\n+    Assert.assertEquals(1, vector1B.getObject(4));\n+    Assert.assertEquals(0, vector1B.getObject(5));\n \n     FieldVector vector2 = root.getVector(\"sizes\");\n     Assert.assertNotNull(vector2);\n@@ -324,30 +317,29 @@ protected void validateFlatDictionary(VectorSchemaRoot root, DictionaryProvider\n     Assert.assertNotNull(encoding2);\n     Assert.assertEquals(2L, encoding2.getId());\n \n-    accessor = vector2.getAccessor();\n-    Assert.assertEquals(6, accessor.getValueCount());\n-    Assert.assertEquals(null, accessor.getObject(0));\n-    Assert.assertEquals(2, accessor.getObject(1));\n-    Assert.assertEquals(1, accessor.getObject(2));\n-    Assert.assertEquals(1, accessor.getObject(3));\n-    Assert.assertEquals(2, accessor.getObject(4));\n-    Assert.assertEquals(null, accessor.getObject(5));\n+    Assert.assertEquals(6, vector2.getValueCount());\n+    Assert.assertEquals(null, vector2.getObject(0));\n+    Assert.assertEquals(2, vector2.getObject(1));\n+    Assert.assertEquals(1, vector2.getObject(2));\n+    Assert.assertEquals(1, vector2.getObject(3));\n+    Assert.assertEquals(2, vector2.getObject(4));\n+    Assert.assertEquals(null, vector2.getObject(5));\n \n     Dictionary dictionary1 = provider.lookup(1L);\n     Assert.assertNotNull(dictionary1);\n-    NullableVarCharVector.Accessor dictionaryAccessor = ((NullableVarCharVector) dictionary1.getVector()).getAccessor();\n-    Assert.assertEquals(3, dictionaryAccessor.getValueCount());\n-    Assert.assertEquals(new Text(\"foo\"), dictionaryAccessor.getObject(0));\n-    Assert.assertEquals(new Text(\"bar\"), dictionaryAccessor.getObject(1));\n-    Assert.assertEquals(new Text(\"baz\"), dictionaryAccessor.getObject(2));\n+    NullableVarCharVector dictionaryVector = ((NullableVarCharVector) dictionary1.getVector());\n+    Assert.assertEquals(3, dictionaryVector.getValueCount());\n+    Assert.assertEquals(new Text(\"foo\"), dictionaryVector.getObject(0));\n+    Assert.assertEquals(new Text(\"bar\"), dictionaryVector.getObject(1));\n+    Assert.assertEquals(new Text(\"baz\"), dictionaryVector.getObject(2));\n \n     Dictionary dictionary2 = provider.lookup(2L);\n     Assert.assertNotNull(dictionary2);\n-    dictionaryAccessor = ((NullableVarCharVector) dictionary2.getVector()).getAccessor();\n-    Assert.assertEquals(3, dictionaryAccessor.getValueCount());\n-    Assert.assertEquals(new Text(\"micro\"), dictionaryAccessor.getObject(0));\n-    Assert.assertEquals(new Text(\"small\"), dictionaryAccessor.getObject(1));\n-    Assert.assertEquals(new Text(\"large\"), dictionaryAccessor.getObject(2));\n+    dictionaryVector = ((NullableVarCharVector) dictionary2.getVector());\n+    Assert.assertEquals(3, dictionaryVector.getValueCount());\n+    Assert.assertEquals(new Text(\"micro\"), dictionaryVector.getObject(0));\n+    Assert.assertEquals(new Text(\"small\"), dictionaryVector.getObject(1));\n+    Assert.assertEquals(new Text(\"large\"), dictionaryVector.getObject(2));\n   }\n \n   protected VectorSchemaRoot writeNestedDictionaryData(BufferAllocator bufferAllocator, DictionaryProvider.MapDictionaryProvider provider) {\n@@ -355,9 +347,9 @@ protected VectorSchemaRoot writeNestedDictionaryData(BufferAllocator bufferAlloc\n     // Define the dictionary and add to the provider\n     NullableVarCharVector dictionaryVector = newNullableVarCharVector(\"D2\", bufferAllocator);\n     dictionaryVector.allocateNewSafe();\n-    dictionaryVector.getMutator().set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n-    dictionaryVector.getMutator().set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n-    dictionaryVector.getMutator().setValueCount(2);\n+    dictionaryVector.set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n+    dictionaryVector.set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n+    dictionaryVector.setValueCount(2);\n \n     Dictionary dictionary = new Dictionary(dictionaryVector, new DictionaryEncoding(2L, false, null));\n     provider.put(dictionary);\n@@ -396,18 +388,17 @@ protected void validateNestedDictionary(VectorSchemaRoot root, DictionaryProvide\n     Assert.assertEquals(2L, encoding.getId());\n     Assert.assertEquals(new ArrowType.Int(32, true), encoding.getIndexType());\n \n-    FieldVector.Accessor accessor = vector.getAccessor();\n-    Assert.assertEquals(3, accessor.getValueCount());\n-    Assert.assertEquals(Arrays.asList(0, 1), accessor.getObject(0));\n-    Assert.assertEquals(Arrays.asList(0), accessor.getObject(1));\n-    Assert.assertEquals(Arrays.asList(1), accessor.getObject(2));\n+    Assert.assertEquals(3, vector.getValueCount());\n+    Assert.assertEquals(Arrays.asList(0, 1), vector.getObject(0));\n+    Assert.assertEquals(Arrays.asList(0), vector.getObject(1));\n+    Assert.assertEquals(Arrays.asList(1), vector.getObject(2));\n \n     Dictionary dictionary = provider.lookup(2L);\n     Assert.assertNotNull(dictionary);\n-    NullableVarCharVector.Accessor dictionaryAccessor = ((NullableVarCharVector) dictionary.getVector()).getAccessor();\n-    Assert.assertEquals(2, dictionaryAccessor.getValueCount());\n-    Assert.assertEquals(new Text(\"foo\"), dictionaryAccessor.getObject(0));\n-    Assert.assertEquals(new Text(\"bar\"), dictionaryAccessor.getObject(1));\n+    NullableVarCharVector dictionaryVector = ((NullableVarCharVector) dictionary.getVector());\n+    Assert.assertEquals(2, dictionaryVector.getValueCount());\n+    Assert.assertEquals(new Text(\"foo\"), dictionaryVector.getObject(0));\n+    Assert.assertEquals(new Text(\"bar\"), dictionaryVector.getObject(1));\n   }\n \n   protected VectorSchemaRoot writeDecimalData(BufferAllocator bufferAllocator) {\n@@ -421,14 +412,14 @@ protected VectorSchemaRoot writeDecimalData(BufferAllocator bufferAllocator) {\n     decimalVector3.allocateNew(count);\n \n     for (int i = 0; i < count; i++) {\n-      decimalVector1.getMutator().setSafe(i, new BigDecimal(BigInteger.valueOf(i), 3));\n-      decimalVector2.getMutator().setSafe(i, new BigDecimal(BigInteger.valueOf(i * (1 << 10)), 2));\n-      decimalVector3.getMutator().setSafe(i, new BigDecimal(BigInteger.valueOf(i * 1111111111111111L), 8));\n+      decimalVector1.setSafe(i, new BigDecimal(BigInteger.valueOf(i), 3));\n+      decimalVector2.setSafe(i, new BigDecimal(BigInteger.valueOf(i * (1 << 10)), 2));\n+      decimalVector3.setSafe(i, new BigDecimal(BigInteger.valueOf(i * 1111111111111111L), 8));\n     }\n \n-    decimalVector1.getMutator().setValueCount(count);\n-    decimalVector2.getMutator().setValueCount(count);\n-    decimalVector3.getMutator().setValueCount(count);\n+    decimalVector1.setValueCount(count);\n+    decimalVector2.setValueCount(count);\n+    decimalVector3.setValueCount(count);\n \n     List<Field> fields = ImmutableList.of(decimalVector1.getField(), decimalVector2.getField(), decimalVector3.getField());\n     List<FieldVector> vectors = ImmutableList.<FieldVector>of(decimalVector1, decimalVector2, decimalVector3);\n@@ -444,19 +435,19 @@ protected void validateDecimalData(VectorSchemaRoot root) {\n \n     for (int i = 0; i < count; i++) {\n       // Verify decimal 1 vector\n-      BigDecimal readValue = decimalVector1.getAccessor().getObject(i);\n+      BigDecimal readValue = decimalVector1.getObject(i);\n       ArrowType.Decimal type = (ArrowType.Decimal) decimalVector1.getField().getType();\n       BigDecimal genValue = new BigDecimal(BigInteger.valueOf(i), type.getScale());\n       Assert.assertEquals(genValue, readValue);\n \n       // Verify decimal 2 vector\n-      readValue = decimalVector2.getAccessor().getObject(i);\n+      readValue = decimalVector2.getObject(i);\n       type = (ArrowType.Decimal) decimalVector2.getField().getType();\n       genValue = new BigDecimal(BigInteger.valueOf(i * (1 << 10)), type.getScale());\n       Assert.assertEquals(genValue, readValue);\n \n       // Verify decimal 3 vector\n-      readValue = decimalVector3.getAccessor().getObject(i);\n+      readValue = decimalVector3.getObject(i);\n       type = (ArrowType.Decimal) decimalVector3.getField().getType();\n       genValue = new BigDecimal(BigInteger.valueOf(i * 1111111111111111L), type.getScale());\n       Assert.assertEquals(genValue, readValue);\n@@ -569,7 +560,7 @@ protected void validateVarBinary(int count, VectorSchemaRoot root) {\n     int numVarBinaryValues = 0;\n     for (int i = 0; i < count; i++) {\n       expectedArray[i] = (byte) i;\n-      Object obj = listVector.getAccessor().getObject(i);\n+      Object obj = listVector.getObject(i);\n       List<?> objList = (List) obj;\n       if (i % 3 == 0) {\n         Assert.assertTrue(objList.isEmpty());\n@@ -584,10 +575,10 @@ protected void validateVarBinary(int count, VectorSchemaRoot root) {\n     }\n \n     // ListVector lastSet should be the index of last value + 1\n-    Assert.assertEquals(listVector.getMutator().getLastSet(), count);\n+    Assert.assertEquals(listVector.getLastSet(), count);\n \n     // NullableVarBinaryVector lastSet should be the index of last value\n     NullableVarBinaryVector binaryVector = (NullableVarBinaryVector) listVector.getChildrenFromFields().get(0);\n-    Assert.assertEquals(binaryVector.getMutator().getLastSet(), numVarBinaryValues - 1);\n+    Assert.assertEquals(binaryVector.getLastSet(), numVarBinaryValues - 1);\n   }\n }\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowFile.java b/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowFile.java\nindex 81e58989f..8559969a2 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowFile.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowFile.java\n@@ -317,11 +317,11 @@ public void testWriteReadTiny() throws IOException {\n \n     try (VectorSchemaRoot root = VectorSchemaRoot.create(MessageSerializerTest.testSchema(), allocator)) {\n       root.getFieldVectors().get(0).allocateNew();\n-      NullableTinyIntVector.Mutator mutator = (NullableTinyIntVector.Mutator) root.getFieldVectors().get(0).getMutator();\n+      NullableTinyIntVector vector = (NullableTinyIntVector) root.getFieldVectors().get(0);\n       for (int i = 0; i < 16; i++) {\n-        mutator.set(i, i < 8 ? 1 : 0, (byte) (i + 1));\n+        vector.set(i, i < 8 ? 1 : 0, (byte) (i + 1));\n       }\n-      mutator.setValueCount(16);\n+      vector.setValueCount(16);\n       root.setRowCount(16);\n \n       // write file\n@@ -368,9 +368,9 @@ private void validateTinyData(VectorSchemaRoot root) {\n     NullableTinyIntVector vector = (NullableTinyIntVector) root.getFieldVectors().get(0);\n     for (int i = 0; i < 16; i++) {\n       if (i < 8) {\n-        Assert.assertEquals((byte) (i + 1), vector.getAccessor().get(i));\n+        Assert.assertEquals((byte) (i + 1), vector.get(i));\n       } else {\n-        Assert.assertTrue(vector.getAccessor().isNull(i));\n+        Assert.assertTrue(vector.isNull(i));\n       }\n     }\n   }\n@@ -397,7 +397,7 @@ public void testWriteReadMetadata() throws IOException {\n     try (BufferAllocator originalVectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n          NullableMapVector vector = (NullableMapVector) field.createVector(originalVectorAllocator)) {\n       vector.allocateNewSafe();\n-      vector.getMutator().setValueCount(0);\n+      vector.setValueCount(0);\n \n       List<FieldVector> vectors = ImmutableList.<FieldVector>of(vector);\n       VectorSchemaRoot root = new VectorSchemaRoot(originalSchema, vectors, 0);\n@@ -578,13 +578,13 @@ public void testWriteReadFixedSizeList() throws IOException {\n       parent.allocateNew();\n \n       for (int i = 0; i < 10; i++) {\n-        tuples.getMutator().setNotNull(i);\n-        floats.getMutator().set(i * 2, i + 0.1f);\n-        floats.getMutator().set(i * 2 + 1, i + 10.1f);\n-        ints.getMutator().set(i, i);\n+        tuples.setNotNull(i);\n+        floats.set(i * 2, i + 0.1f);\n+        floats.set(i * 2 + 1, i + 10.1f);\n+        ints.set(i, i);\n       }\n \n-      parent.getMutator().setValueCount(10);\n+      parent.setValueCount(10);\n       write(parent, file, stream);\n     }\n \n@@ -600,8 +600,8 @@ public void testWriteReadFixedSizeList() throws IOException {\n         arrowReader.loadRecordBatch(rbBlock);\n         Assert.assertEquals(count, root.getRowCount());\n         for (int i = 0; i < 10; i++) {\n-          Assert.assertEquals(Lists.newArrayList(i + 0.1f, i + 10.1f), root.getVector(\"float-pairs\").getAccessor().getObject(i));\n-          Assert.assertEquals(i, root.getVector(\"ints\").getAccessor().getObject(i));\n+          Assert.assertEquals(Lists.newArrayList(i + 0.1f, i + 10.1f), root.getVector(\"float-pairs\").getObject(i));\n+          Assert.assertEquals(i, root.getVector(\"ints\").getObject(i));\n         }\n       }\n     }\n@@ -616,8 +616,8 @@ public void testWriteReadFixedSizeList() throws IOException {\n       arrowReader.loadNextBatch();\n       Assert.assertEquals(count, root.getRowCount());\n       for (int i = 0; i < 10; i++) {\n-        Assert.assertEquals(Lists.newArrayList(i + 0.1f, i + 10.1f), root.getVector(\"float-pairs\").getAccessor().getObject(i));\n-        Assert.assertEquals(i, root.getVector(\"ints\").getAccessor().getObject(i));\n+        Assert.assertEquals(Lists.newArrayList(i + 0.1f, i + 10.1f), root.getVector(\"float-pairs\").getObject(i));\n+        Assert.assertEquals(i, root.getVector(\"ints\").getObject(i));\n       }\n     }\n   }\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowStream.java b/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowStream.java\nindex e2efabef0..c7e34191a 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowStream.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowStream.java\n@@ -70,11 +70,11 @@ public void testReadWrite() throws IOException {\n       int numBatches = 1;\n \n       root.getFieldVectors().get(0).allocateNew();\n-      NullableTinyIntVector.Mutator mutator = (NullableTinyIntVector.Mutator) root.getFieldVectors().get(0).getMutator();\n+      NullableTinyIntVector vector = (NullableTinyIntVector)root.getFieldVectors().get(0);\n       for (int i = 0; i < 16; i++) {\n-        mutator.set(i, i < 8 ? 1 : 0, (byte) (i + 1));\n+        vector.set(i, i < 8 ? 1 : 0, (byte) (i + 1));\n       }\n-      mutator.setValueCount(16);\n+      vector.setValueCount(16);\n       root.setRowCount(16);\n \n       ByteArrayOutputStream out = new ByteArrayOutputStream();\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowStreamPipe.java b/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowStreamPipe.java\nindex 40716942f..f393733cc 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowStreamPipe.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowStreamPipe.java\n@@ -62,13 +62,13 @@ public void run() {\n         writer.start();\n         for (int j = 0; j < numBatches; j++) {\n           root.getFieldVectors().get(0).allocateNew();\n-          NullableTinyIntVector.Mutator mutator = (NullableTinyIntVector.Mutator) root.getFieldVectors().get(0).getMutator();\n+          NullableTinyIntVector vector = (NullableTinyIntVector) root.getFieldVectors().get(0);\n           // Send a changing batch id first\n-          mutator.set(0, j);\n+          vector.set(0, j);\n           for (int i = 1; i < 16; i++) {\n-            mutator.set(i, i < 8 ? 1 : 0, (byte) (i + 1));\n+            vector.set(i, i < 8 ? 1 : 0, (byte) (i + 1));\n           }\n-          mutator.setValueCount(16);\n+          vector.setValueCount(16);\n           root.setRowCount(16);\n \n           writer.writeBatch();\n@@ -117,12 +117,12 @@ public boolean loadNextBatch() throws IOException {\n             VectorSchemaRoot root = getVectorSchemaRoot();\n             Assert.assertEquals(16, root.getRowCount());\n             NullableTinyIntVector vector = (NullableTinyIntVector) root.getFieldVectors().get(0);\n-            Assert.assertEquals((byte) (batchesRead - 1), vector.getAccessor().get(0));\n+            Assert.assertEquals((byte) (batchesRead - 1), vector.get(0));\n             for (int i = 1; i < 16; i++) {\n               if (i < 8) {\n-                Assert.assertEquals((byte) (i + 1), vector.getAccessor().get(i));\n+                Assert.assertEquals((byte) (i + 1), vector.get(i));\n               } else {\n-                Assert.assertTrue(vector.getAccessor().isNull(i));\n+                Assert.assertTrue(vector.isNull(i));\n               }\n             }\n           }\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/file/json/TestJSONFile.java b/java/vector/src/test/java/org/apache/arrow/vector/file/json/TestJSONFile.java\nindex ee90d340d..5c4c48cd2 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/file/json/TestJSONFile.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/file/json/TestJSONFile.java\n@@ -280,7 +280,7 @@ public void testSetStructLength() throws IOException {\n       // initialize vectors\n       try (VectorSchemaRoot root = reader.read();) {\n         FieldVector vector = root.getVector(\"struct_nullable\");\n-        Assert.assertEquals(7, vector.getAccessor().getValueCount());\n+        Assert.assertEquals(7, vector.getValueCount());\n       }\n     }\n   }\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T21:44:08.555+0000",
                    "updated": "2017-11-15T21:44:08.555+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189/comment/16254477",
                    "id": "16254477",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=siddteotia",
                        "name": "siddteotia",
                        "key": "siddteotia",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=siddteotia&avatarId=32343",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=siddteotia&avatarId=32343",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=siddteotia&avatarId=32343",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=siddteotia&avatarId=32343"
                        },
                        "displayName": "Siddharth Teotia",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Resolved by https://github.com/apache/arrow/pull/1316",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=siddteotia",
                        "name": "siddteotia",
                        "key": "siddteotia",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=siddteotia&avatarId=32343",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=siddteotia&avatarId=32343",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=siddteotia&avatarId=32343",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=siddteotia&avatarId=32343"
                        },
                        "displayName": "Siddharth Teotia",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-15T23:53:44.603+0000",
                    "updated": "2017-11-15T23:53:44.603+0000"
                }
            ],
            "maxResults": 139,
            "total": 139,
            "startAt": 0
        },
        "customfield_12311820": "0|i3jpsv:",
        "customfield_12314139": null
    }
}