{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13377672",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377672",
    "key": "ARROW-12725",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12350323",
                "id": "12350323",
                "description": "",
                "name": "6.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-10-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349493",
                "id": "12349493",
                "description": "",
                "name": "4.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-04-26"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12615331",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12615331",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "inwardIssue": {
                    "id": "13376404",
                    "key": "ARROW-12633",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376404",
                    "fields": {
                        "summary": "[C++] Query engine umbrella issue",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=michalno",
            "name": "michalno",
            "key": "michalno",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Michal Nowakiewicz",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=michalno",
            "name": "michalno",
            "key": "michalno",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Michal Nowakiewicz",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=michalno",
            "name": "michalno",
            "key": "michalno",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Michal Nowakiewicz",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 7200,
            "total": 7200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 7200,
            "total": 7200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12725/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 12,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377672/worklog/595104",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10290:\nURL: https://github.com/apache/arrow/pull/10290#issuecomment-839537488\n\n\n   https://issues.apache.org/jira/browse/ARROW-12725\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-12T07:34:48.269+0000",
                    "updated": "2021-05-12T07:34:48.269+0000",
                    "started": "2021-05-12T07:34:48.269+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "595104",
                    "issueId": "13377672"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377672/worklog/637527",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10290:\nURL: https://github.com/apache/arrow/pull/10290#discussion_r688021792\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/key_compare.cc\n##########\n@@ -17,250 +17,398 @@\n \n #include \"arrow/compute/exec/key_compare.h\"\n \n+#include <immintrin.h>\n+#include <memory.h>\n+\n #include <algorithm>\n #include <cstdint>\n \n #include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bit_util.h\"\n #include \"arrow/util/ubsan.h\"\n \n namespace arrow {\n namespace compute {\n \n-void KeyCompare::CompareRows(uint32_t num_rows_to_compare,\n-                             const uint16_t* sel_left_maybe_null,\n-                             const uint32_t* left_to_right_map,\n-                             KeyEncoder::KeyEncoderContext* ctx, uint32_t* out_num_rows,\n-                             uint16_t* out_sel_left_maybe_same,\n-                             const KeyEncoder::KeyRowArray& rows_left,\n-                             const KeyEncoder::KeyRowArray& rows_right) {\n-  ARROW_DCHECK(rows_left.metadata().is_compatible(rows_right.metadata()));\n-\n-  if (num_rows_to_compare == 0) {\n-    *out_num_rows = 0;\n+template <bool use_selection>\n+void KeyCompare::NullUpdateColumnToRow(uint32_t id_col, uint32_t num_rows_to_compare,\n+                                       const uint16_t* sel_left_maybe_null,\n+                                       const uint32_t* left_to_right_map,\n+                                       KeyEncoder::KeyEncoderContext* ctx,\n+                                       const KeyEncoder::KeyColumnArray& col,\n+                                       const KeyEncoder::KeyRowArray& rows,\n+                                       uint8_t* match_bytevector) {\n+  if (!rows.has_any_nulls(ctx) && !col.data(0)) {\n     return;\n   }\n-\n-  // Allocate temporary byte and bit vectors\n-  auto bytevector_holder =\n-      util::TempVectorHolder<uint8_t>(ctx->stack, num_rows_to_compare);\n-  auto bitvector_holder =\n-      util::TempVectorHolder<uint8_t>(ctx->stack, num_rows_to_compare);\n-\n-  uint8_t* match_bytevector = bytevector_holder.mutable_data();\n-  uint8_t* match_bitvector = bitvector_holder.mutable_data();\n-\n-  // All comparison functions called here will update match byte vector\n-  // (AND it with comparison result) instead of overwriting it.\n-  memset(match_bytevector, 0xff, num_rows_to_compare);\n-\n-  if (rows_left.metadata().is_fixed_length) {\n-    CompareFixedLength(num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n-                       match_bytevector, ctx, rows_left.metadata().fixed_length,\n-                       rows_left.data(1), rows_right.data(1));\n-  } else {\n-    CompareVaryingLength(num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n-                         match_bytevector, ctx, rows_left.data(2), rows_right.data(2),\n-                         rows_left.offsets(), rows_right.offsets());\n+  uint32_t num_processed = 0;\n+#if defined(ARROW_HAVE_AVX2)\n+  if (ctx->has_avx2()) {\n+    num_processed = NullUpdateColumnToRow_avx2(use_selection, id_col, num_rows_to_compare,\n+                                               sel_left_maybe_null, left_to_right_map,\n+                                               ctx, col, rows, match_bytevector);\n   }\n+#endif\n \n-  // CompareFixedLength can be used to compare nulls as well\n-  bool nulls_present = rows_left.has_any_nulls(ctx) || rows_right.has_any_nulls(ctx);\n-  if (nulls_present) {\n-    CompareFixedLength(num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n-                       match_bytevector, ctx,\n-                       rows_left.metadata().null_masks_bytes_per_row,\n-                       rows_left.null_masks(), rows_right.null_masks());\n+  if (!col.data(0)) {\n+    // Remove rows from the result for which the column value is a null\n+    const uint8_t* null_masks = rows.null_masks();\n+    uint32_t null_mask_num_bytes = rows.metadata().null_masks_bytes_per_row;\n+    for (uint32_t i = num_processed; i < num_rows_to_compare; ++i) {\n+      uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n+      uint32_t irow_right = left_to_right_map[irow_left];\n+      int64_t bitid = irow_right * null_mask_num_bytes * 8 + id_col;\n+      match_bytevector[i] &= (BitUtil::GetBit(null_masks, bitid) ? 0 : 0xff);\n+    }\n+  } else if (!rows.has_any_nulls(ctx)) {\n+    // Remove rows from the result for which the column value on left side is null\n+    const uint8_t* non_nulls = col.data(0);\n+    ARROW_DCHECK(non_nulls);\n+    for (uint32_t i = num_processed; i < num_rows_to_compare; ++i) {\n+      uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n+      match_bytevector[i] &=\n+          BitUtil::GetBit(non_nulls, irow_left + col.bit_offset(0)) ? 0xff : 0;\n+    }\n+  } else {\n+    const uint8_t* null_masks = rows.null_masks();\n+    uint32_t null_mask_num_bytes = rows.metadata().null_masks_bytes_per_row;\n+    const uint8_t* non_nulls = col.data(0);\n+    ARROW_DCHECK(non_nulls);\n+    for (uint32_t i = num_processed; i < num_rows_to_compare; ++i) {\n+      uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n+      uint32_t irow_right = left_to_right_map[irow_left];\n+      int64_t bitid_right = irow_right * null_mask_num_bytes * 8 + id_col;\n+      int right_null = BitUtil::GetBit(null_masks, bitid_right) ? 0xff : 0;\n+      int left_null =\n+          BitUtil::GetBit(non_nulls, irow_left + col.bit_offset(0)) ? 0 : 0xff;\n+      match_bytevector[i] |= left_null & right_null;\n+      match_bytevector[i] &= ~(left_null ^ right_null);\n+    }\n   }\n+}\n \n-  util::BitUtil::bytes_to_bits(ctx->hardware_flags, num_rows_to_compare, match_bytevector,\n-                               match_bitvector);\n-  if (sel_left_maybe_null) {\n-    int out_num_rows_int;\n-    util::BitUtil::bits_filter_indexes(0, ctx->hardware_flags, num_rows_to_compare,\n-                                       match_bitvector, sel_left_maybe_null,\n-                                       &out_num_rows_int, out_sel_left_maybe_same);\n-    *out_num_rows = out_num_rows_int;\n+template <bool use_selection, class COMPARE_FN>\n+void KeyCompare::CompareBinaryColumnToRowHelper(\n+    uint32_t offset_within_row, uint32_t first_row_to_compare,\n+    uint32_t num_rows_to_compare, const uint16_t* sel_left_maybe_null,\n+    const uint32_t* left_to_right_map, KeyEncoder::KeyEncoderContext* ctx,\n+    const KeyEncoder::KeyColumnArray& col, const KeyEncoder::KeyRowArray& rows,\n+    uint8_t* match_bytevector, COMPARE_FN compare_fn) {\n+  bool is_fixed_length = rows.metadata().is_fixed_length;\n+  if (is_fixed_length) {\n+    uint32_t fixed_length = rows.metadata().fixed_length;\n+    const uint8_t* rows_left = col.data(1);\n+    const uint8_t* rows_right = rows.data(1);\n+    for (uint32_t i = first_row_to_compare; i < num_rows_to_compare; ++i) {\n+      uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n+      uint32_t irow_right = left_to_right_map[irow_left];\n+      uint32_t offset_right = irow_right * fixed_length + offset_within_row;\n+      match_bytevector[i] = compare_fn(rows_left, rows_right, irow_left, offset_right);\n+    }\n   } else {\n-    int out_num_rows_int;\n-    util::BitUtil::bits_to_indexes(0, ctx->hardware_flags, num_rows_to_compare,\n-                                   match_bitvector, &out_num_rows_int,\n-                                   out_sel_left_maybe_same);\n-    *out_num_rows = out_num_rows_int;\n+    const uint8_t* rows_left = col.data(1);\n+    const uint32_t* offsets_right = rows.offsets();\n+    const uint8_t* rows_right = rows.data(2);\n+    for (uint32_t i = first_row_to_compare; i < num_rows_to_compare; ++i) {\n+      uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n+      uint32_t irow_right = left_to_right_map[irow_left];\n+      uint32_t offset_right = offsets_right[irow_right] + offset_within_row;\n+      match_bytevector[i] = compare_fn(rows_left, rows_right, irow_left, offset_right);\n+    }\n   }\n }\n \n-void KeyCompare::CompareFixedLength(uint32_t num_rows_to_compare,\n-                                    const uint16_t* sel_left_maybe_null,\n-                                    const uint32_t* left_to_right_map,\n-                                    uint8_t* match_bytevector,\n-                                    KeyEncoder::KeyEncoderContext* ctx,\n-                                    uint32_t fixed_length, const uint8_t* rows_left,\n-                                    const uint8_t* rows_right) {\n-  bool use_selection = (sel_left_maybe_null != nullptr);\n-\n-  uint32_t num_rows_already_processed = 0;\n-\n+template <bool use_selection>\n+void KeyCompare::CompareBinaryColumnToRow(\n+    uint32_t offset_within_row, uint32_t num_rows_to_compare,\n+    const uint16_t* sel_left_maybe_null, const uint32_t* left_to_right_map,\n+    KeyEncoder::KeyEncoderContext* ctx, const KeyEncoder::KeyColumnArray& col,\n+    const KeyEncoder::KeyRowArray& rows, uint8_t* match_bytevector) {\n+  uint32_t num_processed = 0;\n #if defined(ARROW_HAVE_AVX2)\n-  if (ctx->has_avx2() && !use_selection) {\n-    // Choose between up-to-8B length, up-to-16B length and any size versions\n-    if (fixed_length <= 8) {\n-      num_rows_already_processed = CompareFixedLength_UpTo8B_avx2(\n-          num_rows_to_compare, left_to_right_map, match_bytevector, fixed_length,\n-          rows_left, rows_right);\n-    } else if (fixed_length <= 16) {\n-      num_rows_already_processed = CompareFixedLength_UpTo16B_avx2(\n-          num_rows_to_compare, left_to_right_map, match_bytevector, fixed_length,\n-          rows_left, rows_right);\n-    } else {\n-      num_rows_already_processed =\n-          CompareFixedLength_avx2(num_rows_to_compare, left_to_right_map,\n-                                  match_bytevector, fixed_length, rows_left, rows_right);\n-    }\n+  if (ctx->has_avx2()) {\n+    num_processed = CompareBinaryColumnToRow_avx2(\n+        use_selection, offset_within_row, num_rows_to_compare, sel_left_maybe_null,\n+        left_to_right_map, ctx, col, rows, match_bytevector);\n   }\n #endif\n \n-  typedef void (*CompareFixedLengthImp_t)(uint32_t, uint32_t, const uint16_t*,\n-                                          const uint32_t*, uint8_t*, uint32_t,\n-                                          const uint8_t*, const uint8_t*);\n-  static const CompareFixedLengthImp_t CompareFixedLengthImp_fn[] = {\n-      CompareFixedLengthImp<false, 1>, CompareFixedLengthImp<false, 2>,\n-      CompareFixedLengthImp<false, 0>, CompareFixedLengthImp<true, 1>,\n-      CompareFixedLengthImp<true, 2>,  CompareFixedLengthImp<true, 0>};\n-  int dispatch_const = (use_selection ? 3 : 0) +\n-                       ((fixed_length <= 8) ? 0 : ((fixed_length <= 16) ? 1 : 2));\n-  CompareFixedLengthImp_fn[dispatch_const](\n-      num_rows_already_processed, num_rows_to_compare, sel_left_maybe_null,\n-      left_to_right_map, match_bytevector, fixed_length, rows_left, rows_right);\n-}\n+  uint32_t col_width = col.metadata().fixed_length;\n+  if (col_width == 0) {\n+    int bit_offset = col.bit_offset(1);\n+    CompareBinaryColumnToRowHelper<use_selection>(\n+        offset_within_row, num_processed, num_rows_to_compare, sel_left_maybe_null,\n+        left_to_right_map, ctx, col, rows, match_bytevector,\n+        [bit_offset](const uint8_t* left_base, const uint8_t* right_base,\n+                     uint32_t irow_left, uint32_t offset_right) {\n+          uint8_t left = BitUtil::GetBit(left_base, irow_left + bit_offset) ? 0xff : 0x00;\n+          uint8_t right = right_base[offset_right];\n+          return left == right ? 0xff : 0;\n+        });\n+  } else if (col_width == 1) {\n+    CompareBinaryColumnToRowHelper<use_selection>(\n+        offset_within_row, num_processed, num_rows_to_compare, sel_left_maybe_null,\n+        left_to_right_map, ctx, col, rows, match_bytevector,\n+        [](const uint8_t* left_base, const uint8_t* right_base, uint32_t irow_left,\n+           uint32_t offset_right) {\n+          uint8_t left = left_base[irow_left];\n+          uint8_t right = right_base[offset_right];\n+          return left == right ? 0xff : 0;\n+        });\n+  } else if (col_width == 2) {\n+    CompareBinaryColumnToRowHelper<use_selection>(\n+        offset_within_row, num_processed, num_rows_to_compare, sel_left_maybe_null,\n+        left_to_right_map, ctx, col, rows, match_bytevector,\n+        [](const uint8_t* left_base, const uint8_t* right_base, uint32_t irow_left,\n+           uint32_t offset_right) {\n+          uint16_t left = reinterpret_cast<const uint16_t*>(left_base)[irow_left];\n\nReview comment:\n       Are these guaranteed to be aligned? If so, please add an assertion and a comment.\n\n##########\nFile path: cpp/src/arrow/compute/exec/key_compare.cc\n##########\n@@ -17,250 +17,398 @@\n \n #include \"arrow/compute/exec/key_compare.h\"\n \n+#include <immintrin.h>\n\nReview comment:\n       This include needs to be guarded by an `#ifdef`. This is causing the non-Intel CI jobs to fail\r\n   \r\n   https://app.travis-ci.com/github/apache/arrow/jobs/530849513#L1115\r\n   \r\n   https://app.travis-ci.com/github/apache/arrow/jobs/530849512#L1023\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate_test.cc\n##########\n@@ -991,6 +991,9 @@ TEST(GroupBy, SumOnlyStringAndDictKeys) {\n                                            {\n                                                {\"hash_sum\", nullptr},\n                                            }));\n+    if (key_type->Equals(utf8())) {\n\nReview comment:\n       Why does it only require sorting for string keys?\n\n##########\nFile path: cpp/src/arrow/compute/exec/key_compare.cc\n##########\n@@ -17,250 +17,398 @@\n \n #include \"arrow/compute/exec/key_compare.h\"\n \n+#include <immintrin.h>\n+#include <memory.h>\n+\n #include <algorithm>\n #include <cstdint>\n \n #include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bit_util.h\"\n #include \"arrow/util/ubsan.h\"\n \n namespace arrow {\n namespace compute {\n \n-void KeyCompare::CompareRows(uint32_t num_rows_to_compare,\n-                             const uint16_t* sel_left_maybe_null,\n-                             const uint32_t* left_to_right_map,\n-                             KeyEncoder::KeyEncoderContext* ctx, uint32_t* out_num_rows,\n-                             uint16_t* out_sel_left_maybe_same,\n-                             const KeyEncoder::KeyRowArray& rows_left,\n-                             const KeyEncoder::KeyRowArray& rows_right) {\n-  ARROW_DCHECK(rows_left.metadata().is_compatible(rows_right.metadata()));\n-\n-  if (num_rows_to_compare == 0) {\n-    *out_num_rows = 0;\n+template <bool use_selection>\n+void KeyCompare::NullUpdateColumnToRow(uint32_t id_col, uint32_t num_rows_to_compare,\n+                                       const uint16_t* sel_left_maybe_null,\n+                                       const uint32_t* left_to_right_map,\n+                                       KeyEncoder::KeyEncoderContext* ctx,\n+                                       const KeyEncoder::KeyColumnArray& col,\n+                                       const KeyEncoder::KeyRowArray& rows,\n+                                       uint8_t* match_bytevector) {\n+  if (!rows.has_any_nulls(ctx) && !col.data(0)) {\n     return;\n   }\n-\n-  // Allocate temporary byte and bit vectors\n-  auto bytevector_holder =\n-      util::TempVectorHolder<uint8_t>(ctx->stack, num_rows_to_compare);\n-  auto bitvector_holder =\n-      util::TempVectorHolder<uint8_t>(ctx->stack, num_rows_to_compare);\n-\n-  uint8_t* match_bytevector = bytevector_holder.mutable_data();\n-  uint8_t* match_bitvector = bitvector_holder.mutable_data();\n-\n-  // All comparison functions called here will update match byte vector\n-  // (AND it with comparison result) instead of overwriting it.\n-  memset(match_bytevector, 0xff, num_rows_to_compare);\n-\n-  if (rows_left.metadata().is_fixed_length) {\n-    CompareFixedLength(num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n-                       match_bytevector, ctx, rows_left.metadata().fixed_length,\n-                       rows_left.data(1), rows_right.data(1));\n-  } else {\n-    CompareVaryingLength(num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n-                         match_bytevector, ctx, rows_left.data(2), rows_right.data(2),\n-                         rows_left.offsets(), rows_right.offsets());\n+  uint32_t num_processed = 0;\n+#if defined(ARROW_HAVE_AVX2)\n+  if (ctx->has_avx2()) {\n+    num_processed = NullUpdateColumnToRow_avx2(use_selection, id_col, num_rows_to_compare,\n+                                               sel_left_maybe_null, left_to_right_map,\n+                                               ctx, col, rows, match_bytevector);\n   }\n+#endif\n \n-  // CompareFixedLength can be used to compare nulls as well\n-  bool nulls_present = rows_left.has_any_nulls(ctx) || rows_right.has_any_nulls(ctx);\n-  if (nulls_present) {\n-    CompareFixedLength(num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n-                       match_bytevector, ctx,\n-                       rows_left.metadata().null_masks_bytes_per_row,\n-                       rows_left.null_masks(), rows_right.null_masks());\n+  if (!col.data(0)) {\n+    // Remove rows from the result for which the column value is a null\n+    const uint8_t* null_masks = rows.null_masks();\n+    uint32_t null_mask_num_bytes = rows.metadata().null_masks_bytes_per_row;\n+    for (uint32_t i = num_processed; i < num_rows_to_compare; ++i) {\n+      uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n+      uint32_t irow_right = left_to_right_map[irow_left];\n+      int64_t bitid = irow_right * null_mask_num_bytes * 8 + id_col;\n+      match_bytevector[i] &= (BitUtil::GetBit(null_masks, bitid) ? 0 : 0xff);\n+    }\n+  } else if (!rows.has_any_nulls(ctx)) {\n+    // Remove rows from the result for which the column value on left side is null\n+    const uint8_t* non_nulls = col.data(0);\n+    ARROW_DCHECK(non_nulls);\n+    for (uint32_t i = num_processed; i < num_rows_to_compare; ++i) {\n+      uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n+      match_bytevector[i] &=\n+          BitUtil::GetBit(non_nulls, irow_left + col.bit_offset(0)) ? 0xff : 0;\n+    }\n+  } else {\n+    const uint8_t* null_masks = rows.null_masks();\n+    uint32_t null_mask_num_bytes = rows.metadata().null_masks_bytes_per_row;\n+    const uint8_t* non_nulls = col.data(0);\n+    ARROW_DCHECK(non_nulls);\n+    for (uint32_t i = num_processed; i < num_rows_to_compare; ++i) {\n+      uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n+      uint32_t irow_right = left_to_right_map[irow_left];\n+      int64_t bitid_right = irow_right * null_mask_num_bytes * 8 + id_col;\n+      int right_null = BitUtil::GetBit(null_masks, bitid_right) ? 0xff : 0;\n+      int left_null =\n+          BitUtil::GetBit(non_nulls, irow_left + col.bit_offset(0)) ? 0 : 0xff;\n+      match_bytevector[i] |= left_null & right_null;\n+      match_bytevector[i] &= ~(left_null ^ right_null);\n+    }\n   }\n+}\n \n-  util::BitUtil::bytes_to_bits(ctx->hardware_flags, num_rows_to_compare, match_bytevector,\n-                               match_bitvector);\n-  if (sel_left_maybe_null) {\n-    int out_num_rows_int;\n-    util::BitUtil::bits_filter_indexes(0, ctx->hardware_flags, num_rows_to_compare,\n-                                       match_bitvector, sel_left_maybe_null,\n-                                       &out_num_rows_int, out_sel_left_maybe_same);\n-    *out_num_rows = out_num_rows_int;\n+template <bool use_selection, class COMPARE_FN>\n+void KeyCompare::CompareBinaryColumnToRowHelper(\n+    uint32_t offset_within_row, uint32_t first_row_to_compare,\n+    uint32_t num_rows_to_compare, const uint16_t* sel_left_maybe_null,\n+    const uint32_t* left_to_right_map, KeyEncoder::KeyEncoderContext* ctx,\n+    const KeyEncoder::KeyColumnArray& col, const KeyEncoder::KeyRowArray& rows,\n+    uint8_t* match_bytevector, COMPARE_FN compare_fn) {\n+  bool is_fixed_length = rows.metadata().is_fixed_length;\n+  if (is_fixed_length) {\n+    uint32_t fixed_length = rows.metadata().fixed_length;\n+    const uint8_t* rows_left = col.data(1);\n+    const uint8_t* rows_right = rows.data(1);\n+    for (uint32_t i = first_row_to_compare; i < num_rows_to_compare; ++i) {\n+      uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n+      uint32_t irow_right = left_to_right_map[irow_left];\n+      uint32_t offset_right = irow_right * fixed_length + offset_within_row;\n+      match_bytevector[i] = compare_fn(rows_left, rows_right, irow_left, offset_right);\n+    }\n   } else {\n-    int out_num_rows_int;\n-    util::BitUtil::bits_to_indexes(0, ctx->hardware_flags, num_rows_to_compare,\n-                                   match_bitvector, &out_num_rows_int,\n-                                   out_sel_left_maybe_same);\n-    *out_num_rows = out_num_rows_int;\n+    const uint8_t* rows_left = col.data(1);\n+    const uint32_t* offsets_right = rows.offsets();\n+    const uint8_t* rows_right = rows.data(2);\n+    for (uint32_t i = first_row_to_compare; i < num_rows_to_compare; ++i) {\n+      uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n+      uint32_t irow_right = left_to_right_map[irow_left];\n+      uint32_t offset_right = offsets_right[irow_right] + offset_within_row;\n+      match_bytevector[i] = compare_fn(rows_left, rows_right, irow_left, offset_right);\n+    }\n   }\n }\n \n-void KeyCompare::CompareFixedLength(uint32_t num_rows_to_compare,\n-                                    const uint16_t* sel_left_maybe_null,\n-                                    const uint32_t* left_to_right_map,\n-                                    uint8_t* match_bytevector,\n-                                    KeyEncoder::KeyEncoderContext* ctx,\n-                                    uint32_t fixed_length, const uint8_t* rows_left,\n-                                    const uint8_t* rows_right) {\n-  bool use_selection = (sel_left_maybe_null != nullptr);\n-\n-  uint32_t num_rows_already_processed = 0;\n-\n+template <bool use_selection>\n+void KeyCompare::CompareBinaryColumnToRow(\n+    uint32_t offset_within_row, uint32_t num_rows_to_compare,\n+    const uint16_t* sel_left_maybe_null, const uint32_t* left_to_right_map,\n+    KeyEncoder::KeyEncoderContext* ctx, const KeyEncoder::KeyColumnArray& col,\n+    const KeyEncoder::KeyRowArray& rows, uint8_t* match_bytevector) {\n+  uint32_t num_processed = 0;\n #if defined(ARROW_HAVE_AVX2)\n-  if (ctx->has_avx2() && !use_selection) {\n-    // Choose between up-to-8B length, up-to-16B length and any size versions\n-    if (fixed_length <= 8) {\n-      num_rows_already_processed = CompareFixedLength_UpTo8B_avx2(\n-          num_rows_to_compare, left_to_right_map, match_bytevector, fixed_length,\n-          rows_left, rows_right);\n-    } else if (fixed_length <= 16) {\n-      num_rows_already_processed = CompareFixedLength_UpTo16B_avx2(\n-          num_rows_to_compare, left_to_right_map, match_bytevector, fixed_length,\n-          rows_left, rows_right);\n-    } else {\n-      num_rows_already_processed =\n-          CompareFixedLength_avx2(num_rows_to_compare, left_to_right_map,\n-                                  match_bytevector, fixed_length, rows_left, rows_right);\n-    }\n+  if (ctx->has_avx2()) {\n+    num_processed = CompareBinaryColumnToRow_avx2(\n+        use_selection, offset_within_row, num_rows_to_compare, sel_left_maybe_null,\n+        left_to_right_map, ctx, col, rows, match_bytevector);\n   }\n #endif\n \n-  typedef void (*CompareFixedLengthImp_t)(uint32_t, uint32_t, const uint16_t*,\n-                                          const uint32_t*, uint8_t*, uint32_t,\n-                                          const uint8_t*, const uint8_t*);\n-  static const CompareFixedLengthImp_t CompareFixedLengthImp_fn[] = {\n-      CompareFixedLengthImp<false, 1>, CompareFixedLengthImp<false, 2>,\n-      CompareFixedLengthImp<false, 0>, CompareFixedLengthImp<true, 1>,\n-      CompareFixedLengthImp<true, 2>,  CompareFixedLengthImp<true, 0>};\n-  int dispatch_const = (use_selection ? 3 : 0) +\n-                       ((fixed_length <= 8) ? 0 : ((fixed_length <= 16) ? 1 : 2));\n-  CompareFixedLengthImp_fn[dispatch_const](\n-      num_rows_already_processed, num_rows_to_compare, sel_left_maybe_null,\n-      left_to_right_map, match_bytevector, fixed_length, rows_left, rows_right);\n-}\n+  uint32_t col_width = col.metadata().fixed_length;\n+  if (col_width == 0) {\n+    int bit_offset = col.bit_offset(1);\n+    CompareBinaryColumnToRowHelper<use_selection>(\n+        offset_within_row, num_processed, num_rows_to_compare, sel_left_maybe_null,\n+        left_to_right_map, ctx, col, rows, match_bytevector,\n+        [bit_offset](const uint8_t* left_base, const uint8_t* right_base,\n+                     uint32_t irow_left, uint32_t offset_right) {\n+          uint8_t left = BitUtil::GetBit(left_base, irow_left + bit_offset) ? 0xff : 0x00;\n+          uint8_t right = right_base[offset_right];\n+          return left == right ? 0xff : 0;\n+        });\n+  } else if (col_width == 1) {\n+    CompareBinaryColumnToRowHelper<use_selection>(\n+        offset_within_row, num_processed, num_rows_to_compare, sel_left_maybe_null,\n+        left_to_right_map, ctx, col, rows, match_bytevector,\n+        [](const uint8_t* left_base, const uint8_t* right_base, uint32_t irow_left,\n+           uint32_t offset_right) {\n+          uint8_t left = left_base[irow_left];\n+          uint8_t right = right_base[offset_right];\n+          return left == right ? 0xff : 0;\n+        });\n+  } else if (col_width == 2) {\n+    CompareBinaryColumnToRowHelper<use_selection>(\n+        offset_within_row, num_processed, num_rows_to_compare, sel_left_maybe_null,\n+        left_to_right_map, ctx, col, rows, match_bytevector,\n+        [](const uint8_t* left_base, const uint8_t* right_base, uint32_t irow_left,\n+           uint32_t offset_right) {\n+          uint16_t left = reinterpret_cast<const uint16_t*>(left_base)[irow_left];\n+          uint16_t right = *reinterpret_cast<const uint16_t*>(right_base + offset_right);\n+          return left == right ? 0xff : 0;\n+        });\n+  } else if (col_width == 4) {\n+    CompareBinaryColumnToRowHelper<use_selection>(\n+        offset_within_row, num_processed, num_rows_to_compare, sel_left_maybe_null,\n+        left_to_right_map, ctx, col, rows, match_bytevector,\n+        [](const uint8_t* left_base, const uint8_t* right_base, uint32_t irow_left,\n+           uint32_t offset_right) {\n+          uint32_t left = reinterpret_cast<const uint32_t*>(left_base)[irow_left];\n+          uint32_t right = *reinterpret_cast<const uint32_t*>(right_base + offset_right);\n+          return left == right ? 0xff : 0;\n+        });\n+  } else if (col_width == 8) {\n+    CompareBinaryColumnToRowHelper<use_selection>(\n+        offset_within_row, num_processed, num_rows_to_compare, sel_left_maybe_null,\n+        left_to_right_map, ctx, col, rows, match_bytevector,\n+        [](const uint8_t* left_base, const uint8_t* right_base, uint32_t irow_left,\n+           uint32_t offset_right) {\n+          uint64_t left = reinterpret_cast<const uint64_t*>(left_base)[irow_left];\n+          uint64_t right = *reinterpret_cast<const uint64_t*>(right_base + offset_right);\n+          return left == right ? 0xff : 0;\n+        });\n+  } else {\n+    CompareBinaryColumnToRowHelper<use_selection>(\n+        offset_within_row, num_processed, num_rows_to_compare, sel_left_maybe_null,\n+        left_to_right_map, ctx, col, rows, match_bytevector,\n+        [&col](const uint8_t* left_base, const uint8_t* right_base, uint32_t irow_left,\n+               uint32_t offset_right) {\n+          uint32_t length = col.metadata().fixed_length;\n \n-template <bool use_selection, int num_64bit_words>\n-void KeyCompare::CompareFixedLengthImp(uint32_t num_rows_already_processed,\n-                                       uint32_t num_rows,\n-                                       const uint16_t* sel_left_maybe_null,\n-                                       const uint32_t* left_to_right_map,\n-                                       uint8_t* match_bytevector, uint32_t length,\n-                                       const uint8_t* rows_left,\n-                                       const uint8_t* rows_right) {\n-  // Key length (for encoded key) has to be non-zero\n-  ARROW_DCHECK(length > 0);\n+          // Non-zero length guarantees no underflow\n+          int32_t num_loops_less_one = (static_cast<int32_t>(length) + 7) / 8 - 1;\n+\n+          uint64_t tail_mask = ~0ULL >> (64 - 8 * (length - num_loops_less_one * 8));\n \n-  // Non-zero length guarantees no underflow\n-  int32_t num_loops_less_one = (static_cast<int32_t>(length) + 7) / 8 - 1;\n+          const uint64_t* key_left_ptr =\n+              reinterpret_cast<const uint64_t*>(left_base + irow_left * length);\n+          const uint64_t* key_right_ptr =\n+              reinterpret_cast<const uint64_t*>(right_base + offset_right);\n+          uint64_t result_or = 0;\n+          int32_t i;\n+          // length cannot be zero\n+          for (i = 0; i < num_loops_less_one; ++i) {\n+            uint64_t key_left = key_left_ptr[i];\n+            uint64_t key_right = key_right_ptr[i];\n+            result_or |= key_left ^ key_right;\n+          }\n+          uint64_t key_left = key_left_ptr[i];\n+          uint64_t key_right = key_right_ptr[i];\n+          result_or |= tail_mask & (key_left ^ key_right);\n+          return result_or == 0 ? 0xff : 0;\n+        });\n+  }\n+}\n \n-  // Length remaining in last loop can only be zero for input length equal to zero\n-  uint32_t length_remaining_last_loop = length - num_loops_less_one * 8;\n-  uint64_t tail_mask = (~0ULL) >> (8 * (8 - length_remaining_last_loop));\n+// Overwrites the match_bytevector instead of updating it\n+template <bool use_selection, bool is_first_varbinary_col>\n+void KeyCompare::CompareVarBinaryColumnToRow(\n+    uint32_t id_varbinary_col, uint32_t num_rows_to_compare,\n+    const uint16_t* sel_left_maybe_null, const uint32_t* left_to_right_map,\n+    KeyEncoder::KeyEncoderContext* ctx, const KeyEncoder::KeyColumnArray& col,\n+    const KeyEncoder::KeyRowArray& rows, uint8_t* match_bytevector) {\n+#if defined(ARROW_HAVE_AVX2)\n+  if (ctx->has_avx2()) {\n+    CompareVarBinaryColumnToRow_avx2(\n+        use_selection, is_first_varbinary_col, id_varbinary_col, num_rows_to_compare,\n+        sel_left_maybe_null, left_to_right_map, ctx, col, rows, match_bytevector);\n+    return;\n+  }\n+#endif\n \n-  for (uint32_t id_input = num_rows_already_processed; id_input < num_rows; ++id_input) {\n-    uint32_t irow_left = use_selection ? sel_left_maybe_null[id_input] : id_input;\n+  const uint32_t* offsets_left = col.offsets();\n+  const uint32_t* offsets_right = rows.offsets();\n+  const uint8_t* rows_left = col.data(2);\n+  const uint8_t* rows_right = rows.data(2);\n+  for (uint32_t i = 0; i < num_rows_to_compare; ++i) {\n+    uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n     uint32_t irow_right = left_to_right_map[irow_left];\n-    uint32_t begin_left = length * irow_left;\n-    uint32_t begin_right = length * irow_right;\n+    uint32_t begin_left = offsets_left[irow_left];\n+    uint32_t length_left = offsets_left[irow_left + 1] - begin_left;\n+    uint32_t begin_right = offsets_right[irow_right];\n+    uint32_t length_right;\n+    uint32_t offset_within_row;\n+    if (!is_first_varbinary_col) {\n+      rows.metadata().nth_varbinary_offset_and_length(\n+          rows_right + begin_right, id_varbinary_col, &offset_within_row, &length_right);\n+    } else {\n+      rows.metadata().first_varbinary_offset_and_length(\n+          rows_right + begin_right, &offset_within_row, &length_right);\n+    }\n+    begin_right += offset_within_row;\n+    uint32_t length = std::min(length_left, length_right);\n     const uint64_t* key_left_ptr =\n         reinterpret_cast<const uint64_t*>(rows_left + begin_left);\n     const uint64_t* key_right_ptr =\n         reinterpret_cast<const uint64_t*>(rows_right + begin_right);\n-    uint64_t result_or = 0ULL;\n-    int32_t istripe = 0;\n-\n-    // Specializations for keys up to 8 bytes and between 9 and 16 bytes to\n-    // avoid internal loop over words in the value for short ones.\n-    //\n-    // Template argument 0 means arbitrarily many 64-bit words,\n-    // 1 means up to 1 and 2 means up to 2.\n-    //\n-    if (num_64bit_words == 0) {\n-      for (; istripe < num_loops_less_one; ++istripe) {\n-        uint64_t key_left = util::SafeLoad(&key_left_ptr[istripe]);\n-        uint64_t key_right = util::SafeLoad(&key_right_ptr[istripe]);\n-        result_or |= (key_left ^ key_right);\n+    uint64_t result_or = 0;\n+    if (length > 0) {\n+      int32_t j;\n+      // length can be zero\n+      for (j = 0; j < (static_cast<int32_t>(length) + 7) / 8 - 1; ++j) {\n\nReview comment:\n       Nit: please replace all of these with calls to descriptively named helpers, like:\r\n   ```suggestion\r\n         for (j = 0; j < BitUtil::CeilDiv(length, 8); ++j) {\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/key_compare_avx2.cc\n##########\n@@ -25,160 +25,545 @@ namespace compute {\n \n #if defined(ARROW_HAVE_AVX2)\n \n-uint32_t KeyCompare::CompareFixedLength_UpTo8B_avx2(\n-    uint32_t num_rows, const uint32_t* left_to_right_map, uint8_t* match_bytevector,\n-    uint32_t length, const uint8_t* rows_left, const uint8_t* rows_right) {\n-  ARROW_DCHECK(length <= 8);\n-  __m256i offset_left = _mm256_setr_epi64x(0, length, length * 2, length * 3);\n-  __m256i offset_left_incr = _mm256_set1_epi64x(length * 4);\n-  __m256i mask = _mm256_set1_epi64x(~0ULL >> (8 * (8 - length)));\n-\n-  constexpr uint32_t unroll = 4;\n-  for (uint32_t i = 0; i < num_rows / unroll; ++i) {\n-    auto key_left = _mm256_i64gather_epi64(\n-        reinterpret_cast<arrow::util::int64_for_gather_t*>(rows_left), offset_left, 1);\n-    offset_left = _mm256_add_epi64(offset_left, offset_left_incr);\n-    __m128i offset_right =\n-        _mm_loadu_si128(reinterpret_cast<const __m128i*>(left_to_right_map) + i);\n-    offset_right = _mm_mullo_epi32(offset_right, _mm_set1_epi32(length));\n-\n-    auto key_right = _mm256_i32gather_epi64(\n-        reinterpret_cast<arrow::util::int64_for_gather_t*>(rows_right), offset_right, 1);\n-    uint32_t cmp = _mm256_movemask_epi8(_mm256_cmpeq_epi64(\n-        _mm256_and_si256(key_left, mask), _mm256_and_si256(key_right, mask)));\n-    reinterpret_cast<uint32_t*>(match_bytevector)[i] &= cmp;\n+template <bool use_selection>\n+uint32_t KeyCompare::NullUpdateColumnToRowImp_avx2(\n+    uint32_t id_col, uint32_t num_rows_to_compare, const uint16_t* sel_left_maybe_null,\n+    const uint32_t* left_to_right_map, KeyEncoder::KeyEncoderContext* ctx,\n+    const KeyEncoder::KeyColumnArray& col, const KeyEncoder::KeyRowArray& rows,\n+    uint8_t* match_bytevector) {\n+  if (!rows.has_any_nulls(ctx) && !col.data(0)) {\n+    return num_rows_to_compare;\n   }\n+  if (!col.data(0)) {\n+    // Remove rows from the result for which the column value is a null\n+    const uint8_t* null_masks = rows.null_masks();\n+    uint32_t null_mask_num_bytes = rows.metadata().null_masks_bytes_per_row;\n \n-  uint32_t num_rows_processed = num_rows - (num_rows % unroll);\n-  return num_rows_processed;\n-}\n+    uint32_t num_processed = 0;\n+    constexpr uint32_t unroll = 8;\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      __m256i irow_right;\n+      if (use_selection) {\n+        __m256i irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+        irow_right = _mm256_i32gather_epi32((const int*)left_to_right_map, irow_left, 4);\n+      } else {\n+        irow_right =\n+            _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_to_right_map) + i);\n+      }\n+      __m256i bitid =\n+          _mm256_mullo_epi32(irow_right, _mm256_set1_epi32(null_mask_num_bytes * 8));\n+      bitid = _mm256_add_epi32(bitid, _mm256_set1_epi32(id_col));\n+      __m256i right =\n+          _mm256_i32gather_epi32((const int*)null_masks, _mm256_srli_epi32(bitid, 3), 1);\n+      right = _mm256_and_si256(\n+          _mm256_set1_epi32(1),\n+          _mm256_srlv_epi32(right, _mm256_and_si256(bitid, _mm256_set1_epi32(7))));\n+      __m256i cmp = _mm256_cmpeq_epi32(right, _mm256_setzero_si256());\n+      uint32_t result_lo =\n+          _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_castsi256_si128(cmp)));\n+      uint32_t result_hi =\n+          _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_extracti128_si256(cmp, 1)));\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] &=\n+          result_lo | (static_cast<uint64_t>(result_hi) << 32);\n+    }\n+    num_processed = num_rows_to_compare / unroll * unroll;\n+    return num_processed;\n+  } else if (!rows.has_any_nulls(ctx)) {\n+    // Remove rows from the result for which the column value on left side is null\n+    const uint8_t* non_nulls = col.data(0);\n+    ARROW_DCHECK(non_nulls);\n+    uint32_t num_processed = 0;\n+    constexpr uint32_t unroll = 8;\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      __m256i cmp;\n+      if (use_selection) {\n+        __m256i irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+        irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(col.bit_offset(0)));\n+        __m256i left = _mm256_i32gather_epi32((const int*)non_nulls,\n+                                              _mm256_srli_epi32(irow_left, 3), 1);\n+        left = _mm256_and_si256(\n+            _mm256_set1_epi32(1),\n+            _mm256_srlv_epi32(left, _mm256_and_si256(irow_left, _mm256_set1_epi32(7))));\n+        cmp = _mm256_cmpeq_epi32(left, _mm256_set1_epi32(1));\n+      } else {\n+        __m256i left = _mm256_cvtepu8_epi32(_mm_set1_epi8(static_cast<uint8_t>(\n+            reinterpret_cast<const uint16_t*>(non_nulls + i)[0] >> col.bit_offset(0))));\n+        __m256i bits = _mm256_setr_epi32(1, 2, 4, 8, 16, 32, 64, 128);\n+        cmp = _mm256_cmpeq_epi32(_mm256_and_si256(left, bits), bits);\n+      }\n+      uint32_t result_lo =\n+          _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_castsi256_si128(cmp)));\n+      uint32_t result_hi =\n+          _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_extracti128_si256(cmp, 1)));\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] &=\n+          result_lo | (static_cast<uint64_t>(result_hi) << 32);\n+      num_processed = num_rows_to_compare / unroll * unroll;\n+    }\n+    return num_processed;\n+  } else {\n+    const uint8_t* null_masks = rows.null_masks();\n+    uint32_t null_mask_num_bytes = rows.metadata().null_masks_bytes_per_row;\n+    const uint8_t* non_nulls = col.data(0);\n+    ARROW_DCHECK(non_nulls);\n \n-uint32_t KeyCompare::CompareFixedLength_UpTo16B_avx2(\n-    uint32_t num_rows, const uint32_t* left_to_right_map, uint8_t* match_bytevector,\n-    uint32_t length, const uint8_t* rows_left, const uint8_t* rows_right) {\n-  ARROW_DCHECK(length <= 16);\n-\n-  constexpr uint64_t kByteSequence0To7 = 0x0706050403020100ULL;\n-  constexpr uint64_t kByteSequence8To15 = 0x0f0e0d0c0b0a0908ULL;\n-\n-  __m256i mask =\n-      _mm256_cmpgt_epi8(_mm256_set1_epi8(length),\n-                        _mm256_setr_epi64x(kByteSequence0To7, kByteSequence8To15,\n-                                           kByteSequence0To7, kByteSequence8To15));\n-  const uint8_t* key_left_ptr = rows_left;\n-\n-  constexpr uint32_t unroll = 2;\n-  for (uint32_t i = 0; i < num_rows / unroll; ++i) {\n-    auto key_left = _mm256_inserti128_si256(\n-        _mm256_castsi128_si256(\n-            _mm_loadu_si128(reinterpret_cast<const __m128i*>(key_left_ptr))),\n-        _mm_loadu_si128(reinterpret_cast<const __m128i*>(key_left_ptr + length)), 1);\n-    key_left_ptr += length * 2;\n-    auto key_right = _mm256_inserti128_si256(\n-        _mm256_castsi128_si256(_mm_loadu_si128(reinterpret_cast<const __m128i*>(\n-            rows_right + length * left_to_right_map[2 * i]))),\n-        _mm_loadu_si128(reinterpret_cast<const __m128i*>(\n-            rows_right + length * left_to_right_map[2 * i + 1])),\n-        1);\n-    __m256i cmp = _mm256_cmpeq_epi64(_mm256_and_si256(key_left, mask),\n-                                     _mm256_and_si256(key_right, mask));\n-    cmp = _mm256_and_si256(cmp, _mm256_shuffle_epi32(cmp, 0xee));  // 0b11101110\n-    cmp = _mm256_permute4x64_epi64(cmp, 0x08);                     // 0b00001000\n-    reinterpret_cast<uint16_t*>(match_bytevector)[i] &=\n-        (_mm256_movemask_epi8(cmp) & 0xffff);\n-  }\n+    uint32_t num_processed = 0;\n+    constexpr uint32_t unroll = 8;\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      __m256i left_null;\n+      __m256i irow_right;\n+      if (use_selection) {\n+        __m256i irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+        irow_right = _mm256_i32gather_epi32((const int*)left_to_right_map, irow_left, 4);\n+        irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(col.bit_offset(0)));\n+        __m256i left = _mm256_i32gather_epi32((const int*)non_nulls,\n+                                              _mm256_srli_epi32(irow_left, 3), 1);\n+        left = _mm256_and_si256(\n+            _mm256_set1_epi32(1),\n+            _mm256_srlv_epi32(left, _mm256_and_si256(irow_left, _mm256_set1_epi32(7))));\n+        left_null = _mm256_cmpeq_epi32(left, _mm256_setzero_si256());\n+      } else {\n+        irow_right =\n+            _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_to_right_map) + i);\n+        __m256i left = _mm256_cvtepu8_epi32(_mm_set1_epi8(static_cast<uint8_t>(\n+            reinterpret_cast<const uint16_t*>(non_nulls + i)[0] >> col.bit_offset(0))));\n+        __m256i bits = _mm256_setr_epi32(1, 2, 4, 8, 16, 32, 64, 128);\n+        left_null =\n+            _mm256_cmpeq_epi32(_mm256_and_si256(left, bits), _mm256_setzero_si256());\n+      }\n+      __m256i bitid =\n+          _mm256_mullo_epi32(irow_right, _mm256_set1_epi32(null_mask_num_bytes * 8));\n+      bitid = _mm256_add_epi32(bitid, _mm256_set1_epi32(id_col));\n+      __m256i right =\n+          _mm256_i32gather_epi32((const int*)null_masks, _mm256_srli_epi32(bitid, 3), 1);\n+      right = _mm256_and_si256(\n+          _mm256_set1_epi32(1),\n+          _mm256_srlv_epi32(right, _mm256_and_si256(bitid, _mm256_set1_epi32(7))));\n+      __m256i right_null = _mm256_cmpeq_epi32(right, _mm256_set1_epi32(1));\n \n-  uint32_t num_rows_processed = num_rows - (num_rows % unroll);\n-  return num_rows_processed;\n-}\n+      uint64_t left_null_64 =\n+          static_cast<uint32_t>(_mm256_movemask_epi8(\n+              _mm256_cvtepi32_epi64(_mm256_castsi256_si128(left_null)))) |\n+          (static_cast<uint64_t>(static_cast<uint32_t>(_mm256_movemask_epi8(\n+               _mm256_cvtepi32_epi64(_mm256_extracti128_si256(left_null, 1)))))\n+           << 32);\n \n-uint32_t KeyCompare::CompareFixedLength_avx2(uint32_t num_rows,\n-                                             const uint32_t* left_to_right_map,\n-                                             uint8_t* match_bytevector, uint32_t length,\n-                                             const uint8_t* rows_left,\n-                                             const uint8_t* rows_right) {\n-  ARROW_DCHECK(length > 0);\n+      uint64_t right_null_64 =\n+          static_cast<uint32_t>(_mm256_movemask_epi8(\n+              _mm256_cvtepi32_epi64(_mm256_castsi256_si128(right_null)))) |\n+          (static_cast<uint64_t>(static_cast<uint32_t>(_mm256_movemask_epi8(\n+               _mm256_cvtepi32_epi64(_mm256_extracti128_si256(right_null, 1)))))\n+           << 32);\n \n-  constexpr uint64_t kByteSequence0To7 = 0x0706050403020100ULL;\n-  constexpr uint64_t kByteSequence8To15 = 0x0f0e0d0c0b0a0908ULL;\n-  constexpr uint64_t kByteSequence16To23 = 0x1716151413121110ULL;\n-  constexpr uint64_t kByteSequence24To31 = 0x1f1e1d1c1b1a1918ULL;\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] |= left_null_64 & right_null_64;\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] &= ~(left_null_64 ^ right_null_64);\n+    }\n+    num_processed = num_rows_to_compare / unroll * unroll;\n+    return num_processed;\n+  }\n+}\n \n-  // Non-zero length guarantees no underflow\n-  int32_t num_loops_less_one = (static_cast<int32_t>(length) + 31) / 32 - 1;\n+template <bool use_selection, class COMPARE8_FN>\n+uint32_t KeyCompare::CompareBinaryColumnToRowHelper_avx2(\n+    uint32_t offset_within_row, uint32_t num_rows_to_compare,\n+    const uint16_t* sel_left_maybe_null, const uint32_t* left_to_right_map,\n+    KeyEncoder::KeyEncoderContext* ctx, const KeyEncoder::KeyColumnArray& col,\n+    const KeyEncoder::KeyRowArray& rows, uint8_t* match_bytevector,\n+    COMPARE8_FN compare8_fn) {\n+  bool is_fixed_length = rows.metadata().is_fixed_length;\n+  if (is_fixed_length) {\n+    uint32_t fixed_length = rows.metadata().fixed_length;\n+    const uint8_t* rows_left = col.data(1);\n+    const uint8_t* rows_right = rows.data(1);\n+    constexpr uint32_t unroll = 8;\n+    __m256i irow_left = _mm256_setr_epi32(0, 1, 2, 3, 4, 5, 6, 7);\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      if (use_selection) {\n+        irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+      }\n+      __m256i irow_right;\n+      if (use_selection) {\n+        irow_right = _mm256_i32gather_epi32((const int*)left_to_right_map, irow_left, 4);\n+      } else {\n+        irow_right =\n+            _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_to_right_map) + i);\n+      }\n \n-  __m256i tail_mask =\n-      _mm256_cmpgt_epi8(_mm256_set1_epi8(length - num_loops_less_one * 32),\n-                        _mm256_setr_epi64x(kByteSequence0To7, kByteSequence8To15,\n-                                           kByteSequence16To23, kByteSequence24To31));\n+      __m256i offset_right =\n+          _mm256_mullo_epi32(irow_right, _mm256_set1_epi32(fixed_length));\n+      offset_right = _mm256_add_epi32(offset_right, _mm256_set1_epi32(offset_within_row));\n \n-  for (uint32_t irow_left = 0; irow_left < num_rows; ++irow_left) {\n-    uint32_t irow_right = left_to_right_map[irow_left];\n-    uint32_t begin_left = length * irow_left;\n-    uint32_t begin_right = length * irow_right;\n-    const __m256i* key_left_ptr =\n-        reinterpret_cast<const __m256i*>(rows_left + begin_left);\n-    const __m256i* key_right_ptr =\n-        reinterpret_cast<const __m256i*>(rows_right + begin_right);\n-    __m256i result_or = _mm256_setzero_si256();\n-    int32_t i;\n-    // length cannot be zero\n-    for (i = 0; i < num_loops_less_one; ++i) {\n-      __m256i key_left = _mm256_loadu_si256(key_left_ptr + i);\n-      __m256i key_right = _mm256_loadu_si256(key_right_ptr + i);\n-      result_or = _mm256_or_si256(result_or, _mm256_xor_si256(key_left, key_right));\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] =\n+          compare8_fn(rows_left, rows_right, i * unroll, irow_left, offset_right);\n+\n+      if (!use_selection) {\n+        irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(8));\n+      }\n     }\n+    return num_rows_to_compare - (num_rows_to_compare % unroll);\n+  } else {\n+    const uint8_t* rows_left = col.data(1);\n+    const uint32_t* offsets_right = rows.offsets();\n+    const uint8_t* rows_right = rows.data(2);\n+    constexpr uint32_t unroll = 8;\n+    __m256i irow_left = _mm256_setr_epi32(0, 1, 2, 3, 4, 5, 6, 7);\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      if (use_selection) {\n+        irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+      }\n+      __m256i irow_right;\n+      if (use_selection) {\n+        irow_right = _mm256_i32gather_epi32((const int*)left_to_right_map, irow_left, 4);\n+      } else {\n+        irow_right =\n+            _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_to_right_map) + i);\n+      }\n+      __m256i offset_right =\n+          _mm256_i32gather_epi32((const int*)offsets_right, irow_right, 4);\n+      offset_right = _mm256_add_epi32(offset_right, _mm256_set1_epi32(offset_within_row));\n \n-    __m256i key_left = _mm256_loadu_si256(key_left_ptr + i);\n-    __m256i key_right = _mm256_loadu_si256(key_right_ptr + i);\n-    result_or = _mm256_or_si256(\n-        result_or, _mm256_and_si256(tail_mask, _mm256_xor_si256(key_left, key_right)));\n-    int result = _mm256_testz_si256(result_or, result_or) * 0xff;\n-    match_bytevector[irow_left] &= result;\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] =\n+          compare8_fn(rows_left, rows_right, i * unroll, irow_left, offset_right);\n+\n+      if (!use_selection) {\n+        irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(8));\n+      }\n+    }\n+    return num_rows_to_compare - (num_rows_to_compare % unroll);\n   }\n+}\n \n-  uint32_t num_rows_processed = num_rows;\n-  return num_rows_processed;\n+template <bool use_selection>\n+uint32_t KeyCompare::CompareBinaryColumnToRowImp_avx2(\n+    uint32_t offset_within_row, uint32_t num_rows_to_compare,\n+    const uint16_t* sel_left_maybe_null, const uint32_t* left_to_right_map,\n+    KeyEncoder::KeyEncoderContext* ctx, const KeyEncoder::KeyColumnArray& col,\n+    const KeyEncoder::KeyRowArray& rows, uint8_t* match_bytevector) {\n+  uint32_t col_width = col.metadata().fixed_length;\n+  if (col_width == 0) {\n+    int bit_offset = col.bit_offset(1);\n+    return CompareBinaryColumnToRowHelper_avx2<use_selection>(\n+        offset_within_row, num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n+        ctx, col, rows, match_bytevector,\n+        [bit_offset](const uint8_t* left_base, const uint8_t* right_base,\n+                     uint32_t irow_left_base, __m256i irow_left, __m256i offset_right) {\n+          __m256i left;\n+          if (use_selection) {\n+            irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(bit_offset));\n+            left = _mm256_i32gather_epi32((const int*)left_base,\n+                                          _mm256_srli_epi32(irow_left, 3), 1);\n+            left = _mm256_and_si256(\n+                _mm256_set1_epi32(1),\n+                _mm256_srlv_epi32(left,\n+                                  _mm256_and_si256(irow_left, _mm256_set1_epi32(7))));\n+            left = _mm256_mullo_epi32(left, _mm256_set1_epi32(0xff));\n+          } else {\n+            __m256i bits = _mm256_setr_epi32(1, 2, 4, 8, 16, 32, 64, 128);\n+            uint32_t start_bit_index = irow_left_base + bit_offset;\n+            uint8_t left_bits_8 =\n+                (reinterpret_cast<const uint16_t*>(left_base + start_bit_index / 8)[0] >>\n+                 (start_bit_index % 8)) &\n+                0xff;\n+            left = _mm256_cmpeq_epi32(\n+                _mm256_and_si256(bits, _mm256_set1_epi8(left_bits_8)), bits);\n+            left = _mm256_and_si256(left, _mm256_set1_epi32(0xff));\n+          }\n+          __m256i right = _mm256_i32gather_epi32((const int*)right_base, offset_right, 1);\n+          right = _mm256_and_si256(right, _mm256_set1_epi32(0xff));\n+          __m256i cmp = _mm256_cmpeq_epi32(left, right);\n+          uint32_t result_lo =\n+              _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_castsi256_si128(cmp)));\n+          uint32_t result_hi = _mm256_movemask_epi8(\n+              _mm256_cvtepi32_epi64(_mm256_extracti128_si256(cmp, 1)));\n+          return result_lo | (static_cast<uint64_t>(result_hi) << 32);\n+        });\n+  } else if (col_width == 1) {\n\nReview comment:\n       These blocks are very repetitive and it's difficult to see how they differ. As written the blocks look sufficiently different to make generic extraction difficult, which is unfortunate.\n\n##########\nFile path: cpp/src/arrow/compute/exec/key_compare_avx2.cc\n##########\n@@ -25,160 +25,545 @@ namespace compute {\n \n #if defined(ARROW_HAVE_AVX2)\n \n-uint32_t KeyCompare::CompareFixedLength_UpTo8B_avx2(\n-    uint32_t num_rows, const uint32_t* left_to_right_map, uint8_t* match_bytevector,\n-    uint32_t length, const uint8_t* rows_left, const uint8_t* rows_right) {\n-  ARROW_DCHECK(length <= 8);\n-  __m256i offset_left = _mm256_setr_epi64x(0, length, length * 2, length * 3);\n-  __m256i offset_left_incr = _mm256_set1_epi64x(length * 4);\n-  __m256i mask = _mm256_set1_epi64x(~0ULL >> (8 * (8 - length)));\n-\n-  constexpr uint32_t unroll = 4;\n-  for (uint32_t i = 0; i < num_rows / unroll; ++i) {\n-    auto key_left = _mm256_i64gather_epi64(\n-        reinterpret_cast<arrow::util::int64_for_gather_t*>(rows_left), offset_left, 1);\n-    offset_left = _mm256_add_epi64(offset_left, offset_left_incr);\n-    __m128i offset_right =\n-        _mm_loadu_si128(reinterpret_cast<const __m128i*>(left_to_right_map) + i);\n-    offset_right = _mm_mullo_epi32(offset_right, _mm_set1_epi32(length));\n-\n-    auto key_right = _mm256_i32gather_epi64(\n-        reinterpret_cast<arrow::util::int64_for_gather_t*>(rows_right), offset_right, 1);\n-    uint32_t cmp = _mm256_movemask_epi8(_mm256_cmpeq_epi64(\n-        _mm256_and_si256(key_left, mask), _mm256_and_si256(key_right, mask)));\n-    reinterpret_cast<uint32_t*>(match_bytevector)[i] &= cmp;\n+template <bool use_selection>\n+uint32_t KeyCompare::NullUpdateColumnToRowImp_avx2(\n+    uint32_t id_col, uint32_t num_rows_to_compare, const uint16_t* sel_left_maybe_null,\n+    const uint32_t* left_to_right_map, KeyEncoder::KeyEncoderContext* ctx,\n+    const KeyEncoder::KeyColumnArray& col, const KeyEncoder::KeyRowArray& rows,\n+    uint8_t* match_bytevector) {\n+  if (!rows.has_any_nulls(ctx) && !col.data(0)) {\n+    return num_rows_to_compare;\n   }\n+  if (!col.data(0)) {\n+    // Remove rows from the result for which the column value is a null\n+    const uint8_t* null_masks = rows.null_masks();\n+    uint32_t null_mask_num_bytes = rows.metadata().null_masks_bytes_per_row;\n \n-  uint32_t num_rows_processed = num_rows - (num_rows % unroll);\n-  return num_rows_processed;\n-}\n+    uint32_t num_processed = 0;\n+    constexpr uint32_t unroll = 8;\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      __m256i irow_right;\n+      if (use_selection) {\n+        __m256i irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+        irow_right = _mm256_i32gather_epi32((const int*)left_to_right_map, irow_left, 4);\n+      } else {\n+        irow_right =\n+            _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_to_right_map) + i);\n+      }\n+      __m256i bitid =\n+          _mm256_mullo_epi32(irow_right, _mm256_set1_epi32(null_mask_num_bytes * 8));\n+      bitid = _mm256_add_epi32(bitid, _mm256_set1_epi32(id_col));\n+      __m256i right =\n+          _mm256_i32gather_epi32((const int*)null_masks, _mm256_srli_epi32(bitid, 3), 1);\n+      right = _mm256_and_si256(\n+          _mm256_set1_epi32(1),\n+          _mm256_srlv_epi32(right, _mm256_and_si256(bitid, _mm256_set1_epi32(7))));\n+      __m256i cmp = _mm256_cmpeq_epi32(right, _mm256_setzero_si256());\n+      uint32_t result_lo =\n+          _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_castsi256_si128(cmp)));\n+      uint32_t result_hi =\n+          _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_extracti128_si256(cmp, 1)));\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] &=\n+          result_lo | (static_cast<uint64_t>(result_hi) << 32);\n+    }\n+    num_processed = num_rows_to_compare / unroll * unroll;\n+    return num_processed;\n+  } else if (!rows.has_any_nulls(ctx)) {\n+    // Remove rows from the result for which the column value on left side is null\n+    const uint8_t* non_nulls = col.data(0);\n+    ARROW_DCHECK(non_nulls);\n+    uint32_t num_processed = 0;\n+    constexpr uint32_t unroll = 8;\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      __m256i cmp;\n+      if (use_selection) {\n+        __m256i irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+        irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(col.bit_offset(0)));\n+        __m256i left = _mm256_i32gather_epi32((const int*)non_nulls,\n+                                              _mm256_srli_epi32(irow_left, 3), 1);\n+        left = _mm256_and_si256(\n+            _mm256_set1_epi32(1),\n+            _mm256_srlv_epi32(left, _mm256_and_si256(irow_left, _mm256_set1_epi32(7))));\n+        cmp = _mm256_cmpeq_epi32(left, _mm256_set1_epi32(1));\n+      } else {\n+        __m256i left = _mm256_cvtepu8_epi32(_mm_set1_epi8(static_cast<uint8_t>(\n+            reinterpret_cast<const uint16_t*>(non_nulls + i)[0] >> col.bit_offset(0))));\n+        __m256i bits = _mm256_setr_epi32(1, 2, 4, 8, 16, 32, 64, 128);\n+        cmp = _mm256_cmpeq_epi32(_mm256_and_si256(left, bits), bits);\n+      }\n+      uint32_t result_lo =\n+          _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_castsi256_si128(cmp)));\n+      uint32_t result_hi =\n+          _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_extracti128_si256(cmp, 1)));\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] &=\n+          result_lo | (static_cast<uint64_t>(result_hi) << 32);\n+      num_processed = num_rows_to_compare / unroll * unroll;\n+    }\n+    return num_processed;\n+  } else {\n+    const uint8_t* null_masks = rows.null_masks();\n+    uint32_t null_mask_num_bytes = rows.metadata().null_masks_bytes_per_row;\n+    const uint8_t* non_nulls = col.data(0);\n+    ARROW_DCHECK(non_nulls);\n \n-uint32_t KeyCompare::CompareFixedLength_UpTo16B_avx2(\n-    uint32_t num_rows, const uint32_t* left_to_right_map, uint8_t* match_bytevector,\n-    uint32_t length, const uint8_t* rows_left, const uint8_t* rows_right) {\n-  ARROW_DCHECK(length <= 16);\n-\n-  constexpr uint64_t kByteSequence0To7 = 0x0706050403020100ULL;\n-  constexpr uint64_t kByteSequence8To15 = 0x0f0e0d0c0b0a0908ULL;\n-\n-  __m256i mask =\n-      _mm256_cmpgt_epi8(_mm256_set1_epi8(length),\n-                        _mm256_setr_epi64x(kByteSequence0To7, kByteSequence8To15,\n-                                           kByteSequence0To7, kByteSequence8To15));\n-  const uint8_t* key_left_ptr = rows_left;\n-\n-  constexpr uint32_t unroll = 2;\n-  for (uint32_t i = 0; i < num_rows / unroll; ++i) {\n-    auto key_left = _mm256_inserti128_si256(\n-        _mm256_castsi128_si256(\n-            _mm_loadu_si128(reinterpret_cast<const __m128i*>(key_left_ptr))),\n-        _mm_loadu_si128(reinterpret_cast<const __m128i*>(key_left_ptr + length)), 1);\n-    key_left_ptr += length * 2;\n-    auto key_right = _mm256_inserti128_si256(\n-        _mm256_castsi128_si256(_mm_loadu_si128(reinterpret_cast<const __m128i*>(\n-            rows_right + length * left_to_right_map[2 * i]))),\n-        _mm_loadu_si128(reinterpret_cast<const __m128i*>(\n-            rows_right + length * left_to_right_map[2 * i + 1])),\n-        1);\n-    __m256i cmp = _mm256_cmpeq_epi64(_mm256_and_si256(key_left, mask),\n-                                     _mm256_and_si256(key_right, mask));\n-    cmp = _mm256_and_si256(cmp, _mm256_shuffle_epi32(cmp, 0xee));  // 0b11101110\n-    cmp = _mm256_permute4x64_epi64(cmp, 0x08);                     // 0b00001000\n-    reinterpret_cast<uint16_t*>(match_bytevector)[i] &=\n-        (_mm256_movemask_epi8(cmp) & 0xffff);\n-  }\n+    uint32_t num_processed = 0;\n+    constexpr uint32_t unroll = 8;\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      __m256i left_null;\n+      __m256i irow_right;\n+      if (use_selection) {\n+        __m256i irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+        irow_right = _mm256_i32gather_epi32((const int*)left_to_right_map, irow_left, 4);\n+        irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(col.bit_offset(0)));\n+        __m256i left = _mm256_i32gather_epi32((const int*)non_nulls,\n+                                              _mm256_srli_epi32(irow_left, 3), 1);\n+        left = _mm256_and_si256(\n+            _mm256_set1_epi32(1),\n+            _mm256_srlv_epi32(left, _mm256_and_si256(irow_left, _mm256_set1_epi32(7))));\n+        left_null = _mm256_cmpeq_epi32(left, _mm256_setzero_si256());\n+      } else {\n+        irow_right =\n+            _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_to_right_map) + i);\n+        __m256i left = _mm256_cvtepu8_epi32(_mm_set1_epi8(static_cast<uint8_t>(\n+            reinterpret_cast<const uint16_t*>(non_nulls + i)[0] >> col.bit_offset(0))));\n+        __m256i bits = _mm256_setr_epi32(1, 2, 4, 8, 16, 32, 64, 128);\n+        left_null =\n+            _mm256_cmpeq_epi32(_mm256_and_si256(left, bits), _mm256_setzero_si256());\n+      }\n+      __m256i bitid =\n+          _mm256_mullo_epi32(irow_right, _mm256_set1_epi32(null_mask_num_bytes * 8));\n+      bitid = _mm256_add_epi32(bitid, _mm256_set1_epi32(id_col));\n+      __m256i right =\n+          _mm256_i32gather_epi32((const int*)null_masks, _mm256_srli_epi32(bitid, 3), 1);\n+      right = _mm256_and_si256(\n+          _mm256_set1_epi32(1),\n+          _mm256_srlv_epi32(right, _mm256_and_si256(bitid, _mm256_set1_epi32(7))));\n+      __m256i right_null = _mm256_cmpeq_epi32(right, _mm256_set1_epi32(1));\n \n-  uint32_t num_rows_processed = num_rows - (num_rows % unroll);\n-  return num_rows_processed;\n-}\n+      uint64_t left_null_64 =\n+          static_cast<uint32_t>(_mm256_movemask_epi8(\n+              _mm256_cvtepi32_epi64(_mm256_castsi256_si128(left_null)))) |\n+          (static_cast<uint64_t>(static_cast<uint32_t>(_mm256_movemask_epi8(\n+               _mm256_cvtepi32_epi64(_mm256_extracti128_si256(left_null, 1)))))\n+           << 32);\n \n-uint32_t KeyCompare::CompareFixedLength_avx2(uint32_t num_rows,\n-                                             const uint32_t* left_to_right_map,\n-                                             uint8_t* match_bytevector, uint32_t length,\n-                                             const uint8_t* rows_left,\n-                                             const uint8_t* rows_right) {\n-  ARROW_DCHECK(length > 0);\n+      uint64_t right_null_64 =\n+          static_cast<uint32_t>(_mm256_movemask_epi8(\n+              _mm256_cvtepi32_epi64(_mm256_castsi256_si128(right_null)))) |\n+          (static_cast<uint64_t>(static_cast<uint32_t>(_mm256_movemask_epi8(\n+               _mm256_cvtepi32_epi64(_mm256_extracti128_si256(right_null, 1)))))\n+           << 32);\n \n-  constexpr uint64_t kByteSequence0To7 = 0x0706050403020100ULL;\n-  constexpr uint64_t kByteSequence8To15 = 0x0f0e0d0c0b0a0908ULL;\n-  constexpr uint64_t kByteSequence16To23 = 0x1716151413121110ULL;\n-  constexpr uint64_t kByteSequence24To31 = 0x1f1e1d1c1b1a1918ULL;\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] |= left_null_64 & right_null_64;\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] &= ~(left_null_64 ^ right_null_64);\n+    }\n+    num_processed = num_rows_to_compare / unroll * unroll;\n+    return num_processed;\n+  }\n+}\n \n-  // Non-zero length guarantees no underflow\n-  int32_t num_loops_less_one = (static_cast<int32_t>(length) + 31) / 32 - 1;\n+template <bool use_selection, class COMPARE8_FN>\n+uint32_t KeyCompare::CompareBinaryColumnToRowHelper_avx2(\n+    uint32_t offset_within_row, uint32_t num_rows_to_compare,\n+    const uint16_t* sel_left_maybe_null, const uint32_t* left_to_right_map,\n+    KeyEncoder::KeyEncoderContext* ctx, const KeyEncoder::KeyColumnArray& col,\n+    const KeyEncoder::KeyRowArray& rows, uint8_t* match_bytevector,\n+    COMPARE8_FN compare8_fn) {\n+  bool is_fixed_length = rows.metadata().is_fixed_length;\n+  if (is_fixed_length) {\n+    uint32_t fixed_length = rows.metadata().fixed_length;\n+    const uint8_t* rows_left = col.data(1);\n+    const uint8_t* rows_right = rows.data(1);\n+    constexpr uint32_t unroll = 8;\n+    __m256i irow_left = _mm256_setr_epi32(0, 1, 2, 3, 4, 5, 6, 7);\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      if (use_selection) {\n+        irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+      }\n+      __m256i irow_right;\n+      if (use_selection) {\n+        irow_right = _mm256_i32gather_epi32((const int*)left_to_right_map, irow_left, 4);\n+      } else {\n+        irow_right =\n+            _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_to_right_map) + i);\n+      }\n \n-  __m256i tail_mask =\n-      _mm256_cmpgt_epi8(_mm256_set1_epi8(length - num_loops_less_one * 32),\n-                        _mm256_setr_epi64x(kByteSequence0To7, kByteSequence8To15,\n-                                           kByteSequence16To23, kByteSequence24To31));\n+      __m256i offset_right =\n+          _mm256_mullo_epi32(irow_right, _mm256_set1_epi32(fixed_length));\n+      offset_right = _mm256_add_epi32(offset_right, _mm256_set1_epi32(offset_within_row));\n \n-  for (uint32_t irow_left = 0; irow_left < num_rows; ++irow_left) {\n-    uint32_t irow_right = left_to_right_map[irow_left];\n-    uint32_t begin_left = length * irow_left;\n-    uint32_t begin_right = length * irow_right;\n-    const __m256i* key_left_ptr =\n-        reinterpret_cast<const __m256i*>(rows_left + begin_left);\n-    const __m256i* key_right_ptr =\n-        reinterpret_cast<const __m256i*>(rows_right + begin_right);\n-    __m256i result_or = _mm256_setzero_si256();\n-    int32_t i;\n-    // length cannot be zero\n-    for (i = 0; i < num_loops_less_one; ++i) {\n-      __m256i key_left = _mm256_loadu_si256(key_left_ptr + i);\n-      __m256i key_right = _mm256_loadu_si256(key_right_ptr + i);\n-      result_or = _mm256_or_si256(result_or, _mm256_xor_si256(key_left, key_right));\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] =\n+          compare8_fn(rows_left, rows_right, i * unroll, irow_left, offset_right);\n+\n+      if (!use_selection) {\n+        irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(8));\n+      }\n     }\n+    return num_rows_to_compare - (num_rows_to_compare % unroll);\n+  } else {\n+    const uint8_t* rows_left = col.data(1);\n+    const uint32_t* offsets_right = rows.offsets();\n+    const uint8_t* rows_right = rows.data(2);\n+    constexpr uint32_t unroll = 8;\n+    __m256i irow_left = _mm256_setr_epi32(0, 1, 2, 3, 4, 5, 6, 7);\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      if (use_selection) {\n+        irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+      }\n+      __m256i irow_right;\n+      if (use_selection) {\n+        irow_right = _mm256_i32gather_epi32((const int*)left_to_right_map, irow_left, 4);\n+      } else {\n+        irow_right =\n+            _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_to_right_map) + i);\n+      }\n+      __m256i offset_right =\n+          _mm256_i32gather_epi32((const int*)offsets_right, irow_right, 4);\n+      offset_right = _mm256_add_epi32(offset_right, _mm256_set1_epi32(offset_within_row));\n \n-    __m256i key_left = _mm256_loadu_si256(key_left_ptr + i);\n-    __m256i key_right = _mm256_loadu_si256(key_right_ptr + i);\n-    result_or = _mm256_or_si256(\n-        result_or, _mm256_and_si256(tail_mask, _mm256_xor_si256(key_left, key_right)));\n-    int result = _mm256_testz_si256(result_or, result_or) * 0xff;\n-    match_bytevector[irow_left] &= result;\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] =\n+          compare8_fn(rows_left, rows_right, i * unroll, irow_left, offset_right);\n+\n+      if (!use_selection) {\n+        irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(8));\n+      }\n+    }\n+    return num_rows_to_compare - (num_rows_to_compare % unroll);\n   }\n+}\n \n-  uint32_t num_rows_processed = num_rows;\n-  return num_rows_processed;\n+template <bool use_selection>\n+uint32_t KeyCompare::CompareBinaryColumnToRowImp_avx2(\n+    uint32_t offset_within_row, uint32_t num_rows_to_compare,\n+    const uint16_t* sel_left_maybe_null, const uint32_t* left_to_right_map,\n+    KeyEncoder::KeyEncoderContext* ctx, const KeyEncoder::KeyColumnArray& col,\n+    const KeyEncoder::KeyRowArray& rows, uint8_t* match_bytevector) {\n+  uint32_t col_width = col.metadata().fixed_length;\n+  if (col_width == 0) {\n+    int bit_offset = col.bit_offset(1);\n+    return CompareBinaryColumnToRowHelper_avx2<use_selection>(\n+        offset_within_row, num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n+        ctx, col, rows, match_bytevector,\n+        [bit_offset](const uint8_t* left_base, const uint8_t* right_base,\n+                     uint32_t irow_left_base, __m256i irow_left, __m256i offset_right) {\n+          __m256i left;\n+          if (use_selection) {\n+            irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(bit_offset));\n+            left = _mm256_i32gather_epi32((const int*)left_base,\n+                                          _mm256_srli_epi32(irow_left, 3), 1);\n+            left = _mm256_and_si256(\n+                _mm256_set1_epi32(1),\n+                _mm256_srlv_epi32(left,\n+                                  _mm256_and_si256(irow_left, _mm256_set1_epi32(7))));\n+            left = _mm256_mullo_epi32(left, _mm256_set1_epi32(0xff));\n+          } else {\n+            __m256i bits = _mm256_setr_epi32(1, 2, 4, 8, 16, 32, 64, 128);\n+            uint32_t start_bit_index = irow_left_base + bit_offset;\n+            uint8_t left_bits_8 =\n+                (reinterpret_cast<const uint16_t*>(left_base + start_bit_index / 8)[0] >>\n+                 (start_bit_index % 8)) &\n+                0xff;\n+            left = _mm256_cmpeq_epi32(\n+                _mm256_and_si256(bits, _mm256_set1_epi8(left_bits_8)), bits);\n+            left = _mm256_and_si256(left, _mm256_set1_epi32(0xff));\n+          }\n+          __m256i right = _mm256_i32gather_epi32((const int*)right_base, offset_right, 1);\n+          right = _mm256_and_si256(right, _mm256_set1_epi32(0xff));\n+          __m256i cmp = _mm256_cmpeq_epi32(left, right);\n+          uint32_t result_lo =\n+              _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_castsi256_si128(cmp)));\n+          uint32_t result_hi = _mm256_movemask_epi8(\n+              _mm256_cvtepi32_epi64(_mm256_extracti128_si256(cmp, 1)));\n+          return result_lo | (static_cast<uint64_t>(result_hi) << 32);\n+        });\n+  } else if (col_width == 1) {\n+    return CompareBinaryColumnToRowHelper_avx2<use_selection>(\n+        offset_within_row, num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n+        ctx, col, rows, match_bytevector,\n+        [](const uint8_t* left_base, const uint8_t* right_base, uint32_t irow_left_base,\n+           __m256i irow_left, __m256i offset_right) {\n+          __m256i left;\n+          if (use_selection) {\n+            left = _mm256_i32gather_epi32((const int*)left_base, irow_left, 1);\n+            left = _mm256_and_si256(left, _mm256_set1_epi32(0xff));\n+          } else {\n+            left = _mm256_cvtepu8_epi32(_mm_set1_epi64x(\n+                reinterpret_cast<const uint64_t*>(left_base)[irow_left_base / 8]));\n+          }\n+          __m256i right = _mm256_i32gather_epi32((const int*)right_base, offset_right, 1);\n+          right = _mm256_and_si256(right, _mm256_set1_epi32(0xff));\n+          __m256i cmp = _mm256_cmpeq_epi32(left, right);\n+          uint32_t result_lo =\n+              _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_castsi256_si128(cmp)));\n+          uint32_t result_hi = _mm256_movemask_epi8(\n+              _mm256_cvtepi32_epi64(_mm256_extracti128_si256(cmp, 1)));\n+          return result_lo | (static_cast<uint64_t>(result_hi) << 32);\n+        });\n+  } else if (col_width == 2) {\n+    return CompareBinaryColumnToRowHelper_avx2<use_selection>(\n+        offset_within_row, num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n+        ctx, col, rows, match_bytevector,\n+        [](const uint8_t* left_base, const uint8_t* right_base, uint32_t irow_left_base,\n+           __m256i irow_left, __m256i offset_right) {\n+          __m256i left;\n+          if (use_selection) {\n+            left = _mm256_i32gather_epi32((const int*)left_base, irow_left, 2);\n+            left = _mm256_and_si256(left, _mm256_set1_epi32(0xffff));\n+          } else {\n+            left = _mm256_cvtepu16_epi32(_mm_loadu_si128(\n+                reinterpret_cast<const __m128i*>(left_base) + irow_left_base / 8));\n+          }\n+          __m256i right = _mm256_i32gather_epi32((const int*)right_base, offset_right, 1);\n+          right = _mm256_and_si256(right, _mm256_set1_epi32(0xffff));\n+          __m256i cmp = _mm256_cmpeq_epi32(left, right);\n+          uint32_t result_lo =\n+              _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_castsi256_si128(cmp)));\n+          uint32_t result_hi = _mm256_movemask_epi8(\n+              _mm256_cvtepi32_epi64(_mm256_extracti128_si256(cmp, 1)));\n+          return result_lo | (static_cast<uint64_t>(result_hi) << 32);\n+        });\n+  } else if (col_width == 4) {\n+    return CompareBinaryColumnToRowHelper_avx2<use_selection>(\n+        offset_within_row, num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n+        ctx, col, rows, match_bytevector,\n+        [](const uint8_t* left_base, const uint8_t* right_base, uint32_t irow_left_base,\n+           __m256i irow_left, __m256i offset_right) {\n+          __m256i left;\n+          if (use_selection) {\n+            left = _mm256_i32gather_epi32((const int*)left_base, irow_left, 4);\n+          } else {\n+            left = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_base) +\n+                                      irow_left_base / 8);\n+          }\n+          __m256i right = _mm256_i32gather_epi32((const int*)right_base, offset_right, 1);\n+          __m256i cmp = _mm256_cmpeq_epi32(left, right);\n+          uint32_t result_lo =\n+              _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_castsi256_si128(cmp)));\n+          uint32_t result_hi = _mm256_movemask_epi8(\n+              _mm256_cvtepi32_epi64(_mm256_extracti128_si256(cmp, 1)));\n+          return result_lo | (static_cast<uint64_t>(result_hi) << 32);\n+        });\n+  } else if (col_width == 8) {\n+    return CompareBinaryColumnToRowHelper_avx2<use_selection>(\n+        offset_within_row, num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n+        ctx, col, rows, match_bytevector,\n+        [](const uint8_t* left_base, const uint8_t* right_base, uint32_t irow_left_base,\n+           __m256i irow_left, __m256i offset_right) {\n+          auto left_base_i64 =\n+              reinterpret_cast<const arrow::util::int64_for_gather_t*>(left_base);\n+          __m256i left_lo =\n+              _mm256_i32gather_epi64(left_base_i64, _mm256_castsi256_si128(irow_left), 8);\n+          __m256i left_hi = _mm256_i32gather_epi64(\n+              left_base_i64, _mm256_extracti128_si256(irow_left, 1), 8);\n+          if (use_selection) {\n+            left_lo = _mm256_i32gather_epi64(left_base_i64,\n+                                             _mm256_castsi256_si128(irow_left), 8);\n+            left_hi = _mm256_i32gather_epi64(left_base_i64,\n+                                             _mm256_extracti128_si256(irow_left, 1), 8);\n+          } else {\n+            left_lo = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_base) +\n+                                         irow_left_base / 4);\n+            left_hi = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_base) +\n+                                         irow_left_base / 4 + 1);\n+          }\n+          auto right_base_i64 =\n+              reinterpret_cast<const arrow::util::int64_for_gather_t*>(right_base);\n+          __m256i right_lo = _mm256_i32gather_epi64(\n+              right_base_i64, _mm256_castsi256_si128(offset_right), 1);\n+          __m256i right_hi = _mm256_i32gather_epi64(\n+              right_base_i64, _mm256_extracti128_si256(offset_right, 1), 1);\n+          uint32_t result_lo =\n+              _mm256_movemask_epi8(_mm256_cmpeq_epi64(left_lo, right_lo));\n+          uint32_t result_hi =\n+              _mm256_movemask_epi8(_mm256_cmpeq_epi64(left_hi, right_hi));\n+          return result_lo | (static_cast<uint64_t>(result_hi) << 32);\n+        });\n+  } else {\n+    return CompareBinaryColumnToRowHelper_avx2<use_selection>(\n+        offset_within_row, num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n+        ctx, col, rows, match_bytevector,\n+        [&col](const uint8_t* left_base, const uint8_t* right_base,\n+               uint32_t irow_left_base, __m256i irow_left, __m256i offset_right) {\n+          uint32_t irow_left_array[8];\n+          uint32_t offset_right_array[8];\n+          if (use_selection) {\n+            _mm256_storeu_si256(reinterpret_cast<__m256i*>(irow_left_array), irow_left);\n+          }\n+          _mm256_storeu_si256(reinterpret_cast<__m256i*>(offset_right_array),\n+                              offset_right);\n+          uint32_t length = col.metadata().fixed_length;\n+\n+          // Non-zero length guarantees no underflow\n+          int32_t num_loops_less_one = (static_cast<int32_t>(length) + 31) / 32 - 1;\n+\n+          __m256i tail_mask = _mm256_cmpgt_epi8(\n+              _mm256_set1_epi8(length - num_loops_less_one * 32),\n+              _mm256_setr_epi64x(0x0706050403020100ULL, 0x0f0e0d0c0b0a0908ULL,\n+                                 0x1716151413121110ULL, 0x1f1e1d1c1b1a1918ULL));\n+\n+          uint64_t result = 0;\n+          for (uint32_t irow = 0; irow < 8; ++irow) {\n+            const __m256i* key_left_ptr = reinterpret_cast<const __m256i*>(\n+                left_base +\n+                (use_selection ? irow_left_array[irow] : irow_left_base + irow) * length);\n+            const __m256i* key_right_ptr =\n+                reinterpret_cast<const __m256i*>(right_base + offset_right_array[irow]);\n+            __m256i result_or = _mm256_setzero_si256();\n+            int32_t i;\n+            // length cannot be zero\n+            for (i = 0; i < num_loops_less_one; ++i) {\n+              __m256i key_left = _mm256_loadu_si256(key_left_ptr + i);\n+              __m256i key_right = _mm256_loadu_si256(key_right_ptr + i);\n+              result_or =\n+                  _mm256_or_si256(result_or, _mm256_xor_si256(key_left, key_right));\n+            }\n+            __m256i key_left = _mm256_loadu_si256(key_left_ptr + i);\n+            __m256i key_right = _mm256_loadu_si256(key_right_ptr + i);\n+            result_or = _mm256_or_si256(\n+                result_or,\n+                _mm256_and_si256(tail_mask, _mm256_xor_si256(key_left, key_right)));\n+            uint64_t result_single = _mm256_testz_si256(result_or, result_or) * 0xff;\n+            result |= result_single << (8 * irow);\n+          }\n+          return result;\n+        });\n+  }\n }\n \n-void KeyCompare::CompareVaryingLength_avx2(\n-    uint32_t num_rows, const uint32_t* left_to_right_map, uint8_t* match_bytevector,\n-    const uint8_t* rows_left, const uint8_t* rows_right, const uint32_t* offsets_left,\n-    const uint32_t* offsets_right) {\n-  for (uint32_t irow_left = 0; irow_left < num_rows; ++irow_left) {\n+// Overwrites the match_bytevector instead of updating it\n+template <bool use_selection, bool is_first_varbinary_col>\n+void KeyCompare::CompareVarBinaryColumnToRowImp_avx2(\n+    uint32_t id_varbinary_col, uint32_t num_rows_to_compare,\n+    const uint16_t* sel_left_maybe_null, const uint32_t* left_to_right_map,\n+    KeyEncoder::KeyEncoderContext* ctx, const KeyEncoder::KeyColumnArray& col,\n+    const KeyEncoder::KeyRowArray& rows, uint8_t* match_bytevector) {\n+  const uint32_t* offsets_left = col.offsets();\n+  const uint32_t* offsets_right = rows.offsets();\n+  const uint8_t* rows_left = col.data(2);\n+  const uint8_t* rows_right = rows.data(2);\n+  for (uint32_t i = 0; i < num_rows_to_compare; ++i) {\n+    uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n     uint32_t irow_right = left_to_right_map[irow_left];\n     uint32_t begin_left = offsets_left[irow_left];\n-    uint32_t begin_right = offsets_right[irow_right];\n     uint32_t length_left = offsets_left[irow_left + 1] - begin_left;\n-    uint32_t length_right = offsets_right[irow_right + 1] - begin_right;\n-    uint32_t length = std::min(length_left, length_right);\n-    auto key_left_ptr = reinterpret_cast<const __m256i*>(rows_left + begin_left);\n-    auto key_right_ptr = reinterpret_cast<const __m256i*>(rows_right + begin_right);\n-    __m256i result_or = _mm256_setzero_si256();\n-    int32_t i;\n-    // length can be zero\n-    for (i = 0; i < (static_cast<int32_t>(length) + 31) / 32 - 1; ++i) {\n-      __m256i key_left = _mm256_loadu_si256(key_left_ptr + i);\n-      __m256i key_right = _mm256_loadu_si256(key_right_ptr + i);\n-      result_or = _mm256_or_si256(result_or, _mm256_xor_si256(key_left, key_right));\n+    uint32_t begin_right = offsets_right[irow_right];\n+    uint32_t length_right;\n+    uint32_t offset_within_row;\n+    if (!is_first_varbinary_col) {\n+      rows.metadata().nth_varbinary_offset_and_length(\n+          rows_right + begin_right, id_varbinary_col, &offset_within_row, &length_right);\n+    } else {\n+      rows.metadata().first_varbinary_offset_and_length(\n+          rows_right + begin_right, &offset_within_row, &length_right);\n     }\n+    begin_right += offset_within_row;\n \n-    constexpr uint64_t kByteSequence0To7 = 0x0706050403020100ULL;\n-    constexpr uint64_t kByteSequence8To15 = 0x0f0e0d0c0b0a0908ULL;\n-    constexpr uint64_t kByteSequence16To23 = 0x1716151413121110ULL;\n-    constexpr uint64_t kByteSequence24To31 = 0x1f1e1d1c1b1a1918ULL;\n+    __m256i result_or = _mm256_setzero_si256();\n+    uint32_t length = std::min(length_left, length_right);\n+    if (length > 0) {\n+      const __m256i* key_left_ptr =\n+          reinterpret_cast<const __m256i*>(rows_left + begin_left);\n+      const __m256i* key_right_ptr =\n+          reinterpret_cast<const __m256i*>(rows_right + begin_right);\n+      int32_t j;\n+      // length can be zero\n+      for (j = 0; j < (static_cast<int32_t>(length) + 31) / 32 - 1; ++j) {\n+        __m256i key_left = _mm256_loadu_si256(key_left_ptr + j);\n+        __m256i key_right = _mm256_loadu_si256(key_right_ptr + j);\n+        result_or = _mm256_or_si256(result_or, _mm256_xor_si256(key_left, key_right));\n+      }\n \n-    __m256i tail_mask =\n-        _mm256_cmpgt_epi8(_mm256_set1_epi8(length - i * 32),\n-                          _mm256_setr_epi64x(kByteSequence0To7, kByteSequence8To15,\n-                                             kByteSequence16To23, kByteSequence24To31));\n+      __m256i tail_mask = _mm256_cmpgt_epi8(\n+          _mm256_set1_epi8(length - j * 32),\n+          _mm256_setr_epi64x(0x0706050403020100ULL, 0x0f0e0d0c0b0a0908ULL,\n\nReview comment:\n       why remove these constants?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-12T19:57:49.226+0000",
                    "updated": "2021-08-12T19:57:49.226+0000",
                    "started": "2021-08-12T19:57:49.226+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637527",
                    "issueId": "13377672"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377672/worklog/637637",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "michalursa commented on a change in pull request #10290:\nURL: https://github.com/apache/arrow/pull/10290#discussion_r688204348\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/key_compare.cc\n##########\n@@ -17,250 +17,398 @@\n \n #include \"arrow/compute/exec/key_compare.h\"\n \n+#include <immintrin.h>\n\nReview comment:\n       removed\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-13T02:36:51.263+0000",
                    "updated": "2021-08-13T02:36:51.263+0000",
                    "started": "2021-08-13T02:36:51.263+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637637",
                    "issueId": "13377672"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377672/worklog/637655",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "michalursa commented on a change in pull request #10290:\nURL: https://github.com/apache/arrow/pull/10290#discussion_r688211337\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/key_compare.cc\n##########\n@@ -17,250 +17,398 @@\n \n #include \"arrow/compute/exec/key_compare.h\"\n \n+#include <immintrin.h>\n+#include <memory.h>\n+\n #include <algorithm>\n #include <cstdint>\n \n #include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bit_util.h\"\n #include \"arrow/util/ubsan.h\"\n \n namespace arrow {\n namespace compute {\n \n-void KeyCompare::CompareRows(uint32_t num_rows_to_compare,\n-                             const uint16_t* sel_left_maybe_null,\n-                             const uint32_t* left_to_right_map,\n-                             KeyEncoder::KeyEncoderContext* ctx, uint32_t* out_num_rows,\n-                             uint16_t* out_sel_left_maybe_same,\n-                             const KeyEncoder::KeyRowArray& rows_left,\n-                             const KeyEncoder::KeyRowArray& rows_right) {\n-  ARROW_DCHECK(rows_left.metadata().is_compatible(rows_right.metadata()));\n-\n-  if (num_rows_to_compare == 0) {\n-    *out_num_rows = 0;\n+template <bool use_selection>\n+void KeyCompare::NullUpdateColumnToRow(uint32_t id_col, uint32_t num_rows_to_compare,\n+                                       const uint16_t* sel_left_maybe_null,\n+                                       const uint32_t* left_to_right_map,\n+                                       KeyEncoder::KeyEncoderContext* ctx,\n+                                       const KeyEncoder::KeyColumnArray& col,\n+                                       const KeyEncoder::KeyRowArray& rows,\n+                                       uint8_t* match_bytevector) {\n+  if (!rows.has_any_nulls(ctx) && !col.data(0)) {\n     return;\n   }\n-\n-  // Allocate temporary byte and bit vectors\n-  auto bytevector_holder =\n-      util::TempVectorHolder<uint8_t>(ctx->stack, num_rows_to_compare);\n-  auto bitvector_holder =\n-      util::TempVectorHolder<uint8_t>(ctx->stack, num_rows_to_compare);\n-\n-  uint8_t* match_bytevector = bytevector_holder.mutable_data();\n-  uint8_t* match_bitvector = bitvector_holder.mutable_data();\n-\n-  // All comparison functions called here will update match byte vector\n-  // (AND it with comparison result) instead of overwriting it.\n-  memset(match_bytevector, 0xff, num_rows_to_compare);\n-\n-  if (rows_left.metadata().is_fixed_length) {\n-    CompareFixedLength(num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n-                       match_bytevector, ctx, rows_left.metadata().fixed_length,\n-                       rows_left.data(1), rows_right.data(1));\n-  } else {\n-    CompareVaryingLength(num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n-                         match_bytevector, ctx, rows_left.data(2), rows_right.data(2),\n-                         rows_left.offsets(), rows_right.offsets());\n+  uint32_t num_processed = 0;\n+#if defined(ARROW_HAVE_AVX2)\n+  if (ctx->has_avx2()) {\n+    num_processed = NullUpdateColumnToRow_avx2(use_selection, id_col, num_rows_to_compare,\n+                                               sel_left_maybe_null, left_to_right_map,\n+                                               ctx, col, rows, match_bytevector);\n   }\n+#endif\n \n-  // CompareFixedLength can be used to compare nulls as well\n-  bool nulls_present = rows_left.has_any_nulls(ctx) || rows_right.has_any_nulls(ctx);\n-  if (nulls_present) {\n-    CompareFixedLength(num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n-                       match_bytevector, ctx,\n-                       rows_left.metadata().null_masks_bytes_per_row,\n-                       rows_left.null_masks(), rows_right.null_masks());\n+  if (!col.data(0)) {\n+    // Remove rows from the result for which the column value is a null\n+    const uint8_t* null_masks = rows.null_masks();\n+    uint32_t null_mask_num_bytes = rows.metadata().null_masks_bytes_per_row;\n+    for (uint32_t i = num_processed; i < num_rows_to_compare; ++i) {\n+      uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n+      uint32_t irow_right = left_to_right_map[irow_left];\n+      int64_t bitid = irow_right * null_mask_num_bytes * 8 + id_col;\n+      match_bytevector[i] &= (BitUtil::GetBit(null_masks, bitid) ? 0 : 0xff);\n+    }\n+  } else if (!rows.has_any_nulls(ctx)) {\n+    // Remove rows from the result for which the column value on left side is null\n+    const uint8_t* non_nulls = col.data(0);\n+    ARROW_DCHECK(non_nulls);\n+    for (uint32_t i = num_processed; i < num_rows_to_compare; ++i) {\n+      uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n+      match_bytevector[i] &=\n+          BitUtil::GetBit(non_nulls, irow_left + col.bit_offset(0)) ? 0xff : 0;\n+    }\n+  } else {\n+    const uint8_t* null_masks = rows.null_masks();\n+    uint32_t null_mask_num_bytes = rows.metadata().null_masks_bytes_per_row;\n+    const uint8_t* non_nulls = col.data(0);\n+    ARROW_DCHECK(non_nulls);\n+    for (uint32_t i = num_processed; i < num_rows_to_compare; ++i) {\n+      uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n+      uint32_t irow_right = left_to_right_map[irow_left];\n+      int64_t bitid_right = irow_right * null_mask_num_bytes * 8 + id_col;\n+      int right_null = BitUtil::GetBit(null_masks, bitid_right) ? 0xff : 0;\n+      int left_null =\n+          BitUtil::GetBit(non_nulls, irow_left + col.bit_offset(0)) ? 0 : 0xff;\n+      match_bytevector[i] |= left_null & right_null;\n+      match_bytevector[i] &= ~(left_null ^ right_null);\n+    }\n   }\n+}\n \n-  util::BitUtil::bytes_to_bits(ctx->hardware_flags, num_rows_to_compare, match_bytevector,\n-                               match_bitvector);\n-  if (sel_left_maybe_null) {\n-    int out_num_rows_int;\n-    util::BitUtil::bits_filter_indexes(0, ctx->hardware_flags, num_rows_to_compare,\n-                                       match_bitvector, sel_left_maybe_null,\n-                                       &out_num_rows_int, out_sel_left_maybe_same);\n-    *out_num_rows = out_num_rows_int;\n+template <bool use_selection, class COMPARE_FN>\n+void KeyCompare::CompareBinaryColumnToRowHelper(\n+    uint32_t offset_within_row, uint32_t first_row_to_compare,\n+    uint32_t num_rows_to_compare, const uint16_t* sel_left_maybe_null,\n+    const uint32_t* left_to_right_map, KeyEncoder::KeyEncoderContext* ctx,\n+    const KeyEncoder::KeyColumnArray& col, const KeyEncoder::KeyRowArray& rows,\n+    uint8_t* match_bytevector, COMPARE_FN compare_fn) {\n+  bool is_fixed_length = rows.metadata().is_fixed_length;\n+  if (is_fixed_length) {\n+    uint32_t fixed_length = rows.metadata().fixed_length;\n+    const uint8_t* rows_left = col.data(1);\n+    const uint8_t* rows_right = rows.data(1);\n+    for (uint32_t i = first_row_to_compare; i < num_rows_to_compare; ++i) {\n+      uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n+      uint32_t irow_right = left_to_right_map[irow_left];\n+      uint32_t offset_right = irow_right * fixed_length + offset_within_row;\n+      match_bytevector[i] = compare_fn(rows_left, rows_right, irow_left, offset_right);\n+    }\n   } else {\n-    int out_num_rows_int;\n-    util::BitUtil::bits_to_indexes(0, ctx->hardware_flags, num_rows_to_compare,\n-                                   match_bitvector, &out_num_rows_int,\n-                                   out_sel_left_maybe_same);\n-    *out_num_rows = out_num_rows_int;\n+    const uint8_t* rows_left = col.data(1);\n+    const uint32_t* offsets_right = rows.offsets();\n+    const uint8_t* rows_right = rows.data(2);\n+    for (uint32_t i = first_row_to_compare; i < num_rows_to_compare; ++i) {\n+      uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n+      uint32_t irow_right = left_to_right_map[irow_left];\n+      uint32_t offset_right = offsets_right[irow_right] + offset_within_row;\n+      match_bytevector[i] = compare_fn(rows_left, rows_right, irow_left, offset_right);\n+    }\n   }\n }\n \n-void KeyCompare::CompareFixedLength(uint32_t num_rows_to_compare,\n-                                    const uint16_t* sel_left_maybe_null,\n-                                    const uint32_t* left_to_right_map,\n-                                    uint8_t* match_bytevector,\n-                                    KeyEncoder::KeyEncoderContext* ctx,\n-                                    uint32_t fixed_length, const uint8_t* rows_left,\n-                                    const uint8_t* rows_right) {\n-  bool use_selection = (sel_left_maybe_null != nullptr);\n-\n-  uint32_t num_rows_already_processed = 0;\n-\n+template <bool use_selection>\n+void KeyCompare::CompareBinaryColumnToRow(\n+    uint32_t offset_within_row, uint32_t num_rows_to_compare,\n+    const uint16_t* sel_left_maybe_null, const uint32_t* left_to_right_map,\n+    KeyEncoder::KeyEncoderContext* ctx, const KeyEncoder::KeyColumnArray& col,\n+    const KeyEncoder::KeyRowArray& rows, uint8_t* match_bytevector) {\n+  uint32_t num_processed = 0;\n #if defined(ARROW_HAVE_AVX2)\n-  if (ctx->has_avx2() && !use_selection) {\n-    // Choose between up-to-8B length, up-to-16B length and any size versions\n-    if (fixed_length <= 8) {\n-      num_rows_already_processed = CompareFixedLength_UpTo8B_avx2(\n-          num_rows_to_compare, left_to_right_map, match_bytevector, fixed_length,\n-          rows_left, rows_right);\n-    } else if (fixed_length <= 16) {\n-      num_rows_already_processed = CompareFixedLength_UpTo16B_avx2(\n-          num_rows_to_compare, left_to_right_map, match_bytevector, fixed_length,\n-          rows_left, rows_right);\n-    } else {\n-      num_rows_already_processed =\n-          CompareFixedLength_avx2(num_rows_to_compare, left_to_right_map,\n-                                  match_bytevector, fixed_length, rows_left, rows_right);\n-    }\n+  if (ctx->has_avx2()) {\n+    num_processed = CompareBinaryColumnToRow_avx2(\n+        use_selection, offset_within_row, num_rows_to_compare, sel_left_maybe_null,\n+        left_to_right_map, ctx, col, rows, match_bytevector);\n   }\n #endif\n \n-  typedef void (*CompareFixedLengthImp_t)(uint32_t, uint32_t, const uint16_t*,\n-                                          const uint32_t*, uint8_t*, uint32_t,\n-                                          const uint8_t*, const uint8_t*);\n-  static const CompareFixedLengthImp_t CompareFixedLengthImp_fn[] = {\n-      CompareFixedLengthImp<false, 1>, CompareFixedLengthImp<false, 2>,\n-      CompareFixedLengthImp<false, 0>, CompareFixedLengthImp<true, 1>,\n-      CompareFixedLengthImp<true, 2>,  CompareFixedLengthImp<true, 0>};\n-  int dispatch_const = (use_selection ? 3 : 0) +\n-                       ((fixed_length <= 8) ? 0 : ((fixed_length <= 16) ? 1 : 2));\n-  CompareFixedLengthImp_fn[dispatch_const](\n-      num_rows_already_processed, num_rows_to_compare, sel_left_maybe_null,\n-      left_to_right_map, match_bytevector, fixed_length, rows_left, rows_right);\n-}\n+  uint32_t col_width = col.metadata().fixed_length;\n+  if (col_width == 0) {\n+    int bit_offset = col.bit_offset(1);\n+    CompareBinaryColumnToRowHelper<use_selection>(\n+        offset_within_row, num_processed, num_rows_to_compare, sel_left_maybe_null,\n+        left_to_right_map, ctx, col, rows, match_bytevector,\n+        [bit_offset](const uint8_t* left_base, const uint8_t* right_base,\n+                     uint32_t irow_left, uint32_t offset_right) {\n+          uint8_t left = BitUtil::GetBit(left_base, irow_left + bit_offset) ? 0xff : 0x00;\n+          uint8_t right = right_base[offset_right];\n+          return left == right ? 0xff : 0;\n+        });\n+  } else if (col_width == 1) {\n+    CompareBinaryColumnToRowHelper<use_selection>(\n+        offset_within_row, num_processed, num_rows_to_compare, sel_left_maybe_null,\n+        left_to_right_map, ctx, col, rows, match_bytevector,\n+        [](const uint8_t* left_base, const uint8_t* right_base, uint32_t irow_left,\n+           uint32_t offset_right) {\n+          uint8_t left = left_base[irow_left];\n+          uint8_t right = right_base[offset_right];\n+          return left == right ? 0xff : 0;\n+        });\n+  } else if (col_width == 2) {\n+    CompareBinaryColumnToRowHelper<use_selection>(\n+        offset_within_row, num_processed, num_rows_to_compare, sel_left_maybe_null,\n+        left_to_right_map, ctx, col, rows, match_bytevector,\n+        [](const uint8_t* left_base, const uint8_t* right_base, uint32_t irow_left,\n+           uint32_t offset_right) {\n+          uint16_t left = reinterpret_cast<const uint16_t*>(left_base)[irow_left];\n\nReview comment:\n       I added alignment checks when guaranteed and SafeLoads when not.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-13T03:01:22.385+0000",
                    "updated": "2021-08-13T03:01:22.385+0000",
                    "started": "2021-08-13T03:01:22.385+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637655",
                    "issueId": "13377672"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377672/worklog/637656",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "michalursa commented on a change in pull request #10290:\nURL: https://github.com/apache/arrow/pull/10290#discussion_r688212687\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/key_compare.cc\n##########\n@@ -17,250 +17,398 @@\n \n #include \"arrow/compute/exec/key_compare.h\"\n \n+#include <immintrin.h>\n+#include <memory.h>\n+\n #include <algorithm>\n #include <cstdint>\n \n #include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bit_util.h\"\n #include \"arrow/util/ubsan.h\"\n \n namespace arrow {\n namespace compute {\n \n-void KeyCompare::CompareRows(uint32_t num_rows_to_compare,\n-                             const uint16_t* sel_left_maybe_null,\n-                             const uint32_t* left_to_right_map,\n-                             KeyEncoder::KeyEncoderContext* ctx, uint32_t* out_num_rows,\n-                             uint16_t* out_sel_left_maybe_same,\n-                             const KeyEncoder::KeyRowArray& rows_left,\n-                             const KeyEncoder::KeyRowArray& rows_right) {\n-  ARROW_DCHECK(rows_left.metadata().is_compatible(rows_right.metadata()));\n-\n-  if (num_rows_to_compare == 0) {\n-    *out_num_rows = 0;\n+template <bool use_selection>\n+void KeyCompare::NullUpdateColumnToRow(uint32_t id_col, uint32_t num_rows_to_compare,\n+                                       const uint16_t* sel_left_maybe_null,\n+                                       const uint32_t* left_to_right_map,\n+                                       KeyEncoder::KeyEncoderContext* ctx,\n+                                       const KeyEncoder::KeyColumnArray& col,\n+                                       const KeyEncoder::KeyRowArray& rows,\n+                                       uint8_t* match_bytevector) {\n+  if (!rows.has_any_nulls(ctx) && !col.data(0)) {\n     return;\n   }\n-\n-  // Allocate temporary byte and bit vectors\n-  auto bytevector_holder =\n-      util::TempVectorHolder<uint8_t>(ctx->stack, num_rows_to_compare);\n-  auto bitvector_holder =\n-      util::TempVectorHolder<uint8_t>(ctx->stack, num_rows_to_compare);\n-\n-  uint8_t* match_bytevector = bytevector_holder.mutable_data();\n-  uint8_t* match_bitvector = bitvector_holder.mutable_data();\n-\n-  // All comparison functions called here will update match byte vector\n-  // (AND it with comparison result) instead of overwriting it.\n-  memset(match_bytevector, 0xff, num_rows_to_compare);\n-\n-  if (rows_left.metadata().is_fixed_length) {\n-    CompareFixedLength(num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n-                       match_bytevector, ctx, rows_left.metadata().fixed_length,\n-                       rows_left.data(1), rows_right.data(1));\n-  } else {\n-    CompareVaryingLength(num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n-                         match_bytevector, ctx, rows_left.data(2), rows_right.data(2),\n-                         rows_left.offsets(), rows_right.offsets());\n+  uint32_t num_processed = 0;\n+#if defined(ARROW_HAVE_AVX2)\n+  if (ctx->has_avx2()) {\n+    num_processed = NullUpdateColumnToRow_avx2(use_selection, id_col, num_rows_to_compare,\n+                                               sel_left_maybe_null, left_to_right_map,\n+                                               ctx, col, rows, match_bytevector);\n   }\n+#endif\n \n-  // CompareFixedLength can be used to compare nulls as well\n-  bool nulls_present = rows_left.has_any_nulls(ctx) || rows_right.has_any_nulls(ctx);\n-  if (nulls_present) {\n-    CompareFixedLength(num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n-                       match_bytevector, ctx,\n-                       rows_left.metadata().null_masks_bytes_per_row,\n-                       rows_left.null_masks(), rows_right.null_masks());\n+  if (!col.data(0)) {\n+    // Remove rows from the result for which the column value is a null\n+    const uint8_t* null_masks = rows.null_masks();\n+    uint32_t null_mask_num_bytes = rows.metadata().null_masks_bytes_per_row;\n+    for (uint32_t i = num_processed; i < num_rows_to_compare; ++i) {\n+      uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n+      uint32_t irow_right = left_to_right_map[irow_left];\n+      int64_t bitid = irow_right * null_mask_num_bytes * 8 + id_col;\n+      match_bytevector[i] &= (BitUtil::GetBit(null_masks, bitid) ? 0 : 0xff);\n+    }\n+  } else if (!rows.has_any_nulls(ctx)) {\n+    // Remove rows from the result for which the column value on left side is null\n+    const uint8_t* non_nulls = col.data(0);\n+    ARROW_DCHECK(non_nulls);\n+    for (uint32_t i = num_processed; i < num_rows_to_compare; ++i) {\n+      uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n+      match_bytevector[i] &=\n+          BitUtil::GetBit(non_nulls, irow_left + col.bit_offset(0)) ? 0xff : 0;\n+    }\n+  } else {\n+    const uint8_t* null_masks = rows.null_masks();\n+    uint32_t null_mask_num_bytes = rows.metadata().null_masks_bytes_per_row;\n+    const uint8_t* non_nulls = col.data(0);\n+    ARROW_DCHECK(non_nulls);\n+    for (uint32_t i = num_processed; i < num_rows_to_compare; ++i) {\n+      uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n+      uint32_t irow_right = left_to_right_map[irow_left];\n+      int64_t bitid_right = irow_right * null_mask_num_bytes * 8 + id_col;\n+      int right_null = BitUtil::GetBit(null_masks, bitid_right) ? 0xff : 0;\n+      int left_null =\n+          BitUtil::GetBit(non_nulls, irow_left + col.bit_offset(0)) ? 0 : 0xff;\n+      match_bytevector[i] |= left_null & right_null;\n+      match_bytevector[i] &= ~(left_null ^ right_null);\n+    }\n   }\n+}\n \n-  util::BitUtil::bytes_to_bits(ctx->hardware_flags, num_rows_to_compare, match_bytevector,\n-                               match_bitvector);\n-  if (sel_left_maybe_null) {\n-    int out_num_rows_int;\n-    util::BitUtil::bits_filter_indexes(0, ctx->hardware_flags, num_rows_to_compare,\n-                                       match_bitvector, sel_left_maybe_null,\n-                                       &out_num_rows_int, out_sel_left_maybe_same);\n-    *out_num_rows = out_num_rows_int;\n+template <bool use_selection, class COMPARE_FN>\n+void KeyCompare::CompareBinaryColumnToRowHelper(\n+    uint32_t offset_within_row, uint32_t first_row_to_compare,\n+    uint32_t num_rows_to_compare, const uint16_t* sel_left_maybe_null,\n+    const uint32_t* left_to_right_map, KeyEncoder::KeyEncoderContext* ctx,\n+    const KeyEncoder::KeyColumnArray& col, const KeyEncoder::KeyRowArray& rows,\n+    uint8_t* match_bytevector, COMPARE_FN compare_fn) {\n+  bool is_fixed_length = rows.metadata().is_fixed_length;\n+  if (is_fixed_length) {\n+    uint32_t fixed_length = rows.metadata().fixed_length;\n+    const uint8_t* rows_left = col.data(1);\n+    const uint8_t* rows_right = rows.data(1);\n+    for (uint32_t i = first_row_to_compare; i < num_rows_to_compare; ++i) {\n+      uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n+      uint32_t irow_right = left_to_right_map[irow_left];\n+      uint32_t offset_right = irow_right * fixed_length + offset_within_row;\n+      match_bytevector[i] = compare_fn(rows_left, rows_right, irow_left, offset_right);\n+    }\n   } else {\n-    int out_num_rows_int;\n-    util::BitUtil::bits_to_indexes(0, ctx->hardware_flags, num_rows_to_compare,\n-                                   match_bitvector, &out_num_rows_int,\n-                                   out_sel_left_maybe_same);\n-    *out_num_rows = out_num_rows_int;\n+    const uint8_t* rows_left = col.data(1);\n+    const uint32_t* offsets_right = rows.offsets();\n+    const uint8_t* rows_right = rows.data(2);\n+    for (uint32_t i = first_row_to_compare; i < num_rows_to_compare; ++i) {\n+      uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n+      uint32_t irow_right = left_to_right_map[irow_left];\n+      uint32_t offset_right = offsets_right[irow_right] + offset_within_row;\n+      match_bytevector[i] = compare_fn(rows_left, rows_right, irow_left, offset_right);\n+    }\n   }\n }\n \n-void KeyCompare::CompareFixedLength(uint32_t num_rows_to_compare,\n-                                    const uint16_t* sel_left_maybe_null,\n-                                    const uint32_t* left_to_right_map,\n-                                    uint8_t* match_bytevector,\n-                                    KeyEncoder::KeyEncoderContext* ctx,\n-                                    uint32_t fixed_length, const uint8_t* rows_left,\n-                                    const uint8_t* rows_right) {\n-  bool use_selection = (sel_left_maybe_null != nullptr);\n-\n-  uint32_t num_rows_already_processed = 0;\n-\n+template <bool use_selection>\n+void KeyCompare::CompareBinaryColumnToRow(\n+    uint32_t offset_within_row, uint32_t num_rows_to_compare,\n+    const uint16_t* sel_left_maybe_null, const uint32_t* left_to_right_map,\n+    KeyEncoder::KeyEncoderContext* ctx, const KeyEncoder::KeyColumnArray& col,\n+    const KeyEncoder::KeyRowArray& rows, uint8_t* match_bytevector) {\n+  uint32_t num_processed = 0;\n #if defined(ARROW_HAVE_AVX2)\n-  if (ctx->has_avx2() && !use_selection) {\n-    // Choose between up-to-8B length, up-to-16B length and any size versions\n-    if (fixed_length <= 8) {\n-      num_rows_already_processed = CompareFixedLength_UpTo8B_avx2(\n-          num_rows_to_compare, left_to_right_map, match_bytevector, fixed_length,\n-          rows_left, rows_right);\n-    } else if (fixed_length <= 16) {\n-      num_rows_already_processed = CompareFixedLength_UpTo16B_avx2(\n-          num_rows_to_compare, left_to_right_map, match_bytevector, fixed_length,\n-          rows_left, rows_right);\n-    } else {\n-      num_rows_already_processed =\n-          CompareFixedLength_avx2(num_rows_to_compare, left_to_right_map,\n-                                  match_bytevector, fixed_length, rows_left, rows_right);\n-    }\n+  if (ctx->has_avx2()) {\n+    num_processed = CompareBinaryColumnToRow_avx2(\n+        use_selection, offset_within_row, num_rows_to_compare, sel_left_maybe_null,\n+        left_to_right_map, ctx, col, rows, match_bytevector);\n   }\n #endif\n \n-  typedef void (*CompareFixedLengthImp_t)(uint32_t, uint32_t, const uint16_t*,\n-                                          const uint32_t*, uint8_t*, uint32_t,\n-                                          const uint8_t*, const uint8_t*);\n-  static const CompareFixedLengthImp_t CompareFixedLengthImp_fn[] = {\n-      CompareFixedLengthImp<false, 1>, CompareFixedLengthImp<false, 2>,\n-      CompareFixedLengthImp<false, 0>, CompareFixedLengthImp<true, 1>,\n-      CompareFixedLengthImp<true, 2>,  CompareFixedLengthImp<true, 0>};\n-  int dispatch_const = (use_selection ? 3 : 0) +\n-                       ((fixed_length <= 8) ? 0 : ((fixed_length <= 16) ? 1 : 2));\n-  CompareFixedLengthImp_fn[dispatch_const](\n-      num_rows_already_processed, num_rows_to_compare, sel_left_maybe_null,\n-      left_to_right_map, match_bytevector, fixed_length, rows_left, rows_right);\n-}\n+  uint32_t col_width = col.metadata().fixed_length;\n+  if (col_width == 0) {\n+    int bit_offset = col.bit_offset(1);\n+    CompareBinaryColumnToRowHelper<use_selection>(\n+        offset_within_row, num_processed, num_rows_to_compare, sel_left_maybe_null,\n+        left_to_right_map, ctx, col, rows, match_bytevector,\n+        [bit_offset](const uint8_t* left_base, const uint8_t* right_base,\n+                     uint32_t irow_left, uint32_t offset_right) {\n+          uint8_t left = BitUtil::GetBit(left_base, irow_left + bit_offset) ? 0xff : 0x00;\n+          uint8_t right = right_base[offset_right];\n+          return left == right ? 0xff : 0;\n+        });\n+  } else if (col_width == 1) {\n+    CompareBinaryColumnToRowHelper<use_selection>(\n+        offset_within_row, num_processed, num_rows_to_compare, sel_left_maybe_null,\n+        left_to_right_map, ctx, col, rows, match_bytevector,\n+        [](const uint8_t* left_base, const uint8_t* right_base, uint32_t irow_left,\n+           uint32_t offset_right) {\n+          uint8_t left = left_base[irow_left];\n+          uint8_t right = right_base[offset_right];\n+          return left == right ? 0xff : 0;\n+        });\n+  } else if (col_width == 2) {\n+    CompareBinaryColumnToRowHelper<use_selection>(\n+        offset_within_row, num_processed, num_rows_to_compare, sel_left_maybe_null,\n+        left_to_right_map, ctx, col, rows, match_bytevector,\n+        [](const uint8_t* left_base, const uint8_t* right_base, uint32_t irow_left,\n+           uint32_t offset_right) {\n+          uint16_t left = reinterpret_cast<const uint16_t*>(left_base)[irow_left];\n+          uint16_t right = *reinterpret_cast<const uint16_t*>(right_base + offset_right);\n+          return left == right ? 0xff : 0;\n+        });\n+  } else if (col_width == 4) {\n+    CompareBinaryColumnToRowHelper<use_selection>(\n+        offset_within_row, num_processed, num_rows_to_compare, sel_left_maybe_null,\n+        left_to_right_map, ctx, col, rows, match_bytevector,\n+        [](const uint8_t* left_base, const uint8_t* right_base, uint32_t irow_left,\n+           uint32_t offset_right) {\n+          uint32_t left = reinterpret_cast<const uint32_t*>(left_base)[irow_left];\n+          uint32_t right = *reinterpret_cast<const uint32_t*>(right_base + offset_right);\n+          return left == right ? 0xff : 0;\n+        });\n+  } else if (col_width == 8) {\n+    CompareBinaryColumnToRowHelper<use_selection>(\n+        offset_within_row, num_processed, num_rows_to_compare, sel_left_maybe_null,\n+        left_to_right_map, ctx, col, rows, match_bytevector,\n+        [](const uint8_t* left_base, const uint8_t* right_base, uint32_t irow_left,\n+           uint32_t offset_right) {\n+          uint64_t left = reinterpret_cast<const uint64_t*>(left_base)[irow_left];\n+          uint64_t right = *reinterpret_cast<const uint64_t*>(right_base + offset_right);\n+          return left == right ? 0xff : 0;\n+        });\n+  } else {\n+    CompareBinaryColumnToRowHelper<use_selection>(\n+        offset_within_row, num_processed, num_rows_to_compare, sel_left_maybe_null,\n+        left_to_right_map, ctx, col, rows, match_bytevector,\n+        [&col](const uint8_t* left_base, const uint8_t* right_base, uint32_t irow_left,\n+               uint32_t offset_right) {\n+          uint32_t length = col.metadata().fixed_length;\n \n-template <bool use_selection, int num_64bit_words>\n-void KeyCompare::CompareFixedLengthImp(uint32_t num_rows_already_processed,\n-                                       uint32_t num_rows,\n-                                       const uint16_t* sel_left_maybe_null,\n-                                       const uint32_t* left_to_right_map,\n-                                       uint8_t* match_bytevector, uint32_t length,\n-                                       const uint8_t* rows_left,\n-                                       const uint8_t* rows_right) {\n-  // Key length (for encoded key) has to be non-zero\n-  ARROW_DCHECK(length > 0);\n+          // Non-zero length guarantees no underflow\n+          int32_t num_loops_less_one = (static_cast<int32_t>(length) + 7) / 8 - 1;\n+\n+          uint64_t tail_mask = ~0ULL >> (64 - 8 * (length - num_loops_less_one * 8));\n \n-  // Non-zero length guarantees no underflow\n-  int32_t num_loops_less_one = (static_cast<int32_t>(length) + 7) / 8 - 1;\n+          const uint64_t* key_left_ptr =\n+              reinterpret_cast<const uint64_t*>(left_base + irow_left * length);\n+          const uint64_t* key_right_ptr =\n+              reinterpret_cast<const uint64_t*>(right_base + offset_right);\n+          uint64_t result_or = 0;\n+          int32_t i;\n+          // length cannot be zero\n+          for (i = 0; i < num_loops_less_one; ++i) {\n+            uint64_t key_left = key_left_ptr[i];\n+            uint64_t key_right = key_right_ptr[i];\n+            result_or |= key_left ^ key_right;\n+          }\n+          uint64_t key_left = key_left_ptr[i];\n+          uint64_t key_right = key_right_ptr[i];\n+          result_or |= tail_mask & (key_left ^ key_right);\n+          return result_or == 0 ? 0xff : 0;\n+        });\n+  }\n+}\n \n-  // Length remaining in last loop can only be zero for input length equal to zero\n-  uint32_t length_remaining_last_loop = length - num_loops_less_one * 8;\n-  uint64_t tail_mask = (~0ULL) >> (8 * (8 - length_remaining_last_loop));\n+// Overwrites the match_bytevector instead of updating it\n+template <bool use_selection, bool is_first_varbinary_col>\n+void KeyCompare::CompareVarBinaryColumnToRow(\n+    uint32_t id_varbinary_col, uint32_t num_rows_to_compare,\n+    const uint16_t* sel_left_maybe_null, const uint32_t* left_to_right_map,\n+    KeyEncoder::KeyEncoderContext* ctx, const KeyEncoder::KeyColumnArray& col,\n+    const KeyEncoder::KeyRowArray& rows, uint8_t* match_bytevector) {\n+#if defined(ARROW_HAVE_AVX2)\n+  if (ctx->has_avx2()) {\n+    CompareVarBinaryColumnToRow_avx2(\n+        use_selection, is_first_varbinary_col, id_varbinary_col, num_rows_to_compare,\n+        sel_left_maybe_null, left_to_right_map, ctx, col, rows, match_bytevector);\n+    return;\n+  }\n+#endif\n \n-  for (uint32_t id_input = num_rows_already_processed; id_input < num_rows; ++id_input) {\n-    uint32_t irow_left = use_selection ? sel_left_maybe_null[id_input] : id_input;\n+  const uint32_t* offsets_left = col.offsets();\n+  const uint32_t* offsets_right = rows.offsets();\n+  const uint8_t* rows_left = col.data(2);\n+  const uint8_t* rows_right = rows.data(2);\n+  for (uint32_t i = 0; i < num_rows_to_compare; ++i) {\n+    uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n     uint32_t irow_right = left_to_right_map[irow_left];\n-    uint32_t begin_left = length * irow_left;\n-    uint32_t begin_right = length * irow_right;\n+    uint32_t begin_left = offsets_left[irow_left];\n+    uint32_t length_left = offsets_left[irow_left + 1] - begin_left;\n+    uint32_t begin_right = offsets_right[irow_right];\n+    uint32_t length_right;\n+    uint32_t offset_within_row;\n+    if (!is_first_varbinary_col) {\n+      rows.metadata().nth_varbinary_offset_and_length(\n+          rows_right + begin_right, id_varbinary_col, &offset_within_row, &length_right);\n+    } else {\n+      rows.metadata().first_varbinary_offset_and_length(\n+          rows_right + begin_right, &offset_within_row, &length_right);\n+    }\n+    begin_right += offset_within_row;\n+    uint32_t length = std::min(length_left, length_right);\n     const uint64_t* key_left_ptr =\n         reinterpret_cast<const uint64_t*>(rows_left + begin_left);\n     const uint64_t* key_right_ptr =\n         reinterpret_cast<const uint64_t*>(rows_right + begin_right);\n-    uint64_t result_or = 0ULL;\n-    int32_t istripe = 0;\n-\n-    // Specializations for keys up to 8 bytes and between 9 and 16 bytes to\n-    // avoid internal loop over words in the value for short ones.\n-    //\n-    // Template argument 0 means arbitrarily many 64-bit words,\n-    // 1 means up to 1 and 2 means up to 2.\n-    //\n-    if (num_64bit_words == 0) {\n-      for (; istripe < num_loops_less_one; ++istripe) {\n-        uint64_t key_left = util::SafeLoad(&key_left_ptr[istripe]);\n-        uint64_t key_right = util::SafeLoad(&key_right_ptr[istripe]);\n-        result_or |= (key_left ^ key_right);\n+    uint64_t result_or = 0;\n+    if (length > 0) {\n+      int32_t j;\n+      // length can be zero\n+      for (j = 0; j < (static_cast<int32_t>(length) + 7) / 8 - 1; ++j) {\n\nReview comment:\n       done\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-13T03:06:31.437+0000",
                    "updated": "2021-08-13T03:06:31.437+0000",
                    "started": "2021-08-13T03:06:31.437+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637656",
                    "issueId": "13377672"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377672/worklog/637662",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "michalursa commented on a change in pull request #10290:\nURL: https://github.com/apache/arrow/pull/10290#discussion_r688215346\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/key_compare_avx2.cc\n##########\n@@ -25,160 +25,545 @@ namespace compute {\n \n #if defined(ARROW_HAVE_AVX2)\n \n-uint32_t KeyCompare::CompareFixedLength_UpTo8B_avx2(\n-    uint32_t num_rows, const uint32_t* left_to_right_map, uint8_t* match_bytevector,\n-    uint32_t length, const uint8_t* rows_left, const uint8_t* rows_right) {\n-  ARROW_DCHECK(length <= 8);\n-  __m256i offset_left = _mm256_setr_epi64x(0, length, length * 2, length * 3);\n-  __m256i offset_left_incr = _mm256_set1_epi64x(length * 4);\n-  __m256i mask = _mm256_set1_epi64x(~0ULL >> (8 * (8 - length)));\n-\n-  constexpr uint32_t unroll = 4;\n-  for (uint32_t i = 0; i < num_rows / unroll; ++i) {\n-    auto key_left = _mm256_i64gather_epi64(\n-        reinterpret_cast<arrow::util::int64_for_gather_t*>(rows_left), offset_left, 1);\n-    offset_left = _mm256_add_epi64(offset_left, offset_left_incr);\n-    __m128i offset_right =\n-        _mm_loadu_si128(reinterpret_cast<const __m128i*>(left_to_right_map) + i);\n-    offset_right = _mm_mullo_epi32(offset_right, _mm_set1_epi32(length));\n-\n-    auto key_right = _mm256_i32gather_epi64(\n-        reinterpret_cast<arrow::util::int64_for_gather_t*>(rows_right), offset_right, 1);\n-    uint32_t cmp = _mm256_movemask_epi8(_mm256_cmpeq_epi64(\n-        _mm256_and_si256(key_left, mask), _mm256_and_si256(key_right, mask)));\n-    reinterpret_cast<uint32_t*>(match_bytevector)[i] &= cmp;\n+template <bool use_selection>\n+uint32_t KeyCompare::NullUpdateColumnToRowImp_avx2(\n+    uint32_t id_col, uint32_t num_rows_to_compare, const uint16_t* sel_left_maybe_null,\n+    const uint32_t* left_to_right_map, KeyEncoder::KeyEncoderContext* ctx,\n+    const KeyEncoder::KeyColumnArray& col, const KeyEncoder::KeyRowArray& rows,\n+    uint8_t* match_bytevector) {\n+  if (!rows.has_any_nulls(ctx) && !col.data(0)) {\n+    return num_rows_to_compare;\n   }\n+  if (!col.data(0)) {\n+    // Remove rows from the result for which the column value is a null\n+    const uint8_t* null_masks = rows.null_masks();\n+    uint32_t null_mask_num_bytes = rows.metadata().null_masks_bytes_per_row;\n \n-  uint32_t num_rows_processed = num_rows - (num_rows % unroll);\n-  return num_rows_processed;\n-}\n+    uint32_t num_processed = 0;\n+    constexpr uint32_t unroll = 8;\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      __m256i irow_right;\n+      if (use_selection) {\n+        __m256i irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+        irow_right = _mm256_i32gather_epi32((const int*)left_to_right_map, irow_left, 4);\n+      } else {\n+        irow_right =\n+            _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_to_right_map) + i);\n+      }\n+      __m256i bitid =\n+          _mm256_mullo_epi32(irow_right, _mm256_set1_epi32(null_mask_num_bytes * 8));\n+      bitid = _mm256_add_epi32(bitid, _mm256_set1_epi32(id_col));\n+      __m256i right =\n+          _mm256_i32gather_epi32((const int*)null_masks, _mm256_srli_epi32(bitid, 3), 1);\n+      right = _mm256_and_si256(\n+          _mm256_set1_epi32(1),\n+          _mm256_srlv_epi32(right, _mm256_and_si256(bitid, _mm256_set1_epi32(7))));\n+      __m256i cmp = _mm256_cmpeq_epi32(right, _mm256_setzero_si256());\n+      uint32_t result_lo =\n+          _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_castsi256_si128(cmp)));\n+      uint32_t result_hi =\n+          _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_extracti128_si256(cmp, 1)));\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] &=\n+          result_lo | (static_cast<uint64_t>(result_hi) << 32);\n+    }\n+    num_processed = num_rows_to_compare / unroll * unroll;\n+    return num_processed;\n+  } else if (!rows.has_any_nulls(ctx)) {\n+    // Remove rows from the result for which the column value on left side is null\n+    const uint8_t* non_nulls = col.data(0);\n+    ARROW_DCHECK(non_nulls);\n+    uint32_t num_processed = 0;\n+    constexpr uint32_t unroll = 8;\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      __m256i cmp;\n+      if (use_selection) {\n+        __m256i irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+        irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(col.bit_offset(0)));\n+        __m256i left = _mm256_i32gather_epi32((const int*)non_nulls,\n+                                              _mm256_srli_epi32(irow_left, 3), 1);\n+        left = _mm256_and_si256(\n+            _mm256_set1_epi32(1),\n+            _mm256_srlv_epi32(left, _mm256_and_si256(irow_left, _mm256_set1_epi32(7))));\n+        cmp = _mm256_cmpeq_epi32(left, _mm256_set1_epi32(1));\n+      } else {\n+        __m256i left = _mm256_cvtepu8_epi32(_mm_set1_epi8(static_cast<uint8_t>(\n+            reinterpret_cast<const uint16_t*>(non_nulls + i)[0] >> col.bit_offset(0))));\n+        __m256i bits = _mm256_setr_epi32(1, 2, 4, 8, 16, 32, 64, 128);\n+        cmp = _mm256_cmpeq_epi32(_mm256_and_si256(left, bits), bits);\n+      }\n+      uint32_t result_lo =\n+          _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_castsi256_si128(cmp)));\n+      uint32_t result_hi =\n+          _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_extracti128_si256(cmp, 1)));\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] &=\n+          result_lo | (static_cast<uint64_t>(result_hi) << 32);\n+      num_processed = num_rows_to_compare / unroll * unroll;\n+    }\n+    return num_processed;\n+  } else {\n+    const uint8_t* null_masks = rows.null_masks();\n+    uint32_t null_mask_num_bytes = rows.metadata().null_masks_bytes_per_row;\n+    const uint8_t* non_nulls = col.data(0);\n+    ARROW_DCHECK(non_nulls);\n \n-uint32_t KeyCompare::CompareFixedLength_UpTo16B_avx2(\n-    uint32_t num_rows, const uint32_t* left_to_right_map, uint8_t* match_bytevector,\n-    uint32_t length, const uint8_t* rows_left, const uint8_t* rows_right) {\n-  ARROW_DCHECK(length <= 16);\n-\n-  constexpr uint64_t kByteSequence0To7 = 0x0706050403020100ULL;\n-  constexpr uint64_t kByteSequence8To15 = 0x0f0e0d0c0b0a0908ULL;\n-\n-  __m256i mask =\n-      _mm256_cmpgt_epi8(_mm256_set1_epi8(length),\n-                        _mm256_setr_epi64x(kByteSequence0To7, kByteSequence8To15,\n-                                           kByteSequence0To7, kByteSequence8To15));\n-  const uint8_t* key_left_ptr = rows_left;\n-\n-  constexpr uint32_t unroll = 2;\n-  for (uint32_t i = 0; i < num_rows / unroll; ++i) {\n-    auto key_left = _mm256_inserti128_si256(\n-        _mm256_castsi128_si256(\n-            _mm_loadu_si128(reinterpret_cast<const __m128i*>(key_left_ptr))),\n-        _mm_loadu_si128(reinterpret_cast<const __m128i*>(key_left_ptr + length)), 1);\n-    key_left_ptr += length * 2;\n-    auto key_right = _mm256_inserti128_si256(\n-        _mm256_castsi128_si256(_mm_loadu_si128(reinterpret_cast<const __m128i*>(\n-            rows_right + length * left_to_right_map[2 * i]))),\n-        _mm_loadu_si128(reinterpret_cast<const __m128i*>(\n-            rows_right + length * left_to_right_map[2 * i + 1])),\n-        1);\n-    __m256i cmp = _mm256_cmpeq_epi64(_mm256_and_si256(key_left, mask),\n-                                     _mm256_and_si256(key_right, mask));\n-    cmp = _mm256_and_si256(cmp, _mm256_shuffle_epi32(cmp, 0xee));  // 0b11101110\n-    cmp = _mm256_permute4x64_epi64(cmp, 0x08);                     // 0b00001000\n-    reinterpret_cast<uint16_t*>(match_bytevector)[i] &=\n-        (_mm256_movemask_epi8(cmp) & 0xffff);\n-  }\n+    uint32_t num_processed = 0;\n+    constexpr uint32_t unroll = 8;\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      __m256i left_null;\n+      __m256i irow_right;\n+      if (use_selection) {\n+        __m256i irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+        irow_right = _mm256_i32gather_epi32((const int*)left_to_right_map, irow_left, 4);\n+        irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(col.bit_offset(0)));\n+        __m256i left = _mm256_i32gather_epi32((const int*)non_nulls,\n+                                              _mm256_srli_epi32(irow_left, 3), 1);\n+        left = _mm256_and_si256(\n+            _mm256_set1_epi32(1),\n+            _mm256_srlv_epi32(left, _mm256_and_si256(irow_left, _mm256_set1_epi32(7))));\n+        left_null = _mm256_cmpeq_epi32(left, _mm256_setzero_si256());\n+      } else {\n+        irow_right =\n+            _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_to_right_map) + i);\n+        __m256i left = _mm256_cvtepu8_epi32(_mm_set1_epi8(static_cast<uint8_t>(\n+            reinterpret_cast<const uint16_t*>(non_nulls + i)[0] >> col.bit_offset(0))));\n+        __m256i bits = _mm256_setr_epi32(1, 2, 4, 8, 16, 32, 64, 128);\n+        left_null =\n+            _mm256_cmpeq_epi32(_mm256_and_si256(left, bits), _mm256_setzero_si256());\n+      }\n+      __m256i bitid =\n+          _mm256_mullo_epi32(irow_right, _mm256_set1_epi32(null_mask_num_bytes * 8));\n+      bitid = _mm256_add_epi32(bitid, _mm256_set1_epi32(id_col));\n+      __m256i right =\n+          _mm256_i32gather_epi32((const int*)null_masks, _mm256_srli_epi32(bitid, 3), 1);\n+      right = _mm256_and_si256(\n+          _mm256_set1_epi32(1),\n+          _mm256_srlv_epi32(right, _mm256_and_si256(bitid, _mm256_set1_epi32(7))));\n+      __m256i right_null = _mm256_cmpeq_epi32(right, _mm256_set1_epi32(1));\n \n-  uint32_t num_rows_processed = num_rows - (num_rows % unroll);\n-  return num_rows_processed;\n-}\n+      uint64_t left_null_64 =\n+          static_cast<uint32_t>(_mm256_movemask_epi8(\n+              _mm256_cvtepi32_epi64(_mm256_castsi256_si128(left_null)))) |\n+          (static_cast<uint64_t>(static_cast<uint32_t>(_mm256_movemask_epi8(\n+               _mm256_cvtepi32_epi64(_mm256_extracti128_si256(left_null, 1)))))\n+           << 32);\n \n-uint32_t KeyCompare::CompareFixedLength_avx2(uint32_t num_rows,\n-                                             const uint32_t* left_to_right_map,\n-                                             uint8_t* match_bytevector, uint32_t length,\n-                                             const uint8_t* rows_left,\n-                                             const uint8_t* rows_right) {\n-  ARROW_DCHECK(length > 0);\n+      uint64_t right_null_64 =\n+          static_cast<uint32_t>(_mm256_movemask_epi8(\n+              _mm256_cvtepi32_epi64(_mm256_castsi256_si128(right_null)))) |\n+          (static_cast<uint64_t>(static_cast<uint32_t>(_mm256_movemask_epi8(\n+               _mm256_cvtepi32_epi64(_mm256_extracti128_si256(right_null, 1)))))\n+           << 32);\n \n-  constexpr uint64_t kByteSequence0To7 = 0x0706050403020100ULL;\n-  constexpr uint64_t kByteSequence8To15 = 0x0f0e0d0c0b0a0908ULL;\n-  constexpr uint64_t kByteSequence16To23 = 0x1716151413121110ULL;\n-  constexpr uint64_t kByteSequence24To31 = 0x1f1e1d1c1b1a1918ULL;\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] |= left_null_64 & right_null_64;\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] &= ~(left_null_64 ^ right_null_64);\n+    }\n+    num_processed = num_rows_to_compare / unroll * unroll;\n+    return num_processed;\n+  }\n+}\n \n-  // Non-zero length guarantees no underflow\n-  int32_t num_loops_less_one = (static_cast<int32_t>(length) + 31) / 32 - 1;\n+template <bool use_selection, class COMPARE8_FN>\n+uint32_t KeyCompare::CompareBinaryColumnToRowHelper_avx2(\n+    uint32_t offset_within_row, uint32_t num_rows_to_compare,\n+    const uint16_t* sel_left_maybe_null, const uint32_t* left_to_right_map,\n+    KeyEncoder::KeyEncoderContext* ctx, const KeyEncoder::KeyColumnArray& col,\n+    const KeyEncoder::KeyRowArray& rows, uint8_t* match_bytevector,\n+    COMPARE8_FN compare8_fn) {\n+  bool is_fixed_length = rows.metadata().is_fixed_length;\n+  if (is_fixed_length) {\n+    uint32_t fixed_length = rows.metadata().fixed_length;\n+    const uint8_t* rows_left = col.data(1);\n+    const uint8_t* rows_right = rows.data(1);\n+    constexpr uint32_t unroll = 8;\n+    __m256i irow_left = _mm256_setr_epi32(0, 1, 2, 3, 4, 5, 6, 7);\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      if (use_selection) {\n+        irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+      }\n+      __m256i irow_right;\n+      if (use_selection) {\n+        irow_right = _mm256_i32gather_epi32((const int*)left_to_right_map, irow_left, 4);\n+      } else {\n+        irow_right =\n+            _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_to_right_map) + i);\n+      }\n \n-  __m256i tail_mask =\n-      _mm256_cmpgt_epi8(_mm256_set1_epi8(length - num_loops_less_one * 32),\n-                        _mm256_setr_epi64x(kByteSequence0To7, kByteSequence8To15,\n-                                           kByteSequence16To23, kByteSequence24To31));\n+      __m256i offset_right =\n+          _mm256_mullo_epi32(irow_right, _mm256_set1_epi32(fixed_length));\n+      offset_right = _mm256_add_epi32(offset_right, _mm256_set1_epi32(offset_within_row));\n \n-  for (uint32_t irow_left = 0; irow_left < num_rows; ++irow_left) {\n-    uint32_t irow_right = left_to_right_map[irow_left];\n-    uint32_t begin_left = length * irow_left;\n-    uint32_t begin_right = length * irow_right;\n-    const __m256i* key_left_ptr =\n-        reinterpret_cast<const __m256i*>(rows_left + begin_left);\n-    const __m256i* key_right_ptr =\n-        reinterpret_cast<const __m256i*>(rows_right + begin_right);\n-    __m256i result_or = _mm256_setzero_si256();\n-    int32_t i;\n-    // length cannot be zero\n-    for (i = 0; i < num_loops_less_one; ++i) {\n-      __m256i key_left = _mm256_loadu_si256(key_left_ptr + i);\n-      __m256i key_right = _mm256_loadu_si256(key_right_ptr + i);\n-      result_or = _mm256_or_si256(result_or, _mm256_xor_si256(key_left, key_right));\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] =\n+          compare8_fn(rows_left, rows_right, i * unroll, irow_left, offset_right);\n+\n+      if (!use_selection) {\n+        irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(8));\n+      }\n     }\n+    return num_rows_to_compare - (num_rows_to_compare % unroll);\n+  } else {\n+    const uint8_t* rows_left = col.data(1);\n+    const uint32_t* offsets_right = rows.offsets();\n+    const uint8_t* rows_right = rows.data(2);\n+    constexpr uint32_t unroll = 8;\n+    __m256i irow_left = _mm256_setr_epi32(0, 1, 2, 3, 4, 5, 6, 7);\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      if (use_selection) {\n+        irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+      }\n+      __m256i irow_right;\n+      if (use_selection) {\n+        irow_right = _mm256_i32gather_epi32((const int*)left_to_right_map, irow_left, 4);\n+      } else {\n+        irow_right =\n+            _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_to_right_map) + i);\n+      }\n+      __m256i offset_right =\n+          _mm256_i32gather_epi32((const int*)offsets_right, irow_right, 4);\n+      offset_right = _mm256_add_epi32(offset_right, _mm256_set1_epi32(offset_within_row));\n \n-    __m256i key_left = _mm256_loadu_si256(key_left_ptr + i);\n-    __m256i key_right = _mm256_loadu_si256(key_right_ptr + i);\n-    result_or = _mm256_or_si256(\n-        result_or, _mm256_and_si256(tail_mask, _mm256_xor_si256(key_left, key_right)));\n-    int result = _mm256_testz_si256(result_or, result_or) * 0xff;\n-    match_bytevector[irow_left] &= result;\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] =\n+          compare8_fn(rows_left, rows_right, i * unroll, irow_left, offset_right);\n+\n+      if (!use_selection) {\n+        irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(8));\n+      }\n+    }\n+    return num_rows_to_compare - (num_rows_to_compare % unroll);\n   }\n+}\n \n-  uint32_t num_rows_processed = num_rows;\n-  return num_rows_processed;\n+template <bool use_selection>\n+uint32_t KeyCompare::CompareBinaryColumnToRowImp_avx2(\n+    uint32_t offset_within_row, uint32_t num_rows_to_compare,\n+    const uint16_t* sel_left_maybe_null, const uint32_t* left_to_right_map,\n+    KeyEncoder::KeyEncoderContext* ctx, const KeyEncoder::KeyColumnArray& col,\n+    const KeyEncoder::KeyRowArray& rows, uint8_t* match_bytevector) {\n+  uint32_t col_width = col.metadata().fixed_length;\n+  if (col_width == 0) {\n+    int bit_offset = col.bit_offset(1);\n+    return CompareBinaryColumnToRowHelper_avx2<use_selection>(\n+        offset_within_row, num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n+        ctx, col, rows, match_bytevector,\n+        [bit_offset](const uint8_t* left_base, const uint8_t* right_base,\n+                     uint32_t irow_left_base, __m256i irow_left, __m256i offset_right) {\n+          __m256i left;\n+          if (use_selection) {\n+            irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(bit_offset));\n+            left = _mm256_i32gather_epi32((const int*)left_base,\n+                                          _mm256_srli_epi32(irow_left, 3), 1);\n+            left = _mm256_and_si256(\n+                _mm256_set1_epi32(1),\n+                _mm256_srlv_epi32(left,\n+                                  _mm256_and_si256(irow_left, _mm256_set1_epi32(7))));\n+            left = _mm256_mullo_epi32(left, _mm256_set1_epi32(0xff));\n+          } else {\n+            __m256i bits = _mm256_setr_epi32(1, 2, 4, 8, 16, 32, 64, 128);\n+            uint32_t start_bit_index = irow_left_base + bit_offset;\n+            uint8_t left_bits_8 =\n+                (reinterpret_cast<const uint16_t*>(left_base + start_bit_index / 8)[0] >>\n+                 (start_bit_index % 8)) &\n+                0xff;\n+            left = _mm256_cmpeq_epi32(\n+                _mm256_and_si256(bits, _mm256_set1_epi8(left_bits_8)), bits);\n+            left = _mm256_and_si256(left, _mm256_set1_epi32(0xff));\n+          }\n+          __m256i right = _mm256_i32gather_epi32((const int*)right_base, offset_right, 1);\n+          right = _mm256_and_si256(right, _mm256_set1_epi32(0xff));\n+          __m256i cmp = _mm256_cmpeq_epi32(left, right);\n+          uint32_t result_lo =\n+              _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_castsi256_si128(cmp)));\n+          uint32_t result_hi = _mm256_movemask_epi8(\n+              _mm256_cvtepi32_epi64(_mm256_extracti128_si256(cmp, 1)));\n+          return result_lo | (static_cast<uint64_t>(result_hi) << 32);\n+        });\n+  } else if (col_width == 1) {\n+    return CompareBinaryColumnToRowHelper_avx2<use_selection>(\n+        offset_within_row, num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n+        ctx, col, rows, match_bytevector,\n+        [](const uint8_t* left_base, const uint8_t* right_base, uint32_t irow_left_base,\n+           __m256i irow_left, __m256i offset_right) {\n+          __m256i left;\n+          if (use_selection) {\n+            left = _mm256_i32gather_epi32((const int*)left_base, irow_left, 1);\n+            left = _mm256_and_si256(left, _mm256_set1_epi32(0xff));\n+          } else {\n+            left = _mm256_cvtepu8_epi32(_mm_set1_epi64x(\n+                reinterpret_cast<const uint64_t*>(left_base)[irow_left_base / 8]));\n+          }\n+          __m256i right = _mm256_i32gather_epi32((const int*)right_base, offset_right, 1);\n+          right = _mm256_and_si256(right, _mm256_set1_epi32(0xff));\n+          __m256i cmp = _mm256_cmpeq_epi32(left, right);\n+          uint32_t result_lo =\n+              _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_castsi256_si128(cmp)));\n+          uint32_t result_hi = _mm256_movemask_epi8(\n+              _mm256_cvtepi32_epi64(_mm256_extracti128_si256(cmp, 1)));\n+          return result_lo | (static_cast<uint64_t>(result_hi) << 32);\n+        });\n+  } else if (col_width == 2) {\n+    return CompareBinaryColumnToRowHelper_avx2<use_selection>(\n+        offset_within_row, num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n+        ctx, col, rows, match_bytevector,\n+        [](const uint8_t* left_base, const uint8_t* right_base, uint32_t irow_left_base,\n+           __m256i irow_left, __m256i offset_right) {\n+          __m256i left;\n+          if (use_selection) {\n+            left = _mm256_i32gather_epi32((const int*)left_base, irow_left, 2);\n+            left = _mm256_and_si256(left, _mm256_set1_epi32(0xffff));\n+          } else {\n+            left = _mm256_cvtepu16_epi32(_mm_loadu_si128(\n+                reinterpret_cast<const __m128i*>(left_base) + irow_left_base / 8));\n+          }\n+          __m256i right = _mm256_i32gather_epi32((const int*)right_base, offset_right, 1);\n+          right = _mm256_and_si256(right, _mm256_set1_epi32(0xffff));\n+          __m256i cmp = _mm256_cmpeq_epi32(left, right);\n+          uint32_t result_lo =\n+              _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_castsi256_si128(cmp)));\n+          uint32_t result_hi = _mm256_movemask_epi8(\n+              _mm256_cvtepi32_epi64(_mm256_extracti128_si256(cmp, 1)));\n+          return result_lo | (static_cast<uint64_t>(result_hi) << 32);\n+        });\n+  } else if (col_width == 4) {\n+    return CompareBinaryColumnToRowHelper_avx2<use_selection>(\n+        offset_within_row, num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n+        ctx, col, rows, match_bytevector,\n+        [](const uint8_t* left_base, const uint8_t* right_base, uint32_t irow_left_base,\n+           __m256i irow_left, __m256i offset_right) {\n+          __m256i left;\n+          if (use_selection) {\n+            left = _mm256_i32gather_epi32((const int*)left_base, irow_left, 4);\n+          } else {\n+            left = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_base) +\n+                                      irow_left_base / 8);\n+          }\n+          __m256i right = _mm256_i32gather_epi32((const int*)right_base, offset_right, 1);\n+          __m256i cmp = _mm256_cmpeq_epi32(left, right);\n+          uint32_t result_lo =\n+              _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_castsi256_si128(cmp)));\n+          uint32_t result_hi = _mm256_movemask_epi8(\n+              _mm256_cvtepi32_epi64(_mm256_extracti128_si256(cmp, 1)));\n+          return result_lo | (static_cast<uint64_t>(result_hi) << 32);\n+        });\n+  } else if (col_width == 8) {\n+    return CompareBinaryColumnToRowHelper_avx2<use_selection>(\n+        offset_within_row, num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n+        ctx, col, rows, match_bytevector,\n+        [](const uint8_t* left_base, const uint8_t* right_base, uint32_t irow_left_base,\n+           __m256i irow_left, __m256i offset_right) {\n+          auto left_base_i64 =\n+              reinterpret_cast<const arrow::util::int64_for_gather_t*>(left_base);\n+          __m256i left_lo =\n+              _mm256_i32gather_epi64(left_base_i64, _mm256_castsi256_si128(irow_left), 8);\n+          __m256i left_hi = _mm256_i32gather_epi64(\n+              left_base_i64, _mm256_extracti128_si256(irow_left, 1), 8);\n+          if (use_selection) {\n+            left_lo = _mm256_i32gather_epi64(left_base_i64,\n+                                             _mm256_castsi256_si128(irow_left), 8);\n+            left_hi = _mm256_i32gather_epi64(left_base_i64,\n+                                             _mm256_extracti128_si256(irow_left, 1), 8);\n+          } else {\n+            left_lo = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_base) +\n+                                         irow_left_base / 4);\n+            left_hi = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_base) +\n+                                         irow_left_base / 4 + 1);\n+          }\n+          auto right_base_i64 =\n+              reinterpret_cast<const arrow::util::int64_for_gather_t*>(right_base);\n+          __m256i right_lo = _mm256_i32gather_epi64(\n+              right_base_i64, _mm256_castsi256_si128(offset_right), 1);\n+          __m256i right_hi = _mm256_i32gather_epi64(\n+              right_base_i64, _mm256_extracti128_si256(offset_right, 1), 1);\n+          uint32_t result_lo =\n+              _mm256_movemask_epi8(_mm256_cmpeq_epi64(left_lo, right_lo));\n+          uint32_t result_hi =\n+              _mm256_movemask_epi8(_mm256_cmpeq_epi64(left_hi, right_hi));\n+          return result_lo | (static_cast<uint64_t>(result_hi) << 32);\n+        });\n+  } else {\n+    return CompareBinaryColumnToRowHelper_avx2<use_selection>(\n+        offset_within_row, num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n+        ctx, col, rows, match_bytevector,\n+        [&col](const uint8_t* left_base, const uint8_t* right_base,\n+               uint32_t irow_left_base, __m256i irow_left, __m256i offset_right) {\n+          uint32_t irow_left_array[8];\n+          uint32_t offset_right_array[8];\n+          if (use_selection) {\n+            _mm256_storeu_si256(reinterpret_cast<__m256i*>(irow_left_array), irow_left);\n+          }\n+          _mm256_storeu_si256(reinterpret_cast<__m256i*>(offset_right_array),\n+                              offset_right);\n+          uint32_t length = col.metadata().fixed_length;\n+\n+          // Non-zero length guarantees no underflow\n+          int32_t num_loops_less_one = (static_cast<int32_t>(length) + 31) / 32 - 1;\n+\n+          __m256i tail_mask = _mm256_cmpgt_epi8(\n+              _mm256_set1_epi8(length - num_loops_less_one * 32),\n+              _mm256_setr_epi64x(0x0706050403020100ULL, 0x0f0e0d0c0b0a0908ULL,\n+                                 0x1716151413121110ULL, 0x1f1e1d1c1b1a1918ULL));\n+\n+          uint64_t result = 0;\n+          for (uint32_t irow = 0; irow < 8; ++irow) {\n+            const __m256i* key_left_ptr = reinterpret_cast<const __m256i*>(\n+                left_base +\n+                (use_selection ? irow_left_array[irow] : irow_left_base + irow) * length);\n+            const __m256i* key_right_ptr =\n+                reinterpret_cast<const __m256i*>(right_base + offset_right_array[irow]);\n+            __m256i result_or = _mm256_setzero_si256();\n+            int32_t i;\n+            // length cannot be zero\n+            for (i = 0; i < num_loops_less_one; ++i) {\n+              __m256i key_left = _mm256_loadu_si256(key_left_ptr + i);\n+              __m256i key_right = _mm256_loadu_si256(key_right_ptr + i);\n+              result_or =\n+                  _mm256_or_si256(result_or, _mm256_xor_si256(key_left, key_right));\n+            }\n+            __m256i key_left = _mm256_loadu_si256(key_left_ptr + i);\n+            __m256i key_right = _mm256_loadu_si256(key_right_ptr + i);\n+            result_or = _mm256_or_si256(\n+                result_or,\n+                _mm256_and_si256(tail_mask, _mm256_xor_si256(key_left, key_right)));\n+            uint64_t result_single = _mm256_testz_si256(result_or, result_or) * 0xff;\n+            result |= result_single << (8 * irow);\n+          }\n+          return result;\n+        });\n+  }\n }\n \n-void KeyCompare::CompareVaryingLength_avx2(\n-    uint32_t num_rows, const uint32_t* left_to_right_map, uint8_t* match_bytevector,\n-    const uint8_t* rows_left, const uint8_t* rows_right, const uint32_t* offsets_left,\n-    const uint32_t* offsets_right) {\n-  for (uint32_t irow_left = 0; irow_left < num_rows; ++irow_left) {\n+// Overwrites the match_bytevector instead of updating it\n+template <bool use_selection, bool is_first_varbinary_col>\n+void KeyCompare::CompareVarBinaryColumnToRowImp_avx2(\n+    uint32_t id_varbinary_col, uint32_t num_rows_to_compare,\n+    const uint16_t* sel_left_maybe_null, const uint32_t* left_to_right_map,\n+    KeyEncoder::KeyEncoderContext* ctx, const KeyEncoder::KeyColumnArray& col,\n+    const KeyEncoder::KeyRowArray& rows, uint8_t* match_bytevector) {\n+  const uint32_t* offsets_left = col.offsets();\n+  const uint32_t* offsets_right = rows.offsets();\n+  const uint8_t* rows_left = col.data(2);\n+  const uint8_t* rows_right = rows.data(2);\n+  for (uint32_t i = 0; i < num_rows_to_compare; ++i) {\n+    uint32_t irow_left = use_selection ? sel_left_maybe_null[i] : i;\n     uint32_t irow_right = left_to_right_map[irow_left];\n     uint32_t begin_left = offsets_left[irow_left];\n-    uint32_t begin_right = offsets_right[irow_right];\n     uint32_t length_left = offsets_left[irow_left + 1] - begin_left;\n-    uint32_t length_right = offsets_right[irow_right + 1] - begin_right;\n-    uint32_t length = std::min(length_left, length_right);\n-    auto key_left_ptr = reinterpret_cast<const __m256i*>(rows_left + begin_left);\n-    auto key_right_ptr = reinterpret_cast<const __m256i*>(rows_right + begin_right);\n-    __m256i result_or = _mm256_setzero_si256();\n-    int32_t i;\n-    // length can be zero\n-    for (i = 0; i < (static_cast<int32_t>(length) + 31) / 32 - 1; ++i) {\n-      __m256i key_left = _mm256_loadu_si256(key_left_ptr + i);\n-      __m256i key_right = _mm256_loadu_si256(key_right_ptr + i);\n-      result_or = _mm256_or_si256(result_or, _mm256_xor_si256(key_left, key_right));\n+    uint32_t begin_right = offsets_right[irow_right];\n+    uint32_t length_right;\n+    uint32_t offset_within_row;\n+    if (!is_first_varbinary_col) {\n+      rows.metadata().nth_varbinary_offset_and_length(\n+          rows_right + begin_right, id_varbinary_col, &offset_within_row, &length_right);\n+    } else {\n+      rows.metadata().first_varbinary_offset_and_length(\n+          rows_right + begin_right, &offset_within_row, &length_right);\n     }\n+    begin_right += offset_within_row;\n \n-    constexpr uint64_t kByteSequence0To7 = 0x0706050403020100ULL;\n-    constexpr uint64_t kByteSequence8To15 = 0x0f0e0d0c0b0a0908ULL;\n-    constexpr uint64_t kByteSequence16To23 = 0x1716151413121110ULL;\n-    constexpr uint64_t kByteSequence24To31 = 0x1f1e1d1c1b1a1918ULL;\n+    __m256i result_or = _mm256_setzero_si256();\n+    uint32_t length = std::min(length_left, length_right);\n+    if (length > 0) {\n+      const __m256i* key_left_ptr =\n+          reinterpret_cast<const __m256i*>(rows_left + begin_left);\n+      const __m256i* key_right_ptr =\n+          reinterpret_cast<const __m256i*>(rows_right + begin_right);\n+      int32_t j;\n+      // length can be zero\n+      for (j = 0; j < (static_cast<int32_t>(length) + 31) / 32 - 1; ++j) {\n+        __m256i key_left = _mm256_loadu_si256(key_left_ptr + j);\n+        __m256i key_right = _mm256_loadu_si256(key_right_ptr + j);\n+        result_or = _mm256_or_si256(result_or, _mm256_xor_si256(key_left, key_right));\n+      }\n \n-    __m256i tail_mask =\n-        _mm256_cmpgt_epi8(_mm256_set1_epi8(length - i * 32),\n-                          _mm256_setr_epi64x(kByteSequence0To7, kByteSequence8To15,\n-                                             kByteSequence16To23, kByteSequence24To31));\n+      __m256i tail_mask = _mm256_cmpgt_epi8(\n+          _mm256_set1_epi8(length - j * 32),\n+          _mm256_setr_epi64x(0x0706050403020100ULL, 0x0f0e0d0c0b0a0908ULL,\n\nReview comment:\n       changed\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-13T03:15:27.331+0000",
                    "updated": "2021-08-13T03:15:27.331+0000",
                    "started": "2021-08-13T03:15:27.330+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637662",
                    "issueId": "13377672"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377672/worklog/637665",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "michalursa commented on a change in pull request #10290:\nURL: https://github.com/apache/arrow/pull/10290#discussion_r688217220\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate_test.cc\n##########\n@@ -991,6 +991,9 @@ TEST(GroupBy, SumOnlyStringAndDictKeys) {\n                                            {\n                                                {\"hash_sum\", nullptr},\n                                            }));\n+    if (key_type->Equals(utf8())) {\n\nReview comment:\n       SortBy doesn't work for string dictionary type. And accidentally the order does not change for this test case, so it works across the systems. If you can tell me how to sort dictionary array I will change it.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-13T03:22:29.887+0000",
                    "updated": "2021-08-13T03:22:29.887+0000",
                    "started": "2021-08-13T03:22:29.887+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637665",
                    "issueId": "13377672"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377672/worklog/637687",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "michalursa commented on a change in pull request #10290:\nURL: https://github.com/apache/arrow/pull/10290#discussion_r688249565\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/key_compare_avx2.cc\n##########\n@@ -25,160 +25,545 @@ namespace compute {\n \n #if defined(ARROW_HAVE_AVX2)\n \n-uint32_t KeyCompare::CompareFixedLength_UpTo8B_avx2(\n-    uint32_t num_rows, const uint32_t* left_to_right_map, uint8_t* match_bytevector,\n-    uint32_t length, const uint8_t* rows_left, const uint8_t* rows_right) {\n-  ARROW_DCHECK(length <= 8);\n-  __m256i offset_left = _mm256_setr_epi64x(0, length, length * 2, length * 3);\n-  __m256i offset_left_incr = _mm256_set1_epi64x(length * 4);\n-  __m256i mask = _mm256_set1_epi64x(~0ULL >> (8 * (8 - length)));\n-\n-  constexpr uint32_t unroll = 4;\n-  for (uint32_t i = 0; i < num_rows / unroll; ++i) {\n-    auto key_left = _mm256_i64gather_epi64(\n-        reinterpret_cast<arrow::util::int64_for_gather_t*>(rows_left), offset_left, 1);\n-    offset_left = _mm256_add_epi64(offset_left, offset_left_incr);\n-    __m128i offset_right =\n-        _mm_loadu_si128(reinterpret_cast<const __m128i*>(left_to_right_map) + i);\n-    offset_right = _mm_mullo_epi32(offset_right, _mm_set1_epi32(length));\n-\n-    auto key_right = _mm256_i32gather_epi64(\n-        reinterpret_cast<arrow::util::int64_for_gather_t*>(rows_right), offset_right, 1);\n-    uint32_t cmp = _mm256_movemask_epi8(_mm256_cmpeq_epi64(\n-        _mm256_and_si256(key_left, mask), _mm256_and_si256(key_right, mask)));\n-    reinterpret_cast<uint32_t*>(match_bytevector)[i] &= cmp;\n+template <bool use_selection>\n+uint32_t KeyCompare::NullUpdateColumnToRowImp_avx2(\n+    uint32_t id_col, uint32_t num_rows_to_compare, const uint16_t* sel_left_maybe_null,\n+    const uint32_t* left_to_right_map, KeyEncoder::KeyEncoderContext* ctx,\n+    const KeyEncoder::KeyColumnArray& col, const KeyEncoder::KeyRowArray& rows,\n+    uint8_t* match_bytevector) {\n+  if (!rows.has_any_nulls(ctx) && !col.data(0)) {\n+    return num_rows_to_compare;\n   }\n+  if (!col.data(0)) {\n+    // Remove rows from the result for which the column value is a null\n+    const uint8_t* null_masks = rows.null_masks();\n+    uint32_t null_mask_num_bytes = rows.metadata().null_masks_bytes_per_row;\n \n-  uint32_t num_rows_processed = num_rows - (num_rows % unroll);\n-  return num_rows_processed;\n-}\n+    uint32_t num_processed = 0;\n+    constexpr uint32_t unroll = 8;\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      __m256i irow_right;\n+      if (use_selection) {\n+        __m256i irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+        irow_right = _mm256_i32gather_epi32((const int*)left_to_right_map, irow_left, 4);\n+      } else {\n+        irow_right =\n+            _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_to_right_map) + i);\n+      }\n+      __m256i bitid =\n+          _mm256_mullo_epi32(irow_right, _mm256_set1_epi32(null_mask_num_bytes * 8));\n+      bitid = _mm256_add_epi32(bitid, _mm256_set1_epi32(id_col));\n+      __m256i right =\n+          _mm256_i32gather_epi32((const int*)null_masks, _mm256_srli_epi32(bitid, 3), 1);\n+      right = _mm256_and_si256(\n+          _mm256_set1_epi32(1),\n+          _mm256_srlv_epi32(right, _mm256_and_si256(bitid, _mm256_set1_epi32(7))));\n+      __m256i cmp = _mm256_cmpeq_epi32(right, _mm256_setzero_si256());\n+      uint32_t result_lo =\n+          _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_castsi256_si128(cmp)));\n+      uint32_t result_hi =\n+          _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_extracti128_si256(cmp, 1)));\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] &=\n+          result_lo | (static_cast<uint64_t>(result_hi) << 32);\n+    }\n+    num_processed = num_rows_to_compare / unroll * unroll;\n+    return num_processed;\n+  } else if (!rows.has_any_nulls(ctx)) {\n+    // Remove rows from the result for which the column value on left side is null\n+    const uint8_t* non_nulls = col.data(0);\n+    ARROW_DCHECK(non_nulls);\n+    uint32_t num_processed = 0;\n+    constexpr uint32_t unroll = 8;\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      __m256i cmp;\n+      if (use_selection) {\n+        __m256i irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+        irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(col.bit_offset(0)));\n+        __m256i left = _mm256_i32gather_epi32((const int*)non_nulls,\n+                                              _mm256_srli_epi32(irow_left, 3), 1);\n+        left = _mm256_and_si256(\n+            _mm256_set1_epi32(1),\n+            _mm256_srlv_epi32(left, _mm256_and_si256(irow_left, _mm256_set1_epi32(7))));\n+        cmp = _mm256_cmpeq_epi32(left, _mm256_set1_epi32(1));\n+      } else {\n+        __m256i left = _mm256_cvtepu8_epi32(_mm_set1_epi8(static_cast<uint8_t>(\n+            reinterpret_cast<const uint16_t*>(non_nulls + i)[0] >> col.bit_offset(0))));\n+        __m256i bits = _mm256_setr_epi32(1, 2, 4, 8, 16, 32, 64, 128);\n+        cmp = _mm256_cmpeq_epi32(_mm256_and_si256(left, bits), bits);\n+      }\n+      uint32_t result_lo =\n+          _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_castsi256_si128(cmp)));\n+      uint32_t result_hi =\n+          _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_extracti128_si256(cmp, 1)));\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] &=\n+          result_lo | (static_cast<uint64_t>(result_hi) << 32);\n+      num_processed = num_rows_to_compare / unroll * unroll;\n+    }\n+    return num_processed;\n+  } else {\n+    const uint8_t* null_masks = rows.null_masks();\n+    uint32_t null_mask_num_bytes = rows.metadata().null_masks_bytes_per_row;\n+    const uint8_t* non_nulls = col.data(0);\n+    ARROW_DCHECK(non_nulls);\n \n-uint32_t KeyCompare::CompareFixedLength_UpTo16B_avx2(\n-    uint32_t num_rows, const uint32_t* left_to_right_map, uint8_t* match_bytevector,\n-    uint32_t length, const uint8_t* rows_left, const uint8_t* rows_right) {\n-  ARROW_DCHECK(length <= 16);\n-\n-  constexpr uint64_t kByteSequence0To7 = 0x0706050403020100ULL;\n-  constexpr uint64_t kByteSequence8To15 = 0x0f0e0d0c0b0a0908ULL;\n-\n-  __m256i mask =\n-      _mm256_cmpgt_epi8(_mm256_set1_epi8(length),\n-                        _mm256_setr_epi64x(kByteSequence0To7, kByteSequence8To15,\n-                                           kByteSequence0To7, kByteSequence8To15));\n-  const uint8_t* key_left_ptr = rows_left;\n-\n-  constexpr uint32_t unroll = 2;\n-  for (uint32_t i = 0; i < num_rows / unroll; ++i) {\n-    auto key_left = _mm256_inserti128_si256(\n-        _mm256_castsi128_si256(\n-            _mm_loadu_si128(reinterpret_cast<const __m128i*>(key_left_ptr))),\n-        _mm_loadu_si128(reinterpret_cast<const __m128i*>(key_left_ptr + length)), 1);\n-    key_left_ptr += length * 2;\n-    auto key_right = _mm256_inserti128_si256(\n-        _mm256_castsi128_si256(_mm_loadu_si128(reinterpret_cast<const __m128i*>(\n-            rows_right + length * left_to_right_map[2 * i]))),\n-        _mm_loadu_si128(reinterpret_cast<const __m128i*>(\n-            rows_right + length * left_to_right_map[2 * i + 1])),\n-        1);\n-    __m256i cmp = _mm256_cmpeq_epi64(_mm256_and_si256(key_left, mask),\n-                                     _mm256_and_si256(key_right, mask));\n-    cmp = _mm256_and_si256(cmp, _mm256_shuffle_epi32(cmp, 0xee));  // 0b11101110\n-    cmp = _mm256_permute4x64_epi64(cmp, 0x08);                     // 0b00001000\n-    reinterpret_cast<uint16_t*>(match_bytevector)[i] &=\n-        (_mm256_movemask_epi8(cmp) & 0xffff);\n-  }\n+    uint32_t num_processed = 0;\n+    constexpr uint32_t unroll = 8;\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      __m256i left_null;\n+      __m256i irow_right;\n+      if (use_selection) {\n+        __m256i irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+        irow_right = _mm256_i32gather_epi32((const int*)left_to_right_map, irow_left, 4);\n+        irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(col.bit_offset(0)));\n+        __m256i left = _mm256_i32gather_epi32((const int*)non_nulls,\n+                                              _mm256_srli_epi32(irow_left, 3), 1);\n+        left = _mm256_and_si256(\n+            _mm256_set1_epi32(1),\n+            _mm256_srlv_epi32(left, _mm256_and_si256(irow_left, _mm256_set1_epi32(7))));\n+        left_null = _mm256_cmpeq_epi32(left, _mm256_setzero_si256());\n+      } else {\n+        irow_right =\n+            _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_to_right_map) + i);\n+        __m256i left = _mm256_cvtepu8_epi32(_mm_set1_epi8(static_cast<uint8_t>(\n+            reinterpret_cast<const uint16_t*>(non_nulls + i)[0] >> col.bit_offset(0))));\n+        __m256i bits = _mm256_setr_epi32(1, 2, 4, 8, 16, 32, 64, 128);\n+        left_null =\n+            _mm256_cmpeq_epi32(_mm256_and_si256(left, bits), _mm256_setzero_si256());\n+      }\n+      __m256i bitid =\n+          _mm256_mullo_epi32(irow_right, _mm256_set1_epi32(null_mask_num_bytes * 8));\n+      bitid = _mm256_add_epi32(bitid, _mm256_set1_epi32(id_col));\n+      __m256i right =\n+          _mm256_i32gather_epi32((const int*)null_masks, _mm256_srli_epi32(bitid, 3), 1);\n+      right = _mm256_and_si256(\n+          _mm256_set1_epi32(1),\n+          _mm256_srlv_epi32(right, _mm256_and_si256(bitid, _mm256_set1_epi32(7))));\n+      __m256i right_null = _mm256_cmpeq_epi32(right, _mm256_set1_epi32(1));\n \n-  uint32_t num_rows_processed = num_rows - (num_rows % unroll);\n-  return num_rows_processed;\n-}\n+      uint64_t left_null_64 =\n+          static_cast<uint32_t>(_mm256_movemask_epi8(\n+              _mm256_cvtepi32_epi64(_mm256_castsi256_si128(left_null)))) |\n+          (static_cast<uint64_t>(static_cast<uint32_t>(_mm256_movemask_epi8(\n+               _mm256_cvtepi32_epi64(_mm256_extracti128_si256(left_null, 1)))))\n+           << 32);\n \n-uint32_t KeyCompare::CompareFixedLength_avx2(uint32_t num_rows,\n-                                             const uint32_t* left_to_right_map,\n-                                             uint8_t* match_bytevector, uint32_t length,\n-                                             const uint8_t* rows_left,\n-                                             const uint8_t* rows_right) {\n-  ARROW_DCHECK(length > 0);\n+      uint64_t right_null_64 =\n+          static_cast<uint32_t>(_mm256_movemask_epi8(\n+              _mm256_cvtepi32_epi64(_mm256_castsi256_si128(right_null)))) |\n+          (static_cast<uint64_t>(static_cast<uint32_t>(_mm256_movemask_epi8(\n+               _mm256_cvtepi32_epi64(_mm256_extracti128_si256(right_null, 1)))))\n+           << 32);\n \n-  constexpr uint64_t kByteSequence0To7 = 0x0706050403020100ULL;\n-  constexpr uint64_t kByteSequence8To15 = 0x0f0e0d0c0b0a0908ULL;\n-  constexpr uint64_t kByteSequence16To23 = 0x1716151413121110ULL;\n-  constexpr uint64_t kByteSequence24To31 = 0x1f1e1d1c1b1a1918ULL;\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] |= left_null_64 & right_null_64;\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] &= ~(left_null_64 ^ right_null_64);\n+    }\n+    num_processed = num_rows_to_compare / unroll * unroll;\n+    return num_processed;\n+  }\n+}\n \n-  // Non-zero length guarantees no underflow\n-  int32_t num_loops_less_one = (static_cast<int32_t>(length) + 31) / 32 - 1;\n+template <bool use_selection, class COMPARE8_FN>\n+uint32_t KeyCompare::CompareBinaryColumnToRowHelper_avx2(\n+    uint32_t offset_within_row, uint32_t num_rows_to_compare,\n+    const uint16_t* sel_left_maybe_null, const uint32_t* left_to_right_map,\n+    KeyEncoder::KeyEncoderContext* ctx, const KeyEncoder::KeyColumnArray& col,\n+    const KeyEncoder::KeyRowArray& rows, uint8_t* match_bytevector,\n+    COMPARE8_FN compare8_fn) {\n+  bool is_fixed_length = rows.metadata().is_fixed_length;\n+  if (is_fixed_length) {\n+    uint32_t fixed_length = rows.metadata().fixed_length;\n+    const uint8_t* rows_left = col.data(1);\n+    const uint8_t* rows_right = rows.data(1);\n+    constexpr uint32_t unroll = 8;\n+    __m256i irow_left = _mm256_setr_epi32(0, 1, 2, 3, 4, 5, 6, 7);\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      if (use_selection) {\n+        irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+      }\n+      __m256i irow_right;\n+      if (use_selection) {\n+        irow_right = _mm256_i32gather_epi32((const int*)left_to_right_map, irow_left, 4);\n+      } else {\n+        irow_right =\n+            _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_to_right_map) + i);\n+      }\n \n-  __m256i tail_mask =\n-      _mm256_cmpgt_epi8(_mm256_set1_epi8(length - num_loops_less_one * 32),\n-                        _mm256_setr_epi64x(kByteSequence0To7, kByteSequence8To15,\n-                                           kByteSequence16To23, kByteSequence24To31));\n+      __m256i offset_right =\n+          _mm256_mullo_epi32(irow_right, _mm256_set1_epi32(fixed_length));\n+      offset_right = _mm256_add_epi32(offset_right, _mm256_set1_epi32(offset_within_row));\n \n-  for (uint32_t irow_left = 0; irow_left < num_rows; ++irow_left) {\n-    uint32_t irow_right = left_to_right_map[irow_left];\n-    uint32_t begin_left = length * irow_left;\n-    uint32_t begin_right = length * irow_right;\n-    const __m256i* key_left_ptr =\n-        reinterpret_cast<const __m256i*>(rows_left + begin_left);\n-    const __m256i* key_right_ptr =\n-        reinterpret_cast<const __m256i*>(rows_right + begin_right);\n-    __m256i result_or = _mm256_setzero_si256();\n-    int32_t i;\n-    // length cannot be zero\n-    for (i = 0; i < num_loops_less_one; ++i) {\n-      __m256i key_left = _mm256_loadu_si256(key_left_ptr + i);\n-      __m256i key_right = _mm256_loadu_si256(key_right_ptr + i);\n-      result_or = _mm256_or_si256(result_or, _mm256_xor_si256(key_left, key_right));\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] =\n+          compare8_fn(rows_left, rows_right, i * unroll, irow_left, offset_right);\n+\n+      if (!use_selection) {\n+        irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(8));\n+      }\n     }\n+    return num_rows_to_compare - (num_rows_to_compare % unroll);\n+  } else {\n+    const uint8_t* rows_left = col.data(1);\n+    const uint32_t* offsets_right = rows.offsets();\n+    const uint8_t* rows_right = rows.data(2);\n+    constexpr uint32_t unroll = 8;\n+    __m256i irow_left = _mm256_setr_epi32(0, 1, 2, 3, 4, 5, 6, 7);\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      if (use_selection) {\n+        irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+      }\n+      __m256i irow_right;\n+      if (use_selection) {\n+        irow_right = _mm256_i32gather_epi32((const int*)left_to_right_map, irow_left, 4);\n+      } else {\n+        irow_right =\n+            _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_to_right_map) + i);\n+      }\n+      __m256i offset_right =\n+          _mm256_i32gather_epi32((const int*)offsets_right, irow_right, 4);\n+      offset_right = _mm256_add_epi32(offset_right, _mm256_set1_epi32(offset_within_row));\n \n-    __m256i key_left = _mm256_loadu_si256(key_left_ptr + i);\n-    __m256i key_right = _mm256_loadu_si256(key_right_ptr + i);\n-    result_or = _mm256_or_si256(\n-        result_or, _mm256_and_si256(tail_mask, _mm256_xor_si256(key_left, key_right)));\n-    int result = _mm256_testz_si256(result_or, result_or) * 0xff;\n-    match_bytevector[irow_left] &= result;\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] =\n+          compare8_fn(rows_left, rows_right, i * unroll, irow_left, offset_right);\n+\n+      if (!use_selection) {\n+        irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(8));\n+      }\n+    }\n+    return num_rows_to_compare - (num_rows_to_compare % unroll);\n   }\n+}\n \n-  uint32_t num_rows_processed = num_rows;\n-  return num_rows_processed;\n+template <bool use_selection>\n+uint32_t KeyCompare::CompareBinaryColumnToRowImp_avx2(\n+    uint32_t offset_within_row, uint32_t num_rows_to_compare,\n+    const uint16_t* sel_left_maybe_null, const uint32_t* left_to_right_map,\n+    KeyEncoder::KeyEncoderContext* ctx, const KeyEncoder::KeyColumnArray& col,\n+    const KeyEncoder::KeyRowArray& rows, uint8_t* match_bytevector) {\n+  uint32_t col_width = col.metadata().fixed_length;\n+  if (col_width == 0) {\n+    int bit_offset = col.bit_offset(1);\n+    return CompareBinaryColumnToRowHelper_avx2<use_selection>(\n+        offset_within_row, num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n+        ctx, col, rows, match_bytevector,\n+        [bit_offset](const uint8_t* left_base, const uint8_t* right_base,\n+                     uint32_t irow_left_base, __m256i irow_left, __m256i offset_right) {\n+          __m256i left;\n+          if (use_selection) {\n+            irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(bit_offset));\n+            left = _mm256_i32gather_epi32((const int*)left_base,\n+                                          _mm256_srli_epi32(irow_left, 3), 1);\n+            left = _mm256_and_si256(\n+                _mm256_set1_epi32(1),\n+                _mm256_srlv_epi32(left,\n+                                  _mm256_and_si256(irow_left, _mm256_set1_epi32(7))));\n+            left = _mm256_mullo_epi32(left, _mm256_set1_epi32(0xff));\n+          } else {\n+            __m256i bits = _mm256_setr_epi32(1, 2, 4, 8, 16, 32, 64, 128);\n+            uint32_t start_bit_index = irow_left_base + bit_offset;\n+            uint8_t left_bits_8 =\n+                (reinterpret_cast<const uint16_t*>(left_base + start_bit_index / 8)[0] >>\n+                 (start_bit_index % 8)) &\n+                0xff;\n+            left = _mm256_cmpeq_epi32(\n+                _mm256_and_si256(bits, _mm256_set1_epi8(left_bits_8)), bits);\n+            left = _mm256_and_si256(left, _mm256_set1_epi32(0xff));\n+          }\n+          __m256i right = _mm256_i32gather_epi32((const int*)right_base, offset_right, 1);\n+          right = _mm256_and_si256(right, _mm256_set1_epi32(0xff));\n+          __m256i cmp = _mm256_cmpeq_epi32(left, right);\n+          uint32_t result_lo =\n+              _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_castsi256_si128(cmp)));\n+          uint32_t result_hi = _mm256_movemask_epi8(\n+              _mm256_cvtepi32_epi64(_mm256_extracti128_si256(cmp, 1)));\n+          return result_lo | (static_cast<uint64_t>(result_hi) << 32);\n+        });\n+  } else if (col_width == 1) {\n\nReview comment:\n       I refactored that part a bit.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-13T05:19:07.264+0000",
                    "updated": "2021-08-13T05:19:07.264+0000",
                    "started": "2021-08-13T05:19:07.263+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637687",
                    "issueId": "13377672"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377672/worklog/639535",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10290:\nURL: https://github.com/apache/arrow/pull/10290#discussion_r691474751\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate_test.cc\n##########\n@@ -991,6 +991,9 @@ TEST(GroupBy, SumOnlyStringAndDictKeys) {\n                                            {\n                                                {\"hash_sum\", nullptr},\n                                            }));\n+    if (key_type->Equals(utf8())) {\n\nReview comment:\n       I'll push a change to support sorting by dictionary arrays\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-18T17:46:09.397+0000",
                    "updated": "2021-08-18T17:46:09.397+0000",
                    "started": "2021-08-18T17:46:09.397+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "639535",
                    "issueId": "13377672"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377672/worklog/639545",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10290:\nURL: https://github.com/apache/arrow/pull/10290#discussion_r691488660\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/key_compare_avx2.cc\n##########\n@@ -25,160 +25,545 @@ namespace compute {\n \n #if defined(ARROW_HAVE_AVX2)\n \n-uint32_t KeyCompare::CompareFixedLength_UpTo8B_avx2(\n-    uint32_t num_rows, const uint32_t* left_to_right_map, uint8_t* match_bytevector,\n-    uint32_t length, const uint8_t* rows_left, const uint8_t* rows_right) {\n-  ARROW_DCHECK(length <= 8);\n-  __m256i offset_left = _mm256_setr_epi64x(0, length, length * 2, length * 3);\n-  __m256i offset_left_incr = _mm256_set1_epi64x(length * 4);\n-  __m256i mask = _mm256_set1_epi64x(~0ULL >> (8 * (8 - length)));\n-\n-  constexpr uint32_t unroll = 4;\n-  for (uint32_t i = 0; i < num_rows / unroll; ++i) {\n-    auto key_left = _mm256_i64gather_epi64(\n-        reinterpret_cast<arrow::util::int64_for_gather_t*>(rows_left), offset_left, 1);\n-    offset_left = _mm256_add_epi64(offset_left, offset_left_incr);\n-    __m128i offset_right =\n-        _mm_loadu_si128(reinterpret_cast<const __m128i*>(left_to_right_map) + i);\n-    offset_right = _mm_mullo_epi32(offset_right, _mm_set1_epi32(length));\n-\n-    auto key_right = _mm256_i32gather_epi64(\n-        reinterpret_cast<arrow::util::int64_for_gather_t*>(rows_right), offset_right, 1);\n-    uint32_t cmp = _mm256_movemask_epi8(_mm256_cmpeq_epi64(\n-        _mm256_and_si256(key_left, mask), _mm256_and_si256(key_right, mask)));\n-    reinterpret_cast<uint32_t*>(match_bytevector)[i] &= cmp;\n+template <bool use_selection>\n+uint32_t KeyCompare::NullUpdateColumnToRowImp_avx2(\n+    uint32_t id_col, uint32_t num_rows_to_compare, const uint16_t* sel_left_maybe_null,\n+    const uint32_t* left_to_right_map, KeyEncoder::KeyEncoderContext* ctx,\n+    const KeyEncoder::KeyColumnArray& col, const KeyEncoder::KeyRowArray& rows,\n+    uint8_t* match_bytevector) {\n+  if (!rows.has_any_nulls(ctx) && !col.data(0)) {\n+    return num_rows_to_compare;\n   }\n+  if (!col.data(0)) {\n+    // Remove rows from the result for which the column value is a null\n+    const uint8_t* null_masks = rows.null_masks();\n+    uint32_t null_mask_num_bytes = rows.metadata().null_masks_bytes_per_row;\n \n-  uint32_t num_rows_processed = num_rows - (num_rows % unroll);\n-  return num_rows_processed;\n-}\n+    uint32_t num_processed = 0;\n+    constexpr uint32_t unroll = 8;\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      __m256i irow_right;\n+      if (use_selection) {\n+        __m256i irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+        irow_right = _mm256_i32gather_epi32((const int*)left_to_right_map, irow_left, 4);\n+      } else {\n+        irow_right =\n+            _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_to_right_map) + i);\n+      }\n+      __m256i bitid =\n+          _mm256_mullo_epi32(irow_right, _mm256_set1_epi32(null_mask_num_bytes * 8));\n+      bitid = _mm256_add_epi32(bitid, _mm256_set1_epi32(id_col));\n+      __m256i right =\n+          _mm256_i32gather_epi32((const int*)null_masks, _mm256_srli_epi32(bitid, 3), 1);\n+      right = _mm256_and_si256(\n+          _mm256_set1_epi32(1),\n+          _mm256_srlv_epi32(right, _mm256_and_si256(bitid, _mm256_set1_epi32(7))));\n+      __m256i cmp = _mm256_cmpeq_epi32(right, _mm256_setzero_si256());\n+      uint32_t result_lo =\n+          _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_castsi256_si128(cmp)));\n+      uint32_t result_hi =\n+          _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_extracti128_si256(cmp, 1)));\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] &=\n+          result_lo | (static_cast<uint64_t>(result_hi) << 32);\n+    }\n+    num_processed = num_rows_to_compare / unroll * unroll;\n+    return num_processed;\n+  } else if (!rows.has_any_nulls(ctx)) {\n+    // Remove rows from the result for which the column value on left side is null\n+    const uint8_t* non_nulls = col.data(0);\n+    ARROW_DCHECK(non_nulls);\n+    uint32_t num_processed = 0;\n+    constexpr uint32_t unroll = 8;\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      __m256i cmp;\n+      if (use_selection) {\n+        __m256i irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+        irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(col.bit_offset(0)));\n+        __m256i left = _mm256_i32gather_epi32((const int*)non_nulls,\n+                                              _mm256_srli_epi32(irow_left, 3), 1);\n+        left = _mm256_and_si256(\n+            _mm256_set1_epi32(1),\n+            _mm256_srlv_epi32(left, _mm256_and_si256(irow_left, _mm256_set1_epi32(7))));\n+        cmp = _mm256_cmpeq_epi32(left, _mm256_set1_epi32(1));\n+      } else {\n+        __m256i left = _mm256_cvtepu8_epi32(_mm_set1_epi8(static_cast<uint8_t>(\n+            reinterpret_cast<const uint16_t*>(non_nulls + i)[0] >> col.bit_offset(0))));\n+        __m256i bits = _mm256_setr_epi32(1, 2, 4, 8, 16, 32, 64, 128);\n+        cmp = _mm256_cmpeq_epi32(_mm256_and_si256(left, bits), bits);\n+      }\n+      uint32_t result_lo =\n+          _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_castsi256_si128(cmp)));\n+      uint32_t result_hi =\n+          _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_extracti128_si256(cmp, 1)));\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] &=\n+          result_lo | (static_cast<uint64_t>(result_hi) << 32);\n+      num_processed = num_rows_to_compare / unroll * unroll;\n+    }\n+    return num_processed;\n+  } else {\n+    const uint8_t* null_masks = rows.null_masks();\n+    uint32_t null_mask_num_bytes = rows.metadata().null_masks_bytes_per_row;\n+    const uint8_t* non_nulls = col.data(0);\n+    ARROW_DCHECK(non_nulls);\n \n-uint32_t KeyCompare::CompareFixedLength_UpTo16B_avx2(\n-    uint32_t num_rows, const uint32_t* left_to_right_map, uint8_t* match_bytevector,\n-    uint32_t length, const uint8_t* rows_left, const uint8_t* rows_right) {\n-  ARROW_DCHECK(length <= 16);\n-\n-  constexpr uint64_t kByteSequence0To7 = 0x0706050403020100ULL;\n-  constexpr uint64_t kByteSequence8To15 = 0x0f0e0d0c0b0a0908ULL;\n-\n-  __m256i mask =\n-      _mm256_cmpgt_epi8(_mm256_set1_epi8(length),\n-                        _mm256_setr_epi64x(kByteSequence0To7, kByteSequence8To15,\n-                                           kByteSequence0To7, kByteSequence8To15));\n-  const uint8_t* key_left_ptr = rows_left;\n-\n-  constexpr uint32_t unroll = 2;\n-  for (uint32_t i = 0; i < num_rows / unroll; ++i) {\n-    auto key_left = _mm256_inserti128_si256(\n-        _mm256_castsi128_si256(\n-            _mm_loadu_si128(reinterpret_cast<const __m128i*>(key_left_ptr))),\n-        _mm_loadu_si128(reinterpret_cast<const __m128i*>(key_left_ptr + length)), 1);\n-    key_left_ptr += length * 2;\n-    auto key_right = _mm256_inserti128_si256(\n-        _mm256_castsi128_si256(_mm_loadu_si128(reinterpret_cast<const __m128i*>(\n-            rows_right + length * left_to_right_map[2 * i]))),\n-        _mm_loadu_si128(reinterpret_cast<const __m128i*>(\n-            rows_right + length * left_to_right_map[2 * i + 1])),\n-        1);\n-    __m256i cmp = _mm256_cmpeq_epi64(_mm256_and_si256(key_left, mask),\n-                                     _mm256_and_si256(key_right, mask));\n-    cmp = _mm256_and_si256(cmp, _mm256_shuffle_epi32(cmp, 0xee));  // 0b11101110\n-    cmp = _mm256_permute4x64_epi64(cmp, 0x08);                     // 0b00001000\n-    reinterpret_cast<uint16_t*>(match_bytevector)[i] &=\n-        (_mm256_movemask_epi8(cmp) & 0xffff);\n-  }\n+    uint32_t num_processed = 0;\n+    constexpr uint32_t unroll = 8;\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      __m256i left_null;\n+      __m256i irow_right;\n+      if (use_selection) {\n+        __m256i irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+        irow_right = _mm256_i32gather_epi32((const int*)left_to_right_map, irow_left, 4);\n+        irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(col.bit_offset(0)));\n+        __m256i left = _mm256_i32gather_epi32((const int*)non_nulls,\n+                                              _mm256_srli_epi32(irow_left, 3), 1);\n+        left = _mm256_and_si256(\n+            _mm256_set1_epi32(1),\n+            _mm256_srlv_epi32(left, _mm256_and_si256(irow_left, _mm256_set1_epi32(7))));\n+        left_null = _mm256_cmpeq_epi32(left, _mm256_setzero_si256());\n+      } else {\n+        irow_right =\n+            _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_to_right_map) + i);\n+        __m256i left = _mm256_cvtepu8_epi32(_mm_set1_epi8(static_cast<uint8_t>(\n+            reinterpret_cast<const uint16_t*>(non_nulls + i)[0] >> col.bit_offset(0))));\n+        __m256i bits = _mm256_setr_epi32(1, 2, 4, 8, 16, 32, 64, 128);\n+        left_null =\n+            _mm256_cmpeq_epi32(_mm256_and_si256(left, bits), _mm256_setzero_si256());\n+      }\n+      __m256i bitid =\n+          _mm256_mullo_epi32(irow_right, _mm256_set1_epi32(null_mask_num_bytes * 8));\n+      bitid = _mm256_add_epi32(bitid, _mm256_set1_epi32(id_col));\n+      __m256i right =\n+          _mm256_i32gather_epi32((const int*)null_masks, _mm256_srli_epi32(bitid, 3), 1);\n+      right = _mm256_and_si256(\n+          _mm256_set1_epi32(1),\n+          _mm256_srlv_epi32(right, _mm256_and_si256(bitid, _mm256_set1_epi32(7))));\n+      __m256i right_null = _mm256_cmpeq_epi32(right, _mm256_set1_epi32(1));\n \n-  uint32_t num_rows_processed = num_rows - (num_rows % unroll);\n-  return num_rows_processed;\n-}\n+      uint64_t left_null_64 =\n+          static_cast<uint32_t>(_mm256_movemask_epi8(\n+              _mm256_cvtepi32_epi64(_mm256_castsi256_si128(left_null)))) |\n+          (static_cast<uint64_t>(static_cast<uint32_t>(_mm256_movemask_epi8(\n+               _mm256_cvtepi32_epi64(_mm256_extracti128_si256(left_null, 1)))))\n+           << 32);\n \n-uint32_t KeyCompare::CompareFixedLength_avx2(uint32_t num_rows,\n-                                             const uint32_t* left_to_right_map,\n-                                             uint8_t* match_bytevector, uint32_t length,\n-                                             const uint8_t* rows_left,\n-                                             const uint8_t* rows_right) {\n-  ARROW_DCHECK(length > 0);\n+      uint64_t right_null_64 =\n+          static_cast<uint32_t>(_mm256_movemask_epi8(\n+              _mm256_cvtepi32_epi64(_mm256_castsi256_si128(right_null)))) |\n+          (static_cast<uint64_t>(static_cast<uint32_t>(_mm256_movemask_epi8(\n+               _mm256_cvtepi32_epi64(_mm256_extracti128_si256(right_null, 1)))))\n+           << 32);\n \n-  constexpr uint64_t kByteSequence0To7 = 0x0706050403020100ULL;\n-  constexpr uint64_t kByteSequence8To15 = 0x0f0e0d0c0b0a0908ULL;\n-  constexpr uint64_t kByteSequence16To23 = 0x1716151413121110ULL;\n-  constexpr uint64_t kByteSequence24To31 = 0x1f1e1d1c1b1a1918ULL;\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] |= left_null_64 & right_null_64;\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] &= ~(left_null_64 ^ right_null_64);\n+    }\n+    num_processed = num_rows_to_compare / unroll * unroll;\n+    return num_processed;\n+  }\n+}\n \n-  // Non-zero length guarantees no underflow\n-  int32_t num_loops_less_one = (static_cast<int32_t>(length) + 31) / 32 - 1;\n+template <bool use_selection, class COMPARE8_FN>\n+uint32_t KeyCompare::CompareBinaryColumnToRowHelper_avx2(\n+    uint32_t offset_within_row, uint32_t num_rows_to_compare,\n+    const uint16_t* sel_left_maybe_null, const uint32_t* left_to_right_map,\n+    KeyEncoder::KeyEncoderContext* ctx, const KeyEncoder::KeyColumnArray& col,\n+    const KeyEncoder::KeyRowArray& rows, uint8_t* match_bytevector,\n+    COMPARE8_FN compare8_fn) {\n+  bool is_fixed_length = rows.metadata().is_fixed_length;\n+  if (is_fixed_length) {\n+    uint32_t fixed_length = rows.metadata().fixed_length;\n+    const uint8_t* rows_left = col.data(1);\n+    const uint8_t* rows_right = rows.data(1);\n+    constexpr uint32_t unroll = 8;\n+    __m256i irow_left = _mm256_setr_epi32(0, 1, 2, 3, 4, 5, 6, 7);\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      if (use_selection) {\n+        irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+      }\n+      __m256i irow_right;\n+      if (use_selection) {\n+        irow_right = _mm256_i32gather_epi32((const int*)left_to_right_map, irow_left, 4);\n+      } else {\n+        irow_right =\n+            _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_to_right_map) + i);\n+      }\n \n-  __m256i tail_mask =\n-      _mm256_cmpgt_epi8(_mm256_set1_epi8(length - num_loops_less_one * 32),\n-                        _mm256_setr_epi64x(kByteSequence0To7, kByteSequence8To15,\n-                                           kByteSequence16To23, kByteSequence24To31));\n+      __m256i offset_right =\n+          _mm256_mullo_epi32(irow_right, _mm256_set1_epi32(fixed_length));\n+      offset_right = _mm256_add_epi32(offset_right, _mm256_set1_epi32(offset_within_row));\n \n-  for (uint32_t irow_left = 0; irow_left < num_rows; ++irow_left) {\n-    uint32_t irow_right = left_to_right_map[irow_left];\n-    uint32_t begin_left = length * irow_left;\n-    uint32_t begin_right = length * irow_right;\n-    const __m256i* key_left_ptr =\n-        reinterpret_cast<const __m256i*>(rows_left + begin_left);\n-    const __m256i* key_right_ptr =\n-        reinterpret_cast<const __m256i*>(rows_right + begin_right);\n-    __m256i result_or = _mm256_setzero_si256();\n-    int32_t i;\n-    // length cannot be zero\n-    for (i = 0; i < num_loops_less_one; ++i) {\n-      __m256i key_left = _mm256_loadu_si256(key_left_ptr + i);\n-      __m256i key_right = _mm256_loadu_si256(key_right_ptr + i);\n-      result_or = _mm256_or_si256(result_or, _mm256_xor_si256(key_left, key_right));\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] =\n+          compare8_fn(rows_left, rows_right, i * unroll, irow_left, offset_right);\n+\n+      if (!use_selection) {\n+        irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(8));\n+      }\n     }\n+    return num_rows_to_compare - (num_rows_to_compare % unroll);\n+  } else {\n+    const uint8_t* rows_left = col.data(1);\n+    const uint32_t* offsets_right = rows.offsets();\n+    const uint8_t* rows_right = rows.data(2);\n+    constexpr uint32_t unroll = 8;\n+    __m256i irow_left = _mm256_setr_epi32(0, 1, 2, 3, 4, 5, 6, 7);\n+    for (uint32_t i = 0; i < num_rows_to_compare / unroll; ++i) {\n+      if (use_selection) {\n+        irow_left = _mm256_cvtepu16_epi32(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i*>(sel_left_maybe_null) + i));\n+      }\n+      __m256i irow_right;\n+      if (use_selection) {\n+        irow_right = _mm256_i32gather_epi32((const int*)left_to_right_map, irow_left, 4);\n+      } else {\n+        irow_right =\n+            _mm256_loadu_si256(reinterpret_cast<const __m256i*>(left_to_right_map) + i);\n+      }\n+      __m256i offset_right =\n+          _mm256_i32gather_epi32((const int*)offsets_right, irow_right, 4);\n+      offset_right = _mm256_add_epi32(offset_right, _mm256_set1_epi32(offset_within_row));\n \n-    __m256i key_left = _mm256_loadu_si256(key_left_ptr + i);\n-    __m256i key_right = _mm256_loadu_si256(key_right_ptr + i);\n-    result_or = _mm256_or_si256(\n-        result_or, _mm256_and_si256(tail_mask, _mm256_xor_si256(key_left, key_right)));\n-    int result = _mm256_testz_si256(result_or, result_or) * 0xff;\n-    match_bytevector[irow_left] &= result;\n+      reinterpret_cast<uint64_t*>(match_bytevector)[i] =\n+          compare8_fn(rows_left, rows_right, i * unroll, irow_left, offset_right);\n+\n+      if (!use_selection) {\n+        irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(8));\n+      }\n+    }\n+    return num_rows_to_compare - (num_rows_to_compare % unroll);\n   }\n+}\n \n-  uint32_t num_rows_processed = num_rows;\n-  return num_rows_processed;\n+template <bool use_selection>\n+uint32_t KeyCompare::CompareBinaryColumnToRowImp_avx2(\n+    uint32_t offset_within_row, uint32_t num_rows_to_compare,\n+    const uint16_t* sel_left_maybe_null, const uint32_t* left_to_right_map,\n+    KeyEncoder::KeyEncoderContext* ctx, const KeyEncoder::KeyColumnArray& col,\n+    const KeyEncoder::KeyRowArray& rows, uint8_t* match_bytevector) {\n+  uint32_t col_width = col.metadata().fixed_length;\n+  if (col_width == 0) {\n+    int bit_offset = col.bit_offset(1);\n+    return CompareBinaryColumnToRowHelper_avx2<use_selection>(\n+        offset_within_row, num_rows_to_compare, sel_left_maybe_null, left_to_right_map,\n+        ctx, col, rows, match_bytevector,\n+        [bit_offset](const uint8_t* left_base, const uint8_t* right_base,\n+                     uint32_t irow_left_base, __m256i irow_left, __m256i offset_right) {\n+          __m256i left;\n+          if (use_selection) {\n+            irow_left = _mm256_add_epi32(irow_left, _mm256_set1_epi32(bit_offset));\n+            left = _mm256_i32gather_epi32((const int*)left_base,\n+                                          _mm256_srli_epi32(irow_left, 3), 1);\n+            left = _mm256_and_si256(\n+                _mm256_set1_epi32(1),\n+                _mm256_srlv_epi32(left,\n+                                  _mm256_and_si256(irow_left, _mm256_set1_epi32(7))));\n+            left = _mm256_mullo_epi32(left, _mm256_set1_epi32(0xff));\n+          } else {\n+            __m256i bits = _mm256_setr_epi32(1, 2, 4, 8, 16, 32, 64, 128);\n+            uint32_t start_bit_index = irow_left_base + bit_offset;\n+            uint8_t left_bits_8 =\n+                (reinterpret_cast<const uint16_t*>(left_base + start_bit_index / 8)[0] >>\n+                 (start_bit_index % 8)) &\n+                0xff;\n+            left = _mm256_cmpeq_epi32(\n+                _mm256_and_si256(bits, _mm256_set1_epi8(left_bits_8)), bits);\n+            left = _mm256_and_si256(left, _mm256_set1_epi32(0xff));\n+          }\n+          __m256i right = _mm256_i32gather_epi32((const int*)right_base, offset_right, 1);\n+          right = _mm256_and_si256(right, _mm256_set1_epi32(0xff));\n+          __m256i cmp = _mm256_cmpeq_epi32(left, right);\n+          uint32_t result_lo =\n+              _mm256_movemask_epi8(_mm256_cvtepi32_epi64(_mm256_castsi256_si128(cmp)));\n+          uint32_t result_hi = _mm256_movemask_epi8(\n+              _mm256_cvtepi32_epi64(_mm256_extracti128_si256(cmp, 1)));\n+          return result_lo | (static_cast<uint64_t>(result_hi) << 32);\n+        });\n+  } else if (col_width == 1) {\n\nReview comment:\n       That's an improvement, thanks!\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-18T18:04:56.531+0000",
                    "updated": "2021-08-18T18:04:56.531+0000",
                    "started": "2021-08-18T18:04:56.531+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "639545",
                    "issueId": "13377672"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377672/worklog/643614",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz closed pull request #10290:\nURL: https://github.com/apache/arrow/pull/10290\n\n\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-30T17:43:09.297+0000",
                    "updated": "2021-08-30T17:43:09.297+0000",
                    "started": "2021-08-30T17:43:09.297+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "643614",
                    "issueId": "13377672"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377672/worklog/644169",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz closed pull request #10290:\nURL: https://github.com/apache/arrow/pull/10290\n\n\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-31T14:55:10.697+0000",
                    "updated": "2021-08-31T14:55:10.697+0000",
                    "started": "2021-08-31T14:55:10.697+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "644169",
                    "issueId": "13377672"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 7200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@3513845b[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@e8cb855[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@dbdd27d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@66188d8f[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1b4c004a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@123fa206[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@71f2a406[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@53a42b42[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@28113f2c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@475197ba[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2367c9c2[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@51eb08d7[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 7200,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Aug 30 17:42:59 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-08-30T17:42:59.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12725/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2021-05-10T18:03:17.000+0000",
        "updated": "2021-08-31T14:55:11.000+0000",
        "timeoriginalestimate": null,
        "description": "Previous implementation of hash group by converts input ExecBatches to row-oriented format,\r\nthen hashes and compares rows as if they were a single column.\u00a0\r\nIt is more efficient (especially for small number of key columns) to avoid relatively costly\u00a0\r\nencoding and instead compute hashes of individual columns in column-oriented format mixing them together, and similarly comparing column-oriented data to row-oriented data in the hash table without converting.\u00a0\r\nEncoding only happens for a subset of input rows that are inserted into the hash table - they introduce new groups.\u00a0\r\nKeys in hash table remain stored as row-oriented.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 7200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Compute] GroupBy: improve performance by encoding keys in row format only when they are inserted into hash table",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377672/comment/17406873",
                    "id": "17406873",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 10290\n[https://github.com/apache/arrow/pull/10290]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-08-30T17:42:59.775+0000",
                    "updated": "2021-08-30T17:42:59.775+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0qweg:",
        "customfield_12314139": null
    }
}