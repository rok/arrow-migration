{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13355336",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13355336",
    "key": "ARROW-11425",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349493",
                "id": "12349493",
                "description": "",
                "name": "4.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-04-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=yibocai",
            "name": "yibocai",
            "key": "yibo",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=yibo&avatarId=47542",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=yibo&avatarId=47542",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=yibo&avatarId=47542",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=yibo&avatarId=47542"
            },
            "displayName": "Yibo Cai",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=yibocai",
            "name": "yibocai",
            "key": "yibo",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=yibo&avatarId=47542",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=yibo&avatarId=47542",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=yibo&avatarId=47542",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=yibo&avatarId=47542"
            },
            "displayName": "Yibo Cai",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=yibocai",
            "name": "yibocai",
            "key": "yibo",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=yibo&avatarId=47542",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=yibo&avatarId=47542",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=yibo&avatarId=47542",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=yibo&avatarId=47542"
            },
            "displayName": "Yibo Cai",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 6000,
            "total": 6000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 6000,
            "total": 6000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11425/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 10,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13355336/worklog/544069",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 opened a new pull request #9358:\nURL: https://github.com/apache/arrow/pull/9358\n\n\n   For integers within limited value range, a histogram approach is useful\r\n   to reduce memory footprint and improve performance.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-29T07:02:22.730+0000",
                    "updated": "2021-01-29T07:02:22.730+0000",
                    "started": "2021-01-29T07:02:22.730+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "544069",
                    "issueId": "13355336"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13355336/worklog/544070",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #9358:\nURL: https://github.com/apache/arrow/pull/9358#issuecomment-769620749\n\n\n   https://issues.apache.org/jira/browse/ARROW-11425\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-29T07:02:46.562+0000",
                    "updated": "2021-01-29T07:02:46.562+0000",
                    "started": "2021-01-29T07:02:46.561+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "544070",
                    "issueId": "13355336"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13355336/worklog/544072",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on pull request #9358:\nURL: https://github.com/apache/arrow/pull/9358#issuecomment-769622477\n\n\n   Tested on Xeon Gold 5218, clang-9.\r\n   Up to 2x improvements for integers with limited value range, minor drop for 50% nulls.\r\n   \r\n   Before\r\n   ```\r\n   QuantileKernelInt32/1048576/10000        2058 us         2058 us          340 bytes_per_second=485.836M/s null_percent=0.01 size=1048.58k\r\n   QuantileKernelInt32/1048576/100          1279 us         1279 us          551 bytes_per_second=781.752M/s null_percent=1 size=1048.58k\r\n   QuantileKernelInt32/1048576/10           1719 us         1719 us          408 bytes_per_second=581.835M/s null_percent=10 size=1048.58k\r\n   QuantileKernelInt32/1048576/2            1631 us         1631 us          429 bytes_per_second=613.259M/s null_percent=50 size=1048.58k\r\n   QuantileKernelInt32/1048576/1           0.601 us        0.601 us      1164926 bytes_per_second=1.58694T/s null_percent=100 size=1048.58k\r\n   QuantileKernelInt32/1048576/0            1864 us         1864 us          376 bytes_per_second=536.431M/s null_percent=0 size=1048.58k\r\n   \r\n   QuantileKernelInt64/1048576/10000         944 us          944 us          741 bytes_per_second=1059.49M/s null_percent=0.01 size=1048.58k\r\n   QuantileKernelInt64/1048576/100          1189 us         1189 us          594 bytes_per_second=840.822M/s null_percent=1 size=1048.58k\r\n   QuantileKernelInt64/1048576/10            889 us          889 us          786 bytes_per_second=1124.47M/s null_percent=10 size=1048.58k\r\n   QuantileKernelInt64/1048576/2             812 us          812 us          863 bytes_per_second=1.20332G/s null_percent=50 size=1048.58k\r\n   QuantileKernelInt64/1048576/1           0.601 us        0.601 us      1162030 bytes_per_second=1.58732T/s null_percent=100 size=1048.58k\r\n   QuantileKernelInt64/1048576/0             935 us          935 us          749 bytes_per_second=1069.31M/s null_percent=0 size=1048.58k\r\n   \r\n   QuantileKernelDouble/1048576/10000       1116 us         1116 us          629 bytes_per_second=895.788M/s null_percent=0.01 size=1048.58k\r\n   QuantileKernelDouble/1048576/100         1222 us         1222 us          573 bytes_per_second=818.343M/s null_percent=1 size=1048.58k\r\n   QuantileKernelDouble/1048576/10           902 us          902 us          775 bytes_per_second=1108.27M/s null_percent=10 size=1048.58k\r\n   QuantileKernelDouble/1048576/2            878 us          878 us          797 bytes_per_second=1.1117G/s null_percent=50 size=1048.58k\r\n   QuantileKernelDouble/1048576/1          0.617 us        0.617 us      1134788 bytes_per_second=1.54598T/s null_percent=100 size=1048.58k\r\n   QuantileKernelDouble/1048576/0           1214 us         1214 us          577 bytes_per_second=823.777M/s null_percent=0 size=1048.58k\r\n   \r\n   ```\r\n   \r\n   After\r\n   ```\r\n   QuantileKernelInt32/1048576/10000         641 us          641 us         1091 bytes_per_second=1.52317G/s null_percent=0.01 size=1048.58k\r\n   QuantileKernelInt32/1048576/100           745 us          745 us          935 bytes_per_second=1.31037G/s null_percent=1 size=1048.58k\r\n   QuantileKernelInt32/1048576/10           1277 us         1277 us          549 bytes_per_second=783.305M/s null_percent=10 size=1048.58k\r\n   QuantileKernelInt32/1048576/2            1856 us         1856 us          377 bytes_per_second=538.889M/s null_percent=50 size=1048.58k\r\n   QuantileKernelInt32/1048576/1           0.627 us        0.627 us      1074304 bytes_per_second=1.52125T/s null_percent=100 size=1048.58k\r\n   QuantileKernelInt32/1048576/0             632 us          632 us         1109 bytes_per_second=1.54554G/s null_percent=0 size=1048.58k\r\n   \r\n   QuantileKernelInt64/1048576/10000         370 us          370 us         1888 bytes_per_second=2.6384G/s null_percent=0.01 size=1048.58k\r\n   QuantileKernelInt64/1048576/100           414 us          414 us         1681 bytes_per_second=2.36152G/s null_percent=1 size=1048.58k\r\n   QuantileKernelInt64/1048576/10            686 us          686 us         1021 bytes_per_second=1.42442G/s null_percent=10 size=1048.58k\r\n   QuantileKernelInt64/1048576/2             906 us          906 us          774 bytes_per_second=1104.26M/s null_percent=50 size=1048.58k\r\n   QuantileKernelInt64/1048576/1           0.607 us        0.607 us      1155137 bytes_per_second=1.57133T/s null_percent=100 size=1048.58k\r\n   QuantileKernelInt64/1048576/0             364 us          364 us         1920 bytes_per_second=2.6835G/s null_percent=0 size=1048.58k\r\n   \r\n   QuantileKernelDouble/1048576/10000       1115 us         1115 us          629 bytes_per_second=897.137M/s null_percent=0.01 size=1048.58k\r\n   QuantileKernelDouble/1048576/100         1244 us         1244 us          564 bytes_per_second=804.11M/s null_percent=1 size=1048.58k\r\n   QuantileKernelDouble/1048576/10           914 us          914 us          767 bytes_per_second=1093.93M/s null_percent=10 size=1048.58k\r\n   QuantileKernelDouble/1048576/2            900 us          900 us          778 bytes_per_second=1111.09M/s null_percent=50 size=1048.58k\r\n   QuantileKernelDouble/1048576/1          0.618 us        0.618 us      1079708 bytes_per_second=1.54343T/s null_percent=100 size=1048.58k\r\n   QuantileKernelDouble/1048576/0           1221 us         1221 us          573 bytes_per_second=819.062M/s null_percent=0 size=1048.58k\r\n   ```\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-29T07:06:40.207+0000",
                    "updated": "2021-01-29T07:06:40.207+0000",
                    "started": "2021-01-29T07:06:40.206+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "544072",
                    "issueId": "13355336"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13355336/worklog/544161",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on pull request #9358:\nURL: https://github.com/apache/arrow/pull/9358#issuecomment-769693358\n\n\n   MinGW64 CI error is unrelated.\r\n   Travis CI passed in my personal repo https://travis-ci.org/github/cyb70289/arrow/builds/756695234\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-29T09:36:50.472+0000",
                    "updated": "2021-01-29T09:36:50.472+0000",
                    "started": "2021-01-29T09:36:50.472+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "544161",
                    "issueId": "13355336"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13355336/worklog/545390",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #9358:\nURL: https://github.com/apache/arrow/pull/9358#discussion_r567881299\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_quantile.cc\n##########\n@@ -239,6 +229,243 @@ struct QuantileExecutor {\n   }\n };\n \n+// histogram approach with constant memory, only for integers within limited value range\n+template <typename InType>\n+struct CountQuantiler {\n+  using CType = typename InType::c_type;\n+\n+  CType min;\n+  std::vector<uint64_t> counts;  // counts[i]: # of values equals i + min\n+\n+  // indices to adjacent non-empty bins covering current quantile\n+  struct AdjacentBins {\n+    int left_index;\n+    int right_index;\n+    uint64_t total_count;  // accumulated counts till left_index (inclusive)\n+  };\n+\n+  CountQuantiler(CType min, CType max) {\n+    uint32_t value_range = static_cast<uint32_t>(max - min) + 1;\n+    DCHECK_LT(value_range, 1 << 30);\n+    this->min = min;\n+    this->counts.resize(value_range);\n+  }\n+\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const QuantileOptions& options = QuantileState::Get(ctx);\n+\n+    // count values in all chunks, ignore nulls\n+    const Datum& datum = batch[0];\n+    const int64_t in_length = datum.length() - datum.null_count();\n+    if (in_length > 0) {\n+      for (auto& c : this->counts) c = 0;\n+      for (const auto& array : datum.chunks()) {\n+        const ArrayData& data = *array->data();\n+        const CType* values = data.GetValues<CType>(1);\n+        VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n+                            [&](int64_t pos, int64_t len) {\n+                              for (int64_t i = 0; i < len; ++i) {\n+                                ++this->counts[values[pos + i] - this->min];\n+                              }\n+                            });\n+      }\n+    }\n+\n+    // prepare out array\n+    int64_t out_length = options.q.size();\n+    if (in_length == 0) {\n+      out_length = 0;  // input is empty or only contains null, return empty array\n+    }\n+    // out type depends on options\n+    const bool is_datapoint = IsDataPoint(options);\n+    const std::shared_ptr<DataType> out_type =\n+        is_datapoint ? TypeTraits<InType>::type_singleton() : float64();\n+    auto out_data = ArrayData::Make(out_type, out_length, 0);\n+    out_data->buffers.resize(2, nullptr);\n+\n+    // calculate quantiles\n+    if (out_length > 0) {\n+      const auto out_bit_width = checked_pointer_cast<NumberType>(out_type)->bit_width();\n+      KERNEL_ASSIGN_OR_RAISE(out_data->buffers[1], ctx,\n+                             ctx->Allocate(out_length * out_bit_width / 8));\n+\n+      // find quantiles in ascending order\n+      std::vector<int64_t> q_indices(out_length);\n+      std::iota(q_indices.begin(), q_indices.end(), 0);\n+      std::sort(q_indices.begin(), q_indices.end(),\n+                [&options](int64_t left_index, int64_t right_index) {\n+                  return options.q[left_index] < options.q[right_index];\n+                });\n+\n+      AdjacentBins bins{0, 0, this->counts[0]};\n+      if (is_datapoint) {\n+        CType* out_buffer = out_data->template GetMutableValues<CType>(1);\n+        for (int64_t i = 0; i < out_length; ++i) {\n+          const int64_t q_index = q_indices[i];\n+          out_buffer[q_index] = GetQuantileAtDataPoint(\n+              in_length, &bins, options.q[q_index], options.interpolation);\n+        }\n+      } else {\n+        double* out_buffer = out_data->template GetMutableValues<double>(1);\n+        for (int64_t i = 0; i < out_length; ++i) {\n+          const int64_t q_index = q_indices[i];\n+          out_buffer[q_index] = GetQuantileByInterp(in_length, &bins, options.q[q_index],\n+                                                    options.interpolation);\n+        }\n+      }\n+    }\n+\n+    *out = Datum(std::move(out_data));\n+  }\n+\n+  // return quantile located exactly at some input data point\n+  CType GetQuantileAtDataPoint(int64_t in_length, AdjacentBins* bins, double q,\n+                               enum QuantileOptions::Interpolation interpolation) {\n+    const uint64_t datapoint_index = QuantileToDataPoint(in_length, q, interpolation);\n+    while (datapoint_index >= bins->total_count &&\n+           static_cast<size_t>(bins->left_index) < this->counts.size() - 1) {\n+      ++bins->left_index;\n+      bins->total_count += this->counts[bins->left_index];\n+    }\n+    DCHECK_LT(datapoint_index, bins->total_count);\n+    return static_cast<CType>(bins->left_index + this->min);\n+  }\n+\n+  // return quantile interpolated from adjacent input data points\n+  double GetQuantileByInterp(int64_t in_length, AdjacentBins* bins, double q,\n+                             enum QuantileOptions::Interpolation interpolation) {\n+    const double index = (in_length - 1) * q;\n+    const uint64_t index_floor = static_cast<uint64_t>(index);\n+    const double fraction = index - index_floor;\n+\n+    while (index_floor >= bins->total_count &&\n+           static_cast<size_t>(bins->left_index) < this->counts.size() - 1) {\n+      ++bins->left_index;\n+      bins->total_count += this->counts[bins->left_index];\n+    }\n+    DCHECK_LT(index_floor, bins->total_count);\n+    const double lower_value = static_cast<double>(bins->left_index + this->min);\n+\n+    // quantile lies in this bin, no interpolation needed\n+    if (index <= bins->total_count - 1) {\n+      return lower_value;\n+    }\n+\n+    // quantile lies across two bins, locate next bin if not already done\n+    DCHECK_EQ(index_floor, bins->total_count - 1);\n+    if (bins->right_index <= bins->left_index) {\n+      bins->right_index = bins->left_index + 1;\n+      while (static_cast<size_t>(bins->right_index) < this->counts.size() - 1 &&\n+             this->counts[bins->right_index] == 0) {\n+        ++bins->right_index;\n+      }\n+    }\n+    DCHECK_LT(static_cast<size_t>(bins->right_index), this->counts.size());\n+    DCHECK_GT(this->counts[bins->right_index], 0);\n+    const double higher_value = static_cast<double>(bins->right_index + this->min);\n+\n+    if (interpolation == QuantileOptions::LINEAR) {\n+      return fraction * higher_value + (1 - fraction) * lower_value;\n+    } else if (interpolation == QuantileOptions::MIDPOINT) {\n+      return lower_value / 2 + higher_value / 2;\n+    } else {\n+      DCHECK(false);\n+      return NAN;\n+    }\n+  }\n+};\n+\n+// histogram or sort approach per value range and size, only for integers\n+template <typename InType>\n+struct CountOrSortQuantiler {\n+  using CType = typename InType::c_type;\n+\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // cross point to benefit from histogram approach\n+    // parameters estimated from ad-hoc benchmarks manually\n+    static constexpr int kMinArraySize = 65536 * sizeof(int) / sizeof(CType);\n\nReview comment:\n       I'm not sure why the heuristic would be related to `sizeof(CType)`?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_quantile.cc\n##########\n@@ -239,6 +229,243 @@ struct QuantileExecutor {\n   }\n };\n \n+// histogram approach with constant memory, only for integers within limited value range\n+template <typename InType>\n+struct CountQuantiler {\n+  using CType = typename InType::c_type;\n+\n+  CType min;\n+  std::vector<uint64_t> counts;  // counts[i]: # of values equals i + min\n+\n+  // indices to adjacent non-empty bins covering current quantile\n+  struct AdjacentBins {\n+    int left_index;\n+    int right_index;\n+    uint64_t total_count;  // accumulated counts till left_index (inclusive)\n+  };\n+\n+  CountQuantiler(CType min, CType max) {\n+    uint32_t value_range = static_cast<uint32_t>(max - min) + 1;\n+    DCHECK_LT(value_range, 1 << 30);\n+    this->min = min;\n+    this->counts.resize(value_range);\n+  }\n+\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const QuantileOptions& options = QuantileState::Get(ctx);\n+\n+    // count values in all chunks, ignore nulls\n+    const Datum& datum = batch[0];\n+    const int64_t in_length = datum.length() - datum.null_count();\n+    if (in_length > 0) {\n+      for (auto& c : this->counts) c = 0;\n+      for (const auto& array : datum.chunks()) {\n+        const ArrayData& data = *array->data();\n+        const CType* values = data.GetValues<CType>(1);\n+        VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n+                            [&](int64_t pos, int64_t len) {\n+                              for (int64_t i = 0; i < len; ++i) {\n+                                ++this->counts[values[pos + i] - this->min];\n+                              }\n+                            });\n+      }\n+    }\n+\n+    // prepare out array\n+    int64_t out_length = options.q.size();\n+    if (in_length == 0) {\n+      out_length = 0;  // input is empty or only contains null, return empty array\n+    }\n+    // out type depends on options\n+    const bool is_datapoint = IsDataPoint(options);\n+    const std::shared_ptr<DataType> out_type =\n+        is_datapoint ? TypeTraits<InType>::type_singleton() : float64();\n+    auto out_data = ArrayData::Make(out_type, out_length, 0);\n+    out_data->buffers.resize(2, nullptr);\n+\n+    // calculate quantiles\n+    if (out_length > 0) {\n+      const auto out_bit_width = checked_pointer_cast<NumberType>(out_type)->bit_width();\n+      KERNEL_ASSIGN_OR_RAISE(out_data->buffers[1], ctx,\n+                             ctx->Allocate(out_length * out_bit_width / 8));\n+\n+      // find quantiles in ascending order\n+      std::vector<int64_t> q_indices(out_length);\n+      std::iota(q_indices.begin(), q_indices.end(), 0);\n+      std::sort(q_indices.begin(), q_indices.end(),\n+                [&options](int64_t left_index, int64_t right_index) {\n+                  return options.q[left_index] < options.q[right_index];\n+                });\n+\n+      AdjacentBins bins{0, 0, this->counts[0]};\n+      if (is_datapoint) {\n+        CType* out_buffer = out_data->template GetMutableValues<CType>(1);\n+        for (int64_t i = 0; i < out_length; ++i) {\n+          const int64_t q_index = q_indices[i];\n+          out_buffer[q_index] = GetQuantileAtDataPoint(\n+              in_length, &bins, options.q[q_index], options.interpolation);\n+        }\n+      } else {\n+        double* out_buffer = out_data->template GetMutableValues<double>(1);\n+        for (int64_t i = 0; i < out_length; ++i) {\n+          const int64_t q_index = q_indices[i];\n+          out_buffer[q_index] = GetQuantileByInterp(in_length, &bins, options.q[q_index],\n+                                                    options.interpolation);\n+        }\n+      }\n+    }\n+\n+    *out = Datum(std::move(out_data));\n+  }\n+\n+  // return quantile located exactly at some input data point\n+  CType GetQuantileAtDataPoint(int64_t in_length, AdjacentBins* bins, double q,\n+                               enum QuantileOptions::Interpolation interpolation) {\n+    const uint64_t datapoint_index = QuantileToDataPoint(in_length, q, interpolation);\n+    while (datapoint_index >= bins->total_count &&\n+           static_cast<size_t>(bins->left_index) < this->counts.size() - 1) {\n+      ++bins->left_index;\n+      bins->total_count += this->counts[bins->left_index];\n+    }\n+    DCHECK_LT(datapoint_index, bins->total_count);\n+    return static_cast<CType>(bins->left_index + this->min);\n+  }\n+\n+  // return quantile interpolated from adjacent input data points\n+  double GetQuantileByInterp(int64_t in_length, AdjacentBins* bins, double q,\n+                             enum QuantileOptions::Interpolation interpolation) {\n+    const double index = (in_length - 1) * q;\n+    const uint64_t index_floor = static_cast<uint64_t>(index);\n+    const double fraction = index - index_floor;\n+\n+    while (index_floor >= bins->total_count &&\n+           static_cast<size_t>(bins->left_index) < this->counts.size() - 1) {\n+      ++bins->left_index;\n+      bins->total_count += this->counts[bins->left_index];\n+    }\n+    DCHECK_LT(index_floor, bins->total_count);\n+    const double lower_value = static_cast<double>(bins->left_index + this->min);\n+\n+    // quantile lies in this bin, no interpolation needed\n+    if (index <= bins->total_count - 1) {\n+      return lower_value;\n+    }\n+\n+    // quantile lies across two bins, locate next bin if not already done\n+    DCHECK_EQ(index_floor, bins->total_count - 1);\n+    if (bins->right_index <= bins->left_index) {\n+      bins->right_index = bins->left_index + 1;\n+      while (static_cast<size_t>(bins->right_index) < this->counts.size() - 1 &&\n+             this->counts[bins->right_index] == 0) {\n+        ++bins->right_index;\n+      }\n+    }\n+    DCHECK_LT(static_cast<size_t>(bins->right_index), this->counts.size());\n+    DCHECK_GT(this->counts[bins->right_index], 0);\n+    const double higher_value = static_cast<double>(bins->right_index + this->min);\n+\n+    if (interpolation == QuantileOptions::LINEAR) {\n+      return fraction * higher_value + (1 - fraction) * lower_value;\n+    } else if (interpolation == QuantileOptions::MIDPOINT) {\n+      return lower_value / 2 + higher_value / 2;\n+    } else {\n+      DCHECK(false);\n+      return NAN;\n+    }\n+  }\n+};\n+\n+// histogram or sort approach per value range and size, only for integers\n+template <typename InType>\n+struct CountOrSortQuantiler {\n+  using CType = typename InType::c_type;\n+\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // cross point to benefit from histogram approach\n+    // parameters estimated from ad-hoc benchmarks manually\n+    static constexpr int kMinArraySize = 65536 * sizeof(int) / sizeof(CType);\n+    static constexpr int kMaxValueRange = 65536;\n+\n+    const Datum& datum = batch[0];\n+    if (datum.length() - datum.null_count() >= kMinArraySize) {\n\nReview comment:\n       Note that for int16/uint16, the max value range should always be satisfied.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-01T15:12:40.444+0000",
                    "updated": "2021-02-01T15:12:40.444+0000",
                    "started": "2021-02-01T15:12:40.443+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "545390",
                    "issueId": "13355336"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13355336/worklog/546873",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #9358:\nURL: https://github.com/apache/arrow/pull/9358#discussion_r569153961\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_quantile.cc\n##########\n@@ -239,6 +229,243 @@ struct QuantileExecutor {\n   }\n };\n \n+// histogram approach with constant memory, only for integers within limited value range\n+template <typename InType>\n+struct CountQuantiler {\n+  using CType = typename InType::c_type;\n+\n+  CType min;\n+  std::vector<uint64_t> counts;  // counts[i]: # of values equals i + min\n+\n+  // indices to adjacent non-empty bins covering current quantile\n+  struct AdjacentBins {\n+    int left_index;\n+    int right_index;\n+    uint64_t total_count;  // accumulated counts till left_index (inclusive)\n+  };\n+\n+  CountQuantiler(CType min, CType max) {\n+    uint32_t value_range = static_cast<uint32_t>(max - min) + 1;\n+    DCHECK_LT(value_range, 1 << 30);\n+    this->min = min;\n+    this->counts.resize(value_range);\n+  }\n+\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const QuantileOptions& options = QuantileState::Get(ctx);\n+\n+    // count values in all chunks, ignore nulls\n+    const Datum& datum = batch[0];\n+    const int64_t in_length = datum.length() - datum.null_count();\n+    if (in_length > 0) {\n+      for (auto& c : this->counts) c = 0;\n+      for (const auto& array : datum.chunks()) {\n+        const ArrayData& data = *array->data();\n+        const CType* values = data.GetValues<CType>(1);\n+        VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n+                            [&](int64_t pos, int64_t len) {\n+                              for (int64_t i = 0; i < len; ++i) {\n+                                ++this->counts[values[pos + i] - this->min];\n+                              }\n+                            });\n+      }\n+    }\n+\n+    // prepare out array\n+    int64_t out_length = options.q.size();\n+    if (in_length == 0) {\n+      out_length = 0;  // input is empty or only contains null, return empty array\n+    }\n+    // out type depends on options\n+    const bool is_datapoint = IsDataPoint(options);\n+    const std::shared_ptr<DataType> out_type =\n+        is_datapoint ? TypeTraits<InType>::type_singleton() : float64();\n+    auto out_data = ArrayData::Make(out_type, out_length, 0);\n+    out_data->buffers.resize(2, nullptr);\n+\n+    // calculate quantiles\n+    if (out_length > 0) {\n+      const auto out_bit_width = checked_pointer_cast<NumberType>(out_type)->bit_width();\n+      KERNEL_ASSIGN_OR_RAISE(out_data->buffers[1], ctx,\n+                             ctx->Allocate(out_length * out_bit_width / 8));\n+\n+      // find quantiles in ascending order\n+      std::vector<int64_t> q_indices(out_length);\n+      std::iota(q_indices.begin(), q_indices.end(), 0);\n+      std::sort(q_indices.begin(), q_indices.end(),\n+                [&options](int64_t left_index, int64_t right_index) {\n+                  return options.q[left_index] < options.q[right_index];\n+                });\n+\n+      AdjacentBins bins{0, 0, this->counts[0]};\n+      if (is_datapoint) {\n+        CType* out_buffer = out_data->template GetMutableValues<CType>(1);\n+        for (int64_t i = 0; i < out_length; ++i) {\n+          const int64_t q_index = q_indices[i];\n+          out_buffer[q_index] = GetQuantileAtDataPoint(\n+              in_length, &bins, options.q[q_index], options.interpolation);\n+        }\n+      } else {\n+        double* out_buffer = out_data->template GetMutableValues<double>(1);\n+        for (int64_t i = 0; i < out_length; ++i) {\n+          const int64_t q_index = q_indices[i];\n+          out_buffer[q_index] = GetQuantileByInterp(in_length, &bins, options.q[q_index],\n+                                                    options.interpolation);\n+        }\n+      }\n+    }\n+\n+    *out = Datum(std::move(out_data));\n+  }\n+\n+  // return quantile located exactly at some input data point\n+  CType GetQuantileAtDataPoint(int64_t in_length, AdjacentBins* bins, double q,\n+                               enum QuantileOptions::Interpolation interpolation) {\n+    const uint64_t datapoint_index = QuantileToDataPoint(in_length, q, interpolation);\n+    while (datapoint_index >= bins->total_count &&\n+           static_cast<size_t>(bins->left_index) < this->counts.size() - 1) {\n+      ++bins->left_index;\n+      bins->total_count += this->counts[bins->left_index];\n+    }\n+    DCHECK_LT(datapoint_index, bins->total_count);\n+    return static_cast<CType>(bins->left_index + this->min);\n+  }\n+\n+  // return quantile interpolated from adjacent input data points\n+  double GetQuantileByInterp(int64_t in_length, AdjacentBins* bins, double q,\n+                             enum QuantileOptions::Interpolation interpolation) {\n+    const double index = (in_length - 1) * q;\n+    const uint64_t index_floor = static_cast<uint64_t>(index);\n+    const double fraction = index - index_floor;\n+\n+    while (index_floor >= bins->total_count &&\n+           static_cast<size_t>(bins->left_index) < this->counts.size() - 1) {\n+      ++bins->left_index;\n+      bins->total_count += this->counts[bins->left_index];\n+    }\n+    DCHECK_LT(index_floor, bins->total_count);\n+    const double lower_value = static_cast<double>(bins->left_index + this->min);\n+\n+    // quantile lies in this bin, no interpolation needed\n+    if (index <= bins->total_count - 1) {\n+      return lower_value;\n+    }\n+\n+    // quantile lies across two bins, locate next bin if not already done\n+    DCHECK_EQ(index_floor, bins->total_count - 1);\n+    if (bins->right_index <= bins->left_index) {\n+      bins->right_index = bins->left_index + 1;\n+      while (static_cast<size_t>(bins->right_index) < this->counts.size() - 1 &&\n+             this->counts[bins->right_index] == 0) {\n+        ++bins->right_index;\n+      }\n+    }\n+    DCHECK_LT(static_cast<size_t>(bins->right_index), this->counts.size());\n+    DCHECK_GT(this->counts[bins->right_index], 0);\n+    const double higher_value = static_cast<double>(bins->right_index + this->min);\n+\n+    if (interpolation == QuantileOptions::LINEAR) {\n+      return fraction * higher_value + (1 - fraction) * lower_value;\n+    } else if (interpolation == QuantileOptions::MIDPOINT) {\n+      return lower_value / 2 + higher_value / 2;\n+    } else {\n+      DCHECK(false);\n+      return NAN;\n+    }\n+  }\n+};\n+\n+// histogram or sort approach per value range and size, only for integers\n+template <typename InType>\n+struct CountOrSortQuantiler {\n+  using CType = typename InType::c_type;\n+\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // cross point to benefit from histogram approach\n+    // parameters estimated from ad-hoc benchmarks manually\n+    static constexpr int kMinArraySize = 65536 * sizeof(int) / sizeof(CType);\n\nReview comment:\n       Thanks for pointing this out. I confused memory size and item count. It should be 64K items, regardless of CType.\r\n   Benchmark result at https://docs.google.com/spreadsheets/d/1AmFrdLCIEaC4MaGXUDL5nJPmFuEvjDvsTqV0rDwn4GQ/edit?usp=sharing\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-03T06:09:10.612+0000",
                    "updated": "2021-02-03T06:09:10.612+0000",
                    "started": "2021-02-03T06:09:10.612+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "546873",
                    "issueId": "13355336"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13355336/worklog/546895",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #9358:\nURL: https://github.com/apache/arrow/pull/9358#discussion_r569193045\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_quantile.cc\n##########\n@@ -239,6 +229,243 @@ struct QuantileExecutor {\n   }\n };\n \n+// histogram approach with constant memory, only for integers within limited value range\n+template <typename InType>\n+struct CountQuantiler {\n+  using CType = typename InType::c_type;\n+\n+  CType min;\n+  std::vector<uint64_t> counts;  // counts[i]: # of values equals i + min\n+\n+  // indices to adjacent non-empty bins covering current quantile\n+  struct AdjacentBins {\n+    int left_index;\n+    int right_index;\n+    uint64_t total_count;  // accumulated counts till left_index (inclusive)\n+  };\n+\n+  CountQuantiler(CType min, CType max) {\n+    uint32_t value_range = static_cast<uint32_t>(max - min) + 1;\n+    DCHECK_LT(value_range, 1 << 30);\n+    this->min = min;\n+    this->counts.resize(value_range);\n+  }\n+\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const QuantileOptions& options = QuantileState::Get(ctx);\n+\n+    // count values in all chunks, ignore nulls\n+    const Datum& datum = batch[0];\n+    const int64_t in_length = datum.length() - datum.null_count();\n+    if (in_length > 0) {\n+      for (auto& c : this->counts) c = 0;\n+      for (const auto& array : datum.chunks()) {\n+        const ArrayData& data = *array->data();\n+        const CType* values = data.GetValues<CType>(1);\n+        VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n+                            [&](int64_t pos, int64_t len) {\n+                              for (int64_t i = 0; i < len; ++i) {\n+                                ++this->counts[values[pos + i] - this->min];\n+                              }\n+                            });\n+      }\n+    }\n+\n+    // prepare out array\n+    int64_t out_length = options.q.size();\n+    if (in_length == 0) {\n+      out_length = 0;  // input is empty or only contains null, return empty array\n+    }\n+    // out type depends on options\n+    const bool is_datapoint = IsDataPoint(options);\n+    const std::shared_ptr<DataType> out_type =\n+        is_datapoint ? TypeTraits<InType>::type_singleton() : float64();\n+    auto out_data = ArrayData::Make(out_type, out_length, 0);\n+    out_data->buffers.resize(2, nullptr);\n+\n+    // calculate quantiles\n+    if (out_length > 0) {\n+      const auto out_bit_width = checked_pointer_cast<NumberType>(out_type)->bit_width();\n+      KERNEL_ASSIGN_OR_RAISE(out_data->buffers[1], ctx,\n+                             ctx->Allocate(out_length * out_bit_width / 8));\n+\n+      // find quantiles in ascending order\n+      std::vector<int64_t> q_indices(out_length);\n+      std::iota(q_indices.begin(), q_indices.end(), 0);\n+      std::sort(q_indices.begin(), q_indices.end(),\n+                [&options](int64_t left_index, int64_t right_index) {\n+                  return options.q[left_index] < options.q[right_index];\n+                });\n+\n+      AdjacentBins bins{0, 0, this->counts[0]};\n+      if (is_datapoint) {\n+        CType* out_buffer = out_data->template GetMutableValues<CType>(1);\n+        for (int64_t i = 0; i < out_length; ++i) {\n+          const int64_t q_index = q_indices[i];\n+          out_buffer[q_index] = GetQuantileAtDataPoint(\n+              in_length, &bins, options.q[q_index], options.interpolation);\n+        }\n+      } else {\n+        double* out_buffer = out_data->template GetMutableValues<double>(1);\n+        for (int64_t i = 0; i < out_length; ++i) {\n+          const int64_t q_index = q_indices[i];\n+          out_buffer[q_index] = GetQuantileByInterp(in_length, &bins, options.q[q_index],\n+                                                    options.interpolation);\n+        }\n+      }\n+    }\n+\n+    *out = Datum(std::move(out_data));\n+  }\n+\n+  // return quantile located exactly at some input data point\n+  CType GetQuantileAtDataPoint(int64_t in_length, AdjacentBins* bins, double q,\n+                               enum QuantileOptions::Interpolation interpolation) {\n+    const uint64_t datapoint_index = QuantileToDataPoint(in_length, q, interpolation);\n+    while (datapoint_index >= bins->total_count &&\n+           static_cast<size_t>(bins->left_index) < this->counts.size() - 1) {\n+      ++bins->left_index;\n+      bins->total_count += this->counts[bins->left_index];\n+    }\n+    DCHECK_LT(datapoint_index, bins->total_count);\n+    return static_cast<CType>(bins->left_index + this->min);\n+  }\n+\n+  // return quantile interpolated from adjacent input data points\n+  double GetQuantileByInterp(int64_t in_length, AdjacentBins* bins, double q,\n+                             enum QuantileOptions::Interpolation interpolation) {\n+    const double index = (in_length - 1) * q;\n+    const uint64_t index_floor = static_cast<uint64_t>(index);\n+    const double fraction = index - index_floor;\n+\n+    while (index_floor >= bins->total_count &&\n+           static_cast<size_t>(bins->left_index) < this->counts.size() - 1) {\n+      ++bins->left_index;\n+      bins->total_count += this->counts[bins->left_index];\n+    }\n+    DCHECK_LT(index_floor, bins->total_count);\n+    const double lower_value = static_cast<double>(bins->left_index + this->min);\n+\n+    // quantile lies in this bin, no interpolation needed\n+    if (index <= bins->total_count - 1) {\n+      return lower_value;\n+    }\n+\n+    // quantile lies across two bins, locate next bin if not already done\n+    DCHECK_EQ(index_floor, bins->total_count - 1);\n+    if (bins->right_index <= bins->left_index) {\n+      bins->right_index = bins->left_index + 1;\n+      while (static_cast<size_t>(bins->right_index) < this->counts.size() - 1 &&\n+             this->counts[bins->right_index] == 0) {\n+        ++bins->right_index;\n+      }\n+    }\n+    DCHECK_LT(static_cast<size_t>(bins->right_index), this->counts.size());\n+    DCHECK_GT(this->counts[bins->right_index], 0);\n+    const double higher_value = static_cast<double>(bins->right_index + this->min);\n+\n+    if (interpolation == QuantileOptions::LINEAR) {\n+      return fraction * higher_value + (1 - fraction) * lower_value;\n+    } else if (interpolation == QuantileOptions::MIDPOINT) {\n+      return lower_value / 2 + higher_value / 2;\n+    } else {\n+      DCHECK(false);\n+      return NAN;\n+    }\n+  }\n+};\n+\n+// histogram or sort approach per value range and size, only for integers\n+template <typename InType>\n+struct CountOrSortQuantiler {\n+  using CType = typename InType::c_type;\n+\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // cross point to benefit from histogram approach\n+    // parameters estimated from ad-hoc benchmarks manually\n+    static constexpr int kMinArraySize = 65536 * sizeof(int) / sizeof(CType);\n+    static constexpr int kMaxValueRange = 65536;\n+\n+    const Datum& datum = batch[0];\n+    if (datum.length() - datum.null_count() >= kMinArraySize) {\n\nReview comment:\n       Yes. It looks still desirable to find min/max as it may not cover 64k range.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-03T07:46:57.315+0000",
                    "updated": "2021-02-03T07:46:57.315+0000",
                    "started": "2021-02-03T07:46:57.315+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "546895",
                    "issueId": "13355336"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13355336/worklog/546897",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on pull request #9358:\nURL: https://github.com/apache/arrow/pull/9358#issuecomment-772311969\n\n\n   Benchmark updated to include integers with `wide` and `narrow` value range.\r\n   ```\r\n   QuantileKernelInt32Wide/1048576/10000         1566 us         1566 us          447 bytes_per_second=638.552M/s null_percent=0.01 size=1048.58k\r\n   QuantileKernelInt32Wide/1048576/100           1906 us         1906 us          367 bytes_per_second=524.742M/s null_percent=1 size=1048.58k\r\n   QuantileKernelInt32Wide/1048576/10            2714 us         2714 us          258 bytes_per_second=368.515M/s null_percent=10 size=1048.58k\r\n   QuantileKernelInt32Wide/1048576/2             2431 us         2431 us          288 bytes_per_second=411.435M/s null_percent=50 size=1048.58k\r\n   QuantileKernelInt32Wide/1048576/1            0.627 us        0.627 us      1114130 bytes_per_second=1.52029T/s null_percent=100 size=1048.58k\r\n   QuantileKernelInt32Wide/1048576/0             1864 us         1864 us          376 bytes_per_second=536.539M/s null_percent=0 size=1048.58k\r\n   QuantileKernelInt32Narrow/1048576/10000        643 us          643 us         1088 bytes_per_second=1.51936G/s null_percent=0.01 size=1048.58k\r\n   QuantileKernelInt32Narrow/1048576/100          743 us          743 us          945 bytes_per_second=1.31356G/s null_percent=1 size=1048.58k\r\n   QuantileKernelInt32Narrow/1048576/10          1258 us         1258 us          557 bytes_per_second=795.072M/s null_percent=10 size=1048.58k\r\n   QuantileKernelInt32Narrow/1048576/2           1799 us         1799 us          387 bytes_per_second=555.725M/s null_percent=50 size=1048.58k\r\n   QuantileKernelInt32Narrow/1048576/1          0.644 us        0.644 us      1097860 bytes_per_second=1.47984T/s null_percent=100 size=1048.58k\r\n   QuantileKernelInt32Narrow/1048576/0            635 us          635 us         1105 bytes_per_second=1.53909G/s null_percent=0 size=1048.58k\r\n   QuantileKernelInt64Wide/1048576/10000          680 us          680 us         1034 bytes_per_second=1.43618G/s null_percent=0.01 size=1048.58k\r\n   QuantileKernelInt64Wide/1048576/100            905 us          905 us          772 bytes_per_second=1104.74M/s null_percent=1 size=1048.58k\r\n   QuantileKernelInt64Wide/1048576/10            1392 us         1392 us          505 bytes_per_second=718.177M/s null_percent=10 size=1048.58k\r\n   QuantileKernelInt64Wide/1048576/2              892 us          892 us          782 bytes_per_second=1120.52M/s null_percent=50 size=1048.58k\r\n   QuantileKernelInt64Wide/1048576/1            0.608 us        0.608 us      1138627 bytes_per_second=1.56729T/s null_percent=100 size=1048.58k\r\n   QuantileKernelInt64Wide/1048576/0              762 us          762 us          916 bytes_per_second=1.28095G/s null_percent=0 size=1048.58k\r\n   QuantileKernelInt64Narrow/1048576/10000        372 us          372 us         1887 bytes_per_second=2.62659G/s null_percent=0.01 size=1048.58k\r\n   QuantileKernelInt64Narrow/1048576/100          416 us          416 us         1687 bytes_per_second=2.34746G/s null_percent=1 size=1048.58k\r\n   QuantileKernelInt64Narrow/1048576/10           674 us          674 us         1040 bytes_per_second=1.44975G/s null_percent=10 size=1048.58k\r\n   QuantileKernelInt64Narrow/1048576/2            869 us          869 us          807 bytes_per_second=1.12415G/s null_percent=50 size=1048.58k\r\n   QuantileKernelInt64Narrow/1048576/1          0.609 us        0.609 us      1151528 bytes_per_second=1.56662T/s null_percent=100 size=1048.58k\r\n   QuantileKernelInt64Narrow/1048576/0            368 us          368 us         1912 bytes_per_second=2.65377G/s null_percent=0 size=1048.58k\r\n   QuantileKernelDouble/1048576/10000            1134 us         1134 us          614 bytes_per_second=882.09M/s null_percent=0.01 size=1048.58k\r\n   QuantileKernelDouble/1048576/100              1241 us         1241 us          565 bytes_per_second=805.54M/s null_percent=1 size=1048.58k\r\n   QuantileKernelDouble/1048576/10                924 us          924 us          747 bytes_per_second=1082.46M/s null_percent=10 size=1048.58k\r\n   QuantileKernelDouble/1048576/2                 889 us          889 us          791 bytes_per_second=1124.79M/s null_percent=50 size=1048.58k\r\n   QuantileKernelDouble/1048576/1               0.634 us        0.634 us      1127780 bytes_per_second=1.50509T/s null_percent=100 size=1048.58k\r\n   QuantileKernelDouble/1048576/0                1229 us         1229 us          570 bytes_per_second=813.899M/s null_percent=0 size=1048.58k\r\n   ```\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-03T07:56:57.417+0000",
                    "updated": "2021-02-03T07:56:57.417+0000",
                    "started": "2021-02-03T07:56:57.417+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "546897",
                    "issueId": "13355336"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13355336/worklog/546916",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on pull request #9358:\nURL: https://github.com/apache/arrow/pull/9358#issuecomment-772353862\n\n\n   Travis CI passed: https://travis-ci.org/github/cyb70289/arrow/builds/757359819\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-03T09:10:28.434+0000",
                    "updated": "2021-02-03T09:10:28.434+0000",
                    "started": "2021-02-03T09:10:28.434+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "546916",
                    "issueId": "13355336"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13355336/worklog/547006",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou closed pull request #9358:\nURL: https://github.com/apache/arrow/pull/9358\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-03T13:29:44.209+0000",
                    "updated": "2021-02-03T13:29:44.209+0000",
                    "started": "2021-02-03T13:29:44.209+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "547006",
                    "issueId": "13355336"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 6000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@31ba5537[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1696af8c[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@238c51c7[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@4570f5[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@44de8244[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@61bff96a[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@20fc8ef3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@b1580c1[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3b69ff45[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@250325eb[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@61ccbcae[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@46f82bde[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 6000,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Feb 03 13:29:28 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-02-03T13:29:28.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11425/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2021-01-29T05:09:32.000+0000",
        "updated": "2021-02-03T13:29:45.000+0000",
        "timeoriginalestimate": null,
        "description": "For integers within limited value range, a histogram approach is useful to reduce memory footprint and improve performance.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "1h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 6000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Compute] Improve quantile kernel for integers",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13355336/comment/17277998",
                    "id": "17277998",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 9358\n[https://github.com/apache/arrow/pull/9358]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-02-03T13:29:28.194+0000",
                    "updated": "2021-02-03T13:29:28.194+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0n45c:",
        "customfield_12314139": null
    }
}